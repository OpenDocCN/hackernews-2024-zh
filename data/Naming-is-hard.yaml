- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: æœªåˆ†ç±»'
- en: 'date: 2024-05-27 14:43:06'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:43:06'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Naming is hard
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å–åå¾ˆéš¾
- en: æ¥æºï¼š[https://blog.dureuill.net/articles/too-dangerous-cpp/](https://blog.dureuill.net/articles/too-dangerous-cpp/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://blog.dureuill.net/articles/too-dangerous-cpp/](https://blog.dureuill.net/articles/too-dangerous-cpp/)
- en: Some patterns are only made practical thanks to Rust's memory safety, and too
    dangerous to use in C++. Here's a concrete example.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€äº›æ¨¡å¼ä»…å› ä¸ºRustçš„å†…å­˜å®‰å…¨è€Œå˜å¾—å®ç”¨ï¼Œå¹¶ä¸”åœ¨C++ä¸­ä½¿ç”¨ä¼šè¿‡äºå±é™©ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªå…·ä½“çš„ä¾‹å­ã€‚
- en: '* * *'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Working on an internal library written in Rust, I had an error type for a parser
    that I wanted to be [`Clone`able](https://doc.rust-lang.org/std/clone/trait.Clone.html),
    without duplicating the data inside. In Rust, this calls for a **r**eference-**c**ounted
    pointer, like [Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html).
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸€ä¸ªç”¨Rustç¼–å†™çš„å†…éƒ¨åº“ä¸Šå·¥ä½œæ—¶ï¼Œæˆ‘æœ‰ä¸€ä¸ªæˆ‘å¸Œæœ›èƒ½å¤Ÿå…‹éš†çš„è§£æå™¨é”™è¯¯ç±»å‹ï¼Œè€Œä¸å¤åˆ¶å…¶ä¸­æ•°æ®çš„éœ€æ±‚ã€‚åœ¨Rustä¸­ï¼Œè¿™éœ€è¦ä½¿ç”¨åƒ[Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html)è¿™æ ·çš„å¼•ç”¨è®¡æ•°æŒ‡é’ˆã€‚
- en: So I wrote my error type, used it as the error variant of the fallible functions,
    and moved on with my life.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘å†™äº†æˆ‘çš„é”™è¯¯ç±»å‹ï¼Œå¹¶å°†å…¶ç”¨ä½œæ˜“é”™å‡½æ•°çš„é”™è¯¯å˜ä½“ï¼Œç„¶åç»§ç»­æˆ‘çš„ç”Ÿæ´»ã€‚
- en: '[PRE0]'
  id: totrans-split-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Sometimes later, we noticed that parsing would take a long time to execute on
    some inputs, so I decided I'd send the input to another thread via a [channel](https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html),
    and I'd get the response back through another channel, so that long orders wouldn't
    block the main thread.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™åæ¥ï¼Œæˆ‘ä»¬æ³¨æ„åˆ°åœ¨æŸäº›è¾“å…¥ä¸Šè§£æéœ€è¦å¾ˆé•¿æ—¶é—´æ¥æ‰§è¡Œï¼Œæ‰€ä»¥æˆ‘å†³å®šé€šè¿‡ä¸€ä¸ª[é€šé“](https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html)å°†è¾“å…¥å‘é€åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œç„¶åé€šè¿‡å¦ä¸€ä¸ªé€šé“è·å–å“åº”ï¼Œè¿™æ ·é•¿æ—¶é—´çš„å‘½ä»¤å°±ä¸ä¼šé˜»å¡ä¸»çº¿ç¨‹ã€‚
- en: '[PRE1]'
  id: totrans-split-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, while doing this change, I was greeted with the following error message:'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œåœ¨è¿›è¡Œè¿™ç§æ›´æ”¹æ—¶ï¼Œæˆ‘é‡åˆ°äº†ä»¥ä¸‹é”™è¯¯æ¶ˆæ¯ï¼š
- en: '[PRE2]'
  id: totrans-split-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As the compiler nicely explained, it is because the [`Rc` type does not support
    being sent between threads](https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-Send-for-Rc%3CT,+A%3E),
    as doing so would cause data races. Indeed, the reference count in `Rc` is not
    manipulated in an atomic manner that would be thread safe, it is using regular
    integer operations.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ç¼–è¯‘å™¨å¾ˆå¥½åœ°è§£é‡Šçš„é‚£æ ·ï¼Œè¿™æ˜¯å› ä¸º[`Rc`ç±»å‹ä¸æ”¯æŒåœ¨çº¿ç¨‹ä¹‹é—´å‘é€](https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-Send-for-Rc%3CT,+A%3E)ï¼Œè¿™æ ·åšä¼šå¯¼è‡´æ•°æ®ç«äº‰ã€‚ç¡®å®ï¼Œ`Rc`ä¸­çš„å¼•ç”¨è®¡æ•°å¹¶ä¸æ˜¯ä»¥åŸå­æ–¹å¼å¤„ç†çš„ï¼Œè¿™æ ·ä½¿ç”¨å°±ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œè€Œæ˜¯ä½¿ç”¨å¸¸è§„æ•´æ•°æ“ä½œã€‚
- en: 'For thread-safe reference counting, Rust offers [another type called `Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html),
    that uses **a**tomic **r**eference **c**ounting. Modifying the code to use `Arc`
    is a simple matter of:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºçº¿ç¨‹å®‰å…¨çš„å¼•ç”¨è®¡æ•°ï¼ŒRustæä¾›äº†[å¦ä¸€ç§ç±»å‹ç§°ä¸º`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html)ï¼Œå®ƒä½¿ç”¨äº†**a**tomic
    **r**eference **c**ountingã€‚å°†ä»£ç ä¿®æ”¹ä¸ºä½¿ç”¨`Arc`åªæ˜¯ä¸€ä»¶ç®€å•çš„äº‹æƒ…ï¼š
- en: '[PRE3]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ([Test this code online](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b1f40129f7a6c9baf77fde13a4156889))
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆ[åœ¨çº¿æµ‹è¯•æ­¤ä»£ç ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b1f40129f7a6c9baf77fde13a4156889)ï¼‰
- en: As long as I didn't need reference counting to be atomic, I could use `Rc`.
    When I needed thread-safety, the compiler forced me to switch to `Arc` and the
    overhead of atomic reference counting. This is an illustration of the old principle
    of "don't pay for what you don't use".
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: åªè¦æˆ‘ä¸éœ€è¦å¼•ç”¨è®¡æ•°æ˜¯åŸå­çš„ï¼Œæˆ‘å°±å¯ä»¥ä½¿ç”¨`Rc`ã€‚å½“æˆ‘éœ€è¦çº¿ç¨‹å®‰å…¨æ—¶ï¼Œç¼–è¯‘å™¨å°±å¼ºåˆ¶æˆ‘åˆ‡æ¢åˆ°`Arc`å’ŒåŸå­å¼•ç”¨è®¡æ•°çš„å¼€é”€ã€‚è¿™è¯´æ˜äº†â€œä¸ä¸ºä½ ä¸éœ€è¦çš„ä¸œè¥¿ä»˜è´¹â€çš„æ—§åŸåˆ™ã€‚
- en: This principle is dear to the heart of C++ developers too, yet in stark contrast
    to Rust, C++ only has shared pointers with atomic reference counting in its standard
    library, that is the equivalent to `Arc`, not `Rc`. You always pay for the atomic
    even if you don't use it. Providing 2 classes was considered, but rejected, notably
    because [it was deemed too dangerous](https://stackoverflow.com/a/15140227/1614219)
    ("Code written with the unsynchronized `shared_ptr` may end up being used in threaded
    code down the road, ending up causing difficult to debug problems with no warning").
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªåŸåˆ™å¯¹C++å¼€å‘è€…ä¹Ÿå¾ˆé‡è¦ï¼Œä½†ä¸Rustå½¢æˆé²œæ˜å¯¹æ¯”çš„æ˜¯ï¼ŒC++æ ‡å‡†åº“ä¸­åªæœ‰å¸¦æœ‰åŸå­å¼•ç”¨è®¡æ•°çš„å…±äº«æŒ‡é’ˆï¼Œç›¸å½“äº`Arc`ï¼Œè€Œä¸æ˜¯`Rc`ã€‚å³ä½¿ä½ ä¸ä½¿ç”¨åŸå­ï¼Œä½ ä¹Ÿè¦ä¸ºå®ƒä»˜å‡ºä»£ä»·ã€‚æ›¾è€ƒè™‘æä¾›2ä¸ªç±»ï¼Œä½†è¢«æ‹’ç»äº†ï¼Œå°¤å…¶æ˜¯å› ä¸º[è¢«è®¤ä¸ºå¤ªå±é™©äº†](https://stackoverflow.com/a/15140227/1614219)ï¼ˆ"ä½¿ç”¨éåŒæ­¥çš„`shared_ptr`ç¼–å†™çš„ä»£ç å¯èƒ½æœ€ç»ˆè¢«ç”¨äºçº¿ç¨‹åŒ–ä»£ç ï¼Œå¯¼è‡´éš¾ä»¥è°ƒè¯•çš„é—®é¢˜ï¼Œä¸”æ²¡æœ‰è­¦å‘Š"ï¼‰ã€‚
- en: Because Rust will catch these at compile time, it is not dangerous.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºRustä¼šåœ¨ç¼–è¯‘æ—¶æ•æ‰è¿™äº›é—®é¢˜ï¼Œæ‰€ä»¥å¹¶ä¸å±é™©ã€‚
- en: On some C++ standard library implementations, there are attempts to recover
    the lost performance in some limited situations (e.g. the program as a whole is
    not multi-threaded), [to hilarious effect on micro-benchmarks](http://snf.github.io/2019/02/13/shared-ptr-optimization/).
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸäº› C++ æ ‡å‡†åº“å®ç°ä¸­ï¼Œæœ‰è¯•å›¾åœ¨ä¸€äº›æœ‰é™æƒ…å†µä¸‹æ¢å¤å¤±å»æ€§èƒ½çš„å°è¯•ï¼ˆä¾‹å¦‚ï¼Œæ•´ä¸ªç¨‹åºä¸æ˜¯å¤šçº¿ç¨‹çš„æƒ…å†µä¸‹ï¼‰ï¼Œ[åœ¨å¾®åŸºå‡†æµ‹è¯•ä¸­æ•ˆæœéå¸¸æ»‘ç¨½](http://snf.github.io/2019/02/13/shared-ptr-optimization/)ã€‚
- en: Unfortunately the precaution taken by C++ of always having an atomic reference
    count is still insufficient to make `shared_ptr` safe in a multi-threaded context,
    as one should pay attention to a couple of the proverbial footguns.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼ŒC++ é‡‡ç”¨å§‹ç»ˆå…·æœ‰åŸå­å¼•ç”¨è®¡æ•°çš„é¢„é˜²æªæ–½ï¼Œä»ç„¶ä¸è¶³ä»¥ä½¿ `shared_ptr` åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­å®‰å…¨ï¼Œå› ä¸ºäººä»¬åº”è¯¥æ³¨æ„ä¸€äº›æƒ¯ç”¨è¯­å¢ƒä¸­çš„æ½œåœ¨é—®é¢˜ã€‚
- en: This is a bit of a subtle issue, and honestly I don't think I ever ran into
    that one, but I include it for clarity because sometimes people mix it with the
    second one.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¾®å¦™çš„é—®é¢˜ï¼Œè€å®è¯´æˆ‘ä¸è®¤ä¸ºæˆ‘æ›¾ç»é‡åˆ°è¿‡è¿™ä¸ªé—®é¢˜ï¼Œä½†æˆ‘åœ¨è¿™é‡ŒæåŠå®ƒæ˜¯ä¸ºäº†æ¸…æ™°èµ·è§ï¼Œå› ä¸ºæœ‰æ—¶äººä»¬ä¼šå°†å®ƒä¸ç¬¬äºŒä¸ªé—®é¢˜æ··æ·†ã€‚
- en: You can take a `shared_ptr` and make a copy of it, calling its copy constructor,
    in a thread-safe way. What you cannot do, however, is share a single instance
    of a `shared_ptr` between multiple threads. Imagine having a struct containing
    a shared pointer that is shared between threads, and a method on that struct that
    reassigns the shared pointer. If that method is called unsynchronized by multiple
    threads, then this will result in undefined behavior.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥æ‹¿ä¸€ä¸ª `shared_ptr` å¹¶é€šè¿‡è°ƒç”¨å…¶æ‹·è´æ„é€ å‡½æ•°æ¥å®‰å…¨åœ°è¿›è¡Œå¤åˆ¶ã€‚ç„¶è€Œï¼Œä½ ä¸èƒ½åœ¨å¤šä¸ªçº¿ç¨‹ä¹‹é—´å…±äº«ä¸€ä¸ª `shared_ptr` çš„å•ä¸€å®ä¾‹ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæœ‰ä¸€ä¸ªåŒ…å«å…±äº«æŒ‡é’ˆçš„ç»“æ„ä½“ï¼Œåœ¨å¤šä¸ªçº¿ç¨‹ä¹‹é—´å…±äº«ï¼Œä»¥åŠåœ¨è¯¥ç»“æ„ä½“ä¸Šæœ‰ä¸€ä¸ªé‡æ–°åˆ†é…å…±äº«æŒ‡é’ˆçš„æ–¹æ³•ã€‚å¦‚æœå¤šä¸ªçº¿ç¨‹æœªåŒæ­¥åœ°è°ƒç”¨è¯¥æ–¹æ³•ï¼Œé‚£ä¹ˆè¿™å°†å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚
- en: Apparently, this is enough of an issue that C++20 added a [partial template
    specialization to `std::atomic<std::shared_ptr>`](https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2).
    My advice, though, would be "don't do that!". Instead, keep your shared pointer
    in a single thread, and send copies to other threads as needed.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¾ç„¶ï¼Œè¿™ä¸ªé—®é¢˜è¶³ä»¥å¼•èµ·å…³æ³¨ï¼Œä»¥è‡³äº C++20 æ·»åŠ äº†å¯¹ `std::atomic<std::shared_ptr>` çš„[éƒ¨åˆ†æ¨¡æ¿ç‰¹åŒ–](https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2)ã€‚ç„¶è€Œï¼Œæˆ‘çš„å»ºè®®æ˜¯â€œä¸è¦é‚£æ ·åšï¼â€ã€‚ç›¸åï¼Œä¿æŒä½ çš„å…±äº«æŒ‡é’ˆåœ¨å•çº¿ç¨‹ä¸­ï¼Œå¹¶æ ¹æ®éœ€è¦å‘å…¶ä»–çº¿ç¨‹å‘é€å‰¯æœ¬ã€‚
- en: Since assignment requires at an exclusive reference or an owned object, Rust
    statically forbids assigning to an `Arc` that is shared between multiple threads,
    avoiding the issue at compile time.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºèµ‹å€¼è¦æ±‚å…·æœ‰ç‹¬å å¼•ç”¨æˆ–æ‹¥æœ‰çš„å¯¹è±¡ï¼ŒRust é™æ€åœ°ç¦æ­¢å‘å¤šä¸ªçº¿ç¨‹å…±äº«çš„ `Arc` èµ‹å€¼ï¼Œä»è€Œåœ¨ç¼–è¯‘æ—¶é¿å…äº†æ­¤é—®é¢˜ã€‚
- en: In a `shared_ptr`, only the reference counting is atomic, but the pointed-to
    object needs its own synchronization for writing and reading from different threads.
    This is a bit of a pitfall because it is tempting to simplify "`shared_ptr` is
    a thread-safely-referenced-counted pointer" to "`shared_ptr` is a thread-safe
    reference-counted pointer", while only the former is true.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ `shared_ptr` ä¸­ï¼Œåªæœ‰å¼•ç”¨è®¡æ•°æ˜¯åŸå­çš„ï¼Œä½†æŒ‡å‘çš„å¯¹è±¡éœ€è¦è‡ªå·±çš„åŒæ­¥æœºåˆ¶ï¼Œä»¥ä¾¿ä»ä¸åŒçš„çº¿ç¨‹è¿›è¡Œå†™å…¥å’Œè¯»å–ã€‚è¿™æ˜¯ä¸€ä¸ªé™·é˜±ï¼Œå› ä¸ºæŠŠâ€œ`shared_ptr`
    æ˜¯ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„å¼•ç”¨è®¡æ•°æŒ‡é’ˆâ€ç®€åŒ–ä¸ºâ€œ`shared_ptr` æ˜¯ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„å¼•ç”¨è®¡æ•°æŒ‡é’ˆâ€æ˜¯è¯±äººçš„ï¼Œè€Œåªæœ‰å‰è€…æ˜¯çœŸå®çš„ã€‚
- en: While this may seem obvious to seasoned developers, I saw a lot more of this
    issue in the wild, probably always by junior developers ğŸ™ƒ never by experienced
    developers refactoring their code to introduce threads ğŸ˜‡
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶å¯¹ç»éªŒä¸°å¯Œçš„å¼€å‘è€…æ¥è¯´è¿™å¯èƒ½æ˜¾è€Œæ˜“è§ï¼Œä½†æˆ‘åœ¨å®é™…æƒ…å†µä¸­ç»å¸¸çœ‹åˆ°è¿™ä¸ªé—®é¢˜ï¼Œå¾ˆå¯èƒ½æ˜¯ç”±åˆçº§å¼€å‘è€…å¼•èµ·çš„ ğŸ™ƒï¼Œè€Œä»æœªè¢«æœ‰ç»éªŒçš„å¼€å‘è€…é€šè¿‡é‡æ„ä»£ç å¼•å…¥çº¿ç¨‹
    ğŸ˜‡ã€‚
- en: Naturally, Rust [imposes the same requirement](https://doc.rust-lang.org/std/sync/struct.Arc.html#thread-safety)
    on the content of `Arc`, but [thanks](https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-Send-for-Arc%3CT,+A%3E)
    to [the `Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) and [the
    `Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits, and `Arc`
    only providing shared reference to its contents, writing and reading the pointed-to
    object unsynchronized is a compile-time error.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: è‡ªç„¶åœ°ï¼ŒRust å¯¹ `Arc` çš„å†…å®¹[æ–½åŠ äº†ç›¸åŒçš„è¦æ±‚](https://doc.rust-lang.org/std/sync/struct.Arc.html#thread-safety)ï¼Œä½†[å¤šäºäº†](https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-Send-for-Arc%3CT,+A%3E)
    `Send` å’Œ [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) ç‰¹æ€§ï¼Œ`Arc`
    åªæä¾›å¯¹å…¶å†…å®¹çš„å…±äº«å¼•ç”¨ï¼Œå¯¹æŒ‡å‘çš„å¯¹è±¡è¿›è¡ŒæœªåŒæ­¥çš„å†™å…¥å’Œè¯»å–æ˜¯ä¸€ä¸ªç¼–è¯‘æ—¶é”™è¯¯ã€‚
- en: Rust achieves this result entirely thanks to the borrow checker and its type
    system. It is the only language I used that can statically [prevent data races](https://doc.rust-lang.org/nomicon/races.html).
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: Rust å®Œå…¨ä¾é å€Ÿç”¨æ£€æŸ¥å™¨å’Œå…¶ç±»å‹ç³»ç»Ÿå®ç°è¿™ä¸€ç»“æœã€‚è¿™æ˜¯æˆ‘ä½¿ç”¨çš„å”¯ä¸€ä¸€ç§é™æ€[é˜²æ­¢æ•°æ®ç«äº‰](https://doc.rust-lang.org/nomicon/races.html)çš„è¯­è¨€ã€‚
