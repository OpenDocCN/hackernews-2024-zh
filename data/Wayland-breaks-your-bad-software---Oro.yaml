- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-29 12:48:53'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-29 12:48:53'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Wayland breaks your bad software | Oro
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wayland 打破了你的糟糕软件 | Oro
- en: 来源：[https://orowith2os.gitlab.io/posts/wayland-breaks-your-bad-software/](https://orowith2os.gitlab.io/posts/wayland-breaks-your-bad-software/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://orowith2os.gitlab.io/posts/wayland-breaks-your-bad-software/](https://orowith2os.gitlab.io/posts/wayland-breaks-your-bad-software/)
- en: X11 is, to put it simply, not at all fit for any modern system. Full stop. Everything
    to make it work on modern systems are just hacks. Don’t even try to get away with
    “well, it just works for me” or “but Wayland no worky”. Unless your workflow (and
    hardware) comes from 20+ years ago, you have almost no reason to stick with Xorg,
    especially as it continues to get worse and worse when the user experience relies
    on newer and newer features.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: X11 简而言之，根本不适合任何现代系统。完全停止。为了让它在现代系统上运行，只是一些hack。不要试图通过“嗯，它对我有效”或“但是 Wayland
    不工作”的方式逃避。除非你的工作流程（和硬件）来自20多年前，否则你几乎没有理由坚持使用 Xorg，特别是随着用户体验依赖于更新和新特性的不断恶化。
- en: Almost everything that *didn’t* work even *two months ago* works now, and tons
    of progress is being made so it works for almost everyone - yes, even you, NVIDIA
    users. Or, in some cases, it’s not even Wayland’s place to dictate how things
    are supposed to work - it’s purely the setup you choose.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有*两个月前没有*工作的东西现在都可以工作了，并且正在取得大量进展，以便几乎每个人都可以使用 - 是的，甚至是你，NVIDIA 用户。或者，在某些情况下，Wayland
    甚至不该决定事物应该如何运行 - 这纯粹取决于你选择的设置。
- en: With that being said, let’s get on with it. Expect me to be blunt, and wordy.
    I’ll also be a bit technical. Probably going to devolve into some crying after
    seeing just how horrible X is.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，让我们继续吧。请期待我直言不讳，冗长。我还会有些技术性内容。看到 X 有多可怕后，我可能会开始流泪。
- en: If you have anything to improve, or find something that’s wrong, file an issue
    or pull request to (as of the time of writing) [my website repository](https://gitlab.com/OroWith2Os/orowith2os.gitlab.io)
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何需要改进的地方，或者发现有错的地方，请提交问题或拉取请求到（截至撰写本文时）[我的网站存储库](https://gitlab.com/OroWith2Os/orowith2os.gitlab.io)
- en: Wayland is it[](#wayland-is-it)
  id: totrans-split-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Wayland 就是这个[](#wayland-is-it)
- en: '*Wayland is what newer desktops should look like, and what some *do* look like!*'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*Wayland 是新一代桌面应该呈现的样子，也是一些*实际上*呈现的样子！*'
- en: '*No more having applications listen to your keystrokes without permission,
    or messing with your display. Improved battery life. Simpler APIs.*'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*不再让应用程序在未经许可的情况下监听您的按键，或者干扰您的显示。改进的电池寿命。更简单的 API。*'
- en: '*[Marcan](https://marcan.st/), someone who’s helped build [Asahi Linux](https://asahilinux.org),
    wrote a series of posts detailing things like this, though more on the technical
    stuff for why Wayland got tagged as It.*'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Marcan](https://marcan.st/)，一位曾协助建立[Asahi Linux](https://asahilinux.org)的人，写了一系列文章详细说明了这些事情，虽然更多是关于技术性的内容，解释了为什么
    Wayland 被认为是它的标签。*'
- en: '*Let’s look at [this one](https://social.treehouse.systems/@marcan/110371565062371963),
    which explains basically everything about this situation:*'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们看看[这个](https://social.treehouse.systems/@marcan/110371565062371963)，它基本上解释了这种情况的一切：*'
- en: '*A bit of (simplified) X history and how we got here. Back in the 90s and 2000s,
    X was running display drivers directly in userspace. That was a terrible idea,
    and made interop between X and the TTY layer a nightmare. It also meant you needed
    to write X drivers for everything. And it meant X had to run as root. And that
    if X crashed it had a high chance of making your whole machine unusable.*'
  id: totrans-split-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*（简化的）X 历史和我们的发展过程。回顾90年代和2000年代，X 直接在用户空间运行显示驱动程序。那是一个可怕的想法，使得 X 和 TTY 层之间的互操作成为噩梦。这也意味着你需要为所有东西编写
    X 驱动程序。这也意味着 X 必须以 root 权限运行。如果 X 崩溃，那么整台机器的可用性可能会非常低。*'
- en: '*Then along came KMS, and moved modesetting into the kernel. Along with a common
    API, that obsoleted the need for GPU-specific drivers to display stuff. But X
    kept on using GPU-specific drivers. Why? Because X relies on 2D acceleration,
    a concept that doesn’t even exist any more in modern hardware, so it still needed
    GPU-specific drivers to implement that.*'
  id: totrans-split-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*然后 KMS 出现了，并将模式设置移到了内核中。伴随着一个通用的 API，这使得需要为 GPU 编写特定驱动程序来显示内容的需求过时了。但 X 仍然继续使用特定于
    GPU 的驱动程序。为什么？因为 X 依赖于2D 加速，在现代硬件中根本不存在这样的概念，所以它仍然需要 GPU 特定的驱动程序来实现这一点。*'
- en: '*The X developers of course realized that modern hardware couldn’t do 2D any
    more, so along came Glamor, which implements X’s three decades of 2D acceleration
    APIs on top of OpenGL. Now you could run X on any modern GPU with 3D drivers.
    And so finally we could run X without any GPU-specific drivers, but since X still
    wants there to be “a driver”, along came xf86-video-modesetting, which was supposed
    to be the future. It was intended to work on any modern GPU with Mesa/KMS drivers.*'
  id: totrans-split-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*X的开发人员当然意识到现代硬件不能再进行2D处理了，于是Glamor应运而生，它在OpenGL之上实现了X三十年来的2D加速API。现在你可以在任何带有3D驱动程序的现代GPU上运行X了。因此，最终我们可以在没有任何特定于GPU的驱动程序的情况下运行X，但由于X仍然希望有“一个驱动程序”，因此出现了xf86-video-modesetting，这本来应该是未来的方向。它打算在任何带有Mesa/KMS驱动程序的现代GPU上运行。*'
- en: '*That was in 2015\. And here’s the problem: X was already dying by then. Modesetting
    sucked. Intel deprecated their GPU-specific DDX driver and it started bitrotting,
    but modesetting couldn’t even handle tear-free output until earlier this year
    (2023, 8 whole years later). Just ask any Intel user of the Ivy Bridge/Haswell
    era what a mess it all is. Meanwhile Nvidia and AMD kept maintaining their respective
    DDX drivers and largely insulating users from the slow death of core X, so people
    thought this was a platform/vendor thing, even though X had what was supposed
    to be a platform-neutral solution that just wasn’t up to par.*'
  id: totrans-split-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这是在2015年。而问题在于，X在那时已经开始衰退。显示设置非常糟糕。英特尔淘汰了他们的GPU特定DDX驱动程序，并且开始腐烂，但是直到今年（2023年，整整8年后），显示设置才能处理无撕裂的输出。只需问问任何使用Ivy
    Bridge/Haswell时代英特尔用户，这一切是多么混乱。与此同时，Nvidia和AMD继续维护它们各自的DDX驱动程序，并且大部分时间让用户免受核心X慢慢死去的影响，因此人们认为这是一个平台/供应商的问题，尽管X已经拥有本应该是平台中立的解决方案，只是未能达到预期的水平。*'
- en: '*And so when other platforms like ARM systems came around, we got stuck with
    modesetting. Nobody wants to write an X DDX. Nobody even knows how outside of
    people who have done it in the past, and those people are burned out. So X will
    *always* be stuck being an inferior experience if you’re not AMD or Nvidia, because
    the core common code that’s supposed to handle it all just doesn’t cut it.*'
  id: totrans-split-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*因此，当像ARM系统这样的其他平台出现时，我们卡在了显示设置中。没有人想编写X DDX。甚至没有人知道，除了曾经做过的人之外，那些人早已筋疲力尽。因此，如果你不是AMD或Nvidia，X将永远被困在一个次优的体验中，因为本来应该处理所有这一切的核心通用代码实际上并不尽如人意。*'
- en: '*On top of that, ARM platforms have to deal with separate display and render
    devices, which is something modesetting can’t handle automatically. So now we
    need platform-specific X config files to make it work.*'
  id: totrans-split-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*此外，ARM平台必须处理分离的显示和渲染设备，这是显示设置无法自动处理的。所以现在我们需要特定于平台的X配置文件才能使其工作。*'
- en: '*And then there’s us. When Apple designed the M1, they decided to put a coprocessor
    CPU in the display controller. And instead of running the display driver in macOS,
    they moved most of it to firmware. That means that from Linux’s point of view,
    we’re not running on bare metal, we’re running on top of an abstraction intended
    for macOS’ compositor. And that abstraction doesn’t have stuff like vblank IRQs,
    or traditional cursor planes, and is quite opinionated about pixel formats and
    colorspaces. That all works well with modern Wayland compositors, which use KMS
    abstractions that are a pretty good match for this model (it’s the future and
    every other platform is moving in this direction).*'
  id: totrans-split-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*然后还有我们。当苹果设计M1时，他们决定在显示控制器中放置一个协处理器CPU。而不是在macOS中运行显示驱动程序，他们将大部分内容移到固件中。这意味着从Linux的角度来看，我们并不是在裸机上运行，而是在macOS合成器的抽象层上运行。这个抽象层没有像vblank
    IRQ这样的东西，也没有传统的光标平面，并且对像素格式和色彩空间有非常明确的意见。所有这些都与现代Wayland合成器很好地配合，后者使用了与此模型相当匹配的KMS抽象层（这是未来，其他平台都在朝这个方向发展）。*'
- en: '*But X and its modesetting driver are stuck in the past. It tries to do ridiculous
    things like draw directly into the visible framebuffer instead of a back buffer,
    or expect there to be a “vblank IRQ” even though you don’t need one any more.
    It implements a software fallback for when there is no hardware cursor plane,
    but the code is broken and it flickers. And so on. These are all problems, legacy
    nonsense, and bugs that are part of core X. They just happen to hurt smaller platforms
    more, and they particularly hurt us.*'
  id: totrans-split-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*但是X及其显示设置驱动程序仍然停留在过去。它试图做一些荒谬的事情，比如直接在可见帧缓冲区中进行绘制，而不是后备缓冲区，或者期望有“vblank IRQ”，尽管现在已经不需要了。当没有硬件光标平面时，它实现了软件回退，但代码有问题并且会闪烁。等等。这些都是核心X的问题，遗留的废话和错误。它们只是偶尔会更多地影响较小的平台，特别是伤害我们。*'
- en: '*That’s not even getting into fundamental issues with the core X protocol,
    like how it can’t see the Fn key on Macs because Macs have software Fn keys and
    that keycode is too large in the evdev keycode table, or how it only has 8 modifiers
    that are all in use today, and we need one more for Fn. Those things can’t be
    properly fixed without breaking the X11 protocol and clients.*'
  id: totrans-split-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*甚至没有涉及到核心X协议的基本问题，比如Mac上无法识别Fn键，因为Mac有软件Fn键，而evdev键码表中的该键码过大，或者像今天所有8个修饰键已被使用，我们需要一个额外的Fn键。这些问题在不破坏X11协议和客户端的情况下无法得到适当的修复。*'
- en: '*So no, X will never work properly on Asahi. Because it’s buggy, it has been
    buggy for over 8 years, nobody has fixed it in that time, and certainly nobody
    is going to go fix it now. The attempt at having a vendor-neutral driver was too
    little too late, and by then momentum was already switching to Wayland. Had continued
    X development lasted long enough to get modesetting up to par 8 years ago, the
    story with Asahi today would be different. But it didn’t, and now here we are,
    and there is nothing left to be done.*'
  id: totrans-split-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*所以不，X在Asahi上永远不会正常工作。因为它存在bug，已经有8年之久，这段时间内没有人修复它，当然现在也没有人去修复它。试图拥有一个供应商中立的驱动程序的尝试太少太迟，而且到那时动力已经转向Wayland。如果8年前继续X的开发足够长时间以使得模式设置达到标准，今天Asahi的情况可能会不同。但事实并非如此，现在我们面临的现实是，无可挽回。*'
- en: '*That sums up just about everything, so I’ll go more into detail on stuff that
    wasn’t explained by Marcan.*'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*这基本上概括了所有内容，所以我会更详细地讲解一些马坎没有解释清楚的东西。*'
- en: '*Architecture and performance[](#architecture-and-performance)*'
  id: totrans-split-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*架构和性能[](#architecture-and-performance)*'
- en: '**Some newer hardware, like Apple Silicon, has a good bit of display stuff
    handled in firmware. As such, it actually ends up looking pretty similar to the
    abstractions provided by DRM/KMS, and Wayland is a pretty good fit for it. That
    post that I copied in here from Marcan explains it all in more detail.**'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**一些新硬件，如Apple Silicon，在固件中处理了大部分显示内容。因此，它实际上与DRM/KMS提供的抽象相似，而Wayland非常适合这种情况。Marcan在这里复制的帖子详细解释了所有这些。**'
- en: '**This is actually pretty closely related to the architecture: Wayland is *way*
    more performant.**'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**这实际上与架构非常密切相关：Wayland的性能更为卓越。**'
- en: '**On Xorg, you’ve got several processes: one for the display server, and one
    or two for the compositor and window manager. Why is that so bad, you might ask?
    Well, that’s several processes with an inefficient design. There are some extensions
    to put a bandaid on it, but there are still inherent inefficiencies with X that
    cause problems. The X server handles a lot, after all. And now you’re adding on
    even more with a compositor and window manager, that provide effects and window
    decorations. Xwayland inherits most of the core problems, but it still has one
    telling difference: there’s a better compositor underneath it, that is better
    optimized for the system. And most of your apps are likely to not be running through
    Xwayland, so you get most of the benefits.**'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Xorg上，你有几个进程：一个用于显示服务器，一个或两个用于合成器和窗口管理器。你可能会问，为什么这样不好？好吧，那是几个设计效率低下的进程。有一些扩展可以把它包扎起来，但X仍然存在固有的效率问题。毕竟，X服务器处理了很多事情。现在你又添加了合成器和窗口管理器，它们提供效果和窗口装饰。Xwayland继承了大部分核心问题，但仍然有一个显著的区别：在底层有一个更好的合成器，更为系统优化。而且你的大多数应用程序可能不会通过Xwayland运行，因此你可以获得大部分的好处。*'
- en: '**On Wayland, the solution is simple: do less. The protocol is simpler, the
    compositor does less work, and there are fundamental design changes that allow
    the compositor to be a bit more flexible and do things like [DMA-BUF access](https://wayland.app/protocols/linux-dmabuf-unstable-v1)
    and skip most of the compositing process, instead directly scanning out things
    like games and videos to the screen.**'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Wayland上，解决方案很简单：做更少的事情。协议更简单，合成器的工作量更小，还有一些基本的设计改变，允许合成器更灵活地做一些事情，比如[DMA-BUF
    access](https://wayland.app/protocols/linux-dmabuf-unstable-v1)，并跳过大部分的合成过程，直接将像游戏和视频这样的内容扫描到屏幕上。**'
- en: '**So, with Wayland, you get back a bit of performance in extreme cases, *and*
    on mobile systems you can even get better battery life! This is a pretty big deal,
    especially when it comes to things like the Steam Deck (which uses Gamescope,
    a Wayland microcompositor) or notebook laptops. Would *you* like your laptop to
    run out of juice in the middle of class while taking notes? I think not.**'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**因此，使用Wayland，在极端情况下你可以获得一点性能提升，*而且*在移动系统上，你甚至可以获得更长的电池续航！这是一件相当重要的事情，特别是当涉及到像Steam
    Deck（使用Gamescope，一个Wayland微合成器）或笔记本电脑的时候。*你*希望在上课时笔记本电脑没电吗？我想不会。**'
- en: '**Not to mention making it *way* easier to maintain. The Xorg codebase is unmaintainable,
    and it’s even hit a [development low of all time](https://www.phoronix.com/news/XServer-2022-Development-Pace)
    recently! That’s *thousands* of bugs, *dozens* of features, all never going to
    be fixed and added. Oh, the bus factor….. Hell, one of the only things that was
    recently added to Xorg was [support for libei](https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/975),
    and even then it was only for *Xwayland*. Look through the list of commits since
    then, and everything is basically only for Xwayland.**'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**更不用说使其*更*容易维护了。Xorg的代码基础无法维护，最近甚至达到了[有史以来的开发低谷](https://www.phoronix.com/news/XServer-2022-Development-Pace)！这是*成千上万*个错误，*数十*个功能，全部都不会被修复和添加。哦，总线因子……该死，最近Xorg唯一新增的东西之一是对libei的支持，甚至那也只是为了*Xwayland*。自那以来浏览提交列表，基本上所有东西都是为了Xwayland。**'
- en: '**Now look at Wayland compositors, and you can see new features and improvements
    being made within the last *week!* And you can be sure that they won’t be abandoned
    for a long while because of the core protocol being so horrible to maintain and
    work with.**'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在看看Wayland合成器，你会发现在过去的*一周*内新增了新功能和改进！可以确信，由于核心协议维护和工作的困难性，它们不会很快被放弃。**'
- en: '**One could argue that’s because of each compositor needing to do everything
    themselves, but there’s not really a particular reason as to why you can’t create
    something like the Xorg architecture. That’s what KDE does, after all. The shell
    and the compositor are two separate processes. You also have wlroots, which provides
    quite a few helpers, making it more the Xorg for the Wayland ecosystem.**'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**或许可以说这是每个合成器需要做所有事情的原因，但事实上并没有特定的原因说明为什么不能创建像Xorg架构那样的东西。毕竟这就是KDE所做的。Shell和合成器是两个独立的进程。你还有wlroots，它提供了相当多的辅助工具，使其更像是Wayland生态系统的Xorg。**'
- en: '**Security[](#security)**'
  id: totrans-split-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**安全性[](#security)**'
- en: '***If you’ve ever used Xorg, you might’ve noticed that several tools, especially
    ones that record your screen or listen to your keystrokes, never need permission
    to do so. That’s a *major* issue.***'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: '***如果您曾经使用过Xorg，您可能会注意到一些工具，特别是那些记录屏幕或监听按键的工具，从来不需要权限来执行。这是一个*重大*问题。***'
- en: '***Arbitrary applications can record any and all content that goes to your
    screen. Video calls, private messages, web pages. Anything you can see is everything
    that can be grabbed without your permission…. as well as everything you *can’t*
    see.***'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: '***任意应用程序可以录制到您屏幕上的任何内容。视频通话、私人消息、网页。您能看到的一切都可以在没有您许可的情况下被抓取……以及所有您*看不见*的东西。***'
- en: '***Don’t want to forget your passwords? Don’t worry, keyloggers can save them
    for you, and all without you needing to tell them to! Aren’t they so nice!***'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: '***不想忘记您的密码？别担心，键盘记录器可以为您保存它们，而且完全不需要您告诉它们！它们是不是很好呢！***'
- en: '***If you want to use any of these features on Wayland, you don’t get to just
    do it without permission. That’s Not Good™. So we have the [ScreenCast](https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.ScreenCast),
    [GlobalShortcuts](https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.GlobalShortcuts)
    and [InputCapture](https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.InputCapture)
    portals for that. Don’t expect to use sensitive APIs without permission, and if
    you do, then put simply: kindly fuck off :)***'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: '***如果你想在Wayland上使用这些功能，你不能擅自去做。这不好™。因此，我们有[ScreenCast](https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.ScreenCast)，[GlobalShortcuts](https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.GlobalShortcuts)和[InputCapture](https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.InputCapture)门户。不要指望在没有权限的情况下使用敏感的API，如果你这样做了，简单地说：请友好地离开
    :)***'
- en: '***Screensharing[](#screensharing)***'
  id: totrans-split-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***屏幕共享[](#screensharing)***'
- en: '***Wayland technically has nothing to do with screensharing - this is all handled
    separately, in [PipeWire](https://pipewire.org) and [xdg-desktop-portal](https://github.com/flatpak/xdg-desktop-portal).***'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: '***技术上说，Wayland 与屏幕共享毫无关系 - 所有这些都是分开处理的，在 [PipeWire](https://pipewire.org)
    和 [xdg-desktop-portal](https://github.com/flatpak/xdg-desktop-portal) 中。***'
- en: '***For applications to get *any* information about what’s being displayed,
    they *must* go through xdg-desktop-portal - [ScreenCast](https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.ScreenCast),
    specifically. This presents a prompt to the user asking what windows or screens
    an application should have access to. From there, the application gets access
    to *just* the allowed resources, and in an efficient way.***'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: '***要让应用程序获取有关正在显示的任何信息，它们必须通过 xdg-desktop-portal - [ScreenCast](https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.ScreenCast)，具体来说。这将提示用户选择应用程序应具有访问权限的窗口或屏幕。从那里，应用程序仅获取到被允许的资源，并且以高效的方式。***'
- en: '***Look at Xorg, and you get a worse UX: applications need access to *everything*
    in order to see what apps they want to capture, and without any user input. And
    utilizing the contents of that video stream can be *way* less efficient.***'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: '***看看 Xorg，你会得到一个更糟糕的用户体验：应用程序需要访问 *所有* 的内容，才能看到它们想要捕获的应用程序，而且完全不需要用户输入。而且利用该视频流的内容可能会
    *非常* 低效。***'
- en: '***There *is* an exception to this “Wayland doesn’t do anything” rule - wlroots.
    Their general rule of thumb is to use Wayland protocols for things. Screensharing,
    input emulation, remote desktop, all of that is done on top of Wayland protocols
    on wlroots. Look at GNOME and KDE, and they’ll prefer to go through portals when
    appropriate. But then, you wouldn’t have any interoperability for things like
    screensharing. So you have portals which build on top of those protocols; for
    wlroots, this is [xdg-desktop-portal-wlr](https://github.com/emersion/xdg-desktop-portal-wlr).***'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: '***关于“Wayland 不做任何事情”的规则，有一个例外 - wlroots。他们的一般经验法则是使用 Wayland 协议来处理事务。屏幕共享、输入仿真、远程桌面，所有这些都是在
    wlroots 上的 Wayland 协议的基础上完成的。看看 GNOME 和 KDE，它们会优先通过适当的门户进行。但这样做，你无法像屏幕共享那样实现互操作性。所以，你有建立在这些协议之上的门户；对于
    wlroots 来说，这就是 [xdg-desktop-portal-wlr](https://github.com/emersion/xdg-desktop-portal-wlr)。***'
- en: '***Multi-monitor scaling[](#multi-monitor-scaling)***'
  id: totrans-split-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***多监视器缩放[](#multi-monitor-scaling)***'
- en: '***Nonexistent on Xorg. Exists from the start on Wayland. Sadly, this also
    affects Xwayland.***'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: '***在 Xorg 上不存在。在 Wayland 上从一开始就存在。遗憾的是，这也影响了 Xwayland。***'
- en: '***Xorg, from the very beginning, only ever had to deal with one display. It
    *did* originate from around the 1980s, after all. Having more than one display
    wasn’t even a thought in their mind, let alone ones with different resolutions
    and scales. The official docs even [consider a “Display” to be the entire Xorg
    server, with all of its screens combined](https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html#glossary:Display).***'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: '***Xorg，从一开始就只需处理一个显示器。毕竟，它起源于大约 1980 年代。甚至没有想到会有多个显示器，更不用说分辨率和比例不同的了。官方文档甚至
    [认为“显示”是整个 Xorg 服务器，包括其所有屏幕的结合体](https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html#glossary:Display)。***'
- en: '***Wayland fixes this with an intentional design decision that *also* makes
    it a lot easier to work with other features: the windows don’t have any idea of
    what’s going on outside of their own surfaces. So they just get told what scale
    to use on their specific surfaces.***'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: '***Wayland 通过一种有意的设计决策修复了这个问题，这也使得与其他功能的协作变得更加容易：窗口不知道自己表面外面发生的事情。所以它们只是在特定表面上被告知使用什么比例。***'
- en: '***[refi64](https://refi64.com) did some work on this for Xwayland in the past,
    specifically rebasing and updating [xwayland: Multi DPI support via global factor
    rescaling](https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/733).
    This works primarily because X11 properties are window-local, similar to how the
    scale factor is obtained [on Wayland](https://wayland.app/protocols/wayland#wl_surface:event:preferred_buffer_scale).***'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: '***[refi64](https://refi64.com) 曾经在过去为 Xwayland 做过一些工作，特别是重新基于和更新 [xwayland:
    Multi DPI support via global factor rescaling](https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/733)。这主要工作是因为
    X11 属性是窗口本地的，类似于在 [Wayland](https://wayland.app/protocols/wayland#wl_surface:event:preferred_buffer_scale)
    上获取比例因子的方式。***'
- en: '***This isn’t the case for getting the scale normally, which doesn’t have one
    defined spec. There are environment variables, `XSETTINGS`, toolkit-specific configs,
    and most (or all) of those don’t work with fractional scaling. So the best way
    to explain how X does scaling is…. it doesn’t.***'
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: '***这与通常获取比例的情况不同，它没有定义的规范。有环境变量、`XSETTINGS`、工具包特定的配置，大多数（或全部）都不支持分数缩放。所以解释X如何缩放的最好方法是……
    它不缩放。***'
- en: '***Fractional scaling[](#fractional-scaling)***'
  id: totrans-split-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***分数缩放[](#fractional-scaling)***'
- en: '***The story of fractional scaling on Linux has been…. weird. Xorg, like Wayland,
    didn’t have a concept of fractional scaling from the start. Thankfully Wayland’s
    [gotten that fixed](https://wayland.app/protocols/fractional-scale-v1), but the
    story with Xorg is still in integer scales. It also affects Xwayland, which I’ll
    go more into detail in here.***'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '***Linux上的分数缩放故事一直很奇怪。Xorg和Wayland一样，一开始并没有分数缩放的概念。幸运的是，Wayland已经[修复了这个问题](https://wayland.app/protocols/fractional-scale-v1)，但是Xorg的情况仍然是整数比例。这也影响到Xwayland，在这里我会详细介绍。***'
- en: '***A solution is to make one giant framebuffer with the largest common scale
    and downsample it for the necessary displays, which is more or less what GNOME
    did before on Wayland for fractional scaling - tell clients to render at the next
    largest integer scale, and downsample to the desired fractional scale. The only
    difference is that you do this for your entire Xorg framebuffer, which means your
    entire desktop is rendered at the highest common scale. Not ideal, obviously,
    but it would get the job done.***'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: '***一个解决方案是创建一个巨大的帧缓冲区，具有最大公共比例，并将其缩小以适应必要的显示器，这或多或少是GNOME在Wayland上进行分数缩放之前所做的事情
    - 告诉客户端以最大整数比例渲染，并缩小到所需的分数比例。唯一的区别是您对整个Xorg帧缓冲区执行此操作，这意味着整个桌面都以最高公共比例呈现。显然不是理想的解决方案，但这可以完成工作。***'
- en: '***Like I mentioned in the previous section, most of the configs don’t work
    for fractional scaling. It really is more pain than it’s worth. You’d be better
    off getting Wayland going, and getting the hell off Xorg.***'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: '***就像我在上一节中提到的，大多数配置对分数缩放不起作用。实际上，这比它的价值更痛苦。您最好搞定Wayland，摆脱Xorg。***'
- en: '***For what it’s worth, I’ll also quote a snippet from [Kenny Levinsen](https://kl.wtf/)
    from some discussions about scaling, for a cursed project I’m looking into:***'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: '***说实话，我还会引用[Kenny Levinsen](https://kl.wtf/)关于缩放的一些讨论片段，用于我正在调查的一个诅咒项目：***'
- en: '***just skip scaling to begin with, it’s not important for a demonstration***'
  id: totrans-split-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***首先跳过缩放，对于演示来说并不重要***'
- en: '***later you could hack it by turning the gross font dpi thing into a fractional
    scale value or something - X11 is a hack, so what you make will in turn also be
    a hack.***'
  id: totrans-split-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***稍后，您可以通过将粗体字体DPI转换为分数比例值或类似的东西来进行黑客攻击 - X11是一个黑客，所以您做的东西也将成为一个黑客。***'
- en: '***No point in fretting over that :)***'
  id: totrans-split-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***没有为此担心的必要 :)***'
- en: '***Several refresh rates[](#several-refresh-rates)***'
  id: totrans-split-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***几个刷新率[](#several-refresh-rates)***'
- en: '***When you have just one monitor, it’s all fine and dandy - your game can
    go right to the display. But several monitors gives you one giant framebuffer
    for your compositor that draws to *all* your displays. Xorg doesn’t do normal
    flipping with double buffering like a “normal” display server would do, as it
    instead continuously draws to the framebuffer, and expects the hardware to read
    it once in a while and display it. For a 60Hz display, it reads 60 times a second,
    for 120Hz it reads 120 times a second, and so on.***'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: '***当您只有一个显示器时，一切都很好 - 您的游戏可以直接显示。但是多个显示器会为您的组合器创建一个巨大的帧缓冲区，并在*所有*显示器上绘制。与“正常”显示服务器不同，Xorg不会像双缓冲那样进行常规翻转，而是连续绘制到帧缓冲区，并期望硬件偶尔读取并显示它。对于60Hz显示器，它每秒读取60次，对于120Hz则每秒读取120次，依此类推。***'
- en: '***This means that when you don’t have just one monitor, at least on a setup
    with a compositor (something you would normally want to have), things can get
    ugly. Tearing, lack of modern features like VRR, and so on, as Xorg needs to give
    enough frame updates to work for *all* those monitors, all one what’s one giant
    window - but it can’t do that, so it just updates enough to work for the highest
    refresh rate monitor. This isn’t likely to get fixed any time soon. You just need
    to bypass the compositor entirely for any cases where you want any of those nice
    features.***'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: '***这意味着，当你不只有一个监视器时，至少在一个具有合成器的设置中（通常你希望有这个），情况可能会变得很糟糕。撕裂、缺少像 VRR 这样的现代功能等等，因为
    Xorg 需要足够的帧更新来适应*所有*这些监视器，所有在一个巨大的窗口上 - 但它做不到，所以它只更新足够让刷新率最高的监视器工作。这不太可能很快修复。你只需要完全绕过合成器，以便在需要任何这些好功能的情况下使用。***'
- en: '***I’d like to mention that [pac85](https://gitlab.com/pac85) has a hack that
    works around the lack of VRR, which just fakes a pageflip - the kernel driver
    is explicitly told to perform a flip, but is given the same framebuffer.***'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: '***我想提一下，[pac85](https://gitlab.com/pac85) 有一个绕过缺乏 VRR 的破解，它只是伪造一个页面翻转 - 内核驱动被明确告知执行翻转，但给出相同的帧缓冲。***'
- en: '***It’s like if you continuously drew to a piece of paper and wanted to show
    it to people, but expected them to know what’s going on on their own. And now
    do that with multiple drawings, all on the same piece of paper, all being drawn
    at the same time. To get vsync, you just wouldn’t draw to that piece of paper
    while someone’s looking. Double buffering, i.e. on a normal Wayland compositor,
    has the compositor drawing on another piece of paper in the background, and switches
    it with the first, and repeats whenever updating.***'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: '***这就像你不断地在一张纸上画画，并希望人们知道在他们自己看的时候发生了什么。现在再来做同样的事情，用多个画，都在同一张纸上，同时被画出来。要获得垂直同步，你只需在有人看的时候不要在那张纸上画。双缓冲，即在正常的
    Wayland 合成器上，合成器在后台另一张纸上绘制，并将其与第一张交换，并在每次更新时重复。***'
- en: '***By explicitly performing a (faked) pageflip, you can get VRR to work with
    multiple monitors, as the CRTC then knows when a pageflip happens. It doesn’t
    just update whenever on its own accord. Or, in other words, telling people “hey,
    here’s my new drawing”, instead of giving them a new one and them *knowing* something
    changed with it. And that’s what the kernel patch below allows.***'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: '***通过显式执行（伪造的）页翻转，你可以让多监视器支持 VRR，因为 CRTC 知道何时发生页面翻转。它不会在自己的意愿下随意更新。或者换句话说，告诉人们“嘿，这是我的新图”，而不是给他们一个新图并且他们*知道*它发生了变化。这就是下面的内核补丁所允许的。***'
- en: '*****This is a hack, and can and will break at times. Tread with care. It is
    not suitable for submission anywhere.*****'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*****这是一个破解，有时会失败。小心处理。这不适合在任何地方提交。*****'
- en: '***And the thing that breaks is explicit sync The kernel keeps track of what
    gpu work is acting on which framebuffer So you can imagine things go wrong there***'
  id: totrans-split-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***显式同步的事物会被破坏，内核跟踪 GPU 工作在哪个帧缓冲上运行。所以你可以想象，事情在那里可能出错。***'
- en: '***Xorg patch: [https://gitlab.com/pac85/xorg-server/-/commit/e2a4d5cf8965f7fcc8f07d04cb1e95f5e62a0094](https://gitlab.com/pac85/xorg-server/-/commit/e2a4d5cf8965f7fcc8f07d04cb1e95f5e62a0094)***'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: '***Xorg 补丁：[https://gitlab.com/pac85/xorg-server/-/commit/e2a4d5cf8965f7fcc8f07d04cb1e95f5e62a0094](https://gitlab.com/pac85/xorg-server/-/commit/e2a4d5cf8965f7fcc8f07d04cb1e95f5e62a0094)***'
- en: '***`|'
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: '***`|***'
- en: '[PRE0]'
  id: totrans-split-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|***'
- en: '[PRE1]'
  id: totrans-split-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|`***'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: '|`***'
- en: '***High dynamic range[](#high-dynamic-range)***'
  id: totrans-split-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***高动态范围[](#high-dynamic-range)***'
- en: '***HDR is a pretty new thing. It’s still a child (well, closer to teen, really)
    everywhere but TVs and consoles. macOS is probably the most usable platform in
    that regard. Windows supports it too, but the experience can be iffy, as well
    as their automatic SDR -> HDR conversion.***'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: '***HDR 是一个相当新的东西。除了电视和游戏机之外，它在所有地方都还是一个孩子（实际上更接近青少年）。macOS 可能是在这方面最可用的平台。Windows
    也支持，但体验可能不稳定，以及它们的自动 SDR -> HDR 转换。***'
- en: '***On Linux, it’s been there for a while, assuming you don’t have something
    in between you and the display. This means it should, and does, work for Kodi,
    SDL, and Gamescope, which can run directly on KMS. Since you’ve no doubt seen
    and heard of it, especially if you’ve looked into HDR on Linux, here’s how *Gamescope*
    does it - I’ll mostly just copy-paste some bits from [Joshua Ashton](https://github.com/Joshua-Ashton):***'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: '***在 Linux 上，它已经存在一段时间了，假设你与显示器之间没有任何中间件。这意味着它应该可以，而且确实可以在 Kodi、SDL 和 Gamescope
    上运行，这些可以直接在 KMS 上运行。既然你毫无疑问已经看到并听说过它，特别是如果你研究过 Linux 上的 HDR，这里是 *Gamescope* 是如何做到的
    - 我将主要从 [Joshua Ashton](https://github.com/Joshua-Ashton) 复制粘贴一些内容：***'
- en: '***Gamescope works on Wayland***'
  id: totrans-split-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***Gamescope 在 Wayland 上运行***'
- en: '***It just has its own protocol to send the extra metadata***'
  id: totrans-split-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***它只是用自己的协议发送额外的元数据***'
- en: '***[https://github.com/ValveSoftware/gamescope/blob/7fffcc813c0f1ae48d9f1d4637a508eace889507/protocol/gamescope-xwayland.xml](https://github.com/ValveSoftware/gamescope/blob/7fffcc813c0f1ae48d9f1d4637a508eace889507/protocol/gamescope-xwayland.xml)***'
  id: totrans-split-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***[https://github.com/ValveSoftware/gamescope/blob/7fffcc813c0f1ae48d9f1d4637a508eace889507/protocol/gamescope-xwayland.xml](https://github.com/ValveSoftware/gamescope/blob/7fffcc813c0f1ae48d9f1d4637a508eace889507/protocol/gamescope-xwayland.xml)***'
- en: '***The swapchain feedback and hdr metadata are the only things needed for HDR
    from that***'
  id: totrans-split-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***交换链反馈和 HDR 元数据是唯一需要的东西***'
- en: '***It uses this protocol to implement a Vulkan layer that converts apps using
    X11 Vulkan WSI to Wayland Vulkan WSI and creates an override surface behind the
    scenes***'
  id: totrans-split-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***它使用这个协议来实现一个 Vulkan 层，将使用 X11 Vulkan WSI 的应用程序转换为 Wayland Vulkan WSI，并在幕后创建一个覆盖表面***'
- en: '***And for the OpenGL story, if you were to try and go a similar path:***'
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: '***至于 OpenGL 的问题，如果你尝试走类似的路线：***'
- en: '***if you want to do the same XWayland bypass stuff I do it is going to be
    painful with GL***'
  id: totrans-split-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***如果你想做与我一样的 XWayland 绕过操作，那么在 GL 上会非常痛苦***'
- en: '***Need more mangohud style hooking***'
  id: totrans-split-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***需要更多的 mangohud 风格的挂接***'
- en: '***Or actually maybe not idk***'
  id: totrans-split-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***或者实际上也许不是，我不知道***'
- en: '***I generally try to forget how GL WSI works because it’s terrifying***'
  id: totrans-split-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***我通常试图忘记 GL WSI 的工作方式，因为它太可怕了***'
- en: '***The same work necessary to get HDR working on Gamescope would also be, more
    or less, what would be necessary for any other compositor, and normal Wayland
    clients; there’s just not an [upstream protocol for that quite yet](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/14).***'
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: '***从这个角度看，Gamescope 上实现 HDR 所需的工作与其他合成器和普通的 Wayland 客户端所需的工作基本相同；目前还没有一个 [上游协议](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/14)
    可用。***'
- en: '***And for X? Not happening. There was a [proposal by NVIDIA](https://lists.x.org/archives/xorg-devel/2017-July/054112.html),
    but nobody’s really interested in working on *and* maintaining HDR support for
    Xorg. And here’s a quote or two from Joshua Ashton once again:***'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: '***至于 X？不会发生。虽然 NVIDIA 提出了一个 [提案](https://lists.x.org/archives/xorg-devel/2017-July/054112.html)，但没人真的有兴趣在
    Xorg 上工作并维护 HDR 支持。再次引用 Joshua Ashton 的一两句话：***'
- en: '***I can give you a 3 word quote***'
  id: totrans-split-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***我可以给你一个三个字的引用***'
- en: '***“Let it die”***'
  id: totrans-split-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***“让它死吧”***'
- en: '***More detail is uhh***'
  id: totrans-split-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***更详细的解释是嗯***'
- en: '***X11 visual ids are already a broken mess… lets not touch this shit with
    a 10ft pole kthx***'
  id: totrans-split-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***X11 的视觉 ID 已经是一团糟……我们最好不要碰这些狗屎，离得越远越好***'
- en: '***NVIDIA[](#nvidia)***'
  id: totrans-split-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***NVIDIA[](#nvidia)***'
- en: '***Of course, NVIDIA likes to do their own thing, as always. Just use Nouveau
    if you want to do anything with Xwayland, and you don’t have several GPUs.***'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: '***当然，NVIDIA 像往常一样喜欢做他们自己的事情。如果你想在 Xwayland 上做任何事情，并且没有多个 GPU，就用 Nouveau 吧。***'
- en: '***I can’t be assed to go into more detail, so Google around if you’re interested.
    I *will* link to [this](https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/967)
    though, which allows Xwayland to work on NVIDIA GPUs without many of the problems
    it encountered before, and would allow it to work more easily on newer systems
    like Intel’s new kernel driver, and Asahi Linux.***'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: '***详细解释我懒得搞了，如果你感兴趣的话可以去Google一下。不过我会链接到 [这里](https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/967)，它允许
    Xwayland 在 NVIDIA GPU 上工作时避免之前遇到的许多问题，并且能更轻松地在像 Intel 的新内核驱动和 Asahi Linux 这样的新系统上运行。***'
- en: '***Thankfully [NVK was recently merged into Mesa](https://www.phoronix.com/news/Mesa-NVK-Vulkan-Merged)
    so we can finally get off of the proprietary drivers, and not have a worse UX
    for the NVIDIA users (well, half of them at least. Bug NVIDIA if you’ve got a
    Maxwell or Pascal card that doesn’t support reclocking).***'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: '***幸好 [NVK 最近被合并到 Mesa 中](https://www.phoronix.com/news/Mesa-NVK-Vulkan-Merged)，所以我们终于可以摆脱专有驱动，并且不会给
    NVIDIA 用户带来更糟糕的用户体验（至少对一半用户来说是这样。如果你有 Maxwell 或 Pascal 卡但不支持重频，请向 NVIDIA 提出 bug）。***'
- en: '***Application development PoV[](#application-development-pov)***'
  id: totrans-split-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***应用开发的视角[](#application-development-pov)***'
- en: '***Hell.***'
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: '***地狱。***'
- en: '***If you’re writing retro software for the 1980s, go for X. If you’re writing
    something that’s going to be used by anybody that isn’t running decades old hardware,
    write with Wayland in mind.***'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: '***如果你正在为上个世纪八十年代编写复古软件，那就用 X。如果你在写一些不是为几十年前的硬件设计的东西，那就要考虑 Wayland。***'
- en: '***You’ll be spending more time in a fetal position sobbing than doing anything
    productive if you even *try* and interact with X.***'
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: '***如果你甚至*尝试*和 X 交互，你将花更多时间蜷缩在胎儿姿势抽泣，而不是做任何有意义的事情。***'
- en: '***Wayland, less so - you’ll just need an emotional support Blåhaj to keep
    you company.***'
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: '***Wayland 的问题稍少一些 - 你可能需要一只情感支持 Blåhaj 来陪伴你。***'
- en: '***Or use something like SDL, and try not to interact with the display server
    directly. And you get support for other display servers *and* can more easily
    port your software to other platforms in the process, if that’s what you’re into.***'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: '***或者使用类似 SDL 的东西，并尽量不直接与显示服务器交互。这样你就可以支持其他显示服务器*并且*在此过程中更容易地将你的软件移植到其他平台，如果你愿意的话。***'
- en: '***To get the full experience, I’ll be writing a mini Wayland server and X
    client, which should teach me a fair bit on how all of this works, and I can feed
    my masochism.***'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: '***为了获得完整的体验，我将写一个迷你 Wayland 服务器和 X 客户端，这应该能教会我很多关于所有这些工作方式的知识，并且我可以满足一下我的虐待狂心理。***'
- en: '***Accessibility[](#accessibility)***'
  id: totrans-split-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***辅助功能[](#accessibility)***'
- en: '***One major thing to note about Wayland is the lack of accessibility software
    for it - and this isn’t really solvable by Wayland itself, if you still want security
    guarantees, or really in scope of the protocol.***'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: '***关于 Wayland 的一个重要事项是它缺乏相应的辅助软件 - 这并不是 Wayland 本身可以解决的问题，如果你仍然希望有安全保证，或者确实在协议范围内。***'
- en: '***So how do we plan to solve this? With a portal, of course! Specifically,
    an [accessibility portal](https://github.com/flatpak/xdg-desktop-portal/issues/1046).
    This would allow accessibility tools to work on a variety of compositors, and
    even Xorg itself (you *can* use the InputCapture, RemoteDesktop, and ScreenCast
    portals on X, after all). The main problem is just figuring out the requirements
    of those accessibility tools, and making an API that they can use.***'
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: '***那么我们打算如何解决这个问题呢？当然是通过一个门户！具体来说，是一个[辅助门户](https://github.com/flatpak/xdg-desktop-portal/issues/1046)。这将允许辅助工具在各种合成器上工作，甚至在
    Xorg 本身上也可以使用 InputCapture、RemoteDesktop 和 ScreenCast 门户。主要问题只是要弄清楚这些辅助工具的需求，并制定一个它们可以使用的
    API。***'
- en: '***There’s already the standard a11y interfaces, and those should mostly work
    already - so there’s that. Could be better, but they mostly work.***'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: '***已经存在标准的 a11y 接口，大部分应该已经可以正常工作 - 就是这样。可能还有改进的空间，但它们大部分都可以工作。***'
- en: '***Accessibility in general is in a bit of a sad state on Linux right now,
    but thankfully people like [Lukáš Tyrychtr](https://gitlab.gnome.org/tyrylu) and
    [Tait Hoyem](https://tait.tech/) are helping to improve that.***'
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: '***Linux 上的普遍辅助功能现状有些令人失望，但幸运的是，像[Lukáš Tyrychtr](https://gitlab.gnome.org/tyrylu)和[Tait
    Hoyem](https://tait.tech/)这样的人正在帮助改进这一状况。***'
- en: '***Common complaints[](#common-complaints)***'
  id: totrans-split-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***常见的投诉[](#common-complaints)***'
- en: '***Inevitably, someone is going to complain that *something* doesn’t work.
    So here’s what’s basically a FAQ of issues with explanations and tips.***'
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: '***总会有人抱怨*某事*不能正常工作。因此，这里基本上是一个包含解释和提示的常见问题解答。***'
- en: '***Screen recording: already working. Chrome and Firefox support it, OBS works,
    and Electron just needs apps to update to the newer versions and for a few minor
    kinks to be worked out. Most apps just need to update their toolkits. If an app
    you’re using doesn’t work with it, chances are you can work around it by using
    it in the browser.***'
  id: totrans-split-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***屏幕录制已经可以使用。Chrome 和 Firefox 支持它，OBS 已经可以工作，而 Electron 只需应用程序更新到较新版本并解决一些小问题即可。大多数应用程序只需更新其工具包。如果你使用的应用程序无法与其配合使用，有可能通过在浏览器中使用它来解决。***'
- en: '***Screen tearing: already has the appropriate protocols available, and there
    are a number of issues tracking support for it. All that’s needed now is for the
    kernel drivers to support it.***'
  id: totrans-split-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***屏幕撕裂已经具备了适当的协议，并且有多个问题在跟踪其支持。现在只需要内核驱动程序支持它。***'
- en: '***X-specific tooling: Not even gonna. X-specific tooling is X-specific, not
    Wayland-specific or generic. You’d do better to make Wayland-specific tooling,
    or something that works on both. But don’t expect xrandr or xeyes to work on Wayland.***'
  id: totrans-split-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***X 特定的工具：甭想了。X 特定的工具就是 X 特定的，不是 Wayland 特定或通用的。你最好制作 Wayland 特定的工具，或者能在两者上都能工作的东西。但别指望
    xrandr 或 xeyes 能在 Wayland 上工作。***'
- en: '***Barrier/Synergy/remote desktop: done, and support has already been added
    to GNOME and xdg-desktop-portal. A Wayland protocol for wlroots to build on top
    of is TODO. Remote desktop, specifically, has already been working for quite a
    while now, and it got some improvements thanks to the InputCapture portal (that
    Barrier/Synergy use).***'
  id: totrans-split-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Barrier/Synergy/远程桌面：已完成，并且已经在 GNOME 和 xdg-desktop-portal 中添加了支持。Wayland
    协议待办事项中会构建在 wlroots 之上。特别是远程桌面，已经有一段时间可以使用了，并且得益于 InputCapture portal（Barrier/Synergy
    使用的那个），它得到了一些改进。***'
- en: '***Global keybinds: there’s already an [available portal](https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.GlobalShortcuts)
    for that.***'
  id: totrans-split-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***全局快捷键：已经有一个[可用的门户](https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.GlobalShortcuts)可以处理。***'
- en: '***Network transparency: use [WayPipe](https://gitlab.freedesktop.org/mstoeckl/waypipe).
    Wayland, as a protocol, has no business supporting network transparency. That
    same idea also applies to many other features X11 has that *Wayland* doesn’t.***'
  id: totrans-split-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***网络透明性：使用[WayPipe](https://gitlab.freedesktop.org/mstoeckl/waypipe)。Wayland作为一个协议，并不需要支持网络透明性。X11有很多Wayland没有的功能，同样的想法也适用于其他许多功能。***'
- en: '***Also, please think about if your feature is something *Wayland* needs to
    handle; in most cases, it isn’t. It’s not Wayland’s job to tell compositors how
    their window management works, or define how the compositor as a whole is implemented.
    And it’s not proper to push the workflow from one compositor onto another - they’re
    different compositors, with different workflows, different designs, different
    ideologies. If you don’t like how something works, DIY it so that it’s fit to
    your tastes.***'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: '***另外，请考虑你的功能是否是Wayland需要处理的；在大多数情况下，它并不是。Wayland不需要告诉合成器如何管理它们的窗口，或者定义合成器作为整体如何实现。将一个合成器的工作流程推到另一个合成器上也不合适——它们是不同的合成器，具有不同的工作流程、设计和意识形态。如果你不喜欢某些功能的工作方式，自己动手让它符合你的口味。***'
- en: '***Conclusion[](#conclusion)***'
  id: totrans-split-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***结论[](#conclusion)***  '
- en: '***You could *probably* add all (well, most) of these to Xorg, but not without
    some pretty fundamental changes, rewrites, and extensions. At that point…. you’ve
    just made another Wayland. So don’t even *try* to argue that you can just “improve
    Xorg”. You can’t. The best you’ll get is Xwayland, which barely even functions
    as-is. You’ve already seen, and been told, just how much of a sinking (more like
    an already sunk) boat that the X ecosystem is.***'
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: '***你可能可以向Xorg中添加所有（或者大多数）这些功能，但那要经历一些根本性的变化、重写和扩展。到那时……你已经只是又做了一个Wayland。所以甚至不要试图争论你可以“改进Xorg”。你不能。你最好的选择只是得到Xwayland，它甚至几乎不能正常工作。你已经看到，并且被告知，X生态系统已经沉没得多（更像是已经沉没的船）。***'
- en: '***It’s perfectly valid if you’re staying on Xorg because some features don’t
    quite work just yet, *especially* when it comes to accessibility. But that ship
    can only keep floating for so long. Try out Wayland every once in a while if it
    doesn’t work for you, and keep an eye on the relevant discussions. You’ll have
    to use it eventually, so get used to it. If you can’t live with it as-is, try
    and improve the situation so you *can*. Toss a few bucks to your local FOSS developer.
    Learn how to file issues. Improve things where you can, and make it so *others*
    can improve it where *you* can’t.***'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: '***如果你仍然选择使用Xorg是完全合理的，因为一些功能目前可能还不太完善，特别是在辅助功能方面。但这艘船也只能浮在水面上那么久。偶尔试试Wayland，如果对你不起作用的话，并且关注相关讨论。最终你将不得不使用它，所以适应它。如果你无法接受现状，试着改进情况以便你可以接受。给你本地的自由开源软件开发者捐几块钱。学习如何提交问题。在你能力所及的地方改进事物，让其他人可以在你力所不能及的地方改进。***'
- en: '***I think I’ll end this off with:***'
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: '***我想我会以这个结束：***'
- en: '***Xorg: it’s all hacks, and not all of them work.***'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: '***Xorg：这全都是hack，而且不是所有的hack都有效。***'
