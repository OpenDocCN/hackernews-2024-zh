- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 15:04:52'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 15:04:52'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Oh Sh*t, My App is Successful and I Didn’t Think About Accessibility
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哎呀，我的应用很成功，但我没有考虑到可访问性。
- en: 来源：[https://jacobbartlett.substack.com/p/oh-sht-my-app-is-successful-and-i](https://jacobbartlett.substack.com/p/oh-sht-my-app-is-successful-and-i)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://jacobbartlett.substack.com/p/oh-sht-my-app-is-successful-and-i](https://jacobbartlett.substack.com/p/oh-sht-my-app-is-successful-and-i)
- en: When you have a genius app idea, a brand-new job, or a fresh injection of venture
    capital, the temptation to tunnel-vision on shipping new features can be overwhelming.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个天才的应用创意、一份全新的工作或者一笔新的风险投资时，只专注于发布新功能的诱惑可能会无法抵挡。
- en: If you play your cards right, this focus pays off, rocketing your app to the
    top of the download charts. *Not good enough.*You won’t stop until *everybody*
    is using your app.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做得聪明，这种专注将带来回报，将你的应用推向下载榜的顶端。*这还不够好*。直到*每个人*都在使用你的应用之前，你都不会停止。
- en: 'Upon achieving this absurd milestone, you realise a hard truth: 1 in 6 users
    think your app is broken.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 达到这个荒谬的里程碑后，你意识到一个残酷的事实：6 个用户中有 1 个认为你的应用有问题。
- en: Then it hits you.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你突然领悟到。
- en: Oh shit.
  id: totrans-split-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哎呀。
- en: My app is successful and I didn’t think about accessibility.
  id: totrans-split-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我的应用很成功，但我没有考虑到可访问性。
- en: 16% of people have some kind of accessibility (*a11y* if you’re one of the cool
    kids) requirement. But when you’re flying by the seat of your pants, it’s easy
    to let a11y fall by the wayside — particularly when surrounded by deadlines, with
    limited buy-in from leadership.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 16% 的人有某种形式的可访问性要求（如果你是潮流的一员就叫做 a11y）。但当你处于繁忙的工作期限中，并且领导层的支持有限时，很容易让 a11y 被忽视。
- en: The more successful you become, the worse you’re perceived for failing to acknowledge
    the a11y needs of your users. This is, unfortunately, hard to prioritise without
    somebody influential championing a11y.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你越成功，你就越被认为是因为未能承认用户对 a11y 的需求而被批评。不幸的是，没有有影响力的人支持 a11y，这很难成为优先事项。
- en: 'Today, I’m going to help. I’ll demonstrate how you can get your app up to speed
    with accessibility, and **fast**:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我来帮忙。我将演示如何快速提高应用的无障碍性能：
- en: Audit a11y in your SwiftUI app.
  id: totrans-split-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审核你的 SwiftUI 应用的 a11y。
- en: Get the app looking good at all text scales.
  id: totrans-split-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使应用在所有文字缩放下看起来都很好。
- en: Make the app useable for screen-readers.
  id: totrans-split-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使应用能够被屏幕阅读器使用。
- en: Convince stakeholders to prioritise a11y.
  id: totrans-split-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说服利益相关者优先考虑 a11y。
- en: We’re going to look at a [dead simple, cat-themed, companion app](https://github.com/jacobsapps/oh-shit-a11y)
    I created especially for this article. An app which looks fine on the surface
    but, as soon as you start evaluating it from an a11y perspective, is *utterly
    broken*.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看我专门为这篇文章创建的一个[超级简单的、以猫为主题的伴侣应用](https://github.com/jacobsapps/oh-shit-a11y)。这款应用在表面上看起来很好，但一旦你从
    a11y 的角度进行评估，就会*彻底失败*。
- en: If you want to fully understand the techniques, **code along too!** Start from
    the `Before/` folder as we implement all the techniques detailed in this article
    (look at `After/` for the final, improved, app).
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想完全理解这些技术，**也可以跟着编码！** 从`Before/`文件夹开始，因为我们会在这篇文章中详细介绍所有的技术（查看`After/`获取最终改进的应用）。
- en: To get a proper feel for a11y, you should always test accessibility on a real
    device, as this is how all your users interact with your app.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正了解 a11y，你应该在真实设备上测试可访问性，因为这是所有用户与你的应用交互的方式。
- en: With any work on a11y, you should first optimise Control Center. *Seriously*,
    this is a massive timesaver.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何 a11y 的工作中，你应该首先优化控制中心。*真的*，这能大大节省时间。
- en: Go to iPhone Settings → Control Center. Add the Text Size control and Accessibility
    Shortcuts. Text Size allows you to swipe down from anywhere in any app, and immediately
    select a text scaling to apply — you can even apply sizings on a per-app basis.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 iPhone 设置 → 控制中心。添加文字大小控制和无障碍快捷方式。文字大小允许你从任何应用的任何地方向下滑动，并立即选择要应用的文本缩放 ——
    你甚至可以按应用程序的基础应用大小来应用大小。
- en: Modify Control Centre to include text sizing
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 修改控制中心以包含文字大小调整
- en: Accessibility shortcuts allow you to apply various a11y features on-the-fly,
    such as AssistiveTouch, VoiceOver, Colour Filters, and Reducing Motion. This is,
    however, probably easier to access by **triple-pressing the lock button**, which
    presents the same menu as an action sheet.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无障碍快捷方式允许你即时应用各种 a11y 功能，如辅助触控、VoiceOver、色彩过滤和减少动态效果。然而，**三次按锁定按钮**可能更容易访问，它显示与操作表相同的菜单。
- en: There are 12 possible text sizes in iOS, from `extraSmall` to `accessibilityExtraExtraExtraLarge`
    (aka `AX5`), which is approximately 310%* larger than the default (`large`).
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 有12种可能的文本大小，从`extraSmall`到`accessibilityExtraExtraExtraLarge`（也称为`AX5`），后者大约比默认的`large`字体大310%。
- en: '*this is the scaling of `body` font, however different system text sizes scale
    by different amounts, for example a `largeTitle` is already quite big, so will
    not scale up as much as a `caption`, which is tiny.'
  id: totrans-split-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这是`body`字体的缩放，但是不同系统的文本大小按不同比例缩放，例如`largeTitle`已经相当大，因此不会像`caption`那样缩放得那么多。'
- en: This will be important later on!
  id: totrans-split-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这一点以后会变得很重要！
- en: 'To make sure text sizes work, I like to run two audits:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保文本大小适用，我喜欢进行两项审计：
- en: Test the app on the largest non-a11y font, `extraExtraExtraLarge` (aka `xxxl`),
    ideally with the *Bold Text*accessibility setting enabled too. This is the biggest
    relatively common font, and also what my mum uses. The app should look *good*
    at this size.
  id: totrans-split-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最大非无障碍字体`extraExtraExtraLarge`（也称为`xxxl`）上测试应用，最好还启用*Bold Text*辅助设置。这是相对常见的最大字体，并且也是我妈妈使用的字体。应用在这个尺寸下应该看起来*很好*。
- en: Test the app on the largest a11y font, `AX5`. While, if you’re not used to it,
    it might look comically large, there are people for whom this is *the only way*
    they can interact with your app. While it’s tough to make the UI look perfect
    at this size, it’s blindingly obvious when a company hasn’t even checked if the
    app works at accessibility text scalings.
  id: totrans-split-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最大的a11y字体`AX5`上测试应用。如果你不习惯，可能会觉得看起来太大，但对于一些用户来说，这是他们唯一与你的应用交互的方式。虽然在这个尺寸上完美展现UI很困难，但如果一个公司连检查应用是否适用于无障碍文本缩放都懒得做，那就显而易见了。
- en: Let’s run through our app.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来运行一下我们的应用。
- en: Auditing my login screen with large (default), xxxLarge (and bold), and AX5
    text scalings
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 用大（默认）、xxxLarge（和粗体）和AX5文本缩放审计我的登录界面。
- en: Immediately, we find that our painstakingly crafted login UI falls flat on its
    face when we apply text scaling. We were sloppy, and we didn’t anticipate larger
    text sizes — so never thought to make the content scrollable.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻发现，我们精心设计的登录界面在应用文本缩放时失败了。我们做得太草率了，没有预料到更大的文本尺寸——所以从未考虑过使内容可滚动。
- en: What’s more? Somebody with colourblindness would not be able to read that login
    button, since the contrast is miniscule.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是？有色盲的人可能无法阅读登录按钮，因为对比度微乎其微。
- en: Let’s also check out look at the main list screen of our app.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也来看看我们应用的主列表界面。
- en: Auditing my list screen with large (default), xxxLarge (and bold), and AX5 text scalings
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用大（默认）、xxxLarge（和粗体）和AX5文本缩放审计我的列表界面。
- en: This one is less ‘broken’, in that you can see everything, but it’s clear to
    anybody using an accessibility-sized font that you didn’t bother testing the app
    at this size — just look at the text labels warring for space, or that tiny ❤
    icon next to a massive caption.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相对来说不那么‘坏’，因为你可以看到所有内容，但是对于使用较大字体的人来说，很明显你没有在这个尺寸上进行测试——只需看看文本标签争夺空间，或者那个微小的❤图标与巨大的标题。
- en: Some of our users are unaffected by text scaling — since they may require a
    screenreader to interact with your app.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些用户不受文本缩放影响——因为他们可能需要屏幕阅读器来与你的应用交互。
- en: iOS VoiceOver does an incredible job handling the heavy lifting here, so a little
    bit of thoughtfulness from your team goes a long way.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: iOS VoiceOver在这里处理繁重工作做得非常好，因此你的团队稍加思考就会大有帮助。
- en: Screenreader audits, like text size audits, are also best done on a real device
    (press the lock button 3 times, remember!). There is also a developer tool built
    into Xcode which helps with VoiceOver— the Accessibility Inspector.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕阅读器审计，如文本大小审计，最好在真实设备上完成（按锁定按钮3次，记住！）。Xcode中还有一个开发者工具内置的无障碍检查器，可以帮助使用VoiceOver。
- en: Finding the Accessibility Inspector developer tool in Xcode
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode中找到无障碍检查器开发者工具。
- en: Walking through the app, it’s less offensively broken compared to the text scaling,
    but large areas of the UI like our images are entirely invisible to our users
    because we didn’t bother to add accessibility labels.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览应用时，相比于文本缩放，它的问题没有那么严重，但是我们的一些UI大面积区域，比如我们的图像，对我们的用户来说完全看不见，因为我们没有添加无障碍标签。
- en: I’m intentionally using hostile language here, because this is how your app
    is going to be perceived by users you left behind. Hostile.
  id: totrans-split-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在这里故意使用了敌对的语言，因为这就是用户会如何看待你的应用的原因。敌对。
- en: Screen-reading the login screen tries it’s best, giving the name of the image resource
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕阅读登录界面尽其所能，显示图像资源的名称。
- en: It’s doubly clear when somebody hasn’t been thoughtful thought about VoiceOver
    when every single UI element is iterated through by the screen-reader, including
    unlabelled icons.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当某人没有考虑到 VoiceOver 时，每个 UI 元素都由屏幕阅读器逐个迭代，包括未标记的图标，这一点变得格外清晰。
- en: Lazy use of a screenreader ends up listing every UI element individually
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕阅读器的懒惰使用会导致每个 UI 元素被单独列出。
- en: The situation gets worse with a big list.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当有一个大列表时，情况变得更糟。
- en: If you don’t give SwiftUI information about your content, you can end up with
    a situation where it takes 100s of swipes to move to the logout button at the
    bottom of your scrollable content. And *don’t get me started* on paging.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不给 SwiftUI 提供关于你的内容的信息，可能会出现这样一种情况：要移动到可滚动内容底部的注销按钮，需要滑动数百次。而且*别让我开始*分页问题。
- en: With many items, it takes a very long time to get to the bottom of the content.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多项目，要到内容底部需要很长时间。
- en: It’s clear we’ve got a fair few issues to solve before we can call our app accessible.
    Fortunately, SwiftUI is packed to the gills in tools that allow you to get up
    to speed on a11y extremely fast.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在我们能称我们的应用程序是可访问的之前，我们需要解决相当多的问题。幸运的是，SwiftUI 中提供了丰富的工具，可以让您迅速掌握 a11y 相关知识。
- en: Now we know where the problems are, we can start to address them one by one.
    And quickly.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道问题出在哪里，我们可以开始逐个解决它们。而且速度很快。
- en: This is the most offensive issue — my app onboarding is completely broken, since
    the content doesn’t expand into a scroll view on larger text sizes.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最令人反感的问题 —— 我的应用程序入门完全出问题了，因为内容在更大的文本尺寸上没有展开成滚动视图。
- en: In our audit, the button for our login screen was pushed offscreen as font size
    increased. The rest of the text content strained against each other, labels overlapping
    and truncating as they had no room to expand.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的审核中，登录界面的按钮在字体大小增加时被推到屏幕外。其余文本内容相互紧贴，标签重叠并因无法扩展而截断。
- en: The natural solution is to make the content scrollable. But we don’t want to
    haphazardly allow every single screen to scroll when the content fits fine. We
    aren’t in the business of building Ionic apps **shudders with repressed memories**.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 自然的解决方案是使内容可滚动。但是我们不想让每个屏幕的内容都在内容适合的情况下随意滚动。我们不从事构建 Ionic 应用的业务 **由于被压抑的回忆而颤抖**。
- en: This issue can be addressed with a custom view modifier, what I call the `a11yScrollView()`.
    The goal of this view modifier is to wrap content in a scroll view, but only if
    it *needs* to — content only becomes scrollable if it doesn’t fit. I’ve added
    it to a small library, [A11yUtils](https://github.com/jacobsapps/A11yUtils/blob/main/Sources/A11yUtils/A11yScrollView.swift),
    so you can use it in your own code.
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过自定义视图修饰符解决这个问题，我称之为`a11yScrollView()`。这个视图修饰符的目标是在内容需要时将内容包裹在滚动视图中 —— 只有当内容不适合时才会变得可滚动。我已经将其添加到一个小型库[A11yUtils](https://github.com/jacobsapps/A11yUtils/blob/main/Sources/A11yUtils/A11yScrollView.swift)，这样您可以在自己的代码中使用它。
- en: Right now, this only achieves our dream behaviour in iOS 16.4 and above — applying
    `scrollBounceBehavior` to the scroll view to prevent it from scrolling if the
    content fits already.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这仅在 iOS 16.4 及以上版本中实现了我们梦想中的行为 —— 将`scrollBounceBehavior`应用于滚动视图，以防止如果内容已适合则无法滚动。
- en: xIn the future, I’d like to make it work with `ViewThatFits*` for iOS 16 and
    `GeometryReader` for iOS 15.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我希望使其与 iOS 16 的`ViewThatFits*`和 iOS 15 的`GeometryReader`配合使用。
- en: '**[Feel free to submit a pull request!](https://github.com/jacobsapps/A11yUtils/tree/main)**'
  id: totrans-split-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[随时提交拉取请求！](https://github.com/jacobsapps/A11yUtils/tree/main)**'
- en: Since nobody is around to demand which OS version I target, I can apply this
    modifier to the `VStack` in our onboarding view.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 既然没人在身边要求我针对哪个操作系统版本进行目标，我可以将此修饰符应用于我们入门视图中的`VStack`。
- en: '[PRE0]'
  id: totrans-split-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, the content scrolls nicely — looking good across `xxxl`, `AX3`, and `AX5`.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，内容可以很好地滚动 —— 在`xxxl`，`AX3`和`AX5`上看起来不错。
- en: Our content now scrolls on all text scalings. For good measure, I fixed the
    contrast on the Log In button
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内容现在在所有文本缩放上都可以滚动。为了保险起见，我修复了登录按钮的对比度。
- en: '*In my experience, the `ViewThatFits` approach works nicely, but has problems
    with text entry — the software keyboard actually changes the size of the view,
    causing the content to resize and the layout engine to redraw the content. If
    a `@FocusState` toggles the keyboard on appearance, this leads to an infinite
    redrawing and resizing loop!'
  id: totrans-split-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*根据我的经验，`ViewThatFits`方法效果不错，但在文本输入方面存在问题 —— 软键盘实际上会更改视图的大小，导致内容重新调整大小和布局引擎重绘内容。如果`@FocusState`在出现时切换键盘，这将导致无限重绘和调整大小的循环！'
- en: 'While we’re working on the onboarding screen, there’s another simple improvement
    we can make:'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们正在处理入门屏幕时，还有另一个简单的改进可以做：
- en: '[PRE1]'
  id: totrans-split-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When text size is large, limiting screen real estate, `Spacer()` can cause issues.
    The SwiftUI layout engine will diligently attempt to create space, even if there
    is no room for it, which can lead to your text getting truncated.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本大小较大时，限制屏幕实际空间时，`Spacer()` 可能会导致问题。SwiftUI 布局引擎将尽力创建空间，即使没有空间，也会导致文本被截断。
- en: In this scenario, even with the spacer compressed to a very narrow height, there
    will be 20 points above and below, as defined in our `VStack`.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使将 spacer 压缩到非常窄的高度，`VStack` 中定义的上下都会有 20 个点。
- en: 'We can swap out the `Spacer()` for a `frame()` modifier:'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `Spacer()` 替换为 `frame()` 修饰符：
- en: '[PRE2]'
  id: totrans-split-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Frames behave in a more reliable manner: SwiftUI knows to give as much space
    as possible above this button, however it is clear that the space itself isn’t
    a critical part of the UI, so no unnecessary spacing is applied if there isn’t
    room.'
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的行为更可靠：SwiftUI 知道在此按钮上方尽可能提供尽可能多的空间，但很明显，空间本身并不是 UI 的关键部分，因此如果没有空间，就不会应用不必要的间距。
- en: This frame modifier has a clearer *semantic* meaning — that is, it makes our
    intent clear to SwiftUI. This is a critical concept to understand when it comes
    to a11y, so we’ll cover it more later on.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `frame` 修饰符有一个更明确的*语义*意义 — 即，它让我们在 SwiftUI 中的意图变得清晰。这在讨论 a11y 时是一个关键概念，我们稍后会详细介绍。
- en: Thanks to dynamic type, iOS will scale the font in our app automatically based
    on the user’s chosen font size. This is also pretty straightforward to implement
    with a [custom font](https://developer.apple.com/documentation/uikit/text_display_and_fonts/adding_a_custom_font_to_your_app).
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动态类型，iOS 将根据用户选择的字体大小自动调整我们应用中的字体。这在使用[自定义字体](https://developer.apple.com/documentation/uikit/text_display_and_fonts/adding_a_custom_font_to_your_app)时也相当直观易懂。
- en: This means when we use semantic font sizes in SwiftUI, text will automatically
    scale.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们在 SwiftUI 中使用语义字体大小时，文本将自动缩放。
- en: '[PRE3]'
  id: totrans-split-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even better, when sticking to SFSymbols, we can get dynamic type on our icons!
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，当坚持使用 SFSymbols 时，我们可以在我们的图标上获得动态类型！
- en: '[PRE4]'
  id: totrans-split-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unfortunately, most iOS apps tend to have an Android counterpart, which means
    your designer will be creating custom icons rather than allowing you to use SFSymbols
    everywhere. Most apps will also include custom images and media.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大多数 iOS 应用程序往往有对应的 Android 版本，这意味着您的设计师将创建自定义图标，而不是让您在各处使用 SFSymbols。大多数应用程序还将包含自定义图像和媒体。
- en: Therefore, for our `Before/` example, I’ve treated the icon like any regular
    image we’d add to SwiftUI, using a hardcoded size.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的 `Before/` 示例中，我把这个图标看作是我们在 SwiftUI 中添加的任何常规图像，使用了硬编码大小。
- en: '[PRE5]'
  id: totrans-split-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The result? At the largest font scaling, the content looks very mismatched.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是？在最大的字体缩放下，内容看起来非常不匹配。
- en: Images and icons with a fixed size look strange on larger text scalings
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图像和固定大小的图标在较大的文本缩放下看起来很奇怪。
- en: 'SwiftUI has a nifty tool that gives us the power of dynamic type in our custom
    images and views: the `@ScaledMetric`property wrapper.'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 提供了一个巧妙的工具，使我们可以在自定义图像和视图中使用动态类型：`@ScaledMetric` 属性包装器。
- en: '[PRE6]'
  id: totrans-split-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can use `@ScaledMetric` on its own, which uses the default `body` font scaling.
    It’s even better to use `relativeTo` so SwiftUI knows how to scale it.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以单独使用 `@ScaledMetric`，它使用默认的 `body` 字体缩放。最好使用 `relativeTo`，这样 SwiftUI 就知道如何缩放它。
- en: '`largeTitle` scales a little bit, since it’s already quite large. A `caption`
    style font scales up far more. In this instance, the icon has `body` scaling so
    it matches the accompanying quote text.'
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`largeTitle` 字体尺寸略有缩放，因为它已经相当大了。`caption` 样式的字体尺寸会大得多。在这个例子中，图标的 `body` 缩放使其与伴随的引用文本匹配。'
- en: '[PRE7]'
  id: totrans-split-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, our images look a lot more sensible alongside the text.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的图像在文本旁边看起来更合理。
- en: Image scaling using @ScaledMetric
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @ScaledMetric 进行图像缩放
- en: The images scale better, however our UI is still clearly broken, with the text
    labels vying for space. After exhaustive negotiations with the layout engine,
    they end up full of line breaks.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图像缩放得更好，但我们的 UI 仍然明显有问题，文本标签争夺空间。在与布局引擎进行详尽的协商后，它们最终充满了换行符。
- en: '**What if we could align content based on a user’s text scaling?**'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果我们能够根据用户的文本缩放来对齐内容会怎样？**'
- en: Fortunately, thanks to my library [A11yUtils](https://github.com/jacobsapps/A11yUtils/blob/main/Sources/A11yUtils/A11yHStack.swift),
    we can utilise an `A11yHStack`.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，多亏了我的库 [A11yUtils](https://github.com/jacobsapps/A11yUtils/blob/main/Sources/A11yUtils/A11yHStack.swift)，我们可以利用
    `A11yHStack`。
- en: 'Due to the blistering pace of new SwiftUI tool releases (and Apple’s crappy
    back-porting), this also has a couple of different implementations based on your
    minimum supported OS:'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SwiftUI工具的快速发布速度（以及苹果糟糕的向后兼容性），基于您的最低支持的操作系统，这也有一些不同的实现：
- en: On `iOS 16`, it uses `ViewThatFits` to check whether the `HStack` can contain
    all the content, and if not, uses a `VStack`to arrange the content instead.
  id: totrans-split-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`iOS 16`上，它使用`ViewThatFits`来检查`HStack`是否能容纳所有内容，如果不能，则使用`VStack`来重新排列内容。
- en: On `iOS 15`, it applies a more blunt approach, checking `@Environment(\.sizeCategory)`,
    and switching to a `VStack` if an accessibility text size category (such as `AX1`,
    `AX2`, or `AX5`) is used.
  id: totrans-split-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`iOS 15`上，它采用了更直接的方法，检查`@Environment(\.sizeCategory)`，并在使用辅助功能文本大小类别（如`AX1`、`AX2`或`AX5`）时切换到`VStack`。
- en: 'Here’s the simple approach:'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的方法：
- en: '[PRE8]'
  id: totrans-split-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `@Environment(\.sizeCategory)` is a useful tool to know about, in the cases
    where it’s important to know whether an a11y text size category is being used
    (with `isAccessibilityCategory`). Sometimes, I use this property to remove unnecessary
    UI elements such as images which simply don’t fit at massive content sizes.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Environment(\.sizeCategory)`是一个有用的工具，在需要知道是否使用辅助功能文本大小类别（使用`isAccessibilityCategory`）的情况下特别重要。有时，我使用这个属性来移除在大文本尺寸下根本不适合的不必要的UI元素，比如图片。'
- en: 'The more modern implementation works similarly but utilises `ViewThatFits`,
    so content is only re-distributed if it doesn’t fit:'
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更现代的实现方式类似，但利用了`ViewThatFits`，因此只有当内容不适合时才会重新分配：
- en: '[PRE9]'
  id: totrans-split-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we’re thoughtful, we can apply `A11yHStack` in a few places:'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们深思熟虑，我们可以在几个地方应用`A11yHStack`：
- en: '[PRE10]'
  id: totrans-split-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now our content looks much more sensible on very large text sizes.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的内容在非常大的文本大小上看起来更合理了。
- en: Utilising A11yHStack for our content in the List cells.
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表单元中使用A11yHStack来利用我们的内容。
- en: 'Another small warning: make sure you test on all supported iOS versions, as
    I’ve found the `ViewThatFits`approach to give behaviour I wasn’t expecting. When
    getting started, you may have an easier time re-implementing the `@Environment(\.sizeCategory)`
    approach.'
  id: totrans-split-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个小的警告：确保在所有支持的iOS版本上进行测试，因为我发现`ViewThatFits`方法会产生我意料之外的行为。在开始时，重新实现`@Environment(\.sizeCategory)`方法可能会更容易些。
- en: VoiceOver is a reasonably straightforward piece of the puzzle.
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: VoiceOver是解决难题的一个相当简单的部分。
- en: 'Making your app play well with a screenreader means:'
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的应用与屏幕阅读器良好兼容意味着：
- en: Making sure visual content is adequately described.
  id: totrans-split-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保视觉内容得到充分描述。
- en: Making navigation work intuitively.
  id: totrans-split-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使导航工作更直观。
- en: Ensuring our view makes *semantic* sense.
  id: totrans-split-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们的视图具有*语义*意义。
- en: 'Let’s start with visual descriptions. This is the simplest fix in our repertoire:
    ensuring our graphical content can be described by VoiceOver. The `accessibilityLabel`
    modifier is our bread and butter.'
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从视觉描述开始。这是我们工具箱中最简单的修复措施：确保我们的图形内容可以被VoiceOver描述。`accessibilityLabel`修饰符是我们的基本工具。
- en: '[PRE11]'
  id: totrans-split-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This tells the screenreader how to explain what it’s currently focused on.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉屏幕阅读器如何解释它当前聚焦的内容。
- en: Applying an accessibilityLabel to the onboarding image
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为引导图像应用accessibilityLabel
- en: Next, we can apply the same approach on our main view’s cells. With a small
    modification to our `Cat` data model, we supply an image description alongside
    each cat’s photo.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在主视图的单元上应用相同的方法。通过对我们的`Cat`数据模型进行小的修改，我们为每只猫的照片提供图像描述。
- en: '[PRE12]'
  id: totrans-split-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is as easy as it sounds, and tends to *just work* on Apple platforms.
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点听起来很容易，并且在苹果平台上*只是起作用*。
- en: Applying voiceover descriptions to all our images via the data model
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数据模型为所有图像应用VoiceOver描述
- en: When it comes to navigation through our app, we have the opportunity to be more
    thoughtful. By default, VoiceOver will iterate through every leaf node in the
    SwiftUI view tree and read out all our `Image`s, `Button`s, and `Text`.
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到通过我们的应用进行导航时，我们有机会更加周到。默认情况下，VoiceOver将遍历SwiftUI视图树中的每个叶子节点，并朗读所有我们的`Image`、`Button`和`Text`。
- en: Sometimes, this causes lots of unnecessary navigation for the user. In our app,
    we force users to tap multiple times to navigate past the icon and quote for each
    cat. Reading out the icon’s name (such as `cat.fill`) adds nothing to the experience.
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这会导致用户进行许多不必要的导航。在我们的应用中，我们强制用户点击多次才能导航到每只猫的图标和引用。朗读图标的名称（如`cat.fill`）对体验毫无帮助。
- en: We can combine these together as a single a11y element using the `accessibilityElement(children:)`
    modifier, so the screenreader can treat them as one item when navigating through.
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它们结合在一起作为一个单一的无障碍元素使用 `accessibilityElement(children:)` 修饰符，这样屏幕阅读器在导航时可以将它们视为一个项目。
- en: '[PRE13]'
  id: totrans-split-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can hear the screenreader move through the elements as one item:'
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以听到屏幕阅读器将元素作为一个项目移动：
- en: Combining VoiceOver UI elements together using accessibilityElement(children:)
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `accessibilityElement(children:)` 结合 VoiceOver UI 元素
- en: In some situations, you might have a really complicated UI, such as a [stylised
    timer element which graphically ticks down](https://jacobbartlett.substack.com/i/141732200/image-loading-bug).
    VoiceOver is smart, but it isn’t going infer anything useful from a fancy collection
    of unexplained views.
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能会有一个非常复杂的 UI，例如一个[图形化倒计时的风格化计时器元素](https://jacobbartlett.substack.com/i/141732200/image-loading-bug)。VoiceOver
    很聪明，但它无法从一堆未解释的视图中推断出任何有用的信息。
- en: This is where the `accessibilityRepresentation` modifier comes in really useful.
    It allows you to replace a view’s VoiceOver UI with a fully customised a11y representation.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `accessibilityRepresentation` 修饰符非常有用的地方。它允许您用完全定制的无障碍表示替换视图的 VoiceOver
    UI。
- en: 'This was particularly useful for my latest indie project, [Check ’em](https://jacobbartlett.substack.com/p/building-a-2fa-app-that-detects-patterns),
    where a user’s 2FA codes were displayed with a countdown:'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我最新的独立项目 [Check ’em](https://jacobbartlett.substack.com/p/building-a-2fa-app-that-detects-patterns)
    特别有用，用户的 2FA 代码显示为倒计时：
- en: '[PRE14]'
  id: totrans-split-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This modifier allowed me to introduce a fully custom VoiceOver interface, which
    was far more useful than iterating through each element of the cell in sequence.
    It also prevented the screenreader reading 676,252 as *six hundred and seventy-six
    thousand, two hundred and fifty-two.*
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此修饰符使我能够引入一个完全定制的 VoiceOver 界面，比按顺序迭代单元格的每个元素要有用得多。它还防止屏幕阅读器将 676,252 读作 *六十七万六千二百五十二*。
- en: accessibilityRepresentation modifier used in Check ’em, my indie project
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Check ’em 中使用的 accessibilityRepresentation 修饰符，我的独立项目
- en: 'The main view of this app uses a common, but sloppy, approach to laying out
    our content: wrapping our cells inside a `ForEach`, wrapped in a `LazyVStack`,
    wrapped in a `ScrollView`.'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用的主视图采用了常见但松散的布局方法：将我们的单元格包裹在 `ForEach` 中，再包裹在 `LazyVStack` 中，最后包裹在 `ScrollView`
    中。
- en: '[PRE15]'
  id: totrans-split-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The optimal approach is to **utilise native SwiftUI components wherever possible**.
    In this instance, a `List` is most appropriate.
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最佳方法是**尽可能使用原生 SwiftUI 组件**。在这种情况下，使用 `List` 是最合适的。
- en: Apple makes this a smidgen harder than it needs to be — inexplicably, to use
    our own custom UI rather than the iOS-Settings-styled `List`, we need to add 3
    separate modifiers.
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果使得这比必要的要困难一些 —— 令人费解的是，要使用我们自己的自定义 UI 而不是 iOS 设置风格的 `List`，我们需要添加 3 个单独的修饰符。
- en: '[PRE16]'
  id: totrans-split-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With that boilerplate out of the way, the modifiers now allow us to freely use
    our own UI in a SwiftUI `List`.
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些样板文件，修饰符现在允许我们在 SwiftUI 的 `List` 中自由使用我们自己的 UI。
- en: Default List (left) and our custom List (right) that used .listStyle and .listRow
    modifiers
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认列表（左）和我们自定义列表（右）使用了 .listStyle 和 .listRow 修饰符
- en: One question.
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题。
- en: '**Why go to all this extra trouble to use a native component? **'
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么要费这么大劲去使用本地组件？**'
- en: 'Firstly, the non-a11y reason: SwiftUI `List` is implemented using a `UICollectionView`.
    This utilises cell reuse for high performance scrolling, even if you have many
    items. Conversely, `LazyVStack` keeps all previously-rendered cells in memory,
    meaning your performance nosedives if you’re scrolling through many items.'
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，非无障碍原因：SwiftUI 的 `List` 是使用 `UICollectionView` 实现的。这利用了单元格复用来实现高性能滚动，即使有很多项也不例外。相反，`LazyVStack`
    将所有先前渲染的单元格保留在内存中，这意味着如果您滚动许多项，性能将急剧下降。
- en: 'This information comes courtesy of [Thomas Ricouard](https://medium.com/u/b067c9115d59)
    and friends; read [SwiftUI: The difference between List and LazyVStack](https://dimillian.medium.com/swiftui-the-difference-between-list-and-lazyvstack-3d5eeaccb156)
    to learn more!'
  id: totrans-split-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '这些信息来自 [Thomas Ricouard](https://medium.com/u/b067c9115d59) 和他的朋友们；阅读 [SwiftUI:
    List 与 LazyVStack 的区别](https://dimillian.medium.com/swiftui-the-difference-between-list-and-lazyvstack-3d5eeaccb156)
    了解更多！'
- en: If you’d like to see more content on app performance, check out my recent deep-dive,
    [High Performance Swift Apps](https://jacobbartlett.substack.com/p/high-performance-swift-apps).
  id: totrans-split-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您想看更多关于应用性能的内容，请查看我的最新深度分析，[高性能 Swift 应用](https://jacobbartlett.substack.com/p/high-performance-swift-apps)。
- en: 'The a11y-related reason to use native components are simple, yet myriad:'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地组件的与无障碍相关的原因是简单而又多样的：
- en: '**Apple has, collectively, put more thought into making a11y work more than
    you ever will.**'
  id: totrans-split-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**苹果公司已经集体投入更多的思考来使无障碍性工作，远远超过你能想象的。**'
- en: '`List` has a *semantic meaning*: it tells the screenreader that it’s a container
    that houses a collection of similar content.'
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`具有*语义意义*：它告诉屏幕阅读器它是一个容器，包含一组相似的内容。'
- en: 'This is why, when we have many list items, the naïve implementation was so
    broken: instead of allowing us to skip past the `List` container with VoiceOver,
    we had to swipe through every item in order to reach the *Log Out* button.'
  id: totrans-split-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当我们有很多列表项时，天真的实现如此糟糕：不是让我们通过VoiceOver跳过`List`容器，而是让我们必须逐个滑动每个项目，才能到达*登出*按钮。
- en: With `List`, SwiftUI can inform the screenreader that its content is a single
    Container, making it trivial for the screenreader to navigate past.
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`List`，SwiftUI可以告知屏幕阅读器其内容是单个容器，使屏幕阅读器能够轻松地跳过。
- en: When using VoiceOver, you can skip past the List by setting the navigation increment
    to “containers” and swiping forwards through the content
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用VoiceOver时，您可以通过将导航增量设置为“容器”并向前划过内容，跳过`List`。
- en: There are also many built-in interaction modes with a `List`, such as swipe-to-delete,
    drag-and-drop, and keyboard-based navigation. These will *just work* when using
    the native components. Have you any clue how you’d get a screenreader to work
    with your janky custom implementation?
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用本机组件时*仅仅工作*的多种内置交互模式相比，`List`还有许多，如滑动删除、拖放和基于键盘的导航。当您使用原生组件时，这些功能会*自动生效*。你有没有想过如何让屏幕阅读器与您笨拙的自定义实现一起工作？
- en: Refer to the above passage the next time you need to push back on your designer’s
    latest stroke of genius.
  id: totrans-split-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在您需要回应设计师最新创意时，请参考上述段落。
- en: '`List` isn’t even the most complicated component. How would you implement a11y
    for a custom `Grid`, or a custom distribution of views that wasn’t using the `Layout`
    protocol?'
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`甚至不是最复杂的组件。您如何为自定义的`Grid`或不使用`Layout`协议的视图分布实现无障碍性？'
- en: Now that you understand how to speedrun a11y in your SwiftUI app, before getting
    to work, the final piece of the puzzle is getting buy-in from the rest of your
    business. This is where you can flex your soft skill of *wielding organisational
    influence*.
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何在您的SwiftUI应用程序中快速实现无障碍性之前，开始工作之前，拼图的最后一块是让整个业务都认同这一点。这是您可以展示您软技能*行使组织影响力*的地方。
- en: One big, blunt tool you can wield is the hammer of legislation. Various countries
    around the world such as the [UK](https://www.legislation.gov.uk/uksi/2018/852/contents/made),
    the [USA](https://www.section508.gov/manage/laws-and-policies/), and the [EU](https://www.levelaccess.com/compliance-overview/european-accessibility-act-eaa/),
    have implemented legislation mandating that digital services meet minimum standards
    of accessibility.
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大而粗糙的工具，您可以运用的是立法的锤子。世界各国如[英国](https://www.legislation.gov.uk/uksi/2018/852/contents/made)，[美国](https://www.section508.gov/manage/laws-and-policies/)和[欧盟](https://www.levelaccess.com/compliance-overview/european-accessibility-act-eaa/)都已实施了法律，要求数字服务符合最低无障碍标准。
- en: Furthermore, there are serious business benefits to a11y. 16% of the world population
    currently experience significant disability, meaning you could be missing out
    on users, positive reviews, and revenue by catering to a wider range of needs.
    Depending on your target demographics, this may be more or less critical.
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无障碍性对业务有重大的好处。全球16%的人口目前有明显的残疾，这意味着如果考虑到更广泛的需求，您可能会错过用户、正面评价和收入。根据您的目标人群，这可能更或者不那么关键。
- en: On a smaller scale, I have found that banging the drum on addressing accessibility
    as product debt is far less effective than simply *demonstrating how your app
    is broken*. Taking the need for a11y out of the abstract and displaying the buggy
    sign-up flow is far more persuasive to any engineering organisation.
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在较小的范围内，我发现在处理作为产品债务的无障碍性时，简单地*展示应用程序如何存在问题*，比单纯地敲击警钟要有效得多。将对无障碍性的需求从抽象中剥离出来，并展示有错误的注册流程，对任何工程组织来说都更具说服力。
- en: Nothing is more helpful than having an influential champion in leadership who
    is bought-in to making the product accessible. Of course, all organisations are
    different, so your mileage may vary when applying this advice.
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比领导层中的有影响力的支持者更有帮助的了，他们致力于使产品易于访问。当然，每个组织都不同，因此在应用此建议时，您的效果可能会有所不同。
- en: The most important thing, now that you’ve speedrun a11y and your product is
    totally accessible?
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经快速完成了无障碍操作，您的产品完全可以访问？
- en: '**Don’t drop the ball!**'
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要掉以轻心！**'
- en: Much like with technical debt, now that you’re in a good place, you can bake
    a11y into your standard development workflow. It’s quick and easy now you know
    how!
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像技术债务一样，现在您处于一个良好状态，您可以将无障碍集成到您的标准开发工作流程中。现在你知道怎么做，这很快很容易！
- en: We’ve covered a lot today.
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们涵盖了很多内容。
- en: First we went through the process of auditing your app for common accessibility
    mistakes that show up when using large text scalings or VoiceOver.
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们经历了审核您的应用程序的过程，以查找在使用大文本缩放或VoiceOver时出现的常见无障碍错误。
- en: We looked into fixing the problems that arise when using text scalings, applying
    scrolling with our `a11yScrollView`, content scaling with `@ScaledMetric`, and
    alignment with `A11yHStack`.
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了在使用文本缩放时出现的问题，使用我们的`a11yScrollView`进行滚动，使用`@ScaledMetric`进行内容缩放，以及使用`A11yHStack`进行对齐。
- en: To make our app work well on a screenreader, we implemented `accessibilityLabel`s,
    combined `accessibilityElement`s, and even fully-customised `accessibilityRepresentation`s.
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用在屏幕阅读器上运行良好，我们实现了`accessibilityLabel`s，结合了`accessibilityElement`s，甚至完全定制了`accessibilityRepresentation`s。
- en: We discussed the reasons to stick to native SwiftUI components over custom views,
    such as semantics, interaction modes, and performance.
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了坚持使用原生SwiftUI组件而不是自定义视图的原因，例如语义、交互模式和性能。
- en: Finally, we went over how you might apply soft skills to get buy-in from your
    organisation to take accessibility seriously.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何运用软技能来说服您的组织认真对待无障碍问题。
- en: If you are serious about a11y in your SwiftUI apps, I implore you to work through
    the [companion app](https://github.com/jacobsapps/oh-shit-a11y) and implement
    these techniques yourself, it’s really the best way to internalise the tools.
    If you have a side project you’ve been working on, that’s also a great place to
    start.
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在SwiftUI应用程序中真的关心a11y，我恳请您通过[伴侣应用程序](https://github.com/jacobsapps/oh-shit-a11y)逐步实施这些技术，这真的是内化工具的最佳方式。如果您有一个正在进行的副项目，那也是一个很好的开始。
- en: I am gladly accepting contributions (and issues) to my [A11yUtils](https://github.com/jacobsapps/A11yUtils/blob/main/Sources/A11yUtils/A11yHStack.swift)
    library — I’d love to work with the community to transform this into a comprehensive
    suite of a11y tools to supplement the APIs already in SwiftUI.
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我很高兴接受对我的[A11yUtils](https://github.com/jacobsapps/A11yUtils/blob/main/Sources/A11yUtils/A11yHStack.swift)库的贡献（和问题） — 我很愿意与社区合作，将其转变为一个全面的无障碍工具套件，以补充已经在SwiftUI中的API。
- en: '* * *'
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
