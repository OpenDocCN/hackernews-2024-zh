- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分类：未分类
- en: 'date: 2024-05-27 14:44:49'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 14:44:49
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'Exploring Podman: A More Secure Docker Alternative | Better Stack Community'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Podman：更安全的Docker替代方案 | 更好的堆栈社区
- en: 来源：[https://betterstack.com/community/guides/scaling-docker/podman-vs-docker/](https://betterstack.com/community/guides/scaling-docker/podman-vs-docker/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://betterstack.com/community/guides/scaling-docker/podman-vs-docker/](https://betterstack.com/community/guides/scaling-docker/podman-vs-docker/)
- en: Containerization has become an essential tool for developers and system operators
    to package and deploy applications on various systems and platforms efficiently.
    Many containerization solutions exist today, but without a doubt, Docker has emerged
    as the de facto standard. This is largely due to its excellent tooling, strong
    community, and vast ecosystem of pre-built images that can be easily shared and
    used across different environments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化已经成为开发人员和系统运维人员在各种系统和平台上高效打包和部署应用程序的重要工具。今天存在许多容器化解决方案，但毫无疑问，Docker已经成为事实上的标准。这在很大程度上归功于其出色的工具、强大的社区以及庞大的预构建映像生态系统，这些映像可以轻松共享和在不同环境中使用。
- en: Docker has held this position for many years, and it has truly revolutionized
    how applications are shipped. At the same time, its wide adoption inspired the
    development of many other containerization solutions offering even more features
    and capabilities. One such solution is [Podman](https://podman.io/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在许多年里一直占据着这个位置，它真正改变了应用程序的发布方式。同时，它的广泛采用也激发了许多其他容器化解决方案的发展，这些解决方案提供了更多的功能和能力。其中一种解决方案是[Podman](https://podman.io/)。
- en: Podman is an open-source container engine that aims to provide a more secure
    and lightweight alternative to Docker. It allows users to run containers without
    requiring a daemon, making it easier to manage and deploy containers on a variety
    of systems. Additionally, Podman offers better security defaults through features
    such as rootless containers (i.e., running containers through non-root users),
    user namespaces, and a more careful utilization of kernel capabilities, all of
    which can protect the host system from potential vulnerabilities and security
    threats.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Podman是一个开源容器引擎，旨在提供一个更安全和轻量的Docker替代方案。它允许用户在不需要守护程序的情况下运行容器，从而更容易在各种系统上管理和部署容器。此外，Podman通过诸如无根容器（即通过非根用户运行容器）、用户命名空间和更谨慎地利用内核功能等功能提供了更好的安全默认设置，所有这些都可以保护主机系统免受潜在的漏洞和安全威胁的影响。
- en: With its growing community and close compatibility with Docker images and commands,
    Podman has gained significant traction among developers and system administrators
    looking for alternative containerization solutions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着其不断增长的社区和与Docker映像和命令的密切兼容性，Podman在寻找替代容器化解决方案的开发人员和系统管理员中获得了显著的关注。
- en: In this article, we'll explore some of the key features and benefits of using
    Podman as a containerization tool. We'll also discuss how it compares to Docker
    and see why it has become a popular alternative choice in the industry.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将探讨使用Podman作为容器化工具的一些关键功能和优势。我们还将讨论它与Docker的比较，并看看为什么它已经成为行业中流行的替代选择。
- en: Let's dive right in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即开始。
- en: Prerequisites
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'Before proceeding with this article, ensure that you meet the following prerequisites:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本文之前，请确保您满足以下先决条件：
- en: Good Linux command-line skills.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀的Linux命令行技能。
- en: Prior experience with Docker.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有Docker的先前经验。
- en: (Optional) A Docker Hub account to follow the private registry setup examples.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）需要一个Docker Hub账户来跟随私有注册表设置示例。
- en: Podman vs Docker Comparison
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Podman与Docker比较
- en: 'While both Podman and Docker allow users to run, manage, and deploy containers
    in an efficient and scalable manner, there are some key differences between the
    two. In this section, we will explore several of these differences:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Podman和Docker都允许用户以高效且可伸缩的方式运行、管理和部署容器，但两者之间存在一些关键差异。在本节中，我们将探讨其中几个差异：
- en: 1\. Architecture differences
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1\. 架构差异
- en: One of the main differences between Podman and Docker lies in their architecture.
    While Docker relies on a client-server model, Podman employs a daemonless architecture.
    With Podman's approach, users manage containers directly, eliminating the need
    for a continuous daemon process in the background. This direct management often
    results in Podman containers launching significantly faster, sometimes up to 50%
    quicker than Docker, depending on the image used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 和 Docker 之间的主要区别之一在于它们的架构。虽然 Docker 依赖于客户端 - 服务器模型，但 Podman 使用无守护进程的架构。使用
    Podman 的方法，用户直接管理容器，消除了后台持续守护进程的需要。这种直接管理通常导致 Podman 容器的启动速度明显更快，有时甚至比 Docker
    快 50%，这取决于使用的镜像。
- en: 'This architecture also enhances security. In Docker, initiating a container
    means sending a request to the Docker daemon via the Docker client which subsequently
    launches the container, which means that the container processes are children
    of the Docker daemon, not the user session:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此架构还增强了安全性。在 Docker 中，启动容器意味着通过 Docker 客户端向 Docker 守护进程发送请求，后者随后启动容器，这意味着容器进程是
    Docker 守护进程的子进程，而不是用户会话的子进程：
- en: As a result, any significant event coming from a container process that's picked
    up by the Linux Audit system (`auditd`) specifies its audit user ID as `unset`
    rather than the actual ID of the user who started the respective container in
    the first place. This makes it extremely difficult to link malicious activity
    to a specific user and taints the security of the system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何由容器进程产生的重要事件，由 Linux 审计系统（`auditd`）捕获，都会将其审计用户 ID 指定为 `unset` 而不是最初启动相应容器的用户的实际
    ID。这使得将恶意活动链接到特定用户变得极为困难，并且玷污了系统的安全性。
- en: With Podman, since each container is instantiated directly through a user login
    session, the container process data retains this information and `auditd` can
    accurately detect and list the ID of each user who started a specific container
    process, maintaining a clear audit trail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Podman，由于每个容器直接通过用户登录会话实例化，容器进程数据保留了这些信息，`auditd` 可以准确地检测和列出启动特定容器进程的每个用户的
    ID，维护着清晰的审计追踪。
- en: 2\. Container lifecycle management
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2\. 容器生命周期管理
- en: The absence of a daemon in Podman leads to a distinct approach to managing container
    lifecycles compared to Docker. On Linux, Podman relies extensively on [Systemd](https://systemd.io/)
    for this purpose. For instance, to correctly enforce restart policies for containers
    using the `--restart always` flag, Podman relies on a `systemd` service called
    `podman-restart`. This service automatically restarts all designated containers
    after each system reboot.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Podman 中缺少守护进程导致了与 Docker 相比管理容器生命周期的独特方法。在 Linux 上，Podman 主要依赖于[systemd](https://systemd.io/)来实现这一目的。例如，为了正确地强制执行使用
    `--restart always` 标志的容器的重启策略，Podman 依赖于一个名为 `podman-restart` 的 `systemd` 服务。该服务在每次系统重新启动后自动重新启动所有指定的容器。
- en: Moreover, Podman exposes a handy command for generating Systemd service files
    from running containers. This allows you to bring your containers under `systemd`
    management to start, stop, and inspect the various services running inside of
    them more easily. In contrast, Docker handles all these tasks internally through
    the daemon itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Podman 提供了一个方便的命令，用于从运行中的容器生成 Systemd 服务文件。这允许您将容器纳入 `systemd` 管理，以更轻松地启动、停止和检查其中运行的各种服务。相比之下，Docker
    通过守护进程内部处理所有这些任务。
- en: 3\. Container orchestration
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3\. 容器编排
- en: When developing locally, Docker users normally reach for [Docker Compose](https://docs.docker.com/compose/)
    to define and manage multi-container applications more easily. While Podman doesn't
    support Compose files out of the box, it provides a compatible alternative called
    [Podman Compose](https://github.com/containers/podman-compose), which typically
    works seamlessly with existing `docker-compose.yml` files. For a native experience,
    you may also use pods, a concept that Podman borrows from [Kubernetes](https://kubernetes.io/)
    and allows users to manage a group of containers as one uniform unit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发时，Docker 用户通常会使用 [Docker Compose](https://docs.docker.com/compose/) 来更轻松地定义和管理多容器应用。虽然
    Podman 不直接支持 Compose 文件，但提供了一个兼容的替代方案，称为 [Podman Compose](https://github.com/containers/podman-compose)，它通常与现有的
    `docker-compose.yml` 文件无缝配合。为了获得原生体验，您还可以使用 pod，这是 Podman 从 [Kubernetes](https://kubernetes.io/)
    借鉴的概念，允许用户将一组容器作为一个统一单元进行管理。
- en: When it comes to production deployment, Podman lacks a tool like [Docker Swarm](https://docs.docker.com/engine/swarm/)
    for orchestrating multi-container application workloads. The best possible alternative
    in such cases is to use an external orchestration system such as Kubernetes, which
    offers similar features and integrates well with Podman, although it may require
    some additional configuration and setup to ensure that everything works correctly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产部署方面，Podman 缺乏类似 [Docker Swarm](https://docs.docker.com/engine/swarm/) 的工具，用于编排多容器应用工作负载。在这种情况下，最好的替代方案是使用外部编排系统，例如
    Kubernetes，它提供类似的功能并且与 Podman 集成良好，尽管可能需要一些额外的配置和设置来确保一切正常运行。
- en: 4\. Security considerations
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4\. 安全性考虑
- en: Containers aim to isolate applications from the host system securely, minimizing
    compatibility issues and enhancing security. A primary security concern is the
    risk of container breakout, where an attacker could compromise the host system.
    To mitigate such risks, running containers with minimal privileges is essential.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 容器旨在安全地将应用程序与主机系统隔离开来，从而最大程度地减少兼容性问题并增强安全性。主要的安全性问题是容器突破的风险，攻击者可能会危害主机系统。为了减轻此类风险，以最低权限运行容器至关重要。
- en: Podman is designed to help with this by providing stronger default security
    settings compared to Docker. Features like [rootless containers](https://docs.docker.com/engine/security/rootless/),
    [user namespaces](https://docs.docker.com/engine/security/userns-remap/), and
    [seccomp profiles](https://docs.docker.com/engine/security/seccomp/), while available
    in Docker, aren't enabled by default and often require extra setup.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 的设计目标是通过提供比 Docker 更强的默认安全设置来帮助实现这一目标。诸如 [无根容器](https://docs.docker.com/engine/security/rootless/)、[用户命名空间](https://docs.docker.com/engine/security/userns-remap/)
    和 [seccomp 配置文件](https://docs.docker.com/engine/security/seccomp/) 等功能，虽然在 Docker
    中可用，但默认情况下并未启用，并且通常需要额外的设置。
- en: Podman's default setup includes rootless containers running in isolated user
    namespaces, limiting the impact of any potential breakout. In contrast, Docker's
    default setting runs container processes as `root`, posing a higher risk in case
    of a breakout.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 的默认设置包括在隔离的用户命名空间中运行的无根容器，限制了任何潜在突破的影响。相比之下，Docker 的默认设置将容器进程作为 `root`
    运行，这在突破的情况下存在更高的风险。
- en: Moreover, Podman containers, tied to user sessions, allow audit systems to trace
    malicious activities back to specific users, unlike Docker, where tracing to a
    user is challenging due to the system-wide daemon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与 Docker 不同，Podman 容器与用户会话绑定，允许审计系统追溯恶意活动至特定用户，这是 Docker 难以做到的，因为追溯到用户在系统范围内的守护进程上是具有挑战性的。
- en: Podman and Docker use Linux kernel capabilities and seccomp profiles to control
    process permissions. By default, Podman launches containers with a narrower set
    of 11 capabilities compared to Docker's more permissive default setting of 14
    capabilities.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 和 Docker 使用 Linux 内核功能和 seccomp 配置文件来控制进程权限。默认情况下，Podman 使用比 Docker 更狭窄的
    11 个能力集来启动容器，而 Docker 使用更宽松的默认设置，具有 14 个能力。
- en: In general, while both Podman and Docker can be configured for robust security,
    Podman generally requires less effort to reach a secure configuration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，虽然 Podman 和 Docker 都可以配置为具有强大的安全性，但 Podman 通常需要更少的工作量才能达到安全的配置。
- en: '**Learn More**: [Docker Security: 14 Best Practices You Should Know](/community/guides/scaling-docker/docker-security-best-practices/)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**了解更多**: [Docker 安全性：你应该知道的 14 个最佳实践](/community/guides/scaling-docker/docker-security-best-practices/)'
- en: '* * *'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: To sum it up, both Docker and Podman are capable tools, and knowing the main
    differences between the two can help you choose the right one for your specific
    needs. Please refer to the table below for some of the major differences between
    the two, and you can assume full parity for most other features.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，无论是 Docker 还是 Podman，都是功能强大的工具，了解两者之间的主要区别可以帮助您选择适合您特定需求的工具。请参考下表，了解两者之间的一些主要区别，您可以假设大多数其他功能完全相同。
- en: '|  | Podman | Docker |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  | Podman | Docker |'
- en: '| --- | --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Daemonless architecture | ✔ | ✘ |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 无守护进程架构 | ✔ | ✘ |'
- en: '| Systemd integration | ✔ | ✘ |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| Systemd 集成 | ✔ | ✘ |'
- en: '| Group containers in pods | ✔ | ✘ |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 将容器分组到 Pod 中 | ✔ | ✘ |'
- en: '| Supports Docker Swarm | ✘ | ✔ |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 支持 Docker Swarm | ✘ | ✔ |'
- en: '| Supports Kubernetes YAML | ✔ | ✘ |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 支持 Kubernetes YAML | ✔ | ✘ |'
- en: With all of this clarified, let's go ahead and install Podman locally.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一澄清，让我们继续在本地安装 Podman。
- en: Installing Podman
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Podman
- en: Like Docker, Podman can run without a problem on all popular operating systems.
    This includes macOS and Windows, as well as all major Linux distributions. The
    only significant difference to note is that while Podman can run natively on Linux,
    it requires a virtual machine to work on Windows and macOS. This adds a few extra
    steps to the installation process on these systems, but other than that, the core
    functionality remains the same.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Docker 一样，Podman 可以在所有流行的操作系统上运行良好。这包括 macOS 和 Windows，以及所有主要的 Linux 发行版。唯一需要注意的重大区别是，虽然
    Podman 可以在 Linux 上本地运行，但在 Windows 和 macOS 上需要虚拟机才能工作。这在这些系统上增加了一些额外的安装步骤，但除此之外，核心功能保持不变。
- en: This tutorial assumes that you are using a Debian-based Linux distribution such
    as Ubuntu, Mint, or Debian itself. The installation process for other operating
    systems is very similar and can be applied by referring to the official [Podman
    installation instructions](https://podman.io/docs/installation).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程假设你使用的是基于 Debian 的 Linux 发行版，如 Ubuntu、Mint 或 Debian 本身。其他操作系统的安装过程非常类似，可以通过参考官方[Podman
    安装说明](https://podman.io/docs/installation)来应用。
- en: Make sure that you are using a relatively recent version of your preferred distribution,
    as PPA repositories on older versions may not have the latest Podman available
    for installation. For instance, at the time of this writing, the latest major
    version of Podman is `4.x`, yet the most recent LTS version of Ubuntu ([Ubuntu
    22.04 LTS](https://discourse.ubuntu.com/t/jammy-jellyfish-release-notes/24668))
    locks you in to Podman `3.x`. Therefore, this tutorial is based on a newer non-LTS
    version ([Ubuntu 23.10](https://discourse.ubuntu.com/t/mantic-minotaur-release-notes/35534)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用的是相对较新版本的你偏好的发行版，因为旧版本的 PPA 仓库可能没有最新可用的 Podman 可供安装。例如，在撰写本文时，Podman 的最新主要版本是`4.x`，然而最新的
    Ubuntu LTS 版本（[Ubuntu 22.04 LTS](https://discourse.ubuntu.com/t/jammy-jellyfish-release-notes/24668)）将你锁定到
    Podman `3.x`。因此，本教程基于较新的非 LTS 版本（[Ubuntu 23.10](https://discourse.ubuntu.com/t/mantic-minotaur-release-notes/35534)）。
- en: 'Start by downloading the latest information from all configured upstream package
    sources:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从所有配置的上游软件包源下载最新信息：
- en: 'Then run the following command to install Podman:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令来安装 Podman：
- en: 'You will see an output similar to:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似的输出：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Type `Y` when prompted, then hit `Enter` to continue.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时键入`Y`，然后按`Enter`继续。
- en: 'After the installation is completed, you can verify that Podman is available
    by typing:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以通过输入以下命令来验证 Podman 是否可用：
- en: The output indicates that version `4.3.1` was successfully installed locally,
    and you can run `podman` commands. You are now ready to launch your first container.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明版本`4.3.1`已成功本地安装，并且你可以运行`podman`命令。现在，你已准备好启动你的第一个容器。
- en: Running your first container
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行你的第一个容器
- en: 'Let''s verify that the installation works by running the well-known ["Hello
    World!" image](https://hub.docker.com/_/hello-world) from [Docker Hub](https://hub.docker.com/):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行来验证安装是否正常工作著名的["Hello World!"镜像](https://hub.docker.com/_/hello-world)从[Docker
    Hub](https://hub.docker.com/)：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will observe an output similar to:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似的输出：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This output shows something important. Even though the "Hello World!" image
    was built with tools from the Docker ecosystem, Podman was still able to run the
    container.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了一些重要的内容。即使"Hello World!"镜像是使用 Docker 生态系统中的工具构建的，Podman 仍然可以运行容器。
- en: That's because both Docker and Podman follow the OCI ([Open Container Initiative](https://opencontainers.org/))
    standards. The OCI defines an [image format specification](https://github.com/opencontainers/image-spec/blob/main/spec.md)
    and a [runtime specification](https://github.com/opencontainers/runtime-spec)
    enabling different container runtimes, such as Podman and Docker, to interoperate.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Docker 和 Podman 都遵循 OCI（[Open Container Initiative](https://opencontainers.org/)）标准。OCI
    定义了一个[镜像格式规范](https://github.com/opencontainers/image-spec/blob/main/spec.md)和一个[运行时规范](https://github.com/opencontainers/runtime-spec)，使不同的容器运行时（如
    Podman 和 Docker）能够进行互操作。
- en: As a result, Podman can seamlessly work with most Docker images and containers.
    This compatibility allows you to migrate your existing workloads to Podman easily
    without having to make any modifications and also to leverage the vast library
    of Docker images available on Docker Hub.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Podman 可以无缝地与大多数 Docker 镜像和容器一起工作。这种兼容性使您可以轻松地将现有的工作负载迁移到 Podman，而无需进行任何修改，还可以利用
    Docker Hub 上可用的大量 Docker 镜像库。
- en: 'Let''s further break down the output from the command above. The first line
    says:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步解析上述命令的输出。第一行说：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This message indicates that Podman referenced a configuration file to obtain
    the fully qualified name of the `hello-world` image. Unlike Docker, Podman recommends
    against using short names to refer to images and does not default to a specific
    registry, unless explicitly instructed to do so via its configuration files. Docker,
    on the other hand, always uses Docker Hub (`docker.io`) as its default registry
    and tries to locate every image there when a fully qualified name is not explicitly
    provided.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息表示 Podman 引用了配置文件以获取`hello-world`镜像的完全限定名称。与 Docker 不同，Podman 建议不要使用简称来引用镜像，并且不会默认使用特定的注册表，除非通过其配置文件明确指示这样做。另一方面，Docker
    总是使用 Docker Hub (`docker.io`) 作为其默认注册表，并尝试在没有明确提供完全限定名称时在那里定位每个镜像。
- en: 'You can further inspect the `shortnames.conf` file and confirm that the `hello-world`
    alias maps to the image `docker.io/library/hello-world`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进一步检查`shortnames.conf`文件，并确认`hello-world`别名映射到图像`docker.io/library/hello-world`：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next few lines say:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行说：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These messages indicate that the latest version of the `hello-world` image was
    successfully downloaded to your local machine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息表明最新版本的`hello-world`镜像已成功下载到您的本地计算机。
- en: 'You can verify this by issuing:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过发出以下命令进行验证：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The remaining output (the "Hello from Docker!" message and all subsequent lines)
    display a message that's hard-coded into the [hello](https://github.com/docker-library/hello-world/blob/master/hello.c)
    binary that ships with the `hello-world` image. This message could be a little
    misleading as it suggests that the Docker engine executed the container when,
    in reality, Podman did. It's important to understand that neither the Docker client
    nor the Docker daemon were in any way involved in the process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的输出（“Hello from Docker!”消息和所有后续行）显示了嵌入在`hello-world`镜像中附带的[hello](https://github.com/docker-library/hello-world/blob/master/hello.c)二进制文件中的消息。此消息可能有点误导，因为它暗示
    Docker 引擎执行了容器，而实际上是 Podman 执行了。重要的是要理解，Docker 客户端和 Docker 守护程序在任何情况下都没有参与该过程。
- en: 'Before you move on further, remove the `hello-world` image, as it''s no longer
    needed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在您进一步操作之前，删除`hello-world`镜像，因为它已不再需要：
- en: 'The output indicates that the image was removed, displaying its tag and ID
    for reference:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明已删除镜像，并显示其标签和 ID 供参考：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, let's examine what happens when you attempt to run an arbitrary image
    using only its short name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看当您仅使用其简称运行任意镜像时会发生什么。
- en: Using short image names
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简称
- en: As we discussed previously, Podman suggests using fully-qualified names for
    container images to avoid ambiguity and ensure that the correct image is always
    referenced from a specific registry.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，Podman 建议使用完全限定名称来避免歧义，并确保始终从特定注册表引用正确的镜像。
- en: Let's try running a container using the [official Caddy image](https://hub.docker.com/_/caddy)
    from Docker Hub. If you're unfamiliar with [Caddy](/community/guides/web-servers/caddy/),
    it's a lightweight web server and reverse proxy known for its ease of use and
    fantastic performance. By running Caddy as a container, you can quickly spin up
    a local web server for testing purposes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用[Docker Hub](https://hub.docker.com/_/caddy)的官方 Caddy 镜像运行容器。如果您对[Caddy](/community/guides/web-servers/caddy/)不熟悉，它是一个轻量级的
    Web 服务器和反向代理，以易用性和出色的性能而闻名。通过将 Caddy 作为容器运行，您可以快速启动一个用于测试目的的本地 Web 服务器。
- en: 'Coming from a Docker background, you would typically use the following command
    to start the container:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Docker 背景出发，您通常会使用以下命令启动容器：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This translates to the following command in Podman:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Podman 中对应以下命令：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Most of the time, transitioning from Docker to Podman is a matter of changing
    `docker` to `podman` in your command. In fact, many users add `alias docker=podman`
    to their shell config files and use Podman as an alias for `docker` commands.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，从 Docker 切换到 Podman 只是在命令中将`docker`改为`podman`的问题。事实上，许多用户将`alias docker=podman`添加到其
    shell 配置文件中，并使用 Podman 作为`docker`命令的别名。
- en: 'The flags are also identical:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 标志也是相同的：
- en: '`--rm` specifies that the container should be automatically removed after it
    exits, so it doesn''t clutter up your system.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--rm` 指定容器在退出后应自动删除，以免在系统中留下垃圾。'
- en: '`-p 8080:80` specifies that port `8080` on the host machine should map to port
    `80` in the container, so that you can access the web server running inside the
    container by typing `localhost:8080` in your browser.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p 8080:80` 指定主机上的端口 `8080` 应映射到容器中的端口 `80`，这样您就可以通过在浏览器中键入 `localhost:8080`
    访问容器内运行的 web 服务器。'
- en: Try running the command. If everything goes well, a container should launch,
    allowing you to open `localhost:8080` in a browser to see the built-in Caddy test
    page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行该命令。如果一切顺利，一个容器应该启动，允许你在浏览器中打开 `localhost:8080` 来查看内置的 Caddy 测试页面。
- en: 'Contrary to what you might anticipate, the command fails and returns the following
    error:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与你可能预期的相反，该命令失败并返回以下错误：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The command didn't work because Podman couldn't understand where to pull the
    `caddy` image from.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令未生效，因为 Podman 无法理解从何处拉取 `caddy` 镜像。
- en: 'It first looked up `shortnames.conf` for an alias named `caddy` but could not
    find one. Try a `grep` on `shortnames.conf`, and you will see that it returns
    no matches indeed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先在 `shortnames.conf` 中查找名为 `caddy` 的别名，但找不到。尝试对 `shortnames.conf` 进行 `grep`，你会看到它确实没有返回任何匹配项：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It then looked up the `registries.conf` file for a list of so-called unqualified
    search registries. An unqualified search registry is the one that Podman tries
    to contact whenever a non-fully qualified image name is supplied with the `run`
    command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它在 `registries.conf` 文件中查找一组所谓的未限定搜索注册表。未限定搜索注册表是指每当 `run` 命令提供了非完全限定的镜像名称时，Podman
    尝试联系的注册表。
- en: 'There are three possible solutions to the issue that you encountered. Let''s
    explore all of them:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 针对你遇到的问题，有三种可能的解决方案。让我们探索所有这些：
- en: 1\. Specifying a fully-qualified name
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1\. 指定完全限定名称
- en: 'You can specify the fully-qualified name:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定完全限定名称：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This works! However, coming from a Docker background, you may find using short
    names more ergonomic, because this is the workflow that you're used to. This is
    absolutely possible with Podman, using either aliases or unqualified search registries
    which we'll explore below.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效！但是，如果你来自 Docker 背景，你可能会发现使用短名称更符合人体工程学，因为这是你习惯的工作流程。这在 Podman 中绝对是可能的，使用别名或未限定的搜索注册表，我们将在下面探讨这一点。
- en: 2\. Defining an alias
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2\. 定义别名
- en: 'You may decide to define an alias for `caddy` instead. When doing so, keep
    in mind that the `/etc/containers/registries.conf.d/shortnames.conf` file is not
    meant to be modified directly, as it is shipped as part of the [shortnames project](https://github.com/containers/shortnames).
    The correct way to define a new alias is by adding an `[aliases]` section to your
    `registries.conf` file like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能决定为 `caddy` 定义一个别名。在这样做时，请记住 `/etc/containers/registries.conf.d/shortnames.conf`
    文件不应直接修改，因为它作为 [shortnames 项目](https://github.com/containers/shortnames) 的一部分进行了打包。定义新别名的正确方式是向你的
    `registries.conf` 文件添加一个 `[aliases]` 部分，就像这样：
- en: /etc/containers/registries.conf
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/containers/registries.conf
- en: Copied!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 复制！
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The default registry configuration for Podman is located at `/etc/containers/registries.conf`,
    but modifying this file requires root privileges. This slightly defeats the idea
    of rootless access that Podman aims to support. However, Podman offers a mechanism
    to overcome this limitation. You can put your configuration into `$HOME/.config/containers/registries.conf`,
    and it will take precedence over `/etc/containers/registries.conf`. This requires
    no root privileges.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 的默认注册表配置位于 `/etc/containers/registries.conf`，但修改此文件需要 root 权限。这在某种程度上违背了
    Podman 旨在支持的无根访问的理念。然而，Podman 提供了一种克服此限制的机制。你可以将你的配置放入 `$HOME/.config/containers/registries.conf`，它将优先于
    `/etc/containers/registries.conf`。这不需要 root 权限。
- en: 'Go ahead and create the `$HOME/.config/containers/registries.conf` file on
    your system:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并在你的系统上创建 `$HOME/.config/containers/registries.conf` 文件：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then add the following line to your file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下行添加到你的文件中：
- en: ~/.config/containers/registries.conf
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ~/.config/containers/registries.conf
- en: Copied!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 复制！
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now re-run:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You will see the following output indicating that the solution works:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出，指示解决方案有效：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While this solution works, adding aliases for every image that you plan on using
    will be tedious and time-consuming in the long run. This leads us to the third
    possible solution—configuring an unqualified search registry.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个解决方案有效，但为你打算使用的每个镜像添加别名将在长期内变得乏味和耗时。这引导我们进入第三种可能的解决方案——配置未限定的搜索注册表。
- en: Before you do that, revert the changes that you did so far so you can start
    with a clean state.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之前，撤销你到目前为止所做的更改，这样你就可以从一个干净的状态开始。
- en: 'Hit `Ctrl+C` to terminate the Caddy container and return to your terminal.
    Then remove the `[aliases]` configuration from the `registries.conf` file by truncating
    the entire file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 `Ctrl+C` 终止 Caddy 容器，并返回到你的终端。然后通过截断整个文件，从 `registries.conf` 文件中删除 `[aliases]`
    配置：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Remove the `caddy` image that Podman just downloaded:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 Podman 刚下载的 `caddy` 镜像：
- en: 'As expected, the output shows the tag and ID of the image that was removed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，输出显示已删除的图像的标签和 ID：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You are now ready to define an unqualified search registry.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已准备好定义一个未命名搜索注册表。
- en: 3\. Defining an unqualified search registry
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3\. 定义未命名搜索注册表
- en: 'Open your `$HOME/.config/containers/registries.conf` file and paste the following
    contents:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的 `$HOME/.config/containers/registries.conf` 文件并粘贴以下内容：
- en: ~/.config/containers/registries.conf
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ~/.config/containers/registries.conf
- en: Copied!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 复制！
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now re-run:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will see the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `caddy` image was successfully downloaded, a container was launched, and
    Caddy is now ready to serve web requests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`caddy` 镜像已成功下载，一个容器已启动，Caddy 现在已准备好提供 Web 请求服务。'
- en: 'To confirm that everything works, you can navigate to `localhost:8080`. There,
    you should see the Caddy test page:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认一切正常工作，您可以导航到 `localhost:8080`。 在那里，您应该看到 Caddy 的测试页面：
- en: Using an unqualified search registry is unquestionably a better option than
    using aliases, especially if you intend to use Podman as a drop-in replacement
    for Docker, because you can continue using short names the way that you are used
    to, and they will resolve from Docker Hub by default.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未命名搜索注册表无疑是一个比使用别名更好的选择，特别是如果您打算将 Podman 作为 Docker 的替代品使用，因为您可以继续使用您习惯的方式使用短名称，并且它们将默认从
    Docker Hub 解析。
- en: 'Before you continue further, go back to your terminal and hit `Ctrl+C` to stop
    the container, then remove the Caddy image:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请返回到您的终端并按下 `Ctrl+C` 停止容器，然后删除 Caddy 镜像：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using private image registries
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用私有镜像注册表
- en: You are likely used to working with private registries that host your organization's
    proprietary images. Docker can undoubtedly facilitate that, and so can Podman.
    The process is very similar for both tools.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能习惯于使用托管您组织专有图像的私有注册表。 Docker 无疑可以促成这一点，Podman 也可以。对于这两个工具，该过程非常相似。
- en: This example assumes that you have a working Docker Hub account. If you don't
    have an account, you can [register one for free](https://hub.docker.com/signup).
    The free tier allows you to maintain one private repository free of charge.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例假设您拥有一个可用的 Docker Hub 账户。 如果您没有账户，可以[免费注册一个](https://hub.docker.com/signup)。
    免费套餐允许您免费维护一个私有仓库。
- en: 'Log into your Docker Hub account and navigate to [Account Settings](https://hub.docker.com/settings/general):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 登录您的 Docker Hub 账户并转到 [Account Settings](https://hub.docker.com/settings/general)：
- en: 'Go to [Security](https://hub.docker.com/settings/security) and click on **New
    Access Token**:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 [Security](https://hub.docker.com/settings/security) 并点击 **New Access Token**：
- en: 'Specify **Podman tutorial** as the description and **Read & Write** as the
    desired permissions, then click **Generate**:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **Podman 教程** 指定为描述，**读写** 为所需权限，然后点击 **生成**：
- en: 'Copy the generated access token and store it somewhere safe. We will refer
    to this token as `<your_access_token>`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 复制生成的访问令牌并将其存储在安全的地方。我们将此令牌称为 `<your_access_token>`：
- en: 'The token should now be listed under the available access tokens in your Docker
    Hub account:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌现在应列在您的 Docker Hub 账户的可用访问令牌下：
- en: 'Navigate back to [Repositories](https://hub.docker.com/repositories) and create
    a new private repository as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 [Repositories](https://hub.docker.com/repositories) 并按以下步骤创建一个新的私有仓库：
- en: 'If all goes well, you should see the repository listed in your Docker Hub account:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该在您的 Docker Hub 账户中看到仓库列表：
- en: Let's now configure Podman to run with your private repository.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们配置 Podman 以使用您的私有仓库运行。
- en: 'Type the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: Here, `docker.io` can be omitted if you have listed it as the first `unqualified-search-registries`
    entry in your `registries.conf` file. Nevertheless, it's still considered a good
    practice to specify the registry explicitly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 `registries.conf` 文件中将 `docker.io` 列为第一个 `unqualified-search-registries`
    条目，则可以省略此处的 `docker.io`。尽管如此，明确指定注册表仍然被认为是一个好的做法。
- en: 'Otherwise, `podman login` will fail with the following error:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`podman login` 将失败，并显示以下错误：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Type in your username and access token when prompted, and you should receive
    the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时输入您的用户名和访问令牌，您应该收到以下输出：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Continue by downloading the official `hello-world` image locally:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 继续通过在本地下载官方的 `hello-world` 镜像：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A successful output will look like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的输出将类似于这样：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now list your local Podman images:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在列出您本地的 Podman 图像：
- en: 'You should see the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Go ahead and upload a copy of the `hello-world` image to your private repository.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并将 `hello-world` 镜像的副本上传到您的私有仓库。
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will get the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到以下输出：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Navigate back to your private repository on Docker Hub to verify that the image
    was successfully uploaded:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 Docker Hub 上的私有存储库，以验证镜像是否成功上传：
- en: 'You can now remove the public `hello-world` image from your local machine:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从您的本地计算机中删除公共 `hello-world` 镜像了：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, try running a container using the image from your private repository:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用来自您私有存储库的镜像运行容器：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Podman goes ahead, successfully pulls the private image, and launches a container
    using the image:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 继续进行，成功拉取私有镜像，并使用该镜像启动容器：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Without valid login credentials, you would have received the following error
    instead:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有有效的登录凭据，您将收到以下错误：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, using Podman with a private registry is almost identical to
    using Docker for the same purpose. The only difference is that you prefixed your
    commands with `podman` instead of `docker`. Just like Docker, you can use Podman
    with all popular private registries.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，使用 Podman 连接私有注册表几乎与使用 Docker 相同。唯一的区别是您的命令前缀为 `podman` 而不是 `docker`。与
    Docker 一样，您可以使用 Podman 连接所有流行的私有注册表。
- en: 'Before you continue further, make sure to logout:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保注销：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Also, remove the private image from your local machine:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，从本地计算机中删除私有镜像：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With this, you can proceed to the next section and learn how to orchestrate
    multiple containers with Podman.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，您可以继续下一节，并学习如何使用 Podman 管理多个容器。
- en: Orchestrating multiple containers
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理多个容器
- en: So far, you have only been launching one container at a time to explore how
    Podman works. At some point, you'll surely find it necessary to run multiple containers
    working together as a unit. In this section, you'll explore one of the possible
    ways to do that with [Podman Compose](https://github.com/containers/podman-compose).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只启动了一个容器来探索 Podman 的工作方式。在某些时候，您肯定会发现有必要运行多个容器一起作为一个单位工作。在本节中，您将探索使用
    [Podman Compose](https://github.com/containers/podman-compose) 的可能方式之一。
- en: Podman offers several options for orchestrating multiple containers, but Podman
    Compose is the most similar to what's used in the Docker world. Other options
    are pods and Kubernetes manifests, but both call for a deeper comprehension of
    Podman (and Kubernetes), so we'll leave them out for now.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 提供了几种用于管理多个容器的选项，但 Podman Compose 是最接近 Docker 世界使用的选项。其他选项包括 pods 和 Kubernetes
    清单，但这两者都需要更深入地理解 Podman（和 Kubernetes），所以我们暂时不讨论它们。
- en: In the following example, you'll use the Docker Compose instructions supplied
    with the [official WordPress image](https://hub.docker.com/_/wordpress) on Docker
    Hub to launch a simple [WordPress](https://github.com/WordPress/WordPress) installation
    backed by a MySQL database server. If you're unfamiliar with WordPress, it is
    a popular blogging and content management platform written in PHP.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，您将使用 Docker Hub 提供的 [official WordPress image](https://hub.docker.com/_/wordpress)
    上的 Docker Compose 指令来启动一个简单的由 MySQL 数据库服务器支持的 [WordPress](https://github.com/WordPress/WordPress)
    安装。如果您不熟悉 WordPress，它是一个流行的用 PHP 编写的博客和内容管理平台。
- en: In the Docker ecosystem, Compose allows you to define and manage multiple containers
    through definitions stored inside a `docker-compose.yml` file. Being used to working
    with Docker Compose, you can continue using your existing `docker-compose.yml`
    files with Podman with the help of Podman Compose.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 生态系统中，Compose 允许您通过存储在 `docker-compose.yml` 文件中的定义来定义和管理多个容器。习惯于使用
    Docker Compose，您可以借助 Podman Compose 继续使用现有的 `docker-compose.yml` 文件。
- en: Podman Compose is a community-driven tool that implements the [Compose specification](https://compose-spec.io/)
    and seamlessly integrates with Podman. It relies on Python 3 to work, and one
    of the easiest ways to get started with it is through [pipx](https://pipx.pypa.io/stable/).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Podman Compose 是一个由社区驱动的工具，它实现了 [Compose specification](https://compose-spec.io/)
    并与 Podman 无缝集成。它依赖于 Python 3 运行，并且通过 [pipx](https://pipx.pypa.io/stable/) 是开始使用它的最简单的方法之一。
- en: 'If you don''t already have Python 3 or `pipx` installed on your system, you
    can install them by running:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统尚未安装 Python 3 或 `pipx`，您可以通过运行以下命令来安装它们：
- en: 'You can verify that `pipx` is working by typing:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入以下命令来验证 `pipx` 是否正常工作：
- en: 'This will output a version identifier similar to:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一个类似于版本标识符：
- en: The output confirms that version `1.2.0` is of `pipx` is installed on your system,
    and you're ready to start using it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确认您的系统已安装了版本为 `1.2.0` 的 `pipx`，并且您已准备好开始使用它。
- en: 'You can run the following command to install Podman Compose:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行以下命令来安装 Podman Compose：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If everything goes well, you should see:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会看到：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output indicates that `pipx` was placed in your `$HOME/.local/bin` folder.
    However, that folder is likely not included in your `$PATH` variable, meaning
    if you type `podman-compose` right now, you will get a similar error:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输出指示`pipx`已放置在你的`$HOME/.local/bin`文件夹中。 但是，那个文件夹可能没有包含在你的`$PATH`变量中，这意味着如果你现在键入`podman-compose`，你会得到类似的错误：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Don't be confused by this error. Podman Compose was successfully installed,
    but you need to add its installation folder to your `$PATH`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这个错误搞混了。 Podman Compose 已成功安装，但是你需要将其安装文件夹添加到你的`$PATH`中。
- en: 'You can address this by running:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行来解决这个问题：
- en: This command will ensure that `$HOME/.local/bin` is appended to your `$PATH`
    through one of your shell's config files (`.profile`, `.bash_profile`, `.bashrc`,
    etc. depending on your specific setup).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将通过你的一个 shell 配置文件（`.profile`、`.bash_profile`、`.bashrc`等，取决于你的具体设置）确保将`$HOME/.local/bin`追加到你的`$PATH`中。
- en: 'After running the command, you will see the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令后，你将看到以下输出：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can follow the instructions and re-open your terminal session. Alternatively,
    if you know precisely which shell config file was modified, you can source the
    file for the changes to take immediate effect.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照说明重新打开你的终端会话。 或者，如果你确切地知道哪个 shell 配置文件被修改了，你可以为了使更改立即生效而源文件。
- en: 'For example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'To confirm that the `$PATH` is set correctly, you can run:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认`$PATH`是否设置正确，你可以运行：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see `/home/<your_user_name>/.local/bin` listed in the output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在输出中看到`/home/<your_user_name>/.local/bin`：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a new folder and `cd` into it:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件夹并`cd`进入：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create an `.env` file and define the following variables:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`.env`文件并定义以下变量：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, create a new `docker-compose.yml` file and paste the following contents:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个新的`docker-compose.yml`文件并粘贴以下内容：
- en: docker-compose.yml
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: docker-compose.yml
- en: Copied!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 复制！
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Save the file, then run:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后运行：
- en: Let's examine the output segment by segment.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐段检查输出。
- en: 'Initially, `podman-compose` launches and starts analyzing the `docker-compose.yml`
    file:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`podman-compose`启动并开始分析`docker-compose.yml`文件：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It detects two services named `wordpress` and `db`, and starts processing them
    in sequential order.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它检测到两个名为`wordpress`和`db`的服务，并按顺序开始处理它们。
- en: 'First, it finds out that the `wordpress` service requires an external volume.
    It tries to locate the volume by issuing `podman volume inspect <volume_name>`,
    but since it doesn''t exist, it goes ahead and creates one by issuing `podman
    volume create <volume_name>`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它发现`wordpress`服务需要一个外部卷。 它尝试通过发出`podman volume inspect <volume_name>`来定位卷，但由于不存在，它继续通过发出`podman
    volume create <volume_name>`来创建一个卷：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, it checks whether there is a suitable network for deploying the `wordpress`
    service. It doesn''t find one, so it creates it and then performs another check
    to confirm that the network exists:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它检查是否有适用于部署`wordpress`服务的合适网络。 它未找到，因此创建并执行另一个检查以确认网络是否存在：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, with a suitable network and an external volume in place, Podman Compose
    launches the `wordpress` container:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用合适的网络和已创建的外部卷，Podman Compose 启动`wordpress`容器：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since Podman cannot find a `wordpress` image available locally, it goes ahead
    and looks up the unqualified search registry that you configured earlier (`docker.io`),
    then downloads it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Podman 无法在本地找到可用的`wordpress`镜像，因此它继续查找你之前配置的未经授权的搜索注册表（`docker.io`），然后下载它：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next, Podman Compose proceeds with processing the instructions for the `db`
    service.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Podman Compose 继续处理`db`服务的指令。
- en: 'First, it creates its external volume:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它创建其外部卷：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It then ensures that there is a suitable network for its deployment:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它确保有适用于部署的合适网络：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, it launches the `db` container:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它启动`db`容器：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Just like with the `wordpress` image, Podman cannot find a `mysql:5.7` image
    locally, so it goes ahead and obtains it from Docker Hub:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`wordpress`镜像一样，Podman 无法在本地找到`mysql:5.7`镜像，因此继续从 Docker Hub 获取它：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: At this point, Podman Compose exits successfully, and everything appears to
    be launched correctly. Let's go ahead and verify this.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Podman Compose 成功退出，并且一切似乎都启动正确。 让我们继续验证这一点。
- en: 'First, try to open `localhost:8080` in a browser. You should see the WordPress
    installation page:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试在浏览器中打开`localhost:8080`。 你应该看到WordPress安装页面：
- en: 'Now, go back to your terminal and type in:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到你的终端并键入：
- en: 'Indeed, both the `wordpress` container and the `db` container are up and running:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`wordpress`容器和`db`容器都已经启动并运行：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can also go ahead and explore the list of available images:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以继续探索可用镜像的列表：
- en: 'The list contains all the necessary images for running MySQL and WordPress:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表包含了运行MySQL和WordPress所需的所有必要镜像：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can further explore the list of available networks:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进一步探索可用网络的列表：
- en: 'Two networks show up:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个网络显示出来：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `podman` network is created by default when you install Podman for the first
    time. It is used for launching containers when no other network is explicitly
    specified. On the other hand, the `podman-tutorial_default` network is created
    by Podman Compose to isolate the containers defined in your `docker-compose.yml`
    from any other containers potentially running on the same system.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次安装Podman时，默认创建`podman`网络。当没有显式指定其他网络时，它用于启动容器。另一方面，`podman-tutorial_default`网络是由Podman
    Compose创建的，用于隔离你的`docker-compose.yml`中定义的容器与可能在同一系统上运行的任何其他容器。
- en: 'Finally, let''s check the available volumes:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们检查可用的卷：
- en: 'As expected, two external volumes appear:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，出现了两个外部卷：
- en: '[PRE59]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can go ahead and stop the containers:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续停止容器：
- en: 'Podman Compose stops and removes the containers from your system but keeps
    the network and volumes:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Podman Compose 停止并移除了你系统中的容器，但保留了网络和卷：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can verify that no containers are running by typing:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入来验证没有容器在运行：
- en: The result shows an empty output, which confirms that all of the containers
    were stopped and removed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示一个空输出，这证实了所有容器都已停止和移除。
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you want to remove the volumes as well, you can type in:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想连同卷一起移除，可以输入：
- en: '[PRE62]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To remove the network, type in:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除网络，请输入：
- en: '[PRE63]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, the commands are identical to what you would normally use with
    Docker and Docker Compose. The only noticeable difference is that instead of `docker`
    and `docker-compose`, you type in `podman` and `podman-compose`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，命令与通常使用Docker和Docker Compose时使用的命令相同。唯一显著的区别是，你要输入`podman`和`podman-compose`，而不是`docker`和`docker-compose`。
- en: Final thoughts
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终思考
- en: Podman is a capable containerization technology that offers a viable alternative
    to Docker for running container workloads. Whether you choose Podman or Docker
    depends entirely on your specific needs and preferences.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Podman是一种功能强大的容器化技术，为运行容器工作负载提供了与Docker相媲美的可行选择。你选择Podman还是Docker完全取决于你的具体需求和偏好。
- en: Podman can do most of the things that Docker can do, with the added benefit
    of not requiring a daemon running in the background. On top of that, Podman offers
    some features that Docker does not, such as working with Kubernetes manifest files
    and organizing individual containers into pods.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Podman可以做的大多数事情都与Docker一样，而且不需要在后台运行守护进程的额外好处。除此之外，Podman还提供了一些Docker没有的功能，比如与Kubernetes清单文件一起工作，以及将单个容器组织成Pod。
- en: The final decision is yours. If you require a more lightweight and secure container
    management solution, Podman might be a better choice. However, Docker may be the
    way to go if you prioritize a robust ecosystem with extensive community support.
    Ultimately, both tools offer powerful containerization capabilities to meet your
    requirements.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的决定由你做出。如果你需要一个更轻量级和安全的容器管理解决方案，Podman可能是一个更好的选择。然而，如果你优先考虑具有广泛社区支持的强大生态系统，那么Docker可能是更好的选择。最终，这两个工具都提供了强大的容器化能力，以满足你的需求。
- en: To explore Podman further, consider visiting the [official Podman website](https://podman.io/),
    exploring its [documentation](https://podman.io/docs), and joining its growing
    [community](https://podman.io/community).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步探索Podman，请考虑访问[官方Podman网站](https://podman.io/)，探索其[文档](https://podman.io/docs)，并加入其不断增长的[社区](https://podman.io/community)。
- en: Thanks for reading!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢阅读！
