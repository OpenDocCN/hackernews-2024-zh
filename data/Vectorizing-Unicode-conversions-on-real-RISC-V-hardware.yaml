- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»åˆ«ï¼šæœªåˆ†ç±»
- en: 'date: 2024-05-27 15:14:03'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024-05-27 15:14:03
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Vectorizing Unicode conversions on real RISC-V hardware
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åœ¨å®é™…RISC-Vç¡¬ä»¶ä¸Šå®ç°å‘é‡åŒ–Unicodeè½¬æ¢
- en: æ¥æºï¼š[https://camel-cdr.github.io/rvv-bench-results/articles/vector-utf.html](https://camel-cdr.github.io/rvv-bench-results/articles/vector-utf.html)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://camel-cdr.github.io/rvv-bench-results/articles/vector-utf.html](https://camel-cdr.github.io/rvv-bench-results/articles/vector-utf.html)
- en: Vectorizing Unicode conversions on real RISC-V hardware
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åœ¨å®é™…RISC-Vç¡¬ä»¶ä¸Šå®ç°å‘é‡åŒ–Unicodeè½¬æ¢
- en: In this article we'll discuss how to achieve the speedup below for UTF-8 to
    UTF-16 conversion, using the RISC-V Vector extension.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†è®¨è®ºå¦‚ä½•åˆ©ç”¨RISC-Vå‘é‡æ‰©å±•å®ç°UTF-8åˆ°UTF-16è½¬æ¢çš„åŠ é€Ÿã€‚
- en: 'I excluded the plain ASCII case from the graph above because it made the other
    results less readable, the speedup was: 8x for C908, and 11x for C920\. More comprehensive
    measurements are at the [end](#finbench) of the article.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»ä¸Šé¢çš„å›¾è¡¨ä¸­æ’é™¤äº†çº¯ASCIIæƒ…å†µï¼Œå› ä¸ºè¿™ä½¿å¾—å…¶ä»–ç»“æœå˜å¾—ä¸å¤ªå¯è¯»ï¼Œé€Ÿåº¦æå‡ä¸ºï¼šC908 8å€ï¼ŒC920 11å€ã€‚æ›´å…¨é¢çš„æµ‹é‡ç»“æœåœ¨æ–‡ç« çš„[ç»“å°¾](#finbench)ã€‚
- en: The vast majority of text you'll come across will be encoded in the UTF-8 format,
    but some languages and APIs use UTF-16 as their native format instead (JavaScript,
    Java, Windows, ...). This and other reasons, might cause you to convert between
    different Unicode encodings. As demonstrated by [simdutf](https://github.com/simdutf/simdutf/),
    this conversion process has a lot of optimization potential.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ç»å¤§å¤šæ•°æ–‡æœ¬éƒ½ä»¥UTF-8æ ¼å¼ç¼–ç ï¼Œä½†æŸäº›è¯­è¨€å’ŒAPIä½¿ç”¨UTF-16ä½œä¸ºå…¶æœ¬æœºæ ¼å¼ï¼ˆJavaScriptã€Javaã€Windowsç­‰ï¼‰ã€‚è¿™ä¸ªå’Œå…¶ä»–åŸå› å¯èƒ½å¯¼è‡´ä½ éœ€è¦åœ¨ä¸åŒçš„Unicodeç¼–ç ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚æ­£å¦‚[simdutf](https://github.com/simdutf/simdutf/)æ‰€ç¤ºï¼Œè¿™ä¸ªè½¬æ¢è¿‡ç¨‹å…·æœ‰å¾ˆå¤šä¼˜åŒ–æ½œåŠ›ã€‚
- en: Here we'll focus on UTF-8 to UTF-16 conversion, and aim to develop an optimized
    RISC-V implementation that can be upstreamed to the [simdutf](https://github.com/simdutf/simdutf/)
    library, which is used among others by Node.js and Bun. ([The changes](https://github.com/simdutf/simdutf/pull/373)
    are now upstream)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†ä¸“æ³¨äºUTF-8åˆ°UTF-16è½¬æ¢ï¼Œå¹¶æ—¨åœ¨å¼€å‘ä¸€ä¸ªç»è¿‡ä¼˜åŒ–çš„RISC-Vå®ç°ï¼Œå¯ä»¥ä¸Šæ¸¸åˆ°[simdutf](https://github.com/simdutf/simdutf/)åº“ä¸­ï¼Œè¯¥åº“è¢«Node.jså’ŒBunç­‰é¡¹ç›®ä½¿ç”¨ã€‚ï¼ˆ[æ›´æ”¹](https://github.com/simdutf/simdutf/pull/373)ç°å·²ä¸Šæ¸¸ï¼‰
- en: The RISC-V Vector extension (RVV) adds a set of 32 vector registers that are
    each VLEN bits wide, where VLEN is a power-of-two greater or equal to 128 (in
    the standard V extension). Vector registers can be interpreted as multiple 8/16/32/64
    bit elements, and operated on accordingly, as signed/unsigned integers or single/double
    precision floating point numbers. Since we can operate on multiple elements at
    a time large speedup over scalar code is possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RISC-Vå‘é‡æ‰©å±•ï¼ˆRVVï¼‰æ·»åŠ äº†ä¸€ç»„32ä¸ªå‘é‡å¯„å­˜å™¨ï¼Œæ¯ä¸ªå¯„å­˜å™¨çš„å®½åº¦ä¸ºVLENä½ï¼Œå…¶ä¸­VLENæ˜¯å¤§äºæˆ–ç­‰äº128çš„2çš„å¹‚ï¼ˆåœ¨æ ‡å‡†Væ‰©å±•ä¸­ï¼‰ã€‚å‘é‡å¯„å­˜å™¨å¯ä»¥è§£é‡Šä¸ºå¤šä¸ª8/16/32/64ä½å…ƒç´ ï¼Œå¹¶ç›¸åº”åœ°ä»¥æœ‰ç¬¦å·/æ— ç¬¦å·æ•´æ•°æˆ–å•ç²¾åº¦/åŒç²¾åº¦æµ®ç‚¹æ•°è¿›è¡Œæ“ä½œã€‚ç”±äºæˆ‘ä»¬å¯ä»¥ä¸€æ¬¡æ“ä½œå¤šä¸ªå…ƒç´ ï¼Œå› æ­¤ç›¸å¯¹äºæ ‡é‡ä»£ç ï¼Œå¯ä»¥å®ç°å¤§å¹…åŠ é€Ÿã€‚
- en: At the time of writing (early 2024) there is almost no hardware available that
    supports RVV.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ’°å†™æœ¬æ–‡æ—¶ï¼ˆ2024å¹´åˆï¼‰ï¼Œå‡ ä¹æ²¡æœ‰ç¡¬ä»¶æ”¯æŒRVVã€‚
- en: The only hardware with RVV support, regular consumers can buy, is the [Kendryte
    K230](https://www.canaan.io/product/k230). It has a [C908](https://www.t-head.cn/product/%E7%8E%84%E9%93%81C908)
    in-order core from Xuantie running at 1.6GHz with a VLEN of 128 bits. ([C908 benchmark
    page](../canmv_k230/index.html))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å”¯ä¸€æ”¯æŒRVVçš„ç¡¬ä»¶ï¼Œæ™®é€šæ¶ˆè´¹è€…å¯ä»¥è´­ä¹°çš„æ˜¯[Kendryte K230](https://www.canaan.io/product/k230)ã€‚å®ƒå…·æœ‰æ¥è‡ªæ—‹é“çš„1.6GHzçš„æœ‰åºæ ¸[C908](https://www.t-head.cn/product/%E7%8E%84%E9%93%81C908)ï¼ŒVLENä¸º128ä½ã€‚ï¼ˆ[C908åŸºå‡†æµ‹è¯•é¡µé¢](../canmv_k230/index.html))
- en: You can also buy two other CPUs that support an early incompatible draft version
    (0.7.1) of the vector extension, the [C906](https://www.t-head.cn/product/C906?lang=en)
    and the [C920](https://www.t-head.cn/product/C910?lang=en) (C910 with RVV). Since
    the C906s performance characteristics are very similar to the C908, we won't include
    benchmarks for this one. ([C906 benchmark page](../mangopi_mq_pro/index.html))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½ ä¹Ÿå¯ä»¥è´­ä¹°å¦å¤–ä¸¤æ¬¾æ”¯æŒæ—©æœŸä¸å…¼å®¹è‰æ¡ˆç‰ˆæœ¬ï¼ˆ0.7.1ï¼‰çš„å‘é‡æ‰©å±•çš„CPUï¼Œå³[C906](https://www.t-head.cn/product/C906?lang=en)å’Œ[C920](https://www.t-head.cn/product/C910?lang=en)ï¼ˆC910å¸¦æœ‰RVVï¼‰ã€‚ç”±äºC906çš„æ€§èƒ½ç‰¹å¾ä¸C908éå¸¸ç›¸ä¼¼ï¼Œæˆ‘ä»¬ä¸ä¼šä¸ºæ­¤æä¾›åŸºå‡†æµ‹è¯•ã€‚([C906åŸºå‡†æµ‹è¯•é¡µé¢](../mangopi_mq_pro/index.html))
- en: The [C920](https://www.t-head.cn/product/c910?lang=en) however is a much faster
    out-of-order core at 2GHz, the results of which are more interesting than the
    ones from C908 for future hardware. Targeting RVV 0.7.1 is a pain, as there is
    no official toolchain support, but I've taken the time to manually translate the
    generated assembly and assemble it with an [older GCC branch](https://github.com/brucehoult/riscv-gnu-toolchain).
    ([C920 benchmark page](../milkv_pioneer/index.html))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œ[C920](https://www.t-head.cn/product/c910?lang=en)æ˜¯ä¸€ä¸ªé€Ÿåº¦æ›´å¿«çš„ä¹±åºæ ¸å¿ƒï¼Œé¢‘ç‡ä¸º 2GHzï¼Œå…¶ç»“æœæ¯”æœªæ¥ç¡¬ä»¶çš„
    C908 æ›´åŠ æœ‰è¶£ã€‚ç›®æ ‡æ˜¯ RVV 0.7.1ï¼Œè¿™æ˜¯å¾ˆå›°éš¾çš„ï¼Œå› ä¸ºæ²¡æœ‰å®˜æ–¹çš„å·¥å…·é“¾æ”¯æŒï¼Œä½†æˆ‘èŠ±äº†æ—¶é—´æ‰‹åŠ¨ç¿»è¯‘ç”Ÿæˆçš„æ±‡ç¼–ä»£ç ï¼Œå¹¶ä¸”ç”¨ä¸€ä¸ª[è¾ƒæ—§çš„ GCC åˆ†æ”¯](https://github.com/brucehoult/riscv-gnu-toolchain)æ¥æ±‡ç¼–å®ƒã€‚ï¼ˆ[C920
    åŸºå‡†æµ‹è¯•é¡µé¢](../milkv_pioneer/index.html)ï¼‰
- en: There are [a few open-source RVV implementations](https://github.com/stars/camel-cdr/lists/rvv-implementations),
    but most are still in development/incomplete. The only one that is complete, and
    we could simulate locally is Tenstorrents bobcat (formally ocelot), but it was
    a proof-of-concept design and some instructions we'll be using were explicitly
    not optimized. (we'll discuss that [later](#gather))
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ‰[ä¸€äº›å¼€æºçš„ RVV å®ç°](https://github.com/stars/camel-cdr/lists/rvv-implementations)ï¼Œä½†å¤§å¤šæ•°ä»å¤„äºå¼€å‘ä¸­/ä¸å®Œæ•´çŠ¶æ€ã€‚å”¯ä¸€ä¸€ä¸ªå®Œæ•´çš„ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æœ¬åœ°æ¨¡æ‹Ÿçš„æ˜¯
    Tenstorrents bobcatï¼ˆä»¥å‰æ˜¯ ocelotï¼‰ï¼Œä½†å®ƒæ˜¯ä¸€ä¸ªæ¦‚å¿µéªŒè¯è®¾è®¡ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨çš„ä¸€äº›æŒ‡ä»¤æ˜ç¡®æœªç»è¿‡ä¼˜åŒ–ã€‚ï¼ˆæˆ‘ä»¬ç¨åå°†è®¨è®º[æ­¤äº‹](#gather)ï¼‰
- en: Fortunately, I own the Kendryte K230, and have ssh access to a Milk-V Pioneer
    server with 64 C920 cores, thanks to [perfXlab](http://www.perfxlab.com/). The
    development was done via qemu emulation, as that's far simpler than using real
    hardware, for now.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼Œæˆ‘æ‹¥æœ‰ Kendryte K230ï¼Œå¹¶ä¸”èƒ½å¤Ÿé€šè¿‡ [perfXlab](http://www.perfxlab.com/) è·å¾—å¯¹æ‹¥æœ‰ 64
    ä¸ª C920 æ ¸å¿ƒçš„ Milk-V Pioneer æœåŠ¡å™¨çš„ ssh è®¿é—®æƒé™ã€‚å¼€å‘æ˜¯é€šè¿‡ qemu æ¨¡æ‹Ÿå®Œæˆçš„ï¼Œå› ä¸ºè¿™æ¯”ä½¿ç”¨çœŸå®ç¡¬ä»¶è¦ç®€å•å¾—å¤šï¼Œç›®å‰æ˜¯è¿™æ ·çš„ã€‚
- en: The next two sections will cover the basics of RVV and Unicode, feel free to
    [skip ahead](#attack) if you are already familiar with the topics.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥çš„ä¸¤èŠ‚å°†ä»‹ç» RVV å’Œ Unicode çš„åŸºç¡€çŸ¥è¯†ï¼Œå¦‚æœä½ å·²ç»å¯¹è¿™äº›ä¸»é¢˜å¾ˆç†Ÿæ‚‰ï¼Œå¯ä»¥éšæ„[è·³è¿‡](#attack)ã€‚
- en: 'I''ll try to explain the RVV basics using a short example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å°†å°è¯•ä½¿ç”¨ä¸€ä¸ªç®€çŸ­çš„ä¾‹å­æ¥è§£é‡Š RVV çš„åŸºç¡€çŸ¥è¯†ï¼š
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we're using the C intrinsics API to count the number of UTF-8 characters*
    in the supplied data. The next section will describe this in more detail, but
    to count the number of UTF-8 characters we just need to count the number of bytes
    that don't match the pattern `**0b10xxxxxx**`, assuming the input is valid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ C å†…éƒ¨å‡½æ•° API æ¥è®¡ç®—æä¾›æ•°æ®ä¸­çš„ UTF-8 å­—ç¬¦æ•°ã€‚ä¸‹ä¸€èŠ‚å°†æ›´è¯¦ç»†åœ°æè¿°è¿™ä¸€ç‚¹ï¼Œä½†æ˜¯è¦è®¡ç®— UTF-8 å­—ç¬¦çš„æ•°é‡ï¼Œæˆ‘ä»¬åªéœ€è¦è®¡ç®—ä¸åŒ¹é…æ¨¡å¼`**0b10xxxxxx**`çš„å­—èŠ‚æ•°ï¼Œå‡è®¾è¾“å…¥æ˜¯æœ‰æ•ˆçš„ã€‚
- en: '**From here on out when I refer to a "character" I mean a Unicode code point.
    This doesn''t directly map into a single character on screen, for example, this
    emoji "ğŸ§™â€â™€ï¸" is built with three Unicode code points: ğŸ§™ + Zero Width Joiner +
    â™€ï¸ = ğŸ§™â€â™€ï¸*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä»ç°åœ¨å¼€å§‹ï¼Œå½“æˆ‘æåˆ°â€œå­—ç¬¦â€æ—¶ï¼Œæˆ‘æŒ‡çš„æ˜¯ä¸€ä¸ª Unicode ä»£ç ç‚¹ã€‚è¿™å¹¶ä¸ç›´æ¥æ˜ å°„åˆ°å±å¹•ä¸Šçš„å•ä¸ªå­—ç¬¦ï¼Œä¾‹å¦‚ï¼Œè¿™ä¸ªè¡¨æƒ…ç¬¦å· "ğŸ§™â€â™€ï¸" ç”±ä¸‰ä¸ª
    Unicode ä»£ç ç‚¹æ„æˆï¼šğŸ§™ + é›¶å®½åº¦è¿æ¥å™¨ + â™€ï¸ = ğŸ§™â€â™€ï¸*'
- en: As mentioned above RVV supports different vector lengths. To facilitate having
    the same code work on machines with different vector lengths RVV has the `vsetvl*`
    instruction. You give it the element count of your input, an element width, and
    it will give you a count smaller or equal to your supplied count that it can fit
    into a vector register.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä¸Šæ‰€è¿°ï¼ŒRVV æ”¯æŒä¸åŒçš„å‘é‡é•¿åº¦ã€‚ä¸ºäº†ä½¿ç›¸åŒçš„ä»£ç èƒ½å¤Ÿåœ¨å…·æœ‰ä¸åŒå‘é‡é•¿åº¦çš„æœºå™¨ä¸Šè¿è¡Œï¼ŒRVV æä¾›äº†`vsetvl*`æŒ‡ä»¤ã€‚ä½ éœ€è¦ç»™å‡ºä½ çš„è¾“å…¥å…ƒç´ çš„æ•°é‡å’Œå…ƒç´ å®½åº¦ï¼Œå®ƒå°†ç»™ä½ ä¸€ä¸ªå°äºæˆ–ç­‰äºä½ æä¾›çš„æ•°é‡çš„è®¡æ•°ï¼Œä»¥ä¾¿å°†å…¶è£…å…¥ä¸€ä¸ªå‘é‡å¯„å­˜å™¨ä¸­ã€‚
- en: The code above uses this to iterate over the input, `vl = vsetvl_e8m8(len)`
    represents the of number elements one iteration processes. Next `vle8_v_u8m8()`
    loads `vl` 8-bit integer elements from our input into a vector register.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„ä»£ç ä½¿ç”¨äº†è¿™ä¸ªåŠŸèƒ½æ¥è¿­ä»£è¾“å…¥ï¼Œ`vl = vsetvl_e8m8(len)`ä»£è¡¨ä¸€æ¬¡è¿­ä»£å¤„ç†çš„å…ƒç´ æ•°é‡ã€‚æ¥ä¸‹æ¥çš„`vle8_v_u8m8()`ä»æˆ‘ä»¬çš„è¾“å…¥ä¸­åŠ è½½`vl`ä¸ª8ä½æ•´æ•°å…ƒç´ åˆ°ä¸€ä¸ªå‘é‡å¯„å­˜å™¨ä¸­ã€‚
- en: Then a mask is created where each active element (element where the coresponding
    bit in the mask is set) doesn't match the pattern `**0b10xxxxxx**`. vsrl stands
    for *shift right logical*, and vmsne for *not equal to*, so `vmsne(vsrl(v, **6**,
    vl), **0b10**, vl)` does `(x >> **6**) != **0b10**` on each element. RVV doesn't
    have separate mask registers, instead, masks are stored in the lower bits of a
    vector register, the intrinsics API adds the `vboolN_t` types to give this more
    type safety. Finally, we use `vcpop` to count the number of active elements in
    our mask and add that to our sum.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶ååˆ›å»ºä¸€ä¸ªæ©ç ï¼Œå…¶ä¸­æ¯ä¸ªæ´»åŠ¨å…ƒç´ ï¼ˆæ©ç ä¸­å¯¹åº”ä½è®¾ç½®çš„å…ƒç´ ï¼‰ä¸æ¨¡å¼`**0b10xxxxxx**`ä¸åŒ¹é…ã€‚vsrlä»£è¡¨*å³ç§»é€»è¾‘*ï¼Œvmsneä»£è¡¨*ä¸ç­‰äº*ï¼Œæ‰€ä»¥`vmsne(vsrl(v,
    **6**, vl), **0b10**, vl)`åœ¨æ¯ä¸ªå…ƒç´ ä¸Šæ‰§è¡Œ`(x >> **6**) != **0b10**`ã€‚RVVæ²¡æœ‰å•ç‹¬çš„æ©ç å¯„å­˜å™¨ï¼Œè€Œæ˜¯å°†æ©ç å­˜å‚¨åœ¨å‘é‡å¯„å­˜å™¨çš„ä½ä½ä¸­ï¼Œå†…ç½®APIæ·»åŠ äº†`vboolN_t`ç±»å‹ä»¥æä¾›æ›´å¤šçš„ç±»å‹å®‰å…¨æ€§ã€‚æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨`vcpop`æ¥è®¡ç®—æˆ‘ä»¬çš„æ©ç ä¸­æ´»åŠ¨å…ƒç´ çš„æ•°é‡ï¼Œå¹¶å°†å…¶åŠ åˆ°æˆ‘ä»¬çš„æ€»å’Œä¸­ã€‚
- en: You might be wondering what the "m8" means, I've omitted that so far. RVV has
    32 VLEN bits wide vector registers, but with `vsetvl` you can also configure the
    LMUL (length multiplier), and cause the processor to group these registers. This
    means that subsequent instructions will act on a register group, and `vsetvl`
    will return a `vl` corresponding to LMUL.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½æƒ³çŸ¥é“"m8"æ˜¯ä»€ä¹ˆæ„æ€ï¼Œåˆ°ç›®å‰ä¸ºæ­¢æˆ‘è¿˜æ²¡æœ‰æåˆ°è¿‡ã€‚RVVæœ‰32ä¸ªVLENä½å®½çš„å‘é‡å¯„å­˜å™¨ï¼Œä½†æ˜¯é€šè¿‡`vsetvl`ä½ ä¹Ÿå¯ä»¥é…ç½®LMULï¼ˆé•¿åº¦ä¹˜æ•°ï¼‰ï¼Œå¹¶ä½¿å¤„ç†å™¨å°†è¿™äº›å¯„å­˜å™¨åˆ†ç»„ã€‚è¿™æ„å‘³ç€åç»­æŒ‡ä»¤å°†åœ¨ä¸€ä¸ªå¯„å­˜å™¨ç»„ä¸Šæ‰§è¡Œï¼Œå¹¶ä¸”`vsetvl`å°†è¿”å›ä¸LMULå¯¹åº”çš„`vl`ã€‚
- en: When LMUL=1 we've got 32 VLEN bits wide registers, for LMUL=2 they now act like
    16 VLEN*2 bit wide registers, so for "m8" (LMUL=8), we've got 4 VLEN*8 bit wide
    registers. Here we use less than five vector registers, so using LMUL=8 gives
    us essentially free loop unrolling, which makes the scalar- and mask operations
    less expensive. Unrolling isn't the only advantage of LMUL, it also allows us
    to easily work with mixed-width data, we'll be heavily using this later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: å½“LMUL=1æ—¶ï¼Œæˆ‘ä»¬æœ‰32ä¸ªVLENä½å®½çš„å¯„å­˜å™¨ï¼Œå½“LMUL=2æ—¶ï¼Œå®ƒä»¬ç°åœ¨å°±åƒæ˜¯16ä¸ªVLEN*2ä½å®½çš„å¯„å­˜å™¨ï¼Œæ‰€ä»¥å¯¹äº"m8"ï¼ˆLMUL=8ï¼‰ï¼Œæˆ‘ä»¬æœ‰4ä¸ªVLEN*8ä½å®½çš„å¯„å­˜å™¨ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨å°‘äºäº”ä¸ªå‘é‡å¯„å­˜å™¨ï¼Œæ‰€ä»¥ä½¿ç”¨LMUL=8åŸºæœ¬ä¸Šå°±ç»™äº†æˆ‘ä»¬å…è´¹çš„å¾ªç¯å±•å¼€ï¼Œè¿™ä½¿å¾—æ ‡é‡å’Œæ©ç æ“ä½œçš„æˆæœ¬é™ä½äº†ã€‚å±•å¼€ä¸æ˜¯LMULçš„å”¯ä¸€ä¼˜åŠ¿ï¼Œå®ƒè¿˜å…è®¸æˆ‘ä»¬è½»æ¾åœ°å¤„ç†æ··åˆå®½åº¦çš„æ•°æ®ï¼Œæˆ‘ä»¬ç¨åå°†å¤§é‡ä½¿ç”¨å®ƒã€‚
- en: This also explains why masks are stored in a vector register, more specifically
    in an LMUL=1 vector register, even though they only store one bit per element
    they are referring to. For LMUL=8 and 8-bit elements you need a full LMUL=1 register
    to have enough bits to represent its mask.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¹Ÿè§£é‡Šäº†ä¸ºä»€ä¹ˆæ©ç å­˜å‚¨åœ¨å‘é‡å¯„å­˜å™¨ä¸­ï¼Œæ›´å…·ä½“åœ°è¯´æ˜¯å­˜å‚¨åœ¨LMUL=1å‘é‡å¯„å­˜å™¨ä¸­ï¼Œå³ä½¿å®ƒä»¬æ¯ä¸ªå…ƒç´ åªå­˜å‚¨ä¸€ä¸ªæ¯”ç‰¹ï¼Œå®ƒä»¬æ‰€æŒ‡çš„ã€‚å¯¹äºLMUL=8å’Œ8ä½å…ƒç´ ï¼Œä½ éœ€è¦ä¸€ä¸ªå®Œæ•´çš„LMUL=1å¯„å­˜å™¨æ¥å­˜å‚¨è¶³å¤Ÿçš„æ¯”ç‰¹æ¥è¡¨ç¤ºå…¶æ©ç ã€‚
- en: 'Apart from the RVV feature discussed already, the other features we''ll be
    using are:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†å·²ç»è®¨è®ºè¿‡çš„RVVåŠŸèƒ½ä¹‹å¤–ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨çš„å…¶ä»–åŠŸèƒ½åŒ…æ‹¬ï¼š
- en: '**reductions** over elements: Applies an operation to all elements to produce
    a scalar result. E.g. sum all elements.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å‡å°‘**å…ƒç´ ï¼šå¯¹æ‰€æœ‰å…ƒç´ åº”ç”¨æ“ä½œä»¥äº§ç”Ÿä¸€ä¸ªæ ‡é‡ç»“æœã€‚ä¾‹å¦‚ï¼Œå¯¹æ‰€æœ‰å…ƒç´ æ±‚å’Œã€‚'
- en: '**narrowing/widening** arithmetic operations: Operation that decreases/increases
    element width and LMUL.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**çª„åŒ–/æ‰©å±•**ç®—æœ¯è¿ç®—: å‡å°/å¢åŠ å…ƒç´ å®½åº¦å’ŒLMULçš„æ“ä½œã€‚'
- en: '**permutations**: Instructions to move elements, RVV supports slides, merge
    (blend), compress, and gather (shuffle)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ’åˆ—**: ç§»åŠ¨å…ƒç´ çš„æŒ‡ä»¤ï¼ŒRVVæ”¯æŒæ»‘åŠ¨ã€åˆå¹¶ï¼ˆæ··åˆï¼‰ã€å‹ç¼©å’Œèšé›†ï¼ˆæ´—ç‰Œï¼‰ã€‚'
- en: 'I hope this wasn''t too confusing, here are some more in-depth references on
    RVV if you don''t feel prepared to follow along with the rest of the article:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: å¸Œæœ›è¿™ä¸ä¼šè®©ä½ å¤ªå›°æƒ‘ï¼Œå¦‚æœä½ è§‰å¾—è‡ªå·±è¿˜ä¸å¤Ÿå‡†å¤‡å¥½è·Ÿä¸Šæ–‡ç« çš„åç»­å†…å®¹ï¼Œè¿™é‡Œæœ‰ä¸€äº›å…³äºRVVæ›´æ·±å…¥çš„å‚è€ƒèµ„æ–™ï¼š
- en: 'Unicode defines a set of ~150,000 characters and assigns them a unique 32-bit
    number, called code point. Storing just the code points themself is called UTF-32\.
    This isn''t done in practice, because lower code points occur more often, and
    this wastes a lot of space. There are two other encoding schemes: UTF-8, and UTF-16.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Unicodeå®šä¹‰äº†ä¸€ç»„çº¦150,000ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸ºå®ƒä»¬åˆ†é…äº†ä¸€ä¸ªå”¯ä¸€çš„32ä½æ•°å­—ï¼Œç§°ä¸ºä»£ç ç‚¹ã€‚ä»…å­˜å‚¨ä»£ç ç‚¹æœ¬èº«ç§°ä¸ºUTF-32ã€‚å®é™…ä¸Šä¸è¿™æ ·åšï¼Œå› ä¸ºè¾ƒä½çš„ä»£ç ç‚¹æ›´å¸¸è§ï¼Œè¿™ä¼šæµªè´¹å¤§é‡ç©ºé—´ã€‚è¿˜æœ‰ä¸¤ç§å…¶ä»–çš„ç¼–ç æ–¹æ¡ˆï¼šUTF-8å’ŒUTF-16ã€‚
- en: 'UTF-8 uses one- to four-bytes to represent a code point using the format visualized
    below:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8ä½¿ç”¨ä¸€åˆ°å››ä¸ªå­—èŠ‚æ¥è¡¨ç¤ºä¸€ä¸ªä»£ç ç‚¹ï¼Œä½¿ç”¨ä¸‹é¢å¯è§†åŒ–çš„æ ¼å¼ï¼š
- en: Notice the small Invalid range. Code points between 0xD800-0xDFFF are unassigned
    and invalid, this is used to allow for the UTF-16 encoding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„å°çš„æ— æ•ˆèŒƒå›´ã€‚ä»£ç ç‚¹åœ¨0xD800-0xDFFFä¹‹é—´æ˜¯æœªåˆ†é…å’Œæ— æ•ˆçš„ï¼Œè¿™ç”¨äºå…è®¸UTF-16ç¼–ç ã€‚
- en: UTF-16 encodes the code points from 1, 2 and 3 byte UTF-8 characters directly
    as a single 16-bit character. Four-byte UTF-8 code points are encoded in two 16-bit
    characters by leveraging part of the invalid character range to signal that it's
    a multi-word UTF-16 character.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16ç›´æ¥å°†1ã€2å’Œ3å­—èŠ‚çš„UTF-8å­—ç¬¦çš„ä»£ç ç‚¹ç›´æ¥ç¼–ç ä¸ºå•ä¸ª16ä½å­—ç¬¦ã€‚å››å­—èŠ‚UTF-8ä»£ç ç‚¹é€šè¿‡åˆ©ç”¨éƒ¨åˆ†æ— æ•ˆå­—ç¬¦èŒƒå›´æ¥ä¿¡å·åŒ–ä¸ºå¤šå­—èŠ‚UTF-16å­—ç¬¦çš„ä¸¤ä¸ª16ä½å­—ç¬¦è¿›è¡Œç¼–ç ã€‚
- en: '16-bit words in the range 0xD800-0xDBFF are called high surrogates and in the
    range 0xDC00-0xDFFF low surrogates. A high surrogate is always followed by a low
    surrogate, the code points are encoded as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨èŒƒå›´0xD800-0xDBFFå†…çš„16ä½å­—ç§°ä¸ºé«˜ä»£ç†ï¼Œè€Œåœ¨èŒƒå›´0xDC00-0xDFFFå†…çš„å­—ç§°ä¸ºä½ä»£ç†ã€‚é«˜ä»£ç†æ€»æ˜¯åè·Ÿä½ä»£ç†ï¼Œç¼–ç å¦‚ä¸‹ï¼š
- en: 'Lastly, here is a side-by-side comparison of the encodings for the string "rÎ½á¹¿ğŸ§™",
    which includes all UTF-8 character lengths:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œè¿™é‡Œæ˜¯å­—ç¬¦ä¸²"rÎ½á¹¿ğŸ§™"çš„ç¼–ç çš„å¯¹æ¯”ï¼Œå…¶ä¸­åŒ…æ‹¬æ‰€æœ‰UTF-8å­—ç¬¦é•¿åº¦ï¼š
- en: Our goal is to implement a fast vectorized validating UTF-8 to UTF-16 conversion
    routine, but let's tackle non-validating general UTF-8 to UTF-32 conversion first
    and see where that leads us. We might end up simply converting the Unicode code
    point (UTF-32) to UTF-16, or figure out a use of some intermediate variables to
    get to UTF-16.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç›®æ ‡æ˜¯å®ç°ä¸€ä¸ªå¿«é€Ÿçš„çŸ¢é‡åŒ–éªŒè¯UTF-8åˆ°UTF-16çš„è½¬æ¢ä¾‹ç¨‹ï¼Œä½†è®©æˆ‘ä»¬é¦–å…ˆè§£å†³ééªŒè¯é€šç”¨UTF-8åˆ°UTF-32çš„è½¬æ¢ï¼Œçœ‹çœ‹è¿™ä¼šå¸¦ç»™æˆ‘ä»¬ä»€ä¹ˆã€‚æˆ‘ä»¬å¯èƒ½æœ€ç»ˆä¼šç®€å•åœ°å°†Unicodeä»£ç ç‚¹ï¼ˆUTF-32ï¼‰è½¬æ¢ä¸ºUTF-16ï¼Œæˆ–è€…æ‰¾å‡ºä¸€äº›ä¸­é—´å˜é‡çš„ç”¨æ³•æ¥å¾—åˆ°UTF-16ã€‚
- en: 'So, this leaves us with a few things to do:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œè¿™ç»™æˆ‘ä»¬ç•™ä¸‹äº†ä¸€äº›äº‹æƒ…è¦åšï¼š
- en: identify character positions
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¡®å®šå­—ç¬¦ä½ç½®
- en: remove prefixes
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç§»é™¤å‰ç¼€
- en: combine to UTF-32 code point
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»„åˆåˆ°UTF-32ä»£ç ç‚¹
- en: The most important question seems to be, how we deal with the different character
    sizes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€é‡è¦çš„é—®é¢˜ä¼¼ä¹æ˜¯ï¼Œæˆ‘ä»¬å¦‚ä½•å¤„ç†ä¸åŒçš„å­—ç¬¦å¤§å°ã€‚
- en: 'Initially, I had two ideas on how to approach this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: èµ·åˆï¼Œæˆ‘æœ‰ä¸¤ä¸ªæƒ³æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š
- en: '**vdecompress:** Skimming through the specification, the first instruction
    that seemed to fit the bill was vdecompress. Although it isn''t really an instruction,
    but rather a combination of the `viota` and `vrgather` instructions to synthesize
    a `vcompress` inverse. It uses a mask to move every nth element of a vector to
    the nth active element in the source register. This could allow us to widen every
    UTF-8 character to four bytes long, so we can work on the different-sized characters
    uniformly.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vdecompress:** æµè§ˆè§„èŒƒï¼Œçœ‹èµ·æ¥ç¬¦åˆæ¡ä»¶çš„ç¬¬ä¸€æ¡æŒ‡ä»¤æ˜¯vdecompressã€‚å°½ç®¡å®ƒå®é™…ä¸Šå¹¶ä¸æ˜¯ä¸€æ¡æŒ‡ä»¤ï¼Œè€Œæ˜¯`viota`å’Œ`vrgather`æŒ‡ä»¤çš„ç»„åˆï¼Œç”¨äºåˆæˆä¸€ä¸ª`vcompress`çš„é€†è¿‡ç¨‹ã€‚å®ƒä½¿ç”¨ä¸€ä¸ªæ©ç å°†å‘é‡çš„æ¯ä¸ªç¬¬nä¸ªå…ƒç´ ç§»åŠ¨åˆ°æºå¯„å­˜å™¨ä¸­çš„ç¬¬nä¸ªæ´»åŠ¨å…ƒç´ ã€‚è¿™å¯ä»¥ä½¿æˆ‘ä»¬å°†æ¯ä¸ªUTF-8å­—ç¬¦æ‰©å±•ä¸ºå››ä¸ªå­—èŠ‚é•¿ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç»Ÿä¸€å¤„ç†ä¸åŒå¤§å°çš„å­—ç¬¦ã€‚'
- en: '**vcompress:** Alternatively we could also `vcompress` every nth byte of all
    UTF-8 characters into the nth of four separate vector registers. Then we could
    also write code that operates on all character sizes uniformly, but we''d need
    to recombine the registers to store the final code point.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vcompress:** æˆ–è€…æˆ‘ä»¬ä¹Ÿå¯ä»¥`vcompress`æ¯ä¸ªUTF-8å­—ç¬¦çš„ç¬¬nä¸ªå­—èŠ‚åˆ°å››ä¸ªå•ç‹¬çš„å‘é‡å¯„å­˜å™¨çš„ç¬¬nä¸ªå­—èŠ‚ã€‚ç„¶åæˆ‘ä»¬ä¹Ÿå¯ä»¥ç¼–å†™æ“ä½œæ‰€æœ‰å­—ç¬¦å¤§å°çš„ä»£ç ï¼Œä½†æˆ‘ä»¬éœ€è¦é‡æ–°ç»„åˆå¯„å­˜å™¨ä»¥å­˜å‚¨æœ€ç»ˆçš„ä»£ç ç‚¹ã€‚'
- en: The first approach seemed quite promising to me, so I sketched out the creation
    of the decompress-mask but got stuck on how to proceed from there. The problem
    is, that now you go from an input register of, let's for now assume LMUL=1, to
    an LMUL=4 register, and still need to do all of the logic to remove prefixes and
    shift the bits into place. That makes every operation we do four times slower,
    and we'd need to quite a few operations. Add to that, that `vrgather` is slow
    with larger LMULs (see [later discussion](#gather)), and this doesn't seem like
    that good of an idea anymore.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ç§æ–¹æ³•å¯¹æˆ‘æ¥è¯´ä¼¼ä¹å¾ˆæœ‰å‰é€”ï¼Œæ‰€ä»¥æˆ‘è‰ç»˜äº†åˆ›å»ºè§£å‹ç¼©æ©ç çš„è¿‡ç¨‹ï¼Œä½†å¡åœ¨äº†å¦‚ä½•ç»§ç»­çš„åœ°æ–¹ã€‚é—®é¢˜æ˜¯ï¼Œç°åœ¨ä½ ä»ä¸€ä¸ªè¾“å…¥å¯„å­˜å™¨è½¬åˆ°äº†ï¼Œæš‚æ—¶å‡è®¾LMUL=1ï¼Œåˆ°ä¸€ä¸ªLMUL=4å¯„å­˜å™¨ï¼Œä»ç„¶éœ€è¦åšæ‰€æœ‰å»é™¤å‰ç¼€å¹¶å°†ä½ç§»åŠ¨åˆ°ä½çš„é€»è¾‘ã€‚è¿™ä½¿å¾—æˆ‘ä»¬è¿›è¡Œçš„æ¯ä¸ªæ“ä½œéƒ½æ…¢äº†å››å€ï¼Œè€Œä¸”æˆ‘ä»¬éœ€è¦è¿›è¡Œç›¸å½“å¤šçš„æ“ä½œã€‚åŠ ä¸Š`vrgather`å¯¹äºè¾ƒå¤§çš„LMULçš„é€Ÿåº¦è¾ƒæ…¢ï¼ˆè§[åç»­è®¨è®º](#gather)ï¼‰ï¼Œè¿™ä¼¼ä¹ä¸å†æ˜¯ä¸€ä¸ªå¥½ä¸»æ„äº†ã€‚
- en: Let's consider the `vcompress` approach again. Once we've removed the prefixes
    from our four registers, we get the "shifting the bits into the right position"
    part basically for free, because we need to recombine them anyway. Using a widening
    multiply makes combining them while shifting by six bits even easier than interleaving
    the bytes (shifting by eight bits), because we can't multiply by `**1**<<**8**`
    since it doesn't fit into 8-bits.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å†æ¬¡è€ƒè™‘ `vcompress` æ–¹æ³•ã€‚ä¸€æ—¦æˆ‘ä»¬ä»å››ä¸ªå¯„å­˜å™¨ä¸­ç§»é™¤äº†å‰ç¼€ï¼Œæˆ‘ä»¬åŸºæœ¬ä¸Šå°±å¯ä»¥å…è´¹è·å¾—â€œå°†ä½ç§»åŠ¨åˆ°æ­£ç¡®ä½ç½®â€çš„éƒ¨åˆ†ï¼Œå› ä¸ºæ— è®ºå¦‚ä½•æˆ‘ä»¬éƒ½éœ€è¦é‡æ–°ç»„åˆå®ƒä»¬ã€‚ä½¿ç”¨æ‰©å±•ä¹˜æ³•ä½¿å¾—åœ¨ç§»ä½å…­ä½çš„åŒæ—¶ç»„åˆå®ƒä»¬å˜å¾—æ›´å®¹æ˜“ï¼Œç”šè‡³æ¯”äº¤é”™å­—èŠ‚ï¼ˆç§»ä½å…«ä½ï¼‰è¿˜è¦å®¹æ˜“ï¼Œå› ä¸ºæˆ‘ä»¬æ— æ³•ç”¨
    `**1**<<**8**` ä¹˜ä»¥ 8 ä½ã€‚
- en: I was hoping to use masked widening adds and multiplies, but that didn't end
    up being worth it, as we need to specify a destination operand that is already
    widened. Another complication is that combining the first two bytes with the last
    two bytes needs to shift the first two by 0, 6 or 12 bits, which doesn't nicely
    translate into a masked operation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æœ¬æ¥å¸Œæœ›ä½¿ç”¨æ©ç æ‰©å±•åŠ æ³•å’Œä¹˜æ³•ï¼Œä½†ç»“æœè¯æ˜å¹¶ä¸å€¼å¾—ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦æŒ‡å®šä¸€ä¸ªå·²ç»æ‰©å±•çš„ç›®æ ‡æ“ä½œæ•°ã€‚å¦ä¸€ä¸ªå¤æ‚ä¹‹å¤„åœ¨äºï¼Œå°†å‰ä¸¤ä¸ªå­—èŠ‚ä¸åä¸¤ä¸ªå­—èŠ‚ç»„åˆéœ€è¦å°†å‰ä¸¤ä¸ªå­—èŠ‚å·¦ç§»
    0ã€6 æˆ– 12 ä½ï¼Œè¿™å¹¶ä¸èƒ½å¾ˆå¥½åœ°è½¬æ¢ä¸ºæ©ç æ“ä½œã€‚
- en: We can however always act like we have a four-byte UTF-8 character and later
    calculate and apply a correction right shift amount. This also removes the need
    to mask the add operations, as any residual bits are shifted away.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯æˆ‘ä»¬æ€»æ˜¯å¯ä»¥å‡è£…æˆ‘ä»¬æœ‰ä¸€ä¸ªå››å­—èŠ‚çš„ UTF-8 å­—ç¬¦ï¼Œç„¶åè®¡ç®—å¹¶åº”ç”¨ä¸€ä¸ªæ­£ç¡®çš„å³ç§»é‡ã€‚è¿™ä¹Ÿæ¶ˆé™¤äº†éœ€è¦å±è”½åŠ æ³•æ“ä½œçš„å¿…è¦æ€§ï¼Œå› ä¸ºä»»ä½•å‰©ä½™çš„ä½éƒ½ä¼šè¢«ç§»ä½æ‰ã€‚
- en: 'So here is the game plan:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘ä»¬çš„æ¸¸æˆè®¡åˆ’å¦‚ä¸‹ï¼š
- en: 'We want to process the input in chunks, but if we were to load the data directly
    into a single vector register, we''d need to figure out where the last full character
    ends in the register. Instead of doing that we can always lookahead three bytes,
    and only consider them as continuation bytes, you''ll see why that works out quite
    well later. Here is the framework we''ll be building on top of:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æƒ³è¦ä»¥å—çš„å½¢å¼å¤„ç†è¾“å…¥ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬ç›´æ¥å°†æ•°æ®åŠ è½½åˆ°å•ä¸ªçŸ¢é‡å¯„å­˜å™¨ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å¼„æ¸…æ¥šå¯„å­˜å™¨ä¸­æœ€åä¸€ä¸ªå®Œæ•´å­—ç¬¦çš„ç»“æŸä½ç½®ã€‚æˆ‘ä»¬å¯ä»¥å§‹ç»ˆå‘å‰çœ‹ä¸‰ä¸ªå­—èŠ‚ï¼Œåªå°†å®ƒä»¬è§†ä¸ºè¿ç»­å­—èŠ‚ï¼Œç¨åä½ ä¼šçœ‹åˆ°ä¸ºä»€ä¹ˆè¿™æ ·åšéå¸¸åˆé€‚ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬å°†è¦æ„å»ºçš„æ¡†æ¶ï¼š
- en: '[PRE2]``'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]``'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*/* IMPL: extract b1/b2/b3/b4 */*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* IMPL: æå– b1/b2/b3/b4 */*'
- en: vuint8m2_t v1 = __riscv_vslide1down(v0, src[vl+**0**], vl);
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t v1 = __riscv_vslide1down(v0, src[vl+**0**], vl);
- en: vuint8m2_t v2 = __riscv_vslide1down(v1, src[vl+**1**], vl);
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t v2 = __riscv_vslide1down(v1, src[vl+**1**], vl);
- en: vuint8m2_t v3 = __riscv_vslide1down(v2, src[vl+**2**], vl);
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t v3 = __riscv_vslide1down(v2, src[vl+**2**], vl);
- en: '*/* mask of non-continuation bytes */*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* éè¿ç»­å­—èŠ‚çš„æ©ç  */*'
- en: vbool4_t m = __riscv_vmsne(__riscv_vsrl(v0, **6**, vl), **0b10**, vl);
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: vbool4_t m = __riscv_vmsne(__riscv_vsrl(v0, **6**, vl), **0b10**, vl);
- en: '*/* extract third and fourth bytes */*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* æå–ç¬¬ä¸‰å’Œç¬¬å››ä¸ªå­—èŠ‚ */*'
- en: vuint8m2_t b1 = __riscv_vcompress(v0, m, vl);
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t b1 = __riscv_vcompress(v0, m, vl);
- en: vuint8m2_t b2 = __riscv_vcompress(v1, m, vl);
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t b2 = __riscv_vcompress(v1, m, vl);
- en: vuint8m2_t b3 = __riscv_vcompress(v2, m, vl);
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t b3 = __riscv_vcompress(v2, m, vl);
- en: vuint8m2_t b4 = __riscv_vcompress(v3, m, vl);
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t b4 = __riscv_vcompress(v3, m, vl);
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*/* IMPL: remove prefixes */*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* IMPL: ç§»é™¤å‰ç¼€ */*'
- en: '*/* remove prefix from trailing bytes */*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* ç§»é™¤å°¾éƒ¨å­—èŠ‚çš„å‰ç¼€ */*'
- en: vlOut = __riscv_vcpop(m, vl);
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: vlOut = __riscv_vcpop(m, vl);
- en: b2 = __riscv_vand(b2, **0b00111111**, vlOut);
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: b2 = __riscv_vand(b2, **0b00111111**, vlOut);
- en: b3 = __riscv_vand(b3, **0b00111111**, vlOut);
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: b3 = __riscv_vand(b3, **0b00111111**, vlOut);
- en: b4 = __riscv_vand(b4, **0b00111111**, vlOut);
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: b4 = __riscv_vand(b4, **0b00111111**, vlOut);
- en: '*/* TODO: remove prefix from leading bytes */*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* TODO: ç§»é™¤å‰å¯¼å­—èŠ‚çš„å‰ç¼€ */*'
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*/* IMPL: remove prefix from leading bytes */*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* IMPL: ç§»é™¤å‰å¯¼å­—èŠ‚çš„å‰ç¼€ */*'
- en: vuint8m2_t shift = __riscv_vsrl(b1, **4**, vlOut);
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t shift = __riscv_vsrl(b1, **4**, vlOut);
- en: shift = __riscv_vmerge(__riscv_vssubu(shift, **10**, vlOut), **3**,
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: shift = __riscv_vmerge(__riscv_vssubu(shift, **10**, vlOut), **3**,
- en: __riscv_vmseq(shift, **12**, vlOut), vlOut);
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vmseq(shift, **12**, vlOut), vlOut);
- en: b1 = __riscv_vsll(b1, shift, vlOut);
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: b1 = __riscv_vsll(b1, shift, vlOut);
- en: b1 = __riscv_vsrl(b1, shift, vlOut);
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: b1 = __riscv_vsrl(b1, shift, vlOut);
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*/* IMPL: combine to b1234 */*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* IMPL: åˆå¹¶åˆ° b1234 */*'
- en: '*/* unconditionally widen and combine to b1234 */*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* æ— æ¡ä»¶åœ°æ‰©å±•å’Œåˆå¹¶åˆ° b1234 */*'
- en: vuint16m4_t b34   = __riscv_vwaddu_wv(__riscv_vwmulu(b3,  **1**<<**6**,  vlOut),
    b4,  vlOut);
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: vuint16m4_t b34   = __riscv_vwaddu_wv(__riscv_vwmulu(b3,  **1**<<**6**,  vlOut),
    b4,  vlOut);
- en: vuint16m4_t b12   = __riscv_vwaddu_wv(__riscv_vwmulu(b1,  **1**<<**6**,  vlOut),
    b2,  vlOut);
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: vuint16m4_t b12   = __riscv_vwaddu_wv(__riscv_vwmulu(b1,  **1**<<**6**,  vlOut),
    b2,  vlOut);
- en: vuint32m8_t b1234 = __riscv_vwaddu_wv(__riscv_vwmulu(b12, **1**<<**12**, vlOut),
    b34, vlOut);
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: vuint32m8_t b1234 = __riscv_vwaddu_wv(__riscv_vwmulu(b12, **1**<<**12**, vlOut),
    b34, vlOut);
- en: '*/* TODO: compute shift amount */*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* TODO: è®¡ç®—ç§»ä½é‡ */*'
- en: b1234 = __riscv_vsrl(b1234, __riscv_vzext_vf4(shift, vlOut), vlOut);
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: b1234 = __riscv_vsrl(b1234, __riscv_vzext_vf4(shift, vlOut), vlOut);
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*/* IMPL: compute shift amount */*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* IMPL: è®¡ç®—ç§»ä½é‡ */*'
- en: '*/* derive required right-shift amount from `shift` to reduce*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* ä» `shift` æ´¾ç”Ÿæ‰€éœ€çš„å³ç§»é‡ä»¥å‡å°‘ */'
- en: '** b1234 to the required number of bytes */*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '** b1234 åˆ°æ‰€éœ€çš„å­—èŠ‚æ•° */*'
- en: shift = __riscv_vmul(__riscv_vrsub(__riscv_vssubu(shift, **2**, vlOut), **3**,
    vlOut), **6**, vlOut);
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: shift = __riscv_vmul(__riscv_vrsub(__riscv_vssubu(shift, **2**, vlOut), **3**,
    vlOut), **6**, vlOut);
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#define VRGATHER_u8m1x2(tbl, idx) \'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#define VRGATHER_u8m1x2(tbl, idx) \'
- en: __riscv_vset(__riscv_vlmul_ext_u8m2( \
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vset(__riscv_vlmul_ext_u8m2( \
- en: __riscv_vrgather(tbl, __riscv_vget_u8m1(idx, **0**), vl8m1)), **1**, \
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vrgather(tbl, __riscv_vget_u8m1(idx, **0**), vl8m1)), **1**, \
- en: __riscv_vrgather(tbl, __riscv_vget_u8m1(idx, **1**), vl8m1));
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vrgather(tbl, __riscv_vget_u8m1(idx, **1**), vl8m1));
- en: '`static const uint64_t err1m[] = { **0x0202020202020202**, **0x4915012180808080**
    };`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`static const uint64_t err1m[] = { **0x0202020202020202**, **0x4915012180808080**
    };`'
- en: '`static const uint64_t err2m[] = { **0xCBCBCB8B8383A3E7**, **0xCBCBDBCBCBCBCBCB**
    };`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`static const uint64_t err2m[] = { **0xCBCBCB8B8383A3E7**, **0xCBCBDBCBCBCBCBCB**
    };`'
- en: '`static const uint64_t err3m[] = { **0x0101010101010101**, **0x01010101BABAAEE6**
    };`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`static const uint64_t err3m[] = { **0x0101010101010101**, **0x01010101BABAAEE6**
    };`'
- en: '`const vuint8m1_t err1tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err1m,
    **2**));`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`const vuint8m1_t err1tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err1m,
    **2**));`'
- en: '`const vuint8m1_t err2tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err2m,
    **2**));`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`const vuint8m1_t err2tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err2m,
    **2**));`'
- en: '`const vuint8m1_t err3tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err3m,
    **2**));`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`const vuint8m1_t err3tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err3m,
    **2**));`'
- en: '`const size_t vl8m1 = __riscv_vsetvlmax_e8m1();`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`const size_t vl8m1 = __riscv_vsetvlmax_e8m1();`'
- en: '`const size_t vl16m2 = __riscv_vsetvlmax_e16m2();`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`const size_t vl16m2 = __riscv_vsetvlmax_e16m2();`'
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*...*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*...*'
- en: '*vuint8m2_t v3 = __riscv_vslide1down(v2, src[vl+2], vl);*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*vuint8m2_t v3 = __riscv_vslide1down(v2, src[vl+2], vl);*'
- en: '`vuint8m2_t s1 = __riscv_vreinterpret_u8m2(__riscv_vsrl(__riscv_vreinterpret_u16m2(v2),
    **4**, vl16m2));`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t s1 = __riscv_vreinterpret_u8m2(__riscv_vsrl(__riscv_vreinterpret_u16m2(v2),
    **4**, vl16m2));`'
- en: '`vuint8m2_t s3 = __riscv_vreinterpret_u8m2(__riscv_vsrl(__riscv_vreinterpret_u16m2(v3),
    **4**, vl16m2));`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t s3 = __riscv_vreinterpret_u8m2(__riscv_vsrl(__riscv_vreinterpret_u16m2(v3),
    **4**, vl16m2));`'
- en: '``vuint8m2_t idx2 = __riscv_vand(v2, **0xF**, vl);`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t idx2 = __riscv_vand(v2, **0xF**, vl);`'
- en: '`vuint8m2_t idx1 = __riscv_vand(s1, **0xF**, vl);`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t idx1 = __riscv_vand(s1, **0xF**, vl);`'
- en: '`vuint8m2_t idx3 = __riscv_vand(s3, **0xF**, vl);`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t idx3 = __riscv_vand(s3, **0xF**, vl);`'
- en: '``vuint8m2_t err1 = VRGATHER_u8m1x2(err1tbl, idx1);`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t err1 = VRGATHER_u8m1x2(err1tbl, idx1);`'
- en: '`vuint8m2_t err2 = VRGATHER_u8m1x2(err2tbl, idx2);`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t err2 = VRGATHER_u8m1x2(err2tbl, idx2);`'
- en: '`vuint8m2_t err3 = VRGATHER_u8m1x2(err3tbl, idx3);`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t err3 = VRGATHER_u8m1x2(err3tbl, idx3);`'
- en: '`vint8m2_t  errs = __riscv_vreinterpret_i8m2(`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`vint8m2_t  errs = __riscv_vreinterpret_i8m2(`'
- en: '`__riscv_vand(__riscv_vand(err1, err2, vl), err3, vl));`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`__riscv_vand(__riscv_vand(err1, err2, vl), err3, vl));`'
- en: '`*/* TODO: detect 3/4 byte errors */*[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`*/* TODO: æ£€æµ‹ 3/4 å­—èŠ‚é”™è¯¯ */*[PRE10]'
- en: '``To check for 3/4 byte errors, we check if the previous input had a 3 or 4
    byte character, which should be followed by two continuation bytes. There is no
    error, if we expect two continuations and get them, and if we don''t expect two
    continuations and don''t get them, this maps perfectly to an XOR operation. We
    use the fact, that the upper bit of our error bit set indicates the expectation
    of two continuations. Interpreting the byte as a signed number, lets us easily
    check if the MSB bit is set (`x < 0`) and if any of the other bits are set (`x
    > 0`).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`æ£€æŸ¥ 3/4 å­—èŠ‚é”™è¯¯ï¼Œæˆ‘ä»¬æ£€æŸ¥å‰ä¸€ä¸ªè¾“å…¥æ˜¯å¦æœ‰ 3 æˆ– 4 å­—èŠ‚çš„å­—ç¬¦ï¼Œå…¶ååº”è¯¥æ˜¯ä¸¤ä¸ªç»§ç»­å­—èŠ‚ã€‚å¦‚æœæˆ‘ä»¬æœŸæœ›ä¸¤ä¸ªç»§ç»­å­—èŠ‚å¹¶ä¸”å¾—åˆ°å®ƒä»¬ï¼Œæ²¡æœ‰é”™è¯¯ï¼Œå¦‚æœæˆ‘ä»¬ä¸æœŸæœ›ä¸¤ä¸ªç»§ç»­å­—èŠ‚å¹¶ä¸”æ²¡æœ‰å¾—åˆ°å®ƒä»¬ï¼Œè¿™å°±å®Œç¾åœ°æ˜ å°„åˆ°å¼‚æˆ–æ“ä½œã€‚æˆ‘ä»¬åˆ©ç”¨äº†é”™è¯¯ä½é›†çš„æœ€é«˜ä½æŒ‡ç¤ºäº†æœŸæœ›çš„ä¸¤ä¸ªç»§ç»­å­—èŠ‚ã€‚å°†å­—èŠ‚è§£é‡Šä¸ºæœ‰ç¬¦å·æ•°ï¼Œè®©æˆ‘ä»¬è½»æ¾åœ°æ£€æŸ¥
    MSB ä½æ˜¯å¦è®¾ç½®ï¼ˆ`x < 0`ï¼‰ï¼Œä»¥åŠæ˜¯å¦æœ‰å…¶ä»–ä½è¢«è®¾ç½®ï¼ˆ`x > 0`ï¼‰ã€‚`'
- en: Finally, we test if our error mask contains an error, and exit the function
    with an error code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬æµ‹è¯•é”™è¯¯æ©ç æ˜¯å¦åŒ…å«é”™è¯¯ï¼Œå¹¶ä½¿ç”¨é”™è¯¯ä»£ç é€€å‡ºå‡½æ•°ã€‚
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Lastly, we can''t forget about the first three bytes. They could e.g. be all
    continuation bytes, which would cause our loop to ignore them. Before the start
    of our loop, we find the end of the thired UTF-8 character and pass that to a
    scalar validation routine, here we reuse `utf8_to_utf32_scalar` for simplicity:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`æœ€åï¼Œæˆ‘ä»¬ä¸èƒ½å¿˜è®°å‰ä¸‰ä¸ªå­—èŠ‚ã€‚å®ƒä»¬å¯ä»¥æ˜¯å…¨éƒ¨ç»§ç»­å­—èŠ‚ï¼Œè¿™å°†å¯¼è‡´æˆ‘ä»¬çš„å¾ªç¯å¿½ç•¥å®ƒä»¬ã€‚åœ¨æˆ‘ä»¬çš„å¾ªç¯å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬æ‰¾åˆ°ç¬¬ä¸‰ä¸ª UTF-8 å­—ç¬¦çš„ç»“å°¾å¹¶å°†å…¶ä¼ é€’ç»™æ ‡é‡éªŒè¯ä¾‹ç¨‹ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸ºç®€å•èµ·è§é‡ç”¨
    `utf8_to_utf32_scalar`ï¼š`'
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now for the fun part, making things faster.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨åˆ°äº†æœ‰è¶£çš„éƒ¨åˆ†ï¼Œè®©äº‹æƒ…å˜å¾—æ›´å¿«ã€‚
- en: 'If we read an all ASCII vector, then we can skip the validation pass, and simply
    widen and store the vector. We use a max reduction to determine if we have only
    ASCII bytes, the result of which we can also use for our other fast paths:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è¯»å–äº†å…¨ ASCII å‘é‡ï¼Œåˆ™å¯ä»¥è·³è¿‡éªŒè¯è¿‡ç¨‹ï¼Œç›´æ¥æ‰©å±•å’Œå­˜å‚¨å‘é‡ã€‚æˆ‘ä»¬ä½¿ç”¨æœ€å¤§å½’çº¦æ¥ç¡®å®šæ˜¯å¦åªæœ‰ ASCII å­—èŠ‚ï¼Œå…¶ç»“æœæˆ‘ä»¬è¿˜å¯ä»¥ç”¨äºå…¶ä»–å¿«é€Ÿè·¯å¾„ï¼š
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`This fast path needs to happen after validation. We are only concerned with
    creating b12 from b1 and b2, which allows us to simplify the code from the general
    case a lot.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`è¿™ä¸ªå¿«é€Ÿè·¯å¾„éœ€è¦åœ¨éªŒè¯ä¹‹åå‘ç”Ÿã€‚æˆ‘ä»¬åªå…³å¿ƒä» b1 å’Œ b2 åˆ›å»º b12ï¼Œè¿™ä½¿æˆ‘ä»¬å¯ä»¥å¤§å¤§ç®€åŒ–ä»£ç ï¼Œä»è€Œç®€åŒ–äº†ä¸€èˆ¬æƒ…å†µã€‚'
- en: We don't need to bother with shifting to remove the prefix from b1, there are
    only two possibilities, and one is to do nothing, hence a masked and fits perfectly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸éœ€è¦ä¸ºäº†ä» b1 ä¸­ç§»é™¤å‰ç¼€è€Œè¿›è¡Œä½ç§»ï¼Œåªæœ‰ä¸¤ç§å¯èƒ½æ€§ï¼Œè€Œä¸”å…¶ä¸­ä¸€ç§æ˜¯ä¸è¿›è¡Œä»»ä½•æ“ä½œï¼Œå› æ­¤æ©ç å’Œé€‚åˆå¾—å¾ˆå¥½ã€‚
- en: We still can't use a masked widening multiply without first widening the destination
    operand, but we can use a simple `vmerge` to select between the two possible shift
    values. The addition can then be done using a masked widening add because the
    destination is already widened.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ‰©å±•ç›®æ ‡æ“ä½œæ•°ä¹‹å‰ï¼Œæˆ‘ä»¬ä»ç„¶ä¸èƒ½ä½¿ç”¨æ©ç æ‰©å±•ä¹˜æ³•ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç®€å•çš„`vmerge`æ¥åœ¨ä¸¤ä¸ªå¯èƒ½çš„ä½ç§»å€¼ä¹‹é—´è¿›è¡Œé€‰æ‹©ã€‚ç”±äºç›®çš„åœ°å·²ç»æ‰©å±•äº†ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨æ©ç æ‰©å±•åŠ æ³•æ¥è¿›è¡ŒåŠ æ³•ã€‚
- en: 'Now we need to zero extend again and we are done:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬éœ€è¦å†æ¬¡è¿›è¡Œé›¶æ‰©å±•ï¼Œç„¶åå°±å®Œæˆäº†ï¼š
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`I''ll leave understanding this one as an exercise to the reader, note that
    the code points of all three and below byte UTF-8 characters fit into 16 bytes.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`æˆ‘å°†è¿™ä¸ªç•™ç»™è¯»è€…å»ç†è§£ï¼Œæ³¨æ„æ‰€æœ‰ä¸‰å­—èŠ‚åŠä»¥ä¸‹å­—èŠ‚çš„ UTF-8 å­—ç¬¦çš„ä»£ç ç‚¹éƒ½é€‚åˆäº 16 ä¸ªå­—èŠ‚ã€‚'
- en: '[PRE15]`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]`'
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: size_t vl8m4 = __riscv_vsetvlmax_e8m4();
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: size_t vl8m4 = __riscv_vsetvlmax_e8m4();
- en: const vbool2_t m2even = __riscv_vmseq(__riscv_vand(__riscv_vid_v_u8m4(vl8m4),
    **1**, vl8m4), **0**, vl8m4);
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: const vbool2_t m2even = __riscv_vmseq(__riscv_vand(__riscv_vid_v_u8m4(vl8m4),
    **1**, vl8m4), **0**, vl8m4);
- en: '#define DOWN __riscv_vreinterpret_u16m8'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#define DOWN __riscv_vreinterpret_u16m8'
- en: '#define UP __riscv_vreinterpret_u32m8'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#define UP __riscv_vreinterpret_u32m8'
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*...*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*...*'
- en: '*b1234 = __riscv_vsrl(b1234, ...);*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*b1234 = __riscv_vsrl(b1234, ...);*'
- en: '*/* convert [000000000000aaaa|aaaaaabbbbbbbbbb]*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* è½¬æ¢ä¸º [000000000000aaaa|aaaaaabbbbbbbbbb]*'
- en: '** to      [110111bbbbbbbbbb|110110aaaaaaaaaa] */*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '** è½¬æ¢ä¸º      [110111bbbbbbbbbb|110110aaaaaaaaaa] */*'
- en: vuint32m8_t sur = __riscv_vsub(b1234, **0x10000**, vlOut);
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: vuint32m8_t sur = __riscv_vsub(b1234, **0x10000**, vlOut);
- en: sur = __riscv_vor(__riscv_vsll(sur, **16**, vlOut),
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: sur = __riscv_vor(__riscv_vsll(sur, **16**, vlOut),
- en: __riscv_vsrl(sur, **10**, vlOut), vlOut);
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vsrl(sur, **10**, vlOut), vlOut);
- en: sur = __riscv_vand(sur, **0x3FF03FF**, vlOut);
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: sur = __riscv_vand(sur, **0x3FF03FF**, vlOut);
- en: sur = __riscv_vor(sur, **0xDC00D800**, vlOut);
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: sur = __riscv_vor(sur, **0xDC00D800**, vlOut);
- en: '*/* merge 1 byte b1234 and 2 byte sur */*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* åˆå¹¶ 1 å­—èŠ‚ b1234 å’Œ 2 å­—èŠ‚ sur */*'
- en: vbool4_t m4 = __riscv_vmsgtu(b1234, **0xFFFF**, vlOut);
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: vbool4_t m4 = __riscv_vmsgtu(b1234, **0xFFFF**, vlOut);
- en: b1234 = __riscv_vmerge(b1234, sur, m4, vlOut);
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: b1234 = __riscv_vmerge(b1234, sur, m4, vlOut);
- en: '*/* swap b1234 two byte pairs */*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* äº¤æ¢ b1234 çš„ä¸¤ä¸ªå­—èŠ‚å¯¹ */*'
- en: '*/* compress and store */*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* å‹ç¼©å¹¶å­˜å‚¨ */*'
- en: vbool2_t mOut = __riscv_vmor(__riscv_vmsne(DOWN(b1234), **0**, vlOut***2**),
    m2even, vlOut***2**);
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: vbool2_t mOut = __riscv_vmor(__riscv_vmsne(DOWN(b1234), **0**, vlOut***2**),
    m2even, vlOut***2**);
- en: b1234 = UP(__riscv_vcompress(DOWN(b1234), mOut, vlOut***2**));
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: b1234 = UP(__riscv_vcompress(DOWN(b1234), mOut, vlOut***2**));
- en: size_t vlDest = __riscv_vcpop(mOut, vlOut***2**);
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: size_t vlDest = __riscv_vcpop(mOut, vlOut***2**);
- en: __riscv_vse16_v_u16m8(dest, DOWN(b1234), vlDest);
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vse16_v_u16m8(dest, DOWN(b1234), vlDest);
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*/* reparse last character + tail */*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* é‡æ–°è§£ææœ€åä¸€ä¸ªå­—ç¬¦ + å°¾å·´ */*'
- en: '*if (count > tail) {*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*if (count > tail) {*'
- en: '*if ((src[0] >> 6) == 0b10) --dest;*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*if ((src[0] >> 6) == 0b10) --dest;*'
- en: '*while ((src[0] >> 6) == 0b10 && tail < count)*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*while ((src[0] >> 6) == 0b10 && tail < count)*'
- en: '*--src, ++tail;*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*--src, ++tail;*'
- en: '*/* go back one more, when on high surrogate */*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* åœ¨é«˜ä»£ç†æ—¶å†å›é€€ä¸€ä¸ª */*'
- en: if (dest[-**1**] >= **0xD800** && dest[-**1**] <= **0xDBFF**)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: if (dest[-**1**] >= **0xD800** && dest[-**1**] <= **0xDBFF**)
- en: --dest;
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: --dest;
- en: '*}*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*}*'
- en: '[PRE19][PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19][PRE20]'
