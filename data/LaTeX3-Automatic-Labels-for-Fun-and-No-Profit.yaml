- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-29 12:30:04'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-29 12:30:04
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: LaTeX3 Automatic Labels for Fun and No Profit
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LaTeX3 自动标签：有趣且无盈利
- en: 来源：[https://commutative.xyz/~miguelmurca/blog/x/autoref.html](https://commutative.xyz/~miguelmurca/blog/x/autoref.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://commutative.xyz/~miguelmurca/blog/x/autoref.html](https://commutative.xyz/~miguelmurca/blog/x/autoref.html)
- en: LaTeX3 Automatic Labels for Fun and No Profit
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LaTeX3 自动标签：有趣且无盈利
- en: I’m a PhD student in physics, which means I’ve spent the better part of the
    last 10 years writing LaTeX. For those not in the know, LaTeX is a 40-year old
    superset of a 46-year old typesetting system – i.e., a macro based programming
    language to produce print documents. Notably, it’s mostly intended *not* as a
    programming language; its strongest suit is arguably the way it beautifully typesets
    mathematics, and its solution to express complex mathematical expressions. For
    example,
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一名物理学的博士生，这意味着我过去 10 年大部分时间都在写 LaTeX。对于不了解的人来说，LaTeX 是一个 40 年历史的超集，属于 46 年历史的排版系统
    - 也就是说，它是一个基于宏的编程语言，用于生成印刷文档。值得注意的是，它主要*不*是作为一种编程语言；它最强的一面可以说是它美丽地排版数学公式，以及它解决复杂数学表达式的解决方案。例如，
- en: '[PRE0]'
  id: totrans-split-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: refers to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msqrt><mrow><mfrac><mrow><mi>a</mi>
    <mo>+</mo> <mi>b</mi></mrow> <mrow><mi>|</mi> <mrow><mi>c</mi></mrow> <mi>|</mi></mrow></mfrac></mrow></msqrt></mrow></math>
    . Indeed, if you’ve ever needed to write a mathematical expression into a computer,
    you’re likely to have used either TeX or some form of pidgin TeX.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msqrt><mrow><mfrac><mrow><mi>a</mi>
    <mo>+</mo> <mi>b</mi></mrow> <mrow><mi>|</mi> <mrow><mi>c</mi></mrow> <mi>|</mi></mrow></mfrac></mrow></msqrt></mrow></math>
    。确实，如果您曾经需要在计算机上写入数学表达式，您很可能使用了 TeX 或某种形式的简化 TeX。
- en: But, (La)TeX really is Turing complete – it’s just extremely convoluted. This
    makes (La)TeX a reasonably fun esoteric programming language to play around with.
    On the other hand, being able to wrangle (La)TeX’s macro system lets you automate
    repetitive tasks, or generally extend (La)TeX’s functionality, which end up being
    of practical use. This is why there is also a community effort to improve programming
    ("macro writing") in LaTeX.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，(La)TeX 确实是图灵完备的 - 它只是极为复杂。这使得(La)TeX 成为一个相当有趣的神秘编程语言来玩耍。另一方面，能够驾驭 (La)TeX
    的宏系统让您能够自动化重复的任务，或者通常扩展 (La)TeX 的功能，这最终会变得非常实用。这也是为什么有一个社区努力改进 LaTeX 的编程（“宏编写”）的原因。
- en: LaTeX3 is a “new kernel for LaTeX [… based on] its own consistent interface
    to all the functions needed to control TeX."^([[@expl3.pdf]](https://mirrors.up.pt/pub/CTAN/macros/latex/contrib/l3kernel/expl3.pdf))
    The “new” qualifier is arguable, seeing as it has been in development since 1989,
    but, in short, we now have access to a set of base macros in LaTeX which are more
    sophisticated and behave more predictably. Unfortunately, however, due to Knuth’s
    own [fondness of literate programming](https://en.wikipedia.org/wiki/Literate_programming)
    (the man invented the concept, after all), and because of the nature of LaTeX’s
    output,^([citation needed]) most information about LaTeX3’s functionality is buried
    deep in long PDFs with interspersed prose and code and accessible only via `texdoc
    <designator you must guess>`. A notable (and welcome) exception is [this article
    by Alan Xiang, which I recommend reading](https://www.alanshawn.com/latex3-tutorial/).
    In any case, this post is my attempt to make a small contribution to practical
    and digestible LaTeX3 materials, so that you, too, can procrastinate writing your
    document by writing very convoluted LaTeX macros.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: LaTeX3 是“LaTeX 的新核心，基于其自身一致的接口来控制 TeX 的所有必要函数。”^([[@expl3.pdf]](https://mirrors.up.pt/pub/CTAN/macros/latex/contrib/l3kernel/expl3.pdf))
    “新”一词或许有争议，因为它自 1989 年以来一直在开发中，但简言之，现在我们可以访问一组更复杂且行为更可预测的 LaTeX 基本宏集。不幸的是，由于 Knuth
    本人对文学编程的喜爱（毕竟他发明了这个概念），以及 LaTeX 输出的性质，^([需要引用]) 大多数关于 LaTeX3 功能的信息都埋藏在深入且带有零散散文和代码的长
    PDF 中，只能通过 `texdoc <您必须猜测的标识符>` 访问。一个值得注意的（且受欢迎的）例外是[这篇 Alan Xiang 的文章，我推荐阅读](https://www.alanshawn.com/latex3-tutorial/)。无论如何，本文是我为了提供实用且易于理解的
    LaTeX3 材料而做出的小小贡献，以便您也能通过编写非常复杂的 LaTeX 宏来拖延写文档。
- en: Problem statement and goal
  id: totrans-split-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题陈述和目标
- en: In LaTeX, you may `\label{...}` sections, equations, …, and later refer to their
    identifier with `\ref{...}`. So, for example,
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LaTeX 中，您可以 `\label{...}` 区段、方程式等，然后可以使用 `\ref{...}` 引用它们的标识符。所以，例如，
- en: '[PRE1]'
  id: totrans-split-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: yields
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 产生
- en: '[PRE2]'
  id: totrans-split-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As said, this also works for equations, and is most useful in mathematical
    documents, where you want to reference equations in the body of text. LaTeX2e
    provides the `equation` environment, which automatically typesets a nice `(eqno)`
    next to your equation, and which you can label and reference:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所说，这在方程式中同样适用，并且在数学文档中非常有用，你可以在文本中引用方程式。LaTeX2e提供了`equation`环境，它会在你的方程式旁边自动排版一个漂亮的“(eqno)”，你可以给它标签并进行引用：
- en: '[PRE3]'
  id: totrans-split-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: yields something as
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的结果如下：
- en: '[PRE4]'
  id: totrans-split-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, labels must be unique throughout the document. And so, when writing
    out a long document, it quickly becomes quite upsetting to think up a good label
    for an equation you are certain you will only reference in the next line of text.
    Wouldn’t it be nice to have some `\AutoLabel` and `\AutoRef` macros that would
    let you just
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，标签必须在整个文档中是唯一的。因此，在撰写长篇文档时，为即将在下一行引用的方程式想出一个好的标签很快会让人沮丧。有没有办法让`\AutoLabel`和`\AutoRef`宏在被调用时自动生成并引用标签，那就太好了。
- en: '[PRE5]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First steps
  id: totrans-split-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步
- en: The simplest approach to this problem is to have `\AutoLabel` generate a different
    label every time it’s called in a systematic way, and have `\AutoRef` reference
    that label when it’s called.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的最简单解决方法是让`\AutoLabel`在每次调用时以系统化的方式生成不同的标签，并让`\AutoRef`在调用时引用该标签。
- en: '[PRE6]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s break this down line by line:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析：
- en: 'Anything between `\ExplSyntaxOn` and `\ExplSyntaxOff` obeys LaTeX3’s syntax
    rules, rather than LaTeX2e’s rules. Indeed, (La)TeX allows you to (roughly speaking)
    re-define syntax rules on the fly; in particular, the “function” of each character
    as it is parsed. So, for example, while `\` is usually a special character (indicating
    that what follows is a control sequence), you can change its value halfway through
    the document to function as a regular character. A typical (ab)use of this mechanism
    in LaTeX2e was the modification of the “character type” (the “character code”,
    or “catcode") of `@` between special character and regular letter to guard internal
    commands from the end-user. This procedure was summarized with the `\makeatletter`
    and `\makeatother` commands (to, respectively, set the catcode of `@` to “regular
    letter” and “other character"), and you’ll often find, in LaTeX2e code, code that
    looks like:'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`\ExplSyntaxOn`和`\ExplSyntaxOff`之间的任何内容都遵循LaTeX3的语法规则，而不是LaTeX2e的规则。事实上，(La)TeX允许你在文档中动态重新定义语法规则；特别是，解析时每个字符的“功能”可以粗略地重新定义。例如，虽然`\`通常是一个特殊字符（表示接下来是一个控制序列），但你可以在文档的中途将其值更改为普通字符。在LaTeX2e中，这种机制的典型（滥用）用法是修改`@`的“字符类型”（即“字符码”或“类别码”），使其在特殊字符和普通字母之间转换，以保护内部命令不受最终用户的影响。这个过程可以通过`\makeatletter`和`\makeatother`命令来实现（分别将`@`的类别码设置为“普通字母”和“其他字符”），在LaTeX2e代码中，你经常会看到如下的代码：
- en: '[PRE7]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Calling `\@internalcommand` after `\makeatother` yields an error, because,
    after `\makeatother` is called, LaTeX doesn’t know how to interpret the character
    `@` anymore. This also highlights the fact that the catcode switching happens
    as these declarations are parsed, even though the expressions in the declarations
    themselves are *not* evaluated at the time of declaration. This finds expression
    in the following example, a mistake I’ve incurred in more than once:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`\makeatother`之后调用`\@internalcommand`会产生错误，因为在调用`\makeatother`之后，LaTeX不再知道如何解释字符`@`。这也突显了类别码切换发生在解析这些声明时，即使这些声明本身的表达式在声明时并不被评估。这在以下示例中得到了表现，这是我多次犯过的错误：
- en: '[PRE8]'
  id: totrans-split-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Calling `\boom` later in the document errors out, since at the time of declaration,
    `\@` is parsed as the command in the declaration, not `\@destroytheworld`. At
    macro declaration time, the parser sees `\makeatletter`, but only as a macro that
    is part of the declaration – it doesn’t make sense to “run” the definition at
    declaration time, after all. It thus parses the rest of the declaration based
    on its current rules, which do *not* expect `@` to be a regular character. So,
    as far as the parser cares, `\boom` reads `[macro: \makeatletter] [macro: \@]
    [letters: destroytheworld] [macro: \makeatother]`. When `\boom` is finally called,
    LaTeX complains about the use of `\@`.'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: '在文档的后面调用`\boom`会导致错误，因为在声明时，`\@`被解析为声明中的命令，而不是`\@destroytheworld`。在宏声明时，解析器看到`\makeatletter`，但只将其视为声明的一部分的宏
    - 毕竟，在声明时运行定义是没有意义的。因此，它根据当前的规则解析声明的其余部分，这些规则并不期望`@`是一个普通字符。因此，解析器将`\boom`最终解析为`[macro:
    \makeatletter] [macro: \@] [letters: destroytheworld] [macro: \makeatother]`。当最终调用`\boom`时，LaTeX会抱怨使用了`\@`。'
- en: 'This is a reasonably long tangent to say that `\ExplSyntaxOn` modifies catcodes,
    to favour better and more consistent macro names, and to provide a nicer “programming”
    environment. There are two notable effects: first, within `expl3` rules, spaces
    are ignored. Really, dealing with spaces within macro declarations is a true pain
    point of LaTeX2e; not just spaces you type out, but also spaces implied by new
    lines. Here’s an example; what do you expect the differences to be between `\a`,
    `\b`, `\c`, and `\d`?'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的离题，用来说明`\ExplSyntaxOn`修改类别码，以便更喜欢和更一致的宏名称，并提供更好的“编程”环境。有两个显著的效果：首先，在`expl3`规则内，空格被忽略。实际上，在LaTeX2e中处理宏声明中的空格是一个真正的痛点；不仅仅是你键入的空格，还有新行隐含的空格。这里有一个例子；你期望`\a`、`\b`、`\c`和`\d`之间的差异是什么？
- en: '[PRE9]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I tested these out by calling `.\a..\b..\c..\d.` within a LaTeX document; the
    periods are there to highlight eventual spacing. The results are as follows:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过在LaTeX文档中调用`.\a..\b..\c..\d.`来测试这些；句点用于突出可能的间距。结果如下：
- en: '[PRE10]'
  id: totrans-split-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: (I’ve highlighted spaces for you, with the `␣` character.) Essentially, what
    you would expect happens in the body of text – that a single newline becomes a
    space – is also happening within the macro declaration, inserting spurious spaces
    everywhere. These spaces can only be avoided by inserting comment characters,
    `%`, before the end of the line, which the parser interprets as an explicit instruction
    to ignore the newline. This results in a mess of `%` everywhere in macro declarations,
    since, at some point, macro writers start putting a `%` at the end of every line
    where they don’t *explicitly* want some space. While, in the example given, the
    spaces are not too critical (although unwanted), within complicated macro declarations
    spurious spaces will cause some really nasty bugs and crashes. The situation is
    even worse with double newlines, which get transformed into a paragraph, and that
    will *really* mess up your command’s parsing.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: (我已经为你突出显示了空格，使用了 `␣` 字符。) 本质上，在文本主体中你所期望的 – 单个换行变成空格 – 也发生在宏声明中，导致在任何地方插入多余的空格。这些空格只能通过在行尾插入注释字符
    `%` 来避免，解析器将其解释为显式指令以忽略换行符。这导致宏声明中到处都是 `%` 的混乱，因为在某些时候，宏编写者开始在不想有空格的每行末尾放置 `%`。虽然在给定的示例中，空格不太重要（尽管不需要），但在复杂的宏声明中，多余的空格将导致一些非常恶劣的错误和崩溃。双重换行的情况更糟，它们会转换为段落，这将*真正*混乱你命令的解析。
- en: The other notable catcode switch is making `:` and `_` “regular letters”. So,
    while in LaTeX2e, macro names are generally composed of `a-zA-Z` (and, eventually,
    `@`), in LaTeX3, macros names are expected to be of the form (`texdoc expl3`,
    sec. 3.2.),
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个显著的类别码切换是使`:`和`_`成为“普通字母”。因此，在LaTeX2e中，宏名称通常由`a-zA-Z`（最终是`@`）组成，而在LaTeX3中，宏名称期望是形式为（`texdoc
    expl3`，第3.2节）
- en: '[PRE11]'
  id: totrans-split-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'where `module` would be a unique per-macro package prefix, to avoid name collisions,
    and `description` would be the actual name of the macro. `arg-spec` is a bit more
    special, telling you what *kind* of argument the macro expects, and, notably,
    if the command will expand it or not. Think of it as only slightly more than type
    hints. Macro expansion is a big topic – too big to cover here – but here’s an
    illustrative example:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`module`将是唯一的每个宏包前缀，以避免名称冲突，`description`将是宏的实际名称。`arg-spec`有点特殊，告诉你宏期望的参数
    *类型*，尤其是命令是否会扩展它。可以将其视为仅略高于类型提示。宏扩展是一个大主题 – 在这里无法详细覆盖 – 但这里有一个说明性的例子：
- en: '[PRE12]'
  id: totrans-split-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Read more about expansion [here](https://www.overleaf.com/learn/latex/Articles/How_does_%5Cexpandafter_work%3A_The_meaning_of_expansion).
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于扩展的更多信息，请[在这里](https://www.overleaf.com/learn/latex/Articles/How_does_%5Cexpandafter_work%3A_The_meaning_of_expansion)阅读。
- en: 'In `expl3`, the `arg-spec` bit of a macro will tell you what the macro consumes,
    and if it will expand what it consumes. The main ones to care about (though you
    can find a complete list in `texdoc expl3`, chapter 3, and throughout the main
    reference for programming in LaTeX3, `texdoc interface3`) are:'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`expl3`中，宏的`arg-spec`部分将告诉您宏消耗的内容，以及它是否会展开所消耗的内容。主要关注的几个（虽然您可以在`texdoc expl3`的第3章和LaTeX3主要参考手册中找到完整列表）是：
- en: '`n` – a braced set of characters ("token list"),'
  id: totrans-split-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` – 一组括号中的字符 ("记号列表")，'
- en: '`N` – a single character ("token"); a macro is a single token,'
  id: totrans-split-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`N` – 一个单一字符 ("记号")；宏是一个单一的记号，'
- en: '`c` – a macro *name* (`foobar`, rather than `\foobar`); thus, a token list,'
  id: totrans-split-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c` – 一个宏 *名称* (`foobar`，而不是`\foobar`)；因此，一个记号列表，'
- en: '`V` – a variable, i.e., a macro containing a value (read on),'
  id: totrans-split-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V` – 一个变量，即包含值的宏 (继续阅读),'
- en: '`v` – a variable’s *name*; like `c`, but for `V`,'
  id: totrans-split-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v` – 一个变量的 *名称*；类似于 `c`，但适用于 `V`，'
- en: '`e` – a braced set of characters to be fully expanded before consumption,'
  id: totrans-split-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e` – 在消费前需要完全展开的一组花括号内的字符，'
- en: '`o` – a braced set of characters to be expanded once before consumption,'
  id: totrans-split-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o` – 在消费前需要展开一次的一组花括号内的字符，'
- en: '`T` and `F` – a braced set of characters to be inserted in case some condition
    evaluates to true or false, respectively.'
  id: totrans-split-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T` 和 `F` – 一个条件评估为真或假时插入的一组花括号内的字符。'
- en: 'The notion of a “variable” also appears here, as LaTeX3 tries to separate the
    notion of a macro that *does* something (a function) from a macro that merely
    stores some value (a variable). So, in LaTeX3 terms, `\foo` below would be a variable,
    whereas `\baz` is a function:'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“变量”的概念也出现了，因为 LaTeX3 尝试将一个做事情的宏（函数）与仅仅存储某个值的宏（变量）分开。因此，在 LaTeX3 的术语中，下面的
    `\foo` 将是一个变量，而 `\baz` 则是一个函数：
- en: '[PRE13]'
  id: totrans-split-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Though I should really say,
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我真的应该说，
- en: '[PRE14]'
  id: totrans-split-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even more correct would be
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 更加正确的说法将是
- en: '[PRE15]'
  id: totrans-split-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And, finally, heck it, `texdoc expl3` specifies that variables should be named
    as `\⟨scope⟩_⟨module⟩_⟨description⟩_⟨type⟩`, so here’s some good, honest to God,
    LaTeX3:'
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看吧，`texdoc expl3` 指定了变量应该命名为 `\⟨scope⟩_⟨module⟩_⟨description⟩_⟨type⟩`，所以这里是一些真正的、老实的
    LaTeX3：
- en: '[PRE16]'
  id: totrans-split-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the price to pay for the magical expansion control tools that LaTeX3
    gives.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是得到 LaTeX3 提供的神奇扩展控制工具所需付出的代价。
- en: Finally, we move to the following line,
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们移至以下行，
- en: '[PRE17]'
  id: totrans-split-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we’re declaring a new integer variable. As good LaTeX3 netizens, we use
    the correct variable naming scheme, and declare the variable to be global with
    `g_` (labels will need to be globally unique to the document, so this makes sense).
    We can expect this variable to be initialized to 0; from page 168 of `texdoc interface3`:'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明一个新的整数变量。作为合格的 LaTeX3 使用者，我们使用正确的变量命名方案，并通过 `g_`（文档中的标签需要全局唯一，所以这是合理的）将变量声明为全局变量。我们期望这个变量被初始化为
    0；参见 `texdoc interface3` 第 168 页：
- en: The ⟨integer⟩ is initially equal to 0.
  id: totrans-split-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个 ⟨integer⟩ 最初等于 0。
- en: The idea will be that we can generate infinite unique labels by choosing a unique
    prefix, and suffixing it with an increasing integer; `\g_autolabel_int` will hold
    this integer.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的想法是可以通过选择一个唯一的前缀并将其后缀化为递增整数来生成无限唯一的标签；`\g_autolabel_int` 将保存这个整数。
- en: 'Next line:'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行：
- en: '[PRE18]'
  id: totrans-split-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here we declare a user-facing command, with `\NewDocumentCommand` (LaTeX3’s
    version of `\newcommand`, much nicer to use and about which you can read with
    `texdoc xparse`). Thus, there is no need to adhere to LaTeX3’s naming conventions.
    The declaration furthermore specifies that it takes no arguments from the user,
    and leaves in its place, when called, two instructions: a global increment of
    the `\g_autolabel_int` variable, and `\exp_args:Ne \label {autolabelprefix- \int_use:N
    \g_autolabel_int}`. Here is what `interface3.pdf` has to say about `\exp_args:Ne`:'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个用户可见的命令，使用 `\NewDocumentCommand`（LaTeX3 版本的 `\newcommand`，使用起来更加友好，关于这点你可以阅读
    `texdoc xparse`）。因此，无需遵循 LaTeX3 的命名约定。声明进一步指定它不从用户那里接受任何参数，并在调用时留下两条指令：`\g_autolabel_int`
    变量的全局递增和 `\exp_args:Ne \label {autolabelprefix- \int_use:N \g_autolabel_int}`。关于
    `\exp_args:Ne`，`interface3.pdf` 有以下说明：
- en: 'This function absorbs two arguments (the ⟨function⟩ name and the ⟨tokens⟩)
    and exhaustively expands the ⟨tokens⟩. The result is inserted in braces into the
    input stream after reinsertion of the ⟨function⟩. Thus the ⟨function⟩ may take
    more than one argument: all others are left unchanged.'
  id: totrans-split-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此函数吸收两个参数（⟨function⟩ 名称和 ⟨tokens⟩），并穷尽地展开 ⟨tokens⟩。结果被插入花括号中重新插入 ⟨function⟩
    到输入流中。因此 ⟨function⟩ 可能需要多于一个参数：其他所有参数都保持不变。
- en: Ideally, we would have some labelling function `\label:n` with a variant `\label:e`,
    that would expand whatever would be given to it before taking the result as the
    actual label text. But, we don’t, since `label` is a LaTeX2e command (`texdoc
    latex2e`, chap. 7.1). So, we use `LaTeX3`’s `\exp_args:Ne`, to leave the first
    token (`\label`) alone while the braced tokens that follow are not fully expanded.
    Only then is this token list passed as argument to `\label`.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望有一个标签函数 `\label:n` 和一个变体 `\label:e`，在接受实际标签文本之前会展开其输入内容。但实际上，由于 `label`
    是 LaTeX2e 的命令（见 `texdoc latex2e`，第 7.1 章），所以我们使用 `LaTeX3` 的 `\exp_args:Ne`，保持第一个记号（`\label`）不变，而其后的花括号内的记号不会完全展开。然后将这个记号列表作为
    `\label` 的参数传递。
- en: 'Inside the token list, we find `autolabelprefix- \int_use:N \g_autolabel_int`:
    since `\int_use:N` will “[recover] the content of an ⟨integer⟩ and [place] it
    directly in the input stream”, we get, after full expansion, our unique label,
    of the form'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记列表内部，我们找到了`autolabelprefix- \int_use:N \g_autolabel_int`：因为`\int_use:N`将“恢复一个⟨integer⟩的内容并将其直接放入输入流”，我们在完全展开后得到了我们唯一的标签形式
- en: '[PRE19]'
  id: totrans-split-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we have the declaration of the command that references this label:'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有引用此标签的命令声明：
- en: '[PRE20]'
  id: totrans-split-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It’s fairly similar to `\AutoLabel`, with the exception that the relevant LaTeX2e
    function is now `\ref`, rather than `\label`. Since we know the form of the generated
    labels, we reconstruct the label at referencing time, by once again using the
    `\g_autolabel_int` variable and `\exp_args:Ne`.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它与`\AutoLabel`非常相似，唯一的区别是相关的LaTeX2e函数现在是`\ref`，而不是`\label`。由于我们知道生成的标签形式，我们可以在引用时通过再次使用`\g_autolabel_int`变量和`\exp_args:Ne`来重建标签。
- en: Multiple Labels
  id: totrans-split-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个标签
- en: The above solution works fine, but it quickly breaks down if we wish to reference
    two equations after *both* their declarations. To recover a previous example,
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述解决方案很好用，但如果我们希望在*两个*声明后引用两个方程式时，它很快就会崩溃。
- en: '[PRE21]'
  id: totrans-split-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: will not work, as the output will read
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将不起作用，因为输出将会读取
- en: '[PRE22]'
  id: totrans-split-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can deal with this quite simply, by counting the number of labels and references
    separately:'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过分别计数标签和引用来简单处理这个问题。
- en: '[PRE23]'
  id: totrans-split-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I’ve sneaked in `\c_autoprefix_tl` as a constant token list holding the prefix,
    just because it looks that much nicer than a repeated arbitrary constant string
    throughout the source, and I’ve also done away with the scope for the sake of
    readability. Otherwise everything is still quite similar to the previous definition.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经偷偷地将`\c_autoprefix_tl`作为常量标记列表插入，只因为它在源代码中看起来比重复的任意常量字符串更加美观，为了可读性，我们还取消了作用域。否则，一切仍然与之前的定义非常相似。
- en: 'Things start going awry when using, for example, the `gather` environment from
    the `amsmath` package:'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用例如`amsmath`包中的`gather`环境时，事情开始变得混乱起来：
- en: '[PRE24]'
  id: totrans-split-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: produces
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 产生
- en: '[PRE25]'
  id: totrans-split-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'What’s going on? LaTeX3 does have some console debugging capabilities, with
    commands such as `tl_show:N`, but it’s easier, here, to just go with LaTeX’s version
    of print-debugging: placing values directly in the text. We thus modify the `\AutoLabel`
    definition to not only label the equations, but also place the label’s name in
    the text stream:'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？LaTeX3确实具有一些控制台调试功能，例如`tl_show:N`等命令，但在这里更容易采用LaTeX的版本进行打印调试：直接在文本中放置值。因此，我们修改了`\AutoLabel`的定义，不仅标记方程式，还将标签名称放入文本流：
- en: '[PRE26]'
  id: totrans-split-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once again compiling, we find that the equations now read:'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译，我们发现方程式现在读取为：
- en: '[PRE27]'
  id: totrans-split-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Huh?! Where did labels 1 and 2 go? The problem seems to happen only with `amsmath`
    environments, and so a little bit of trolling its documentation (`texdoc amsmath`)
    reveals the following paragraph:'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀？标签1和2去哪儿了？问题似乎只发生在`amsmath`环境中，稍微查看一下它的文档（`texdoc amsmath`）揭示了以下段落：
- en: '`ifmeasuring@` – All display environments get typeset twice—once during a “measuring”
    phase and then again during a “production” phase; `\ifmeasuring@` will be used
    to determine which case we’re in, so we can take appropriate action.'
  id: totrans-split-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ifmeasuring@` - 所有显示环境都会进行两次排版——一次在“测量”阶段，然后在“生成”阶段；`\ifmeasuring@`将用于确定我们处于哪种情况，以便我们可以采取适当的行动。'
- en: '`\newif\ifmeasuring@`'
  id: totrans-split-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`\newif\ifmeasuring@`'
- en: 'Uh oh. Our `\AutoLabel` function is getting called twice: once in a box that
    `amsmath` uses to perform measurements, and then discards, and then again when
    the actual typesetting happens. To make matters worse, `amsmath` is using a Plain
    TeX Boolean, `\ifmeasuring@`, *and* the Boolean’s name has a `@` in it. Here’s
    what `interface3.pdf` has to say on its Booleans, and Plain TeX’s Booleans:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕了。我们的`\AutoLabel`函数被调用了两次：一次在`amsmath`用于执行测量的盒子中，然后被丢弃，然后在实际排版发生时再次调用。更糟糕的是，`amsmath`正在使用一个Plain
    TeX布尔值`\ifmeasuring@`，*并且*布尔值的名称中包含一个`@`。这里有`interface3.pdf`关于其布尔值和Plain TeX的布尔值的相关信息：
- en: 'TeXhackers note: The `bool` data type is not implemented using the `\iffalse`/`\iftrue`
    primitives, in contrast to `\newif`, etc., in plain TeX, LaTeX2e and so on. Programmers
    should not base use of `bool` switches on any particular expectation of the implementation.'
  id: totrans-split-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TeXhackers注意：与Plain TeX、LaTeX2e等不同，`bool`数据类型未使用`\iffalse`/`\iftrue`原语实现。程序员不应该基于特定的实现期望使用`bool`开关。
- en: Plain TeX Booleans are very fickle, and likely to misbehave if the Boolean test
    looks anything other than
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 纯TeX布尔值非常棘手，如果布尔测试看起来与以下内容不同，可能会出现问题
- en: 'We might get away with giving some arguments to `\a` or `\b`, but no more than
    that; certainly, something like `\ifbool\a\b\c\else\d\e\f\fi` is bound to cause
    you trouble. So, our first step is moving the whole of `\AutoLabel` into a single
    macro of its own:'
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能可以将一些参数给予`\a`或`\b`，但不能超过这些；当然，像`\ifbool\a\b\c\else\d\e\f\fi`这样的东西肯定会给你带来麻烦。因此，我们的第一步是将整个`\AutoLabel`移入其自身的单个宏中：
- en: '[PRE28]'
  id: totrans-split-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we need only to test `\ifmeasuring@` inside `\AutoLabel`, and behave accordingly;
    i.e., if, indeed, measuring, we don’t want to do anything at all. But, recall
    that LaTeX3 and LaTeX2e’s relationship with `@` is different, and LaTeX3 won’t
    correctly interpret `\ifmeasuring@` at all (it’s not expecting macro names to
    have `@`s in them). We may get around this by first using a `c`-type argument,
    and an auxiliary definition:'
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需在`\AutoLabel`中测试`\ifmeasuring@`，并相应地处理；也就是说，如果正在测量，我们根本不想做任何事情。但请注意，LaTeX3和LaTeX2e对`@`的处理方式不同，LaTeX3根本不会正确解释`\ifmeasuring@`（它不期望宏名称中有`@`）。我们可以通过首先使用`c`类型参数和辅助定义来解决这个问题：
- en: '[PRE29]'
  id: totrans-split-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We’re using the `Nc` variant of `\cs_set_eq:NN`, about which `interface3.pdf`
    tells us:'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`\cs_set_eq:NN`的`Nc`变体，关于这一点，`interface3.pdf`告诉我们：
- en: Globally creates ⟨control sequence1⟩ and sets it to have the same meaning as
    ⟨control sequence2⟩ or ⟨token⟩. The second control sequence may subsequently be
    altered with- out affecting the copy.
  id: totrans-split-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 全局创建⟨控制序列1⟩并将其设置为与⟨控制序列2⟩或⟨标记⟩相同的含义。第二个控制序列可以在不影响副本的情况下进行修改。
- en: Is this very kosher? Absolutely not. Is this the least cursed LaTeX macro ever
    written? Not even close, and it works, to boot. Run your compilation steps again,
    and you’ll find the document now correctly reads
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做合适吗？绝对不是。这是有史以来最不诅咒的LaTeX宏吗？一点也不，而且它还有效。重新运行编译步骤，你会发现文档现在正确地读取
- en: '[PRE30]'
  id: totrans-split-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Some final improvements
  id: totrans-split-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些最终的改进
- en: The last thing that’s missing is the ability to repeatedly reference the same
    equation. As it stands, there is no way to typeset something like
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一缺少的是重复引用同一个方程的能力。目前，还没有办法排版类似
- en: '[PRE31]'
  id: totrans-split-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s fix that. Specifically, let’s modify `\AutoRef` to take in an optional
    argument. If the argument is present, and equal to `n`, then that command should
    reference the `n`th equation before it. Thus, our previous example would correspond
    to something like
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来修复这个问题。具体来说，让我们修改`\AutoRef`以接受一个可选的参数。如果参数存在，并且等于`n`，那么该命令应该引用之前的第`n`个方程。因此，我们之前的示例将对应于类似于以下内容
- en: '[PRE32]'
  id: totrans-split-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'I’ll once again give you the final answer, and then break down any new elements:'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我将再次给出最终答案，然后分解任何新元素：
- en: '[PRE33]'
  id: totrans-split-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, note that I’ve also guarded the `\g_autoref_int` counter against double
    incrementation due to measuring – something we’d neglected to previously do, but
    it’s plausible `\AutoRef` is called within an `amsmath` environment. Otherwise,
    the main difference to the previous definitions has to do with the inclusion of
    the optional (`o`) argument in the declaration of `\AutoRef`.When no value is
    given for these arguments, they take a special flag value (usually denoted `-NoValue-`
    in the documentation). `xparse` provides the nice `IfValue(TF)` macros to deal
    with the cases where, respectively, the argument takes some value, or no value.
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意，我还保护了`\g_autoref_int`计数器免受测量中的双重增加影响 – 这是我们先前忽略的，但在`\AutoRef`被调用于`amsmath`环境中时是合理的。否则，与先前定义相比的主要区别在于在声明`\AutoRef`时包含了可选（o）参数。当没有为这些参数提供值时，它们将采用特殊的标志值（通常在文档中用`-NoValue-`表示）。`xparse`提供了很好的`IfValue(TF)`宏来处理这些情况，分别处理参数有值和没有值的情况。
- en: 'So, when we find that the user passed some optional value, we calculate the
    corresponding “absolute label number”; this is given by the current auto-labelling
    number, minus the number the user gave minus one (in other words: if `g_autolabel_int`
    is currently `2`, implying `autoprefix-1` and `-2` were already defined, and the
    user passes in `\AutoRef[2]`, they are referencing `autoprefix-1`, and `1 = 2-(2-1)`).'
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们发现用户传入了一些可选值时，我们计算相应的“绝对标签数”；这由当前的自动标签数减去用户给出的数再减一得出（换句话说：如果`g_autolabel_int`当前为`2`，意味着`autoprefix-1`和`-2`已经定义，用户传入`\AutoRef[2]`，则他们引用的是`autoprefix-1`，即`1
    = 2-(2-1)`）。
- en: 'If, on the other hand, the user did not pass in any value, then they are referencing
    the most recent label; as before, we increment `g_autoref_int`, and set `\l_tmpa_int`
    to hold this number:'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果用户没有传入任何值，则他们引用最近的标签；与以前一样，我们增加`g_autoref_int`，并设置`\l_tmpa_int`以保存这个数字：
- en: '[PRE34]'
  id: totrans-split-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, the final line correctly references the most recent label:'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后一行正确地引用了最近的标签：
- en: '[PRE35]'
  id: totrans-split-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This *almost* works, except for the following edge case: what do you expect
    the following code to produce?'
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*几乎*能正常工作，除了以下边缘情况：您期望以下代码会产生什么结果？
- en: '[PRE36]'
  id: totrans-split-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As it stands, the first call to `\AutoRef[1]` correctly references the label
    of the first equation, but it does *not* advance `\g_autoref_int`, because a value
    is given. Therefore, when `\AutoRef` is called a second time, in the second paragraph,
    it again references the first equation. This is, however, the behaviour we might
    expect in the following situation (which, with apologies, is more synthetic):'
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，对`\AutoRef[1]`的第一次调用正确地引用了第一个方程的标签，但它*不会*推进`\g_autoref_int`，因为给定了一个值。因此，在第二段落中第二次调用`\AutoRef`时，它再次引用第一个方程。然而，这正是我们在以下情况下可能预期到的行为（抱歉，这更多是合成的情况）：
- en: '[PRE37]'
  id: totrans-split-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Indeed, here, we do *not* expect `\AutoRef[1]` to advance `\g_autoref_int`.
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，在这里，我们*不*希望`\AutoRef[1]`推进`\g_autoref_int`。
- en: 'The bottom line is that, to get the intended behaviour, calling `\AutoRef[1]`
    should be indifferent from simply calling `\AutoRef`; but only in the case where
    the two would produce the same result. This is not currently the case. But!, LaTeX3
    has us covered with some pretty comprehensive arithmetic tools. The following
    modification to `\AutoRef` is sufficient:'
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，为了得到预期的行为，调用`\AutoRef[1]`应该与简单调用`\AutoRef`没有区别；但仅在这两种情况会产生相同结果的情况下。目前并非如此。但是！LaTeX3已经为我们提供了一些非常全面的算术工具。对`\AutoRef`的以下修改已经足够：
- en: '[PRE38]'
  id: totrans-split-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The idea is not so different; but now, instead of addressing the optional argument
    directly (`#1`), we start by assigning it to `\l_tmpb_tl`. Then, if we find that
    the user did pass in some value, but that this value is 1, and would result in
    the same as not having provided any value at all, we put the empty value into
    `\l_tmpb_tl`. The rest of the command is therefore processed, in that case, as
    though the user had not supplied a value.
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法并不完全不同；但现在，我们不是直接处理可选参数（`#1`），而是首先将其分配给`\l_tmpb_tl`。然后，如果我们发现用户确实传递了某个值，但该值为1，并且会导致与未提供任何值相同，我们将空值放入`\l_tmpb_tl`。因此，在这种情况下，该命令的其余部分被处理，就好像用户没有提供值一样。
- en: Using `\l_tmpb_tl` instead of `#1` requires some further care with `\exp_args:Ne`
    to make sure the value of `\l_tmpb_tl` is expanded before it’s tested, but nothing
    special.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`\l_tmpb_tl`代替`#1`需要更多注意，特别是要确保在测试之前扩展`\l_tmpb_tl`的值，但没有什么特别的。
- en: 'Thus, we have our final set of LaTeX3 macros:'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了我们最终的LaTeX3宏集：
- en: '[PRE39]'
  id: totrans-split-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While quite a modest contribution to the [very hefty history of LaTeX packages](https://ctan.math.illinois.edu/),
    it nonetheless served as a basis for discussing important points of LaTeX3 macro
    writing, such as syntax differences, token list manipulation, controlled expansion,
    variables and functions, Boolean tests, and LaTeX2e interfacing. Not too shabby.
    Hopefully this post is also a good enough introduction that you may now directly
    reference important reference documents, such as `interface3.pdf`, yourself.
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在[LaTeX包的非常庞大历史](https://ctan.math.illinois.edu/)中算是一个相当谦逊的贡献，但它仍然作为讨论LaTeX3宏编写的重要点的基础，例如语法差异，标记列表操作，受控展开，变量和函数，布尔测试以及LaTeX2e接口的基础。不算太糟糕。希望本帖也能作为一个足够好的介绍，让你可以直接参考重要的参考文档，比如`interface3.pdf`。
- en: Personally, I also find the macro itself quite useful in practice, and it’s
    something I’ve been using in my scientific writing. I am yet to find out if Physical
    Review will be upset by it.
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我在实践中也发现这个宏非常有用，并且我一直在我的科学写作中使用它。我还不知道Physical Review是否会对此感到不悦。
- en: 'As a parting gift, and to point the interested user towards property lists,
    here is an exercise for the reader: the `revtex4-2` document class, mandated by
    Physical Review, does not support the use of `\footnotetext` and `\footnotenumber`.
    This means that any footnote text really must be in the middle of the source of
    the body of text. Can you write `\FootnoteLater` and `\FootnoteNow` to rectify
    this?'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为告别礼，并将感兴趣的用户指向属性列表，这里有一个给读者的练习：Physical Review强制要求的`revtex4-2`文档类不支持`\footnotetext`和`\footnotenumber`的使用。这意味着任何脚注文本实际上必须位于正文源代码的中间。您能写出`\FootnoteLater`和`\FootnoteNow`来纠正这一点吗？
- en: '* * *'
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**A Post-Scriptum for HackerNews readers:** I like to submit these posts to
    HN, as I feel like the average HN user fits the intended audience. But, 1\. famously,
    HN can be quite predictable in some of their responses (by what I expect is, essentially,
    a meme effect), and 2\. I’ve had some unexpected experiences resulting from previously
    reaching FP in HN. So, consider this a preemptive response to some points I expect
    to be raised. If you’re coming in from HN and you see someone fail to account
    for these answers, you’ll know they haven’t even read the whole thing. So:'
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**给HackerNews读者的附言：** 我喜欢把这些文章提交到HN，因为我觉得平均的HN用户就是我的目标读者群体。但是，1.众所周知，HN在某些回复中可能非常可预测（我认为这本质上是一种模因效应），2.之前我在HN上达到FP后也经历过一些意外的经历。所以，请把这视为我预期会被提到的一些点的预防性回应。如果你从HN进来并看到有人未能考虑到这些答案，你会知道他们甚至没有完整地阅读整篇文章。'
- en: It’s weird I even have to say this, but don’t stalk me and email me at my personal
    address. This is genuinely something that has happened, inexplicably. If you wish
    to contact me by email, by all means do so to `miguelmurca+autoref [æt] cumperativa.xyz`.
  id: totrans-split-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很奇怪我竟然需要说这个，但请不要跟踪我并给我发邮件到我的个人邮箱。这确实发生过，莫名其妙的事情。如果你想通过邮件联系我，请发邮件到 `miguelmurca+autoref
    [æt] cumperativa.xyz`。
- en: Again, strange that I would need to point this out, but do not assume my nationality,
    or language. This post is in English. If you wish to write me, please do so in
    English.
  id: totrans-split-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，很奇怪我需要指出这一点，但请不要假设我的国籍或语言。这篇文章是用英文写的。如果你想写信给我，请用英文写。
- en: Yes, we are aware of [typst](https://github.com/typst/typst). I think it’s cool,
    but C++ hasn’t replaced C, Rust hasn’t replaced C++, Typst is unlikely to replace
    LaTeX. Likewise, many are aware of [LuaTeX](https://www.luatex.org/), but, again,
    the entrenching of a 40-odd year system is not to be underestimated. I am rooting
    for `typst`, anyway, and hope it finds its place. A good place to start would
    be to provide a compilation toolchain from `typst` to TeX, if they really want
    to replace TeX.
  id: totrans-split-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，我们知道 [typst](https://github.com/typst/typst)。我觉得它很酷，但是C++没有取代C，Rust也没有取代C++，Typst也不太可能取代LaTeX。同样，很多人知道
    [LuaTeX](https://www.luatex.org/)，但是一个有40多年历史的系统的根深蒂固是不可低估的。不管怎样，我还是支持 `typst`，希望它能找到自己的位置。如果他们真的想取代TeX，一个好的起点就是提供从
    `typst` 到TeX的编译工具链。
- en: There are, in fact, reasons why someone would not want to just use your favourite
    form of Markdown plus pidgin TeX, not least of all because not everyone is just
    taking notes, and also because not everyone (dare I say, most people) who are
    using LaTeX are of the computer science/technology subject. Also, on a purely
    personal level, if you were taking your class notes in Markdown+TeX, either the
    syllabus was too easy or you were making it way harder for yourself.
  id: totrans-split-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，有很多理由为什么有些人不愿意只使用你最喜欢的Markdown加上一点点的TeX，其中至少一个原因是不是每个人都只是在做笔记，还因为不是每个人（我敢说，大多数人）使用LaTeX的人都是计算机科学/技术专业的。另外，从纯个人角度来看，如果你用Markdown+TeX来做课堂笔记，要么课程太简单了，要么你自己给自己增加了很多困难。
- en: Yes, LaTeX is ugly and antiquated. It *is* old. It’s an evolving, niche, very
    precocious thing, and it suffers from this. And, yet, it seems to have its place.
    But, if you just look at it like an esoteric programming language, why should
    this be a problem?
  id: totrans-split-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，LaTeX看起来确实又丑又过时。它确实很老了。它是一个不断发展的、小众的、非常怪异的东西，也因此受到影响。然而，它似乎有它的位置。但是，如果你把它看作一个奇怪的编程语言，为什么这会成为问题呢？
- en: Even though I strived to be correct, it’s likely I’ve incurred in some error.
    There are a lot of people who are *really* good with LaTeX in HN, and I expect
    them to point out any errors (for which I will be very grateful, and will duly
    correct). But, at the end of the day, LaTeX is far from my primary occupation,
    and I felt like the sort of introduction that this text would be able to give
    to the average programmer w.r.t. LaTeX would outweigh any eventual minor error,
    easily corrected by consulting the official references.
  id: totrans-split-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管我努力保持正确，但我可能会犯一些错误。HN上有很多人真的很擅长LaTeX，我期望他们指出任何错误（我会非常感激，并会及时更正）。但归根结底，LaTeX并不是我的主要工作，我觉得这篇文章能够给普通程序员带来对LaTeX的介绍，这比任何可能的小错误更重要，可以轻易通过查阅官方资料进行修正。
- en: Yes, it’s `$YEAR` and we’re still producing PDFs. Again, historical reasons
    plus the fact that most people doing maths are not necessarily very interested
    in computers.
  id: totrans-split-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，现在是`$YEAR`，我们仍然在制作PDF文档。同样的，出于历史原因，加上大多数从事数学工作的人并不一定对计算机非常感兴趣。
- en: 99% of the time that you’re writing LaTeX, you need to know literally nothing
    of what’s contained in this blog post.
  id: totrans-split-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 99% 的时间，当你在写 LaTeX 时，你实际上不需要知道这篇博文中所包含的任何内容。
- en: (La)TeX does not have a grammar. Parsing TeX is Turing complete. This does not
    mean that you could not write a grammar for, roughly speaking, “much” of TeX,
    especially “many” mathematical expressions. I suspect this is what quite a few
    pidgin TeX-related programs do.
  id: totrans-split-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (La)TeX 没有语法。解析 TeX 是图灵完备的。这并不意味着你不能为 TeX 写一个语法，粗略地说，特别是对于“许多”数学表达式。我怀疑这就是许多简易
    TeX 相关程序所做的事情。
- en: '* * *'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
