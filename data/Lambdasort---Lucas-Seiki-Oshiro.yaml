- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 14:29:10'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:29:10'
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Lambdasort - Lucas Seiki Oshiro
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambdasort - Lucas Seiki Oshiro
- en: 来源：[https://lucasoshiro.github.io/software-en/2020-06-06-lambdasort/](https://lucasoshiro.github.io/software-en/2020-06-06-lambdasort/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://lucasoshiro.github.io/software-en/2020-06-06-lambdasort/](https://lucasoshiro.github.io/software-en/2020-06-06-lambdasort/)
- en: Quicksort written in Python only using lambdas!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 lambda 编写的快速排序！
- en: 'GitHub: [https://github.com/lucasoshiro/lambdasort](https://github.com/lucasoshiro/lambdasort)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitHub: [https://github.com/lucasoshiro/lambdasort](https://github.com/lucasoshiro/lambdasort)'
- en: Lambda calculus
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: λ演算
- en: 'Python, just like many other programming languages, supports **high-order functions**
    and **anonymous functions**. This means, basically, that we can do this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python，就像许多其他编程语言一样，支持**高阶函数**和**匿名函数**。这基本上意味着我们可以这样做：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Right. This way, **functions are values** that can be created and returned by
    other functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 没错。这样一来，**函数就是值**，可以由其他函数创建并返回。
- en: 'What if we write a code that the type of every value is a function? For example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写一个每个值的类型都是函数的代码会怎样？例如：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At first look it seems to be useless. However, believe it or not (spoiler:
    this will be explained further), that is a boolean `and` of `True` and `False`!'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看似乎毫无用处。然而，信不信由你（剧透：稍后会解释），这是 `True` 和 `False` 的布尔 `and` 运算！
- en: This is the famous **lambda calculus**. It only has functions that get functions
    as parameters and return other functions. For us, that is enough, but if you want
    to read more about it, I really suggest you [this article on Wikipedia](https://en.wikipedia.org/wiki/Lambda_calculus).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是著名的**λ演算**。它只有接收函数作为参数并返回其他函数的函数。对我们来说，这已经足够了，但如果你想要了解更多，我真的建议你阅读[维基百科上的这篇文章](https://en.wikipedia.org/wiki/Lambda_calculus)。
- en: Even though it seems to be insufficient to do anything, actually lambda calculus
    can solve any problem that can be solved with an algorithm, as it is **Turing-complete**!
    [Alan Turing](https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/computability-and-definability/FE8B4FC84276D7BACB8433BD578C6BFD#access-block)
    itself has proven it!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它看起来似乎不足以做任何事情，但实际上 λ演算可以解决任何可以用算法解决的问题，因为它是**图灵完备**的！[艾伦·图灵](https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/computability-and-definability/FE8B4FC84276D7BACB8433BD578C6BFD#access-block)本人已经证明了这一点！
- en: 'The excellent [Programming with Nothing](https://tomstu.art/programming-with-nothing)
    by Tom Stuart shows how to write a fizzbuzz using lambda calculus in Ruby. When
    I read it the first time I wanted to do something similar to it, so I made this:
    **A QUICKSORT IN LAMBDA CALCULUS**.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 出色的[Tom Stuart 的“无限编程”](https://tomstu.art/programming-with-nothing)展示了如何使用
    Ruby 中的 lambda 演算编写 fizzbuzz。第一次阅读时，我想要做类似的事情，所以我做了这个：**λ演算中的快速排序**。
- en: I will tell you all the steps of how I did that!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我会告诉你我是如何做到的每一步的！
- en: 'The beginning: a normal quicksort in Python'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始：一个普通的 Python 快速排序
- en: 'The first step was to write a quicksort in Python, but with a difference compared
    to the traditional quicksort: it **doesn’t change** the original list, instead,
    it **returns** a new list, just like the `sorted` in Python:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是用 Python 写一个快速排序，但与传统的快速排序相比有一个区别：它**不会改变**原始列表，而是**返回**一个新列表，就像 Python
    中的 `sorted` 一样：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Take a look in the use of the functions `car`, `cdr` and `cons`. I followed
    the Lisp nomenclature for those functions. They will be further implemented the
    same way as some Lisp dialects, so I tried to be closer to them in how lists work
    instead of the usual in Python:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看函数 `car`、`cdr` 和 `cons` 的用法。我遵循了 Lisp 对这些函数的命名约定。它们将进一步按照一些 Lisp 方言的方式实现，因此我尝试使它们在列表工作方面更接近它们而不是
    Python 中的通常用法：
- en: The `car` function returns the **first** element
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`car` 函数返回第一个元素'
- en: The `cdr` function returns a list with the **rest** of the elements. In other
    words, all the elements except the first
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cdr` 函数返回一个带有其余元素的列表。换句话说，除了第一个元素外的所有元素'
- en: By now, I also implemented `cons` as a function that returns a new list that
    looks the same as the provided but **appending** a new element to its beginning,
    but `cons` is more than that (I’ll discuss it later)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我还将 `cons` 实现为一个函数，它返回一个看起来与提供的列表相同但在其开头**附加**一个新元素的新列表，但 `cons` 不仅仅是如此（我稍后会讨论它）
- en: The `concat` function **concatenates** two lists.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat` 函数**连接**两个列表。'
- en: 'The rest is only a standard quicksort:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分只是标准的快速排序：
- en: The `partition` function **splits** a list in two, the left one being a list
    that all of its elements are lesser than the first element of the right one (the
    pivot), and the right one being a list that all elements are greater or equal
    to the pivot.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition` 函数**将列表分割**成两部分，左边的列表中的所有元素都小于右边的第一个元素（中轴），右边的列表中的所有元素都大于或等于中轴。'
- en: The `quicksort` function calls `partition` to split the list that we want to
    sort into two and **sorts** each one using `quicksort` itself, recursively, being
    the base of the recursions lists with length lesser or equal to 1.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quicksort` 函数调用 `partition` 将我们要排序的列表分成两部分，并分别使用 `quicksort` 对其进行排序，递归地，递归的基础是长度小于或等于
    1 的列表。'
- en: As for the weird constructions `L, R = ...`, by now it is useless to do those
    parallel attributions, but this will be helpful in the future.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 至于奇怪的构造 `L, R = ...`，现在做这些并行赋值是没有用的，但在未来会很有帮助。
- en: You can see it [here](https://github.com/lucasoshiro/lambdasort/blob/simple-quicksort/lambdasort.py).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[这里](https://github.com/lucasoshiro/lambdasort/blob/simple-quicksort/lambdasort.py)看到它。
- en: Redefining types
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新定义类型
- en: 'As the idea is to rewrite quicksort using only lambdas, we need to somehow
    **represent data** using only functions. The types here are:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的想法是只使用 lambda 重写快速排序，我们需要以只使用函数的方式来**表示数据**。这里的类型有：
- en: integers (the values in the list that we want to sort)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数（我们要排序的列表中的值）
- en: lists
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: pairs (used by the functions that return more than one value)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对（由返回多个值的函数使用）
- en: booleans (used by the verifications)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值（由验证使用）
- en: Luckily, the creator of lambda calculus, **Alonzo Church** has also shown us
    how to do that. There’s an [article about it](https://en.wikipedia.org/wiki/Church_encoding)
    on Wikipedia.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，lambda演算的创始人**阿隆佐·丘奇**也向我们展示了如何做到这一点。维基百科上有一篇[关于此的文章](https://en.wikipedia.org/wiki/Church_encoding)。
- en: Booleans
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'Let’s start by the easier ones, **booleans**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更容易的开始，**布尔值**：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Yeah, `true` is only a function that takes **two arguments** and returns **the
    first one**, and `false` is a function that takes two arguments and returns **the
    second one**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，`true` 只是一个接受**两个参数**并返回**第一个参数**的函数，而 `false` 是一个接受两个参数并返回**第二个参数**的函数。
- en: 'I know that you’re thinking: “it should be `lambda a, b: a` and `lambda a,
    b: b`, why there are two `lambdas`?”. This is because in the definition of lambda
    calculus, functions can only take **one argument**. Contrary to that definition,
    in Python `lambda` can take zero or more arguments, but here I’m restricting myself
    to only use functions that take only one argument in order to stick to the definition.
    This way, what would be written as `lambda a1, a2, a3, ..., an:` will be written
    as `lambda a1: lambda a2: lambda a3: ... lambda an:`. When calling the function,
    we use `(a1)(a2)(a3)...(an)` instead of `(a1, a2, a3, ..., an)`. The name of that
    conversion is **[currying](https://en.wikipedia.org/wiki/Currying)**, named after
    Haskell Curry. An example of language that natively uses currying to handle function
    is Haskell (you don’t say!).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '我知道你在想：“应该是`lambda a, b: a`和`lambda a, b: b`，为什么有两个`lambda`？”。这是因为在 lambda
    演算的定义中，函数只能接受**一个参数**。与该定义相反，在 Python 中 `lambda` 可以接受零个或多个参数，但在这里我限制自己只使用接受一个参数的函数，以符合该定义。这样，原本会写成
    `lambda a1, a2, a3, ..., an:` 的函数将被写成 `lambda a1: lambda a2: lambda a3: ... lambda
    an:`。在调用函数时，我们使用 `(a1)(a2)(a3)...(an)` 而不是 `(a1, a2, a3, ..., an)`。这种转换的名称是 **[柯里化](https://en.wikipedia.org/wiki/Currying)**，以
    Haskell Curry 命名。一个本地使用柯里化处理函数的例子是 Haskell（你别说！）。'
- en: 'After that, I implemented the tree basic **boolean operations**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我实现了三个基本的**布尔运算**：
- en: '`not`: takes a Church boolean, and calls it using as parameters `false` and
    `true`. If the boolean is `true`, it returns the **first argument** (`false`);
    if it is `false`, then it returns the **second argument** (`true`).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`：接受一个 Church 布尔值，并使用 `false` 和 `true` 作为参数调用它。如果布尔值是`true`，则返回**第一个参数**（`false`）；如果是`false`，则返回**第二个参数**（`true`）。'
- en: '`or`: takes two Church booleans, calls the first one passing as arguments `true`
    and the second boolean. If the first argument of `or` is `true`, then it returns
    its **first argument** (`true`); if it is `false`, then it returns its **second
    argument** (the second argument of `or`).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`：接受两个 Church 布尔值，调用第一个并将`true`和第二个布尔值作为参数传递给它。如果`or`的第一个参数是`true`，则返回其**第一个参数**（`true`）；如果是`false`，则返回其**第二个参数**（`or`的第二个参数）。'
- en: '`and`: much like `or`. Try to simulate it mentally ;-)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`：很像 `or`。试着在脑中模拟它 ;-)'
- en: 'We can also define an `if`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义一个`if`：
- en: if
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In `if`, `c`is the **condition**; `t` is the “then” block, what happens when
    the **condition is true**, and `e` is the “else” block, what happens when the
    condition is **false**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 中，`c` 是 **条件**；`t` 是“then”块，当 **条件为真** 时发生的情况，`e` 是“else”块，当条件为 **假**
    时发生的情况。
- en: 'This way, `if` is closer to an **if-expression** in Python (or ternary operator)
    than a control flow `if`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`if` 更接近于 Python 中的 **if 表达式**（或三元运算符）而不是控制流 `if`：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Conversion
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转换
- en: 'I also defined two functions to convert Church booleans to Python booleans
    (`l2b`) and vice-versa (`b2l`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我还定义了两个函数将 Church 布尔值转换为 Python 布尔值（`l2b`）和反之亦然（`b2l`）：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Mental exercise: simulate them!'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 思维练习：模拟它们！
- en: You can see it [here](https://github.com/lucasoshiro/lambdasort/blob/booleans/lambdasort.py)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [这里](https://github.com/lucasoshiro/lambdasort/blob/booleans/lambdasort.py)
    看到它
- en: Integers
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数
- en: '**Church numerals** are defined as:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**Church 数** 被定义为：'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is, all the integers are functions that take **two arguments** `p` and
    `x` this way:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，所有的整数都是以这种方式接受 **两个参数** `p` 和 `x` 的函数：
- en: 0 is a function that returns `x` (just like `false`)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 是一个返回 `x` 的函数（就像 `false` 一样）
- en: 1 is a function that returns `p(x)`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 是一个返回 `p(x)` 的函数
- en: 2 is a function that returns `p(p(x))`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 是一个返回 `p(p(x))` 的函数
- en: and so on. However, we can represent negative numbers using this encoding.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推。但是，我们可以使用这种编码表示负数。
- en: Increment and decrement
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 增量和减量
- en: '**Increment** is easy to define, it is a function that adds another layer of
    `p(...)`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**增量** 定义起来很容易，它是一个添加另一层 `p(...)` 的函数：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But **decrement** is far harder. Explaining it takes some time, and understanding
    it is not useful for us right now. If you really want to know how it works, try
    it by yourself. If you don’t care, just trust ~~me~~ Church that it works:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 **减少** 要困难得多。解释它需要一些时间，而且现在理解它对我们来说没有用。如果你真的想知道它是如何工作的，请自己试一试。如果你不在乎，就相信
    ~~我~~ Church 它是有效的：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you tried to simulate it by yourself, you probably tried to figure out what
    happens if you decrement zero. And you found that the **decrement of zero is zero**
    here. Sadly this is a limitation, and we’ll need to remember it soon in the future.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己尝试模拟它，你可能试图弄清楚如果你减少零会发生什么。你发现了这里 **零的减量是零**。不幸的是，这是一个限制，我们很快将在未来需要记住它。
- en: Add and subtraction
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加法和减法
- en: Ok, we have increment and decrement. If we increment `n` times a number `m`,
    then we’ll have `m + n`, and if we decrement `n` times we’ll have `m - n`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们有增加和减少了。如果我们增加 `n` 次数字 `m`，那么我们将得到 `m + n`，如果我们减少 `n` 次，我们将得到 `m - n`。
- en: 'We can define add and subtraction this way:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样定义加法和减法：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that increment and decrement will passed as the `p` argument of the number
    `n` and `m` will be the `x` argument. In other words, `m` will be incremented
    or decremented **the same amount** of times than the number of calls that `p`
    has in `n`, this is, `n` times. Very, very beautiful.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意增量和减量将作为数字 `n` 的 `p` 参数传递，`m` 将是 `x` 参数。换句话说，`m` 将增加或减少与 `n` 中 `p` 调用次数相同的次数，这是，`n`
    次。非常、非常美丽。
- en: Even so, a consequence of the decrement of zero being zero here is that `n -
    m` will always be zero if `m > n`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，零的减量是零的结果是，如果 `m > n`，则 `n - m` 将始终为零。
- en: Multiplication and division are also possible, but they won’t be useful for
    this quicksort.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法和除法也是可能的，但它们对这个快速排序来说不是很有用。
- en: Comparisons
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 比较
- en: 'The integer operations that will actually be useful for implementing quicksort
    are the **comparisons**. Let’s start by defining the function that tells if a
    Church number is or not zero (mental exercise: why does this work?):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上对于实现快速排序有用的整数运算是**比较**。让我们从定义告诉一个 Church 数是否为零的函数开始（思维练习：这为什么有效？）：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using only the operation of **equals zero**, combined with **boolean** and
    **arithmetic** operations we can define the others:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用 **等于零** 操作，结合 **布尔** 和 **算术** 运算，我们可以定义其他运算：
- en: '`m <= n`: `(m - n) == 0` (remember: `m - n = 0` if `n > m`)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m <= n`: `(m - n) == 0` （记住：如果 `n > m`，则 `m - n = 0`）'
- en: '`m == n`: `(m <= n) and (n <= m)`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m == n`: `(m <= n) and (n <= m)`'
- en: '`n < m`: `(m <= n) and not (m == n)`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n < m`: `(m <= n) and not (m == n)`'
- en: 'Or, in Python / lambda calculus:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 Python / lambda 演算中：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Conversion
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转换
- en: 'If we want to **convert** a Church number to a Python integer we’ll only need
    to pass the increment function as the first argument (`p`) and 0 as the second:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将一个 Church 数转换为 Python 整数，我们只需要将增量函数作为第一个参数（`p`）传递，0 作为第二个参数：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can do the inverse: we can **increment** several times the Church zero until
    we reach the number:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以反过来做：我们可以多次 **增加** Church 零直到达到该数字：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also define functions to convert Python integer lists into Church number
    lists and vice-versa:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义函数将 Python 整数列表转换为 Church 数字列表，反之亦然：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using Church numbers
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Church 数字
- en: 'As we can convert Python integer lists into Church number lists and vice-versa
    and we can compare Church numbers, we can apply the first change to Quicksort:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们可以将 Python 整数列表转换为 Church 数字列表，反之亦然，而且我们可以比较 Church 数字，所以我们可以对快速排序应用第一个改变：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `partition` function now operates over **Church number lists**. In order
    to do that, we replaced `x < p` by `LAMBDA_LESS(x)(p)`, that returns a Church
    boolean instead of `True` and `False`. I needed to use `l2b` to convert the Church
    boolean to a Python boolean so we can keep the compatibility with `if`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition`函数现在在**Church 数字列表**上运行。为了做到这一点，我们将`x < p`替换为`LAMBDA_LESS(x)(p)`，它返回一个
    Church 布尔值，而不是`True`和`False`。我需要使用`l2b`将 Church 布尔值转换为 Python 布尔值，以便我们可以保持与`if`的兼容性。'
- en: The function `partition_wrapper` **adapts** the new `partition` in a way that
    it takes Python integers, but partitioning using the new `partition` function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`partition_wrapper`**调整**了新的`partition`，使其以采用 Python 整数的方式进行分区，但使用新的`partition`函数进行分区。
- en: In the following sections I will make several substitutions of types, functions
    and operators by functions in lambda calculus, just like I did so far. I’ll try
    to change only what is relevant for each step, using the conversion functions
    if necessary.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将通过 lambda 演算中的函数对类型、函数和操作符进行多次替换，就像我迄今为止所做的那样。我将尝试只改变每个步骤中相关的内容，必要时使用转换函数。
- en: You can see it [here](https://github.com/lucasoshiro/lambdasort/blob/integers/lambdasort.py).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[这里](https://github.com/lucasoshiro/lambdasort/blob/integers/lambdasort.py)看到它。
- en: Pairs and lists
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对和列表
- en: 'Our basic data structure is the **pair**. The pair is really a pair of values,
    just like a Python tuple of size 2\. In Church encoding, a pair and its basic
    operations are defined like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本数据结构是**对**。这对真的是一对值，就像 Python 的大小为 2 的元组一样。在 Church 编码中，一对及其基本操作定义如下：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first function, `LAMBDA_CONS`, defines the pair. Note that, when passing
    two values as its arguments (e. g. `LAMBDA_CONS(15)(20)`), it will return a function
    that takes an argument `l` and **returns** the `l` call using the pair elements
    as **arguments** (in our example, `l(15)(20)`). That is: `LAMBDA_CONS(15)(20)
    = lambda l: l(15)(20)`. In Python and other languages that supports first-class
    functions, those two values are stored in a **[closure](https://en.wikipedia.org/wiki/Closure_(computer_programming))**,
    and we can even get them this way:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个函数，`LAMBDA_CONS`，定义了这对。请注意，当将两个值作为其参数传递（例如`LAMBDA_CONS(15)(20)`）时，它将返回一个函数，该函数接受一个参数`l`并**返回**使用对元素作为**参数**的`l`调用（在我们的示例中，`l(15)(20)`）。也就是说：`LAMBDA_CONS(15)(20)
    = lambda l: l(15)(20)`。在 Python 和其他支持一等函数的语言中，这两个值存储在一个**[闭包](https://en.wikipedia.org/wiki/Closure_(computer_programming))**中，我们甚至可以这样得到它们：'
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: About `LAMBDA_CAR` and `LAMBDA_CDR`, they return the **first** and the **second**
    element of the pair, respectively.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`LAMBDA_CAR`和`LAMBDA_CDR`，它们分别返回对的**第一个**和**第二个**元素。
- en: 'Mental exercise: try to understand why `LAMBDA_CAR` and `LAMBDA_CDR` work!'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 思维练习：试着理解为什么`LAMBDA_CAR`和`LAMBDA_CDR`有效！
- en: Lists
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表
- en: If you paid enough attention, you noted that `car`, `cdr` and `cons` are the
    same names that we used to define the functions that operate over **lists**. And
    yes, they are the same! This happens because the way lists are implemented in
    Church encoding.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够注意，你会注意到`car`、`cdr`和`cons`是我们用来定义在**列表**上操作的函数的相同名称。是的，它们是一样的！这是因为列表在 Church
    编码中的实现方式。
- en: '**Church lists** just are pairs where:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**Church 列表**只是一对，其中：'
- en: the first element is the **first element** of the list
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个元素是列表的**第一个元素**
- en: the second element is a **list with the rest** of the elements
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个元素是一个**剩余元素的列表**
- en: 'That is a recursive definition where the base of the recursion (an **empty
    list**) can be implemented by many ways. Here we are using to represent an empty
    list the boolean `LAMBDA_FALSE`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个递归定义，其中递归的基础（一个**空列表**）可以通过多种方式实现。在这里，我们使用布尔值`LAMBDA_FALSE`来表示一个空列表：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This way, a list with the values `[1, 2, 3]` can be declared this way:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，具有值`[1, 2, 3]`的列表可以这样声明：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In practice, they are recursive pairs:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，它们是递归对：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So many parentheses! But note that, at this point, `LAMBDA_CAR`, `LAMBDA_CDR`
    and `LAMBDA_CONS`, when applied to **lists** have the same behaviour than `car`,
    `cdr` and `cons` that we defined to operate over Python lists:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如此多的括号！但请注意，此时，`LAMBDA_CAR`、`LAMBDA_CDR`和`LAMBDA_CONS`，当应用于**列表**时，具有与我们定义的用于操作Python列表的`car`、`cdr`和`cons`相同的行为：
- en: '`LAMBDA_CAR` returns the first element of the first pair, this is, **the first
    element** of the list (`1`)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LAMBDA_CAR`返回第一个对的第一个元素，即列表的**第一个元素**（`1`）'
- en: '`LAMBDA_CDR` returns the first element of the second pair, this is, **the rest**
    of the list (`(2, (3, LAMBDA_EMPTY))`)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LAMBDA_CDR`返回第二对的第一个元素，即列表的**剩余部分**（`(2, (3, LAMBDA_EMPTY))`）'
- en: '`LAMBDA_CONS` adds another pair, appending **another element**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LAMBDA_CONS`添加另一对，附加**另一个元素**'
- en: 'As the definition of those lists is recursive, the iteration over them will
    also be done in a recursive way. The function that we’ll use to know whether the
    recursion has reached the end is this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些列表的定义是递归的，对它们的迭代也将以递归方式完成。我们将用于知道递归是否达到了结尾的函数是：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That is:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是：
- en: 'if `l` is **empty** (it is equal to `LAMBDA_EMPTY`), then it returns the second
    argument: `LAMBDA_TRUE`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`l`为空（等于`LAMBDA_EMPTY`），那么它返回第二个参数：`LAMBDA_TRUE`
- en: 'if `l` is **not empty**, then `l` is a pair. `l` is called with the function
    `(lambda h: lambda t: lambda d: LAMBDA_FALSE)` as argument. That function discards
    everything and return `LAMBDA_FALSE`. Try to simulate it ;-).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`l`**不为空**，那么`l`是一对。 `l`以函数`(lambda h: lambda t: lambda d: LAMBDA_FALSE)`为参数调用。该函数丢弃所有内容并返回`LAMBDA_FALSE`。尝试模拟一下
    ;-).'
- en: Conversion
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转换
- en: '**Pairs** can be converted from and to Python lists that have only two elements.
    The pythonic way to do that would be using tuples of size 2, but, in order to
    keep the code homogeneity, I’m using lists:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**对**可以从仅具有两个元素的 Python 列表转换为和从中转换。这样做的 pythonic 方法是使用大小为 2 的元组，但为了保持代码的一致性，我正在使用列表：'
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also convert Python lists and Church lists:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以转换 Python 列表和 Church 列表：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using Church pairs in `partition`
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在`partition`中使用 Church 对
- en: 'As `partition` returns two values (a Python tuple), we can use here a Church
    pair:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`partition`返回两个值（一个 Python 元组），因此我们可以在这里使用 Church 对：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using Church lists in `partition`
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在`partition`中使用 Church 列表
- en: 'Let’s use Church lists in quicksort! First of all, we’re going to convert `partition`
    to operate over Church lists. Currently, our situation is this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在快速排序中使用 Church 列表！首先，我们将转换`partition`以在 Church 列表上操作。目前，我们的情况是这样的：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, we need to replace `car`, `cdr`, `cons` and `[]` by their corresponding
    in lambda calculus:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要将`car`、`cdr`、`cons`和`[]`替换为它们在 lambda 演算中的对应物：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that I created the generator `lliterator` to iterate over Church lists:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我创建了生成器`lliterator`来迭代 Church 列表：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using Church lists in `quicksort`
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在`quicksort`中使用 Church 列表
- en: 'Now we’re going to add **Church lists** to the function `quicksort`! We still
    need to define the function `concat` for Church lists. We can implement it recursively:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把**Church 列表**添加到函数`quicksort`中！我们仍然需要为 Church 列表定义函数`concat`。我们可以递归地实现它：
- en: If the list on the left **is empty**, we need to use the **list on the right**
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果左侧的列表**为空**，我们需要使用右侧的列表
- en: 'If the list on the left **is not empty**, it returns a new list where:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果左侧的列表**不为空**，它将返回一个新的列表，其中：
- en: the first element is the **first element** (`car`) of the **list on the left**
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个元素是左侧列表的**第一个元素**（`car`）
- en: the rest of the list is the concatenation of the **rest** (`cdr`) of the **list
    on the left** with the **list on the right**
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余列表是左侧列表的**剩余部分**（`cdr`）与右侧列表的**列表**的连接
- en: 'That is (note the currying):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是（注意柯里化）：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is a little different to the other operations that were written in a single
    expression. Spoiler: we’re going to handle this further!'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他在单个表达式中编写的操作有些不同。剧透：我们将进一步处理这个！
- en: 'Once having `concat` defined, we can replace all the Python list operations
    by Church list operations in `quicksort`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了`concat`，我们就可以在`quicksort`中用 Church 列表操作替换所有 Python 列表操作：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can see it [here](https://github.com/lucasoshiro/lambdasort/blob/pairs-lists/lambdasort.py).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[这里](https://github.com/lucasoshiro/lambdasort/blob/pairs-lists/lambdasort.py)看到它。
- en: Replacing loops by recursive functions
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用递归函数替换循环
- en: As in lambda calculus **there aren’t any states**, we can’t use loops as we
    do in imperative languages, that is, repeating a code snippet and changing the
    state of a variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 lambda 演算中**没有任何状态**，我们不能像在命令式语言中那样使用循环，即重复代码片段并更改变量的状态。
- en: And due to the lack of states, instead of changing an existing value we return
    a **new** value, just like we did when replacing the standard behaviour of quicksort
    to return a sorted list instead of sort the original list.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏状态，我们不是更改现有值，而是返回一个**新**值，就像我们替换快速排序的标准行为以返回已排序列表而不是对原始列表进行排序时一样。
- en: Even when we are write code in languages that support both the functional and
    imperative paradigms, like Python, if we restrict ourselves to write a code in
    a functional manner we can’t use loops.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在支持函数式和命令式范式的语言中编写代码，例如Python，如果我们限制自己以函数式方式编写代码，我们不能使用循环。
- en: And how can we solve the problems that would be solved using loops? There are
    many solutions depending on the case, for example, we could use `reduce`, list
    comprehensions, `map`, `filter`, recursive functions, etc. In this quicksort we
    only have **one loop**, in `partition`. We’re going to replace it by a **recursive
    function**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决使用循环解决的问题？根据情况有许多解决方案，例如，我们可以使用`reduce`、列表推导、`map`、`filter`、递归函数等等。在这个快速排序中，我们只有**一个循环**，在`partition`中。我们将其替换为一个**递归函数**。
- en: Replacing `for` by `while`
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用`while`替换`for`
- en: 'Currently, the loop is this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，循环是这样的：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After removing the iterator `lliterator` and replacing the `for` by a `while`,
    we get this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 删除迭代器`lliterator`并将`for`替换为`while`后，我们得到了这样的结果：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In other words: at first `S` is equal to the input list without the first element
    (the pivot `p`). Each iteration of `while` **removes** a value from `S` and stores
    it in `x`. If `x < p`, we append `x` to the beginning of `L`, otherwise we append
    to the end of `R`. The **stop condition** is when the list `S` is empty.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：初始时`S`等于输入列表去除第一个元素（枢轴`p`）后的内容。`while`的每次迭代**移除**`S`中的一个值，并将其存储在`x`中。如果`x
    < p`，我们将`x`添加到`L`的开头，否则我们将其添加到`R`的末尾。停止条件是当列表`S`为空时。
- en: 'For now on we can identify the elements that will be useful for writing this
    loop as a recursive function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们可以确定哪些元素将有助于编写这个循环作为一个递归函数：
- en: the inputs **`L` and `R`** that are, at first, empty Church lists;
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入**`L`和`R`**，初始为空的Church列表；
- en: the input **`S`** that is, at first, equal to `LAMBDA_CDR(A)`;
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入**`S`**，初始为`LAMBDA_CDR(A)`；
- en: the **outputs**, that are the values of `L` and `R` at the end of the loop;
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出，即循环结束时的`L`和`R`的值；
- en: the **stop condition**, that are when `S` is empty.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止条件，即`S`为空时。
- en: Converting `while` to recursion
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将`while`转换为递归
- en: 'Cool, what we have so far is enough to write a **recursive function** (that
    I’m calling here `_partition`), given the `while` loop code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，到目前为止，我们已经足以编写一个**递归函数**（我在这里称之为`_partition`），给定`while`循环代码：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that `_partition` doesn’t change the state of the inputs `L` and `R`. Instead
    of *changing* the original input data, it returns *new* data that are stored in
    the variables `nL` and `nR`, that are the `L` and `R` arguments of the next recursive
    call.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`_partition`不会改变输入`L`和`R`的状态。与其*改变*原始输入数据，它返回*新*数据，这些数据存储在变量`nL`和`nR`中，它们是下一次递归调用的`L`和`R`参数。
- en: 'We can also make that function return Church pairs instead of tuples:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使该函数返回Church对而不是元组：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can see it [here]((https://github.com/lucasoshiro/lambdasort/blob/recursion/lambdasort.py).).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[这里](https://github.com/lucasoshiro/lambdasort/blob/recursion/lambdasort.py)看到它。
- en: Replacing variables by `let`s
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用`let`替换变量
- en: A [let expression](https://en.wikipedia.org/wiki/Let_expression) allows us to
    define a value to a variable inside a **scope** so that its value will **never
    be changed**. In Python, this concept makes little sense, but it is implemented
    in many ways by different languages. I’ll show you some of them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[let表达式](https://zh.wikipedia.org/wiki/Let%E8%A1%A8%E8%BE%BE%E5%BC%8F)允许我们在一个**作用域**内将一个值定义给一个变量，以便其值**永远不会被改变**。在Python中，这个概念意义不大，但是不同的语言以许多方式实现了它。我会给你展示一些例子。'
- en: 'Starting by **Kotlin**, `let` is a method that can be called by any object
    so we can assign a temporary name to it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Kotlin**开始，`let`是可以由任何对象调用的方法，因此我们可以为其分配一个临时名称：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In **Haskell**, `let` is an expression where the first half is the value attribution
    and the second half is the expression that we want to evaluate:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Haskell**中，`let`是一个表达式，其中前半部分是值的赋值，后半部分是我们要评估的表达式：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In **[Hy](http://hylang.org)** (Python with Lisp syntax), it is very close
    to Haskell: first we attribute the values to the variables, then we declare the
    expression that will use them:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在**[Hy](http://hylang.org)**（具有Lisp语法的Python）中，它与Haskell非常接近：首先我们将值赋给变量，然后声明将使用它们的表达式：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: (`x` will be 8 in the three examples above)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: （上述三个示例中的`x`都将是8）
- en: 'That construction is a very common in functional languages, as their variables
    have a **fixed value** inside a scope. In addition, they are easy to be written
    using **lambda calculus**. We can write the example above like that:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造在函数式语言中非常常见，因为它们的变量在作用域内有一个**固定的值**。此外，它们很容易使用**lambda演算**编写。我们可以像这样重写上面的示例：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that, like before, we are attributing `a = 2` and `b = 3` and then calculating
    `a + b * a`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与以前一样，我们将 `a = 2` 和 `b = 3` 赋给变量，然后计算 `a + b * a`。
- en: Our mission in this step is to put **all the variables** that are not argument
    or constants in lets, so they could be used in lambda calculus.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一步的任务是将**所有不是参数或常量的变量**放入 let 中，这样它们就可以在 lambda 演算中使用。
- en: 'For now on, the code will be very unreadable, but let’s focus in an example
    of how that substitution is made. In the function `_partition` that we defined
    before, we’re going to replace `x` by a let. By now, this function looks like
    this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，代码将变得非常难以阅读，但让我们专注于一个如何进行替换的示例。在我们之前定义的 `_partition` 函数中，我们将用 let 替换 `x`。到目前为止，这个函数看起来像这样：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `if` here only changes the values of `L` and `R`, we can write it as an
    **if-expression**:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `if` 只改变 `L` 和 `R` 的值，我们可以将其写成一个**if表达式**：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We’re only evaluating `x` in order to be used by that if-expression, so we
    can use a `let` here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是为了被那个 if 表达式使用而评估 `x`，所以我们可以在这里使用 `let`：
- en: '**attribution**: `x = LAMBDA_CAR(S)`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赋值**：`x = LAMBDA_CAR(S)`'
- en: '**expression**: the if-expression that we just defined'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达式**：我们刚刚定义的 if 表达式'
- en: 'To do that, let’s declare a new function called `_partition2` that takes `x`
    as its argument and call it soon after, passing as the argument `x = LAMBDA_CAR(S)`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，让我们声明一个名为 `_partition2` 的新函数，它以 `x` 为参数，并在之后立即调用它，将 `x = LAMBDA_CAR(S)` 作为参数传递：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We have a `let`! We can also replace the tuple by a **Church pair**:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `let`！我们还可以用一个**Church 对**替换元组：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can see it [here](https://github.com/lucasoshiro/lambdasort/blob/let/lambdasort.py).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[这里](https://github.com/lucasoshiro/lambdasort/blob/let/lambdasort.py)看到它。
- en: Rewriting functions using `lambda`
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `lambda` 重写函数
- en: At this point, having all the **variables replaced by let**, the `partition`
    and `quicksort` functions don’t have variables anymore. They only have some `if`s,
    the return expression, and the definition of **internal functions** used by the
    lets (and they have the same characteristics).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，将所有**变量替换为 let**，`partition` 和 `quicksort` 函数不再具有变量。它们只有一些 `if`、返回表达式以及由
    lets 使用的**内部函数**的定义（它们具有相同的特征）。
- en: 'Take a look at this (yeah, only a look because this code is unreadable):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看这个（是的，只看一看，因为这段代码是无法阅读的）：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can **replace** all the `if`s by **if-expressions** and those if-expressions
    by `LAMBDA_IF` that we defined using Church booleans. Besides that, the **internal
    functions** can be defined using `lambda` instead of `def` as they only have the
    **return expression**. Now we have this awful code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用**if表达式**替换所有的 `if`，并用我们使用 Church 布尔值定义的 `LAMBDA_IF` 替换那些 if 表达式。此外，**内部函数**可以使用
    `lambda` 而不是 `def` 来定义，因为它们只有**返回表达式**。现在我们有了这段糟糕的代码：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this case, the internal functions (even though they are now variables) can
    be **constants**. This way, they don’t need to be inside `quicksort` and `partition`
    that could only have the **return expression**. Then, they could be written using
    `lambda` instead of `def`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，内部函数（即使它们现在是变量）可以是**常量**。这样，它们就不需要在 `quicksort` 和 `partition` 中，后者只能有**返回表达式**。然后，它们可以使用
    `lambda` 而不是 `def` 来编写：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Recursion and Y combinator
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归和 Y 组合子
- en: 'Some of those lambda functions are **recursive**:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些 lambda 函数是**递归**的：
- en: '`quicksort` calls `_quicksort2` that calls `quicksort`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quicksort` 调用 `_quicksort2`，后者调用 `quicksort`'
- en: '`_partition` calls `_partition3` that calls `_partition`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_partition` 调用 `_partition3`，后者调用 `_partition`'
- en: However, a property of lambda calculus is that a function **doesn’t need to
    have a name**. But how can a function reference itself without knowing its name?
    The answer is **[Y Combinator](https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus)**.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，lambda 演算的一个特性是，一个函数**不需要有一个名称**。但是一个函数如何在不知道它的名称的情况下引用自身呢？答案是**[Y 组合子](https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus)**。
- en: 'To illustrate Y combinator, take a look at this factorial function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 Y 组合子，请看这个阶乘函数：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then we can use Y combinator to replace the `fac` call:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用 Y 组合子替换 `fac` 调用：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'What happens inside that thing? Note that we have a function `(lambda f: lambda
    n: 1 if n == 0 else n * f(f)(n-1))`, very similar to the original `fac`, **except**
    that it takes an argument `f` and calls `f(f)` instead of `fac`. The idea of Y
    combinator here is that `f` will always be the **same function** and that it passes
    **itself as an argument**, recursively, in order to the allow the recursive calls
    to make another recursive calls. Who will guarantee the **base** of that recursion
    is `(lambda f: f(f))`, that will provide the first passing of that function to
    itself.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '在那个东西里发生了什么？请注意，我们有一个函数`(lambda f: lambda n: 1 if n == 0 else n * f(f)(n-1))`，非常类似于原始的`fac`，**除了**它接受一个参数`f`并调用`f(f)`而不是`fac`。这里Y组合子的思想是，`f`将始终是**相同的函数**，并且它递归地将**自己作为参数**传递，以便递归调用产生另一个递归调用。谁将保证递归的**基础**是`(lambda
    f: f(f))`，它将为该函数的第一个传递提供第一个传递。'
- en: 'Mental exercise: try to simulate `fac(2)` and see the magic happening.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 心理练习：尝试模拟`fac(2)`，看看神奇的事情发生了。
- en: Using Y combinator
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Y组合子
- en: 'Ok, now we can replace the recursive call in `quicksort` by a Y combinator.
    By now it looks like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以在`quicksort`中用Y组合子替换递归调用。现在它看起来是这样的：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And if we replace it by Y combinator:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用Y组合子替换它：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Mental exercise: the `quicksort` call **is not** in `quicksort` itself but
    in `_quicksort2` (that is called by `quicksort`). Can you figure out how Y combinator
    is used in that situation?'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 心理练习：`quicksort`调用**不在**`quicksort`本身中，而在`_quicksort2`中（由`quicksort`调用）。你能想象出Y组合子在这种情况下是如何使用的吗？
- en: You can see it [here](https://github.com/lucasoshiro/lambdasort/blob/y-combinator/lambdasort.py).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[这里](https://github.com/lucasoshiro/lambdasort/blob/y-combinator/lambdasort.py)看到它。
- en: Expanding everything!
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展一切！
- en: At this point, all the **values**, **data structures** and `if`s are functions.
    Also, those functions and all the others are **values** that can be written in
    a single expression.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，所有的**值**、**数据结构**和`if`都是函数。此外，这些函数和所有其他函数都是可以写成单个表达式的**值**。
- en: Our work here is, basically, replace **all the constants** by their **values**
    so that `quicksort` can be a single expression. This can be done using the text
    replacement tool of a text editor.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的工作基本上是，将**所有的常量**替换为它们的**值**，以便`quicksort`可以成为一个单一的表达式。这可以通过文本编辑器的文本替换工具来完成。
- en: 'Finally we have this awful thing:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们有了这个可怕的东西：
- en: '`quicksort = (lambda r: r(r))(lambda r: lambda A: (lambda r: lambda A: (lambda
    c: lambda t: lambda e: c(t)(e))((lambda l: l(lambda h: lambda t: lambda d: (lambda
    a: lambda b: b))((lambda a: lambda b: a)))(A))(lambda A: A)(lambda A: (lambda
    c: lambda t: lambda e: c(t)(e))((lambda l: l(lambda h: lambda t: lambda d: (lambda
    a: lambda b: b))((lambda a: lambda b: a)))((lambda p: p(lambda a: lambda b: b))(A)))(A)((lambda
    r: lambda A: lambda LR: (lambda c: lambda t: lambda e: c(t)(e))((lambda l: l(lambda
    h: lambda t: lambda d: (lambda a: lambda b: b))((lambda a: lambda b: a)))(r(r)((lambda
    p: p(lambda a: lambda b: a))(LR))))((lambda a: lambda b: lambda l: l(a)(b))((lambda
    p: p(lambda a: lambda b: a))((lambda p: p(lambda a: lambda b: b))(LR)))(r(r)((lambda
    p: p(lambda a: lambda b: b))((lambda p: p(lambda a: lambda b: b))(LR)))))(((lambda
    r: r(r)) (lambda r: lambda l1: (lambda c: lambda t: lambda e: c(t)(e))((lambda
    l: l(lambda h: lambda t: lambda d: (lambda a: lambda b: b))((lambda a: lambda
    b: a)))((lambda p: p(lambda a: lambda b: b))(l1)))(lambda l2: (lambda a: lambda
    b: lambda l: l(a)(b))((lambda p: p(lambda a: lambda b: a))(l1))(l2))((lambda r:
    lambda l2: (lambda a: lambda b: lambda l: l(a)(b))((lambda p: p(lambda a: lambda
    b: a))(l1))(r(r)((lambda p: p(lambda a: lambda b: b))(l1))(l2)))(r))))(r(r)((lambda
    p: p(lambda a: lambda b: a))(LR)))((lambda a: lambda b: lambda l: l(a)(b))((lambda
    p: p(lambda a: lambda b: a))((lambda p: p(lambda a: lambda b: b))(LR)))(r(r)((lambda
    p: p(lambda a: lambda b: b))((lambda p: p(lambda a: lambda b: b))(LR)))))))(r)(A)((lambda
    A:((lambda A: lambda LR: (lambda a: lambda b: lambda l: l(a)(b))((lambda p: p(lambda
    a: lambda b: a))(LR))((lambda a: lambda b: lambda l: l(a)(b))((lambda p: p(lambda
    a: lambda b: a))(A))((lambda p: p(lambda a: lambda b: b))(LR)))))(A)(((lambda
    r: r(r))(lambda r: lambda S: (lambda c: lambda t: lambda e: c(t)(e))((lambda l:
    l(lambda h: lambda t: lambda d: (lambda a: lambda b: b))((lambda a: lambda b:
    a)))(S))(lambda L: lambda R: lambda p: (lambda a: lambda b: lambda l: l(a)(b))(L)(R))(lambda
    L: lambda R: lambda p: (lambda r: lambda S: lambda LR: lambda p: r(r)((lambda
    p: p(lambda a: lambda b: b))(S))((lambda p: p(lambda a: lambda b: a))(LR))((lambda
    p: p(lambda a: lambda b: b))(LR))(p))(r)(S)((lambda x: lambda L: lambda R: lambda
    p: (lambda c: lambda t: lambda e: c(t)(e))((lambda m: lambda n: (lambda a: lambda
    b: a(b)((lambda a: lambda b: b)))((lambda m: lambda n: (lambda n: n(lambda x:
    (lambda a: lambda b: b))((lambda a: lambda b: a)))((lambda m: lambda n: n((lambda
    n: lambda f: lambda x: n(lambda g: lambda h: h(g(f)))(lambda y: x)(lambda y: y)))(m))(m)(n)))(m)(n))((lambda
    a: a((lambda a: lambda b: b))((lambda a: lambda b: a)))((lambda m: lambda n: (lambda
    a: lambda b: a(b)((lambda a: lambda b: b)))((lambda m: lambda n: (lambda n: n(lambda
    x: (lambda a: lambda b: b))((lambda a: lambda b: a)))((lambda m: lambda n: n((lambda
    n: lambda f: lambda x: n(lambda g: lambda h: h(g(f)))(lambda y: x)(lambda y: y)))(m))(m)(n)))(m)(n))((lambda
    m: lambda n: (lambda n: n(lambda x: (lambda a: lambda b: b))((lambda a: lambda
    b: a)))((lambda m: lambda n: n((lambda n: lambda f: lambda x: n(lambda g: lambda
    h: h(g(f)))(lambda y: x)(lambda y: y)))(m))(m)(n)))(n)(m)))(m)(n))))(x)(p))((lambda
    a: lambda b: lambda l: l(a)(b))((lambda a: lambda b: lambda l: l(a)(b))(x)(L))(R))((lambda
    a: lambda b: lambda l: l(a)(b))(L)((lambda a: lambda b: lambda l: l(a)(b))(x)(R))))((lambda
    p: p(lambda a: lambda b: a))(S))(L)(R)(p))(p))))((lambda p: p(lambda a: lambda
    b: b))(A))((lambda a: lambda b: b))((lambda a: lambda b: b))((lambda p: p(lambda
    a: lambda b: a))(A))))(A)))))(r)(A)(A))`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`quicksort = (lambda r: r(r))(lambda r: lambda A: (lambda r: lambda A: (lambda
    c: lambda t: lambda e: c(t)(e))((lambda l: l(lambda h: lambda t: lambda d: (lambda
    a: lambda b: b))((lambda a: lambda b: a)))(A))(lambda A: A)(lambda A: (lambda
    c: lambda t: lambda e: c(t)(e))((lambda l: l(lambda h: lambda t: lambda d: (lambda
    a: lambda b: b))((lambda a: lambda b: a)))((lambda p: p(lambda a: lambda b: b))(A)))(A)((lambda
    r: lambda A: lambda LR: (lambda c: lambda t: lambda e: c(t)(e))((lambda l: l(lambda
    h: lambda t: lambda d: (lambda a: lambda b: b))((lambda a: lambda b: a)))(r(r)((lambda
    p: p(lambda a: lambda b: a))(LR))))((lambda a: lambda b: lambda l: l(a)(b))((lambda
    p: p(lambda a: lambda b: a))((lambda p: p(lambda a: lambda b: b))(LR)))(r(r)((lambda
    p: p(lambda a: lambda b: b))((lambda p: p(lambda a: lambda b: b))(LR)))))(((lambda
    r: r(r)) (lambda r: lambda l1: (lambda c: lambda t: lambda e: c(t)(e))((lambda
    l: l(lambda h: lambda t: lambda d: (lambda a: lambda b: b))((lambda a: lambda
    b: a)))((lambda p: p(lambda a: lambda b: b))(l1)))(lambda l2: (lambda a: lambda
    b: lambda l: l(a)(b))((lambda p: p(lambda a: lambda b: a))(l1))(l2))((lambda r:
    lambda l2: (lambda a: lambda b: lambda l: l(a)(b))((lambda p: p(lambda a: lambda
    b: a))(l1))(r(r)((lambda p: p(lambda a: lambda b: b))(l1))(l2)))(r))))(r(r)((lambda
    p: p(lambda a: lambda b: a))(LR)))((lambda a: lambda b: lambda l: l(a)(b))((lambda
    p: p(lambda a: lambda b: a))((lambda p: p(lambda a: lambda b: b))(LR)))(r(r)((lambda
    p: p(lambda a: lambda b: b))((lambda p: p(lambda a: lambda b: b))(LR)))))))(r)(A)((lambda
    A:((lambda A: lambda LR: (lambda a: lambda b: lambda l: l(a)(b))((lambda p: p(lambda
    a: lambda b: a))(LR))((lambda a: lambda b: lambda l: l(a)(b))((lambda p: p(lambda
    a: lambda b: a))(A))((lambda p: p(lambda a: lambda b: b))(LR)))))(A)(((lambda
    r: r(r))(lambda r: lambda S: (lambda c: lambda t: lambda e: c(t)(e))((lambda l:
    l(lambda h: lambda t: lambda d: (lambda a: lambda b: b))((lambda a: lambda b:
    a)))(S))(lambda L: lambda R: lambda p: (lambda a: lambda b: lambda l: l(a)(b))(L)(R))(lambda
    L: lambda R: lambda p: (lambda r: lambda S: lambda LR: lambda p: r(r)((lambda
    p: p(lambda a: lambda b: b))(S))((lambda p: p(lambda a: lambda b: a))(LR))((lambda
    p: p(lambda a: lambda b: b))(LR))(p))(r)(S)((lambda x: lambda L: lambda R: lambda
    p: (lambda c: lambda t: lambda e: c(t)(e))((lambda m: lambda n: (lambda a: lambda
    b: a(b)((lambda a: lambda b: b)))((lambda m: lambda n: (lambda n: n(lambda x:
    (lambda a: lambda b: b))((lambda a: lambda b: a)))((lambda m: lambda n: n((lambda
    n: lambda f: lambda x: n(lambda g: lambda h: h(g(f)))(lambda y: x)(lambda y: y)))(m))(m)(n)))(m)(n))((lambda
    a: a((lambda a: lambda b: b))((lambda a: lambda b: a)))((lambda m'
- en: Using lambdasort
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用lambdasort
- en: Of course we can’t use this `quicksort` by itself in a list as it operates in
    Church encoding. We’ll need a wrapper to translate the Python types to Church
    encoding, sort the Church list using `quicksort` and then translate it back to
    a Python list. We’re going to use the previous functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不能单独在列表中使用这个`quicksort`，因为它是以Church编码方式操作的。我们需要一个包装器来将Python类型转换为Church编码，使用`quicksort`对Church列表进行排序，然后将其转换回Python列表。我们将使用之前的函数。
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now you can use `quicksort_wrapper` to sort your list and it will use our lambdasort
    as backend:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用`quicksort_wrapper`来对你的列表进行排序，它将使用我们的lambdasort作为后端：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Final thoughts
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后的思考
- en: I wrote lambdasort in 2017 (my third year of university) in just two intense
    days, after a class by [Professor Gubi](https://memorial.ime.usp.br/homenageados/5)
    about lambda calculus and Y combinator. He told us about Programming with Nothing,
    mentioned earlier. I found it so impressive that I wanted to do something similar,
    and challenged myself to write something *harder* then a fizzbuzz, so here we
    are!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我在2017年（我大学的第三年）只用了两天写出了lambdasort，在参加了[古比教授](https://memorial.ime.usp.br/homenageados/5)关于lambda演算和Y组合子的课程后。他曾经提到过编程无所不用其极。我觉得那太令人印象深刻了，我想做点类似的事情，于是挑战自己写了一些比fizzbuzz更*困难*的东西，所以我们就在这里！
- en: Write it was really fun, and I didn’t notice at first how much I learned in
    only two days, and it took me years to finally write this text explaining what
    I did. So, thank you for reading it!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 写下这些真的很有趣，起初我没有注意到我只用了两天就学到了这么多知识，而我花了几年时间才最终写下这篇解释我所做的事情的文字。所以，谢谢你阅读！
- en: Last but not least, English is not my first language and I’m trying to make
    my best efforts to keep my personal page in both Portuguese and English. So, if
    you find something wrong about it or about anything here feel free to [open a
    issue](https://github.com/lucasoshiro/lucasoshiro.github.io/issues).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的，英语不是我的母语，我正在尽最大努力保持我的个人页面同时用葡萄牙语和英语编写。所以，如果你发现有什么不对或者对这里的任何事情有意见，请随时[提出问题](https://github.com/lucasoshiro/lucasoshiro.github.io/issues)。
