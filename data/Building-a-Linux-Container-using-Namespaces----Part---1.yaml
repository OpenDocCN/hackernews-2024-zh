- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 13:09:22'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 13:09:22'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'Building a Linux Container using Namespaces :: Part - 1'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '构建 Linux 容器使用 Namespaces :: 第一部分'
- en: 来源：[https://www.polarsparc.com/xhtml/Containers-1.html](https://www.polarsparc.com/xhtml/Containers-1.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://www.polarsparc.com/xhtml/Containers-1.html](https://www.polarsparc.com/xhtml/Containers-1.html)
- en: 'Building a Linux Container using Namespaces :: Part - 1'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: '构建 Linux 容器使用 Namespaces :: 第一部分'
- en: '* * *'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Ever wondered how Linux Containers worked ???
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过 Linux 容器是如何工作的？
- en: Currently, [Docker](https://www.polarsparc.com/xhtml/Docker.html) is one of
    the most popular and prevalent container implementations.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，[Docker](https://www.polarsparc.com/xhtml/Docker.html) 是最流行和普遍使用的容器实现之一。
- en: Containers run on top of the same Operating System kernel, but isolate the application
    processes running inside them from one another. One of the secret sauces behind
    containers is [Namespaces](http://man7.org/linux/man-pages/man7/namespaces.7.html).
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行在相同的操作系统内核上，但将其内部运行的应用程序进程互相隔离。容器背后的秘密之一是 [Namespaces](http://man7.org/linux/man-pages/man7/namespaces.7.html)。
- en: A Namespace abstracts global system resources, such as, host names, user IDs,
    group IDs, process IDs, network ports, etc., in a way that it appears to the processes
    (within the namespace) as though they have their own isolated instance of the
    global system resources. One of the primary goals of namespaces is to support
    the implementation of containers (lightweight virtualization).
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间将全局系统资源，如主机名、用户 ID、组 ID、进程 ID、网络端口等，在进程看来抽象为它们拥有自己的隔离实例。命名空间的主要目标之一是支持容器的实现（轻量级虚拟化）。
- en: Currently, in Linux there are 6 types of namespaces - IPC, Network, Mount, PID,
    User, and UTS.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Linux 中存在 6 种类型的命名空间 — IPC、网络、挂载、PID、用户和 UTS。
- en: 'The following are brief descriptions for each of the namespaces:'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个命名空间的简要描述：
- en: 'IPC :: This namespace isolates certain interprocess communication (IPC) resources,
    namely, Message Queues, Semaphores, and Shared Memory'
  id: totrans-split-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IPC :: 此命名空间隔离了某些进程间通信（IPC）资源，即消息队列、信号量和共享内存。'
- en: 'Network :: This namespace provides isolation of the system resources associated
    with networking, such as, Network devices, IP addresses, IP routing tables, /proc/net
    directory, port numbers, and so on'
  id: totrans-split-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '网络 :: 此命名空间提供了与网络相关的系统资源隔离，例如网络设备、IP 地址、IP 路由表、/proc/net 目录、端口号等。'
- en: 'Mount :: This namespace isolates the set of filesystem mount points seen by
    a group of processes. Processes in different mount namespaces can have different
    views of the filesystem hierarchy'
  id: totrans-split-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mount :: 此命名空间隔离了一组进程所看到的文件系统挂载点集合。不同挂载命名空间中的进程可以有不同的文件系统层次结构视图。'
- en: 'PID :: This namespace isolates the process ID number space. This allows processes
    in different PID namespaces to have the same PID'
  id: totrans-split-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PID :: 此命名空间隔离了进程 ID 号空间。这使得不同 PID 命名空间中的进程可以拥有相同的 PID。'
- en: 'User :: This namespace isolates the user and group ID number spaces, such that,
    a process''s user and group IDs can be different inside and outside the user namespace'
  id: totrans-split-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '用户 :: 此命名空间隔离了用户和组 ID 号空间，使得进程的用户和组 ID 在用户命名空间内外可以不同。'
- en: 'UTS :: This namespace isolates two system identifiers — the hostname and the
    domainname. For containers, the UTS namespaces allows each container to have its
    own hostname and NIS domain name'
  id: totrans-split-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'UTS :: 此命名空间隔离了两个系统标识符 — 主机名和域名。对于容器来说，UTS 命名空间允许每个容器拥有自己的主机名和 NIS 域名。'
- en: For the demonstration in this article, we will be using the unshare Linux command
    as well as implement, build, and execute a simple container using golang.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文的演示中，我们将使用 unshare Linux 命令，以及使用 golang 实现、构建和执行一个简单的容器。
- en: The installation is on a Ubuntu 18.04 LTS based Linux desktop.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 安装在基于 Ubuntu 18.04 LTS 的 Linux 桌面系统上。
- en: We will need two commands newuidmap and newgidmap to demonstrate User namespace.
    For this, we need to install the package uidmap.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要两个命令 newuidmap 和 newgidmap 来演示用户命名空间。为此，我们需要安装 uidmap 软件包。
- en: 'To install the package uidmap, execute the following command:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 uidmap 软件包，请执行以下命令：
- en: $ sudo apt install -y uidmap
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo apt install -y uidmap
- en: Next, we will need the brctl command to create a bridge network interface. For
    this, we need to install the package bridge-utils.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将需要 brctl 命令来创建一个桥接网络接口。为此，我们需要安装 bridge-utils 软件包。
- en: 'To install the package bridge-utils, execute the following command:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 bridge-utils 软件包，请执行以下命令：
- en: $ sudo apt install -y bridge-utils
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo apt install -y bridge-utils
- en: To develop, build, and execute the simple container in go programming language,
    we need to install the golang package.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发、构建和执行go编程语言中的简单容器，我们需要安装golang包。
- en: 'To check the version of golang available to install, execute the following
    command:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查可安装的golang版本，请执行以下命令：
- en: $ sudo apt-cache policy golang
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo apt-cache policy golang
- en: 'The following would be a typical output:'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是典型的输出：
- en: Output.1
  id: totrans-split-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出。1
- en: '[PRE0]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install golang, execute the following command:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装golang，请执行以下命令：
- en: $ sudo apt install -y golang
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo apt install -y golang
- en: The above installation procedure installs golang from the official Ubuntu repository.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述安装过程从官方Ubuntu存储库安装golang。
- en: 'Create a directory for developing, building, and running go programs by executing
    the following commands:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令为开发、构建和运行go程序创建一个目录：
- en: $ mkdir $HOME/projects/go
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: $ mkdir $HOME/projects/go
- en: $ export GOPATH=$HOME/projects/go
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: $ export GOPATH=$HOME/projects/go
- en: We will need one of the popular go packages on netlink for networking.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个名为netlink的流行go包进行网络连接。
- en: 'To download the go package, execute the following command:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载go包，请执行以下命令：
- en: $ go get github.com/vishvananda/netlink
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: $ go get github.com/vishvananda/netlink
- en: Open two Terminal windows - we will refer to them as TA and TB respectively.
    TB is where we will demonstrate the simple container.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 打开两个终端窗口 - 我们将分别称它们为TA和TB。TB是我们将演示简单容器的地方。
- en: We need to download a minimal root filesystem (rootfs) that will be used as
    the base image for the simple container. For our demonstration, we will choose
    the latest [Ubuntu Base 18.04.4 LTS](http://cdimage.ubuntu.com/ubuntu-base/releases/18.04.4/release/ubuntu-base-18.04.4-base-amd64.tar.gz)
    at the time of this article.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要下载一个作为简单容器基础镜像的最小根文件系统（rootfs）。对于我们的演示，我们将选择此文章撰写时的最新[Ubuntu Base 18.04.4
    LTS](http://cdimage.ubuntu.com/ubuntu-base/releases/18.04.4/release/ubuntu-base-18.04.4-base-amd64.tar.gz)。
- en: We will assume the latest Ubuntu Base is downloaded to the directory $HOME/Downloads.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设最新的Ubuntu Base已下载到目录$HOME/Downloads。
- en: The unshare command executes the specified program with the indicated namespace(s)
    isolated from the parent process.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: unshare命令将指定的程序与从父进程隔离的指定命名空间一起执行。
- en: 'To display the options for the unshare command, execute the following command
    in TA:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示unshare命令的选项，请在TA中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是典型的输出：
- en: Output.2
  id: totrans-split-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出。2
- en: '[PRE1]'
  id: totrans-split-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each process (with [PID]) has associated with it a sub-directory /proc/[PID]/ns
    that contains one entry for each of the namespaces.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程（带有[PID]）都有一个子目录/proc/[PID]/ns，其中包含每个命名空间的一个条目。
- en: 'To list all the namespaces associated with a process, execute the following
    command in TA :'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出与进程相关的所有命名空间，请在TA中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是典型的输出：
- en: Output.3
  id: totrans-split-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出。3
- en: '[PRE2]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To launch a simple container whose host name is isolated from the parent host
    name, execute the following command in TB:'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个简单容器，其主机名与父主机名隔离，请在TB中执行以下命令：
- en: $ sudo unshare -u /bin/sh
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo unshare -u /bin/sh
- en: The -u option enables the UTS namespace.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: -u选项启用UTS命名空间。
- en: 'The command prompt will change to a #.'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提示符将更改为#。
- en: 'To check the PID of the simple container, execute the following command in
    TB:'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查简单容器的PID，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是典型的输出：
- en: 'To list all the namespaces associated with the simple container, execute the
    following command in TB:'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出与简单容器相关的所有命名空间，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是典型的输出：
- en: Output.5
  id: totrans-split-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出。5
- en: '[PRE3]'
  id: totrans-split-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Comparing Output.5 to Output.3, we see a change in the uts namespace, which
    is expected and correct.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: 比较输出。5和输出。3，我们看到了UTS命名空间的变化，这是预期的和正确的。
- en: 'To change the host name of the simple container, execute the following command
    in TB:'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改简单容器的主机名，请在TB中执行以下命令：
- en: 'To display the host name of the parent host, execute the following command
    in TA:'
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示父主机的主机名，请在TA中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是典型的输出：
- en: 'To display the host name of the simple container, execute the following command
    in TB:'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示简单容器的主机名，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是典型的输出：
- en: This demonstrates to us that we have isolated the host name of the simple container
    from the parent host name.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了我们已将简单容器的主机名与父主机名隔离开来。
- en: 'To exit the simple container, execute the following command in TB:'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出简单容器，请在TB中执行以下命令：
- en: 'Next, we will mimic the above UTS namespace isolation using the following go
    program:'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下go程序模仿上述UTS命名空间隔离：
- en: <fieldset id="sc-fieldset"><legend>Listing.1</legend>
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: <fieldset id="sc-fieldset"><legend>清单.1</legend>
- en: '[PRE4]'
  id: totrans-split-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: </fieldset>
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: </fieldset>
- en: The Command function from the exec package allows one to run the specified command
    (1st parameter) with the supplied arguments (2nd parameter). It returns an instance
    of the Cmd struct.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: exec包中的Command函数允许运行指定的命令（第一个参数）并使用提供的参数（第二个参数）。它返回Cmd结构体的实例。
- en: One can set the standard input (os.Stdin), the standard output os.Stdout, the
    standard error os.Stderr, and some operating system specific attributes on the
    returned Cmd instance. In this case, we specify the syscall.CLONE_NEWUTS OS attribute
    to indicate the command be run in a new UTS namespace.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在返回的Cmd实例上设置标准输入（os.Stdin）、标准输出os.Stdout、标准错误os.Stderr以及一些操作系统特定的属性。在本例中，我们指定syscall.CLONE_NEWUTS操作系统属性以指示在新的UTS命名空间中运行命令。
- en: 'IMPORTANT : When the main process starts, it internally spawns another main
    process (with the CLONE argument) in a new namespace. It is this spawned main
    process (running in the new namespace) that is overlayed (syscall.Exec) with the
    shell command by invoking the function execContainerShell.'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：当主进程启动时，它会在新的命名空间中内部生成另一个主进程（带有CLONE参数）。正是这个在新命名空间中运行的生成的主进程，通过调用execContainerShell函数将其覆盖（syscall.Exec）为shell命令。
- en: 'Create and change to the directory $GOPATH/uts by executing the following commands
    in TB:'
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在TB中执行以下命令创建并切换到目录$GOPATH/uts：
- en: $ mkdir -p $GOPATH/uts
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: $ mkdir -p $GOPATH/uts
- en: $ cd $GOPATH/uts
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: $ cd $GOPATH/uts
- en: Copy the above code into the program file main.go in the current directory.
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将以上代码复制到当前目录中的程序文件main.go中。
- en: 'To compile the program file main.go, execute the following command in TB:'
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译程序文件main.go，请在TB中执行以下命令：
- en: 'To run program main, execute the following command in TB:'
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行主程序，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是典型的输出：
- en: Output.8
  id: totrans-split-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.8
- en: '[PRE5]'
  id: totrans-split-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The command prompt will change to a ->.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提示符将变更为->。
- en: 'To display the host name of the simple container, execute the following command
    in TB:'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示简单容器的主机名，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是典型的输出：
- en: 'To exit the simple container, execute the following command in TB:'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出简单容器，请在TB中执行以下命令：
- en: SUCCESS !!! We have demonstrated the UTS namespace using both the unshare command
    and a simple go program.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！！！我们已经展示了使用unshare命令和简单go程序的UTS命名空间。
- en: Let us layer the User namespace on top of the UTS namespace.
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将用户命名空间层叠在UTS命名空间上。
- en: 'To launch a simple container whose user/group IDs as well as the host name
    are isolated from the parent namespace, execute the following command in TB:'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个简单容器，其用户/组ID以及主机名与父命名空间隔离，请在TB中执行以下命令：
- en: $ sudo unshare -uU /bin/sh
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo unshare -uU /bin/sh
- en: The -U option enables the User namespace.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: -U选项启用了用户命名空间。
- en: 'To display the user ID and group ID in the new namespace, execute the following
    command in TB:'
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要在新的命名空间中显示用户ID和组ID，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是典型的输出：
- en: Output.10
  id: totrans-split-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.10
- en: '[PRE6]'
  id: totrans-split-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When a User namespace is created, it starts without a mapping for the user/group
    IDs in the new namespace to the parent user/group IDs. The unmapped user/group
    ID is assigned the default value of the overflow user/group ID. The default value
    for the overflow user ID is read from /proc/sys/kernel/overflowuid (which is 65534).
    Similarly, the default value for the overflow group ID is read from /proc/sys/kernel/overflowgid
    (which is 65534).
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户命名空间时，默认情况下，新命名空间中的用户/组ID不会映射到父命名空间的用户/组ID。未映射的用户/组ID将分配默认值溢出用户/组ID。溢出用户ID的默认值从/proc/sys/kernel/overflowuid读取（为65534）。类似地，溢出组ID的默认值从/proc/sys/kernel/overflowgid读取（为65534）。
- en: 'To fix the mapping for the user/group ID to the parent user/group ID, exit
    the simple container by executing the following command in TB:'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复用户/组ID到父用户/组ID的映射，请通过在TB中执行以下命令退出简单容器：
- en: 'To re-launch the simple container with the current effective user/group ID
    mapped to the superuser user/group ID in the new namespace, execute the following
    command in TB:'
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用当前有效的用户/组ID映射到新命名空间中的超级用户/组ID重新启动简单容器，请在TB中执行以下命令：
- en: $ sudo unshare -uUr /bin/sh
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo unshare -uUr /bin/sh
- en: The -r option enables the mapping of the user/group IDs in the new namespace
    to the parent namespace user/group IDs.
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: -r选项启用在新命名空间中用户/组ID到父命名空间用户/组ID的映射。
- en: 'The command prompt will change to a #.'
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提示符将更改为#。
- en: 'To display the user ID and group ID in the new namespace, execute the following
    command in TB:'
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示新命名空间中的用户ID和组ID，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.11
  id: totrans-split-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.11
- en: '[PRE7]'
  id: totrans-split-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To list all the namespaces associated with the simple container, execute the
    following command in TB:'
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出与简单容器关联的所有命名空间，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.12
  id: totrans-split-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.12
- en: '[PRE8]'
  id: totrans-split-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Comparing Output.12 to Output.3, we see a change in both the uts namespace as
    well as the user namespace, which is what is expected and correct.
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出.12与输出.3进行比较，我们看到了UTS命名空间和用户命名空间的变化，这是预期且正确的。
- en: 'To exit the simple container, execute the following command in TB:'
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出简单容器，请在TB中执行以下命令：
- en: 'Next, we will mimic the above UTS and User namespace isolation using the following
    go program:'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下go程序模仿上述的UTS和用户命名空间隔离：
- en: <fieldset id="sc-fieldset"><legend>Listing.2</legend>
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: <fieldset id="sc-fieldset"><legend>列表.2</legend>
- en: '[PRE9]'
  id: totrans-split-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: </fieldset>
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: </fieldset>
- en: As indicated previously, the Command function returns an instance of the Cmd
    struct.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Command函数返回Cmd结构的一个实例。
- en: In this example, we specify the additional syscall.CLONE_NEWUSER OS attribute
    to indicate the command be run in a new User namespace.
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们指定了额外的syscall.CLONE_NEWUSER操作系统属性，以指示在新的用户命名空间中运行命令。
- en: In addition, we set the user ID map UidMappings as an array of syscall.SysProcIDMap
    struct entries, each consisting of the user ID mapping in the container (ContainerID)
    to the user ID in the host namespace (HostID). In this case, we map the root user
    ID 0 in the container to the root user ID 0 of the host namespace. Similarly,
    we set the group ID map GidMappings
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将用户ID映射UidMappings设置为syscall.SysProcIDMap结构条目的数组，每个条目包含容器中的用户ID映射（ContainerID）到主机命名空间中的用户ID（HostID）。在本例中，我们将容器中的根用户ID
    0映射到主机命名空间中的根用户ID 0。类似地，我们设置组ID映射GidMappings
- en: 'Create and change to the directory $GOPATH/user by executing the following
    commands in TB:'
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在TB中执行以下命令来创建并切换到目录$GOPATH/user：
- en: $ mkdir -p $GOPATH/user
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: $ mkdir -p $GOPATH/user
- en: $ cd $GOPATH/user
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
  zh: $ cd $GOPATH/user
- en: Copy the above code into the program file main.go in the current directory.
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码复制到当前目录中的程序文件main.go中。
- en: 'To compile the program file main.go, execute the following command in TB:'
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译程序文件 main.go，请在TB中执行以下命令：
- en: 'To run program main, execute the following command in TB:'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序 main，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.13
  id: totrans-split-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.13
- en: '[PRE10]'
  id: totrans-split-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The command prompt will change to a ->.
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提示符将更改为->。
- en: 'To display the user ID and group ID in the new namespace, execute the following
    command in TB:'
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示新命名空间中的用户ID和组ID，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.14
  id: totrans-split-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.14
- en: '[PRE11]'
  id: totrans-split-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To list all the namespaces associated with the simple container, execute the
    following command in TB:'
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出与简单容器关联的所有命名空间，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.15
  id: totrans-split-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.15
- en: '[PRE12]'
  id: totrans-split-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To display the host name of the simple container, execute the following command
    in TB:'
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要在简单容器中显示主机名，请在TB中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: 'To exit the simple container, execute the following command in TB:'
  id: totrans-split-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出简单容器，请在TB中执行以下命令：
- en: SUCCESS !!! We have demonstrated the combined UTS and User namespaces using
    both the unshare command and a simple go program.
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们展示了使用unshare命令和一个简单的go程序组合UTS和用户命名空间。
- en: Let us now layer the PID namespace on top of the User namespace and the UTS
    namespace.
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在用户命名空间和UTS命名空间之上添加PID命名空间。
- en: 'To launch a simple container whose process IDs as well as the user/group IDs
    and the host name are isolated from the parent namespace, execute the following
    command in TB:'
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个简单容器，其进程ID、用户/组ID和主机名与父命名空间隔离，请在TB中执行以下命令：
- en: $ sudo unshare -uUrpf --mount-proc /bin/sh
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo unshare -uUrpf --mount-proc /bin/sh
- en: The -p option enables the PID namespace.
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: -p选项启用PID命名空间。
- en: The -f option enables spawning (or forking) of new processes in the new namespace.
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: -f选项启用在新命名空间中生成（或分叉）新进程。
- en: The --mount-proc option mounts the proc filesystem as a private mount at /proc
    in the new namespace. This means the /proc pseudo directory only shows information
    only about processes within that PID namespace.
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
  zh: --mount-proc选项在新的命名空间中将proc文件系统作为私有挂载点挂载到/proc。这意味着/proc伪目录仅显示有关该PID命名空间内进程的信息。
- en: ATTENTION
  id: totrans-split-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE13]'
  id: totrans-split-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The command prompt will change to a #.'
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
  zh: '命令提示符将变为 #。'
- en: 'To display all the processes in the new namespace, execute the following command
    in TB:'
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示新命名空间中的所有进程，请在 TB 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
  zh: 典型输出如下：
- en: Output.17
  id: totrans-split-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.17
- en: '[PRE14]'
  id: totrans-split-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To display all the processes in the parent namespace, execute the following
    command in TA:'
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示父命名空间中的所有进程，请在 TA 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
  zh: 典型输出如下：
- en: Output.18
  id: totrans-split-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.18
- en: '[PRE15]'
  id: totrans-split-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Comparing Output.17 to Output.18, we see the isolation between the new namespace
    and the parent namespace, which is what is expected and correct.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
  zh: 比较输出.17 和输出.18，我们可以看到新命名空间与父命名空间之间的隔离，这是预期的正确行为。
- en: 'To exit the simple container, execute the following command in TB:'
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出简单容器，请在 TB 中执行以下命令：
- en: 'Next, we will mimic the above UTS, User, and PID namespace isolation using
    the following go program:'
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下 Go 程序模拟上述 UTS、用户和 PID 命名空间隔离：
- en: <fieldset id="sc-fieldset"><legend>Listing.3</legend>
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`<fieldset id="sc-fieldset"><legend>Listing.3</legend>`'
- en: '[PRE16]'
  id: totrans-split-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: </fieldset>
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`</fieldset>`'
- en: As indicated previously, the Command function returns an instance of the Cmd
    struct.
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Command 函数返回 Cmd 结构体的一个实例。
- en: In this example, we specify the additional syscall.CLONE_NEWNS and syscall.CLONE_NEWPID
    OS attributes to indicate the command be run in a new PID namespace.
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们指定了附加的 syscall.CLONE_NEWNS 和 syscall.CLONE_NEWPID 操作系统属性，以指示在新 PID 命名空间中运行命令。
- en: 'Create and change to the directory $GOPATH/pid by executing the following commands
    in TB:'
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 TB 中执行以下命令，创建并切换到目录 $GOPATH/pid：
- en: $ mkdir -p $GOPATH/pid
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ mkdir -p $GOPATH/pid`'
- en: $ cd $GOPATH/pid
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ cd $GOPATH/pid`'
- en: Copy the above code into the program file main.go in the current directory.
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将以上代码复制到当前目录中的程序文件 main.go。
- en: 'To compile the program file main.go, execute the following command in TB:'
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
  zh: 编译程序文件 main.go，需在 TB 中执行以下命令：
- en: 'To run program main, execute the following command in TB:'
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序 main，请在 TB 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: 典型输出如下：
- en: Output.19
  id: totrans-split-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.19
- en: '[PRE17]'
  id: totrans-split-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The command prompt will change to a ->.
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提示符将变为 ->。
- en: 'To display the host name of the simple container, execute the following command
    in TB:'
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示简单容器的主机名，请在 TB 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: 典型输出如下：
- en: 'To display the user ID and group ID in the new namespace, execute the following
    command in TB:'
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示新命名空间中的用户 ID 和组 ID，请在 TB 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
  zh: 典型输出如下：
- en: Output.21
  id: totrans-split-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.21
- en: '[PRE18]'
  id: totrans-split-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To display all the processes in the simple container, execute the following
    command in TB:'
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示简单容器中的所有进程，请在 TB 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-190
  prefs: []
  type: TYPE_NORMAL
  zh: 典型输出如下：
- en: Output.22
  id: totrans-split-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.22
- en: '[PRE19]'
  id: totrans-split-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To list all the namespaces associated with the simple container, execute the
    following command in TB:'
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出与简单容器关联的所有命名空间，需在 TB 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
  zh: 典型输出如下：
- en: Output.23
  id: totrans-split-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.23
- en: '[PRE20]'
  id: totrans-split-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To exit the simple container, execute the following command in TB:'
  id: totrans-split-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出简单容器，请在 TB 中执行以下命令：
- en: SUCCESS !!! We have demonstrated the combined UTS, User, and PID namespaces
    using both the unshare command and a simple go program.
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经演示了使用 unshare 命令和一个简单的 Go 程序结合使用 UTS、用户和 PID 命名空间。
- en: We will now setup the minimal Ubuntu Base image for use in the new namespace
    in the /tmp directory.
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在 /tmp 目录中为新命名空间设置最小化的 Ubuntu 基础映像。
- en: 'To create and copy the base image to a directory in /tmp, execute the following
    commands in TA:'
  id: totrans-split-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并将基础映像复制到 /tmp 目录中的目录，请在 TA 中执行以下命令：
- en: $ mkdir -p /tmp/rootfs/.old_root
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ mkdir -p /tmp/rootfs/.old_root`'
- en: $ tar -xvf $HOME/Downloads/ubuntu-base-18.04.4-base-amd64.tar.gz --directory
    /tmp/rootfs
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ tar -xvf $HOME/Downloads/ubuntu-base-18.04.4-base-amd64.tar.gz --directory
    /tmp/rootfs`'
- en: cd /tmp
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd /tmp`'
- en: Now let us now layer the Mount namespace on top of the User, the UTS, and the
    PID namespaces.
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将 Mount 命名空间叠加到 UTS、用户和 PID 命名空间上。
- en: 'To launch a simple container whose mount points as well as the process IDs,
    the user/group IDs, and the host name are isolated from the parent namespace,
    execute the following command in TB:'
  id: totrans-split-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个简单容器，其挂载点以及进程 ID、用户/组 ID 和主机名与父命名空间隔离，请在 TB 中执行以下命令：
- en: $ sudo unshare -uUrpfm --mount-proc /bin/sh
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo unshare -uUrpfm --mount-proc /bin/sh`'
- en: The -m option enables the Mount namespace.
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m` 选项启用 Mount 命名空间。'
- en: 'The command prompt will change to a #.'
  id: totrans-split-208
  prefs: []
  type: TYPE_NORMAL
  zh: '命令提示符将变为 #。'
- en: 'To list all the mount points in the parent namespace, execute the following
    command in TA:'
  id: totrans-split-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出父命名空间中的所有挂载点，请在 TA 中执行以下命令：
- en: $ cat /proc/mounts | sort
  id: totrans-split-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ cat /proc/mounts | sort`'
- en: 'The following would be a typical output:'
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.24
  id: totrans-split-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.24
- en: '[PRE21]'
  id: totrans-split-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let us list all the mount points in the new namespace by executing the
    following command in TB:'
  id: totrans-split-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在 TB 中执行以下命令列出新命名空间中的所有挂载点：
- en: cat /proc/mounts | sort
  id: totrans-split-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cat /proc/mounts | sort
- en: 'The following would be a typical output:'
  id: totrans-split-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.25
  id: totrans-split-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.25
- en: '[PRE22]'
  id: totrans-split-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Comparing Output.25 and Output.24, we see the one difference for proc. When
    a new Mount namespace is created, the mount points of the new namespace is a copy
    of the mount points in the parent's namespace.
  id: totrans-split-219
  prefs: []
  type: TYPE_NORMAL
  zh: 比较输出 Output.25 和 Output.24，我们看到 proc 的一个区别。创建新的挂载命名空间时，新命名空间的挂载点是父命名空间挂载点的副本。
- en: We will now demonstrate any changes to the new namespace will not affect the
    parent namespace.
  id: totrans-split-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将演示新命名空间中的任何更改不会影响父命名空间。
- en: 'To make the mount point / (and its children recursively) to be private to the
    new namespace, execute the following command in TB:'
  id: totrans-split-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要使挂载点 /（及其递归子项）成为新命名空间的私有，请在 TB 中执行以下命令：
- en: mount --make-rprivate /
  id: totrans-split-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mount --make-rprivate /
- en: 'To recursive bind the mount point rootfs/ to rootfs/ in the new namespace,
    execute the following command in TB:'
  id: totrans-split-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TB 中，要将挂载点 rootfs/ 递归绑定到新命名空间中的 rootfs/，请执行以下命令：
- en: mount --rbind rootfs/ rootfs/
  id: totrans-split-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mount --rbind rootfs/ rootfs/
- en: 'We need the proc filesystem in the new namespace for making changes to mounts.
    To mount /proc as the proc filesystem proc in the new namespace, execute the following
    command in TB:'
  id: totrans-split-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在新命名空间中的 proc 文件系统来进行挂载更改。要在新命名空间中将 /proc 挂载为 proc 文件系统，请在 TB 中执行以下命令：
- en: mount -t proc proc rootfs/proc
  id: totrans-split-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mount -t proc proc rootfs/proc
- en: 'Next, we need to make rootfs/ the root filesystem in the new namespace and
    move the parent root filesystem to rootfs/.old_root using the pivot_root command.
    To do that, execute the following commands in TB:'
  id: totrans-split-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 rootfs/ 设为新命名空间的根文件系统，并使用 pivot_root 命令将父根文件系统移动到 rootfs/.old_root。要执行此操作，请在
    TB 中执行以下命令：
- en: pivot_root rootfs/ rootfs/.old_root
  id: totrans-split-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pivot_root rootfs/ rootfs/.old_root
- en: cd /
  id: totrans-split-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cd /
- en: 'To list all the file(s) under / in the parent namespace, execute the following
    command in TA:'
  id: totrans-split-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出父命名空间中 / 目录下的所有文件，请在 TA 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.26
  id: totrans-split-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.26
- en: '[PRE23]'
  id: totrans-split-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To list all the file(s) under / in the new namespace, execute the following
    command in TB:'
  id: totrans-split-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出新命名空间中 / 目录下的所有文件，请在 TB 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.27
  id: totrans-split-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.27
- en: '[PRE24]'
  id: totrans-split-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Comparing Output.26 and Output.27, we see the root filesystems are totally different.
  id: totrans-split-238
  prefs: []
  type: TYPE_NORMAL
  zh: 比较输出 Output.26 和 Output.27，我们看到根文件系统完全不同。
- en: 'To mount /tmp as the temporary filesystem tmpfs in the new namespace, execute
    the following command in TB:'
  id: totrans-split-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 /tmp 挂载为新命名空间的临时文件系统 tmpfs，请在 TB 中执行以下命令：
- en: mount -t tmpfs tmpfs /tmp
  id: totrans-split-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mount -t tmpfs tmpfs /tmp
- en: 'To create a text file /tmp/leopard.txt in the directory /tmp of the new namespace,
    execute the following command in TB:'
  id: totrans-split-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要在新命名空间的 /tmp 目录下创建文本文件 /tmp/leopard.txt，请在 TB 中执行以下命令：
- en: echo 'leopard' > /tmp/leopard.txt
  id: totrans-split-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: echo 'leopard' > /tmp/leopard.txt
- en: 'To list the properties of the file /tmp/leopard.txt in the new namespace, execute
    the following command in TB:'
  id: totrans-split-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出新命名空间中文件 /tmp/leopard.txt 的属性，请在 TB 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.28
  id: totrans-split-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.28
- en: '[PRE25]'
  id: totrans-split-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To list the properties of the file /tmp/leopard.txt in the parent namespace,
    execute the following command in TA:'
  id: totrans-split-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出父命名空间中文件 /tmp/leopard.txt 的属性，请在 TA 中执行以下命令：
- en: 'The following would be a typical output:'
  id: totrans-split-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.29
  id: totrans-split-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.29
- en: '[PRE26]'
  id: totrans-split-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, to completely remove the parent root filesystem rootfs/.old_root from
    the new namespace, execute the following commands in TB:'
  id: totrans-split-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要完全从新命名空间中删除父根文件系统 rootfs/.old_root，请在 TB 中执行以下命令：
- en: mount --make-rprivate /.old_root
  id: totrans-split-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mount --make-rprivate /.old_root
- en: umount -l /.old_root
  id: totrans-split-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: umount -l /.old_root
- en: 'To list all the mount points in the new namespace by executing the following
    command in TB :'
  id: totrans-split-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出新命名空间中的所有挂载点，请在 TB 中执行以下命令：
- en: cat /proc/mounts | sort
  id: totrans-split-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cat /proc/mounts | sort
- en: 'The following would be a typical output:'
  id: totrans-split-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的输出：
- en: Output.30
  id: totrans-split-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出.30
- en: '[PRE27]'
  id: totrans-split-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To exit the new namespace, execute the following command in TB:'
  id: totrans-split-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出新命名空间，请在 TB 中执行以下命令：
- en: SUCCESS !!! We have demonstrated the combined UTS, User, PID, and Mount namespaces
    using the unshare command.
  id: totrans-split-260
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经演示了使用 unshare 命令结合 UTS、用户、PID 和挂载命名空间。
- en: '* * *'
  id: totrans-split-261
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
