- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 13:41:38'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 13:41:38'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Why SQLite Uses Bytecode
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么 SQLite 使用字节码
- en: 来源：[https://sqlite.org/draft/whybytecode.html](https://sqlite.org/draft/whybytecode.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://sqlite.org/draft/whybytecode.html](https://sqlite.org/draft/whybytecode.html)
- en: 1\. Introduction
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 引言
- en: 'Every SQL database engine works in roughly the same way: It first translates
    the input SQL text into a "prepared statement". Then it "executes" the prepared
    statement to generate a result.'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 SQL 数据库引擎的工作方式大致相同：它首先将输入的 SQL 文本转换成一个“准备好的语句”。然后执行准备好的语句以生成结果。
- en: A prepared statement is an object that represents the steps needed to accomplish
    the input SQL. Or, to think of it in another way, the prepared statement is the
    SQL statement translated into a form that is more easily understood by the computer.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好的语句是一个对象，表示完成输入 SQL 所需的步骤。或者，换一种方式来思考，准备好的语句是将 SQL 语句翻译成计算机更易理解的形式。
- en: In SQLite, a prepared statement is an instance of the [sqlite3_stmt object](c3ref/stmt.html).
    In other systems, the prepared statement is usually an internal data structure
    that is not directly visible to the application programmer. Developers of other
    SQL database engines do not necessarily call these objects "prepared statements".
    But such objects exists, whatever they might be called. This paper will use the
    term "prepared statement".
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 中，准备好的语句是 [sqlite3_stmt 对象](c3ref/stmt.html)的一个实例。在其他系统中，准备好的语句通常是一个内部数据结构，不直接对应应用程序员可见。其他
    SQL 数据库引擎的开发者未必称这些对象为“准备好的语句”。但无论它们如何被称呼，这些对象都是存在的。本文将使用术语“准备好的语句”。
- en: 'There are countless ways of implementing a prepared statement. This paper will
    look at the two most common methods:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有无数种实现准备好的语句的方法。本文将讨论两种最常见的方法：
- en: '**Bytecode** → The input SQL is translated into a virtual machine language
    that is then run by a virtual machine interpreter. This is the technique used
    by SQLite.'
  id: totrans-split-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字节码** → 输入的 SQL 被翻译成一个虚拟机语言，然后由虚拟机解释器运行。这是 SQLite 使用的技术。'
- en: '**Tree-Of-Objects** → The input SQL is translated in a tree of objects that
    represent the processing to be done. The SQL is executed by walking this tree.
    This is the technique used by MySQL and PostgreSQL.'
  id: totrans-split-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对象树** → 输入的 SQL 被翻译成一个对象树，表示要执行的处理过程。SQL 通过遍历这棵树来执行。这是 MySQL 和 PostgreSQL
    使用的技术。'
- en: There are advantages and disadvantages to each of these representations of a
    prepared statement. The purpose of this paper is to articulate some of those advantages
    and disadvantages.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每种准备好的语句表示方法都有其优势和劣势。本文的目的是阐述其中一些优势和劣势。
- en: 1.1\. How To Provide Feedback
  id: totrans-split-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1\. 如何提供反馈
- en: This document is written from the perspective of the original author of SQLite.
    If you disagree with any of the opinions offered in this document, you are welcomed
    to offer corrections and/or contrary views on the [SQLite Forum](https://sqlite.org/forum).
    Or you can email the author directly.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是从 SQLite 的原始作者的角度编写的。如果您对本文提出的任何观点持不同意见，欢迎在 [SQLite 论坛](https://sqlite.org/forum)
    提出更正和/或相反的观点。或者您也可以直接邮件联系作者。
- en: 1.2\. Definition Of "Bytecode"
  id: totrans-split-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2\. "字节码" 的定义
- en: 'The [bytecode generated by SQLite](opcode.html) might be a little different
    from what many readers think of as bytecode. The bytecode used (for example) by
    the [Java virtual machine](https://en.wikipedia.org/wiki/Java_virtual_machine)
    or by [WebAssembly](https://en.wikipedia.org/wiki/WebAssembly) consists almost
    entirely of low-level operations, similar to what physical CPUs implement: basic
    math operators, comparisons, conditional jumps, and instructions to move content
    between different memory locations. SQLite bytecode has these kinds of low-level
    instructions, too. But SQLite bytecode also contains some high-level operations
    that are specific to the needs of a database engine. Here are just a few examples:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由 SQLite 生成的 [字节码](opcode.html) 可能与许多读者所认知的字节码有些许不同。例如，[Java 虚拟机](https://en.wikipedia.org/wiki/Java_virtual_machine)
    或 [WebAssembly](https://en.wikipedia.org/wiki/WebAssembly) 使用的字节码几乎完全由低级操作组成，类似于物理
    CPU 实现的基本数学运算符、比较、条件跳转以及在不同内存位置之间移动内容的指令。SQLite 的字节码也包含一些高级操作，这些操作特定于数据库引擎的需求。以下仅列举了一些示例：
- en: '**OP_Column** → Extract the value from the N-th column of the database row
    that a particular cursor is currently pointing at.'
  id: totrans-split-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OP_Column** → 从特定游标当前指向的数据库行中提取第 N 列的值。'
- en: '**OP_CreateBtree** → Allocate space for a new B-Tree in the database file.'
  id: totrans-split-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OP_CreateBtree** → 在数据库文件中为新的B-Tree分配空间。'
- en: '**OP_ParseSchema** → Reread and reparse all or part of the [sqlite_schema table](schematab.html)
    and refresh internal symbol tables accordingly.'
  id: totrans-split-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OP_ParseSchema** → 重新读取并重新解析全部或部分[sqlite_schema表](schematab.html)，并相应地刷新内部符号表。'
- en: '**OP_SeekGE** → Move a cursor on a particular B-Tree to the first entry that
    is greater than or equal to a given key.'
  id: totrans-split-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OP_SeekGE** → 将光标移动到特定B-Tree上第一个大于或等于给定键的条目。'
- en: '**OP_Next** → Advance a cursor on a particular B-Tree to the next entry in
    the B-Tree and jump, or fall through if there are no more entries in that B-Tree.'
  id: totrans-split-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OP_Next** → 将特定B-Tree上的光标移动到B-Tree中的下一个条目，并跳转，如果该B-Tree中没有更多条目，则跳过。'
- en: In other words, the "bytecode" used by SQLite is not so much a set of CPU instructions
    as it is a list of database primitives that are to be run in a particular order.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，SQLite使用的“字节码”更像是一组要按特定顺序运行的数据库原语，而不是一组CPU指令。
- en: 1.3\. Definition Of "Abstract Syntax Tree" or "AST"
  id: totrans-split-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3\. "抽象语法树"或"AST"的定义
- en: An "[Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)"
    or AST is a data structure that describes a program or statement in some kind
    of formal language. In our context, the formal language is SQL. An AST is typically
    implemented as a tree of objects where each object represents one small part of
    the overall SQL statement. ASTs emerge naturally from parsers for formal languages.
    The usual technique is to use an [LALR(1) parser](https://en.wikipedia.org/wiki/LALR_parser).
    With such a parser, each terminal symbol holds metadata that will become a leaf
    of the AST, and each non-terminal symbol holds metadata that will become a sub-branch
    of the overall AST. As rules of the grammar are "reduced" by the parser, new nodes
    of the AST are allocated and connected to subnodes. After the parse completes,
    the start-symbol of the grammar is left holding the root of the AST.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"[抽象语法树](https://en.wikipedia.org/wiki/Abstract_syntax_tree)"或AST是描述某种形式语言中程序或语句的数据结构。在我们的上下文中，形式语言是SQL。AST通常实现为对象树，其中每个对象代表整体SQL语句的一个小部分。AST是形式语言解析器的自然产物。通常的技术是使用[LALR(1)解析器](https://en.wikipedia.org/wiki/LALR_parser)。使用这样的解析器，每个终结符号保存将成为AST叶子的元数据，每个非终结符号保存将成为整体AST子分支的元数据。随着解析器“减少”语法规则，AST的新节点被分配并连接到子节点。解析完成后，语法的起始符号将保留AST的根。'
- en: An AST is a tree of objects. But an AST is not a suitable form for a prepared
    statement. After being generated, an AST first needs to be transformed in various
    ways before it can executed. Symbols need to be resolved. Semantic rules need
    to be checked. Optimizations need to be applied that transform input SQL statement
    into different forms that execute more quickly. Finally, the AST needs to be translated
    into an alternative representation that is more amenable to execution.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: AST是一组对象的树。但AST不是预处理语句的合适形式。生成AST后，首先需要以各种方式对其进行转换，然后才能执行。需要解析符号、检查语义规则，并应用能够将输入SQL语句转换为更快执行的不同形式的优化。最后，AST需要转换为更适合执行的另一种表示形式。
- en: Some people refer to the tree of objects that is used as the executable form
    for MySQL and PostgreSQL as an AST. This is probably a misuse of the term "AST",
    because by the time the tree of objects is ready to be executed, it has been changed
    so much that it has little resemblance to the original SQL text. The confusion
    arises in part because both the final prepared statement object and the original
    AST are both trees of objects. The usual technique is for the original AST that
    comes directly out of the parser to be transformed little by little, in multiple
    passes, until at the end it is fully converted into an tree of objects that is
    no longer strictly an AST but that can be evaluated to generate a result. There
    is not necessarily a clear point during this process when the tree-of-objects
    ceases to be an AST and becomes a prepared statement instead. And because there
    is no clear boundary between an AST and a prepared statement, people often refer
    to a prepared statement that is represented as a tree of objects as an "AST",
    even though that description is not precise.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人将MySQL和PostgreSQL中用作可执行形式的对象树称为AST。这可能是对术语"AST"的误用，因为在准备好执行的对象树被修改多次后，它与原始SQL文本几乎没有相似之处。混淆的部分在于最终的准备好的语句对象和原始AST都是对象树。通常的技术是原始AST直接从解析器中出来后，逐渐进行多次转换，直到最后完全转换为一个对象树，它不再严格是AST，但可以评估生成结果。在此过程中，并没有明确的时刻标明对象树何时不再是AST，而成为一个准备好的语句。因为AST和准备好的语句之间没有明确的边界，所以人们经常将表示为对象树的准备好的语句称为"AST"，即使这种描述并不精确。
- en: 1.4\. Dataflow Programming
  id: totrans-split-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4\. 数据流编程
- en: '[Dataflow programming](https://en.wikipedia.org/wiki/Dataflow_programming)
    is a style of programming in which individual nodes specialize in doing one small
    part of the overall computation. Each node receives inputs from other nodes and
    sends its output to other nodes. Thus the nodes form a directed graph that carry
    inputs into outputs.'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[数据流编程](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BC%96%E7%A8%8B)是一种编程风格，其中各个节点专门负责整体计算中的一个小部分。每个节点从其他节点接收输入并将其输出发送到其他节点。因此，节点形成一个有向图，将输入转换为输出。'
- en: A "dataflow program" is perhaps a better description than "AST" for the tree
    of objects that an SQL database engine uses as a prepared statement.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: '"数据流程序"或许比"AST"更好地描述了SQL数据库引擎作为准备好的语句使用的对象树。'
- en: 2\. Advantages To Compiling Into Bytecode
  id: totrans-split-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 将编译为字节码的优势
- en: 'SQLite compiles to bytecode, and the SQLite developers are very happy with
    this approach. Here is why:'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite编译为字节码，SQLite开发人员对这种方法非常满意。以下是原因：
- en: 2.1\. Bytecode Is Easier To Understand
  id: totrans-split-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. 字节码更易于理解
- en: 'A flat list of opcodes can be easily printed to see exactly how an SQL statement
    is being implemented. This is what happens in SQLite when you preface an SQL statement
    with the "EXPLAIN" keyword: Instead of actually running the SQL, the result is
    a listing of the bytecode that would have been used to implement that SQL.'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列操作码可以轻松打印，以准确查看SQL语句的实现方式。在SQLite中，当您在SQL语句前加上"EXPLAIN"关键字时，就会发生这种情况：不实际运行SQL，而是得到一个显示将用于实现该SQL的字节码列表。
- en: Bytecode lends itself to this because a bytecode program is easily represented
    as a table. In SQLite bytecode, each instruction has one opcode and five operands.
    Thus a prepared statement can be rendered as if it were a query against a six-column
    table.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码很适合这样做，因为字节码程序很容易表示为一张表格。在SQLite的字节码中，每个指令有一个操作码和五个操作数。因此，一个准备好的语句可以被呈现为针对一个六列表的查询。
- en: A tree-of-objects representation is more difficult to publish in a human-readable
    form. The objects that comprise the tree tend to all be very different, and thus
    it is tricky to come up with a consistent and simple table representation with
    which to display the objects. Any such table representation that you do come up
    with would almost certainly have more than six columns, probably many more. The
    problem of rendering a tree-of-objects as a table is sufficiently difficult that
    nobody does it, as far as I know. Hence, no tree-of-objects database engine provides
    the level of detail in their "EXPLAIN" output that SQLite provides.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象树表示为表格形式更难以以人类可读的形式发布。构成对象树的对象往往非常不同，因此很难想出一种一致和简单的表格表示方法来显示这些对象。无论您想出的任何这样的表格表示方法几乎肯定会有超过六列，可能会更多。将对象树渲染为表格的问题足够困难，以至于据我所知没有人这样做。因此，没有对象树数据库引擎提供SQLite提供的"EXPLAIN"输出中的详细级别。
- en: 2.2\. Bytecode Is Easier To Debug
  id: totrans-split-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 字节码更容易调试
- en: Bytecode provides a clear separation between front-end parsing and analysis
    and back-end evaluation of an SQL statement. When problems arise (incorrect answers
    and/or poor performance), the developers can examine the bytecode to quickly determine
    if the source of the trouble is either the front-end analysis or the back-end
    data storage section of the product.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码提供了前端解析和分析与后端评估 SQL 语句之间的清晰分离。当出现问题（答案不正确和/或性能差）时，开发人员可以检查字节码，快速确定问题的根源是产品的前端分析还是后端数据存储部分。
- en: In debugging builds of SQLite, the [PRAGMA vdbe_trace=ON;](pragma.html#pragma_vdbe_trace)
    command will cause a trace of the bytecode execution to appear on the console.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 的调试版本中，执行 [PRAGMA vdbe_trace=ON;](pragma.html#pragma_vdbe_trace) 命令将导致在控制台上显示字节码执行的跟踪信息。
- en: 2.3\. Bytecode Can Be Run Incrementally
  id: totrans-split-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. 字节码可以逐步运行
- en: SQL statements written in bytecode can be evaluated incrementally. For example,
    a statement can be run until it generates just its first row of output. The statement
    then pauses until it is stepped again. It is not necessary to run the statement
    to completion before examining the first row of output.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字节码编写的 SQL 语句可以逐步评估。例如，可以运行语句直到仅生成其第一行输出。然后语句暂停，直到再次步进。在检查第一行输出之前，无需运行语句完成。
- en: This is more difficult to achieve in a tree-of-objects design. When the prepared
    statement is a tree-of-objects, execution is normally accomplished by walking
    the tree. To pause the statement in the middle of a computation means unwinding
    the stack back up to the caller, all the while saving enough state to resume evaluation
    where it last left off. This is not impossible to do, but is sufficiently difficult
    that I have never seen it actually done.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象树设计中，这更难以实现。当准备好的语句是对象树时，执行通常通过遍历树来完成。要在计算过程中暂停语句意味着将堆栈展开回调用者，同时保存足够的状态以便在上次停止的地方恢复评估。这并不是不可能做到的，但足够困难，我从未见过实际完成。
- en: Most SQL database engines do not really need to do incremental execution of
    prepared statements because most SQL database engines are client/server. In client/server
    engines, a single SQL statement is sent to the server, then the complete reply
    comes back over the wire all at once. Thus each statement runs to completion in
    a single go. But SQLite is not client/server. SQLite is a library that runs in
    the same address space and using the same stack as the application. Being able
    to easily and reliably perform incremental execution of an SQL statement is important
    to SQLite.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 SQL 数据库引擎实际上不需要对准备好的语句进行增量执行，因为大多数 SQL 数据库引擎是客户端/服务器模式。在客户端/服务器引擎中，单个 SQL
    语句被发送到服务器，然后完整的回复一次性通过网络返回。因此，每个语句都在一次执行中完成。但 SQLite 不是客户端/服务器。SQLite 是在同一个地址空间和使用同一堆栈的应用程序中运行的库。能够轻松和可靠地执行
    SQL 语句的增量执行对于 SQLite 非常重要。
- en: 2.4\. Bytecode Is Smaller
  id: totrans-split-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4\. 字节码更小
- en: The bytecode generated by SQLite is usually smaller than the corresponding AST
    coming out of the parser. During initial processing of SQL text (during the call
    to [sqlite3_prepare()](c3ref/prepare.html) and similar) both the AST and the bytecode
    exist in memory at the same time, so more memory is used then. But that is a transient
    state. The AST is quickly discarded and its memory recycled, even before the call
    to [sqlite3_prepare()](c3ref/prepare.html) returns, so the resulting [prepared
    statement](c3ref/stmt.html) ends up consuming less memory in its bytecode representation
    than it did as an AST. This is important because calls to [sqlite3_prepare()](c3ref/prepare.html)
    are transient, but prepared statements are often cached for possible reuse and
    persist in memory for a long time.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 生成的字节码通常比解析器输出的相应 AST 小。在 SQL 文本的初始处理过程中（在调用 [sqlite3_prepare()](c3ref/prepare.html)
    和类似函数时），AST 和字节码同时存在于内存中，因此会使用更多内存。但这是短暂的状态。AST 很快被丢弃并回收其内存，甚至在 [sqlite3_prepare()](c3ref/prepare.html)
    返回之前，因此生成的 [prepared statement](c3ref/stmt.html) 以其字节码表示消耗的内存比作为 AST 时少。这很重要，因为对
    [sqlite3_prepare()](c3ref/prepare.html) 的调用是短暂的，但准备好的语句通常会被缓存以便可能的重用，并且在内存中长时间存在。
- en: 2.5\. Bytecode Is Faster
  id: totrans-split-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5\. 字节码更快
- en: I *believe* that a bytecode representation of a prepared statement runs faster,
    because fewer decisions need to be made for each step of the computation. Emphasis
    on "believe" in the previous sentence → it is difficult to verify this claim experimentally
    since nobody has ever put in the multiple years of effort necessary to generate
    equivalent bytecode and tree-of-object representations of a prepared statement
    to see which one actually runs faster. We do know that [SQLite is very fast](fasterthanfs.html),
    but we do not have good side-by-side comparisons with other SQL databases since
    the other databases spend a lot of time doing client/server message processing,
    and it is difficult to untangle the message round-trip overhead from the actual
    processing time.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我*相信*，准备语句的字节码表示运行速度更快，因为每个计算步骤需要做出的决策更少。在上一句中强调“相信” → 实验上很难验证这一说法，因为没有人愿意投入多年的努力来生成等效的字节码和对象树表示的准备语句，以查看到底哪种运行速度更快。我们知道[SQLite
    非常快](fasterthanfs.html)，但是我们没有与其他 SQL 数据库进行过良好的并行比较，因为其他数据库花费大量时间在客户端/服务器消息处理上，很难将消息往返开销与实际处理时间分开。
- en: 3\. Advantages Of Compiling Into A Tree Of Objects
  id: totrans-split-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 将编译为对象树的优势
- en: The SQLite developers think that the bytecode approach is best, at least for
    the use cases the SQLite tries to fill, but the tree-of-objects approach to processing
    SQL does have some advantages over bytecode. There are always tradeoffs.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的开发人员认为字节码方法最佳，至少对于 SQLite 尝试填补的用例来说是如此，但对象树方法在处理 SQL 时确实具有一些优势。总是存在权衡。
- en: 3.1\. Query Planning Decisions Can Be Deferred Until Runtime
  id: totrans-split-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 查询计划决策可以推迟到运行时
- en: When a prepared statement is bytecode, once the bytecode has been generated,
    the algorithm is fixed and cannot be subsequently changed without completely rewriting
    the bytecode. This is not the case with a tree-of-objects prepared statement.
    A tree-of-objects is easier to modify on-the-fly. The query plan is mutable and
    can be tweaked as it is running, based on the progress of the query. Thus a query
    can be dynamically self-tuning.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当准备语句是字节码时，一旦生成了字节码，算法就固定了，不能在完全重写字节码的情况下进行后续更改。而对象树准备语句则不同。对象树易于即时修改。查询计划是可变的，并且可以根据查询的进展进行调整。因此，查询可以动态自我调整。
- en: 3.2\. Dataflow Programs Are Easy To Parallelize
  id: totrans-split-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. 数据流程序易于并行化
- en: 'In a dataflow program, each processing node can be assigned to a different
    thread. There needs to be some kind of threadsafe queuing mechanism for transferring
    intermediate results from one node to the next. But no synchronization primitives
    are typically needed within each node of the program. Node schedule is trivial:
    A node becomes eligible to run when it has data available and there is space in
    its output queue.'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据流程序中，每个处理节点可以分配给不同的线程。需要某种线程安全的队列机制来传输从一个节点到下一个节点的中间结果。但通常在程序的每个节点内部不需要同步原语。节点调度是简单的：当节点有可用数据并且其输出队列有空间时，节点就有资格运行。
- en: This is an important consideration for database engines that are designed to
    run large analytic queries ([OLAP](https://en.wikipedia.org/wiki/Online_analytical_processing))
    on large multi-core servers. The primary focus of SQLite is transaction processing
    ([OLTP](https://en.wikipedia.org/wiki/Online_transaction_processing)) on the internet-of-things,
    so there is less need to represent prepared statements as dataflow programs in
    SQLite.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设计用于在大型多核服务器上运行大型分析查询（[OLAP](https://en.wikipedia.org/wiki/Online_analytical_processing)）的数据库引擎，这是一个重要考虑因素。SQLite
    的主要重点是在物联网上进行事务处理（[OLTP](https://en.wikipedia.org/wiki/Online_transaction_processing)），因此在
    SQLite 中不需要将准备语句表示为数据流程序。
