- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 15:04:44'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 15:04:44'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: MMU-less systems and FDPIC | MaskRay
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[无 MMU 系统和 FDPIC | MaskRay](https://maskray.me/blog/2024-02-20-mmu-less-systems-and-fdpic)'
- en: 来源：[https://maskray.me/blog/2024-02-20-mmu-less-systems-and-fdpic](https://maskray.me/blog/2024-02-20-mmu-less-systems-and-fdpic)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://maskray.me/blog/2024-02-20-mmu-less-systems-and-fdpic](https://maskray.me/blog/2024-02-20-mmu-less-systems-and-fdpic)
- en: This article describes ABI and toolchain considerations about systems without
    a Memory Management Unit (MMU). We will focus on FDPIC and the in-development
    FDPIC ABI for RISC-V, with updates as I delve deeper into the topic.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本文描述了没有内存管理单元（MMU）系统的 ABI 和工具链考虑因素。我们将重点讨论 FDPIC 和在开发中的 RISC-V FDPIC ABI，随着对这一主题的深入研究进行更新。
- en: Embedded systems often lack MMUs, relying on real-time operating systems (RTOS)
    like VxWorks or special Linux configurations (`CONFIG_MMU=n`). In these systems,
    the offset between the text and data segments is often not knwon at compile time.
    Therefore, a dedicated register is typically set to somewhere in the data segment
    and writable data is accessed relative to this register.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统通常缺乏 MMU，依赖于实时操作系统（RTOS）如 VxWorks 或特殊的 Linux 配置 (`CONFIG_MMU=n`)。在这些系统中，文本段和数据段之间的偏移量通常在编译时不可知。因此，通常会将专用寄存器设置到数据段的某个位置，并且可写数据相对于该寄存器访问。
- en: Why is the offset not knwon at compile time? There are primarily two reasons.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在编译时不知道偏移量？主要有两个原因。
- en: First, eXecute in Place (XIP), where code resides in ROM while the data segment
    is copied to RAM. Therefore, the offset between the text and data segments is
    often not knwon at compile time.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，eXecute in Place (XIP) 指的是代码存放在 ROM 中，数据段复制到 RAM 中。因此，在编译时通常不知道文本段和数据段之间的偏移量。
- en: Second, all processes share the same address space without MMU. However, it
    is still desired for these processes to share text segments. Therefore needs a
    mechanism for code to find its corresponding data.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，所有进程在没有 MMU 的情况下共享相同的地址空间。但仍希望这些进程共享文本段。因此需要一种机制，让代码找到其相应的数据。
- en: '## Compiler support for unknown text-data segment offset'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: '## 编译器支持未知文本数据段偏移'
- en: '`-msep-data`'
  id: totrans-split-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`-msep-data`'
- en: GCC's m68k port [added `-msep-data`](https://gcc.gnu.org/pipermail/gcc-patches/2003-September/113699.html)
    in 2003-10.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 的 m68k 版本 [添加了 `-msep-data`](https://gcc.gnu.org/pipermail/gcc-patches/2003-September/113699.html)
    在 2003-10。
- en: Add -msep-data and -mid-shared-library support for uClinux. These are two special
    PIC variants that allow executing linux applications in ROM filesystems without
    loading an additional copy in memory (XIP).
  id: totrans-split-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为 uClinux 添加 -msep-data 和 -mid-shared-library 支持。这两个特殊的 PIC 变体允许在 ROM 文件系统中执行
    Linux 应用程序，而无需在内存中加载额外的副本（XIP）。
- en: With -msep-data, references to global data are made through register A5 which
    is loaded with a pointer to the start of the data/bss segment allocated in RAM.
  id: totrans-split-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 -msep-data，全局数据的引用通过寄存器 A5 进行，该寄存器加载一个指向 RAM 中分配的数据/bss 段起始地址的指针。
- en: The -mid-shared-library option allows using a special shared library flavour
    that allows allocationg a distinct data/bss section for each process without the
    need to relocate code in both library and application.
  id: totrans-split-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -mid-shared-library 选项允许使用特殊的共享库版本，为每个进程分配一个独立的数据/bss 段，而无需在库和应用程序中重新定位代码。
- en: '`-msep-data` is PIC only and updates `-fno-pic` to `-fPIE`. In this mode, a5
    is read-only and holds the address of `_GLOBAL_OFFSET_TABLE_`. When not used with
    `-mid-shared-library`, `-fPIC -msep-data` is unnecessary. Just stick with `-fPIE
    -msep-data`.'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`-msep-data` 只适用于 PIC，并将 `-fno-pic` 更新为 `-fPIE`。在此模式下，a5 是只读的，保存 `_GLOBAL_OFFSET_TABLE_`
    的地址。如果不与 `-mid-shared-library` 一起使用，`-fPIC -msep-data` 是不必要的。只需使用 `-fPIE -msep-data`。'
- en: '`-mid-shared-library`'
  id: totrans-split-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`-mid-shared-library`'
- en: '[This option](https://gcc.gnu.org/onlinedocs/gcc/M680x0-Options.html#:~:text=mid)
    was added to GCC''s m68k port along with `-msep-data`. The documentation says:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[此选项](https://gcc.gnu.org/onlinedocs/gcc/M680x0-Options.html#:~:text=mid) 在
    GCC 的 m68k 版本中与 `-msep-data` 一起添加。文档中写道：'
- en: Generate code that supports shared libraries via the library ID method. This
    allows for execute-in-place and shared libraries in an environment without virtual
    memory management. This option implies -fPIC.
  id: totrans-split-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成支持通过库 ID 方法的共享库的代码。这允许在没有虚拟内存管理的环境中进行执行和共享库。此选项隐含了 -fPIC。
- en: '`-mid-shared-library` is PIC only and updates `-fno-pic` to `-fPIE`. You compile
    a source file with `-mid-shared-library -mshared-library-id=n`, and the functions
    will be attached to library ID n. At function entry a5 points to an array that
    maps a library ID to the corresponding GOT base address. The compiler generates
    `move.l -(n+1)*4(%a5),%a5` to obtain the actual GOT base address. The a5 will
    then be used to access the corresponding data segment.'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`-mid-shared-library` 仅适用于PIC，并将 `-fno-pic` 更新为 `-fPIE`。使用 `-mid-shared-library
    -mshared-library-id=n` 编译源文件，函数将附加到库ID n。函数入口时，a5 指向一个数组，该数组将库ID映射到相应的GOT基地址。编译器生成
    `move.l -(n+1)*4(%a5),%a5` 来获取实际的GOT基地址。然后使用a5来访问相应的数据段。'
- en: '`gcc/config/bfin` added `-msep-data` in 2006.'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc/config/bfin` 在2006年添加了 `-msep-data`。'
- en: '`-mno-pic-data-is-text-relative`'
  id: totrans-split-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`-mno-pic-data-is-text-relative`'
- en: 'This ARM option is similar to `-msep-data` and only makes sense with `-fpie`/`-fpic`.
    In 2013, `-mno-pic-data-is-text-relative`, generalized from the ARM [VxWorks RTP](https://gcc.gnu.org/pipermail/gcc-patches/2007-May/217111.html)
    port, was [added](https://inbox.sourceware.org/gcc-patches/000001cedf74%24bd1bf710%243753e530%24@arm.com/)
    to assume that text and data segments don''t have a fixed displacement. On non-VxWorks-RTP
    targets, `-mno-pic-data-is-text-relative` implies [`-msingle-pic-base`](https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html#index-msingle-pic-base):'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ARM选项类似于 `-msep-data` ，仅在 `-fpie`/`-fpic` 时才有意义。在2013年，从ARM [VxWorks RTP](https://gcc.gnu.org/pipermail/gcc-patches/2007-May/217111.html)
    移植中概括出来的 `-mno-pic-data-is-text-relative` 被 [添加](https://inbox.sourceware.org/gcc-patches/000001cedf74%24bd1bf710%243753e530%24@arm.com/)
    ，假设文本段和数据段没有固定的位移。对于非VxWorks-RTP目标，`-mno-pic-data-is-text-relative` 暗示 [`-msingle-pic-base`](https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html#index-msingle-pic-base)
    ：
- en: Treat the register used for PIC addressing as read-only, rather than loading
    it in the prologue for each function. The runtime system is responsible for initializing
    this register with an appropriate value before execution begins.
  id: totrans-split-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将用于PIC寻址的寄存器视为只读，而不是在每个函数的序言中加载它。运行时系统负责在执行开始前使用适当的值初始化此寄存器。
- en: r9 is used as the static base (`arm_pic_register`) in the position-independent
    data model to access the data segment. Since r9 is not changed, dynamic linking
    seems unsupported as a DSO needs a different data segment.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置无关数据模型中，r9 被用作静态基地址 (`arm_pic_register`) ，用于访问数据段。由于r9不会改变，动态链接似乎不支持，因为DSO需要不同的数据段。
- en: GCC's s390x port added `-mno-pic-data-is-text-relative` in 2017 [for kpatch](https://github.com/dynup/kpatch/commit/10002f5aa671de2878252aaa48f585457d39638a)
    (live kernel patching).
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: GCC的s390x端口在2017年为kpatch [添加了 `-mno-pic-data-is-text-relative`](https://github.com/dynup/kpatch/commit/10002f5aa671de2878252aaa48f585457d39638a)
    （动态内核修补）。
- en: '`-fropi` and `-frwpi`'
  id: totrans-split-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`-fropi` 和 `-frwpi`'
- en: Clang ARM's `-fropi` and `-frwpi` are special `-fno-pic` variants that only
    intended for static linking. While regular `-fno-pic` assumes absolute addressing
    for both code data, `-fropi` and `-frwpi` add a twist by enforcing relative addressing
    based on specific assumptions about relocation. Both options consider the text-data
    segment offset unknown at compile time.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: Clang ARM 的 `-fropi` 和 `-frwpi` 是特殊的 `-fno-pic` 变体，仅用于静态链接。而常规的 `-fno-pic` 假定代码数据均使用绝对寻址，`-fropi`
    和 `-frwpi` 通过根据特定的重定位假设强制执行相对寻址，为此增加了一些变化。这两个选项考虑了编译时未知的文本-数据段偏移量。
- en: '`-fropi` assumes code and read-only data will be relocated at runtime, making
    absolute addressing unsuitable. Instead, PC-relative addressing is used. The `.ARM.attributes`
    section contains `Tag_ABI_PCS_RO_data: 1` like `-fpic`.'
  id: totrans-split-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fropi` 假定代码和只读数据将在运行时重新定位，因此绝对寻址不适用。而是使用PC相对寻址。`.ARM.attributes` 部分包含 `Tag_ABI_PCS_RO_data:
    1` ，类似 `-fpic`。'
- en: '`-frwpi` assumes writable data will be relocated at runtime, making absolute
    addressing unsuitable. Instead, writable data is accessed relative to the static
    base register. The `.ARM.attributes` section contains `Tag_ABI_PCS_RW_data: 2`.'
  id: totrans-split-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-frwpi` 假定可写数据将在运行时重新定位，因此绝对寻址不适用。而是相对于静态基址寄存器访问可写数据。`.ARM.attributes` 部分包含
    `Tag_ABI_PCS_RW_data: 2` 。'
- en: You can use `-fropi` and `-frwpi` together to require relative addressing for
    both code and data. Compared with `-fno-pic -frwpi`, `-fno-pic -fropi -frwpi`
    needs one more instruction to retrieve a function address.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以同时使用 `-fropi` 和 `-frwpi` 来要求代码和数据的相对寻址。与 `-fno-pic -frwpi` 相比，`-fno-pic -fropi
    -frwpi` 需要额外的一条指令来检索函数地址。
- en: In terms of semantics, I think `-fno-pic -fropic -frwpic` is identical to `-fpie
    -mno-pic-data-is-text-relative` with hidden visibility declarations. In practice,
    GCC `-fpie -mno-pic-data-is-text-relative` utilizes GOT-relative relocations (`R_ARM_GOT_BREL`),
    not MOVW/MOVT instructions.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，我认为 `-fno-pic -fropic -frwpic` 和 `-fpie -mno-pic-data-is-text-relative`
    在使用隐藏可见性声明时是相同的。在实践中，GCC `-fpie -mno-pic-data-is-text-relative` 使用GOT相对重定位（`R_ARM_GOT_BREL`），而不是MOVW/MOVT指令。
- en: '`-mfdpic`'
  id: totrans-split-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`-mfdpic`'
- en: We will discuss this in detal later.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将详细讨论此问题。
- en: Compiler option summary
  id: totrans-split-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器选项总结
- en: '`-msep-data` and `-mno-pic-data-is-text-relative` are the same, relying on
    `-fpie/-fpic` semantics to enforce relative addressing for the text segment. `-fropi`
    and `-frwpi` offer finer control. You can choose to use relative addressing for
    text segment only (`-fropi`), data segment only (using `-frwpi`), or both.'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`-msep-data` 和 `-mno-pic-data-is-text-relative` 是相同的，依赖于 `-fpie/-fpic` 语义来强制文本段的相对寻址。`-fropi`
    和 `-frwpi` 提供更精细的控制。您可以选择仅对文本段使用相对寻址（`-fropi`），仅对数据段使用（使用 `-frwpi`），或同时使用两者。'
- en: Neither `-msep-data` nor `-fropi -frwpi` supports shared libraries. `-msep-data`'s
    variant `-mid-shared-library` provides a library ID based shared library, which
    works for some cases but is inflexible.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`-msep-data` 和 `-fropi -frwpi` 都不支持共享库。`-msep-data` 的变种 `-mid-shared-library`
    提供了基于库ID的共享库，适用于某些情况，但不灵活。'
- en: '* * *'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Now, let's review OS support. While I'm not an RTOS expert, let's explore Linux's
    executable file loaders and see how they handle MMU-less scenarios.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾操作系统的支持。虽然我不是RTOS专家，让我们探讨Linux的可执行文件加载器，并查看它们如何处理没有MMU的情况。
- en: Linux binfmt loaders
  id: totrans-split-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux二进制格式加载器
- en: '`fs/Kconfig.binfmt` defines a few loaders.'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs/Kconfig.binfmt` 定义了一些加载器。'
- en: '`BINFMT_ELF` defaults to y and depends on `MMU`.'
  id: totrans-split-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BINFMT_ELF` 默认为y，并依赖于 `MMU`。'
- en: '`BINFMT_ELF_FDPIC` defaults to y when `BINFMT_ELF` is not selected. A few architecture
    support `BINFMT_ELF_FDPIC` for NOMMU. ARM supports FDPIC even with a MMU.'
  id: totrans-split-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BINFMT_ELF_FDPIC` 在未选择 `BINFMT_ELF` 时默认为y。一些架构支持 `BINFMT_ELF_FDPIC` 用于NOMMU。即使带有MMU，ARM也支持FDPIC。'
- en: '`BINFMT_FLAT` is provided for a few architectures.'
  id: totrans-split-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BINFMT_FLAT` 为几种架构提供支持。'
- en: Therefore, both `BINFMT_ELF_FDPIC` and `BINFMT_FLAT` can be used for MMU-less
    systems. `BINFMT_FLAT` is a very old solution that does not allow dynamic linking
    while `BINFMT_ELF_FDPIC` supports dynamic linking.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`BINFMT_ELF_FDPIC` 和 `BINFMT_FLAT` 可用于没有MMU的系统。`BINFMT_FLAT` 是一个非常古老的解决方案，不允许动态链接，而
    `BINFMT_ELF_FDPIC` 支持动态链接。
- en: BTW, `BINFMT_AOUT`, removed in 2022, had been supported for alpha/arm/x86-32.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`BINFMT_AOUT` 在2022年被移除，曾支持alpha/arm/x86-32。
- en: Binary flat format
  id: totrans-split-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制平面格式
- en: 'Linux''s `BINFMT_FLAT` refers to an object file format used by [μClinux](https://en.wikipedia.org/wiki/%CE%9CClinux):
    Binary Flat format (BFLT). [https://myembeddeddev.blogspot.com/2010/02/uclinux-flat-file-format.html](https://myembeddeddev.blogspot.com/2010/02/uclinux-flat-file-format.html)
    has an introduction. BFLT is an executable file only format, not used for relocatable
    files. An executable file is typically converted from ELF using [elf2flt](https://github.com/uclinux-dev/elf2flt).
    `ld-elf2flt` is a ld wrapper that invokes `elf2flt` when the option `-elf2flt`
    is seen.'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的 `BINFMT_FLAT` 是指由[μClinux](https://en.wikipedia.org/wiki/%CE%9CClinux)使用的对象文件格式：Binary
    Flat format (BFLT)。[https://myembeddeddev.blogspot.com/2010/02/uclinux-flat-file-format.html](https://myembeddeddev.blogspot.com/2010/02/uclinux-flat-file-format.html)
    有一个介绍。BFLT仅用于可执行文件格式，不用于可重定位文件。可执行文件通常使用 [elf2flt](https://github.com/uclinux-dev/elf2flt)
    从ELF转换。`ld-elf2flt` 是一个ld包装器，当看到选项 `-elf2flt` 时调用 `elf2flt`。
- en: Linux's `BINFMT_FLAT` supports both version 2 (`OLD_FLAT_VERSION`) and version
    4\. Version 4 supports eXecute in Place (XIP), where code resides in ROM while
    the data segment is copied to RAM. Therefore, the offset between the text and
    data segments is often not knwon at compile time.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的 `BINFMT_FLAT` 支持版本2 (`OLD_FLAT_VERSION`) 和版本4。版本4支持在ROM中执行（XIP），其中代码驻留在ROM中，而数据段被复制到RAM中。因此，文本段和数据段之间的偏移通常在编译时未知。
- en: Greg added [ID-based shared library support](https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=3d97dc2d349e6630bced9ced2ca7d0c7b52e49bc)
    to be used with [`-mid-shared-library`](#mid-shared-library) in 2003, which was
    [removed](https://git.kernel.org/linus/70578ff3367dd4ad8f212a9b5c05cffadabf39a8)
    in April 2022\. The code supported one executable and at most 3 shared libraries.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: Greg在2003年为 [`-mid-shared-library`](#mid-shared-library) 添加了[基于ID的共享库支持](https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=3d97dc2d349e6630bced9ced2ca7d0c7b52e49bc)，这在2022年4月被[移除](https://git.kernel.org/linus/70578ff3367dd4ad8f212a9b5c05cffadabf39a8)。该代码支持一个可执行文件和最多3个共享库。
- en: 'The tooling for shared library support seems to be called eXtended FLAT (XFLAT).
    It is a limited shared library scheme that disallows global variable sharing.
    Quoting [XFLAT FAQ](https://xflat.sourceforge.net/XFlatFAQ.html):'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用于共享库支持的工具似乎称为eXtended FLAT（XFLAT）。这是一种限制的共享库方案，不允许全局变量共享。引用[XFLAT FAQ](https://xflat.sourceforge.net/XFlatFAQ.html)：
- en: XFLAT provides an alternative mechanism to bind and relocate functions using
    a thunk layer that is inserted between each inter-module function call. However,
    without a GOT it is not possible to bind and relocate data. In short, with no
    GOT XFLAT cannot support sharing of global variables between program and shared
    library modules.
  id: totrans-split-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XFLAT提供了一种替代机制，用于通过插入在每个模块间函数调用之间的Thunk层来绑定和重定位函数。然而，没有GOT，无法绑定和重定位数据。简而言之，没有GOT，XFLAT无法支持程序和共享库模块之间的全局变量共享。
- en: FDPIC
  id: totrans-split-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FDPIC
- en: FDPIC can be seen as an extended `-mno-pic-data-is-text-relative` mode that
    utilizes function descriptors to support PIC register changes for dynamic linking.
    A FDPIC executable can be loaded using either the regular Linux ELF loader for
    MMU systems or `fs/binfmt_elf_fdpic.c` for MMU-less systems. `fs/binfmt_elf_fdpic.c`
    has been [available](https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=be3e0ada7b264efa8714b1ff6203c2c29fcc61c5)
    since 2002\. It supports both MMU and NOMMU configurations but does not support
    `ET_EXEC` executables in NOMMU mode. Each architecture that supports FDPIC defines
    an `EI_OSABI` value to be checked by the loader.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: FDPIC可以看作是一种扩展的`-mno-pic-data-is-text-relative`模式，它利用函数描述符支持动态链接的PIC寄存器更改。FDPIC可执行文件可以使用常规的Linux
    ELF加载器加载到MMU系统或使用`fs/binfmt_elf_fdpic.c`加载到无MMU系统中。自2002年以来，`fs/binfmt_elf_fdpic.c`一直[可用](https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=be3e0ada7b264efa8714b1ff6203c2c29fcc61c5)。它支持MMU和NOMMU配置，但不支持NOMMU模式下的`ET_EXEC`可执行文件。支持FDPIC的每个架构都定义了一个要由加载器检查的`EI_OSABI`值。
- en: Several architectures define a FDPIC ABI.
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 几种架构定义了FDPIC ABI。
- en: Here is a summary.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个摘要。
- en: The read-only sections, which can be shared, are commonly referred to as the
    "text segment", whereas the writable sections are non-shared and commonly referred
    to as the "data segment". Functions and certain data symbols (`.rodata`) reside
    in the text segment, while other data symbols and the GOT reside in the data segment.
    Special entries called "canonical function descriptors" also reside in the GOT.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以共享的只读段通常称为“文本段”，而可写段是非共享的，通常称为“数据段”。函数和某些数据符号（`.rodata`）驻留在文本段中，而其他数据符号和GOT驻留在数据段中。特殊条目称为“规范函数描述符”也驻留在GOT中。
- en: A call-clobbered register is reserved as the FDPIC register, used to access
    the data segment. Upon entry to a function, the FDPIC register holds the address
    of `_GLOBAL_OFFSET_TABLE_`. The text segment can be referenced using PC-relative
    addressing. The data segment including GOT is referenced using indirect FDPIC-register-relative
    addressing. We will see later that sometimes it's unknown whether a non-preemptible
    symbol resides in the text segment or the data segment, in which case GOT-indirect
    addressing with the FDPIC register has to be used.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被调用破坏的寄存器作为FDPIC寄存器保留，用于访问数据段。进入函数时，FDPIC寄存器保存了`_GLOBAL_OFFSET_TABLE_`的地址。文本段可以使用PC相对寻址引用。包括GOT在内的数据段使用间接FDPIC寄存器相对寻址引用。稍后我们将看到，有时不确定一个不可抢占符号驻留在文本段还是数据段，此时必须使用带有FDPIC寄存器的GOT间接寻址。
- en: A function call is called external if the destination may reside in another
    module, which has a different data segment and therefore needs a different FDPIC
    register value. Therefore, an external function call needs to update the FDPIC
    register as well as changing the program counter (PC). The FDPIC register can
    be spilled into a stack slot or a call-saved register, if the caller needs to
    reference the data segment later. The FDPIC register is call-clobbered to [allow
    external tail calls](/blog/2021-09-19-all-about-procedure-linkage-table#got-setup-is-expensive-without-pc-relative-addressing)
    and avoid PLT saving the register.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用称为外部调用，如果目标可能驻留在另一个模块中，该模块具有不同的数据段，因此需要不同的FDPIC寄存器值。因此，外部函数调用需要更新FDPIC寄存器以及改变程序计数器（PC）。如果调用者需要稍后引用数据段，则FDPIC寄存器可以溢出到堆栈插槽或调用保存的寄存器。FDPIC寄存器被调用破坏，以[允许外部尾调用](/blog/2021-09-19-all-about-procedure-linkage-table#got-setup-is-expensive-without-pc-relative-addressing)，并避免PLT保存该寄存器。
- en: Calling a function pointer, including calling a PLT entry, also sets both the
    FDPIC register and PC. When the address of a function is taken, the address of
    its canonical function descriptor is obtained, not that of the entry point. The
    descriptor, resides in the GOT, contains pointers to both the function's entry
    point and its FDPIC register value. The two GOT entries are relocated by a dynamic
    relocation of type `R_*_FUNCDESC_VALUE` (e.g. [`R_FRV_FUNCDESC_VALUE`](https://www.fsfla.org/~lxoliva/writeups/FR-V/FDPIC-ABI.txt#:~:text=The%20R_FRV_FUNCDESC_VALUE%20relocation%20is%20used%20to)).
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数指针，包括调用PLT条目，也会设置FDPIC寄存器和PC。当获取函数的地址时，获取的是它的规范函数描述符的地址，而不是入口点的地址。描述符位于GOT中，包含指向函数入口点和其FDPIC寄存器值的指针。这两个GOT条目通过类型为`R_*_FUNCDESC_VALUE`（例如[`R_FRV_FUNCDESC_VALUE`](https://www.fsfla.org/~lxoliva/writeups/FR-V/FDPIC-ABI.txt#:~:text=The%20R_FRV_FUNCDESC_VALUE%20relocation%20is%20used%20to)）的动态重定位进行重新定位。
- en: If the symbol is preemptible, the code sequence loads a GOT entry. When the
    symbol is a function, the GOT entry is relocated by a dynamic relocation `R_*_FUNCDESC`
    and will contain the address of the function descriptor address.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果符号可抢占，代码序列会加载一个GOT条目。当符号是一个函数时，GOT条目会被动态重定位`R_*_FUNCDESC`重新定位，并将包含函数描述符地址。
- en: Let's checkout examples taking addresses of functions and variables.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下获取函数和变量地址的示例。
- en: '|'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-split-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-split-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Function access in FDPIC
  id: totrans-split-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在FDPIC中的函数访问
- en: Canonical function descriptors are stored in the GOT, and their access depends
    on whether the referenced function is preemptible or not.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 规范函数描述符存储在GOT中，它们的访问取决于引用的函数是否可抢占。
- en: 'For non-preemptible functions: the address of the descriptor is directly computed
    by adding an offset to the FDPIC register.'
  id: totrans-split-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不可抢占的函数：描述符的地址通过将偏移添加到FDPIC寄存器直接计算而得。
- en: 'For preemptible functions: a GOT entry is loaded first. This entry, relocated
    by a `R_*_FUNCDESC` dynamic relocation, holds the final address of the function
    descriptor.'
  id: totrans-split-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可抢占的函数：首先加载一个GOT条目。这个条目通过`R_*_FUNCDESC`动态重定位进行重新定位，保存函数描述符的最终地址。
- en: '|'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-split-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Unfortunately, when linking a DSO, an `R_ARM_GOTOFFFUNCDESC` relocation referencing
    a hidden symbol results in a linker error. This error likely arises because the
    generated `R_ARM_FUNCDESC_VALUE` dynamic relocation requires a dynamic symbol.
    While this can be implemented using an `STB_LOCAL STT_SECTION` dynamic symbol,
    GNU ld currently lacks support for this approach.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，在链接DSO时，引用隐藏符号的`R_ARM_GOTOFFFUNCDESC`重定位会导致链接器错误。这个错误可能是由于生成的`R_ARM_FUNCDESC_VALUE`动态重定位需要一个动态符号引起的。虽然可以使用`STB_LOCAL
    STT_SECTION`动态符号来实现这一点，但GNU ld目前不支持这种方法。
- en: '|'
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-split-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-split-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Let's try sh4. `sh4-linux-gnu-gcc -fpic -mfdpic -O2 q.c -shared -nostdlib` allows
    taking the address of a hidden function but not a protected function (my [pending
    fix](https://sourceware.org/pipermail/binutils/2024-February/132519.html)).
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试sh4。`sh4-linux-gnu-gcc -fpic -mfdpic -O2 q.c -shared -nostdlib`允许获取隐藏函数的地址，但不允许获取受保护函数的地址（我的[pending
    fix](https://sourceware.org/pipermail/binutils/2024-February/132519.html)）。
- en: Then, let's see a global variable initialized by the address of a function and
    a C++ virtual table.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们看看由函数地址和C++虚表初始化的全局变量。
- en: '|'
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-split-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-split-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-split-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-split-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'TODO: `-fexperimental-relative-c++-abi-vtables`'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: TODO：`-fexperimental-relative-c++-abi-vtables`
- en: Data access in FDPIC
  id: totrans-split-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在FDPIC中的数据访问
- en: 'GOT-indirect addressing is required for accessing data symbols under two conditions:'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下需要使用GOT间接寻址来访问数据符号：
- en: 'Preemptible symbols: Traditional GOT requirement.'
  id: totrans-split-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可抢占符号：传统的GOT需求。
- en: 'Non-preemptible symbols with potential data segment placement: This includes'
  id: totrans-split-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有潜在数据段放置的不可抢占符号：这包括
- en: 'Writable data symbols: This covers both locally declared (`int var;`) and externally
    declared (`extern int var;`) non-const variables.'
  id: totrans-split-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可写数据符号：这涵盖了本地声明的（`int var;`）和外部声明的（`extern int var;`）非const变量。
- en: 'Potential dynamic initialization: `const A a; extern const int var;`'
  id: totrans-split-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 潜在的动态初始化：`const A a; extern const int var;`
- en: 'Certain guaranteed constant initialization: `extern constinit const int *const
    extern_const;`. Constant initialization may require a relocation, e.g. `constinit
    const int *const extern_const = &var;`'
  id: totrans-split-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些保证的常量初始化：`extern constinit const int *const extern_const;`。常量初始化可能需要进行重定位，例如`constinit
    const int *const extern_const = &var;`
- en: '|'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-split-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-split-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The dynamic relocations `R_*_RELATIVE` and `R_*_GLOB_DAT` do not use the standard
    `+ load_base` semantics. It seems that musl fdpic doesn't support the special
    `R_*_RELATIVE`.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: 动态重定位`R_*_RELATIVE`和`R_*_GLOB_DAT`未使用标准的`+ load_base`语义。看起来musl fdpic不支持特殊的`R_*_RELATIVE`。
- en: 'If the referenced data symbol is non-preemptible and guaranteed to be in the
    text segment, we can use PC-relative addressing. However, this scenario is remarkably
    rare in practice. The most likely use case is like the following:'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引用的数据符号是非可抢占的，并且保证在文本段中，我们可以使用基于 PC 的地址。 然而，在实践中，这种情况非常罕见。 最可能的用例如下：
- en: '|'
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-split-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-split-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'GCC''s arm port does not seem to utilize PC-relative addressing. We can try
    GCC''s SuperH port:'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 的 ARM 端口似乎没有使用基于 PC 的地址。 我们可以尝试 GCC 的 SuperH 端口：
- en: '|'
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-split-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-split-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: It optimizes `addr_hidden_var` but not `addr_ro_hidden_var`.
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它优化了 `addr_hidden_var`，但没有优化 `addr_ro_hidden_var`。
- en: Thread-local storage in FDPIC
  id: totrans-split-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FDPIC 中的线程本地存储
- en: '*ARM FDPIC ABI* defines static TLS relocations `R_ARM_TLS_GD32_FDPIC, R_ARM_TLS_LDM32_FDPIC,
    R_ARM_TLS_IE32_FDPIC` to be relative to GOT, as opposed to their non-FDPIC counterpart
    relative to PC.'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*ARM FDPIC ABI* 定义了静态 TLS 重定位 `R_ARM_TLS_GD32_FDPIC, R_ARM_TLS_LDM32_FDPIC,
    R_ARM_TLS_IE32_FDPIC` 相对于 GOT，与其非-FDPIC 对应物相对于 PC 不同。'
- en: PLT in FDPIC
  id: totrans-split-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FDPIC 中的 PLT
- en: The PLT entry needs to update the FDPIC register as well as changing the program
    counter (PC). binutils' arm port uses the following code sequence.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: PLT 条目需要更新 FDPIC 寄存器以及更改程序计数器（PC）。 binutils 的 ARM 端口使用以下代码序列。
- en: '|'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-split-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-split-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Lazy binding could be implemented, but it is difficult if the architecture does
    not allow atomic updates of two words. binutils' arm port just disable lazy binding.
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果架构不允许两个字的原子更新，懒绑定就很难实现。 binutils 的 ARM 端口只是禁用了懒绑定。
- en: Let's inspect an example involving consecutive function calls.
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个涉及连续函数调用的例子。
- en: '|'
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-split-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-split-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-split-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-split-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'If GCC implements `-fno-plt`, it can use the following code sequence:'
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 GCC 实现了 `-fno-plt`，可以使用以下代码序列：
- en: '|'
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-split-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-split-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Relative relocations and `.rofixup` section
  id: totrans-split-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对重定位和 `.rofixup` 部分
- en: 'Unlike standard `R_*_RELATIVE` relocations that use "*loc += load_base" semantics,
    the load address in FDPIC mode is dependent on the containing segment. The following
    code adapted fro musl demonstrates the behavior:'
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不像标准的`R_*_RELATIVE`重定位那样使用"*loc += load_base"语义，FDPIC 模式中的加载地址取决于包含段的情况。 下面从musl改编的代码展示了这种行为：
- en: '|'
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-split-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-split-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In `-pie` and `-shared` links, a dynamic section is present, and non-preemptible
    function and data pointers are relocated by `R_*_FUNCDESC_VALUE` and `R_*_RELATIVE`
    dynamic relocations. For `-no-pie` links, the situation varies:'
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `-pie` 和 `-shared` 链接中，存在动态部分，并且非可抢占函数和数据指针通过 `R_*_FUNCDESC_VALUE` 和 `R_*_RELATIVE`
    动态重定位进行重定位。 对于 `-no-pie` 链接，情况各异：
- en: 'Dynamic links: A dynamic section is present. We can still use dynamic relocations.'
  id: totrans-split-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态链接：存在动态部分。 我们仍然可以使用动态重定位。
- en: 'Static links: There is no dynamic section. In the non-FDPIC, there is even
    no relocation (other than `R_*_IRELATIVE`, unsupported in musl/uclibc-ng).'
  id: totrans-split-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态链接：没有动态部分。 在非-FDPIC 中，甚至没有重定位（除了 musl/uclibc-ng 不支持的 `R_*_IRELATIVE`）。
- en: 'FDPIC executables of type `ET_EXEC` present a unique challenge: while the text
    segment has a fixed address, the data segment has an unknown address at link time
    and require relocations. To address this, a linker-created section named `.rofixup`
    was introduced in the first FDPIC ABI (FR-V), and later adopted by other FDPIC
    ABIs.'
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`ET_EXEC` 类型的 FDPIC 可执行文件面临独特的挑战：虽然文本段有固定地址，但数据段在链接时具有未知地址并且需要重定位。 为解决此问题，链接器创建了一个名为
    `.rofixup` 的部分，在第一个 FDPIC ABI（FR-V）中引入，后来被其他 FDPIC ABI 接受。'
- en: '`.rofixup` holds non-preemptible function and data pointers, which have `R_*_RELATIVE`
    semantics. The last entry of `.rofixup` is special and holds the address of `_GLOBAL_OFFSET_TABLE_`.
    In a `-pie` or `-shared` link, `.rofixup` has only one entry. `__ROFIXUP_LIST__`
    and `__ROFIXUP_END__` are defined as encapsulation symbols of `.rofixup`.'
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`.rofixup` 拥有非可抢占函数和数据指针，具有 `R_*_RELATIVE` 语义。 `.rofixup` 的最后一个条目是特殊的，并保存了
    `_GLOBAL_OFFSET_TABLE_` 的地址。 在 `-pie` 或 `-shared` 链接中，`.rofixup` 只有一个条目。 `__ROFIXUP_LIST__`
    和 `__ROFIXUP_END__` 被定义为 `.rofixup` 的封装符号。'
- en: At run time, the loader sets the FDPIC register to the relocated `_GLOBAL_OFFSET_TABLE_`
    value before traferring control to the entry point of the executable.
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，加载器将 FDPIC 寄存器设置为重新定位后的 `_GLOBAL_OFFSET_TABLE_` 值，然后将控制传递到可执行文件的入口点。
- en: 'Here is an example:'
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '|'
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-split-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-split-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Reflections on FDPIC
  id: totrans-split-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FDPIC 的反思
- en: 'FDPIC can be seen as:'
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
  zh: FDPIC 可以被视为：
- en: An extended `-msep-data`/`-mno-pic-data-is-text-relative` mode that utilizes
    function descriptors to support PIC register changes for dynamic linking.
  id: totrans-split-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种扩展的 `-msep-data`/`-mno-pic-data-is-text-relative` 模式利用函数描述符来支持动态链接的 PIC 寄存器更改。
- en: A fixed [PPC64 ELFv1 function descriptors ABI](/blog/2023-02-26-linker-notes-on-power-isa#ppc64-elfv1-function-descriptors).
    However, PPC64 ELFv1's trick of `st_value` referring to the function descriptor
    is better than the existing FDPIC ABIs (sh, arm).
  id: totrans-split-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定的[PPC64 ELFv1函数描述符ABI](/blog/2023-02-26-linker-notes-on-power-isa#ppc64-elfv1-function-descriptors)。但是，PPC64
    ELFv1中`st_value`引用函数描述符的技巧优于现有的FDPIC ABI（sh、arm）。
- en: FDPIC resembles PPC64 ELFv2 TOC where the FDPIC register is set by the caller
    instead of the callee, avoiding global/local entry and tail call complexity.
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
  zh: FDPIC类似于PPC64 ELFv2 TOC，其中FDPIC寄存器由调用者而不是被调用者设置，避免了全局/局部入口和尾调用复杂性。
- en: '`-fno-pic -mfdpic` with hidden visibility declarations can replace `-fno-pic
    -fropi -frwpi`, though clobbered r9 across function calls has slight overhead.'
  id: totrans-split-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fno-pic -mfdpic`与隐藏可见性声明可以替代`-fno-pic -fropi -frwpi`，尽管跨函数调用时破坏的r9有轻微的开销。'
- en: '`-fPIE -mfdpic` with hidden visibility declarations can replace `-fPIE -msep-data`,
    though setting the call-clobbered FDPIC register has slight overhead.'
  id: totrans-split-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fPIE -mfdpic`与隐藏可见性声明可以替代`-fPIE -msep-data`，尽管设置调用时破坏的FDPIC寄存器有轻微的开销。'
- en: '`-mfdpic` often generates smaller code than `-mno-fdpic` on architectures where
    PC-relative addressing is expensive. This includes:'
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`-mfdpic`在PC相对寻址昂贵的体系结构上通常生成比`-mno-fdpic`更小的代码。这包括：'
- en: 'sh4: Lacks PC-relative addressing entirely.'
  id: totrans-split-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sh4：完全缺乏PC相对寻址。
- en: 'arm: Needs `LDR` with `.word _GLOBAL_OFFSET_TABLE_-(.LPIC0+4)`, which is expensive.'
  id: totrans-split-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: arm：需要使用带有`.word _GLOBAL_OFFSET_TABLE_ - (.LPIC0 + 4)`的`LDR`，这是昂贵的。
- en: Since FDPIC works effectively even on systems with MMUs, it raises the intriguing
    possibility of replacing the standard calling ABI entirely.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于FDPIC甚至在具有MMU系统上也能有效工作，因此可能完全替代标准调用ABI的想法显得非常有趣。
- en: '`-mfdpic` enables FDPIC code generation. GCC''sh port got [FDPIC support](https://gcc.gnu.org/git/gitweb.cgi?p=gcc.git;h=1e44e857e05c165f6f01aeb56a7a43ee765bfc99)
    in 2015\. `-mfpic` implies `-fPIE`, so `-fno-pic -mfdpic` and `-fPIE -mfdpic`
    have the same codegen behavior. `-fPIC -mfdpic` may have different generated code
    as it additionally sets `flag_shlib`.'
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`-mfdpic`启用了FDPIC代码生成。GCC的sh端口在2015年获得了[FDPIC支持](https://gcc.gnu.org/git/gitweb.cgi?p=gcc.git;h=1e44e857e05c165f6f01aeb56a7a43ee765bfc99)。`-mfpic`意味着`-fPIE`，因此`-fno-pic
    -mfdpic`和`-fPIE -mfdpic`具有相同的代码生成行为。`-fPIC -mfdpic`可能有不同的生成代码，因为它额外设置了`flag_shlib`。'
- en: The cfgexpand pass calls `sh_get_fdpic_reg_initial_val` to retrieve the FDPIC
    register value from a pseudo register, and register the pseudo register for the
    first invocation. At the start of the ira (Integrated Register Allocator) pass,
    `allocate_initial_values` initializes the pseudo register to the hard register
    r12 at the function entry point. sh is the only port that defines `TARGET_ALLOCATE_INITIAL_VALUE`.
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: cfgexpand pass调用`sh_get_fdpic_reg_initial_val`从伪寄存器中检索FDPIC寄存器值，并将伪寄存器注册为第一次调用时的硬寄存器r12。在ira（集成寄存器分配器）pass开始时，`allocate_initial_values`将伪寄存器初始化为函数入口点的硬寄存器r12。sh是唯一定义`TARGET_ALLOCATE_INITIAL_VALUE`的端口。
- en: In GCC's arm port, `-fno-pic -mfdpic` generated code does not work.
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCC的ARM端口中，`-fno-pic -mfdpic`生成的代码无法工作。
- en: In addition, external function calls save and restore r9.
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，外部函数调用会保存和恢复r9。
- en: 'gas''s arm port needs `--fdpic` to assemble FDPIC-related relocation types.
    GCC configured with a `arm*-*-uclinuxfdpiceabi` target utilizes `arm/uclinuxfdpiceabi.h`
    and transforms `-mfdpic` to `--fdpic` when assembling a file. For other targets,
    `-Wa,--fdpic` is needed to assemble the output. [[PATCH] arm: Support -mfdpic
    for more targets](https://gcc.gnu.org/pipermail/gcc-patches/2024-February/646436.html)
    will make `-Wa,--fdpic` unneeded.'
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: 'gas的ARM端口需要`--fdpic`来组装与FDPIC相关的重定位类型。使用配置为`arm*-*-uclinuxfdpiceabi`目标的GCC利用`arm/uclinuxfdpiceabi.h`，在组装文件时将`-mfdpic`转换为`--fdpic`。对于其他目标，需要`-Wa,--fdpic`来组装输出。[[PATCH]
    arm: Support -mfdpic for more targets](https://gcc.gnu.org/pipermail/gcc-patches/2024-February/646436.html)将使`-Wa,--fdpic`不再需要。'
- en: '`-mfdpic -mtls-dialect=gnu2` is not supported. The ARM FDPIC ABI uses `ldr`
    to load a 32-bit constant embedded in the text segment. The offset is used to
    materialize the address of a GOT entry (canonical function descriptor, address
    of the canonical function descriptor, or address of data).'
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`-mfdpic -mtls-dialect=gnu2`不受支持。ARM FDPIC ABI使用`ldr`来加载嵌入在文本段中的32位常量。偏移量用于实现GOT条目（规范函数描述符、规范函数描述符的地址或数据的地址）的地址。'
- en: You can configure binutils with `--target=arm-unknown-uclinuxfdpiceabi` to get
    a BFD linker that supports FDPIC emulations.
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--target=arm-unknown-uclinuxfdpiceabi`配置binutils以获取支持FDPIC仿真的BFD链接器。
- en: '|'
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-split-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-split-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: GNU ld' arm port fails on `R_ARM_GOTOFFFUNCDESC` referencing a hidden function
    symbol ([PR31408](https://sourceware.org/bugzilla/show_bug.cgi?id=31408)).
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
  zh: GNU ld的ARM端在引用隐藏函数符号时失败（[PR31408](https://sourceware.org/bugzilla/show_bug.cgi?id=31408)）。
- en: '|'
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-split-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-split-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-split-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In `-no-pie` mode, certain non-function references that require a `.rofixup`
    entrie leads to a segfault ([PR31407](https://sourceware.org/bugzilla/show_bug.cgi?id=31407)).
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`-no-pie`模式下，某些需要`.rofixup`条目的非函数引用会导致段错误（[PR31407](https://sourceware.org/bugzilla/show_bug.cgi?id=31407)）。
- en: Global/weak non-hidden symbols referenced by `R_ARM_FUNCDESC` are unnecessarily
    exported ([PR31409](https://sourceware.org/bugzilla/show_bug.cgi?id=31407)).
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由`R_ARM_FUNCDESC`引用的全局/弱非隐藏符号被不必要地导出（[PR31409](https://sourceware.org/bugzilla/show_bug.cgi?id=31407)）。
- en: RISC-V FDPIC
  id: totrans-split-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RISC-V FDPIC
- en: Several proposals exist for defining FDPIC-like ABIs to work for MMU-less systems.
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几个提议用于定义类似于FDPIC的ABI以在没有MMU的系统上工作。
- en: Undoubtly, GP should be used as the FDPIC register.
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，GP应作为FDPIC寄存器使用。
- en: 'Loading a constant near code (like ARM) is not efficient. Instead, consider
    a two-instruction sequence:'
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将常量加载到代码附近（类似于ARM）并不高效。相反，考虑使用两条指令的序列：
- en: Use hi20 and lo12 instructions to generate an offset relative to the GP register.
  id: totrans-split-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用hi20和lo12指令生成相对于GP寄存器的偏移量。
- en: Use `c.add a0, gp` to compute the address of the GOT entry.
  id: totrans-split-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`c.add a0, gp`来计算GOT条目的地址。
- en: Maciej's code sequence supports both function and data access through indirect
    GP-relative addressing. We can easily enhance it by adding `R_RISCV_RELAX` to
    enable linker relaxation and improve performance. Additionally, for consistency
    with similar notations on x86-64 and AArch64 ("gotpcrel"), let's adopt "gotgprel"
    notation.
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
  zh: 马杰克的代码序列支持通过间接GP相对寻址访问函数和数据。我们可以通过添加`R_RISCV_RELAX`来增强它，以启用链接器放松并提高性能。此外，为了与x86-64和AArch64上类似的标记保持一致（"gotpcrel"），让我们采用"gotgprel"标记。
- en: '|'
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-split-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-split-209
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-split-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'For data access, the code sequence is followed by instructions like:'
  id: totrans-split-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据访问，代码序列后跟随类似以下的指令：
- en: 'Function descriptors and data have different semantics, requiring two relocation
    types. Stefan O''Rear proposes:'
  id: totrans-split-213
  prefs: []
  type: TYPE_NORMAL
  zh: 函数描述符和数据具有不同的语义，需要两种重定位类型。斯蒂芬·奥里尔建议：
- en: '`R_RISCV_FUNCDESC_GOTGPREL_HI`: Find or create two GOT entries for the canonical
    function descriptor.'
  id: totrans-split-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R_RISCV_FUNCDESC_GOTGPREL_HI`：为规范函数描述符找到或创建两个GOT条目。'
- en: '`R_RISCV_GOTGPREL_HI`: For or create a GOT for the symbol, and return an offset
    from the FDPIC register.'
  id: totrans-split-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R_RISCV_GOTGPREL_HI`：为符号找到或创建一个GOT，并返回相对于FDPIC寄存器的偏移量。'
- en: Drawing inspiration from ARM FDPIC, two additional relocation types are needed
    for TLS. This results in a 4-type scheme.
  id: totrans-split-216
  prefs: []
  type: TYPE_NORMAL
  zh: 借鉴ARM FDPIC，需要两种额外的重定位类型用于TLS。这导致了一个4种类型的方案。
- en: 'RISC-V FDPIC: optimization'
  id: totrans-split-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RISC-V FDPIC：优化
- en: 'Addressing performance concerns is crucial. Stefan suggests an "indirect-to-relative
    optimization and relaxation scheme":'
  id: totrans-split-218
  prefs: []
  type: TYPE_NORMAL
  zh: 处理性能问题至关重要。斯蒂芬建议采用“间接到相对优化和放松方案”：
- en: '`R_RISCV_PIC_ADD`: Tags `c.add rX, gp` to enable optimization'
  id: totrans-split-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R_RISCV_PIC_ADD`：标记`c.add rX, gp`以启用优化'
- en: '`R_RISCV_INTERMEDIATE_LOAD`: Tags `ld rY, <gotgprel_lo12>(rX)` to enable optimization'
  id: totrans-split-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R_RISCV_INTERMEDIATE_LOAD`：标记`ld rY, <gotgprel_lo12>(rX)`以启用优化'
- en: 'Indirect GP-relative addressing can be optimized to direct GP-relative addressing
    under specific conditions:'
  id: totrans-split-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定条件下，间接GP相对寻址可以优化为直接GP相对寻址：
- en: Non-preemptible functions
  id: totrans-split-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非可抢占函数
- en: Non-preemptible data in the data segment
  id: totrans-split-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据段中的非可抢占数据
- en: '|'
  id: totrans-split-224
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-split-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-split-226
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-split-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: GOT-indirect addressing can be optimized to PC-relative for non-preemptible
    data in the text segment.
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
  zh: GOT间接寻址可以针对文本段中的非可抢占数据进行PC相对寻址优化。
- en: '|'
  id: totrans-split-230
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-split-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-split-232
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-split-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-split-234
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: GOT-indirect addressing can be optimized to absolute addressing for non-preemptible
    data in the text segment.
  id: totrans-split-235
  prefs: []
  type: TYPE_NORMAL
  zh: GOT间接寻址可以针对文本段中的非可抢占数据进行优化为绝对寻址。
- en: '|'
  id: totrans-split-236
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-split-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-split-238
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-split-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-split-240
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This can be used for `SHN_ABS` and unresolved undefined weak symbols. With `-no-pie`
    linking, regular symbols are elligible for this optimization as well. However,
    linkers may choose not to implement this since the added complexity might outweigh
    the benefits.
  id: totrans-split-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于`SHN_ABS`和未解析的未定义弱符号。在`-no-pie`链接时，常规符号也有资格进行此优化。然而，链接器可能选择不实现这一点，因为增加的复杂性可能超过了好处。
- en: 'RISC-V FDPIC: thread-local storage'
  id: totrans-split-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RISC-V FDPIC：线程本地存储
- en: 'To handle TLSDESC, we introduce a new relocation type: `R_RISCV_TLSDESC_GPREL_HI`.
    This type instructs the linker to find or create two GOT entries unless optimized
    to local-exec or init-exec. The combined hi20 and lo12 offsets compute the GP-relative
    offset to the first GOT entry.'
  id: totrans-split-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理TLSDESC，我们引入了一个新的重定位类型：`R_RISCV_TLSDESC_GPREL_HI`。这种类型指示链接器查找或创建两个GOT条目，除非优化为本地执行或初始执行。组合的hi20和lo12偏移量计算到第一个GOT条目的GP相对偏移量。
- en: '|'
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE40]'
  id: totrans-split-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-split-246
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-split-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-split-248
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Existing relocation types, `R_RISCV_TLSDESC_LOAD_LO12` and `R_RISCV_TLSDESC_ADD_LO12`,
    are extended to work with `R_RISCV_TLSDESC_GPREL_HI`.
  id: totrans-split-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的重定位类型，`R_RISCV_TLSDESC_LOAD_LO12`和`R_RISCV_TLSDESC_ADD_LO12`，被扩展以适用于`R_RISCV_TLSDESC_GPREL_HI`。
- en: '|'
  id: totrans-split-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-split-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|'
  id: totrans-split-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-split-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-split-254
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'For initial-exec TLS model, we need a new pseudoinstruction, say, `la.tls.ie.fd
    rX, sym`. It expands to:'
  id: totrans-split-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初始执行TLS模型，我们需要一个新的伪指令，比如`la.tls.ie.fd rX, sym`。它扩展为：
- en: '|'
  id: totrans-split-256
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE44]'
  id: totrans-split-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|'
  id: totrans-split-258
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE45]'
  id: totrans-split-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|'
  id: totrans-split-260
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Stefan's scheme defines `R_RISCV_PIC_LO12_I` as an alias for `R_RISCV_PCREL_LO12_I`.
    Since the symbol is GP-relative instead of PC-relative, avoiding `PCREL` in the
    relocation type name makes sense.
  id: totrans-split-261
  prefs: []
  type: TYPE_NORMAL
  zh: 斯蒂凡的方案将`R_RISCV_PIC_LO12_I`定义为`R_RISCV_PCREL_LO12_I`的别名。由于符号是相对于GP而不是PC的，避免在重定位类型名称中使用`PCREL`是合理的。
- en: Stefan's 11-type scheme adds `R_RISCV_PIC_ADDR_LO12_I` to be associated with
    `ld rX, 0(rX)` instead. I have not yet figured out the reasoning.
  id: totrans-split-262
  prefs: []
  type: TYPE_NORMAL
  zh: 斯蒂凡的11种方案将`R_RISCV_PIC_ADDR_LO12_I`与`ld rX, 0(rX)`关联起来。我还没有弄清楚其理由。
- en: 'RISC-V FDPIC: `-fno-plt`'
  id: totrans-split-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RISC-V FDPIC：`-fno-plt`
- en: Regular [`-fno-plt`](/blog/2021-09-19-all-about-procedure-linkage-table#fno-plt)
    code loads the `.got.plt` entry using PC-relative addressing and performs an indirect
    branch. The FDPIC `-fno-plt` variant needs to load both the FDPIC register and
    the destination address.
  id: totrans-split-264
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的[`-fno-plt`](/blog/2021-09-19-all-about-procedure-linkage-table#fno-plt)代码使用PC相对寻址加载`.got.plt`条目，并执行间接跳转。
    FDPIC `-fno-plt`变体需要加载FDPIC寄存器和目标地址。
- en: '|'
  id: totrans-split-265
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE46]'
  id: totrans-split-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|'
  id: totrans-split-267
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE47]'
  id: totrans-split-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|'
  id: totrans-split-269
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: libc implementations with FDPIC support
  id: totrans-split-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: libc实现支持FDPIC。
- en: uclibc-ng supports AArch32, Blackfin, and FR-V.
  id: totrans-split-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uclibc-ng支持AArch32、Blackfin和FR-V。
- en: musl supports SuperH.
  id: totrans-split-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: musl支持SuperH。
