- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 14:39:07'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:39:07'
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: metahead | the world's 1st enterprise-grade metarepo
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: metahead | 世界上第一个企业级元仓库
- en: 来源：[https://www.metahead.dev/](https://www.metahead.dev/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://www.metahead.dev/](https://www.metahead.dev/)
- en: If you’re using git submodules, metahead can enable big improvements to your
    workflow. The usual loop with submodules is to make a commit in a submodule, then
    to update the repos containing the submodule. By replacing submodules with metahead,
    you can make the code truly part of all the repos using the module, and a commit
    to the module repository will be seamlessly synchronized to all the users of this
    module. With one PR, update all the repos which use this code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 git 子模块，metahead 可以极大改善你的工作流程。通常使用子模块的循环是在子模块中进行提交，然后更新包含子模块的存储库。通过用
    metahead 替换子模块，你可以将代码真正成为使用该模块的所有存储库的一部分，并且对模块存储库的提交将无缝同步到使用此模块的所有用户。通过一个 PR，更新使用此代码的所有存储库。
