- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»åˆ«ï¼šæœªåˆ†ç±»
- en: 'date: 2024-05-27 14:36:01'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024å¹´05æœˆ27æ—¥14:36:01
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Trade-offs between Different CRDTs
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä¸åŒCRDTä¹‹é—´çš„æƒè¡¡
- en: æ¥æºï¼š[https://interjectedfuture.com/trade-offs-between-different-crdts/](https://interjectedfuture.com/trade-offs-between-different-crdts/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://interjectedfuture.com/trade-offs-between-different-crdts/](https://interjectedfuture.com/trade-offs-between-different-crdts/)
- en: What are the trade-offs between different kinds of CRDTs (Conflict-free Replicated
    Data Types)? Most introductory talks cover just state-based and operations-based
    CRDTs because that's what the original paper formulated. But since then, there
    have been other variations, and I haven't seen much written about them in blog
    posts, so I'll cover their trade-offs here.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸åŒç±»å‹çš„CRDTä¹‹é—´æœ‰ä»€ä¹ˆæƒè¡¡ï¼Ÿå¤§éƒ¨åˆ†çš„åˆçº§è®²åº§åªæ¶µç›–äº†åŸºäºçŠ¶æ€å’ŒåŸºäºæ“ä½œçš„CRDTï¼Œå› ä¸ºé‚£æ˜¯åŸå§‹è®ºæ–‡åˆ¶å®šçš„å†…å®¹ã€‚ä½†è‡ªé‚£æ—¶ä»¥æ¥ï¼Œå·²ç»å‡ºç°äº†å…¶ä»–å˜ç§ï¼Œæˆ‘åœ¨åšå®¢æ–‡ç« ä¸­ä¹Ÿæ²¡çœ‹åˆ°æœ‰å¤ªå¤šå…³äºå®ƒä»¬çš„å†™ä½œï¼Œæ‰€ä»¥æˆ‘ä¼šåœ¨è¿™é‡Œæ¶µç›–å®ƒä»¬çš„æƒè¡¡ã€‚
- en: The basics of [CRDTs](https://crdt.tech/) are covered in a lot of other different
    places [^1], so I won't try to speed run it here. Let's just jump into the differences.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[CRDTs](https://crdt.tech/)çš„åŸºç¡€çŸ¥è¯†åœ¨è®¸å¤šå…¶ä»–ä¸åŒçš„åœ°æ–¹è¢«æ¶µç›–[^1]ï¼Œæ‰€ä»¥æˆ‘ä¸ä¼šåœ¨è¿™é‡Œå°è¯•åŠ é€Ÿä»‹ç»ã€‚è®©æˆ‘ä»¬ç›´æ¥è°ˆè®ºå®ƒä»¬çš„å·®å¼‚ã€‚'
- en: State-based CRDTs (Convergent CRDTs)
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åŸºäºçŠ¶æ€çš„CRDTï¼ˆæ”¶æ•›CRDTï¼‰
- en: In State-based CRDTs, a replica's state can be updated by a merge operation
    with another replica's state. But if the [network is unreliable and can deliver
    events out of order](https://architecturenotes.co/fallacies-of-distributed-systems/),
    how would all the replicas achieve convergence and agreement of all their states?
    The trick is simply to restrict ourselves to data structures and operations that
    are immune to net-splits and out-of-order delivery.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åŸºäºçŠ¶æ€çš„CRDTä¸­ï¼Œä¸€ä¸ªå‰¯æœ¬çš„çŠ¶æ€å¯ä»¥é€šè¿‡ä¸å¦ä¸€ä¸ªå‰¯æœ¬çš„çŠ¶æ€è¿›è¡Œåˆå¹¶æ“ä½œæ¥æ›´æ–°ã€‚ä½†æ˜¯ï¼Œå¦‚æœ[ç½‘ç»œä¸å¯é å¹¶ä¸”å¯ä»¥æ— åºäº¤ä»˜äº‹ä»¶](https://architecturenotes.co/fallacies-of-distributed-systems/)ï¼Œé‚£ä¹ˆæ‰€æœ‰å‰¯æœ¬å¦‚ä½•å®ç°æ”¶æ•›å’Œè¾¾æˆå®ƒä»¬æ‰€æœ‰çŠ¶æ€çš„ä¸€è‡´ï¼Ÿè¯€çªå°±æ˜¯ç®€å•åœ°é™åˆ¶è‡ªå·±ä½¿ç”¨å¯¹ç½‘ç»œåˆ†è£‚å’Œæ— åºäº¤ä»˜å…ç–«çš„æ•°æ®ç»“æ„å’Œæ“ä½œã€‚
- en: First, the internal data structure of the CRDT must be monotonically increasing.
    Second, the merge operation has to be commutative, associative, and idempotent
    with respect to the internal data structures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼ŒCRDTçš„å†…éƒ¨æ•°æ®ç»“æ„å¿…é¡»æ˜¯å•è°ƒé€’å¢çš„ã€‚å…¶æ¬¡ï¼Œåˆå¹¶æ“ä½œå¿…é¡»å¯¹å†…éƒ¨æ•°æ®ç»“æ„å…·æœ‰äº¤æ¢å¾‹ã€ç»“åˆå¾‹å’Œå¹‚ç­‰æ€§ã€‚
- en: These constraints make the CRDT immune to the unreliable network. As long as
    all replicas eventually see every state update event, they're guaranteed to converge
    to the same state. Due to the use of vector clocks, replicas coming in and out
    of the network are easily handled. The internal bookkeeping grows linearly with
    the number of replicas.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›çº¦æŸä½¿å¾—CRDTå¯¹ä¸å¯é çš„ç½‘ç»œå…·æœ‰å…ç–«æ€§ã€‚åªè¦æ‰€æœ‰çš„å‰¯æœ¬æœ€ç»ˆçœ‹åˆ°æ¯ä¸ªçŠ¶æ€æ›´æ–°äº‹ä»¶ï¼Œå®ƒä»¬å°±èƒ½ä¿è¯æ”¶æ•›åˆ°ç›¸åŒçš„çŠ¶æ€ã€‚ç”±äºä½¿ç”¨å‘é‡æ—¶é’Ÿï¼Œå‰¯æœ¬è¿›å‡ºç½‘ç»œéƒ½å¾ˆå®¹æ˜“å¤„ç†ã€‚å†…éƒ¨ç°¿è®°éšç€å‰¯æœ¬æ•°é‡çš„å¢åŠ è€Œçº¿æ€§å¢é•¿ã€‚
- en: The rest of the design problem is how to build useful data structures out of
    only monotonically increasing elements. Luckily, there is already a [menagerie
    of CRDTs](https://github.com/pfrazee/crdt_notes/tree/68c5fe81ade109446a9f4c24e03290ec5493031f#portfolio-of-basic-crdts)
    that can model numbers, arrays, maps, strings, and other common data structures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾è®¡é—®é¢˜çš„å‰©ä½™éƒ¨åˆ†æ˜¯å¦‚ä½•æ„å»ºæœ‰ç”¨çš„æ•°æ®ç»“æ„ï¼Œåªåˆ©ç”¨å•è°ƒé€’å¢çš„å…ƒç´ ã€‚å¹¸è¿çš„æ˜¯ï¼Œå·²ç»æœ‰ä¸€ç³»åˆ—çš„CRDTå¯ä»¥æ¨¡æ‹Ÿæ•°å­—ã€æ•°ç»„ã€æ˜ å°„ã€å­—ç¬¦ä¸²å’Œå…¶ä»–å¸¸è§çš„æ•°æ®ç»“æ„ã€‚
- en: 'State-based CRDTs are theoretically sound, but in practice, it has a glaring
    downside: they require sending the entire state of a replica over the network
    to other replicas. This can be prohibitive for all but the smallest states like
    counters and registers. That''s because a CRDT needs to maintain internal bookkeeping
    of "which replica said what" at some logical time in order to resolve conflicts
    for any new state changes. The end-user queries this internal bookkeeping for
    a current value, like a functional view calculated from the actual state, the
    internal bookkeeping. For anything beyond a counter or register, this internal
    bookkeeping can be too big for sets and maps. And as the number of replicas grows,
    it can grow too big too quickly.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºçŠ¶æ€çš„CRDTåœ¨ç†è®ºä¸Šæ˜¯åˆç†çš„ï¼Œä½†åœ¨å®è·µä¸­æœ‰ä¸€ä¸ªæ˜¾è‘—çš„ç¼ºç‚¹ï¼šä»–ä»¬éœ€è¦å°†ä¸€ä¸ªå‰¯æœ¬çš„æ•´ä¸ªçŠ¶æ€å‘é€åˆ°å…¶ä»–å‰¯æœ¬çš„ç½‘ç»œä¸Šã€‚è¿™å¯¹é™¤äº†æœ€å°çŠ¶æ€ï¼ˆå¦‚è®¡æ•°å™¨å’Œå¯„å­˜å™¨ï¼‰ä»¥å¤–çš„æ‰€æœ‰æƒ…å†µæ¥è¯´éƒ½æ˜¯ç¦æ­¢çš„ã€‚å› ä¸ºCRDTéœ€è¦åœ¨æŸä¸ªé€»è¾‘æ—¶é—´ç‚¹ä¸Šç»´æŠ¤â€œå“ªä¸ªå‰¯æœ¬è¯´äº†ä»€ä¹ˆâ€çš„å†…éƒ¨ç°¿è®°ï¼Œä»¥ä¾¿è§£å†³ä»»ä½•æ–°çŠ¶æ€å˜åŒ–çš„å†²çªã€‚æœ€ç»ˆç”¨æˆ·æŸ¥è¯¢è¿™ä¸ªå†…éƒ¨ç°¿è®°ä»¥è·å–å½“å‰å€¼ï¼Œæ¯”å¦‚ä»å®é™…çŠ¶æ€ã€å†…éƒ¨ç°¿è®°è®¡ç®—çš„åŠŸèƒ½è§†å›¾ã€‚å¯¹äºé™¤äº†è®¡æ•°å™¨æˆ–å¯„å­˜å™¨ä¹‹å¤–çš„ä»»ä½•æƒ…å†µï¼Œè¿™ä¸ªå†…éƒ¨ç°¿è®°å¯¹äºé›†åˆå’Œæ˜ å°„æ¥è¯´å¯èƒ½ä¼šå¤ªå¤§ã€‚éšç€å‰¯æœ¬æ•°é‡çš„å¢åŠ ï¼Œå®ƒå¯èƒ½ä¼šå˜å¾—å¤ªå¤§ï¼Œå¤ªå¿«ã€‚
- en: Therefore, most current CRDT implementations are not state-based but op-based.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå¤§å¤šæ•°å½“å‰çš„CRDTå®ç°ä¸æ˜¯åŸºäºçŠ¶æ€çš„ï¼Œè€Œæ˜¯åŸºäºæ“ä½œçš„ã€‚
- en: ğŸ’¡
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡
- en: '- Uses merge function to converge'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '- ä½¿ç”¨åˆå¹¶å‡½æ•°è¿›è¡Œæ”¶æ•›'
- en: '- Merge function needs to be commutative, associative, and idempotent'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '- åˆå¹¶å‡½æ•°éœ€è¦æ˜¯å¯äº¤æ¢çš„ã€å¯ç»“åˆçš„å’Œå¹‚ç­‰çš„'
- en: '- Internal data structure needs to be monotonically increasing'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '- å†…éƒ¨æ•°æ®ç»“æ„éœ€è¦å•è°ƒå¢åŠ '
- en: ğŸ‘
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ‘
- en: '- Easy syncing protocol that just broadcasts new state to other replicas'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '- ç®€å•çš„åŒæ­¥åè®®åªéœ€å‘å…¶ä»–å‰¯æœ¬å¹¿æ’­æ–°çŠ¶æ€'
- en: '- Does not need to keep a history to sync (as we''ll see later)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '- ä¸éœ€è¦ä¿ç•™å†å²è®°å½•è¿›è¡ŒåŒæ­¥ï¼ˆç¨åæˆ‘ä»¬ä¼šçœ‹åˆ°ï¼‰'
- en: ğŸ‘
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ‘
- en: '- Sending the entire state over the wire is impractical for all but the simplest
    CRDTs'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '- å°†æ•´ä¸ªçŠ¶æ€é€šè¿‡ç½‘ç»œä¼ è¾“å¯¹äºé™¤äº†æœ€ç®€å•çš„CRDTsä¹‹å¤–çš„æ‰€æœ‰CRDTsæ¥è¯´éƒ½æ˜¯ä¸åˆ‡å®é™…çš„'
- en: '- Internal data structure grows linearly with the number of replicas'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '- å†…éƒ¨æ•°æ®ç»“æ„éšå‰¯æœ¬æ•°é‡å‘ˆçº¿æ€§å¢é•¿'
- en: '- Harder to accommodate replicas that come in and out of the network'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '- éš¾ä»¥å®¹çº³è¿›å‡ºç½‘ç»œçš„å‰¯æœ¬'
- en: Operation-based CRDTs (Commutative CRDTs)
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åŸºäºæ“ä½œçš„CRDTï¼ˆå¯äº¤æ¢CRDTï¼‰
- en: Current practical implementations of CRDTs opt for a way to ship smaller pieces
    of data over the wire while retaining the same properties as a state-based CRDT.
    We will give up a merge function and instead use a defined set of operations that
    can be used on the state. It's akin to defining [a command in an effect system](https://guide.elm-lang.org/effects/).
    Like before, the operations will need to be constrained to give us the property
    of uncoordinated syncing between replicas. The operations will need to be both
    commutative and associative, but unlike the merge function, they do not have to
    be idempotent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å‰CRDTçš„å®é™…å®ç°é€‰æ‹©äº†ä¸€ç§åœ¨ä¿ç•™çŠ¶æ€CRDTçš„åŒæ—¶é€šè¿‡ç½‘ç»œä¼ è¾“æ›´å°æ•°æ®å—çš„æ–¹å¼ã€‚æˆ‘ä»¬æ”¾å¼ƒåˆå¹¶å‡½æ•°ï¼Œè€Œæ˜¯ä½¿ç”¨ä¸€ç»„å¯ç”¨äºçŠ¶æ€çš„å®šä¹‰æ“ä½œã€‚è¿™ç±»ä¼¼äºåœ¨[æ•ˆæœç³»ç»Ÿä¸­å®šä¹‰å‘½ä»¤](https://guide.elm-lang.org/effects/)ã€‚ä¸ä»¥å‰ä¸€æ ·ï¼Œè¿™äº›æ“ä½œéœ€è¦å—åˆ°é™åˆ¶ï¼Œä»¥ä¾¿åœ¨å‰¯æœ¬ä¹‹é—´æ»¡è¶³ä¸åè°ƒçš„åŒæ­¥å±æ€§ã€‚è¿™äº›æ“ä½œå¿…é¡»æ—¢å¯äº¤æ¢åˆå¯ç»“åˆï¼Œä½†ä¸åˆå¹¶å‡½æ•°ä¸åŒï¼Œå®ƒä»¬ä¸å¿…æ˜¯å¹‚ç­‰çš„ã€‚
- en: Without idempotency, the syncing protocol now cannot just be an out-of-order
    delivery of updates like in state-based CRDTs. Instead, we require the operations
    to be delivered in causal order. When a replica syncs and catches up to the latest
    state, the operations are applied in causal order. Any concurrent operations will
    result in the same state, due to the commutative and associative properties of
    the operations. We're shifting part of the complexity of the merge function into
    the sync protocol.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ²¡æœ‰å¹‚ç­‰æ€§ï¼Œé‚£ä¹ˆåŒæ­¥åè®®å°±ä¸èƒ½å†åƒçŠ¶æ€CRDTsä¸­é‚£æ ·ä»…ä»…æ˜¯æ— åºä¼ é€’æ›´æ–°äº†ã€‚ç›¸åï¼Œæˆ‘ä»¬éœ€è¦ä»¥å› æœé¡ºåºä¼ é€’æ“ä½œã€‚å½“å‰¯æœ¬è¿›è¡ŒåŒæ­¥å¹¶èµ¶ä¸Šæœ€æ–°çŠ¶æ€æ—¶ï¼Œæ“ä½œå°†æŒ‰å› æœé¡ºåºåº”ç”¨ã€‚ä»»ä½•å¹¶å‘æ“ä½œéƒ½ä¼šå› ä¸ºæ“ä½œçš„å¯äº¤æ¢å’Œå¯ç»“åˆå±æ€§è€Œå¯¼è‡´ç›¸åŒçŠ¶æ€ã€‚æˆ‘ä»¬å°†éƒ¨åˆ†åˆå¹¶å‡½æ•°çš„å¤æ‚æ€§è½¬ç§»åˆ°åŒæ­¥åè®®ä¸­ã€‚
- en: Our internal bookkeeping to converge to the same state with concurrent operations
    doesn't use vector clocks. Instead, we can keep a log of the causal history of
    all the operations that occurred. Our internal bookkeeping no longer grows with
    the number of replicas, but instead with the number of events.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç”¨äºåœ¨å¹¶å‘æ“ä½œä¸‹æ”¶æ•›åˆ°ç›¸åŒçŠ¶æ€çš„å†…éƒ¨è®°è´¦ä¸ä½¿ç”¨å‘é‡æ—¶é’Ÿã€‚ç›¸åï¼Œæˆ‘ä»¬å¯ä»¥ä¿ç•™å‘ç”Ÿçš„æ‰€æœ‰æ“ä½œçš„å› æœå†å²è®°å½•ã€‚æˆ‘ä»¬çš„å†…éƒ¨è®°è´¦ä¸å†éšå‰¯æœ¬æ•°é‡å¢é•¿ï¼Œè€Œæ˜¯éšäº‹ä»¶æ•°é‡å¢é•¿ã€‚
- en: Op-based CRDTs can scale easily with the number of replicas and with an unknown
    number of replicas that come in and out of the network easily. However, like blockchains,
    it has an ever-growing internal bookkeeping if it wants to allow any replica to
    sync regardless of how long it has been offline.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºæ“ä½œçš„CRDTå¯ä»¥è½»æ¾åœ°éšç€å‰¯æœ¬æ•°é‡å’Œè¿›å‡ºç½‘ç»œçš„å‰¯æœ¬æ•°é‡è¿›è¡Œæ‰©å±•ã€‚ç„¶è€Œï¼Œå°±åƒåŒºå—é“¾ä¸€æ ·ï¼Œå¦‚æœè¦å…è®¸ä»»ä½•å‰¯æœ¬è¿›è¡ŒåŒæ­¥è€Œä¸ç®¡å®ƒç¦»çº¿å¤šä¹…ï¼Œé‚£ä¹ˆå®ƒå°†æœ‰ä¸€ä¸ªä¸æ–­å¢é•¿çš„å†…éƒ¨è®°è´¦ã€‚
- en: There are two ways to address this ever-growing bookkeeping. One or the other
    may be feasible depending on the requirements of your application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥è§£å†³è¿™ä¸ªä¸æ–­å¢é•¿çš„è®°è´¦é—®é¢˜ã€‚æ ¹æ®ä½ çš„åº”ç”¨è¦æ±‚ï¼Œå…¶ä¸­ä¸€ç§å¯èƒ½æ›´å¯è¡Œã€‚
- en: 'The first is to adopt what accountants do: close books at the end of every
    month and quarter. All replicas keep a rolling window of the latest N days of
    data and throw away data that''s older than N days. And if a replica has been
    offline longer than a certain number of days, then they cannot be expected to
    sync and will need to reload from the latest.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ç§æ–¹æ³•æ˜¯é‡‡ç”¨ä¼šè®¡å¸ˆçš„åšæ³•ï¼šæ¯ä¸ªæœˆå’Œæ¯ä¸ªå­£åº¦ç»“è´¦ã€‚æ‰€æœ‰å‰¯æœ¬éƒ½ä¿ç•™æœ€æ–°Nå¤©æ•°æ®çš„æ»šåŠ¨çª—å£ï¼Œå¹¶ä¸”ä¸¢å¼ƒæ—©äºNå¤©çš„æ•°æ®ã€‚å¦‚æœä¸€ä¸ªå‰¯æœ¬ç¦»çº¿æ—¶é—´è¶…è¿‡ä¸€å®šå¤©æ•°ï¼Œé‚£ä¹ˆå®ƒä»¬å°±ä¸èƒ½è¢«æœŸæœ›è¿›è¡ŒåŒæ­¥ï¼Œå¹¶ä¸”éœ€è¦é‡æ–°åŠ è½½æœ€æ–°æ•°æ®ã€‚
- en: 'The second is to keep all the history, but find ways to compress it. This is
    what the CRDT library [Automerge does](https://youtu.be/x7drE24geUw?si=syBk3NTxeDQekk30&t=3201).
    This can sound like a bad idea, but we already have software that keeps its entire
    history around that developers use every day: [Git](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects).
    Of course, not all application requirements allow us to do this, but in my opinion,
    we don''t do enough of it. Disks are comparatively cheap now, and the [benefits
    of immutability](https://interjectedfuture.com/persistent-data-structure-redux/)
    far outweigh the downsides.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒç§æ–¹æ³•æ˜¯ä¿ç•™æ‰€æœ‰å†å²è®°å½•ï¼Œä½†æ‰¾åˆ°å‹ç¼©çš„æ–¹æ³•ã€‚è¿™å°±æ˜¯CRDTåº“[Automergeæ‰€åšçš„](https://youtu.be/x7drE24geUw?si=syBk3NTxeDQekk30&t=3201)ã€‚è¿™å¬èµ·æ¥å¯èƒ½ä¸æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ï¼Œä½†æˆ‘ä»¬å·²ç»æœ‰è½¯ä»¶æ¯å¤©éƒ½ä¿ç•™å…¶æ•´ä¸ªå†å²ä½¿ç”¨ï¼š[Git](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects)ã€‚å½“ç„¶ï¼Œå¹¶éæ‰€æœ‰åº”ç”¨è¦æ±‚éƒ½å…è®¸æˆ‘ä»¬è¿™æ ·åšï¼Œä½†åœ¨æˆ‘çœ‹æ¥ï¼Œæˆ‘ä»¬æ²¡æœ‰è¶³å¤Ÿçš„åšè¿™ä¸ªã€‚ç°åœ¨ï¼Œç£ç›˜ç›¸å¯¹ä¾¿å®œï¼Œè€Œ[ä¸å˜æ€§çš„å¥½å¤„](https://interjectedfuture.com/persistent-data-structure-redux/)è¿œè¿œè¶…è¿‡äº†ä¸è¶³ä¹‹å¤„ã€‚
- en: To query for the value of an op-based CRDT, we can apply all operations from
    the history log to an empty state to get the current state. Alternatively, we
    can keep a cache of the latest state in memory and update it on every operation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æŸ¥è¯¢åŸºäºæ“ä½œçš„CRDTçš„å€¼ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰æ“ä½œä»å†å²æ—¥å¿—åº”ç”¨åˆ°ç©ºçŠ¶æ€ï¼Œä»¥è·å–å½“å‰çŠ¶æ€ã€‚æˆ–è€…ï¼Œå¯ä»¥åœ¨å†…å­˜ä¸­ä¿å­˜æœ€æ–°çŠ¶æ€çš„ç¼“å­˜ï¼Œå¹¶åœ¨æ¯æ¬¡æ“ä½œæ—¶æ›´æ–°å®ƒã€‚
- en: ğŸ’¡
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡
- en: '- Applies operations to converge state'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '- åº”ç”¨æ“ä½œä»¥æ”¶æ•›çŠ¶æ€'
- en: '- Operations need to be commutative and associative'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '- æ“ä½œéœ€è¦æ˜¯å¯äº¤æ¢å’Œç»“åˆçš„'
- en: '- Internal data structure needs to be monotonically increasing'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '- å†…éƒ¨æ•°æ®ç»“æ„éœ€è¦å•è°ƒé€’å¢'
- en: ğŸ‘
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ‘
- en: '- Small amount of data sent over the network to sync'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '- å‘é€åˆ°åŒæ­¥çš„ç½‘ç»œä¸Šçš„æ•°æ®é‡å¾ˆå°'
- en: '- Easier to accommodate replicas that come in and out of the network'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '- æ›´å®¹æ˜“é€‚åº”è¿›å‡ºç½‘ç»œçš„å¤åˆ¶å“'
- en: '- Data is immutable, hence diffs, undos, and comparisons are easy.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°æ®æ˜¯ä¸å¯å˜çš„ï¼Œå› æ­¤å·®å¼‚ï¼Œæ’¤é”€å’Œæ¯”è¾ƒéƒ½å¾ˆå®¹æ˜“ã€‚
- en: ğŸ‘
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ‘
- en: '- Syncing protocol needs to implement causal delivery of operations'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: éœ€è¦å®ç°æ“ä½œçš„å› æœä¼ é€’çš„åŒæ­¥åè®®
- en: '- Internal data structure is a history of operations that grows linearly with
    the number of operations'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '- å†…éƒ¨æ•°æ®ç»“æ„æ˜¯éšæ“ä½œæ•°é‡çº¿æ€§å¢é•¿çš„æ“ä½œå†å²'
- en: Delta-state CRDTs
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Î”-çŠ¶æ€ CRDTs
- en: Delta-state CRDTs try to solve the data-over-the-wire problem differently. Instead
    of breaking the merge function into operations to send over the wire, we try to
    calculate the minimum amount of state to send to other replicas to sync.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: å¢é‡çŠ¶æ€ CRDTs è¯•å›¾ä»¥ä¸åŒçš„æ–¹å¼è§£å†³æ•°æ®ä¼ è¾“é—®é¢˜ã€‚æˆ‘ä»¬å°è¯•è®¡ç®—å‘é€åˆ°å…¶ä»–å¤åˆ¶å“åŒæ­¥çš„æœ€å°çŠ¶æ€é‡ï¼Œè€Œä¸æ˜¯å°†åˆå¹¶å‡½æ•°åˆ†è§£ä¸ºé€šè¿‡ç”µçº¿å‘é€çš„æ“ä½œã€‚
- en: 'There are two versions of delta-state CRDTs. In the [first Î´-state CRDT paper](https://arxiv.org/pdf/1410.2803.pdf),
    we do something similar to op-based CRDTs: we create a set of operations, called
    delta-mutators) that are used to update the state. But instead of sending these
    operations over the wire, delta-mutators generate a diff between the states before
    the delta-mutator was applied and after it was applied. The diff is then stored
    in a buffer to be sent out to all other replicas.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ä¸ªç‰ˆæœ¬çš„å¢é‡çŠ¶æ€ CRDTsã€‚åœ¨[ç¬¬ä¸€ç¯‡ Î”-çŠ¶æ€ CRDT è®ºæ–‡](https://arxiv.org/pdf/1410.2803.pdf)ä¸­ï¼Œæˆ‘ä»¬åšäº†ç±»ä¼¼äºåŸºäºæ“ä½œçš„
    CRDTs çš„æ“ä½œï¼šæˆ‘ä»¬åˆ›å»ºä¸€ç»„æ“ä½œï¼Œç§°ä¸ºå¢é‡å˜å¼‚å™¨ï¼Œç”¨äºæ›´æ–°çŠ¶æ€ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬ä¸ä¼šå°†è¿™äº›æ“ä½œå‘é€åˆ°ç½‘ç»œä¸Šï¼Œè€Œæ˜¯å¢é‡å˜å¼‚å™¨ç”Ÿæˆåœ¨åº”ç”¨å¢é‡å˜å¼‚å™¨ä¹‹å‰å’Œä¹‹åçŠ¶æ€ä¹‹é—´çš„å·®å¼‚ã€‚ç„¶åï¼Œå°†å·®å¼‚å­˜å‚¨åœ¨ç¼“å†²åŒºä¸­å‘é€åˆ°æ‰€æœ‰å…¶ä»–å¤åˆ¶å“ã€‚
- en: But this buffer isn't a queue. The buffer holds the diff between the current
    state and the state when the buffer was last sent to other replicas. This is possible
    because the delta-mutator diffs are composable. This means if we have two diffs,
    d[12] (a diff between State X[1] and State X[2]) and d[23] (a diff between State
    X[2] and State X[3]), the composition of the two diffs would be D[13] (computed
    with d[12] â¨† d[23]). Hence, the application of d[12] and then d[23] is the same
    as the application of the composition D[13]. The paper calls these compositions,
    delta-groups.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ï¼Œæ­¤ç¼“å†²åŒºä¸æ˜¯é˜Ÿåˆ—ã€‚ç¼“å†²åŒºä¿å­˜å½“å‰çŠ¶æ€å’Œä¸Šæ¬¡å°†ç¼“å†²åŒºå‘é€ç»™å…¶ä»–å¤åˆ¶å“çš„çŠ¶æ€ä¹‹é—´çš„å·®å¼‚ã€‚è¿™æ˜¯å¯èƒ½çš„ï¼Œå› ä¸ºå¢é‡å˜å¼‚å™¨çš„å·®å¼‚æ˜¯å¯ç»„åˆçš„ã€‚è¿™æ„å‘³ç€å¦‚æœæˆ‘ä»¬æœ‰ä¸¤ä¸ªå·®å¼‚ï¼Œd[12]ï¼ˆState
    X[1] å’Œ State X[2] ä¹‹é—´çš„å·®å¼‚ï¼‰å’Œ d[23]ï¼ˆState X[2] å’Œ State X[3] ä¹‹é—´çš„å·®å¼‚ï¼‰ï¼Œé‚£ä¹ˆä¸¤ä¸ªå·®å¼‚çš„ç»„åˆå°†æ˜¯ D[13]ï¼ˆä½¿ç”¨
    d[12] â¨† d[23] è®¡ç®—ï¼‰ã€‚å› æ­¤ï¼Œå°† d[12] åº”ç”¨äº d[23] æ˜¯ä¸ç»„åˆ D[13] çš„åº”ç”¨ç›¸åŒã€‚è®ºæ–‡ç§°è¿™äº›ç»„åˆä¸ºå¢é‡ç¾¤ã€‚
- en: And because the diffs exist in the same join-semilattice as the states, you
    can use the same merge function to merge the diffs received from other replicas
    into your own local state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºå·®å¼‚å­˜åœ¨äºä¸çŠ¶æ€ç›¸åŒçš„è¿æ¥åŠæ ¼ä¸­ï¼Œæ‰€ä»¥æ‚¨å¯ä»¥ä½¿ç”¨ç›¸åŒçš„åˆå¹¶å‡½æ•°å°†æ¥è‡ªå…¶ä»–å¤åˆ¶å“çš„å·®å¼‚åˆå¹¶åˆ°æ‚¨è‡ªå·±çš„æœ¬åœ°çŠ¶æ€ä¸­ã€‚
- en: The [second Î”-state paper](https://web.archive.org/web/20230607175939/https://novasys.di.fct.unl.pt/~alinde/publications/a12-van_der_linde.pdf)
    takes a slightly different approach. While the ğ›¿-state CRDT has a replica send
    the same diff to all other replicas, in the Î”-state CRDT, we notice that the information
    about which replica has which part of the state is already encoded in the vector
    clock internal bookkeeping of the CRDTs. Hence, we can tailor the diff that we
    send to each replica. Therefore, we can toss the buffer and calculate the exact
    diff of the state that another replica needs. But by trading off the buffer, you
    now need to keep track of tombstones.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[ç¬¬äºŒä»½Î”-stateè®ºæ–‡](https://web.archive.org/web/20230607175939/https://novasys.di.fct.unl.pt/~alinde/publications/a12-van_der_linde.pdf)é‡‡ç”¨äº†ç¨å¾®ä¸åŒçš„æ–¹æ³•ã€‚è™½ç„¶ğ›¿-state
    CRDTè¦æ±‚ä¸€ä¸ªå‰¯æœ¬å°†ç›¸åŒçš„å¢é‡å‘é€ç»™æ‰€æœ‰å…¶ä»–å‰¯æœ¬ï¼Œä½†åœ¨Î”-state CRDTä¸­ï¼Œæˆ‘ä»¬æ³¨æ„åˆ°æœ‰å…³æ¯ä¸ªå‰¯æœ¬æ‹¥æœ‰çŠ¶æ€çš„å“ªä¸€éƒ¨åˆ†çš„ä¿¡æ¯å·²ç»è¢«ç¼–ç è¿›äº†CRDTçš„å‘é‡æ—¶é’Ÿå†…éƒ¨è®°å½•ä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é’ˆå¯¹æ¯ä¸ªå‰¯æœ¬å®šåˆ¶éœ€è¦å‘é€çš„å¢é‡ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä¸¢æ‰ç¼“å†²åŒºå¹¶è®¡ç®—å¦ä¸€ä¸ªå‰¯æœ¬éœ€è¦çš„çŠ¶æ€çš„ç¡®åˆ‡å¢é‡ã€‚ä½†æ˜¯é€šè¿‡ç‰ºç‰²ç¼“å†²åŒºï¼Œä½ ç°åœ¨éœ€è¦è¿½è¸ªå¢“ç¢‘ã€‚'
- en: Delta-CRDTs retain the idempotency property of state-based CRDTs but do not
    require lots of bandwidth to sync replicas.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Delta-CRDTä¿ç•™äº†åŸºäºçŠ¶æ€çš„CRDTçš„å¹‚ç­‰æ€§å±æ€§ï¼Œä½†ä¸éœ€è¦å¤§é‡å¸¦å®½æ¥åŒæ­¥å‰¯æœ¬ã€‚
- en: ğŸ’¡
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡
- en: '- Merge either full state or deltas to converge'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '- åˆå¹¶æ—¶è¦ä¹ˆåˆå¹¶å…¨éƒ¨çŠ¶æ€ï¼Œè¦ä¹ˆåˆå¹¶å¢é‡ä»¥å®ç°æ”¶æ•›'
- en: '- Merge function needs to be commutative, associative, and idempotent'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '- åˆå¹¶å‡½æ•°éœ€è¦æ˜¯å¯äº¤æ¢çš„ã€å¯ç»“åˆçš„å’Œå¹‚ç­‰çš„'
- en: '- Internal data structure needs to be monotonically increasing'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '- å†…éƒ¨æ•°æ®ç»“æ„éœ€è¦å•è°ƒé€’å¢'
- en: ğŸ‘
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ‘
- en: '- Small amount of data sent over the network to sync'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '- å‘é€åˆ°ç½‘ç»œä¸Šçš„æ•°æ®é‡å¾ˆå°ä»¥ä¾¿åŒæ­¥'
- en: '- Syncing protocol is simple and just needs to broadcast to all other replicas'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '- åŒæ­¥åè®®å¾ˆç®€å•ï¼Œåªéœ€è¦å‘æ‰€æœ‰å…¶ä»–å‰¯æœ¬å¹¿æ’­'
- en: ğŸ‘
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ‘
- en: '- Internal data structure grows with the number of replicas'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '- éšç€å‰¯æœ¬æ•°é‡çš„å¢åŠ ï¼Œå†…éƒ¨æ•°æ®ç»“æ„ä¹Ÿä¼šå¢é•¿'
- en: '- Internal data structure can get complex, like using'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '- å†…éƒ¨æ•°æ®ç»“æ„å¯èƒ½ä¼šå˜å¾—å¤æ‚ï¼Œæ¯”å¦‚ä½¿ç”¨'
- en: '[Dots](https://www.bartoszsypytkowski.com/optimizing-state-based-crdts-part-2/)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[ç‚¹](https://www.bartoszsypytkowski.com/optimizing-state-based-crdts-part-2/)'
- en: .
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: '- Merge function implementation can get complex.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '- åˆå¹¶å‡½æ•°çš„å®ç°å¯èƒ½ä¼šå˜å¾—å¤æ‚ã€‚'
- en: The Search Continues
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æœç´¢ç»§ç»­
- en: While all of these CRDTs have strengths and weaknesses, I'm looking for something
    where I don't have to compromise. Next time, I'll cover my search into Merkle
    CRDTs. In the meantime, [follow me on twitter](https://twitter.com/iamwil).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰è¿™äº›CRDTéƒ½æœ‰å„è‡ªçš„ä¼˜ç¼ºç‚¹ï¼Œæˆ‘åœ¨å¯»æ‰¾ä¸€ç§ä¸éœ€è¦å¦¥åçš„ä¸œè¥¿ã€‚ä¸‹æ¬¡ï¼Œæˆ‘å°†ä»‹ç»æˆ‘å¯¹Merkle CRDTsçš„æœç´¢ã€‚ä¸æ­¤åŒæ—¶ï¼Œå¯ä»¥[å…³æ³¨æˆ‘çš„ Twitter](https://twitter.com/iamwil)ã€‚
- en: '* * *'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[^1]: Here''s some introductory material on CRDTs I found helpful'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[^1]: è¿™æ˜¯æˆ‘å‘ç°æœ‰ç”¨çš„CRDTsçš„ä»‹ç»ææ–™'
- en: '- [An interactive intro to CRDTs](https://jakelazaroff.com/words/an-interactive-intro-to-crdts/)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '- [CRDTsäº¤äº’å¼ä»‹ç»](https://jakelazaroff.com/words/an-interactive-intro-to-crdts/)'
- en: '- [An introduction to state-based CRDTs](https://www.bartoszsypytkowski.com/the-state-of-a-state-based-crdts/)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '- [åŸºäºçŠ¶æ€çš„CRDTsç®€ä»‹](https://www.bartoszsypytkowski.com/the-state-of-a-state-based-crdts/)'
- en: '- [CRDTs for non-academics](https://www.youtube.com/watch?v=vBU70EjwGfw)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '- [éå­¦è€…çš„CRDTs](https://www.youtube.com/watch?v=vBU70EjwGfw)'
- en: '- [CRDT: The Hard Parts](https://www.youtube.com/watch?v=x7drE24geUw)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '- [CRDTï¼šå›°éš¾ä¹‹å¤„](https://www.youtube.com/watch?v=x7drE24geUw)'
- en: '- [Readings in CRDTs](https://christophermeiklejohn.com/crdt/2014/07/22/readings-in-crdts.html)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '- [CRDTsé˜…è¯»ææ–™](https://christophermeiklejohn.com/crdt/2014/07/22/readings-in-crdts.html)'
- en: '- [crdt.tech](https://crdt.tech)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '- [crdt.tech](https://crdt.tech)'
