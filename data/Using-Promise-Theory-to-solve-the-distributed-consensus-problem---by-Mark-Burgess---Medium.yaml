- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 14:52:45'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:52:45'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Using Promise Theory to solve the distributed consensus problem | by Mark Burgess
    | Medium
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺理论解决分布式共识问题 | 作者：Mark Burgess | Medium
- en: 来源：[https://mark-burgess-oslo-mb.medium.com/using-promise-theory-to-solve-the-distributed-consensus-problem-4cc2116f24e1](https://mark-burgess-oslo-mb.medium.com/using-promise-theory-to-solve-the-distributed-consensus-problem-4cc2116f24e1)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://mark-burgess-oslo-mb.medium.com/using-promise-theory-to-solve-the-distributed-consensus-problem-4cc2116f24e1](https://mark-burgess-oslo-mb.medium.com/using-promise-theory-to-solve-the-distributed-consensus-problem-4cc2116f24e1)
- en: Using Promise Theory to solve the distributed consensus problem
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺理论解决分布式共识问题
- en: Secure tools for sharing granular data between micro clients
  id: totrans-split-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全工具用于在微客户端之间共享细粒度数据
- en: 'Whenever we try to fix something in one corner of IT, we seem to yank another
    corner out of place and create new problems–trading one conundrum for another.
    Microservices are a perfect example of that: the denormalization of data and centralization
    of processes makes teams less interdependent (solving a human issue), but creates
    challenges for managing shared state. Breaking up singular data stores into (not
    completely) independent parts can easily upset the integrity of algorithms, data,
    user experiences, and hence [business continuity](https://en.wikipedia.org/wiki/Business_continuity_planning).
    These headaches are now more keenly felt as these matters become regulated by
    law (think [GDPR](https://gdpr-info.eu/), [DORA](https://www.digital-operational-resilience-act.com/),
    etc). The most prominent issue is the so-called *consistency* of shared data,
    because it underpins so much and involves technical issues that engineers can
    sympathize with.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们试图在IT的一个角落修复问题时，似乎总是在搬弄其它角落，制造新问题——用一个难题换另一个难题。微服务就是一个典型例子：数据的去规范化和流程的集中化使得团队的相互依赖性降低（解决了一个人为问题），但也带来了管理共享状态的挑战。将单一数据存储分解为（并非完全）独立的部分很容易破坏算法、数据、用户体验的完整性，从而影响到[业务连续性](https://en.wikipedia.org/wiki/Business_continuity_planning)。随着这些事务逐渐受到法律法规的监管（如[GDPR](https://gdpr-info.eu/)、[DORA](https://www.digital-operational-resilience-act.com/)等），这些头疼的问题变得更加明显。其中最突出的问题是所谓的*一致性*问题，因为它涵盖了如此多的内容，涉及到工程师能够理解的技术问题。
- en: Dare we ask?
  id: totrans-split-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们敢不敢问？
- en: The problem of [data consistency](https://en.wikipedia.org/wiki/Data_consistency)
    remains one of those issues that continues to attract attention both from academics
    and practitioners. It’s famously muddled together with the notion of [distributed
    consensus](https://en.wikipedia.org/wiki/Consensus_(computer_science)). The English
    meanings are basically the same, but the technical meanings are used differently.
    Confusingly, the latter is used as part of the usual solution to the former in
    standard algorithms like [**Paxos**](https://en.wikipedia.org/wiki/Paxos_(computer_science))
    and [**Raft**](https://en.wikipedia.org/wiki/Raft_(algorithm)). Lesser known but
    influential results, like the [**FLP theorem**](https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf),
    “prove” the impossibility of distributed consensus in an asynchronous environment
    and scare people away from thinking carefully. There’s also the infamous CAP conjecture
    whose popularization (and apparently endless revisions) added fuel to the mysticism
    in a generally unhelpful way.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[数据一致性](https://en.wikipedia.org/wiki/Data_consistency)问题依然是吸引学术界和从业者关注的问题之一。它与[分布式共识](https://en.wikipedia.org/wiki/Consensus_(computer_science))的概念混为一谈。英语的含义基本相同，但技术上的用法不同。令人困惑的是，后者常常作为前者标准算法（如[Paxos](https://en.wikipedia.org/wiki/Paxos_(computer_science))和[Raft](https://en.wikipedia.org/wiki/Raft_(algorithm))）的一部分。还有一些较为影响深远但不为人知的成果，例如[FLP定理](https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf)，它“证明”了在异步环境中分布式共识的不可能性，并使人们不敢轻易深思。此外，还有著名的CAP猜想，它的普及（以及明显无休止的修订）以一种普遍无益的方式增加了神秘色彩。'
- en: The IT industry isn’t always good at asking probing questions–we like to trust
    leaders and influencers who can think for us. But those thinkers sometimes leave
    the problem half solved, and we end up with standard solutions that random software
    engineers interpret for us. Dare we question them?
  id: totrans-split-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IT行业并不擅长提出深入问题——我们喜欢相信那些可以替我们思考的领导者和影响者。但是这些思考者有时会留下问题的半解答，我们最终得到的是那些随意软件工程师解读的标准解决方案。我们敢质疑它们吗？
- en: Over my tenure in Computer Science, I’ve tried to clarify and even debunk the
    occasional myth about what can and can’t be done by developing clear models, many
    of which are summarised in my [Treatise on Systems](http://markburgess.org/treatise.html),
    often with the help of the increasingly ubiquitous [Promise Theory](https://en.wikipedia.org/wiki/Promise_theory).
    The data consistency issue is no different, and it turns out that there is a simple
    answer we’ve been missing that [**András Gerlits**](https://itnext.io/microservices-and-the-myth-of-loose-coupling-9bbca007ac1a)
    and I have been talking about quite a lot recently in connection with his [**Omniledger
    calibrator software**](https://omniledger.io/). Of course, there may be several
    ways of “solving” a problem, depending on the semantics we desire. Part of the
    confusion about consistency lies in deciding what we consider to be an equitable
    solution.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我在计算机科学领域的任期中，我试图通过开发清晰的模型来澄清甚至揭穿关于什么可以做什么不能做的偶尔神话，其中许多模型在我的[Treatise on Systems](http://markburgess.org/treatise.html)中进行了总结，这些模型通常是在日益普及的[承诺理论](https://en.wikipedia.org/wiki/Promise_theory)的帮助下完成的。数据一致性问题也不例外，我们一直在谈论的是[**安德拉斯·格尔利茨**](https://itnext.io/microservices-and-the-myth-of-loose-coupling-9bbca007ac1a)和我最近与他有关[**Omniledger校准软件**](https://omniledger.io/)的简单答案。
- en: Let’s apply the smallest amount of [Promise Theory](http://markburgess.org/promises.html)
    to show how *intentional consistency* of data can be engineered at the same time
    as we scale the scope and availability of a service.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用最少量的[承诺理论](http://markburgess.org/promises.html)来展示如何在扩展服务的范围和可用性的同时工程化*有意的一致性*数据。
- en: 'Consistency: one of the skis is parallel!'
  id: totrans-split-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性：一只滑雪板是平行的！
- en: By consistency, we obviously don’t mean whipping data into a smooth spongy texture
    for a dish best served fast! Consistency in IT refers to the pure undelayed homogeneity
    of *facts* throughout a system–of data values, or key-value pairs that spans several
    computers.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一致性，我们显然不是指把数据打成一种光滑多孔的质地，以便更快地供应！IT中的一致性指的是系统中**事实**的纯粹无延迟的同质性——数据值或跨越多台计算机的键值对。
- en: Consistency manifests as a business reliability (perhaps even security) issue
    for most of us. It’s now related to *regulatory compliance* issues, particularly
    in the EU, as well as matters of privacy and user experience. The related terms
    *consensus* and *quorum* are more subtly used to refer to how one *reaches* agreement
    about disputed facts, but in practice these all mean that we want parts of a system
    to reach the goal of being *aligned* in their *promises of data*.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数人来说，一致性表现为商业可靠性（甚至安全性）问题。现在它与*监管合规性*问题息息相关，特别是在欧盟，以及隐私和用户体验问题。相关术语*共识*和*法定人数*更加微妙地用于指代如何在争议事实上达成一致意见，但在实践中，所有这些都意味着我们希望系统的各个部分在它们对*数据承诺*方面达成*一致*的*目标*。
- en: 'On a ski slope, skiers are taught to keep their skis in alignment when making
    turns. When parallel, the skis’ directions “agree” or are consistent with each
    other. One might say they have reached a consensus about their direction of travel.
    Those who are less stylish in their parallelism sometimes joke: “well, one of
    the skis was parallel!”. In IT, we don’t want our systems to be split down the
    middle by misalignments.'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在滑雪斜坡上，教练教导滑雪者在转弯时保持他们的滑雪板对齐。当平行时，滑雪板的方向“一致”或与彼此一致。有人可能会说，他们在他们的平行性上不那么时髦：“嗯，其中一只滑雪板是平行的！”在IT领域，我们不希望我们的系统因为错位而被一分为二。
- en: We can’t actually stop it from happening, but we can prevent ourselves from
    ever *seeing it* so that it can make no difference in practice. Just how stringently
    this is prevented accounts for several differences in the discussions about data
    consistency.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上无法阻止它发生，但我们可以防止自己*看见*它，以使其在实践中不产生任何影响。严格来说，这种预防的程度在关于数据一致性的讨论中占有一席之地。
- en: Seeing is believing
  id: totrans-split-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 眼见为实
- en: If consensus is about winning an argument, then consistency is a problem about
    *calibration* of state. Any user or observer has an equal “right” or capability
    to measure the answers given by different independent agents and compare them
    to see if they are equal. That single point of measurement calibrates the outcomes
    of any two agents (see diagram below).
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果共识是关于赢得一场争论，那么一致性就是一个关于*状态校准*的问题。任何用户或观察者都有平等的“权利”或能力来测量不同独立代理给出的答案，并将它们进行比较，看看它们是否相等。这个单一的测量点校准了任何两个代理的结果（见下图）。
- en: '**A and B are supposed to be in alignment. A claims the value is a, B clams
    it’s b. It’s up to C to decide whether it receives these and finds that a = b
    are the same.**'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**A和B应该保持一致。A声称值是a，B声称是b。决定是否接收这些并发现a = b是C的职责。**'
- en: '*C* observes *A* and *B* and, using this information, it is able to make a
    conditional promise based on that information to any other agent of interest (including
    the original *A* and *B*) about whether or not a=b according to its own measurements
    and to the best of its capabilities. *C* is thus a calibrator–an independent adjudicator
    of truth. This is how law courts work: a judge compares *A* and *B* to resolve
    differences or make a choice. Consensus means that *A*, *B*, and *C* all agree
    about their value for the promise. This is easy if there is an authoritative source
    for correct change. This is what we need to preserve.'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*观察*A*和*B*，并利用这些信息，它能够根据自己的测量和最好的能力向任何其他感兴趣的代理人作出基于这些信息的有条件承诺，包括原始的*A*和*B*。*C*因此是一个校准器
    - 真相的独立裁决者。这就是法庭的工作方式：法官比较*A*和*B*以解决分歧或作出选择。共识意味着*A*、*B*和*C*对承诺的值达成一致。如果存在正确变化的权威来源，这很容易。这是我们需要保留的内容。'
- en: Agreeing about different versions of a particular value is relatively easy as
    long as the values of a and b never change. But in a dynamically changing environment,
    like bumping over snow moguls, keeping a and b skis aligned depends on a race
    to change each. What if *a* changes while no one is looking and *C* hasn’t measured
    *a* in a while, so it still thinks that *a=b*, but *A* knows better. How can we
    know this? Clearly, we can’t because we already lost that race, but we need to
    ask whether this matters to anything that can happen. If a skier falls in a forest
    and no one is looking…should we care?
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定值的不同版本上达成一致相对较容易，只要a和b的值不改变。但在像在雪堆上碰撞时这样动态变化的环境中，保持a和b的滑雪板对齐取决于每次变化的竞赛。如果*a*在无人注意时发生变化，而*C*长时间没有测量*a*，所以它仍然认为*a=b*，但*A*知道更多。我们如何知道这一点？显然，我们不能，因为我们已经输掉了这场竞赛，但我们需要问这对任何可能发生的事情是否重要。如果一个滑雪者在森林里摔倒，而没有人看到…我们应该关心吗？
- en: Central services!?
  id: totrans-split-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中心服务！？
- en: A small but growing number of voices is challenging the authority of the FLP
    and CAP results, pointing out that their implications have been misunderstood.
    The impossibility claims for distributed consensus stem from an incorrect assumption
    about the universality of change. The standard assumption is that it has to apply
    to everyone “at the same time”. But what does “at the same time” mean? If you’ve
    ever watched a thunderstorm, you know that sensory data (what we see and what
    we hear) arrive at very different times even though the strike happens at a single
    moment and at a single location.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个声音越来越多的群体正在挑战FLP和CAP结果的权威，指出它们的影响被误解了。分布式共识的不可能性主张源于对变化普遍性的错误假设。标准假设是它必须同时适用于每个人。“同时”意味着什么？如果你曾经看过雷暴，你会知道感官数据（我们看到和听到的）即使在闪电发生在单一时刻和单一位置的情况下，到达时间也是非常不同的。
- en: 'A*vailability* (readiness to listen) and *consensus* (agreement) are *not*
    global constraints that need to imply rigorous temporal precision, they are actually
    only constraints on the *local* behaviour of observers and influencers (users).
    Promise Theory is about autonomous agents, which implies the *causal independence
    of agents*: changes promised by one agent cannot influence another without an
    explicit acceptance by the promisee. So Promise Theory can help us to clarify
    where incorrect assumptions about causality go wrong.'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*可用性*（愿意倾听）和*共识*（一致）不是需要暗示严格时间精确性的全局约束，它们实际上只是观察者和影响者（用户）*本地*行为的约束。承诺理论关于自治代理，这意味着代理之间的*因果独立性*：一个代理承诺的变化不能在没有承诺者明确接受的情况下影响另一个。因此，承诺理论可以帮助我们澄清有关因果关系错误的地方。'
- en: 'Alignment of data ultimately boils down to how different agents in an information
    system signal and observe change to one another. After all it’s this change that
    measures the passage of time across the different partial processes. Observation
    is a crucial element, because we don’t notice changes (the passage of time) while
    we have our eyes closed. When we open them again, that’s when the change reaches
    us in a single tick. So everyone receives the information at their own behest:
    at their own pace, not when the lightning actually strikes.'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对齐最终归结为信息系统中不同代理如何相互信号和观察变化。毕竟，正是这种变化衡量了跨不同部分过程的时间流逝。观察是一个关键元素，因为当我们闭上眼睛时，我们不会注意到变化（时间的流逝）。当我们再次睁开眼睛时，变化以单个时间单位达到我们。所以每个人都按照自己的意愿接收信息：以自己的节奏，而不是闪电真正打击的时候。
- en: If we apply this to think about how fragments in a system align their changing
    facts, the solution for maintaining alignment across multiple locations boils
    down to making sure we preserve the historical order of changes from the original
    source. If you smash a plate with a picture painted on it, we can reconstruct
    the picture later so that it’s consistent with the original as long as we put
    the pieces in the correct spacetime order.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把这个思想应用到系统中的片段如何调整它们变化的事实，那么在多个位置保持对齐的解决方案就归结为确保我们保留从原始来源的变更历史顺序。如果你用图案绘制的碟子摔碎了，我们可以后来重建图案，只要我们按照正确的时空顺序放置碎片。
- en: An obvious and simple way to assure consistency is to have just one answer to
    compare to. A single copy cannot be inconsistent, so we use *singular sources*
    as sources for truth and arbitration. For perfect parallel turns, use a snowboard!
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 确保一致性的一个明显且简单的方法是只有一个答案可供比较。单一副本不可能不一致，所以我们将*单一来源*用作真理和仲裁的来源。对于完美的并行转弯，请使用滑雪板！
- en: The industry standard is to force a single “master” database and replicate it
    for redundancy. That way, you don’t have to worry about the “master” being consistent.
    We don’t look at the copies too often, so that’s one way of avoiding trouble.
    Centralization to a single master is presented as a control decision to assure
    an authoritative source, i.e. a single source of control. But when the master
    fails, we have to worry about whether any of the backups are consistent with the
    master. Since we’ve now lost the original, the meaning of consistent is now ambiguous.
    Aligned with what? Which of the skis is parallel?
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 行业标准是强制使用单个“主”数据库，并为其冗余复制。这样，您就不必担心“主”是否一致。我们不经常看副本，所以这是避免麻烦的一种方式。将中心化到单个主体被呈现为控制决策，以确保权威来源，即单一控制来源。但是当主失败时，我们必须担心备份是否与主一致。因为我们现在已经失去了原始数据，所以一致的含义现在变得模糊。与什么对齐？哪个滑雪板平行？
- en: Many also point out that a central service is also a possible bottleneck (depending
    on its relative capacity), but the true importance of centralisation in system
    design is really (you guessed it) for *calibration–*to act as a standard measuring
    stick for data. It turns out we can solve both the consistency problem and the
    bottleneck problem alongside the partial sharing (microservice) problem all at
    the same time by introducing a *data calibrator*, and just getting the plumbing
    right to preserve causal order across a system. It’s a bit like a shared clock,
    but in which the flow of data is the clock itself! In this way, all concerns about
    data or network partitions, unreliable connections etc, can be resolved for each
    individual client *locally* for best effort. To make everything happen “at the
    same time” we can simply stop time for those who wait without a central service!
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人还指出，中央服务也可能是一个瓶颈（取决于其相对容量），但在系统设计中中心化的真正重要性实际上是（你猜到了）*校准*——作为数据的标准度量标准。事实证明，我们可以通过引入*数据校准器*并正确配置管道来同时解决一致性问题、瓶颈问题以及部分共享（微服务）问题。这有点像共享时钟，但其中数据流就是时钟本身！通过这种方式，关于数据或网络分区、不可靠连接等的所有担忧可以在每个客户端*本地*进行最大努力地解决。为了让一切同时发生，我们可以简单地为那些没有中央服务等待的人停止时间！
- en: Independent contractors or central services?
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 独立承包商还是中央服务？
- en: Scale it, agent by agent
  id: totrans-split-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐个代理扩展
- en: The figure below shows the basic interaction between a client and a single server,
    e.g. a database. Assuming that there is only one copy of data on this server,
    it has to be self-consistent.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了客户端与单个服务器之间的基本交互，例如数据库。假设这台服务器上只有一个数据副本，它必须是自洽的。
- en: 'A user interacts with a datastore. The causality is simple: one version, one
    value at a time.'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与数据存储交互。因果关系很简单：一个版本，一次一个值。
- en: As we add more clients, a single database may not be able to cope with the work
    so we look to scale the system. Using Promise Theory notation, the database promises
    to accept data (-) in the order the client promises to offer data (+). We simply
    need to scale these promises to deal with a single *superagent* that encapsulates
    more clients and databases to maintain alignment across redundant copies of data
    on a continuous basis.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随着客户数量的增加，单个数据库可能无法处理工作，因此我们寻求扩展系统。使用 Promise Theory 符号，数据库承诺接受数据（-），按客户承诺提供数据（+）的顺序。我们只需要扩展这些承诺以处理一个*超级代理*，它封装了更多的客户端和数据库，以持续在冗余数据副本之间保持对齐。
- en: What’s true for *a single client-server pair* must also be true for *any pair*
    in a collection of pairs. Consider three such pairs, in the diagram below.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*单个客户端-服务器对*的真理对于*任意一对*也必须在一组对中成立。考虑下面示意图中的三对。'
- en: When N independent data stores want to coordinate a few records each can have
    one version at a time in their private scope, but each data store and user can
    hold its own version of what they call the same thing, becaus agreeing onthe key
    is not agreeing about the value.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当 N 个独立的数据存储想要协调每个记录时，可以在其私有范围内一次只能有一个版本，但是每个数据存储和用户可以持有自己关于他们所称之物的版本，因为关于键的一致性并不等同于关于值的一致性。
- en: Every pair can work independently, but if we want *all three* of these pairs
    to be aligned with one another “at all times”, could we arrange a perfect alignment
    of their data promises? They need to be coordinated.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每对可以独立工作，但如果我们希望*所有三对*能够“始终”互相对齐，我们能够安排它们的数据承诺的完美对齐吗？它们需要协调。
- en: '*Because data changes tend to be sparse arrival processes their streams can
    naturally be merged without losing any contention. If (in rare cases) the streams
    all have heavy traffic, we can use traffic lights to poll them round robin in
    the usual way. Roundabouts (“road circles”) do this in traffic. We can create
    the same effect with simple polling of the entrances and exits.*'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于数据更改往往是稀疏的到达过程，它们的流可以自然地合并而不会失去任何争议。如果（在罕见情况下）这些流量都很大，我们可以使用交通灯以常规方式轮询它们。交通圆环（“环形道路”）在交通中这样做。我们可以通过简单轮询入口和出口创建相同的效果。*'
- en: '“At all times” is the key term, and this is where people often stumble. There
    are, after all, times when we don’t care if things are the same: i.e. when no
    one is looking. Skiers can pick themselves up in the forest and recover without
    being disqualified from a race. Instead of “equality at all times” we should be
    asking “alignment whenever someone actually looks”, because this is all we can
    promise about someone else’s state. Whatever we can’t see is uncorroborated hearsay.'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: “始终”是关键术语，这是人们经常犯错的地方。毕竟，有时候我们不在乎事物是否相同：例如，当没有人在看的时候。滑雪者可以在森林中自己爬起来并恢复而不会被取消比赛资格。我们应该询问“每当有人实际上查看时是否对齐”，而不是“始终相等”，因为这是我们能对他人状态做出的唯一承诺。我们看不到的东西都是无法证实的传闻。
- en: What the FLP and CAP results interpret too restrictively is that all times and
    locations must be universally in alignment for arbitrarily small intervals of
    a mythical *universal time*. However, when sleeping, hours can pass during which
    we can neither say nor care whether data elsewhere are in step or not. If we disregard
    times when it is impossible to observe misalignment, the issues simply become
    about tracing the history in causal order, like in a *supply chain*. We accomplish
    this by managing observables when making *conditional promises* about consensus.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: FLP 和 CAP 结果解释得太过严格，即所有时间和位置都必须在一个神秘的*全球时间*的任意小时间间隔内普遍保持一致。然而，当睡觉时，可能经过几个小时，我们既不能说也不关心其他地方的数据是否同步。如果我们忽略不可能观察到不一致的时间，问题就简单地变成了追踪因果顺序中的历史，就像*供应链*一样。我们通过在作出*有条件承诺*时管理可观察量来完成这一点。
- en: We already know that the simple way to achieve this is to get everyone to interact
    with the same database, which is the central services model. We can do better
    than this by introducing a conditional interpolation pipeline. Reads and writes
    of data queue up centrally to be admitted to a single calibrated timeline. If
    two clients send a conflicting request it’s First Come First Served and the latecomer
    is returned to sender. The accepted transactions are thus queued up to final destinations
    so they can be picked up once the receivers are awake and available to assimilate
    them.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道实现这一点的简单方法是让所有人与同一个数据库进行交互，这是中央服务模型。我们可以通过引入条件插值管道做得更好。数据队列的读写被集中到一个单一校准的时间轴上。如果两个客户端发送冲突请求，按照先到先服务的原则，后到者将被退回发送者。接受的事务因此排队等待最终的目标地点，以便接收器醒来并可以消化它们。
- en: Granular scaling with no master
  id: totrans-split-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无主的细粒度缩放
- en: 'Let’s do it step by step. You can skip this if it’s too much detail. To make
    N databases behave as one we have to note the following:'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步来。如果细节太多，您可以跳过此步骤。要使 N 个数据库行为像一个数据库，我们必须注意以下几点：
- en: 'We replace each master database interaction by interactions with an interloper:
    a kind of “virtual data service”, i.e. a scale model of a single database (made
    from distributed parts) made using smart data plumbing.'
  id: totrans-split-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将每个主数据库交互替换为与介入者的互动：一种“虚拟数据服务”，即使用智能数据管道制作的单一数据库的规模模型（由分布式部件制成）。
- en: We then tie the *ability to observe* records together with the condition of
    no pending change. This is slightly different from a typical mutex lock, but it
    amounts to the same thing.
  id: totrans-split-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将*能够观察*记录的能力与没有未决变更的条件联系在一起。这与典型的互斥锁略有不同，但本质上是一样的。
- en: We intercept the usual promises from client to database by wrapping the service
    connection with our smart pipeline, which now passes everything through an interloper
    or data calibrator.
  id: totrans-split-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过用我们的智能管道包装服务连接，将客户到数据库的典型承诺拦截，现在将一切传递给介入者或数据校准器。
- en: 'With these promises, we can actually scale data replication up and down more
    powerfully than by the master replica set method. Every database can continue
    to work at near full capacity at its edge of the network. The data calibrator
    mediates a kind of virtual database that coordinates changes on a microgranular
    level between otherwise independent databases. Instead of writing directly to
    a database connection, we feed operations into a smart pipeline and everything
    else happens transparently. The data managed by the interloper proxy can cover
    just as much or as little of the whole edge data stores as we want it to. This
    is a matter of policy. The result is that we have an idea which is perfect for:'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借这些承诺，我们实际上可以比主复制集方法更强大地扩展数据复制的上下游。每个数据库都可以在其网络边缘几乎完全容量地继续工作。数据校准器在微粒级别协调独立数据库之间的变更，介入代理管理的数据可以覆盖我们想要的整个边缘数据存储的多少。这是一种政策问题。其结果是我们有一个完美的理念：
- en: '[Copy on write](https://en.wikipedia.org/wiki/Copy-on-write) backup of all
    data, or'
  id: totrans-split-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[写时复制](https://en.wikipedia.org/wiki/Copy-on-write)备份所有数据，或者'
- en: Microservices with denormalized storage, where perhaps only a small amount of
    user data needs caching over some region.
  id: totrans-split-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非规范化存储的微服务，在某些区域可能只需要缓存少量用户数据。
- en: To restore unity, replace three interactions with three things with three interactions,
    one at a time, with one thing. We can use this simple causal reasoning to prevent
    inconsistencies at various levels of nitpicking.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了恢复统一性，逐个用一个东西替换三个互动中的三件事。我们可以利用这种简单的因果推理来防止各个层次的挑剔不一致。
- en: Promise theoretically, we proceed by drawing a boundary around the three interactions
    we want to calibrate (excluding the databases themselves, which we don’t want
    to force to be fully identical) and call these a single superagent. We redirect
    the interactions for shared data to this new agent, which implements a smart data
    pipeline for causal updates.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上许诺，我们通过在想要校准的三个互动周围划定边界（排除数据库本身，我们不希望强制完全相同），称之为单一的超级代理。我们将共享数据的互动重定向到这个新代理，该代理实现了用于因果更新的智能数据管道。
- en: To the client user, this now looks like a single interface (or proxy) to a scaled
    model of a database.
  id: totrans-split-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对客户用户而言，现在看起来像是一个数据库规模模型的单一接口（或代理）。
- en: To each database, the client just looks like a single client.
  id: totrans-split-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个数据库而言，客户端看起来只像一个单一的客户端。
- en: The promises
  id: totrans-split-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: Let’s quickly examine the client-server interactions more closely and turn each
    direct interaction into a supply chain interaction, with replication of the data
    stream.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细审视客户端-服务器交互，并将每一次直接交互转化为数据流的供应链交互。
- en: An interaction can be described formally by an exchange of promises about how
    the two sides will behave. Each side has the freedom to decide what it accepts
    from the other, though this is rarely properly acknowledged in human design including
    IT.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个交互可以通过关于双方行为的承诺交换形式描述。每一方都有决定接受对方什么的自由，尽管这在包括IT在内的人类设计中很少得到适当承认。
- en: '**Client**:'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端**：'
- en: Clients impose changes ad hoc at any time.
  id: totrans-split-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户随时自发进行更改。
- en: Clients promise to pay attention to and take responsibility for non-accepted
    (failed) data impositions signalled by the interloper.
  id: totrans-split-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户承诺关注并承担由干扰者标记的非接受（失败）的数据强加。
- en: '**db** :'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库**：'
- en: A virtual db connection accepts only read/write/change commands from the interloper
    and sleeps in between such events.
  id: totrans-split-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟数据库连接仅接受来自干扰者的读/写/更改命令，并在此类事件之间进入休眠状态。
- en: The db signals the interloper of success/failure for any attempted read/write
    as its virtual client.
  id: totrans-split-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库作为其虚拟客户端，向干扰者信号成功/失败的任何尝试读取/写入。
- en: '**Interloper**:'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**干扰者**：'
- en: Our smart plumbing accepts read requests for the shared data if and only if
    the relevant records are up to date with all shared data changes logged by the
    interpolator, i.e. the private write queue for that database is empty. We don’t
    need to wait for irrelevant records.
  id: totrans-split-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的智能管道仅在相关记录已经通过干扰者记录的所有共享数据更改保持最新的情况下，接受对共享数据的读请求。我们无需等待无关记录。
- en: The interloper accepts new write requests to forward to its shared clients *if
    and only if* all active shared data connections confirm that they haven’t already
    received a prior command that might read or write relevant overlapping data (e.g.
    in a select/search of an affected value or a write to the affected value).
  id: totrans-split-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当所有活动共享数据连接确认尚未接收到可能读取或写入相关重叠数据的先前命令（例如在受影响值的选择/搜索或受影响值的写入中）时，干扰者才会接受新的写入请求转发给其共享客户。
- en: Accepted writes are queued in a single totally ordered queue shared by all active
    edge databases and are only removed when all databases have been updated.
  id: totrans-split-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受的写操作按顺序排队，存在一个由所有活动边缘数据库共享的完全有序队列中，并且只有在所有数据库更新完成后才会移除。
- en: The queue processes the commit requests (as private write queues) to each database
    and empties the queue as quickly as possible so that the affected records can
    be read again. It’s this granular locking that permits almost wait-free replication
    of consistent shared state,
  id: totrans-split-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该队列处理提交请求（作为各个数据库的私有写队列），并尽快清空队列，以便可以再次读取受影响的记录。正是这种粒度锁定使得几乎无需等待地复制一致的共享状态，
- en: The operations inform clients of success/failure for any attempted read/write,
    like a normal SQL API.
  id: totrans-split-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作通知客户有关任何尝试读取/写入的成功/失败，就像普通的SQL API一样。
- en: The interloper is now the gatekeeper of a single scaled truth–a smart data calibrator
    on a highly granular level. Its logic is determined entirely by conditional promises,
    like a causal supply chain. Everything flows normally unless the preconditions
    are not met. If no one is looking, there’s no pressure to deliver quickly. If
    there is a delivery failure somewhere, or there are crossed wires, no one can
    jump the queue or take out data that haven’t yet arrived.
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 干扰者现在是单一缩放真相的守门人——高度细粒度的智能数据校准器。其逻辑完全由条件承诺决定，就像因果供应链一样。除非前提条件未满足，否则一切正常流动。如果没有人关注，就没有快速交付的压力。如果某处出现交付失败，或者出现交叉的线路，没有人可以插队或取出尚未到达的数据。
- en: If one of the databases becomes unavailable (e.g. if it loses power or its network
    connection creating a “partition”) no harmful misalignment can be observed by
    any client, because the interloper disallows reads until everything is reported
    to be back in sync. Thus, when an orphaned receiver rejoins the collective, it
    has to catch up with the shared order before it can serve any affected data to
    its local clients. While cut off, attempts to write to the shared state would
    simply fail without blocking writes to remaining available destinations. No collisions
    can possibly occur as long as all changes are fed through the pipeline. Time effectively
    stops for clients until a partitioned database gets plugged back in. The interpolator
    acts as a master ledger for all changes, taking care of global order and regular
    semantics.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个数据库变得不可用（例如失去电源或其网络连接导致“分区”），任何客户端都不会观察到有害的错位，因为干扰者会禁止读取，直到一切报告回到同步状态。因此，当一个孤立的接收者重新加入集体时，它必须在为其本地客户端提供任何受影响数据之前追赶共享顺序。在被切断的同时，尝试写入共享状态将简单地失败，而不会阻止向其余可用目标写入。只要所有更改都通过管道传递，就不可能发生冲突。对客户端而言，时间实际上停止，直到分区数据库重新连接。插值器充当所有更改的主帐簿，负责全局顺序和常规语义的处理。
- en: 'Most solutions to the consensus/consistency problem don’t try to fully prevent
    misreads of data like this, because that would require some changes to established
    technology–and heaven forbid that we should inconvenience technologists to make
    a public safety improvement. It’s more common to offer limited help in avoiding
    the issue by posting “buyer beware” notices or recommendations for “best buy”
    service. That covers some legal disclaimers, which may cover many cases: after
    all, as network reliability improves, the probability of observing inconsistencies
    shrinks anyway. The biggest problem becomes one of simple negligence in coordinating
    updates across distributed copies.'
  id: totrans-split-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数解决一致性问题的方案并不试图完全防止此类数据误读，因为这需要对现有技术进行一些改变——但天哪，我们不愿意为了改善公共安全而使技术人员感到不便。更常见的是通过发布“买家注意”通知或“最佳购买”服务的推荐来提供有限的帮助以避免这个问题。这涵盖了一些法律免责声明，可能涵盖了许多情况：毕竟，随着网络可靠性的提高，观察到的不一致性的概率也在缩小。最大的问题变成了在分布式副本之间协调更新时的简单疏忽。
- en: Why is this different from master replication?
  id: totrans-split-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这与主复制有何不同？
- en: Our ideal scenario promises a *virtual scale model* of each *single data record*
    that we choose to track, made by connecting several databases together over a
    smart data pipeline. Causal change manages temporal order over arbitrary spatial
    separations, like a supply chain or pipeline. In the usual approach to database
    redundancy, replicas tend to reduce database throughput performance; here the
    opposite may actually be true.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的理想情景承诺每个我们选择跟踪的*单个数据记录*的*虚拟规模模型*，通过智能数据管道连接多个数据库。因果变化管理着任意空间分离的时间顺序，如供应链或管道。在传统的数据库冗余方法中，副本往往会降低数据库的吞吐性能；在这里，情况可能正好相反。
- en: What replica sets using Paxos and Raft propose is that you will literally deal
    with one master server and try to keep backup copies of an entire database aligned
    independently. When a master dies or fails, the clients try to decide on a new
    leader so that they are all talking to the same server. This leads to a delay
    in which no one can write. The skis come off!
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: Paxos 和 Raft 使用的副本集合提议，您将真正处理一个主服务器并尝试保持整个数据库备份副本独立对齐。当主服务器死亡或失败时，客户端尝试决定一个新的领导者，以便他们都在与同一服务器通信。这导致了一个延迟，在这段时间内没有人可以写入。滑雪板脱落了！
- en: There's no particular need to replicate a whole database if we only want to
    share a few records. Granularity is the answer to scalability and reliability.
  id: totrans-split-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们只想共享几条记录，没有特别需要复制整个数据库。粒度是可扩展性和可靠性的答案。
- en: This is not the end of the story…
  id: totrans-split-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这并不是故事的终结...
- en: All this is straightforward and it would surely be great if more people used
    this approach, but probabilities tend to argue against solving the problem. What
    our simple and obvious promise theoretic solution cannot do is make sense of the
    biggest problem we have with modern data stores, which is that they typically
    offer only *latest-value semantics*. The caching problem.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很简单，如果更多人采用这种方法肯定是很好的，但概率往往不支持解决问题。我们简单明了的承诺理论解决方案无法理解现代数据存储面临的最大问题，即它们通常只提供*最新值语义*。缓存问题。
- en: In IT, correct values are assumed to be the latest values. It’s a race to be
    last, because the last value wins by overwriting and obliterating what came before.
    So if you have an evil demon flooding the system with nonsense, you’re in trouble.
    We always live in the moment, even when we keep ledgers and transaction logs at
    some master location for forensics. Are we sure those logs are consistent? More
    importantly, are they a record of what everyone *intended*?
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在IT领域，我们假设正确的值是最新的值。这是一场争夺，因为最后的值通过覆盖和抹除之前的内容获胜。因此，如果有恶魔通过系统注入无意义的信息，那么就会有麻烦。即使我们保留总部位置的分类账和交易日志以进行取证，我们仍然生活在当下。我们确定这些日志一致吗？更重要的是，它们是否记录了每个人的*意图*？
- en: We still continue to design software that does not align change on a continuous
    basis across multiple locations. We see the world of data as if it were a perpetual
    snapshot, and we try to keep offline backups in sync by brute force as lagging
    snapshots. Most of our technologies fail to track their changes as *versions*
    of data records. We apply continuous [time-series databases](https://en.wikipedia.org/wiki/Time_series_database)
    (addressable logs) and [version control repositories](https://en.wikipedia.org/wiki/Repository_(version_control))
    (like git) for only a few specialised purposes at the edge.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍在继续设计软件，这些软件并不会在多个地点之间持续对齐变更。我们将数据世界看作永恒的快照，通过蛮力将离线备份与滞后的快照同步。大多数我们的技术未能将其更改跟踪为数据记录的*版本*。我们仅在边缘少数特定目的上应用连续的[时间序列数据库](https://en.wikipedia.org/wiki/Time_series_database)（可寻址日志）和[版本控制存储库](https://en.wikipedia.org/wiki/Repository_(version_control))（如git）。
- en: In our age of ubiquitous e-commerce, we want data services to be *available*
    all the time, not least for uninterrupted revenue. When restocking, we sometimes
    need to close the shop doors temporarily to avoid mishaps when moving stuff. We
    believe that continuous availability implies *instantaneous* and *simultaneous*
    change for everyone, but that’s not true. In reality, clients and updates come
    in bursts and each transaction takes a finite time (that we call *latency*) so
    what we do in the gaps between can go unnoticed. We should hope for these gaps
    when replicating data for backup, because replication is typically slow to catch
    up with continuous change and we fear the risks of having data that are out of
    essential alignment at a crucial moment.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个无处不在的电子商务时代，我们希望数据服务始终*可用*，以确保收入不受干扰。在补货时，有时我们需要暂时关闭店铺以避免搬运物品时的意外。我们相信持续可用性意味着对每个人都进行*即时*和*同时*的更改，但这并非如此。事实上，客户和更新会突然而至，每个事务都需要一定时间（我们称之为*延迟*），因此我们在空隙期间所做的事情可能被忽视。在备份数据时，我们应该希望这些间隙，因为复制通常很难跟上持续变化的步伐，我们担心在关键时刻数据不会对齐的风险。
- en: What remains is a modelling issue (one of imposition over promise), not a technology
    problem per se–but, luckily it’s a discussion for another snapshot in time.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的是一个建模问题（承诺的强加），并非技术问题本身——但幸运的是，这是另一个时间点的讨论话题。
- en: Additional references
  id: totrans-split-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他参考资料
- en: Scaling systems so that they keep the same kind of promises at every scale is
    discussed in my article about [Software Wind Tunnels](http://markburgess.org/blog_windtunnel.html),
    and in more detail in the [Treatise on Systems](http://markburgess.org/treatise.html).
  id: totrans-split-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我在关于[软件风洞](http://markburgess.org/blog_windtunnel.html)的文章中讨论了在各种规模下保持相同承诺的系统扩展问题，并在[系统论文](http://markburgess.org/treatise.html)中详细讨论了这个问题。
- en: This essay is based on a slimmed down version of [a paper I wrote with András
    Gerlits](https://www.researchgate.net/publication/359578461_Continuous_Integration_of_Data_Histories_into_Consistent_Namespaces)
    and served as a simple introduction to his software implementation.
  id: totrans-split-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这篇文章基于与[安德拉什·格利茨](https://www.researchgate.net/publication/359578461_Continuous_Integration_of_Data_Histories_into_Consistent_Namespaces)合作的论文简化版本，并作为他软件实现的简单介绍。
- en: '*If you need to help to solve this issue, I suggest reaching out to* [*András*](https://twitter.com/AndrasGerlits)
    *above or even me!*'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你需要帮助解决这个问题，我建议联系* [*安德拉什*](https://twitter.com/AndrasGerlits) *或者甚至是我！*'
- en: '[See the book](http://markburgess.org/treatise.html)'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[查看书籍](http://markburgess.org/treatise.html)'
