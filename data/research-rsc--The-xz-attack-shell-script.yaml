- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 12:50:19'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024年5月27日 12:50:19
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'research!rsc: The xz attack shell script'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'research!rsc: xz攻击shell脚本'
- en: 来源：[https://research.swtch.com/xz-script](https://research.swtch.com/xz-script)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://research.swtch.com/xz-script](https://research.swtch.com/xz-script)
- en: The xz attack shell script
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: xz攻击shell脚本
- en: Posted on Tuesday, April 2, 2024.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 发布于2024年4月2日星期二。
- en: Updated Wednesday, April 3, 2024.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 更新于2024年4月3日星期三。
- en: '[## Introduction](#introduction)'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 简介](#introduction)'
- en: Andres Freund [published the existence of the xz attack](https://www.openwall.com/lists/oss-security/2024/03/29/4)
    on 2024-03-29 to the public oss-security@openwall mailing list. The day before,
    he alerted Debian security and the (private) distros@openwall list. In his mail,
    he says that he dug into this after “observing a few odd symptoms around liblzma
    (part of the xz package) on Debian sid installations over the last weeks (logins
    with ssh taking a lot of CPU, valgrind errors).”
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: Andres Freund [公布了xz攻击的存在](https://www.openwall.com/lists/oss-security/2024/03/29/4)，于2024年3月29日发布到公共oss-security@openwall邮件列表中。一天前，他向Debian安全团队和（私人）distros@openwall邮件列表发出了警报。在他的邮件中，他说在“过去几周观察到Debian
    sid安装中liblzma（xz软件包的一部分）出现一些奇怪的症状（通过ssh登录消耗大量CPU，valgrind错误）”后，他深入研究了这个问题。
- en: 'At a high level, the attack is split in two pieces: a shell script and an object
    file. There is an injection of shell code during `configure`, which injects the
    shell code into `make`. The shell code during `make` adds the object file to the
    build. This post examines the shell script. (See also [my timeline post](xz-timeline).)'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，攻击分为两部分：一个shell脚本和一个目标文件。在`configure`期间注入了shell代码，这些代码将shell代码注入到`make`中。在`make`期间，shell代码将目标文件添加到构建中。本文将详细检查shell脚本。（另请参阅[我的时间线帖子](xz-timeline)。）
- en: The nefarious object file would have looked suspicious checked into the repository
    as `evil.o`, so instead both the nefarious shell code and object file are embedded,
    compressed and encrypted, in some binary files that were added as “test inputs”
    for some new tests. The test file directory already existed from long before Jia
    Tan arrived, and the README explained “This directory contains bunch of files
    to test handling of .xz, .lzma (LZMA_Alone), and .lz (lzip) files in decoder implementations.
    Many of the files have been created by hand with a hex editor, thus there is no
    better "source code" than the files themselves.” This is a fact of life for parsing
    libraries like liblzma. The attacker looked like they were just [adding a few
    new test files](https://git.tukaani.org/?p=xz.git;a=commitdiff;h=cf44e4b7f5dfdbf8c78aef377c10f71e274f63c0).
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那个恶意的目标文件如果以`evil.o`的形式提交到仓库中会显得很可疑，因此恶意shell代码和目标文件都被嵌入、压缩和加密在一些二进制文件中，这些文件被添加为“某些新测试”的“测试输入”。测试文件目录早在贾谭到来之前就已经存在，并且README解释道：“这个目录包含了用来测试解码器实现中.xz、.lzma（LZMA_Alone）和.lz（lzip）文件处理的一堆文件。许多文件是通过十六进制编辑器手动创建的，因此没有比文件本身更好的‘源代码’。”
    这对于像liblzma这样的解析库来说是生活的一部分。攻击者看起来只是在[添加一些新的测试文件](https://git.tukaani.org/?p=xz.git;a=commitdiff;h=cf44e4b7f5dfdbf8c78aef377c10f71e274f63c0)。
- en: Unfortunately the nefarious object file turned out to have a bug that caused
    problems with Valgrind, so the test files needed to be updated to add the fix.
    [That commit](https://git.tukaani.org/?p=xz.git;a=commitdiff;h=74b138d2a6529f2c07729d7c77b1725a8e8b16f1)
    explained “The original files were generated with random local to my machine.
    To better reproduce these files in the future, a constant seed was used to recreate
    these files.” The attackers realized at this point that they needed a better update
    mechanism, so the new nefarious script contains an extension mechanism that lets
    it look for updated scripts in new test files, which wouldn’t draw as much attention
    as rewriting existing ones.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，那个恶意的目标文件出现了一个导致Valgrind出现问题的错误，因此需要更新测试文件以添加修复。[该提交](https://git.tukaani.org/?p=xz.git;a=commitdiff;h=74b138d2a6529f2c07729d7c77b1725a8e8b16f1)解释道：“原始文件是在我的机器上生成的随机本地文件。为了将来更好地复制这些文件，使用了一个恒定的种子来重新创建这些文件。”
    攻击者意识到他们需要一个更好的更新机制，因此新的恶意脚本包含了一个扩展机制，允许它在新的测试文件中寻找更新的脚本，这不会像重写现有文件那样引起太多注意。
- en: The effect of the scripts is to arrange for the nefarious object file’s `_get_cpuid`
    function to be called as part of a [GNU indirect function](https://sourceware.org/glibc/wiki/GNU_IFUNC)
    (ifunc) resolver. In general these resolvers can be called lazily at any time
    during program execution, but for security reasons it has become popular to call
    all of them during dynamic linking (very early in program startup) and then map
    the [global offset table (GOT) and procedure linkage table (PLT) read-only](https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html),
    to keep buffer overflows and the like from being able to edit it. But a nefarious
    ifunc resolver would run early enough to be able to edit those tables, and that’s
    exactly what the backdoor introduced. The resolver then looked through the tables
    for `RSA_public_decrypt` and replaced it with a nefarious version that [runs attacker
    code when the right SSH certificate is presented](https://github.com/amlweems/xzbot).[](#configure)
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本的效果是安排使恶意对象文件的`_get_cpuid`函数作为[GNU间接函数](https://sourceware.org/glibc/wiki/GNU_IFUNC)（ifunc）解析器的一部分调用。一般来说，这些解析器可以在程序执行的任何时候懒惰地调用，但基于安全原因，调用它们在动态链接期间（程序启动的早期阶段）全部调用已变得很流行，然后将[全局偏移表（GOT）和过程链接表（PLT）设置为只读](https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html)，以防止缓冲区溢出等能够编辑它。但恶意的ifunc解析器会早到足以编辑这些表，这正是后门引入的。然后，解析器会浏览这些表，寻找`RSA_public_decrypt`，并用一个恶意版本替换它，当正确的SSH证书被呈现时运行攻击者的代码。[链接](https://github.com/amlweems/xzbot)[](#configure)
- en: '[Configure](#configure)'
  id: totrans-split-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[配置](#configure)'
- en: Again, this post looks at the script side of the attack. Like most complex Unix
    software, xz-utils uses GNU autoconf to decide how to build itself on a particular
    system. In ordinary operation, autoconf reads a `configure.ac` file and produces
    a `configure` script, perhaps with supporting m4 files brought in to provide “libraries”
    to the script. Usually, the `configure` script and its support libraries are only
    added to the tarball distributions, not the source repository. The xz distribution
    works this way too.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，这篇文章将重点放在攻击的脚本方面。与大多数复杂的Unix软件一样，xz-utils使用GNU autoconf来决定如何在特定系统上构建自身。在普通操作中，autoconf会读取一个`configure.ac`文件，并生成一个`configure`脚本，可能还会引入支持脚本文件以提供“库”给该脚本。通常情况下，`configure`脚本及其支持库只会添加到tarball分发包中，而不会添加到源代码库中。xz分发包也是这样工作的。
- en: 'The attack kicks off with the attacker adding an unexpected support library,
    `m4/build-to-host.m4` to the xz-5.6.0 and xz-5.6.1 tarball distributions. Compared
    to the standard `build-to-host.m4`, the attacker has made the following changes:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击由攻击者向xz-5.6.0和xz-5.6.1的tarball分发中添加了一个意外的支持库`m4/build-to-host.m4`开始。与标准的`build-to-host.m4`相比，攻击者做出了以下更改：
- en: '[PRE0]'
  id: totrans-split-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All in all, this is a fairly plausible set of diffs, in case anyone thought
    to check. It bumps the version number, updates the copyright year to look current,
    and makes a handful of inscrutable changes that don’t look terribly out of place.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这是一组相当可信的差异，如果有人想检查的话。它提升了版本号，更新了版权年份以显得当前，并做了一些看起来不是很出格的难以理解的改变。
- en: Looking closer, something is amiss. Starting near the bottom,
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看，有些地方不对劲。从底部开始，
- en: '[PRE1]'
  id: totrans-split-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s see which files in the distribution match the pattern (simplifying the
    `grep` command):'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看分发中与模式匹配的文件有哪些（简化`grep`命令）：
- en: '[PRE2]'
  id: totrans-split-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s surprising! So this script sets `gl_am_configmake=./tests/files/bad-3-corrupt_lzma2.xz`
    and `HAVE_PKG_CONFIGMAKE=1`. The `gl_path_map` setting is a [tr(1)](https://linux.die.net/man/1/tr)
    command that swaps tabs and spaces and swaps underscores and dashes.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这令人惊讶！因此，此脚本设置了`gl_am_configmake=./tests/files/bad-3-corrupt_lzma2.xz`和`HAVE_PKG_CONFIGMAKE=1`。`gl_path_map`设置是一个[tr(1)](https://linux.die.net/man/1/tr)命令，它交换制表符和空格，并交换下划线和破折号。
- en: Now reading the top of the script,
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在阅读脚本的顶部，
- en: '[PRE3]'
  id: totrans-split-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: extracts the final dot-separated element of that filename, leaving `xz`. That
    is, it’s the file name suffix, not a prefix, and it is the name of the compression
    command that is likely already installed on any build machine.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从该文件名中提取最后的点分隔元素，留下`xz`。也就是说，这是文件名的后缀，不是前缀，并且它是压缩命令的名称，很可能已经安装在任何构建机器上。
- en: 'The next section is:'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节是：
- en: '[PRE4]'
  id: totrans-split-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We know that `gl_am_configmake=./tests/files/bad-3-corrupt_lzma2.xz`, so this
    sets the `gl_[$1]_config` variable to the string
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`gl_am_configmake=./tests/files/bad-3-corrupt_lzma2.xz`，因此将这个`gl_[$1]_config`变量设置为该字符串
- en: '[PRE5]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At first glance, especially in the original quoted form, the `sed` command looks
    like it has something to do with line endings, but in fact `r\n` is the `sed`
    “read from file `\n`” command. Since the file `\n` does not exist, the command
    does nothing at all, and then since `sed` has not been invoked with the `-n` option,
    `sed` prints each line of input. So `sed "r\n"` is just an obfuscated `cat` command,
    and remember that `$gl_path_map` is the `tr` command from before, and `$gl_[$1]_prefix`
    is `xz`. To the shell, this command is really
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，特别是在原始引用形式中，`sed`命令看起来似乎与行尾有关，但实际上`r\n`是`sed`的“从文件`\n`读取”命令。由于文件`\n`不存在，该命令根本不起作用，然后由于`sed`没有以`-n`选项调用，`sed`打印输入的每一行。所以`sed
    "r\n"`只是一个混淆的`cat`命令，并记住`$gl_path_map`是之前的`tr`命令，而`$gl_[$1]_prefix`是`xz`。对于shell来说，这个命令实际上是
- en: '[PRE6]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But right now it’s still just a string; it hasn’t been run. That changes with
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在它仍然只是一个字符串；它还没有被运行。这将在以下更改后发生
- en: '[PRE7]'
  id: totrans-split-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The final `"eval \$gl_[$1]_config"` runs that command. If we run it on the
    xz 5.6.0 repo, we get:'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`"eval \$gl_[$1]_config"`运行该命令。如果我们在xz 5.6.0仓库上运行它，我们会得到：
- en: '[PRE8]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I have inserted some line breaks, here and in later script fragments, to keep
    the lines from being too long in the web page.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经插入了一些换行符，这样在网页中行不会太长。
- en: 'Why the Hello and World? The README text that came with the test file describes
    it:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有Hello和World？随测试文件附带的README文本有所描述：
- en: bad-3-corrupt_lzma2.xz has three Streams in it. The first and third streams
    are valid xz Streams. The middle Stream has a correct Stream Header, Block Header,
    Index and Stream Footer. Only the LZMA2 data is corrupt. This file should decompress
    if `--single-stream` is used.
  id: totrans-split-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bad-3-corrupt_lzma2.xz文件包含三个流。第一个和第三个流是有效的xz流。中间的流具有正确的流头、块头、索引和流尾。只有LZMA2数据损坏了。如果使用`--single-stream`选项，该文件应该可以解压缩。
- en: The first and third streams are the Hello and World, and the middle stream has
    been corrupted by swapping the byte values unswapped by the `tr` command.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第三个流是Hello和World，而中间的流由于`tr`命令交换了字节值而被损坏。
- en: 'Recalling that xz 5.6.1 shipped with different “test” files, we can also try
    xz 5.6.1:'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下，xz 5.6.1附带了不同的“测试”文件，我们也可以尝试xz 5.6.1：
- en: '[PRE9]'
  id: totrans-split-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first difference is that the script makes sure (very sure!) to exit if not
    being run on Linux. The second difference is that the long “`export i`” line deviates
    in the final head command offset (724 vs 939) and then the tail offset and the
    `tr` argument. Let’s break those down.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个不同之处在于脚本确保（非常确保！）如果不在Linux上运行则退出。第二个不同之处在于长的“`export i`”行在最终的head命令偏移量（724
    vs 939）以及tail偏移量和`tr`参数中有所不同。让我们分析一下这些。
- en: 'The `head` command prints a prefix of its input. Let’s look at the start:'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`命令打印其输入的前缀。让我们来看看开头：'
- en: '[PRE10]'
  id: totrans-split-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This discards the first kilobyte of standard input, prints the next two kilobytes,
    discards the next kilobyte, and prints the next two kilobytes. And so on. The
    whole command for 5.6.1 is:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将丢弃标准输入的第一个千字节，打印接下来的两千字节，丢弃下一个千字节，然后打印接下来的两千字节。xz 5.6.1的完整命令是
- en: '[PRE11]'
  id: totrans-split-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The shell variable `i` is set to this long command. Then the script runs:'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: shell变量`i`被设置为这个长命令。然后脚本运行：
- en: '[PRE12]'
  id: totrans-split-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first `xz` command uncompresses another malicious test file. The `eval`
    then runs the `head` pipeline, extracting a total of 16×2048+939 = 33,707 bytes.
    Then the `tail` command keeps only the final 31,233 bytes. The `tr` command applies
    a simple substitution cipher to the output (so that just in case anyone thought
    to pull these specific byte ranges out of the file, they wouldn’t recognize it
    as a valid lzma input!?). The second `xz` command decodes the translated bytes
    as a raw lzma stream, and then of course the result is piped through the shell.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`xz`命令解压了另一个恶意测试文件。然后`eval`运行`head`管道，提取了16×2048+939 = 33,707字节。接着`tail`命令仅保留最后的31,233字节。`tr`命令对输出应用了简单的替换密码（以防有人想要从文件中提取这些特定的字节范围，他们将无法识别它作为有效的lzma输入！？）。第二个`xz`命令将翻译后的字节解码为原始的lzma流，然后当然结果通过shell管道处理。
- en: Skipping the shell pipe, we can run this, obtaining a very long shell script.
    I have added commentary in between sections of the output.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过shell管道，我们可以运行这个命令，得到一个非常长的shell脚本。我在输出的各个部分之间添加了评论。
- en: '[PRE13]'
  id: totrans-split-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So far, setting up environment variables.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，设置环境变量。
- en: '[PRE14]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A line that only appears in 5.6.1, exiting when not run on Linux. In general
    the scripts in 5.6.0 and 5.6.1 are very similar: 5.6.1 has a few additions. We
    will examine the 5.6.1 script, with the additions marked. This line is an attempted
    robustness fix with a bug (pointed out by Jakub Wilk): there are no spaces around
    the `=`, making the line a no-op.'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只出现在 5.6.1 版本中的行，在非 Linux 系统上运行时退出。一般来说，5.6.0 和 5.6.1 版本的脚本非常相似：5.6.1 有一些额外的添加。我们将检查
    5.6.1 版本的脚本，并标记添加部分。这行是一个尝试的健壮性修复，但存在一个错误（Jakub Wilk 指出）：`= `周围没有空格，使该行成为一个无操作。
- en: '[PRE15]'
  id: totrans-split-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first of many odd eval statements, for variables that do not appear to
    be set anywhere. One possibility is that these are debug prints: when the attacker
    is debugging the script, setting, say, `zrKcVq=env` inserts a debug print during
    execution. Another possibility is that these are extension points that can be
    set by some other mechanism, run before this code, in the future.'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条奇怪的评估语句，用于那些看起来没有设置的变量。一种可能性是这些是调试打印语句：当攻击者调试脚本时，设置，比如 `zrKcVq=env` 在执行期间插入一个调试打印。另一种可能性是这些是可以由其他机制设置的扩展点，在将来运行在这段代码之前。
- en: '[PRE16]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If `config.status` exists, we read various variables from it into the shell,
    along with two extension points. Note that we are still inside the config.status
    check (let’s call it “if #1”) as we continue through the output.'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: '如果存在 `config.status`，我们从中读取各种变量到 shell 中，以及两个扩展点。请注意，我们仍然在 config.status 检查内部（我们称之为“if
    #1”），当我们继续处理输出时。'
- en: '[PRE17]'
  id: totrans-split-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This section is entirely new in 5.6.1\. It looks for a single test file to contain
    the magic texts `'~!:_ W'` and `'|_!{ -'`, extracts the bytes between them, applies
    a substitution cipher, decompresses the result, and evaluates the output as a
    shell script. This appears to be an extension mechanism, so that the next time
    changes are needed in this script, a new script can be added in a different test
    file, instead of having to [make up reasons to regenerate existing binary test
    files](https://git.tukaani.org/?p=xz.git;a=commitdiff;h=74b138d2a6529f2c07729d7c77b1725a8e8b16f1).
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分在 5.6.1 版本中完全是新内容。它寻找一个单独的测试文件，包含魔术文本 `'~!:_ W'` 和 `'|_!{ -'`，提取它们之间的字节，应用替代密码，解压缩结果，并评估输出为一个
    shell 脚本。这似乎是一个扩展机制，所以下次需要在这个脚本中进行更改时，可以在不同的测试文件中添加新脚本，而不是[编造理由重新生成现有的二进制测试文件](https://git.tukaani.org/?p=xz.git;a=commitdiff;h=74b138d2a6529f2c07729d7c77b1725a8e8b16f1)。
- en: The next chunk continues with script that was present in 5.6.0.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块继续使用在 5.6.0 版本中存在的脚本。
- en: '[PRE18]'
  id: totrans-split-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Two different checks that [GNU indirect function](https://maskray.me/blog/2021-01-18-gnu-indirect-function)
    support is enabled. If not, stop the script. The backdoor requires this functionality.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 两个不同的检查，确保启用了 [GNU indirect function](https://maskray.me/blog/2021-01-18-gnu-indirect-function)
    支持。如果没有，则停止脚本。后门需要此功能。
- en: '[PRE19]'
  id: totrans-split-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Require shared library support.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要求支持共享库。
- en: '[PRE20]'
  id: totrans-split-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Require an x86-64 Linux system.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要求一个 x86-64 Linux 系统。
- en: '[PRE21]'
  id: totrans-split-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Require all the crc ifunc code (in case it has been patched out?).
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要求所有 crc ifunc 代码（万一已经被修补？）。
- en: '[PRE22]'
  id: totrans-split-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Require gcc (not clang, I suppose) and GNU ld.
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要求使用 gcc（不是 clang，我想），以及 GNU ld。
- en: '[PRE23]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Require the backdoor-containing test files. Of course, if these files didn’t
    exist, it’s unclear how we obtained this script in the first place, but better
    safe than sorry, I suppose.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要求包含后门的测试文件。当然，如果这些文件不存在，不清楚我们如何首次获得这个脚本，但我想宁愿安全也不要后悔。
- en: '[PRE24]'
  id: totrans-split-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add a bunch of checks when the file `debian/rules` exists or `$RPM_ARCH` is
    set to `x86_64`. Note that we are now inside two `if` statements: the `config.status`
    check above, and this one (let’s call it “if #2”).'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: '添加一堆检查，当文件 `debian/rules` 存在或者 `$RPM_ARCH` 设置为 `x86_64`。请注意，我们现在在两个 `if` 语句内部：上面的
    config.status 检查，以及这个（我们称之为“if #2”）。'
- en: '[PRE25]'
  id: totrans-split-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Check that `liblzma/Makefile` contains all the lines that will be used as anchor
    points later for inserting new text into the Makefile.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `liblzma/Makefile` 是否包含所有将用作将新文本插入 Makefile 锚点的行。
- en: '[PRE26]'
  id: totrans-split-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`$O` was set at the very start of the script. This is checking that the libtool
    file, presumably generated during the build process, configures the compiler for
    a PIC (position independent code) build.'
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`$O` 在脚本的开头设置。这是检查 libtool 文件是否在构建过程中生成，为 PIC（位置独立代码）构建配置编译器。'
- en: '[PRE27]'
  id: totrans-split-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`$U` was also set at the start of the script: `U="bad-3-corrupt_lzma2.xz"`.
    Real work is starting!'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`$U` 也在脚本的开头设置为：`U="bad-3-corrupt_lzma2.xz"`。真正的工作开始了！'
- en: '[PRE28]'
  id: totrans-split-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`sed -i` runs an in-place modification of the input file, in this case `liblzma/Makefile`.
    Specifically, find the `ACLOCAL_M4` line we grepped for earlier (`/$j/`) and insert
    the `am__test` setting from `$b` (`i$b`).'
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed -i` 对输入文件进行原地修改，在本例中是 `liblzma/Makefile`。具体来说，找到我们之前用 `/$j/` grep 的 `ACLOCAL_M4`
    行，并从 `$b` 中插入 `am__test` 设置 (`i$b`)。'
- en: '[PRE29]'
  id: totrans-split-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Shell quoting inside a quoted string inside a Makefile really is something special.
    This is escaping the backslashes in the tr command enough times that it will work
    to insert them into the Makefile after the `am__install_max` line (`$w`).
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 中一个引用字符串中的 Shell 引用确实是非常特殊的。这是通过在 `tr` 命令中适当多次转义反斜杠，使其在 `am__install_max`
    行后能够插入到 Makefile 中的操作。
- en: '[PRE30]'
  id: totrans-split-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'More added lines. It’s worth stopping for a moment to look at what’s happened
    so far. The script has added these lines to `src/liblzma/Makefile`:'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多的行。停下来看看到目前为止发生了什么是值得的。脚本已将以下行添加到 `src/liblzma/Makefile` 中：
- en: '[PRE31]'
  id: totrans-split-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'These look plausible but fall apart under closer examination: for example,
    `am__test_dir` is a file, not a directory. The goal here seems to be that after
    `configure` has run, the generated `Makefile` still looks plausibly inscrutable.
    And the lines have been added in scattered places throughout the `Makefile`; no
    one will see them all next to each other like in this display. Back to the script:'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些看起来很合理，但在仔细检查下就会破绽百出：例如，`am__test_dir` 是一个文件，而不是一个目录。这里的目标似乎是在 `configure`
    运行后，生成的 `Makefile` 仍然看起来像是难以理解的。而且这些行被分散地添加到 `Makefile` 的各个地方；没有人会像在这里的展示中那样看到它们全部在一起。回到脚本本身：
- en: '[PRE32]'
  id: totrans-split-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Add `liblzma_la_LDFLAGS += -Wl,--sort-section=name,-X` to the Makefile. If the
    `LDFLAGS` do not already say `-z,now` or `-Wl,now`, add `-z,now`.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Makefile 中添加 `liblzma_la_LDFLAGS += -Wl,--sort-section=name,-X`。如果 `LDFLAGS`
    中没有 `-z,now` 或 `-Wl,now`，则添加 `-z,now`。
- en: 'The “`-Wl,now`” forces `LD_BIND_NOW` behavior, in which the dynamic loader
    resolves all symbols at program startup time. One reason this is normally done
    is for security: it makes sure that the global offset table and procedure linkage
    tables can be marked read-only early in process startup, so that buffer overflows
    or write-after-free bugs cannot target those tables. However, it also has the
    effect of running GNU indirect function (ifunc) resolvers at startup during that
    resolution process, and the backdoor arranges to be called from one of those.
    This early invocation of the backdoor setup lets it run while the tables are still
    writable, allowing the backdoor to replace the entry for `RSA_public_decrypt`
    with its own version. But we are getting ahead of ourselves. Back to the script:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: “`-Wl,now`” 强制 `LD_BIND_NOW` 行为，在程序启动时动态加载器解析所有符号。通常这样做的一个原因是出于安全考虑：它确保全局偏移表和过程链接表在进程启动早期就能被标记为只读，从而防止缓冲区溢出或释放后写入错误的问题。然而，这也会在启动过程中运行
    GNU 间接函数（ifunc）解析器，并且后门会安排在其中一个解析过程中被调用。这种早期调用后门设置允许它在表仍然可写时运行，从而使后门可以替换 `RSA_public_decrypt`
    的入口为自己的版本。但我们得回到脚本本身：
- en: '[PRE33]'
  id: totrans-split-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We checked earlier that the libtool file said `pic_flag=" -fPIC -DPIC"`. The
    sed command changes it to read `pic_flag=" -fPIC -DPIC -fno-lto -ffunction-sections
    -fdata-sections"`.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前检查了 libtool 文件中是否说 `pic_flag=" -fPIC -DPIC"`。sed 命令将其修改为 `pic_flag=" -fPIC
    -DPIC -fno-lto -ffunction-sections -fdata-sections"`。
- en: It is not clear why these additional flags are important, but in general they
    disable linker optimizations that could plausibly get in the way of subterfuge.
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 并不清楚这些额外标志为何如此重要，但通常它们会禁用链接器优化，这可能会妨碍诡计。
- en: '[PRE34]'
  id: totrans-split-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Shell quoting continues to be trippy, but we’ve reached the final change. This
    adds the line
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 引用继续令人迷惑，但我们已经达到最终的更改。这添加了以下一行：
- en: '[PRE35]'
  id: totrans-split-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: to one place in the Makefile, and then adds a long script that sets up some
    variables, entirely as misdirection, that ends with
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到 Makefile 的一个地方，然后添加一个设置了一些变量的长脚本，完全是误导，以以下内容结尾：
- en: '[PRE36]'
  id: totrans-split-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `sed rpath` command is just as much an obfuscated `cat` as `sed "r\n"`
    was, but `-rpath` is a very common linker flag, so at first glance you might not
    notice it’s next to the wrong command. Recalling the `am__test` and related lines
    added above, this pipeline ends up being equivalent to:'
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed rpath` 命令和 `sed "r\n"` 一样是一个模糊的 `cat`，但 `-rpath` 是一个非常常见的链接标志，所以乍一看你可能不会注意到它跟错误的命令在一起。回想起前面添加的
    `am__test` 和相关行，这个管道最终相当于：'
- en: '[PRE37]'
  id: totrans-split-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our old friend! We know what this does, though. It runs the very script we are
    currently reading in this post. [How recursive!](https://research.swtch.com/zip)[](#make)
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的老朋友！我们知道这样做的原因，尽管如此。它运行了我们当前在这篇文章中阅读的脚本本身。[多么递归！](https://research.swtch.com/zip)[](#make)
- en: '[Make](#make)'
  id: totrans-split-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Make](#make)'
- en: 'Instead of running during `configure` in the tarball root directory, let''s
    mentally re-execute the script as it would run during `make` in the `liblzma`
    directory. In that context, the variables at the top have been set, but all the
    editing we just considered was skipped over by “if #1” not finding `./config.status`.
    Now let''s keep executing the script.'
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'Instead of running during `configure` in the tarball root directory, let''s
    mentally re-execute the script as it would run during `make` in the `liblzma`
    directory. In that context, the variables at the top have been set, but all the
    editing we just considered was skipped over by “if #1” not finding `./config.status`.
    Now let''s keep executing the script.'
- en: '[PRE38]'
  id: totrans-split-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That `fi` closes “if #2”, which checked for a Debian or RPM build. The upcoming
    `elif` continues “if #1”, which checked for config.status, meaning now we are
    executing the part of the script that matters when run during `make` in the `liblzma`
    directory:'
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'That `fi` closes “if #2”, which checked for a Debian or RPM build. The upcoming
    `elif` continues “if #1”, which checked for config.status, meaning now we are
    executing the part of the script that matters when run during `make` in the `liblzma`
    directory:'
- en: '[PRE39]'
  id: totrans-split-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If we see the built objects for the crc code, we are running as part of `make`.
    Run the following code.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: If we see the built objects for the crc code, we are running as part of `make`.
    Run the following code.
- en: '[PRE40]'
  id: totrans-split-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We start this section with another extension hook. This time the magic strings
    are `'jV!.^%'` and `'%.R.1Z'`. As before, there are no test files with these strings.
    This was for future extensibility.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: We start this section with another extension hook. This time the magic strings
    are `'jV!.^%'` and `'%.R.1Z'`. As before, there are no test files with these strings.
    This was for future extensibility.
- en: 'On to the code shared with 5.6.0:'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'On to the code shared with 5.6.0:'
- en: '[PRE41]'
  id: totrans-split-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Check that the ifunc-enabled CRC source files look right. Interestingly, Lasse
    Collin renamed `crc_clmul.c` to `crc_x86_clmul.h` [on 2024-01-11](https://git.tukaani.org/?p=xz.git;a=commit;h=419f55f9dfc2df8792902b8953d50690121afeea).
    One has to assume that the person or team behind “Jia Tan” had been working on
    all this code well before then and that the first version checked `crc_clmul.c`.
    They were probably very annoyed when Lasse Collin accidentally broke their in-development
    backdoor by cleaning up the file names!
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: Check that the ifunc-enabled CRC source files look right. Interestingly, Lasse
    Collin renamed `crc_clmul.c` to `crc_x86_clmul.h` [on 2024-01-11](https://git.tukaani.org/?p=xz.git;a=commit;h=419f55f9dfc2df8792902b8953d50690121afeea).
    One has to assume that the person or team behind “Jia Tan” had been working on
    all this code well before then and that the first version checked `crc_clmul.c`.
    They were probably very annoyed when Lasse Collin accidentally broke their in-development
    backdoor by cleaning up the file names!
- en: '[PRE42]'
  id: totrans-split-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Check that the build configuration has the extra flags we added before.
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: Check that the build configuration has the extra flags we added before.
- en: '[PRE43]'
  id: totrans-split-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Check that no one has added `lazy` to the linker options, which might override
    the `-Wl,now`. (This code really needs to run before the tables it patches get
    marked read-only!)
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: Check that no one has added `lazy` to the linker options, which might override
    the `-Wl,now`. (This code really needs to run before the tables it patches get
    marked read-only!)
- en: '[PRE44]'
  id: totrans-split-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is selecting between two different offset values depending on the content
    of `gettext.m4`. The distributed xz tarballs do not contain that string in `gettext.m4`
    (it does appear in `build-to-host.m4`), so the `grep` finds nothing, `$Y` is the
    empty string, and the true case of the `if` executes: `N=0` and `W=88792`.'
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'This is selecting between two different offset values depending on the content
    of `gettext.m4`. The distributed xz tarballs do not contain that string in `gettext.m4`
    (it does appear in `build-to-host.m4`), so the `grep` finds nothing, `$Y` is the
    empty string, and the true case of the `if` executes: `N=0` and `W=88792`.'
- en: '[PRE45]'
  id: totrans-split-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'I inserted a line break here. Remember the “corrupt” test file script set `i`
    to the large head pipeline? It’s still set here, being used inside the script
    extracted from that pipeline. Before, the pipeline extracted 33,707 bytes and
    then we used the final 31,233 bytes. Now we are using the entire thing, which
    probably means just the prefix that we skipped before. The sed command is inserting
    a newline after every byte of that output, setting up for piping into the remainder
    of the command line:'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'I inserted a line break here. Remember the “corrupt” test file script set `i`
    to the large head pipeline? It’s still set here, being used inside the script
    extracted from that pipeline. Before, the pipeline extracted 33,707 bytes and
    then we used the final 31,233 bytes. Now we are using the entire thing, which
    probably means just the prefix that we skipped before. The sed command is inserting
    a newline after every byte of that output, setting up for piping into the remainder
    of the command line:'
- en: '[PRE46]'
  id: totrans-split-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I inserted another line break here. What is this? [@nugxperience on Twitter
    recognized it](https://twitter.com/nugxperience/status/1773906926503591970) as
    an RC4-like decryption function, implemented in awk! Apparently the `tr`-based
    substitution cipher wasn’t secure enough for this step. This is the 5.6.1 version;
    the 5.6.0 version is the same except that the second loop counts to 4096 instead
    of 8192.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: I inserted another line break here. What is this? [@nugxperience on Twitter
    recognized it](https://twitter.com/nugxperience/status/1773906926503591970) as
    an RC4-like decryption function, implemented in awk! Apparently the `tr`-based
    substitution cipher wasn’t secure enough for this step. This is the 5.6.1 version;
    the 5.6.0 version is the same except that the second loop counts to 4096 instead
    of 8192.
- en: 'Back to the script:'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'Back to the script:'
- en: '[PRE47]'
  id: totrans-split-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We finally made it to the end of this long line. The decrypted output is piped
    through xz to decompress it; the `--single-stream` flag says to stop at the end
    of the first xz EOF marker instead of looking for additional files on standard
    input. This avoids reading the section of the input that we extracted with the
    `tail` command before. Then the decompressed data is piped through a `head` pair
    that extracts either the full 88,792 byte input or zero bytes, depending on `gettext.m4`
    from before, and writes it to `liblzma_la-crc64-fast.o`. In our build, we are
    taking the full input.
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于走到了这条长线的末端。解密的输出通过 xz 传输进行解压；`--single-stream` 标志指示停止在第一个 xz EOF 标记处，而不是在标准输入中寻找其他文件。这避免了读取之前用
    `tail` 命令提取的输入部分。然后，解压的数据通过 `head` 对被抽取的完整的 88,792 字节输入或零字节进行了管道传输，并将其写入 `liblzma_la-crc64-fast.o`。在我们的构建中，我们接受了完整的输入。
- en: '[PRE48]'
  id: totrans-split-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If all that failed, stop quietly.
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些都失败了，请静静地停止。
- en: '[PRE49]'
  id: totrans-split-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Wait what? Oh! Notice the two different file names `crc64_fast` versus `crc64-fast`.
    And neither of these is the one we just extracted. These are in `.libs/`, and
    the one we extracted is in the current directory. This is backing up the real
    file (the underscored one) into a file with a very similar name (the hyphenated
    one).
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: 等等？哦！注意两个不同的文件名 `crc64_fast` 和 `crc64-fast`。而且这两个都不是我们刚提取的那个文件。这些位于 `.libs/`，而我们提取的是在当前目录。这将实际文件（带有下划线的文件）备份到一个文件名非常相似的文件（带有连字符的文件）。
- en: '[PRE50]'
  id: totrans-split-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This string `$V` begins with “`#endif`”, which is never a good sign. Let’s move
    on for now, but we’ll take a closer look at that text shortly.
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `$V` 以 “`#endif`” 开头，这绝不是一个好兆头。暂且不谈这个，我们稍后会仔细查看这段文本。
- en: '[PRE51]'
  id: totrans-split-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This `if` statement is running a pipeline of sed commands piped into `$CC` with
    the arguments `liblzma_la-crc64-fast.o` (adding that object as an input to the
    compiler) and `-x` `c` `-` (compile a C program from standard input). That is,
    it rebuilds an edited copy of `crc64_fast.c` (a real xz source file) and merges
    the extracted malicious `.o` file into the resulting object, overwriting the underscored
    real object file that would have been built originally for `crc64_fast.c`. The
    `sed` `1i` tells the compiler the file name to record in debug info, since the
    compiler is reading standard input—very tidy! But what are the edits?
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `if` 语句正在运行一系列的 `sed` 命令管道传输到 `$CC`，参数是 `liblzma_la-crc64-fast.o`（将该对象作为编译器的输入）和
    `-x` `c` `-`（从标准输入编译一个 C 程序）。也就是说，它重新构建了 `crc64_fast.c`（一个真实的 xz 源文件）的编辑副本，并将提取的恶意
    `.o` 文件合并到结果对象中，覆盖了原本为 `crc64_fast.c` 构建的带有下划线的真实对象文件。`sed` `1i` 告诉编译器在调试信息中记录文件名，因为编译器正在读取标准输入——非常整洁！但是这些修改是什么呢？
- en: 'The file starts out looking like:'
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: 文件一开始看起来是这样的：
- en: '[PRE52]'
  id: totrans-split-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The sed commands add an `_` prefix to the name of the function in the return
    condition, and then add `$V` after the `include` line, producing (with reformatting
    of the C code):'
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed` 命令在返回条件中为函数名称添加了 `_` 前缀，然后在 `include` 行之后添加了 `$V`，经过 C 代码的重新格式化：'
- en: '[PRE53]'
  id: totrans-split-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That is, the crc64_resolve function, which is the ifunc resolver that gets run
    early in dynamic loading, before the GOT and PLT have been marked read-only, is
    now calling the newly inserted `_is_arch_extension_supported`, which calls `_get_cpuid`.
    This still looks like plausible code, since this is pretty similar to [the real
    is_arch_extension_supported](https://git.tukaani.org/?p=xz.git;a=blob;f=src/liblzma/check/crc_x86_clmul.h;h=ae66ca9f8c710fd84cd8b0e6e52e7bbfb7df8c0f;hb=2d7d862e3ffa8cec4fd3fdffcd84e984a17aa429#l388).
    But `_get_cpuid` is provided by the backdoor .o, and it does a lot more before
    returning the cpuid information. In particular it rewrites the GOT and PLT to
    hijack calls to RSA_public_decrypt.
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，crc64_resolve 函数，这是在动态加载早期运行的 ifunc 解析器，在 GOT 和 PLT 被标记为只读之前，现在调用了新插入的
    `_is_arch_extension_supported`，后者调用了 `_get_cpuid`。这看起来仍然像是合理的代码，因为这与 [真实的 is_arch_extension_supported](https://git.tukaani.org/?p=xz.git;a=blob;f=src/liblzma/check/crc_x86_clmul.h;h=ae66ca9f8c710fd84cd8b0e6e52e7bbfb7df8c0f;hb=2d7d862e3ffa8cec4fd3fdffcd84e984a17aa429#l388)
    非常相似。但是 `_get_cpuid` 是由后门的 .o 提供的，它在返回 cpuid 信息之前做了更多操作。特别是重新编写了 GOT 和 PLT 以劫持对
    RSA_public_decrypt 的调用。
- en: 'But let’s get back to the shell script, which is still running from inside
    `src/liblzma/Makefile` and just successfully inserted the backdoor into `.libs/liblzma_la-crc64_fast.o`.
    We are now in the `if` compiler success case:'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但是让我们回到 shell 脚本，它仍在从 `src/liblzma/Makefile` 内部运行，并且成功地将后门插入到 `.libs/liblzma_la-crc64_fast.o`
    中。我们现在处于编译器成功的 `if` 情况：
- en: '[PRE54]'
  id: totrans-split-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This does the same thing for `crc32_fast.c`, except it doesn’t add the backdoored
    object code. We don’t want two copies of that in the build. It is unclear why
    the script bothers to intercept both the crc32 and crc64 ifuncs; either one should
    have sufficed. Perhaps they wanted the dispatch code for both to look similar
    in a debugger. Now we’re in the doubly nested `if` compiler success case:'
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这对 `crc32_fast.c` 做了同样的事情，只是它没有添加后门的目标代码。我们不希望在构建中有两份副本。不清楚为什么脚本要拦截 crc32 和
    crc64 的 ifuncs；任何一个都应该足够了。也许他们希望两者在调试器中的调度代码看起来类似。现在我们进入了双重嵌套的编译器成功情况的 `if` 分支：
- en: '[PRE55]'
  id: totrans-split-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If we can relink the .la file, then...
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以重新链接 .la 文件，那么...
- en: '[PRE56]'
  id: totrans-split-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If the relink succeeded but didn’t write the file, assume it failed and restore
    the backups.
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新链接成功但没有写入文件，则假设失败并恢复备份。
- en: '[PRE57]'
  id: totrans-split-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: No matter what, remove the libraries. (The `Makefile` link step is presumably
    going to happen next and recreate them.)
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，删除库文件。（`Makefile`链接步骤预计会在接下来进行并重新创建它们。）
- en: '[PRE58]'
  id: totrans-split-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is the `else` for the link failing. Restore from backups.
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是链接失败的情况。从备份中恢复。
- en: '[PRE59]'
  id: totrans-split-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now we are in the inner compiler success case. Delete backups.
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在内部编译器成功的情况。删除备份。
- en: '[PRE60]'
  id: totrans-split-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is the else for the crc32 compilation failing. Restore from backups.
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 crc32 编译失败的情况。从备份中恢复。
- en: '[PRE61]'
  id: totrans-split-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is the else for the crc64 compilation failing. Restore from backup. (This
    is not the cleanest shell script in the world!)
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 crc64 编译失败的情况。从备份中恢复。（这不是世界上最干净的 shell 脚本！）
- en: '[PRE62]'
  id: totrans-split-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now we are at the end of the Makefile section of the script. Delete the backup.
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们到了脚本的 Makefile 部分的结尾。删除备份。
- en: '[PRE63]'
  id: totrans-split-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Close the “`elif` we’re in a Makefile”, one more extension point/debug print,
    and we’re done! The script has injected the object file into the objects built
    during `make`, leaving no trace behind.
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭“`elif`我们在一个 Makefile 中”的分支，再加一个扩展点/调试打印，我们完成了！脚本已将目标文件注入到`make`期间构建的对象中，不留痕迹。
