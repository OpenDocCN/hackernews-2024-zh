- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ç±»ï¼šæœªåˆ†ç±»
- en: 'date: 2024-05-27 12:56:28'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024-05-27 12:56:28
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Dr George W Stagg - Fortran on WebAssembly
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: George W Stagg åšå£« - Fortran åœ¨ WebAssembly ä¸Šçš„åº”ç”¨
- en: æ¥æºï¼š[https://gws.phd/posts/fortran_wasm/](https://gws.phd/posts/fortran_wasm/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://gws.phd/posts/fortran_wasm/](https://gws.phd/posts/fortran_wasm/)
- en: Introduction
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç®€ä»‹
- en: '[Fortran](https://fortran-lang.org) is one of the oldest programming languages
    around. It first appeared in 1957, making it older than the C programming language,
    the Intel 4004 CPU, and even the IBM System/360 series of mainframe computers.
    Fortran was created at a time when the byte had just been invented, and computers
    were still made of vacuum tubes and frustration.'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[Fortran](https://fortran-lang.org) æ˜¯æœ€å¤è€çš„ç¼–ç¨‹è¯­è¨€ä¹‹ä¸€ã€‚å®ƒé¦–æ¬¡å‡ºç°äº 1957 å¹´ï¼Œæ—©äº C ç¼–ç¨‹è¯­è¨€ã€Intel
    4004 CPU ç”šè‡³ IBM System/360 ç³»åˆ—å¤§å‹è®¡ç®—æœºã€‚Fortran è¯ç”Ÿä¹‹æ—¶ï¼Œå­—èŠ‚åˆšåˆšé—®ä¸–ï¼Œè®¡ç®—æœºä»ç„¶é‡‡ç”¨çœŸç©ºç®¡ï¼Œæƒ…å†µè‰°éš¾ã€‚'
- en: Â¹Â The name is derived from *Formula Translator*. Fortran was originally stylised
    in all-caps, but modern Fortran has dropped it.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: Â¹Â åç§°æ¥æºäº *Formula Translator*ã€‚Fortran æœ€åˆæ˜¯å…¨å¤§å†™é£æ ¼ï¼Œä½†ç°ä»£ Fortran å·²ç»æ”¾å¼ƒäº†è¿™ç§å†™æ³•ã€‚
- en: Â²Â The System/360 was released around 1965\. The 4004 around 1970\. And [K&R
    C](https://en.wikipedia.org/wiki/The_C_Programming_Language) was published in
    1978.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: Â²Â System/360 å¤§çº¦åœ¨ 1965 å¹´å‘å¸ƒã€‚4004 åˆ™æ˜¯åœ¨ 1970 å¹´å·¦å³ã€‚è€Œ [K&R C](https://en.wikipedia.org/wiki/The_C_Programming_Language)
    åˆ™äº 1978 å¹´å‡ºç‰ˆã€‚
- en: Â³Â The argument goes that Fortranâ€™s lack of aliasing and use of native arrays
    rather than pointer arithmetic allow the optimiser to generate more efficient
    output than an equivalent C program. However, there are also counter-arguments
    against this.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: Â³Â æœ‰è§‚ç‚¹è®¤ä¸ºï¼ŒFortran çš„ç¼ºä¹åˆ«åå’Œä½¿ç”¨æœ¬åœ°æ•°ç»„è€Œä¸æ˜¯æŒ‡é’ˆç®—æœ¯ï¼Œä½¿å¾—ä¼˜åŒ–å™¨èƒ½å¤Ÿæ¯”ç­‰æ•ˆçš„ C ç¨‹åºç”Ÿæˆæ›´æœ‰æ•ˆç‡çš„è¾“å‡ºã€‚ä¸è¿‡ï¼Œä¹Ÿæœ‰åå¯¹æ„è§ã€‚
- en: Over the years, Fortran has formed a rich history of use for computationally
    intensive scientific and engineering applications. It has powered the fluid dynamics
    of weather prediction and climate models, provided the condensed matter simulations
    for my [PhD](../../docs/thesis_gws.pdf), and is still considered by some to be
    more efficient than C for numerically heavy work. The syntax of modern Fortran
    is also surprisingly easy to get up and running with. This is not your parentâ€™s
    FortranÂ 77 code; most restrictions that make fixedâ€‘form Fortran awful to use are
    no longer in place in modern Fortran.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: å¤šå¹´æ¥ï¼ŒFortran åœ¨ç§‘å­¦å’Œå·¥ç¨‹è®¡ç®—å¯†é›†åº”ç”¨ä¸­ç§¯ç´¯äº†ä¸°å¯Œçš„å†å²ã€‚å®ƒæ¨åŠ¨äº†å¤©æ°”é¢„æµ‹å’Œæ°”å€™æ¨¡å‹çš„æµä½“åŠ¨åŠ›å­¦ï¼Œä¸ºæˆ‘çš„ [åšå£«è®ºæ–‡](../../docs/thesis_gws.pdf)
    æä¾›äº†å‡èšæ€æ¨¡æ‹Ÿï¼Œå¹¶ä¸”åœ¨æŸäº›æƒ…å†µä¸‹è¢«è®¤ä¸ºæ¯” C æ›´æœ‰æ•ˆç‡ï¼Œç‰¹åˆ«æ˜¯åœ¨æ•°å€¼è®¡ç®—å·¥ä½œä¸­ã€‚ç°ä»£ Fortran çš„è¯­æ³•ä¹Ÿå‡ºå¥‡åœ°æ˜“äºä¸Šæ‰‹ã€‚è¿™ä¸æ˜¯ä½ çˆ¶è¾ˆä½¿ç”¨çš„ Fortran
    77 ä»£ç ï¼›å¤§éƒ¨åˆ†é™åˆ¶ä½¿å¾—å›ºå®šæ ¼å¼çš„ Fortran å¾ˆéš¾ä½¿ç”¨ï¼Œåœ¨ç°ä»£ Fortran ä¸­å·²ä¸å†å­˜åœ¨ã€‚
- en: In a clash of computational eras, this blog post is about compiling existing
    Fortran code for WebAssembly so that it can run in a web browser. Iâ€™ll describe
    the method we currently use for the [webR](https://github.com/r-wasm/webr) project,
    compiling Fortran code using a patched version of [LLVM](https://llvm.org)â€™s `flang-new`
    compiler. The post also serves as a request for help. The method I describe unfortunately
    relies on a hack, and this hack means that I cannot contribute the changes back
    to LLVM without assistance from a more experienced compiler developer.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¡ç®—æ—¶ä»£çš„ç¢°æ’ä¸­ï¼Œè¿™ç¯‡åšæ–‡è®¨è®ºäº†å°†ç°æœ‰ Fortran ä»£ç ç¼–è¯‘ä¸º WebAssemblyï¼Œä»¥ä¾¿åœ¨ Web æµè§ˆå™¨ä¸­è¿è¡Œçš„æ–¹æ³•ã€‚æˆ‘å°†æè¿°æˆ‘ä»¬å½“å‰åœ¨ [webR](https://github.com/r-wasm/webr)
    é¡¹ç›®ä¸­ä½¿ç”¨çš„æ–¹æ³•ï¼Œä½¿ç”¨äº† [LLVM](https://llvm.org) çš„ `flang-new` ç¼–è¯‘å™¨çš„ä¿®è¡¥ç‰ˆæœ¬ã€‚è¿™ç¯‡æ–‡ç« ä¹Ÿæ˜¯ä¸€åˆ™å¯»æ±‚å¸®åŠ©çš„è¯·æ±‚ã€‚æˆ‘æè¿°çš„æ–¹æ³•ä¸å¹¸åœ°ä¾èµ–äºä¸€ç§æŠ€å·§ï¼Œè¿™ç§æŠ€å·§æ„å‘³ç€æˆ‘æ— æ³•åœ¨æ²¡æœ‰æ›´æœ‰ç»éªŒçš„ç¼–è¯‘å™¨å¼€å‘è€…å¸®åŠ©çš„æƒ…å†µä¸‹å‘
    LLVM è´¡çŒ®è¿™äº›æ”¹åŠ¨ã€‚
- en: â´Â â€œLLVMâ€ is not an acronym, it is the full name of the project.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: â´Â â€œLLVMâ€ ä¸æ˜¯é¦–å­—æ¯ç¼©å†™ï¼Œè€Œæ˜¯é¡¹ç›®çš„å…¨ç§°ã€‚
- en: So, whatâ€™s the problem?
  id: totrans-split-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œé—®é¢˜å‡ºåœ¨å“ªé‡Œï¼Ÿ
- en: There are a surprising number of potential methods and toolchains available
    to compile Fortran to WebAssembly. Unfortunately, none of the available options
    are feature complete. Each method has its drawbacks, and none are a simple plug-and-play
    solution.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰è®¸å¤šæ½œåœ¨çš„æ–¹æ³•å’Œå·¥å…·é“¾å¯ä»¥å°† Fortran ç¼–è¯‘åˆ° WebAssemblyã€‚ä¸å¹¸çš„æ˜¯ï¼Œæ‰€æœ‰å¯ç”¨çš„é€‰é¡¹éƒ½ä¸å®Œå¤‡ã€‚æ¯ç§æ–¹æ³•éƒ½æœ‰å…¶ç¼ºç‚¹ï¼Œæ²¡æœ‰ä¸€ç§æ˜¯ç®€å•çš„å³æ’å³ç”¨çš„è§£å†³æ–¹æ¡ˆã€‚
- en: Back in 2020, the situation was summarised wonderfully by Christoph Honalâ€™s
    article [FORTRAN in the Browser](https://chrz.de/2020/04/21/fortran-in-the-browser/).
    Even now, the article is worth reading and provides a nice background for this
    post. I personally owe a lot to Christophâ€™s article, particularly for its description
    of the [Dragonegg](https://dragonegg.llvm.org) toolchain. Without that article,
    I would have given up on Fortran for WebAssembly a long time ago.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: å›åˆ°2020å¹´ï¼Œå…‹é‡Œæ–¯æ‰˜å¤«Â·éœçº³å°”çš„æ–‡ç« [FORTRAN in the Browser](https://chrz.de/2020/04/21/fortran-in-the-browser/)ç²¾å½©åœ°æ€»ç»“äº†å½“æ—¶çš„æƒ…å†µã€‚å³ä½¿åˆ°ç°åœ¨ï¼Œè¿™ç¯‡æ–‡ç« ä»ç„¶å€¼å¾—ä¸€è¯»ï¼Œå¹¶ä¸ºæœ¬æ–‡æä¾›äº†è‰¯å¥½çš„èƒŒæ™¯ã€‚æˆ‘ä¸ªäººå¯¹å…‹é‡Œæ–¯æ‰˜å¤«çš„æ–‡ç« å¾ˆæ„Ÿæ¿€ï¼Œç‰¹åˆ«æ˜¯å¯¹å…¶å¯¹[Dragonegg](https://dragonegg.llvm.org)å·¥å…·é“¾çš„æè¿°ã€‚å¦‚æœæ²¡æœ‰é‚£ç¯‡æ–‡ç« ï¼Œæˆ‘å¾ˆæ—©å°±ä¼šæ”¾å¼ƒå°†Fortranç”¨äºWebAssemblyäº†ã€‚
- en: Our goal by the end of this post is to be able to compile a modern Fortran routine
    to WebAssembly that takes in some numerical arguments, computes the output of
    [BLAS](http://www.netlib.org/blas/) and [LAPACK](https://netlib.org/lapack/) routines,
    and either returns the result or prints it to console. From what I remember, in
    2020 none of the methods outlined in Christophâ€™s article could do this satisfactorily.
    Dragonegg and `f2c` both get close but have some drawbacks, as Iâ€™ll describe below.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨æœ¬æ–‡ç»“æŸæ—¶çš„ç›®æ ‡æ˜¯èƒ½å¤Ÿç¼–è¯‘ä¸€ä¸ªç°ä»£Fortranä¾‹ç¨‹ä¸ºWebAssemblyï¼Œè¯¥ä¾‹ç¨‹æ¥æ”¶ä¸€äº›æ•°å€¼å‚æ•°ï¼Œè®¡ç®—[BLAS](http://www.netlib.org/blas/)å’Œ[LAPACK](https://netlib.org/lapack/)ä¾‹ç¨‹çš„è¾“å‡ºï¼Œå¹¶å°†ç»“æœè¿”å›æˆ–æ‰“å°åˆ°æ§åˆ¶å°ã€‚æ®æˆ‘è®°å¾—ï¼Œ2020å¹´æ—¶ï¼Œå…‹é‡Œæ–¯æ‰˜å¤«æ–‡ç« ä¸­æ¦‚è¿°çš„æ–¹æ³•éƒ½æ— æ³•ä»¤äººæ»¡æ„åœ°å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚Dragoneggå’Œ`f2c`è™½ç„¶æ¥è¿‘ï¼Œä½†éƒ½æœ‰ä¸€äº›ç¼ºç‚¹ï¼Œæˆ‘å°†åœ¨ä¸‹æ–‡æè¿°ã€‚
- en: âµÂ LAPACK (Linear Algebra Package) is a popular library of routines used to numerically
    solve problems in linear algebra. Itâ€™s written in Fortran 90 and itself relies
    on a BLAS (Basic Linear Algebra Subprograms) library.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: âµÂ LAPACKï¼ˆçº¿æ€§ä»£æ•°åŒ…ï¼‰æ˜¯ä¸€ä¸ªæµè¡Œçš„ä¾‹ç¨‹åº“ï¼Œç”¨äºæ•°å€¼è§£å†³çº¿æ€§ä»£æ•°é—®é¢˜ã€‚å®ƒç”¨Fortran 90ç¼–å†™ï¼Œå¹¶ä¾èµ–äºä¸€ä¸ªBLASï¼ˆåŸºæœ¬çº¿æ€§ä»£æ•°å­ç¨‹åºï¼‰åº“ã€‚
- en: â¶Â via [Pyodide](https://pyodide.org/en/stable/) and [webR](https://github.com/r-wasm/webr).
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: â¶Â é€šè¿‡[Pyodide](https://pyodide.org/en/stable/)å’Œ[webR](https://github.com/r-wasm/webr)ã€‚
- en: Together, BLAS and LAPACK routines provide a powerful numerical platform. Running
    them in the browser opens the door for several higher-level programming environments
    that rely on them under the hood, such as SciPy or R. The beauty of this approach
    is that it allows you to bring existing and extensively battle-tested tools and
    libraries to the web without having to rewrite them all in Rust or JavaScript.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: BLASå’ŒLAPACKä¾‹ç¨‹ä¸€èµ·æä¾›äº†ä¸€ä¸ªå¼ºå¤§çš„æ•°å€¼å¹³å°ã€‚åœ¨æµè§ˆå™¨ä¸­è¿è¡Œå®ƒä»¬ä¸ºå‡ ä¸ªä¾èµ–äºå®ƒä»¬çš„é«˜çº§ç¼–ç¨‹ç¯å¢ƒæ‰“å¼€äº†å¤§é—¨ï¼Œä¾‹å¦‚SciPyæˆ–Rã€‚è¿™ç§æ–¹æ³•çš„ä¼˜åŠ¿åœ¨äºï¼Œå®ƒå…è®¸æ‚¨å°†ç°æœ‰å’Œç»è¿‡å……åˆ†æµ‹è¯•çš„å·¥å…·å’Œåº“å¸¦åˆ°Webä¸Šï¼Œè€Œæ— éœ€å°†å®ƒä»¬å…¨éƒ¨é‡å†™ä¸ºRustæˆ–JavaScriptã€‚
- en: Later, Iâ€™ll show an example of this with a machine learning demo that directly
    uses BLAS routines compiled from Fortran to WebAssembly. Rather than having to
    write fiddly linear algebra numerical algorithms in JavaScript, we can use reliable
    and efficient BLAS routines directly.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: åé¢ï¼Œæˆ‘å°†å±•ç¤ºä¸€ä¸ªæœºå™¨å­¦ä¹ æ¼”ç¤ºç¤ºä¾‹ï¼Œè¯¥ç¤ºä¾‹ç›´æ¥ä½¿ç”¨ä»Fortranç¼–è¯‘ä¸ºWebAssemblyçš„BLASä¾‹ç¨‹ã€‚æˆ‘ä»¬æ— éœ€åœ¨JavaScriptä¸­ç¼–å†™å¤æ‚çš„çº¿æ€§ä»£æ•°æ•°å€¼ç®—æ³•ï¼Œè€Œæ˜¯ç›´æ¥ä½¿ç”¨å¯é å’Œé«˜æ•ˆçš„BLASä¾‹ç¨‹ã€‚
- en: â·Â Whilst running machine learning algorithms in a web browser will never be
    as efficient as using dedicated hardware, such as a GPU, I still think itâ€™s a
    fun demo.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: â·Â å°½ç®¡åœ¨Webæµè§ˆå™¨ä¸­è¿è¡Œæœºå™¨å­¦ä¹ ç®—æ³•æ°¸è¿œæ— æ³•ä¸ä½¿ç”¨ä¸“ç”¨ç¡¬ä»¶ï¼ˆå¦‚GPUï¼‰ä¸€æ ·é«˜æ•ˆï¼Œä½†æˆ‘ä»ç„¶è®¤ä¸ºè¿™æ˜¯ä¸€ä¸ªæœ‰è¶£çš„æ¼”ç¤ºã€‚
- en: Compiler round-up
  id: totrans-split-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç¼–è¯‘å™¨æ¦‚è¿°
- en: Since [FORTRAN in the Browser](https://chrz.de/2020/04/21/fortran-in-the-browser/)
    was published things have changed a little, particularly when it comes to the
    LLVM-based Fortran compilers. As far as I am aware, hereâ€™s a brief round-up of
    the current situation in 2024.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: è‡ªä»[FORTRAN in the Browser](https://chrz.de/2020/04/21/fortran-in-the-browser/)å‘å¸ƒä»¥æ¥ï¼Œä¸€äº›äº‹æƒ…æœ‰æ‰€å˜åŒ–ï¼Œç‰¹åˆ«æ˜¯å½“æ¶‰åŠåˆ°åŸºäºLLVMçš„Fortranç¼–è¯‘å™¨æ—¶ã€‚æ®æˆ‘æ‰€çŸ¥ï¼Œè¿™é‡Œæ˜¯2024å¹´çš„å½“å‰æƒ…å†µçš„ç®€è¦æ¦‚è¿°ã€‚
- en: The `f2c` utility
  id: totrans-split-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`f2c`å®ç”¨ç¨‹åº'
- en: The [`f2c`](https://en.wikipedia.org/wiki/F2c) program converts Fortran 77 to
    C code, which Emscripten can then compile into WebAssembly. This is the method
    that the [Pyodide](https://pyodide.org/en/stable/) project uses to compile Python
    packages containing Fortran code. They say that this [â€œdoes not work very wellâ€](https://pyodide.org/en/0.25.0/project/roadmap.html#find-a-better-way-to-compile-fortran).
    The tool doesnâ€™t work with modern Fortran code, and even after conversion the
    result still throws fatal errors and requires extensive patching.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[`f2c`](https://en.wikipedia.org/wiki/F2c)ç¨‹åºå°†Fortran 77è½¬æ¢ä¸ºCä»£ç ï¼Œç„¶åEmscriptenå¯ä»¥å°†å…¶ç¼–è¯‘æˆWebAssemblyã€‚è¿™æ˜¯[Pyodide](https://pyodide.org/en/stable/)é¡¹ç›®ç”¨æ¥ç¼–è¯‘åŒ…å«Fortranä»£ç çš„PythonåŒ…çš„æ–¹æ³•ã€‚ä»–ä»¬è¯´è¿™ç§æ–¹æ³•â€œæ•ˆæœä¸ä½³â€ï¼ˆhttps://pyodide.org/en/0.25.0/project/roadmap.html#find-a-better-way-to-compile-fortranï¼‰ã€‚è¯¥å·¥å…·æ— æ³•å¤„ç†ç°ä»£Fortranä»£ç ï¼Œå³ä½¿è½¬æ¢åç»“æœä»ä¼šå‡ºç°è‡´å‘½é”™è¯¯ï¼Œéœ€è¦å¤§é‡ä¿®è¡¥ã€‚'
- en: LFortran
  id: totrans-split-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LFortran
- en: The LFortran compiler has made great strides over the last few years. In 2020,
    it was [missing a lot of features](https://gitlab.com/lfortran/lfortran/-/issues/121)
    and only supported a very small subset of Fortran. Now it now supports a much
    wider range of language features and can be used to compile a reasonable amount
    of Fortran code. It can even compile to WebAssembly out of the box!
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: è¿‡å»å‡ å¹´é‡Œï¼ŒLFortranç¼–è¯‘å™¨å–å¾—äº†é•¿è¶³çš„è¿›æ­¥ã€‚2020å¹´æ—¶ï¼Œå®ƒ[ç¼ºå°‘å¾ˆå¤šåŠŸèƒ½](https://gitlab.com/lfortran/lfortran/-/issues/121)ï¼Œä»…æ”¯æŒæå°çš„Fortranå­é›†ã€‚ç°åœ¨ï¼Œå®ƒæ”¯æŒæ›´å¹¿æ³›çš„è¯­è¨€ç‰¹æ€§ï¼Œå¹¶å¯ä»¥ç”¨æ¥ç¼–è¯‘ç›¸å½“æ•°é‡çš„Fortranä»£ç ã€‚å®ƒç”šè‡³å¯ä»¥ç›´æ¥ç¼–è¯‘åˆ°WebAssemblyï¼
- en: â¸Â Check out the LFortran demo at [https://dev.lfortran.org](https://dev.lfortran.org).
    While extremely impressive, note that the first thing I tried was changing `x
    ** 2` to `x ** 3` and saw that such a change is currently not supported by the
    code generator.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: â¸Â è¯·æŸ¥çœ‹[LFortranæ¼”ç¤º](https://dev.lfortran.org)ã€‚å°½ç®¡ä»¤äººå°è±¡æ·±åˆ»ï¼Œä½†è¯·æ³¨æ„ï¼Œæˆ‘å°è¯•çš„ç¬¬ä¸€ä»¶äº‹æ˜¯å°†`x ** 2`æ”¹ä¸º`x
    ** 3`ï¼Œç»“æœå‘ç°å½“å‰ä»£ç ç”Ÿæˆå™¨ä¸æ”¯æŒè¿™æ ·çš„æ›´æ”¹ã€‚
- en: However, there are still some barriers that make using LFortran a little rough.
    The project is currently considered to be in alpha phase and the developers state
    that issues compiling real-world code are expected. While it can successfully
    compile some projects, such as [MINPACK](https://github.com/fortran-lang/minpack),
    the full Fortran specification is not yet supported and so many larger projects
    still cannot be compiled.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ï¼ŒLFortranä»ç„¶å­˜åœ¨ä¸€äº›ä½¿ç”¨ä¸Šçš„éšœç¢ã€‚è¯¥é¡¹ç›®ç›®å‰è¢«è®¤ä¸ºå¤„äºalphaé˜¶æ®µï¼Œå¼€å‘äººå‘˜è¡¨ç¤ºé¢„è®¡ä¼šå‡ºç°ç¼–è¯‘ç°å®ä¸–ç•Œä»£ç çš„é—®é¢˜ã€‚è™½ç„¶å®ƒå¯ä»¥æˆåŠŸç¼–è¯‘ä¸€äº›é¡¹ç›®ï¼Œä¾‹å¦‚[MINPACK](https://github.com/fortran-lang/minpack)ï¼Œä½†å®Œæ•´çš„Fortranè§„èŒƒå°šæœªå®Œå…¨æ”¯æŒï¼Œå› æ­¤è®¸å¤šè¾ƒå¤§çš„é¡¹ç›®ä»æ— æ³•ç¼–è¯‘ã€‚
- en: The LFortran developers are targeting full support for Fortran 2018, and its
    standout feature is an interactive Jupyter-like Fortran REPL. With a few more
    years of development, I expect that LFortran will be an excellent choice for compiling
    Fortran code for WebAssembly.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: LFortranå¼€å‘äººå‘˜æ­£åœ¨åŠªåŠ›æ”¯æŒå®Œæ•´çš„Fortran 2018ï¼Œå¹¶ä¸”å…¶æ˜¾è‘—ç‰¹æ€§æ˜¯ä¸€ä¸ªç±»ä¼¼äºäº¤äº’å¼Jupyterçš„Fortran REPLã€‚å†ç»è¿‡å‡ å¹´çš„å‘å±•ï¼Œæˆ‘é¢„è®¡LFortranå°†æˆä¸ºç¼–è¯‘Fortranä»£ç åˆ°WebAssemblyçš„ä¼˜ç§€é€‰æ‹©ã€‚
- en: Dragonegg
  id: totrans-split-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dragonegg
- en: '[Dragonegg](https://dragonegg.llvm.org) is a plugin for GCC that uses the GNU
    compilers as a frontend and emits LLVM IR. With this, LLVM can be used as the
    backend to produce WebAssembly output. The technique works, and it was the original
    method that I used to compile Fortran sources for the [webR](https://github.com/r-wasm/webr)
    project.'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dragonegg](https://dragonegg.llvm.org)æ˜¯GCCçš„ä¸€ä¸ªæ’ä»¶ï¼Œä½¿ç”¨GNUç¼–è¯‘å™¨ä½œä¸ºå‰ç«¯ï¼Œå¹¶ç”ŸæˆLLVM IRã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼ŒLLVMå¯ä»¥ä½œä¸ºåç«¯ç”ŸæˆWebAssemblyè¾“å‡ºã€‚è¿™ç§æŠ€æœ¯å¯è¡Œï¼Œå¹¶ä¸”è¿™æ˜¯æˆ‘ä¸º[webRé¡¹ç›®](https://github.com/r-wasm/webr)ç¼–è¯‘Fortranæºä»£ç æœ€åˆä½¿ç”¨çš„æ–¹æ³•ã€‚'
- en: However, there are some pretty serious drawbacks to this approach. Dragonegg
    requires a very old version of GCC and LLVM. For most users, this means setting
    up a virtual machine or Docker container to provide the necessary environment.
    The LLVM IR emitted by Dragonegg also needs some fairly nasty post-processing
    before LLVM can produce WebAssembly output. Take a look at the [script originally
    used by webR](https://github.com/r-wasm/webr/blob/v0.1.0/tools/dragonegg/emfc.in)
    to get an idea of the extra processing required.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™ç§æ–¹æ³•ä¹Ÿå­˜åœ¨ä¸€äº›ä¸¥é‡çš„ç¼ºç‚¹ã€‚Dragoneggéœ€è¦éå¸¸æ—§çš„GCCå’ŒLLVMç‰ˆæœ¬ã€‚å¯¹å¤§å¤šæ•°ç”¨æˆ·è€Œè¨€ï¼Œè¿™æ„å‘³ç€éœ€è¦è®¾ç½®è™šæ‹Ÿæœºæˆ–Dockerå®¹å™¨æ¥æä¾›å¿…è¦çš„ç¯å¢ƒã€‚Dragoneggç”Ÿæˆçš„LLVM
    IRè¿˜éœ€è¦ä¸€äº›ç›¸å½“å¤æ‚çš„åå¤„ç†æ‰èƒ½ç”±LLVMç”ŸæˆWebAssemblyè¾“å‡ºã€‚æŸ¥çœ‹[webRæœ€åˆä½¿ç”¨çš„è„šæœ¬](https://github.com/r-wasm/webr/blob/v0.1.0/tools/dragonegg/emfc.in)å¯ä»¥äº†è§£æ‰€éœ€çš„é¢å¤–å¤„ç†ã€‚
- en: â¹Â The latest supported versions are `gcc-4.8` and `llvm-3.3`
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: â¹Â æœ€æ–°æ”¯æŒçš„ç‰ˆæœ¬æ˜¯`gcc-4.8`å’Œ`llvm-3.3`
- en: Nevertheless, in 2020 this was the only real way to compile Fortran code for
    WebAssembly.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œåœ¨2020å¹´ï¼Œè¿™æ˜¯ç¼–è¯‘Fortranä»£ç åˆ°WebAssemblyçš„å”¯ä¸€çœŸæ­£æ–¹æ³•ã€‚
- en: Classic flang
  id: totrans-split-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ç»å…¸Flang
- en: '[â€œClassicâ€ Flang](https://github.com/flang-compiler/flang) is another Fortran
    compiler targeting LLVM, based on an open-sourced PGI/NVIDIA compiler `pgfortran`.
    Classic Flang never supported 32-bit output, so it is not an option for us since
    weâ€™ll be using `wasm32` for our target architecture. This will likely be the case
    until browser support for 64-bit Wasm memory has improved.'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[â€œç»å…¸â€Flang](https://github.com/flang-compiler/flang)æ˜¯å¦ä¸€ä¸ªé’ˆå¯¹LLVMçš„Fortranç¼–è¯‘å™¨ï¼ŒåŸºäºå¼€æºçš„PGI/NVIDIAç¼–è¯‘å™¨`pgfortran`ã€‚ç»å…¸Flangä»æœªæ”¯æŒ32ä½è¾“å‡ºï¼Œå› æ­¤å¯¹æˆ‘ä»¬æ¥è¯´ä¸æ˜¯ä¸€ä¸ªé€‰æ‹©ï¼Œå› ä¸ºæˆ‘ä»¬å°†ä½¿ç”¨`wasm32`ä½œä¸ºç›®æ ‡æ¶æ„ã€‚åœ¨æµè§ˆå™¨å¯¹64ä½Wasmå†…å­˜çš„æ”¯æŒæ”¹å–„ä¹‹å‰ï¼Œè¿™å¯èƒ½ä¼šä¸€ç›´æ˜¯é—®é¢˜ã€‚'
- en: ^(10)Â Previously, Flang or Flang-7.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: ^(10)Â ä»¥å‰æ˜¯Flangæˆ–Flang-7ã€‚
- en: ^(11)Â At the time of writing Firefox, Chrome and Node supports `wasm64`, but
    locked behind a feature flag.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: ^(11)Â æˆªè‡³æ’°å†™æ—¶ï¼ŒFirefoxã€Chromeå’ŒNodeéƒ½æ”¯æŒ`wasm64`ï¼Œä½†éœ€è¦é€šè¿‡åŠŸèƒ½æ ‡å¿—æ¥é”å®šã€‚
- en: 'Even so, the project documentation itself suggests that choosing to use Classic
    Flang for a new project today is probably not a great idea:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡å¦‚æ­¤ï¼Œé¡¹ç›®æ–‡æ¡£æœ¬èº«å»ºè®®ï¼Œé€‰æ‹©åœ¨æ–°é¡¹ç›®ä¸­ä½¿ç”¨ç»å…¸Flangå¯èƒ½ä¸æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ï¼š
- en: Classic Flang [â€¦] continues to be maintained, but the plan is to replace Classic
    Flang with the new Flang in the future.
  id: totrans-split-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»å…¸Flang[â€¦]ç»§ç»­ç»´æŠ¤ï¼Œä½†è®¡åˆ’æœªæ¥å°†å…¶æ›¿æ¢ä¸ºæ–°çš„Flangã€‚
- en: LLVM Flang
  id: totrans-split-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LLVM Flang
- en: '[â€œLLVM Flangâ€](https://flang.llvm.org/docs/) is a full ground-up reimplementation
    of a Fortran frontend for LLVM. It was designed to replace Classic Flang, developed
    by much of the same team, and was accepted as part of the LLVM project as of LLVM
    11\. As such, the Flang sources can now be found in [the official LLVM source
    tree](https://github.com/llvm/llvm-project/tree/main/flang).'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[â€œLLVM Flangâ€](https://flang.llvm.org/docs/)æ˜¯ä¸€ä¸ªå®Œå…¨ä»å¤´å¼€å§‹é‡æ–°å®ç°çš„ç”¨äºLLVMçš„Fortranå‰ç«¯ã€‚å®ƒæ—¨åœ¨å–ä»£ç”±åŒä¸€å›¢é˜Ÿå¼€å‘çš„ç»å…¸Flangï¼Œå¹¶ä¸”å·²ç»ä½œä¸ºLLVMé¡¹ç›®çš„ä¸€éƒ¨åˆ†è¢«æ¥å—ï¼Œä»LLVM
    11ç‰ˆæœ¬å¼€å§‹ï¼ŒFlangçš„æºä»£ç ç°åœ¨å¯ä»¥åœ¨[å®˜æ–¹LLVMæºç æ ‘](https://github.com/llvm/llvm-project/tree/main/flang)ä¸­æ‰¾åˆ°ã€‚'
- en: ^(12)Â Also known as Flang, new Flang, or `flang-new`. Previously, F18.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: ^(12)Â ä¹Ÿè¢«ç§°ä¸ºFlangã€æ–°Flangæˆ–`flang-new`ã€‚ä»¥å‰æ˜¯F18ã€‚
- en: Flang is not yet considered to be ready for production use, but its development
    is extremely active right now and pre-production versions of the `flang-new` compiler
    have been made available by the team. In recent years, the compiler has become
    very usable for compiling real-world Fortran code.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: Flangç›®å‰å°šæœªè¢«è®¤ä¸ºå·²ç»å‡†å¤‡å¥½ç”¨äºç”Ÿäº§ï¼Œä½†å…¶å¼€å‘ç›®å‰éå¸¸æ´»è·ƒï¼Œå›¢é˜Ÿå·²ç»å‘å¸ƒäº†`flang-new`ç¼–è¯‘å™¨çš„é¢„ç”Ÿäº§ç‰ˆæœ¬ã€‚è¿‘å¹´æ¥ï¼Œè¯¥ç¼–è¯‘å™¨åœ¨ç¼–è¯‘å®é™…çš„Fortranä»£ç æ–¹é¢å˜å¾—éå¸¸å¯ç”¨ã€‚
- en: Currently, LLVM Flang cannot generate WebAssembly output out of the box. Despite
    this, weâ€™ll soon see that with LLVMâ€™s modular design itâ€™s possible to use the
    Flang frontend with LLVMâ€™s WebAssembly backend. With this, we can take advantage
    of all the development work put into the Flang frontend by the NVIDIA and PGI
    teams for our own purposes of compiling Fortran to WebAssembly.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å‰ï¼ŒLLVM Flangæ— æ³•ç›´æ¥ç”ŸæˆWebAssemblyè¾“å‡ºã€‚å°½ç®¡å¦‚æ­¤ï¼Œç”±äºLLVMçš„æ¨¡å—åŒ–è®¾è®¡ï¼Œæˆ‘ä»¬å¾ˆå¿«å°†çœ‹åˆ°å¯ä»¥å°†Flangå‰ç«¯ä¸LLVMçš„WebAssemblyåç«¯ç»“åˆä½¿ç”¨ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨NVIDIAå’ŒPGIå›¢é˜Ÿä¸ºç¼–è¯‘Fortranåˆ°WebAssemblyæ‰€åšçš„æ‰€æœ‰å¼€å‘å·¥ä½œã€‚
- en: This was also possible back in 2020, though it required larger patches to LLVM,
    injecting custom maths routines, and a multi-step compilation process. Now, due
    to the impressive development efforts in the `flang-new` frontend, creating a
    Fortran to WebAssembly compiler is possible with just a few small changes to LLVMâ€™s
    source code.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åœ¨2020å¹´ä¹Ÿæ˜¯å¯èƒ½çš„ï¼Œå°½ç®¡éœ€è¦å¯¹LLVMè¿›è¡Œè¾ƒå¤§çš„è¡¥ä¸ï¼Œæ³¨å…¥è‡ªå®šä¹‰æ•°å­¦å‡½æ•°ï¼Œå¹¶è¿›è¡Œå¤šæ­¥éª¤çš„ç¼–è¯‘è¿‡ç¨‹ã€‚ç°åœ¨ï¼Œç”±äº`flang-new`å‰ç«¯çš„æ˜¾è‘—å¼€å‘å·¥ä½œï¼Œåªéœ€å¯¹LLVMçš„æºä»£ç è¿›è¡Œå°‘é‡æ›´æ”¹ï¼Œå°±å¯ä»¥åˆ›å»ºä¸€ä¸ªFortranåˆ°WebAssemblyçš„ç¼–è¯‘å™¨ã€‚
- en: Building and using LLVM Flang for WebAssembly
  id: totrans-split-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ„å»ºå¹¶ä½¿ç”¨LLVM Flangç”¨äºWebAssembly
- en: If one were interested in trying out LLVM Flang, they might grab an LLVM release
    using their package manager of choice. However, following that route will disappoint
    us, as a `flang-new` binary is not included.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæœ‰å…´è¶£å°è¯•LLVM Flangï¼Œå¯ä»¥é€šè¿‡å–œæ¬¢çš„åŒ…ç®¡ç†å™¨è·å–LLVMçš„å‘å¸ƒç‰ˆæœ¬ã€‚ç„¶è€Œï¼ŒæŒ‰ç…§è¿™æ¡è·¯çº¿èµ°ä¼šè®©æˆ‘ä»¬å¤±æœ›ï¼Œå› ä¸º`flang-new`äºŒè¿›åˆ¶æ–‡ä»¶å¹¶ä¸åŒ…å«åœ¨å†…ã€‚
- en: ^(13)Â At least, not with LLVM v17.0.6 for macOS using `brew`.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: ^(13)Â è‡³å°‘ï¼Œåœ¨ä½¿ç”¨`brew`å®‰è£…LLVM v17.0.6çš„macOSä¸Šä¸è¡Œã€‚
- en: '[~/fortran]brew install llvm'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]brew install llvm'
- en: ==> Downloading https://formulae.brew.sh/api/formula.jws.json
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: ==> ä¸‹è½½ https://formulae.brew.sh/api/formula.jws.json
- en: '################################################################################
    100.0%'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: '################################################################################
    100.0%'
- en: ==> Downloading https://ghcr.io/v2/homebrew/core/llvm/manifests/17.0.6_1
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: ==> ä¸‹è½½ https://ghcr.io/v2/homebrew/core/llvm/manifests/17.0.6_1
- en: '################################################################################
    100.0%'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: '################################################################################
    100.0%'
- en: ==> Fetching llvm
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: ==> è·å– llvm
- en: ==> Downloading https://ghcr.io/v2/homebrew/core/llvm/blobs/sha256:8d739bdfa4152
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: ==> ä¸‹è½½ https://ghcr.io/v2/homebrew/core/llvm/blobs/sha256:8d739bdfa4152
- en: '################################################################################
    100.0%'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: '################################################################################
    100.0%'
- en: ==> Installing llvm
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: ==> å®‰è£… llvm
- en: ==> Pouring llvm--17.0.6_1.arm64_sonoma.bottle.tar.gz
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: ==> æ­£åœ¨è§£å‹ llvm--17.0.6_1.arm64_sonoma.bottle.tar.gz
- en: ==> Summary
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: ==> æ€»ç»“
- en: 'ğŸº /opt/homebrew/Cellar/llvm/17.0.6_1: 7,207 files, 1.7GB'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'ğŸº /opt/homebrew/Cellar/llvm/17.0.6_1: 7,207 files, 1.7GB'
- en: ==> Checking for dependents of upgraded formulae...
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: ==> æ£€æŸ¥å‡çº§å…¬å¼çš„ä¾èµ–é¡¹...
- en: ==> No broken dependents to reinstall!
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: ==> æ²¡æœ‰éœ€è¦é‡æ–°å®‰è£…çš„å·²æŸåä¾èµ–é¡¹ï¼
- en: '[~/fortran]flang-new'
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]flang-new'
- en: 'zsh: command not found: flang-new'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'zsh: command not found: flang-new'
- en: Since we will be modifying the LLVM Flang source in any case, weâ€™ll have to
    compile from scratch. Letâ€™s grab the LLVM v18.1.1 sources and start there instead.
    Feel free to follow along at home; Iâ€™ll try to provide all the commands and everything
    you need.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¢ç„¶æˆ‘ä»¬æ— è®ºå¦‚ä½•éƒ½è¦ä¿®æ”¹ LLVM Flang æºç ï¼Œæˆ‘ä»¬éœ€è¦ä»å¤´å¼€å§‹ç¼–è¯‘ã€‚è®©æˆ‘ä»¬è·å– LLVM v18.1.1 çš„æºç å¹¶ä»é‚£é‡Œå¼€å§‹ã€‚è¯·éšæ—¶è·Ÿè¿›ï¼›æˆ‘ä¼šå°½é‡æä¾›æ‰€æœ‰å¿…è¦çš„å‘½ä»¤å’Œä¿¡æ¯ã€‚
- en: ^(14)Â Iâ€™m going to assume youâ€™re familiar with [Emscripten](https://emscripten.org)
    and have a version of that toolchain on your path. If not, and you want to play
    along, start with [emsdk](https://github.com/emscripten-core/emsdk) to setup Emscripten
    on your machine, get comfortable with compiling C code for WebAssembly, then return
    here to continue.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: ^(14)Â æˆ‘å‡è®¾æ‚¨ç†Ÿæ‚‰ [Emscripten](https://emscripten.org)ï¼Œå¹¶ä¸”åœ¨æ‚¨çš„è·¯å¾„ä¸Šæœ‰è¯¥å·¥å…·é“¾çš„ç‰ˆæœ¬ã€‚å¦‚æœä¸æ˜¯è¿™æ ·ï¼Œå¹¶ä¸”æ‚¨å¸Œæœ›å‚ä¸å…¶ä¸­ï¼Œè¯·ä»
    [emsdk](https://github.com/emscripten-core/emsdk) å¼€å§‹ï¼Œåœ¨æ‚¨çš„æœºå™¨ä¸Šè®¾ç½® Emscriptenï¼Œç†Ÿæ‚‰ä¸º WebAssembly
    ç¼–è¯‘ C ä»£ç çš„è¿‡ç¨‹ï¼Œç„¶åå†å›åˆ°è¿™é‡Œç»§ç»­ã€‚
- en: '[~/fortran]git clone --depth=1 --branch=llvmorg-18.1.1 https://github.com/llvm/llvm-project.git'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]git clone --depth=1 --branch=llvmorg-18.1.1 https://github.com/llvm/llvm-project.git'
- en: Cloning into 'llvm-project'...
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£åœ¨å…‹éš†åˆ° 'llvm-project'...
- en: 'remote: Enumerating objects: 138937, done.'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: è¿œç¨‹ï¼šæ­£åœ¨æšä¸¾å¯¹è±¡ï¼š138937ï¼Œå®Œæˆã€‚
- en: 'Receiving objects: 100% (138937/138937), 199.81 MiB | 11.36 MiB/s, done.'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥æ”¶å¯¹è±¡ï¼š100%ï¼ˆ138937/138937ï¼‰ï¼Œ199.81 MiB | 11.36 MiB/sï¼Œå®Œæˆã€‚
- en: 'Note: switching to ''6009708b4367171ccdbf4b5905cb6a803753fe18''.'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šåˆ‡æ¢åˆ° '6009708b4367171ccdbf4b5905cb6a803753fe18'ã€‚
- en: 'Updating files: 100% (132077/132077), done.'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´æ–°æ–‡ä»¶ï¼š100%ï¼ˆ132077/132077ï¼‰ï¼Œå®Œæˆã€‚
- en: '[~/fortran]cmake -G Ninja -S llvm-project/llvm -B build \'
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]cmake -G Ninja -S llvm-project/llvm -B build \'
- en: -DCMAKE_INSTALL_PREFIX=llvm-18.1.1 \
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: -DCMAKE_INSTALL_PREFIX=llvm-18.1.1 \
- en: -DCMAKE_BUILD_TYPE=MinSizeRel \
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: -DCMAKE_BUILD_TYPE=MinSizeRel \
- en: -DLLVM_DEFAULT_TARGET_TRIPLE="wasm32-unknown-emscripten" \
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: -DLLVM_DEFAULT_TARGET_TRIPLE="wasm32-unknown-emscripten" \
- en: -DLLVM_TARGETS_TO_BUILD="WebAssembly" \
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: -DLLVM_TARGETS_TO_BUILD="WebAssembly" \
- en: -DLLVM_ENABLE_PROJECTS="clang;flang;mlir"
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: -DLLVM_ENABLE_PROJECTS="clang;flang;mlir"
- en: -- The C compiler identification is AppleClang 15.0.0.15000100
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: -- C ç¼–è¯‘å™¨æ ‡è¯†ä¸º AppleClang 15.0.0.15000100
- en: '-- Found assembler: /Library/Developer/CommandLineTools/usr/bin/cc'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: -- å‘ç°æ±‡ç¼–ç¨‹åºï¼š/Library/Developer/CommandLineTools/usr/bin/cc
- en: -- Detecting C compiler ABI info - done
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: -- æ£€æµ‹ C ç¼–è¯‘å™¨ ABI ä¿¡æ¯ - å®Œæˆ
- en: -- Performing Test HAVE_POSIX_REGEX -- success
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: -- æµ‹è¯•æˆåŠŸ HAVE_POSIX_REGEX --
- en: -- Configuring done (29.0s)
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: -- é…ç½®å®Œæˆï¼ˆ29.0ç§’ï¼‰
- en: -- Generating done (2.9s)
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: -- ç”Ÿæˆå®Œæˆï¼ˆ2.9ç§’ï¼‰
- en: '-- Build files have been written to: fortran/build'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: -- å·²ç¼–å†™æ„å»ºæ–‡ä»¶ï¼šfortran/build
- en: '[~/fortran]cmake --build build'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]cmake --build build'
- en: '...'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[6136/6136] Linking CXX executable bin/obj2yaml'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[6136/6136] é“¾æ¥ CXX å¯æ‰§è¡Œæ–‡ä»¶ bin/obj2yaml'
- en: Grab a cuppa, this step uses a lot of resources and can take a **very** long
    time.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹¿æ¯èŒ¶å§ï¼Œè¿™ä¸€æ­¥ä¼šæ¶ˆè€—å¤§é‡èµ„æºï¼Œå¯èƒ½éœ€è¦**éå¸¸**é•¿çš„æ—¶é—´ã€‚
- en: '^(15)Â **cuppa** (/ËˆkÊŒp.É™/): noun, informal, UK. A hot drink, usually tea or
    coffee.'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: '^(15)Â **cuppa** (/ËˆkÊŒp.É™/): åè¯ï¼Œéæ­£å¼ç”¨æ³•ï¼Œè‹±å›½ã€‚ä¸€ç§çƒ­é¥®ï¼Œé€šå¸¸æ˜¯èŒ¶æˆ–å’–å•¡ã€‚'
- en: Interlude â€” Calling Fortran subroutines from C
  id: totrans-split-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ’æ›² â€”â€” ä» C è°ƒç”¨ Fortran å­ç¨‹åº
- en: While we wait for LLVM to build, start up a new terminal and weâ€™ll remind ourselves
    how to compile and link a Fortran subroutine as part of a C program. The principles
    here will help us later when it comes to calling Fortran from JavaScript.
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰å¾… LLVM æ„å»ºæ—¶ï¼Œæ‰“å¼€ä¸€ä¸ªæ–°çš„ç»ˆç«¯çª—å£ï¼Œæˆ‘ä»¬æ¥å›é¡¾ä¸€ä¸‹å¦‚ä½•å°† Fortran å­ç¨‹åºç¼–è¯‘å¹¶é“¾æ¥åˆ° C ç¨‹åºä¸­ã€‚è¿™é‡Œçš„åŸç†å°†æœ‰åŠ©äºæˆ‘ä»¬ç¨ååœ¨ JavaScript
    ä¸­è°ƒç”¨ Fortran æ—¶ä½¿ç”¨ã€‚
- en: 'First, letâ€™s write a simple subroutine that takes in three integer arguments:
    `x`, `y`, and `z`. It will set the value of `z` to the sum of `x` and `y`. Name
    our new subroutine `foo` and save the file containing your subroutine as `foo.f08`.'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªç®€å•çš„å­ç¨‹åºï¼Œæ¥å—ä¸‰ä¸ªæ•´æ•°å‚æ•°ï¼š`x`ã€`y` å’Œ `z`ã€‚å®ƒå°†æŠŠ `z` çš„å€¼è®¾ä¸º `x` å’Œ `y` çš„å’Œã€‚å‘½åæˆ‘ä»¬çš„æ–°å­ç¨‹åºä¸º
    `foo`ï¼Œå¹¶å°†åŒ…å«æ‚¨çš„å­ç¨‹åºçš„æ–‡ä»¶ä¿å­˜ä¸º `foo.f08`ã€‚
- en: '[PRE0]'
  id: totrans-split-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Notice how, generally, Fortran routines pass arguments by reference and we
    can declare how an argument will be used in the subroutine using `INTENT()`. Assuming
    you already have a traditional Fortran compiler like `gfortran` installed, compile
    the Fortran source into an object file.'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ³¨æ„åˆ°ï¼Œä¸€èˆ¬æ¥è¯´ï¼ŒFortran ä¾‹ç¨‹é€šè¿‡å¼•ç”¨ä¼ é€’å‚æ•°ï¼Œå¹¶ä¸”æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `INTENT()` åœ¨å­ç¨‹åºä¸­å£°æ˜å‚æ•°çš„ä½¿ç”¨æ–¹å¼ã€‚å‡è®¾æ‚¨å·²ç»å®‰è£…äº†ç±»ä¼¼
    `gfortran` çš„ä¼ ç»Ÿ Fortran ç¼–è¯‘å™¨ï¼Œè¯·å°† Fortran æºç ç¼–è¯‘æˆç›®æ ‡æ–‡ä»¶ã€‚'
- en: ^(16)Â You donâ€™t *need* a native fortran compiler to follow along with the rest
    of the post, but if youâ€™d like one you can get `gfortran` from your OSâ€™s usual
    package manager as part of the GCC compiler suite. Thereâ€™s also [`ifort`](https://www.intel.com/content/www/us/en/developer/tools/oneapi/fortran-compiler.html),
    if youâ€™re on an Intel CPU.
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: ^(16)Â æ‚¨ä¸*å¿…é¡»*æœ‰ä¸€ä¸ªæœ¬åœ°çš„ Fortran ç¼–è¯‘å™¨æ‰èƒ½è·Ÿç€æœ¬æ–‡ç»§ç»­è¿›è¡Œï¼Œä½†å¦‚æœæ‚¨æƒ³è¦ä¸€ä¸ªï¼Œå¯ä»¥ä»æ‚¨æ“ä½œç³»ç»Ÿçš„å¸¸è§„è½¯ä»¶åŒ…ç®¡ç†å™¨ä¸­è·å– `gfortran`
    ä½œä¸º GCC ç¼–è¯‘å™¨å¥—ä»¶çš„ä¸€éƒ¨åˆ†ã€‚å¦‚æœæ‚¨åœ¨ Intel CPU ä¸Šï¼Œè¿˜æœ‰ [`ifort`](https://www.intel.com/content/www/us/en/developer/tools/oneapi/fortran-compiler.html)ã€‚
- en: '[~/fortran]gfortran -c foo.f08 -o foo.o'
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]gfortran -c foo.f08 -o foo.o'
- en: '[~/fortran]file foo.o'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]æ–‡ä»¶ foo.o'
- en: 'foo.o: Mach-O 64-bit object arm64'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: foo.oï¼šMach-O 64 ä½å¯¹è±¡ arm64
- en: '[~/fortran]nm foo.o'
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]nm foo.o'
- en: 0000000000000038 s EH_frame1
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000038 s EH_frame1
- en: 0000000000000000 T _foo_
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000000 T _foo_
- en: 0000000000000000 t ltmp0
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000000 t ltmp0
- en: 0000000000000038 s ltmp1
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000038 s ltmp1
- en: Iâ€™m on an M1 macOS machine, so my resulting object is a Mach object for ARM.
    If youâ€™re a Linux user, you should see something like `ELF 64-bit LSB shared object,
    x86-64`. Iâ€™ve also run `nm` to take a look at the names of the symbols in the
    object that the compiler has built. Keep an eye on the symbol for our subroutine
    â€” on my machine itâ€™s named `_foo_`. The leading underscore is fairly standard,
    but the trailing underscore differs from what is usual for C procedures.
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä½¿ç”¨çš„æ˜¯ M1 macOS æœºå™¨ï¼Œæ‰€ä»¥æˆ‘çš„ç”Ÿæˆå¯¹è±¡æ˜¯ç”¨äº ARM çš„ Mach å¯¹è±¡ã€‚å¦‚æœæ‚¨æ˜¯ Linux ç”¨æˆ·ï¼Œæ‚¨åº”è¯¥çœ‹åˆ°ç±»ä¼¼ `ELF 64 ä½
    LSB å…±äº«å¯¹è±¡ï¼Œx86-64` çš„å†…å®¹ã€‚æˆ‘è¿˜è¿è¡Œäº† `nm` å‘½ä»¤æ¥æŸ¥çœ‹ç¼–è¯‘å™¨ç”Ÿæˆçš„å¯¹è±¡ä¸­çš„ç¬¦å·åç§°ã€‚è¯·æ³¨æ„æˆ‘ä»¬å­ä¾‹ç¨‹çš„ç¬¦å· â€”â€” åœ¨æˆ‘çš„æœºå™¨ä¸Šï¼Œå®ƒè¢«å‘½åä¸º
    `_foo_`ã€‚å‰å¯¼ä¸‹åˆ’çº¿æ˜¯ç›¸å½“æ ‡å‡†çš„ï¼Œä½†æ˜¯å°¾éšä¸‹åˆ’çº¿ä¸ C è¿‡ç¨‹çš„é€šå¸¸æƒ…å†µä¸åŒã€‚
- en: Letâ€™s write a C program that calls our Fortran subroutine. Notice again how
    we pass the arguments by reference to the external symbol. Also, if your Fortran
    compiler added the trailing underscore, weâ€™ll need to include it when we declare
    the symbol name in C.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªè°ƒç”¨æˆ‘ä»¬ Fortran å­ä¾‹ç¨‹çš„ C ç¨‹åºã€‚å†æ¬¡æ³¨æ„æˆ‘ä»¬å¦‚ä½•é€šè¿‡å¼•ç”¨å°†å‚æ•°ä¼ é€’ç»™å¤–éƒ¨ç¬¦å·ã€‚æ­¤å¤–ï¼Œå¦‚æœæ‚¨çš„ Fortran ç¼–è¯‘å™¨æ·»åŠ äº†å°¾éšä¸‹åˆ’çº¿ï¼Œæˆ‘ä»¬åœ¨
    C ä¸­å£°æ˜ç¬¦å·åç§°æ—¶ä¹Ÿéœ€è¦åŒ…å«å®ƒã€‚
- en: ^(17)Â Modern Fortran standards provide a Fortran module [`iso_c_binding`](https://fortranwiki.org/fortran/show/iso_c_binding)
    and a C header file `ISO_Fortran_binding.h` to improve C interoperability, but
    our code is going to be simple enough that we can do without those today.
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: ^(17) ç°ä»£ Fortran æ ‡å‡†æä¾›äº†ä¸€ä¸ª Fortran æ¨¡å— [`iso_c_binding`](https://fortranwiki.org/fortran/show/iso_c_binding)
    å’Œä¸€ä¸ª C å¤´æ–‡ä»¶ `ISO_Fortran_binding.h`ï¼Œä»¥æé«˜ä¸ C çš„äº’æ“ä½œæ€§ï¼Œä½†æˆ‘ä»¬ä»Šå¤©çš„ä»£ç è¶³å¤Ÿç®€å•ï¼Œå¯ä»¥ä¸ç”¨è¿™äº›ã€‚
- en: '[PRE1]'
  id: totrans-split-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Compile the C source using `gcc` or equivalent, and then run the resulting
    binary to observe a truly staggering level of numerical computation.'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä½¿ç”¨ `gcc` æˆ–ç­‰æ•ˆå·¥å…·ç¼–è¯‘ C æºç ï¼Œç„¶åè¿è¡Œç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œè§‚å¯Ÿä»¤äººæƒŠå¹çš„æ•°å€¼è®¡ç®—æ°´å¹³ã€‚'
- en: '[~/fortran]gcc main.c foo.o -o main'
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]gcc main.c foo.o -o main'
- en: '[~/fortran]./main'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]./main'
- en: 1 + 1 = 2**  **## Returning to LLVM Flang
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 1 = 2**  **## è¿”å› LLVM Flang
- en: Once LLVM has finished compiling, the `flang-new` binary should be available
    in the directory `build/bin`. We can now run it and confirm that it has been set
    up to produce binaries for `wasm32` and Emscripten.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦ LLVM ç¼–è¯‘å®Œæˆï¼Œ`flang-new` äºŒè¿›åˆ¶æ–‡ä»¶åº”è¯¥ä½äºç›®å½• `build/bin` ä¸­ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥è¿è¡Œå®ƒï¼Œå¹¶ç¡®è®¤å·²è®¾ç½®ä¸ºç”Ÿæˆ `wasm32`
    å’Œ Emscripten çš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚
- en: '[~/fortran]./build/bin/flang-new --version'
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]./build/bin/flang-new --version'
- en: flang-new version 18.1.1 (https://github.com/llvm/llvm-project.git dba2a75e9c7ef81fe84774ba5eee5e67e01d801a)
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: flang-new ç‰ˆæœ¬ 18.1.1ï¼ˆhttps://github.com/llvm/llvm-project.git dba2a75e9c7ef81fe84774ba5eee5e67e01d801aï¼‰
- en: 'Target: wasm32-unknown-emscripten'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®æ ‡ï¼šwasm32-unknown-emscripten
- en: 'Thread model: posix'
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: çº¿ç¨‹æ¨¡å‹ï¼šposix
- en: 'InstalledDir: .../fortran/build/bin'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: InstalledDirï¼š.../fortran/build/bin
- en: Great! Letâ€™s try compiling our Fortran subroutine using our freshly built compiler.
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: å¤ªæ£’äº†ï¼è®©æˆ‘ä»¬å°è¯•ä½¿ç”¨æˆ‘ä»¬æ–°æ„å»ºçš„ç¼–è¯‘å™¨ç¼–è¯‘æˆ‘ä»¬çš„ Fortran å­ä¾‹ç¨‹ã€‚
- en: '[~/fortran]./build/bin/flang-new -c foo.f08 -o foo.o'
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]./build/bin/flang-new -c foo.f08 -o foo.o'
- en: 'error: fortran/llvm-project/flang/lib/Optimizer/CodeGen/Target.cpp:1162:'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: é”™è¯¯ï¼šfortran/llvm-project/flang/lib/Optimizer/CodeGen/Target.cpp:1162ï¼š
- en: 'not yet implemented: target not implemented'
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: å°šæœªå®ç°ï¼šç›®æ ‡æœªå®ç°
- en: 'LLVM ERROR: aborting'
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM é”™è¯¯ï¼šä¸­æ­¢
- en: Ah, not so great. The `wasm32-unknown-emscripten` target triple unfortunately
    hasnâ€™t been implemented yet in the `flang-new` compiler.
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: å•Šï¼Œä¸å¤ªå¥½ã€‚`flang-new` ç¼–è¯‘å™¨ä¸­é—æ†¾åœ°å°šæœªå®ç° `wasm32-unknown-emscripten` ç›®æ ‡ä¸‰å…ƒç»„ã€‚
- en: And so here comes our first patch to LLVM. We will implement the target by extending
    Flangâ€™s list of known target specifics. The required changes, shown below as a
    diff, can be mostly deduced by looking at the other targets implemented in the
    file `flang/lib/Optimizer/CodeGen/Target.cpp`.
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥ä¸º LLVM çš„ç¬¬ä¸€ä¸ªè¡¥ä¸ã€‚æˆ‘ä»¬å°†é€šè¿‡æ‰©å±• Flang çš„å·²çŸ¥ç›®æ ‡ç‰¹å®šåˆ—è¡¨æ¥å®ç°ç›®æ ‡ã€‚ä¸‹é¢æ˜¾ç¤ºçš„æ‰€éœ€æ›´æ”¹å¯ä»¥é€šè¿‡æŸ¥çœ‹æ–‡ä»¶ `flang/lib/Optimizer/CodeGen/Target.cpp`
    ä¸­å·²å®ç°çš„å…¶ä»–ç›®æ ‡æ¥æ¨æ–­ã€‚
- en: '[PRE2]'
  id: totrans-split-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Save the contents of the above diff as the file `add-wasm32-target.diff`,
    and then apply it to the `llvm-project` directory using `git` or the `patch` utility.
    Then, rebuild LLVM Flang. It should be quicker to build the second time, as most
    generated objects are unaffected by the change.'
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*å°†ä¸Šè¿°å·®å¼‚å†…å®¹ä¿å­˜ä¸ºæ–‡ä»¶ `add-wasm32-target.diff`ï¼Œç„¶åä½¿ç”¨ `git` æˆ– `patch` å®ç”¨ç¨‹åºå°†å…¶åº”ç”¨äº `llvm-project`
    ç›®å½•ã€‚ç„¶åï¼Œé‡æ–°æ„å»º LLVM Flangã€‚ç¬¬äºŒæ¬¡æ„å»ºåº”è¯¥ä¼šæ›´å¿«ï¼Œå› ä¸ºå¤§éƒ¨åˆ†ç”Ÿæˆçš„å¯¹è±¡ä¸å—æ­¤æ›´æ”¹çš„å½±å“ã€‚'
- en: '[~/fortran]patch -p1 -d llvm-project < add-wasm32-target.diff'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]patch -p1 -d llvm-project < add-wasm32-target.diff'
- en: '[~/fortran]cmake --build build'
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]cmake --build build'
- en: '...'
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[180/180] Generating ../../../../include/flang/ieee_arithmetic.mod'
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[180/180] ç”Ÿæˆ../../../../include/flang/ieee_arithmetic.mod'
- en: Once LLVM has been recompiled, try compiling our Fortran source once again.
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦LLVMé‡æ–°ç¼–è¯‘ï¼Œå†æ¬¡å°è¯•ç¼–è¯‘æˆ‘ä»¬çš„Fortranæºã€‚
- en: '[~/fortran]./build/bin/flang-new -c foo.f08 -o foo.o'
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]./build/bin/flang-new -c foo.f08 -o foo.o'
- en: '[~/fortran]file foo.o'
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]file foo.o'
- en: 'foo.o: WebAssembly (wasm) binary module version 0x1 (MVP)'
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'foo.o: WebAssembly (wasm) äºŒè¿›åˆ¶æ¨¡å—ç‰ˆæœ¬ 0x1 (MVP)'
- en: '[~/fortran]llvm-nm foo.o'
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]llvm-nm foo.o'
- en: 00000001 T foo_
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 00000001 T foo_
- en: Success! We can confirm this is a real WebAssembly object using the `file` utility,
    and `llvm-nm` can see the `foo` symbol within, corresponding to our Fortran subroutine.
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: æˆåŠŸï¼æˆ‘ä»¬å¯ä»¥ç¡®è®¤è¿™æ˜¯ä¸€ä¸ªçœŸå®çš„WebAssemblyå¯¹è±¡ï¼Œä½¿ç”¨`file`å®ç”¨ç¨‹åºï¼Œ`llvm-nm`å¯ä»¥çœ‹åˆ°å…¶ä¸­çš„`foo`ç¬¦å·ï¼Œå¯¹åº”æˆ‘ä»¬çš„Fortranå­ç¨‹åºã€‚
- en: ^(18)Â You might need to use a WebAssembly aware version of this tool from Emscripten.
    If youâ€™re using [emsdk](https://github.com/emscripten-core/emsdk), ensure that
    `.../emsdk/upstream/bin/` is on your `$PATH`.
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
  zh: ^(18)Â æ‚¨å¯èƒ½éœ€è¦ä½¿ç”¨Emscriptenæä¾›çš„WebAssemblyæ„ŸçŸ¥ç‰ˆæœ¬çš„è¿™ä¸ªå·¥å…·ã€‚å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨[emsdk](https://github.com/emscripten-core/emsdk)ï¼Œè¯·ç¡®ä¿`.../emsdk/upstream/bin/`åœ¨æ‚¨çš„`$PATH`ä¸­ã€‚
- en: ^(19)Â Here Iâ€™m using Node v18, but I think anything newer than Node v16 should
    work. Emscripten is bundled with a version of Node, but I like using [nvm](https://github.com/nvm-sh/nvm)
    to manage my Node installations.
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: ^(19)Â åœ¨è¿™é‡Œæˆ‘æ­£åœ¨ä½¿ç”¨Node v18ï¼Œä½†æˆ‘è®¤ä¸ºæ¯”Node v16æ›´æ–°çš„ç‰ˆæœ¬éƒ½åº”è¯¥å¯ä»¥å·¥ä½œã€‚Emscriptenæ†ç»‘äº†ä¸€ä¸ªNodeçš„ç‰ˆæœ¬ï¼Œä½†æˆ‘å–œæ¬¢ä½¿ç”¨[nvm](https://github.com/nvm-sh/nvm)æ¥ç®¡ç†æˆ‘çš„Nodeå®‰è£…ã€‚
- en: Letâ€™s continue compiling our C function for WebAssembly using Emscripten and
    running it using Node. We should see the same output as with our native binary.
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç»§ç»­ä½¿ç”¨Emscriptenç¼–è¯‘æˆ‘ä»¬çš„Cå‡½æ•°ä¸ºWebAssemblyï¼Œå¹¶ä½¿ç”¨Nodeè¿è¡Œå®ƒã€‚æˆ‘ä»¬åº”è¯¥çœ‹åˆ°ä¸æˆ‘ä»¬çš„æœ¬æœºäºŒè¿›åˆ¶ç›¸åŒçš„è¾“å‡ºã€‚
- en: '[~/fortran]emcc main.c foo.o -o main.js'
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]emcc main.c foo.o -o main.js'
- en: '[~/fortran]node main.js'
  id: totrans-split-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]node main.js'
- en: 1 + 1 = 2*  *## Interlude â€” Calling a Fortran routine from JavaScript
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 1 = 2*  *## å¹•é—´ â€” ä»JavaScriptè°ƒç”¨Fortranä¾‹ç¨‹
- en: In the previous section we used a C program to call Fortran code, but we donâ€™t
    technically need to do that. If we tell Emscripten about the Fortran subroutine,
    we can call it directly from JavaScript without writing any C code.
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªCç¨‹åºè°ƒç”¨Fortranä»£ç ï¼Œä½†æˆ‘ä»¬æŠ€æœ¯ä¸Šä¸éœ€è¦è¿™æ ·åšã€‚å¦‚æœæˆ‘ä»¬å‘Šè¯‰Emscriptenå…³äºFortranå­ç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä»JavaScriptè°ƒç”¨å®ƒï¼Œè€Œæ— éœ€ç¼–å†™ä»»ä½•Cä»£ç ã€‚
- en: First, letâ€™s link our Fortran object with Emscripten, producing a script that
    loads our WebAssembly binary into memory but does not execute any routines. In
    addition to our symbol `_foo_`, weâ€™ll also export `_malloc` and `_free` so that
    we can use them from JavaScript.
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè®©æˆ‘ä»¬å°†æˆ‘ä»¬çš„Fortranå¯¹è±¡ä¸Emscriptené“¾æ¥ï¼Œç”Ÿæˆä¸€ä¸ªè„šæœ¬ï¼Œå°†æˆ‘ä»¬çš„WebAssemblyäºŒè¿›åˆ¶åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œä½†ä¸æ‰§è¡Œä»»ä½•ä¾‹ç¨‹ã€‚é™¤äº†æˆ‘ä»¬çš„ç¬¦å·`_foo_`ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜å°†å¯¼å‡º`_malloc`å’Œ`_free`ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥ä»JavaScriptä¸­ä½¿ç”¨å®ƒä»¬ã€‚
- en: ^(20)Â See the [Emscripten documentation](https://emscripten.org/docs/tools_reference/settings_reference.html)
    for more details about `emcc` command line options. By the way, if youâ€™ve not
    used Emscripten much before you might see extra `cache:INFO` lines emitted during
    various steps in this post. They are nothing to worry about and can be ignored.
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: ^(20)Â è¯·æŸ¥çœ‹[Emscriptenæ–‡æ¡£](https://emscripten.org/docs/tools_reference/settings_reference.html)ï¼Œä»¥è·å–æœ‰å…³`emcc`å‘½ä»¤è¡Œé€‰é¡¹çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ã€‚é¡ºä¾¿è¯´ä¸€å¥ï¼Œå¦‚æœæ‚¨ä¹‹å‰æ²¡æœ‰ä½¿ç”¨è¿‡Emscriptenï¼Œå¯èƒ½ä¼šåœ¨æœ¬æ–‡çš„å„ä¸ªæ­¥éª¤ä¸­çœ‹åˆ°é¢å¤–çš„`cache:INFO`è¡Œã€‚å®ƒä»¬æ— éœ€æ‹…å¿ƒï¼Œå¯ä»¥å¿½ç•¥ä¸è®¡ã€‚
- en: '[~/fortran]emcc foo.o -sEXPORTED_FUNCTIONS=_foo_,_malloc,_free -o foo.js'
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]emcc foo.o -sEXPORTED_FUNCTIONS=_foo_,_malloc,_free -o foo.js'
- en: 'cache:INFO: generating system asset: symbol_lists/ae47d07bfa3321ac4dde96bd87821b4aa93f9a19.json...
    (this will be cached in ".../emsdk/upstream/emscripten/cache/symbol_lists/ae47d07bfa3321ac4dde96bd87821b4aa93f9a19.json"
    for subsequent builds)'
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'cache:INFO: æ­£åœ¨ç”Ÿæˆç³»ç»Ÿèµ„äº§ï¼šsymbol_lists/ae47d07bfa3321ac4dde96bd87821b4aa93f9a19.json...ï¼ˆè¿™å°†è¢«ç¼“å­˜åˆ°".../emsdk/upstream/emscripten/cache/symbol_lists/ae47d07bfa3321ac4dde96bd87821b4aa93f9a19.json"ä»¥ä¾›åç»­æ„å»ºä½¿ç”¨ï¼‰'
- en: 'cache:INFO: - ok'
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'cache:INFO: - å®Œæˆ'
- en: '[~/fortran]node foo.js'
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]node foo.js'
- en: '[~/fortran]'
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]'
- en: Notice that when we run the script `foo.js` directlyâ€¦ nothing happens.
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå½“æˆ‘ä»¬ç›´æ¥è¿è¡Œè„šæœ¬`foo.js`æ—¶......ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚
- en: Next, weâ€™ll write a JavaScript file that loads `foo.js` and then calls our Fortran
    subroutine. Weâ€™ll need to allocate some memory to hold our integers `x`, `y` and
    `z` using the exported `_malloc()` function. Weâ€™ll also need to set our input
    arguments `x` and `y` to some integer values, and we can do that by setting values
    in the allocated WebAssembly memory through `Module.HEAPU32`.
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ç¼–å†™ä¸€ä¸ªJavaScriptæ–‡ä»¶ï¼ŒåŠ è½½`foo.js`ï¼Œç„¶åè°ƒç”¨æˆ‘ä»¬çš„Fortranå­ä¾‹ç¨‹ã€‚æˆ‘ä»¬éœ€è¦åˆ†é…ä¸€äº›å†…å­˜æ¥ä¿å­˜æˆ‘ä»¬çš„æ•´æ•°`x`ã€`y`å’Œ`z`ï¼Œä½¿ç”¨å¯¼å‡ºçš„`_malloc()`å‡½æ•°ã€‚æˆ‘ä»¬è¿˜éœ€è¦å°†æˆ‘ä»¬çš„è¾“å…¥å‚æ•°`x`å’Œ`y`è®¾ç½®ä¸ºä¸€äº›æ•´æ•°å€¼ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨åˆ†é…çš„WebAssemblyå†…å­˜ä¸­è®¾ç½®å€¼æ¥å®ç°ï¼Œä½¿ç”¨`Module.HEAPU32`ã€‚
- en: '[PRE3]'
  id: totrans-split-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*[~/fortran]node standalone.js'
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*[~/fortran]node standalone.js'
- en: x = 123
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
  zh: x = 123
- en: y = 456
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: y = 456
- en: x + y = 579
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
  zh: x + y = 579
- en: You should also be able to run the resulting WebAssembly binary in a web browser.
    Remove the line `var Module = require('./foo.js');` from `standalone.js`, and
    instead load the script `foo.js` in your HTML.
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨è¿˜åº”è¯¥èƒ½å¤Ÿåœ¨ web æµè§ˆå™¨ä¸­è¿è¡Œç”Ÿæˆçš„ WebAssembly äºŒè¿›åˆ¶æ–‡ä»¶ã€‚ä» `standalone.js` ä¸­åˆ é™¤ `var Module =
    require('./foo.js');` è¿™ä¸€è¡Œï¼Œè€Œæ˜¯åœ¨æ‚¨çš„ HTML ä¸­åŠ è½½è„šæœ¬ `foo.js`ã€‚
- en: '[PRE4]'
  id: totrans-split-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Spin up a local web server, visit the page, and the same output should be
    seen in the browserâ€™s JavaScript console.'
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*å¯åŠ¨æœ¬åœ° web æœåŠ¡å™¨ï¼Œè®¿é—®é¡µé¢ï¼ŒåŒæ ·çš„è¾“å‡ºåº”è¯¥å‡ºç°åœ¨æµè§ˆå™¨çš„ JavaScript æ§åˆ¶å°ä¸­ã€‚'
- en: '^(22)Â Something like `Rscript -e ''httpuv::runStaticServer()''` or `python3
    -m http.server` should work well.**  **## The Fortran runtime library: A journey
    to â€œHello, World!â€'
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: ^(22)Â ç±»ä¼¼ `Rscript -e 'httpuv::runStaticServer()'` æˆ– `python3 -m http.server`
    åº”è¯¥å¾ˆå¥½ç”¨ã€‚**  **## Fortran è¿è¡Œæ—¶åº“ï¼šé€šå‘â€œHello, World!â€çš„æ—…ç¨‹
- en: The ubiquitous â€œHello, World!â€ test program is the usual way to introduce a
    programming language, but I didnâ€™t introduce Fortran using such a program above.
    As youâ€™ll see, that was for a good reason. Letâ€™s see what happens when we try
    to build a â€œHello, World!â€ subroutine in Fortran and call it from C. As before,
    weâ€™ll compile the Fortran object using `flang-new` and use Emscripten to compile
    and link the C code.
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
  zh: æ™®éçš„â€œHello, World!â€æµ‹è¯•ç¨‹åºé€šå¸¸ç”¨æ¥ä»‹ç»ç¼–ç¨‹è¯­è¨€ï¼Œä½†æˆ‘æ²¡æœ‰ä½¿ç”¨è¿™æ ·çš„ç¨‹åºæ¥ä»‹ç» Fortranã€‚æ­£å¦‚æ‚¨å°†çœ‹åˆ°çš„é‚£æ ·ï¼Œè¿™æ˜¯æœ‰å……åˆ†ç†ç”±çš„ã€‚è®©æˆ‘ä»¬çœ‹çœ‹å½“æˆ‘ä»¬å°è¯•åœ¨
    Fortran ä¸­æ„å»ºä¸€ä¸ªâ€œHello, World!â€å­ç¨‹åºå¹¶ä» C è°ƒç”¨å®ƒæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚ä¸ä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ `flang-new` ç¼–è¯‘ Fortran
    å¯¹è±¡ï¼Œå¹¶ä½¿ç”¨ Emscripten ç¼–è¯‘å’Œé“¾æ¥ C ä»£ç ã€‚
- en: '[PRE5]'
  id: totrans-split-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*[PRE6]'
  id: totrans-split-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE6]'
- en: '*[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o'
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o'
- en: '[~/fortran]emcc hello.c hello.o -o hello.js'
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]emcc hello.c hello.o -o hello.js'
- en: 'wasm-ld: error: hello.o: undefined symbol: _FortranAioBeginExternalListOutput'
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'wasm-ld: error: hello.o: undefined symbol: _FortranAioBeginExternalListOutput'
- en: 'wasm-ld: error: hello.o: undefined symbol: _FortranAioOutputAscii'
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'wasm-ld: error: hello.o: undefined symbol: _FortranAioOutputAscii'
- en: 'wasm-ld: error: hello.o: undefined symbol: _FortranAioEndIoStatement'
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'wasm-ld: error: hello.o: undefined symbol: _FortranAioEndIoStatement'
- en: 'emcc: error: ''wasm-ld -o hello.wasm [...] --no-entry --stack-first --table-base=1''
    failed (returned 1)'
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'emcc: error: ''wasm-ld -o hello.wasm [...] --no-entry --stack-first --table-base=1''
    å¤±è´¥ï¼ˆè¿”å› 1ï¼‰'
- en: The build failed due to some missing symbols. This is a consequence of a more
    general issue in that we have not yet compiled the LLVM Fortran runtime library
    for WebAssembly. There are a bunch of library symbols that weâ€™re currently missing,
    including some functions that are required to print output!
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
  zh: æ„å»ºå¤±è´¥ï¼Œå› ä¸ºç¼ºå°‘ä¸€äº›ç¬¦å·ã€‚è¿™æ˜¯æˆ‘ä»¬å°šæœªä¸º WebAssembly ç¼–è¯‘ LLVM Fortran è¿è¡Œæ—¶åº“çš„ç»“æœã€‚å½“å‰ç¼ºå°‘ä¸€äº›åº“ç¬¦å·ï¼ŒåŒ…æ‹¬æ‰“å°è¾“å‡ºæ‰€éœ€çš„æŸäº›å‡½æ•°ï¼
- en: Luckily, the runtime library is written in C++ as part of the LLVM source tree
    at `llvm-project/flang/runtime`. So, in principle, all we need to do is build
    the library using Emscriptenâ€™s `em++` compiler and then link to it whenever weâ€™re
    using Fortran code in our WebAssembly program.
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼Œè¿è¡Œæ—¶åº“ä½œä¸º LLVM æºä»£ç æ ‘çš„ä¸€éƒ¨åˆ†ï¼Œä»¥ C++ ç¼–å†™åœ¨ `llvm-project/flang/runtime` ä¸­ã€‚å› æ­¤ï¼ŒåŸåˆ™ä¸Šï¼Œæˆ‘ä»¬åªéœ€ä½¿ç”¨
    Emscripten çš„ `em++` ç¼–è¯‘å™¨æ„å»ºè¯¥åº“ï¼Œç„¶ååœ¨ä½¿ç”¨ Fortran ä»£ç çš„ WebAssembly ç¨‹åºä¸­é“¾æ¥å®ƒã€‚
- en: Here is a `Makefile` designed to make this step easy. Save it in the current
    directory and then run `make`. It should go ahead and use the version of Emscripten
    on your path to build a static Fortran runtime library at `build/flang/runtime/libFortranRuntime.a`.
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ª `Makefile`ï¼Œæ—¨åœ¨ä½¿æ­¤æ­¥éª¤å˜å¾—ç®€å•ã€‚å°†å…¶ä¿å­˜åœ¨å½“å‰ç›®å½•ä¸­ï¼Œç„¶åè¿è¡Œ `make`ã€‚å®ƒåº”è¯¥ä¼šä½¿ç”¨æ‚¨è·¯å¾„ä¸Šçš„ Emscripten ç‰ˆæœ¬ï¼Œåœ¨
    `build/flang/runtime/libFortranRuntime.a` ä¸­æ„å»ºä¸€ä¸ªé™æ€ Fortran è¿è¡Œæ—¶åº“ã€‚
- en: ^(24)Â Be sure to indent the rules in this file using tabs, not spaces.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: ^(24)Â ç¡®ä¿ä½¿ç”¨åˆ¶è¡¨ç¬¦è€Œä¸æ˜¯ç©ºæ ¼æ¥ç¼©è¿›æ­¤æ–‡ä»¶ä¸­çš„è§„åˆ™ã€‚
- en: '[PRE7]'
  id: totrans-split-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*[~/fortran]make'
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*[~/fortran]make'
- en: em++ .../ISO_Fortran_binding.o -c .../ISO_Fortran_binding.cpp
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: em++ .../ISO_Fortran_binding.o -c .../ISO_Fortran_binding.cpp
- en: em++ .../allocatable.o -c .../allocatable.cpp
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: em++ .../allocatable.o -c .../allocatable.cpp
- en: em++ .../array-constructor.o -c .../array-constructor.cpp
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: em++ .../array-constructor.o -c .../array-constructor.cpp
- en: '...'
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: emar -rcs build/flang/runtime/libFortranRuntime.a .../binary-to-decimal.o
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
  zh: emar -rcs build/flang/runtime/libFortranRuntime.a .../binary-to-decimal.o
- en: '[~/fortran]file build/flang/runtime/libFortranRuntime.a'
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]file build/flang/runtime/libFortranRuntime.a'
- en: 'build/flang/runtime/libFortranRuntime.a: current ar archive'
  id: totrans-split-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'build/flang/runtime/libFortranRuntime.a: å½“å‰çš„ ar å­˜æ¡£'
- en: Letâ€™s try again, linking in our shiny new library as part of the Emscripten
    build step.
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å†è¯•ä¸€æ¬¡ï¼Œåœ¨ Emscripten æ„å»ºæ­¥éª¤ä¸­é“¾æ¥æˆ‘ä»¬é—ªäº®çš„æ–°åº“ã€‚
- en: '[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o'
  id: totrans-split-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o'
- en: '[~/fortran]emcc hello.c hello.o build/flang/runtime/libFortranRuntime.a -o
    hello.js'
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]emcc hello.c hello.o build/flang/runtime/libFortranRuntime.a -o
    hello.js'
- en: 'wasm-ld: warning: function signature mismatch: _FortranAioOutputAscii'
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'wasm-ld: warning: å‡½æ•°ç­¾åä¸åŒ¹é…ï¼š_FortranAioOutputAscii'
- en: '>>> defined as (i32, i32, i64) -> i32 in hello.o'
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> åœ¨ hello.o ä¸­å®šä¹‰ä¸º (i32, i32, i64) -> i32'
- en: '>>> defined as (i32, i32, i32) -> i32 in build/flang/runtime/libFortranRuntime.a(io-api.o)'
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> åœ¨ build/flang/runtime/libFortranRuntime.a(io-api.o) ä¸­å®šä¹‰ä¸º (i32, i32, i32)
    -> i32'
- en: Success? Not quite. A warning is issued, letting us know about a signature mismatch.
    Emscripten has compiled the symbol `_FortranAioOutputAscii` to take three `i32`
    arguments. However, `flang-new` has compiled `hello.f08` with the expectation
    that the symbol takes two `i32` arguments and a single `i64` argument.
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
  zh: æˆåŠŸäº†å—ï¼Ÿä¸å®Œå…¨ã€‚æœ‰ä¸€ä¸ªè­¦å‘Šè¢«å‘å‡ºï¼Œè®©æˆ‘ä»¬çŸ¥é“å­˜åœ¨ç­¾åä¸åŒ¹é…çš„é—®é¢˜ã€‚Emscriptenå·²ç»ç¼–è¯‘äº†ç¬¦å·`_FortranAioOutputAscii`æ¥æ¥å—ä¸‰ä¸ª`i32`å‚æ•°ã€‚ç„¶è€Œï¼Œ`flang-new`ç¼–è¯‘äº†`hello.f08`ï¼ŒæœŸæœ›è¯¥ç¬¦å·æ¥å—ä¸¤ä¸ª`i32`å‚æ•°å’Œä¸€ä¸ª`i64`å‚æ•°ã€‚
- en: ^(25)Â This is [LLVM IR notation](https://llvm.org/docs/LangRef.html#integer-type),
    meaning an integer of size 32 bits.
  id: totrans-split-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^(25)Â è¿™æ˜¯[LLVM IRæ ‡è®°](https://llvm.org/docs/LangRef.html#integer-type)ï¼Œè¡¨ç¤ºå¤§å°ä¸º32ä½çš„æ•´æ•°ã€‚
- en: ^(26)Â This continues to crop up when compiling R packages for webR. Package
    authors or vendored libraries may have used tools such as `f2c` that declare a
    Fortran `SUBROUTINE` to return an `int`, while other libraries might declare a
    Fortran `SUBROUTINE` to return `void`. Who is right? Iâ€™m not sure, as I understand
    it early Fortran did not have a standard interface to C. Personally, I think returning
    `void` makes most sense.
  id: totrans-split-197
  prefs: []
  type: TYPE_NORMAL
  zh: ^(26)Â åœ¨ç¼–è¯‘webRåŒ…æ—¶ï¼Œè¿™ç§æƒ…å†µä»ç„¶ä¼šå‡ºç°ã€‚è½¯ä»¶åŒ…ä½œè€…æˆ–ä¾›åº”çš„åº“å¯èƒ½ä½¿ç”¨äº†è¯¸å¦‚`f2c`è¿™æ ·çš„å·¥å…·ï¼Œå£°æ˜Fortran `SUBROUTINE`è¿”å›`int`ï¼Œè€Œå…¶ä»–åº“å¯èƒ½å£°æ˜Fortran
    `SUBROUTINE`è¿”å›`void`ã€‚è°æ˜¯æ­£ç¡®çš„ï¼Ÿæˆ‘ä¸ç¡®å®šï¼Œå› ä¸ºæ®æˆ‘äº†è§£ï¼Œæ—©æœŸçš„Fortranæ²¡æœ‰æ ‡å‡†çš„Cæ¥å£ã€‚ä¸ªäººè®¤ä¸ºè¿”å›`void`æ˜¯æœ€æœ‰æ„ä¹‰çš„ã€‚
- en: This is unfortunate. Despite being emitted as just a warning, if you try running
    the emitted program using Node you will see that the problem is catastrophic.
    WebAssembly, unlike a lot of target systems, absolutely requires that symbols
    defined over multiple compilation units have consistent function signatures, both
    in argument and return type.
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™çœŸæ˜¯ä¸å¹¸ã€‚å°½ç®¡åªè¢«ä½œä¸ºè­¦å‘Šå‘å‡ºï¼Œå¦‚æœæ‚¨å°è¯•ä½¿ç”¨Nodeè¿è¡Œç”Ÿæˆçš„ç¨‹åºï¼Œæ‚¨ä¼šå‘ç°é—®é¢˜æ˜¯ç¾éš¾æ€§çš„ã€‚ä¸è®¸å¤šç›®æ ‡ç³»ç»Ÿä¸åŒï¼ŒWebAssemblyç»å¯¹è¦æ±‚åœ¨å¤šä¸ªç¼–è¯‘å•å…ƒä¸­å®šä¹‰çš„ç¬¦å·å…·æœ‰ä¸€è‡´çš„å‡½æ•°ç­¾åï¼ŒåŒ…æ‹¬å‚æ•°å’Œè¿”å›ç±»å‹ã€‚
- en: '[~/fortran]node hello.js'
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]node hello.js'
- en: '.../fortran/hello.js:128'
  id: totrans-split-200
  prefs: []
  type: TYPE_NORMAL
  zh: '.../fortran/hello.js:128'
- en: throw ex;
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: throw ex;
- en: ^
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
  zh: ^
- en: 'RuntimeError: unreachable'
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'RuntimeError: unreachable'
- en: at wasm://wasm/001a0366:wasm-function[20]:0x15d9
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ wasm://wasm/001a0366:wasm-function[20]:0x15d9
- en: at removeRunDependency (/Users/georgestagg/fortran/hello.js:630:7)
  id: totrans-split-205
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ removeRunDependency (/Users/georgestagg/fortran/hello.js:630:7)
- en: Node.js v18.18.0
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js v18.18.0
- en: 'Rather than going over the debugging process that eventually leads us to what
    is going on here, let me point you directly to the cause of the problem. Take
    a look at this comment from the LLVM source:'
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å…¶è¯¦ç»†è®¨è®ºæœ€ç»ˆå¯¼è‡´è¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆçš„è°ƒè¯•è¿‡ç¨‹ï¼Œä¸å¦‚ç›´æ¥æŒ‡å‡ºé—®é¢˜çš„åŸå› ã€‚çœ‹çœ‹LLVMæºä»£ç ä¸­çš„è¿™æ¡è¯„è®ºï¼š
- en: '[PRE8]'
  id: totrans-split-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-split-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*And therein lies the problem. For us, the host is different to the target,
    breaking assumptions in the LLVM source code. Surprisingly, this does not cause
    as much chaos as you might expect. From what I can tell, this machinery is used
    only to make the Fortran runtime library functions, written in C++, available
    to Fortran. There is a compile-time calculation using `sizeof()`, and since most
    of the sizes match anyway it mostly works fine.'
  id: totrans-split-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*é—®é¢˜å°±åœ¨è¿™é‡Œã€‚å¯¹äºæˆ‘ä»¬æ¥è¯´ï¼Œä¸»æœºä¸ç›®æ ‡ä¸åŒï¼Œæ‰“ç ´äº†LLVMæºä»£ç ä¸­çš„å‡è®¾ã€‚ä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œè¿™å¹¶æ²¡æœ‰åƒä½ é¢„æœŸçš„é‚£æ ·é€ æˆå¤ªå¤šæ··ä¹±ã€‚æ®æˆ‘æ‰€çŸ¥ï¼Œè¿™ä¸ªæœºåˆ¶ä»…ç”¨äºå°†ç”¨C++ç¼–å†™çš„Fortranè¿è¡Œæ—¶åº“å‡½æ•°æä¾›ç»™Fortranä½¿ç”¨ã€‚ä½¿ç”¨äº†`sizeof()`çš„ç¼–è¯‘æ—¶è®¡ç®—ï¼Œç”±äºå¤§å¤šæ•°å¤§å°åŒ¹é…ï¼Œå®ƒåŸºæœ¬ä¸Šè¿è¡Œè‰¯å¥½ã€‚'
- en: ^(27)Â The [C data model](https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models)
    for the host and target defines how many bits certain fundamental C types are
    represented with. The specific sizes can differ based on the hardware architecture
    and your OS.
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
  zh: ^(27)Â [ä¸»æœºå’Œç›®æ ‡çš„Cæ•°æ®æ¨¡å‹](https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models)å®šä¹‰äº†ç‰¹å®šç¡¬ä»¶æ¶æ„å’Œæ“ä½œç³»ç»Ÿä¸Šå¦‚ä½•è¡¨ç¤ºæŸäº›åŸºæœ¬Cç±»å‹çš„ä½æ•°ã€‚å…·ä½“çš„å¤§å°å¯ä»¥æ ¹æ®ç¡¬ä»¶æ¶æ„å’Œæ“ä½œç³»ç»Ÿè€Œå¼‚ã€‚
- en: Unfortunately for us, assuming youâ€™re following along on a modern 64-bit Unix-like
    system such as Linux or macOS, the sizes donâ€™t match for the `long` data type.
    The result of `sizeof(long)` on our compilerâ€™s host platform is 8 bytes (`i64`),
    but for the target platform of `wasm32-unknown-emscripten` the returned value
    should be 4 bytes (`i32`).
  id: totrans-split-212
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œå‡è®¾ä½ æ­£åœ¨ä¸€å°ç°ä»£çš„64ä½ç±»Unixç³»ç»Ÿï¼Œæ¯”å¦‚Linuxæˆ–è€…macOSä¸Šè·Ÿéšï¼Œ`long`æ•°æ®ç±»å‹çš„å¤§å°å¹¶ä¸åŒ¹é…ã€‚åœ¨æˆ‘ä»¬ç¼–è¯‘å™¨çš„ä¸»æœºå¹³å°ä¸Šï¼Œ`sizeof(long)`çš„ç»“æœæ˜¯8å­—èŠ‚ï¼ˆ`i64`ï¼‰ï¼Œä½†å¯¹äº`wasm32-unknown-emscripten`ç›®æ ‡å¹³å°ï¼Œè¿”å›çš„å€¼åº”è¯¥æ˜¯4å­—èŠ‚ï¼ˆ`i32`ï¼‰ã€‚
- en: When we compile the Fortran runtime library C++ code using Emscripten, things
    are fine. The resulting symbols are compiled with signatures such that `long`
    arguments are `i32`. However, when we compile our Fortran code with `flang-new`
    the external library symbols are declared such that `long` arguments are `i64`.
    This difference leads to the inconsistent function signature warning and runtime
    failure.
  id: totrans-split-213
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬ä½¿ç”¨ Emscripten ç¼–è¯‘ Fortran è¿è¡Œæ—¶åº“çš„ C++ ä»£ç æ—¶ï¼Œä¸€åˆ‡éƒ½å¾ˆé¡ºåˆ©ã€‚ç”Ÿæˆçš„ç¬¦å·æ˜¯å¸¦æœ‰ç­¾åçš„ï¼Œä»¥ä¾¿ `long` å‚æ•°ä¸º `i32`ã€‚ç„¶è€Œï¼Œå½“æˆ‘ä»¬ä½¿ç”¨
    `flang-new` ç¼–è¯‘æˆ‘ä»¬çš„ Fortran ä»£ç æ—¶ï¼Œå¤–éƒ¨åº“ç¬¦å·å£°æ˜çš„æ˜¯ `long` å‚æ•°ä¸º `i64`ã€‚è¿™ç§å·®å¼‚å¯¼è‡´äº†ä¸ä¸€è‡´çš„å‡½æ•°ç­¾åè­¦å‘Šå’Œè¿è¡Œæ—¶å¤±è´¥ã€‚
- en: Why did using `PRINT()` in our â€œHello, World!â€ program invoke a function that
    takes an argument of type `long`? Well, in some implementations of Fortran there
    are so-called â€œhiddenâ€ arguments that are added whenever you pass a Fortran `CHARACTER`
    type to a function or subroutine. These extra arguments pass in the length of
    the strings. In the Fortran runtime library the hidden arguments are declared
    with type `size_t` which, following a chain of `typedef`s, ends up being the same
    as `unsigned long`. This hidden implicit argument is the one with inconsistent
    size.****  ***## Hacking around the issue
  id: totrans-split-214
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆåœ¨æˆ‘ä»¬çš„â€œHello, World!â€ç¨‹åºä¸­ä½¿ç”¨ `PRINT()` ä¼šè°ƒç”¨ä¸€ä¸ªå¸¦æœ‰ `long` ç±»å‹å‚æ•°çš„å‡½æ•°ï¼Ÿå—¯ï¼Œåœ¨ä¸€äº› Fortran å®ç°ä¸­ï¼Œå½“æ‚¨å°†
    Fortran `CHARACTER` ç±»å‹ä¼ é€’ç»™å‡½æ•°æˆ–å­ç¨‹åºæ—¶ï¼Œä¼šæ·»åŠ æ‰€è°“çš„â€œéšè—â€å‚æ•°ã€‚è¿™äº›é¢å¤–çš„å‚æ•°ä¼ é€’å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚åœ¨ Fortran è¿è¡Œæ—¶åº“ä¸­ï¼Œéšè—å‚æ•°å£°æ˜ä¸º
    `size_t` ç±»å‹ï¼Œéšåé€šè¿‡ä¸€ç³»åˆ— `typedef` æœ€ç»ˆå˜ä¸º `unsigned long`ã€‚è¿™ä¸ªéšè—çš„éšå¼å‚æ•°å°±æ˜¯å°ºå¯¸ä¸ä¸€è‡´çš„å‚æ•°ã€‚****  ***##
    è§£å†³é—®é¢˜çš„ä¸´æ—¶åŠæ³•
- en: Unfortunately, I donâ€™t know enough about the LLVM or Flang internals to implement
    a real solution to this problem. Ideally, `flang-new` would emit the correct use
    of `i32` or `i64` for the target architecture and data model when cross-compiling,
    no matter the host architecture the compiler is running on.
  id: totrans-split-215
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œæˆ‘å¯¹ LLVM æˆ– Flang çš„å†…éƒ¨äº†è§£ä¸å¤Ÿï¼Œæ— æ³•ä¸ºè¿™ä¸ªé—®é¢˜å®ç°çœŸæ­£çš„è§£å†³æ–¹æ¡ˆã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œå½“è¿›è¡Œäº¤å‰ç¼–è¯‘æ—¶ï¼Œæ— è®ºç¼–è¯‘å™¨è¿è¡Œåœ¨å“ªä¸ªä¸»æœºæ¶æ„ä¸Šï¼Œ`flang-new`
    éƒ½åº”è¯¥é’ˆå¯¹ç›®æ ‡æ¶æ„å’Œæ•°æ®æ¨¡å‹æ­£ç¡®åœ°ä½¿ç”¨ `i32` æˆ– `i64`ã€‚
- en: Since I canâ€™t solve this today, letâ€™s hack around it for now. Weâ€™ll build a
    version of `flang-new` with the size of a `long` hard-coded to what we need for
    `wasm32` and Emscripten. Weâ€™ll also make some changes so that calls to `malloc()`
    from Fortran are emitted with an `i32` argument.
  id: totrans-split-216
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºä»Šå¤©æˆ‘è§£å†³ä¸äº†è¿™ä¸ªé—®é¢˜ï¼Œæš‚æ—¶è®©æˆ‘ä»¬ç»•è¿‡å®ƒã€‚æˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªç‰ˆæœ¬çš„ `flang-new`ï¼Œå°† `long` çš„å¤§å°ç¡¬ç¼–ç ä¸ºæˆ‘ä»¬åœ¨ `wasm32` å’Œ
    Emscripten ä¸­éœ€è¦çš„å¤§å°ã€‚æˆ‘ä»¬è¿˜ä¼šåšä¸€äº›æ›´æ”¹ï¼Œä»¥ä¾¿ä» Fortran ä¸­å¯¹ `malloc()` çš„è°ƒç”¨å‘å‡ºå¸¦æœ‰ `i32` å‚æ•°ã€‚
- en: ^(28)Â This additionally fixes dynamic allocation with `ALLOCATE()`, a feature
    introduced in Fortran 90.
  id: totrans-split-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^(28)Â æ­¤å¤–ï¼Œè¿™è¿˜ä¿®å¤äº† Fortran 90 ä¸­å¼•å…¥çš„ `ALLOCATE()` çš„åŠ¨æ€åˆ†é…åŠŸèƒ½ã€‚
- en: The required patches are again shown as a diff below. If youâ€™re following along,
    save it as a file named `force-4-byte-values.diff` and apply it to the `llvm-project`
    directory using `git` or the `patch` utility. Finally, recompile `flang-new` once
    more.
  id: totrans-split-218
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€éœ€çš„è¡¥ä¸å¦‚ä¸‹æ‰€ç¤ºã€‚å¦‚æœæ‚¨åœ¨è·Ÿè¿›ï¼Œå°†å…¶ä¿å­˜ä¸ºåä¸º `force-4-byte-values.diff` çš„æ–‡ä»¶ï¼Œå¹¶ä½¿ç”¨ `git` æˆ– `patch`
    å®ç”¨ç¨‹åºå°†å…¶åº”ç”¨äº `llvm-project` ç›®å½•ã€‚æœ€åï¼Œé‡æ–°ç¼–è¯‘ `flang-new` ä¸€æ¬¡ã€‚
- en: '[PRE10]'
  id: totrans-split-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*[~/fortran]patch -p1 -d llvm-project < force-4-byte-values.diff'
  id: totrans-split-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*[~/fortran]patch -p1 -d llvm-project < force-4-byte-values.diff'
- en: '[~/fortran]cmake --build build'
  id: totrans-split-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]cmake --build build'
- en: '[0/60] Building CXX object tools/flang/lib/Lower/Runtime.cpp.o'
  id: totrans-split-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[0/60] æ­£åœ¨æ„å»º CXX å¯¹è±¡ tools/flang/lib/Lower/Runtime.cpp.o'
- en: '...'
  id: totrans-split-223
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[49/49] Generating ../../../../include/flang/ieee_arithmetic.f18.mod'
  id: totrans-split-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[49/49] ç”Ÿæˆ ../../../../include/flang/ieee_arithmetic.f18.mod'
- en: 'Once LLVM has been rebuilt, try compiling our program once again. This time,
    it should compile without any warnings and successfully run under Node:'
  id: totrans-split-225
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦ LLVM é‡æ–°æ„å»ºå®Œæˆï¼Œå†æ¬¡å°è¯•ç¼–è¯‘æˆ‘ä»¬çš„ç¨‹åºã€‚è¿™æ¬¡ï¼Œå®ƒåº”è¯¥å¯ä»¥åœ¨ Node ä¸‹æ— è­¦å‘Šåœ°æˆåŠŸç¼–è¯‘å¹¶è¿è¡Œäº†ã€‚
- en: '[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o'
  id: totrans-split-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o'
- en: '[~/fortran]emcc hello.c hello.o build/flang/runtime/libFortranRuntime.a -o
    hello.js'
  id: totrans-split-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]emcc hello.c hello.o build/flang/runtime/libFortranRuntime.a -o
    hello.js'
- en: '[~/fortran]node hello.js'
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]node hello.js'
- en: Hello, World!*********  ***# Compiling BLAS and LAPACK for WebAssembly
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
  zh: Hello, World!*********  ***# ä¸º WebAssembly ç¼–è¯‘ BLAS å’Œ LAPACK
- en: Now that we have a Fortran compiler that can output WebAssembly objects, letâ€™s
    build some Fortran projects. [BLAS](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms)
    (Basic Linear Algebra Subprograms) is a set of low-level routines that perform
    many common operations in linear algebra, including tools for matrix and vector
    multiplication. They are a de facto standard in numerical computation, with several
    different implementations of the BLAS routines available. Some implementations
    have been tuned for use on certain hardware, others have been well optimised on
    account of being around for a long time â€” the original BLAS routines were released
    in 1979!
  id: totrans-split-230
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªå¯ä»¥è¾“å‡º WebAssembly å¯¹è±¡çš„ Fortran ç¼–è¯‘å™¨ï¼Œè®©æˆ‘ä»¬æ„å»ºä¸€äº› Fortran é¡¹ç›®ã€‚[BLAS](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms)ï¼ˆåŸºæœ¬çº¿æ€§ä»£æ•°å­ç¨‹åºï¼‰æ˜¯ä¸€ç»„ä½çº§åˆ«ä¾‹ç¨‹ï¼Œæ‰§è¡Œçº¿æ€§ä»£æ•°ä¸­è®¸å¤šå¸¸è§æ“ä½œï¼ŒåŒ…æ‹¬çŸ©é˜µå’Œå‘é‡ä¹˜æ³•çš„å·¥å…·ã€‚å®ƒä»¬æ˜¯æ•°å€¼è®¡ç®—ä¸­çš„äº‹å®æ ‡å‡†ï¼Œæœ‰å‡ ç§ä¸åŒçš„
    BLAS ä¾‹ç¨‹å®ç°å¯ç”¨ã€‚ä¸€äº›å®ç°å·²ç»é’ˆå¯¹ç‰¹å®šç¡¬ä»¶è¿›è¡Œäº†ä¼˜åŒ–ï¼Œå…¶ä»–çš„åˆ™å› ä¸ºå­˜åœ¨æ—¶é—´è¾ƒé•¿è€Œè¿›è¡Œäº†ä¼˜åŒ– â€”â€” æœ€åˆçš„ BLAS ä¾‹ç¨‹äº 1979 å¹´å‘å¸ƒï¼
- en: Letâ€™s grab a copy of the latest release of the so-called â€œreference implementationâ€
    of BLAS, written in Fortran 90, and compile it using the patched LLVM we built
    above.
  id: totrans-split-231
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è·å–ä¸€ä»½ BLAS çš„æœ€æ–°ç‰ˆæœ¬â€œå‚è€ƒå®ç°â€ï¼Œå®ƒæ˜¯ç”¨ Fortran 90 ç¼–å†™çš„ï¼Œå¹¶ä½¿ç”¨æˆ‘ä»¬ä¸Šé¢æ„å»ºçš„è¡¥ä¸ç‰ˆ LLVM è¿›è¡Œç¼–è¯‘ã€‚
- en: '[~/fortran]curl -L https://www.netlib.org/blas/blas-3.12.0.tgz > blas-3.12.0.tgz'
  id: totrans-split-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]curl -L https://www.netlib.org/blas/blas-3.12.0.tgz > blas-3.12.0.tgz'
- en: '% Total % Received % Xferd Average Speed Time Time Time Current'
  id: totrans-split-233
  prefs: []
  type: TYPE_NORMAL
  zh: '% æ€»è®¡ % å·²ä¸‹è½½ % ä¼ è¾“ä¸­ å¹³å‡é€Ÿåº¦ æ—¶é—´ æ—¶é—´ æ—¶é—´ å½“å‰'
- en: Dload Upload Total Spent Left Speed
  id: totrans-split-234
  prefs: []
  type: TYPE_NORMAL
  zh: Dload Upload Total Spent Left Speed
- en: 100 323k 100 323k 0 0 317k 0 0:00:01 0:00:01 --:--:-- 317k
  id: totrans-split-235
  prefs: []
  type: TYPE_NORMAL
  zh: 100 323k 100 323k 0 0 317k 0 0:00:01 0:00:01 --:--:-- 317k
- en: '[~/fortran]tar xzf blas-3.12.0.tgz'
  id: totrans-split-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]tar xzf blas-3.12.0.tgz'
- en: Weâ€™ll need to modify `BLAS-3.12.0/make.inc` to tell it about our version of
    `flang-new` and the Emscripten tools. Modify the following settings, leaving the
    other lines in that file as they are, then build BLAS using `make`.
  id: totrans-split-237
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ä¿®æ”¹ `BLAS-3.12.0/make.inc`ï¼Œå‘Šè¯‰å®ƒå…³äºæˆ‘ä»¬çš„ `flang-new` ç‰ˆæœ¬å’Œ Emscripten å·¥å…·çš„ä¿¡æ¯ã€‚ä¿®æ”¹ä»¥ä¸‹è®¾ç½®ï¼Œä¿æŒè¯¥æ–‡ä»¶ä¸­çš„å…¶ä»–è¡Œä¸å˜ï¼Œç„¶åä½¿ç”¨
    `make` æ¥æ„å»º BLASã€‚
- en: '[PRE11]'
  id: totrans-split-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*[~/fortran]cd BLAS-3.12.0'
  id: totrans-split-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*[~/fortran]cd BLAS-3.12.0'
- en: '[~/fortran/BLAS-3.12.0]make'
  id: totrans-split-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran/BLAS-3.12.0]make'
- en: ../build/bin/flang-new -O2 -c -o isamax.o isamax.f
  id: totrans-split-241
  prefs: []
  type: TYPE_NORMAL
  zh: ../build/bin/flang-new -O2 -c -o isamax.o isamax.f
- en: ../build/bin/flang-new -O2 -c -o sasum.o sasum.f
  id: totrans-split-242
  prefs: []
  type: TYPE_NORMAL
  zh: ../build/bin/flang-new -O2 -c -o sasum.o sasum.f
- en: '...'
  id: totrans-split-243
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: emar cr blas_LINUX.a isamax.o ... xerbla_array.o
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
  zh: emar cr blas_LINUX.a isamax.o ... xerbla_array.o
- en: emranlib blas_LINUX.a
  id: totrans-split-245
  prefs: []
  type: TYPE_NORMAL
  zh: emranlib blas_LINUX.a
- en: '[~/fortran/BLAS-3.12.0]cd ..'
  id: totrans-split-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran/BLAS-3.12.0]cd ..'
- en: '[~/fortran]'
  id: totrans-split-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]'
- en: That went pretty well! Letâ€™s try using it in a Fortran subroutine compiled for
    WebAssembly. For fun, weâ€™ll try working with double precision complex numbers.
    Weâ€™ll use the BLAS level 2 routine [`ZGEMV()`](https://netlib.org/lapack/explore-html-3.6.1/dc/dc1/group__complex16__blas__level2_gafaeb2abd9fffa7442b938dc384aeaf47.html#gafaeb2abd9fffa7442b938dc384aeaf47),
    which performs the matrix-vector operation
  id: totrans-split-248
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£è¿›å±•ç›¸å½“é¡ºåˆ©ï¼è®©æˆ‘ä»¬å°è¯•åœ¨ä¸º WebAssembly ç¼–è¯‘çš„ Fortran å­ç¨‹åºä¸­ä½¿ç”¨å®ƒã€‚ä¸ºäº†å¥½ç©ï¼Œæˆ‘ä»¬å°†å°è¯•ä½¿ç”¨åŒç²¾åº¦å¤æ•°ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ BLAS
    2çº§ä¾‹ç¨‹ [`ZGEMV()`](https://netlib.org/lapack/explore-html-3.6.1/dc/dc1/group__complex16__blas__level2_gafaeb2abd9fffa7442b938dc384aeaf47.html#gafaeb2abd9fffa7442b938dc384aeaf47)ï¼Œå®ƒæ‰§è¡ŒçŸ©é˜µ-å‘é‡æ“ä½œã€‚
- en: \[\begin{equation} \mathbf{y} \leftarrow \alpha\mathbf{A}\mathbf{x} + \beta\mathbf{y},
    \end{equation}\]
  id: totrans-split-249
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \mathbf{y} \leftarrow \alpha\mathbf{A}\mathbf{x} + \beta\mathbf{y},
    \end{equation}\]
- en: where \(\alpha\) and \(\beta\) are scalar constants, \(\mathbf{x}\) and \(\mathbf{y}\)
    are vectors, and \(\mathbf{A}\) is a matrix. Our Fortran routine will take in
    `alpha`, `beta`, `A`, `X`, and `Y`, with a fixed parameter `N` so that \(\mathbf{A}\)
    is a square matrix with three rows and columns. The result is written back into
    \(\mathbf{y}\), so we declare that `Y` is of intent `INOUT`.
  id: totrans-split-250
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œ \(\alpha\) å’Œ \(\beta\) æ˜¯æ ‡é‡å¸¸æ•°ï¼Œ\(\mathbf{x}\) å’Œ \(\mathbf{y}\) æ˜¯å‘é‡ï¼Œ\(\mathbf{A}\)
    æ˜¯çŸ©é˜µã€‚æˆ‘ä»¬çš„ Fortran ç¨‹åºå°†æ¥æ”¶ `alpha`ã€`beta`ã€`A`ã€`X` å’Œ `Y`ï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ªå›ºå®šå‚æ•° `N`ï¼Œä½¿å¾— \(\mathbf{A}\)
    æ˜¯ä¸€ä¸ªæœ‰ä¸‰è¡Œå’Œåˆ—çš„æ–¹é˜µã€‚ç»“æœå†™å›åˆ° \(\mathbf{y}\) ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å£°æ˜ `Y` çš„æ„å›¾ä¸º `INOUT`ã€‚
- en: '[PRE12]'
  id: totrans-split-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Notice how with some BLAS routines, `CHARACTER` strings of length one control
    configuration settings. Here, we pass `''N''` as the first argument. It is one
    of the reasons we spent time and care above building a version of `flang-new`
    that can deal with `CHARACTER` arguments and their hidden implicit length arguments
    for the `wasm32` target.'
  id: totrans-split-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*è¯·æ³¨æ„ï¼Œå¯¹äºæŸäº› BLAS ä¾‹ç¨‹ï¼Œé•¿åº¦ä¸ºä¸€çš„ `CHARACTER` å­—ç¬¦ä¸²æ§åˆ¶é…ç½®è®¾ç½®ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°† `''N''` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’ã€‚è¿™æ˜¯æˆ‘ä»¬èŠ±è´¹æ—¶é—´å’Œç²¾åŠ›åœ¨ä¸Šé¢æ„å»ºä¸€ä¸ªèƒ½å¤„ç†
    `CHARACTER` å‚æ•°åŠå…¶ `wasm32` ç›®æ ‡çš„ `flang-new` ç‰ˆæœ¬çš„åŸå› ä¹‹ä¸€ã€‚'
- en: Next, weâ€™ll write a C program to create some complex variables, send them to
    Fortran and BLAS for processing, and print the result. This will let us know both
    that passing double precision complex numbers to Fortran and calling BLAS routines
    works as expected.
  id: totrans-split-253
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ç¼–å†™ä¸€ä¸ªCç¨‹åºæ¥åˆ›å»ºä¸€äº›å¤æ‚å˜é‡ï¼Œå°†å®ƒä»¬å‘é€åˆ°Fortranå’ŒBLASè¿›è¡Œå¤„ç†ï¼Œå¹¶æ‰“å°ç»“æœã€‚è¿™å°†è®©æˆ‘ä»¬çŸ¥é“å°†åŒç²¾åº¦å¤æ•°ä¼ é€’ç»™Fortranå¹¶è°ƒç”¨BLASä¾‹ç¨‹æ˜¯å¦æŒ‰é¢„æœŸå·¥ä½œã€‚
- en: '[PRE13]'
  id: totrans-split-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*[~/fortran]./build/bin/flang-new -c bar.f08 -o bar.o'
  id: totrans-split-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*[~/fortran]./build/bin/flang-new -c bar.f08 -o bar.o'
- en: '[~/fortran]emcc bar.c bar.o build/flang/runtime/libFortranRuntime.a BLAS-3.12.0/blas_LINUX.a
    -o bar.js'
  id: totrans-split-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]emcc bar.c bar.o build/flang/runtime/libFortranRuntime.a BLAS-3.12.0/blas_LINUX.a
    -o bar.js'
- en: '[~/fortran]node bar.js'
  id: totrans-split-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]node bar.js'
- en: 'Y[0]: 23.000000 + 6.000000i, Y[1]: 18.000000 + 10.000000i, Y[2]: 6.000000 +
    16.000000i'
  id: totrans-split-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'Y[0]: 23.000000 + 6.000000i, Y[1]: 18.000000 + 10.000000i, Y[2]: 6.000000 +
    16.000000i'
- en: 'And there we have it: BLAS compiled from Fortran 90 sources and running under
    WebAssembly! To finish up, letâ€™s confirm for ourselves that this output is correct,'
  id: totrans-split-259
  prefs: []
  type: TYPE_NORMAL
  zh: è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†ä»Fortran 90æºä»£ç ç¼–è¯‘çš„BLASï¼Œå¹¶åœ¨WebAssemblyä¸‹è¿è¡Œï¼æœ€åï¼Œè®©æˆ‘ä»¬äº²è‡ªç¡®è®¤è¿™ä¸ªè¾“å‡ºæ˜¯æ­£ç¡®çš„ï¼Œ
- en: ^(31)Â Keeping in mind Fortranâ€™s column-major array layout.
  id: totrans-split-260
  prefs: []
  type: TYPE_NORMAL
  zh: ^(31)Â è¯·è®°ä½Fortrançš„åˆ—ä¸»è¦æ•°ç»„å¸ƒå±€ã€‚
- en: \[\begin{equation} \begin{split} \alpha\mathbf{A}\mathbf{x} & + \beta\mathbf{y}
    \\[0.5em] & = \begin{pmatrix} i & 7 & 8\\ 4 & 2i & 9\\ 5 & 6 & 3i \end{pmatrix}
    \cdot \begin{pmatrix} 0\\1\\2 \end{pmatrix} + 2i \begin{pmatrix} 3\\4\\5 \end{pmatrix}\\[0.5em]
    & = \begin{pmatrix} 23+6i\\18+10i\\6+16i \end{pmatrix}. \end{split} \end{equation}\]
  id: totrans-split-261
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \begin{split} \alpha\mathbf{A}\mathbf{x} & + \beta\mathbf{y}
    \\[0.5em] & = \begin{pmatrix} i & 7 & 8\\ 4 & 2i & 9\\ 5 & 6 & 3i \end{pmatrix}
    \cdot \begin{pmatrix} 0\\1\\2 \end{pmatrix} + 2i \begin{pmatrix} 3\\4\\5 \end{pmatrix}\\[0.5em]
    & = \begin{pmatrix} 23+6i\\18+10i\\6+16i \end{pmatrix}. \end{split} \end{equation}\]
- en: 'Example: A handwritten digit classifier'
  id: totrans-split-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹ï¼šæ‰‹å†™æ•°å­—åˆ†ç±»å™¨
- en: The following demo uses a [multi-layer perceptron (MLP)](https://en.wikipedia.org/wiki/Multilayer_perceptron)
    artificial neural network to classify hand-drawn digits. Try it out with your
    mouse or touchscreen! Just draw a digit from 0-9 in the box, and the classifier
    will try to label what digit you wrote. The relative probabilities according to
    the network are shown in a plot on the right.
  id: totrans-split-263
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ¼”ç¤ºä½¿ç”¨[å¤šå±‚æ„ŸçŸ¥å™¨ï¼ˆMLPï¼‰](https://en.wikipedia.org/wiki/Multilayer_perceptron)äººå·¥ç¥ç»ç½‘ç»œæ¥å¯¹æ‰‹ç»˜æ•°å­—è¿›è¡Œåˆ†ç±»ã€‚ç”¨é¼ æ ‡æˆ–è§¦æ‘¸å±å°è¯•ä¸€ä¸‹å§ï¼åªéœ€åœ¨æ¡†ä¸­ç»˜åˆ¶ä¸€ä¸ª0-9çš„æ•°å­—ï¼Œåˆ†ç±»å™¨å°†å°è¯•æ ‡è®°æ‚¨å†™çš„æ˜¯ä»€ä¹ˆæ•°å­—ã€‚æ ¹æ®ç½‘ç»œçš„ç›¸å¯¹æ¦‚ç‡ï¼Œåœ¨å³ä¾§çš„å›¾ä¸­æ˜¾ç¤ºã€‚
- en: Itâ€™s not a perfect model, but it works fairly well for me! The weights powering
    the model have been pre-trained using Python, but the classification is performed
    at runtime using JavaScript and WebAssembly, running in your browser right now.
  id: totrans-split-264
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸æ˜¯ä¸€ä¸ªå®Œç¾çš„æ¨¡å‹ï¼Œä½†å¯¹æˆ‘æ¥è¯´æ•ˆæœç›¸å½“ä¸é”™ï¼è¿™ä¸ªæ¨¡å‹çš„æƒé‡å·²ç»ä½¿ç”¨Pythonè¿›è¡Œäº†é¢„è®­ç»ƒï¼Œä½†åˆ†ç±»æ˜¯åœ¨è¿è¡Œæ—¶ä½¿ç”¨JavaScriptå’ŒWebAssemblyè¿›è¡Œçš„ï¼Œåœ¨æ‚¨çš„æµè§ˆå™¨ä¸­å®æ—¶è¿è¡Œã€‚
- en: With an MLP network, the classification process is essentially a repeated application
    of matrix-vector addition and multiplication. In this demo the heavy lifting is
    done by a single Fortran subroutine making use of the BLAS level 2 routine [`DGEMV()`](https://netlib.org/lapack/explore-html-3.6.1/d7/d15/group__double__blas__level2_gadd421a107a488d524859b4a64c1901a9.html).
  id: totrans-split-265
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºMLPç½‘ç»œï¼Œåˆ†ç±»è¿‡ç¨‹å®è´¨ä¸Šæ˜¯é‡å¤åº”ç”¨çŸ©é˜µ-å‘é‡åŠ æ³•å’Œä¹˜æ³•ã€‚åœ¨è¿™ä¸ªæ¼”ç¤ºä¸­ï¼Œé€šè¿‡ä¸€ä¸ªå•ç‹¬çš„Fortranå­ç¨‹åºæ¥å®Œæˆé‡æ´»ï¼Œåˆ©ç”¨äº†BLASç¬¬2çº§ä¾‹ç¨‹[`DGEMV()`](https://netlib.org/lapack/explore-html-3.6.1/d7/d15/group__double__blas__level2_gadd421a107a488d524859b4a64c1901a9.html)ã€‚
- en: Building LAPACK
  id: totrans-split-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ„å»ºLAPACK
- en: '[LAPACK](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms) (Linear
    Algebra Package) is a software library for solving linear algebra problems numerically.
    Itâ€™s built upon BLAS and has similarly become a standard with many reimplementations
    designed for specific hardware or systems.'
  id: totrans-split-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[LAPACK](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms)ï¼ˆçº¿æ€§ä»£æ•°åŒ…ï¼‰æ˜¯ç”¨äºæ•°å€¼è§£çº¿æ€§ä»£æ•°é—®é¢˜çš„è½¯ä»¶åº“ã€‚å®ƒå»ºç«‹åœ¨BLASä¹‹ä¸Šï¼Œå¹¶ä¸”ç±»ä¼¼åœ°å·²ç»æˆä¸ºè®¸å¤šé’ˆå¯¹ç‰¹å®šç¡¬ä»¶æˆ–ç³»ç»Ÿè®¾è®¡çš„é‡æ–°å®ç°çš„æ ‡å‡†ã€‚'
- en: Letâ€™s finish this post by also building the â€œreference implementationâ€ of LAPACK.
  id: totrans-split-268
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é€šè¿‡ä¹Ÿæ„å»ºLAPACKçš„â€œå‚è€ƒå®ç°â€æ¥å®Œæˆæœ¬æ–‡ã€‚
- en: ^(32)Â Also available from [netlib](https://www.netlib.org/lapack/), released
    under a modified BSD licence.
  id: totrans-split-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^(32)Â ä¹Ÿå¯ä»[netlib](https://www.netlib.org/lapack/)è·å–ï¼Œå‘å¸ƒåœ¨ä¿®æ”¹ç‰ˆBSDè®¸å¯ä¸‹ã€‚
- en: '[~/fortran]curl -L https://github.com/Reference-LAPACK/lapack/archive/refs/tags/v3.12.0.tar.gz
    > lapack-3.12.0.tgz'
  id: totrans-split-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]curl -L https://github.com/Reference-LAPACK/lapack/archive/refs/tags/v3.12.0.tar.gz
    > lapack-3.12.0.tgz'
- en: '% Total % Received % Xferd Average Speed Time Time Time Current'
  id: totrans-split-271
  prefs: []
  type: TYPE_NORMAL
  zh: '% æ€»è®¡ % ä¸‹è½½ % Xferd å¹³å‡é€Ÿåº¦ æ—¶é—´ æ—¶é—´ å½“å‰'
- en: Dload Upload Total Spent Left Speed
  id: totrans-split-272
  prefs: []
  type: TYPE_NORMAL
  zh: Dload Upload Total Spent Left Speed
- en: 100 7747k 0 7747k 0 0 4117k 0 --:--:-- 0:00:01 --:--:-- 6655k
  id: totrans-split-273
  prefs: []
  type: TYPE_NORMAL
  zh: 100 7747k 0 7747k 0 0 4117k 0 --:--:-- 0:00:01 --:--:-- 6655k
- en: '[~/fortran]tar xzf lapack-3.12.0.tgz'
  id: totrans-split-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]tar xzf lapack-3.12.0.tgz'
- en: Similar to BLAS, we need to modify some configuration options to let LAPACK
    know about Emscripten and `flang-new`. Copy the file `lapack-3.12.0/make.inc.example`
    to `lapack-3.12.0/make.inc`, then make the following modifications. Be sure to
    replace `[...]` with the full path to the build directory on your machine, and
    leave the other options in the file as they are.
  id: totrans-split-275
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸BLASç±»ä¼¼ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹ä¸€äº›é…ç½®é€‰é¡¹ï¼Œè®©LAPACKäº†è§£Emscriptenå’Œ`flang-new`ã€‚å°†æ–‡ä»¶`lapack-3.12.0/make.inc.example`å¤åˆ¶åˆ°`lapack-3.12.0/make.inc`ï¼Œç„¶åè¿›è¡Œä»¥ä¸‹ä¿®æ”¹ã€‚ç¡®ä¿ç”¨æ‚¨æœºå™¨ä¸Šæ„å»ºç›®å½•çš„å®Œæ•´è·¯å¾„æ›¿æ¢`[...]`ï¼Œå¹¶å°†æ–‡ä»¶ä¸­çš„å…¶ä»–é€‰é¡¹ä¿æŒä¸å˜ã€‚
- en: ^(33)Â A relative path doesnâ€™t work here. Alternatively, simply set the option
    to read `flang-new` and make it available on your `$PATH`.
  id: totrans-split-276
  prefs: []
  type: TYPE_NORMAL
  zh: ^(33)Â ç›¸å¯¹è·¯å¾„åœ¨è¿™é‡Œä¸èµ·ä½œç”¨ã€‚æˆ–è€…ï¼Œç®€å•åœ°è®¾ç½®é€‰é¡¹ä»¥è¯»å–`flang-new`å¹¶åœ¨æ‚¨çš„`$PATH`ä¸Šæä¾›å®ƒã€‚
- en: '[PRE14]'
  id: totrans-split-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Then, build LAPACK using the `make lib` command to create the WebAssembly
    static library `liblapack.a`.'
  id: totrans-split-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*ç„¶åï¼Œä½¿ç”¨`make lib`å‘½ä»¤æ„å»ºLAPACKï¼Œä»¥åˆ›å»ºWebAssemblyé™æ€åº“`liblapack.a`ã€‚'
- en: '[~/fortran]cd lapack-3.12.0'
  id: totrans-split-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]cd lapack-3.12.0'
- en: '[~/fortran/lapack-3.12.0]make lib'
  id: totrans-split-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran/lapack-3.12.0]è¿›è¡Œlibåˆ¶ä½œ'
- en: make -C SRC
  id: totrans-split-281
  prefs: []
  type: TYPE_NORMAL
  zh: make -C SRC
- en: '.../build/bin/flang-new -O2 -c -o sbdsvdx.o sbdsvdx.f'
  id: totrans-split-282
  prefs: []
  type: TYPE_NORMAL
  zh: '.../build/bin/flang-new -O2 -c -o sbdsvdx.o sbdsvdx.f'
- en: '...'
  id: totrans-split-283
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: emar cr ../../libtmglib.a slatms.o ... dlarnd.o
  id: totrans-split-284
  prefs: []
  type: TYPE_NORMAL
  zh: emar cr ../../libtmglib.a slatms.o ... dlarnd.o
- en: emranlib ../../libtmglib.a
  id: totrans-split-285
  prefs: []
  type: TYPE_NORMAL
  zh: emranlib ../../libtmglib.a
- en: '[~/fortran/lapack-3.12.0]cd ..'
  id: totrans-split-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran/lapack-3.12.0]cd ..'
- en: '[~/fortran]'
  id: totrans-split-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]'
- en: '[~/fortran]file lapack-3.12.0/liblapack.a'
  id: totrans-split-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]æ–‡ä»¶lapack-3.12.0/liblapack.a'
- en: 'lapack-3.12.0/liblapack.a: current ar archive'
  id: totrans-split-289
  prefs: []
  type: TYPE_NORMAL
  zh: lapack-3.12.0/liblapack.aï¼šå½“å‰arå½’æ¡£
- en: 'With this, LAPACK routines can be called in a similar way to the BLAS routine
    example in the previous section.*  *## Example: Polynomial Interpolation with
    Linear Algebra'
  id: totrans-split-290
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äº†è¿™ä¸ªï¼Œå¯ä»¥åƒå‰é¢éƒ¨åˆ†ä¸­BLASä¾‹ç¨‹ç¤ºä¾‹ä¸­ä¸€æ ·è°ƒç”¨LAPACKä¾‹ç¨‹ã€‚*  *## ä¾‹å­ï¼šä½¿ç”¨çº¿æ€§ä»£æ•°è¿›è¡Œå¤šé¡¹å¼æ’å€¼
- en: The following demo finds interpolating polynomials for a set of points, demonstrating
    LAPACK routines running in your web browser.
  id: totrans-split-291
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ¼”ç¤ºä¸ºä¸€ç»„ç‚¹æ‰¾åˆ°æ’å€¼å¤šé¡¹å¼ï¼Œå±•ç¤ºåœ¨æ‚¨çš„Webæµè§ˆå™¨ä¸­è¿è¡Œçš„LAPACKä¾‹ç¨‹ã€‚
- en: Click the plot to add new points. An interpolating polynomial will be found
    to pass through all the points using [Vandermondeâ€™s method](https://en.wikipedia.org/wiki/Vandermonde_matrix).
    The linear algebra equation given by this method is then solved numerically in
    LAPACK using the [`DGELS()`](https://netlib.org/lapack/explore-html-3.6.1/d7/d3b/group__double_g_esolve_ga1df516c81d3e902cca1fc79a7220b9cb.html#ga1df516c81d3e902cca1fc79a7220b9cb)
    routine.
  id: totrans-split-292
  prefs: []
  type: TYPE_NORMAL
  zh: ç‚¹å‡»ç»˜å›¾ä»¥æ·»åŠ æ–°ç‚¹ã€‚å°†ä½¿ç”¨[Vandermondeæ–¹æ³•](https://en.wikipedia.org/wiki/Vandermonde_matrix)æ‰¾åˆ°ä¸€ä¸ªæ’å€¼å¤šé¡¹å¼ï¼Œè¯¥å¤šé¡¹å¼å°†é€šè¿‡æ‰€æœ‰ç‚¹ã€‚ç„¶åï¼Œä½¿ç”¨[`DGELS()`](https://netlib.org/lapack/explore-html-3.6.1/d7/d3b/group__double_g_esolve_ga1df516c81d3e902cca1fc79a7220b9cb.html#ga1df516c81d3e902cca1fc79a7220b9cb)ä¾‹ç¨‹åœ¨LAPACKä¸­å¯¹æ­¤æ–¹æ³•ç»™å‡ºçš„çº¿æ€§ä»£æ•°æ–¹ç¨‹è¿›è¡Œæ•°å€¼æ±‚è§£ã€‚
- en: ^(34)Â  It is always possible to find an \(n-1\) degree polynomial containing
    \(n\) data points exactly. However, when \(n\) is large the polynomial fluctuates
    wildly between successive data points. This problem is known as [Rungeâ€™s phenomenon](https://en.wikipedia.org/wiki/Runge%27s_phenomenon)
    and can be avoided by using [spline interpolation](https://en.wikipedia.org/wiki/Spline_interpolation).*******
  id: totrans-split-293
  prefs: []
  type: TYPE_NORMAL
  zh: ^(34)Â æ€»æ˜¯å¯ä»¥æ‰¾åˆ°ä¸€ä¸ªåŒ…å«\(n-1\)ä¸ªæ•°æ®ç‚¹çš„\(n\)æ¬¡å¤šé¡¹å¼ã€‚ç„¶è€Œï¼Œå½“\(n\)å¾ˆå¤§æ—¶ï¼Œå¤šé¡¹å¼åœ¨ç›¸é‚»æ•°æ®ç‚¹ä¹‹é—´æ³¢åŠ¨å¾ˆå¤§ã€‚è¿™ä¸ªé—®é¢˜è¢«ç§°ä¸º[Rungeç°è±¡](https://en.wikipedia.org/wiki/Runge%27s_phenomenon)ï¼Œå¯ä»¥é€šè¿‡ä½¿ç”¨[æ ·æ¡æ’å€¼](https://en.wikipedia.org/wiki/Spline_interpolation)æ¥é¿å…ã€‚*******
