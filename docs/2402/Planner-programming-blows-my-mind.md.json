["```\nmain =>\n  Arr = [a, b, c, a],\n  X = a,\n  member(X, Arr),\n  member(Y, Arr),\n  X != Y,\n  println([X, Y]). \n```", "```\n+---+\n|   |\n| G |\n|O  |\n+---+ \n```", "```\nimport planner.\nimport util.\n\nmain =>\n   Origin = {0, 0}\n   , Goal = {2, 2}\n   , Start = {Origin, Goal}\n   , best_plan(Start, Plan)\n   , println(Plan)\n   . \n```", "```\nfinal({Pos, Goal}) => Pos = Goal. \n```", "```\nfinal(S) =>\n  S = {Pos, Goal}\n  , Pos = Goal\n  . \n```", "```\naction(From, To, Action, Cost) ?=>\n  From = {{Fx, Fy}, Goal}\n  , Dir = [{-1, 0}, {1, 0}, {0, -1}, {0, 1}] \n  , member({Dx, Dy}, Dir)                    % (a)\n  , Tx = Fx + Dx\n  , Ty = Fy + Dy\n  , member(Tx, 0..10)                        % (b)\n  , member(Ty, 0..10)                        % (b)\n  , To = {{Tx, Ty}, Goal}\n  , Action = {move, To[1]}\n  , Cost = 1\n  . \n```", "```\n> picat planner1.pi\n\n[{move,{1,0}},{move,{2,0}},{move,{2,1}},{move,{2,2}}] \n```", "```\nmain =>\n  Origin = {0, 0}\n  , Goal = {2, 2}\n  , Start = {Origin, Goal}\n  , best_plan(Start, Path)\n- , println(Plan)\n+ , printf(\"Origin: %w\\n\", Origin)\n+ , printf(\"Goal: %w\\n\", Goal)\n+ , printf(\"Bounds: {10, 10}\\n\")\n+ , printf(\"Path: \")\n+ , println(join([to_string(A[2]): A in Plan], \", \"))\n  . \n```", "```\n> raku format_path.raku -bf planner1.pi\n\n+-----+\n|     |\n|     |\n|  G  |\n|  •  |\n|O••  |\n+-----+ \n```", "```\n , Tx = Fx + Dx\n  , Ty = Fy + Dy\n+ , {Tx, Ty} != {2, 1} \n```", "```\n+-----+\n|     |\n|     |\n| •G  |\n| •   |\n|O•   |\n+-----+ \n```", "```\nimport planner.\nimport util.\n\nmain =>\n  Origin = {0, 0}\n  , Goal = {2, 2}\n  , Start = {Origin, Goal}\n  , best_plan(Start, Plan)\n  % , println(Plan) \n  , printf(\"Origin: %w\\n\", Origin)\n  , printf(\"Goal: %w\\n\", Goal)\n  , printf(\"Bounds: {10, 10}\\n\")\n  , printf(\"Path: \")\n  , println(join([to_string(A[2]):  A in Plan], \", \"))\n  .\n\nfinal(S) =>\n  S = {Pos, Goal},\n  Pos = Goal.\n\naction(From, To, Action, Cost) ?=>\n  From = {{Fx, Fy}, Goal}\n  , Dir = [{-1, 0}, {1, 0}, {0, -1}, {0, 1}]\n  , member({Dx, Dy}, Dir)\n  , Tx = Fx + Dx\n  , Ty = Fy + Dy\n  % , {Tx, Ty} != {2, 1}\n  , member(Tx, 0..10)\n  , member(Ty, 0..10)\n  , To = {{Tx, Ty}, Goal}\n  , Action = {move, To[1]}\n  , Cost = 1\n  . \n```", "```\nmain =>\n  Origin = {0, 0}\n- , Goal = {2, 2}\n+ , Goal = [{2, 2}, {3, 4}] \n```", "```\naction(From, To, Action, Cost) ?=>\n  From = {Pos, Goal}\n  , Goal = [Pos|Rest]\n  , To = {Pos, Rest}\n  , Action = {mark, From[1]}\n  , Cost = 1\n  . \n```", "```\nfinal({Pos, Goal}) =>\n- Pos = Goal.\n+ Goal = []. \n```", "```\n+-----+\n|   G |\n|   • |\n|  G• |\n|  •  |\n|O••  |\n+-----+ \n```", "```\nimport planner.\nimport util.\n\nmain =>\n  Origin = {0, 0}\n  , Goal = [{2, 2}, {3, 4}]\n  %, Goal = [{9, 2}, {0, 4}, {9, 6}, {0, 9}]\n  , Start = {Origin, Goal}\n  , best_plan(Start, Plan)\n  , printf(\"Origin: %w\\n\", Origin)\n  , printf(\"Goal: %w\\n\", Goal)\n  , printf(\"Bounds: {10, 10}\\n\")\n  , printf(\"Path: \")\n  , println(join([to_string(A[2]):  A in Plan], \", \"))\n  .\n\nfinal({Pos, Goal}) =>\n  Goal = [].\n\naction(From, To, Action, Cost) ?=>\n  From = {{Fx, Fy}, Goal}\n  , Dir = [{-1, 0}, {1, 0}, {0, -1}, {0, 1}]\n  , member({Dx, Dy}, Dir)\n  , Tx = Fx + Dx\n  , Ty = Fy + Dy\n  , member(Tx, 0..10)\n  , member(Ty, 0..10)\n  , To = {{Tx, Ty}, Goal}\n  , Action = {move, To[1]}\n  , Cost = 1\n  .\n\naction(From, To, Action, Cost) ?=>\n  From = {Pos, Goal}\n  , Goal = [Pos|Rest]\n  , To = {Pos, Rest}\n  , Action = {mark, From[1]}\n  , Cost = 1\n  . \n```", "```\nmain =>\n  Origin = {0, 0}\n- , Goal = [{2, 2}, {3, 4}]\n+ , Goal = [{9, 2}, {0, 4}, {9, 6}, {0, 9}] \n```", "```\n+----------+\n|G         |\n|•         |\n|•         |\n|•••••••••G|\n|         •|\n|G•••••••••|\n|•         |\n|•••••••••G|\n|         •|\n|O•••••••••|\n+----------+ \n```", "```\naction(From, T, Action, Cost) ?=>\n  From = {Pos, Goal}\n- , Goal = [Pos|Rest]\n- , T = {Pos, Rest}\n+ , member(Pos, Goal)\n+ , T = {Pos, delete(Goal, Pos)}\n  , Action = {mark, From[1]}\n  , Cost = 1\n  . \n```", "```\n+----------+\n|G•••••••••|\n|•        •|\n|•        •|\n|•        G|\n|•        •|\n|G        •|\n|•        •|\n|•        G|\n|•         |\n|O         |\n+----------+ \n```", "```\nimport planner.\nimport util.\n\nmain =>\n  Origin = {0, 0}\n  , Goal = [{9, 2}, {0, 4}, {9, 6}, {0, 9}]\n  , Start = {Origin, Goal}\n  , best_plan(Start, Plan)\n  , printf(\"Origin: %w\\n\", Origin)\n  , printf(\"Goal: %w\\n\", Goal)\n  , printf(\"Bounds: {10, 10}\\n\")\n  , printf(\"Path: \")\n  , println(join([to_string(A[2]):  A in Plan], \", \"))\n  .\n\nfinal({Pos, Goal}) =>\n  Goal = [].\n\naction(From, To, Action, Cost) ?=>\n  From = {{Fx, Fy}, Goal}\n  , Dir = [{-1, 0}, {1, 0}, {0, -1}, {0, 1}]\n  , member({Dx, Dy}, Dir)\n  , Tx = Fx + Dx\n  , Ty = Fy + Dy\n  , member(Tx, 0..10)\n  , member(Ty, 0..10)\n  , To = {{Tx, Ty}, Goal}\n  , Action = {move, To[1]}\n  , Cost = 1\n  .\n\naction(From, To, Action, Cost) ?=>\n  From = {Pos, Goal}\n  , member(Pos, Goal)\n  , To = {Pos, delete(Goal, Pos)}\n  , Action = {mark, From[1]}\n  , Cost = 1 \n  . \n```", "```\n% got help from http://www.hakank.org/picat/set_partition.pi \nimport planner.\nimport util.\nimport cp.\n\nmain =>\nNumbers = [32, 122, 77, 86, 59, 47, 154, 141, 172, 49, 5, 62, 99, 109, 17, 30, 977]\n  , if final(Numbers) then\n      println(\"Input already has a partition!\")\n      , explain_solution(Numbers)\n    else\n        best_plan(Numbers, Plan)\n      , printf(\"Removed: %w%n\",[R: $remove(R, _) in Plan])\n      , $remove(Last, FinalState) = Plan[Plan.length]\n      , printf(\"Final: %w%n\", FinalState)\n      , explain_solution(FinalState)\n    end\n  .\n\nfinal(Numbers) => get_solutions(Numbers) != [].\n\nget_solutions(Numbers) = S =>\n  X = new_list(Numbers.length)\n  , X :: 0..1\n  , X[1] #= 0 % symmetry breaking\n  , sum(Numbers) #= 2*sum([Numbers[I]*X[I]: I in 1..Numbers.length])\n  , S = solve_all([$limit(1)], X) \n  .\n\naction(From, To, Action, Cost) =>\n   member(Element, From)\n   , To = delete(From, Element)\n   , Action = $remove(Element, To)\n   , Cost = Element\n   .\n\nexplain_solution(Numbers) =>\n  [Sol] = get_solutions(Numbers)\n  , Left =  [Numbers[I]: I in 1..Numbers.length, Sol[I] = 0]\n  , Right = [Numbers[I]: I in 1..Numbers.length, Sol[I] = 1]\n  , printf(\"%s=%d%n\", join([to_string(N): N in Left], \"+\"), sum(Left))\n  , printf(\"%s=%d%n\", join([to_string(N): N in Right], \"+\"), sum(Right))\n  . \n```", "```\nRemoved: [5,17]\nFinal: [32,122,77,86,59,47,154,141,172,49,62,99,109,30,977]\n32+99+977=1108\n122+77+86+59+47+154+141+172+49+62+109+30=1108 \n```", "```\n*** error(failed,main/0) \n```"]