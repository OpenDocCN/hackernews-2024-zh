<!--yml

category: 未分类

date: 2024-05-29 13:25:08

-->

# Netflix如何真正使用Java - InfoQ

> 来源：[https://www.infoq.com/presentations/netflix-java/](https://www.infoq.com/presentations/netflix-java/)

## 脚本

Bakker: 我要谈谈Netflix如何真正使用Java。你可能知道Netflix实际上主要是使用RxJava微服务，配合Hystrix和Spring Cloud。实际上，混沌猴（Chaos Monkeys）正在主导这个秀。我只能说到这里，因为几年前，这基本上是真实的，也许除了混沌猴。这些技术堆栈是我们在过去几年中一直在构建的。事情已经发生了变化。在这样的会议上，我经常与人们交谈，他们会说，是的，我们正在使用Netflix的技术栈。但是具体是哪个技术栈呢？几乎从来不是我们实际使用的技术栈。这些只是因为我们多年来一直在谈论我们的技术，人们才与Netflix关联起来的东西，但事情可能有所变化。我们将打破一些神话。我们将看看我们实际上是如何使用Java的。事情正在不断发展。事情真的一直在变化。

## 背景

我叫Paul。我在Netflix的Java平台工作。Java平台负责我们围绕Java构建的库、框架和工具，确保所有Java开发人员在开发Java应用时能够愉快地工作。我也是一名Java冠军。我在Java领域已经有相当长的时间了。过去，我写了两本关于Java模块化的书籍。我还是DGS框架的首批作者之一，这是我们在Java中使用的GraphQL框架。我们将详细讨论DGS及其在架构中的应用。

## 演变的架构

在我们开始深入探讨 JVM 和我们使用的 Java，以及我们使用的框架之前，我们必须更好地理解我们的架构是如何演变的。这解释了为什么几年前我们以某种方式使用 Java，而今天我们的做法完全不同。关于 Netflix 的 Java，你应该了解我们有大量的 Java。我们基本上是一个 Java 店，Netflix 的每个后端基本上都是一个 Java 应用程序。我们有许多应用程序。在 Netflix 这样的规模下，有很多内部应用程序仅用于跟踪事务。我们还是世界上最大的电影制片厂之一。有很多软件仅用于制作电影，基本上还是全部 Java。然后当然，我们有我们称之为流媒体应用的东西，基本上就是 Netflix 应用，你可能已经知道了。这就是我们在这里看到的。这个屏幕我们称之为 LOLOMO，即电影列表的列表。这只是一个由 Java 支持的应用程序的示例。你必须明白，我所说的几乎所有内容，对于基本上每一个 Java 后端来说都是正确的。我们现在几乎所有不同的系统，无论是内部系统还是面向消费者的系统，都使用相同的架构，并且在各处使用相同的技术栈。虽然我举了这个例子，因为这只是一个大的例子来玩弄，但它比那更加普遍。

## Groovy 时代

当我大约七年前加入Netflix时，我们正处于我称之为Groovy时代。关于Netflix，你可能知道的是，Netflix拥有微服务生态系统。基本上，每个功能和每个数据片段都由特定的微服务管理。它们有很多，确切地说有成千上万个。在这张幻灯片上，我只是凭自己的想法制作了一个简化版，因为这样更容易理解。想象一下LOLOMO屏幕，就是我们之前看到的电影列表的列表，你可能对那个屏幕很熟悉，为了呈现那个屏幕，我们需要从许多不同的微服务获取数据。也许有一个前十名的服务，因为我们需要一个电影的前十名列表。那个服务由一个特定的服务支持。然后还有一个艺术品服务，我们在LOLOMO中显示的图像就是从那里得到的，这些图像也都是个性化的。可能还有一个电影元数据服务，提供电影标题、演员和电影描述。可能还有一个LOLOMO服务，实际上提供我们要呈现的列表，同样也是个性化的。我说我们可能需要调用10个服务。如果你的设备，比如说你的电视或者你的iOS设备，必须要对这些不同的微服务进行10次网络调用，那将非常低效。根本不可能扩展。你将会得到一个非常糟糕的客户体验。感觉就像使用迪士尼的应用一样。这根本不理想。相反，我们需要一个API的单一入口，你的设备通过它进行调用。从那里，我们向所有不同的微服务做扇出操作，因为现在我们的网络速度非常快。现在我们可以在没有性能影响的情况下做这个扇出操作。我们还有另一个问题要解决，因为所有这些不同的设备，在微妙的方式上，它们都有一点不同。我们试图让UI在每种不同的设备上看起来和行为类似。所有这些不同的设备，比如电视与iOS设备，在内存、网络带宽方面都有非常不同的限制。它们实际上以微妙不同的方式加载数据。

想想看，你会如何创建一个适用于所有这些不同设备的 API？假设你创建了一个 REST API。我们可能会得到太少或太多的数据。如果我们创建一个 REST API 来统治它们所有，对于所有这些不同的设备来说都会是一个糟糕的体验，因为我们总是浪费一些数据，或者我们必须进行多次网络调用，这也是不好的。为了解决这个问题，我们所做的是使用我们所谓的后端为前端模式。基本上，每个前端，每个 UI 都有自己的迷你后端。这个迷你后端负责进行扇出，并获取该 UI 在特定点上确切需要的数据。它们过去是由 Groovy 脚本支持的。这个迷你后端基本上是一个特定屏幕上特定设备的 Groovy 脚本，或者实际上是特定设备版本的 Groovy 脚本。这些脚本将由 UI 开发人员编写，因为他们是唯一真正知道他们需要渲染特定屏幕所需的确切数据的人。这个 Groovy 脚本只会存在于一个 API 服务器中，这个服务器基本上是一个巨大的 Java 应用程序。它将通过调用 Java 客户端库向所有这些不同的微服务进行扇出。这些客户端库基本上只是 gRPC 服务或 REST 客户端的包装器。

现在，在这里我们开始看到一个有趣的问题，因为，在 Java 中如何处理这样的扇出？这实际上并不是微不足道的。因为如果你按照传统方式做，创建一堆线程，并开始通过最小的线程管理来管理那个扇出，那很快就会变得非常混乱，因为这不仅仅是管理一堆线程，还要处理容错。如果其中一个服务没有及时响应怎么办？如果它只是失败了？现在我们必须清理线程，并确保一切再次完美地组合在一起。再次强调，这一点根本不是微不足道的。这就是 RxJava 和响应式编程真正发挥作用的地方。因为响应式编程为你提供了一个更好的方式来进行这样的扇出。它将处理所有你需要做的线程管理等等。正是因为这种扇出行为，这就是为什么我们如此深入地涉足响应式编程领域，并且在许多年前我们在一定程度上负责使 RxJava 成为一个大事件。在 RxJava 之上，我们创建了 Hystrix，这是一个容错库，它负责故障转移和隔离以及所有这些事情。这在我七年前加入时是有很多道理的。这是当时服务大部分流量的重要架构。实际上，它仍然是我们架构的一个重要部分，因为根据你使用的设备，如果是稍旧的设备，你可能仍然会通过这个 API 被服务，因为我们不只有一个架构，我们有许多架构，因为这样更好。

## 限制

虽然这显然效果非常好，因为我们主要是基于这种架构扩展我们的成员群体。 一个缺点是每个端点都有一个脚本。 因为我们需要为这些不同的 UI 创建 API。 有很多脚本要维护和管理。 另一个问题是 UI 开发人员必须创建所有的迷你后端，因为他们知道他们需要什么数据。 现在他们处于 Groovy Java 空间，并使用 RxJava。 尽管他们非常有能力做到这一点，但这可能不是他们日常使用的主要语言。 主要问题实际上是响应式确实很难。 就我个人而言，我至少已经进行了10年的响应式编程。 我曾经对此非常兴奋，并告诉每个人它有多么棒。 事实上很难，因为即使有了这种经验，看一个非平凡的响应式代码片段，我也不知道发生了什么。 实际上，我需要花很长时间才能真正理解，好的，这实际上是发生了什么。 这些是应该发生的操作。 这是后备行为。 很难。

## GraphQL 联合

渐渐地，我们已经开始迁移到一个全新的架构，即，我们正在从不同的角度来看待事物。 这一切都基于 GraphQL 联合。 比较 GraphQL 和 REST，GraphQL 的一个非常重要的方面是，你总是有一个模式。 在你的模式中，你放置所有的操作，所以你的查询和你的变更，你定义它们，并且告诉它确切地从你的查询返回的类型中哪些字段是可用的。 在这里，我们有一个显示查询，它返回一个显示类型，一个显示作为标题，并且有评论。 评论再次是我们定义的另一种类型。 然后，我们可以向我们的 API 发送一个查询，它在幻灯片的右侧。 我们必须在那里做的事情，这也是非常重要的，我们必须明确我们的字段选择。 我们不能只要求显示并从显示获取旧数据。 现在我们必须明确地说出你要在显示上获取标题和评论上的星级评分。 如果我们不请求一个字段，我们就不会得到这个字段。 这非常重要，因为与 REST 相比，非常基本地，你得到任何 REST 服务决定发送给你的东西。 你只是得到你明确要求的数据。 如果你指定你的查询，那么更多的工作，但它解决了超获取的整个问题，在这里你得到比你实际需要的数据多得多。 这使得创建一个服务所有不同 UI 的 API 更容易。 通常，当你发送一个 GraphQL 查询时，你只会得到结果编码为 JSON。

我们不仅仅在使用 GraphQL，实际上我们正在使用 GraphQL 联合来适应我们的微服务架构。在这张图片中，我们仍然有我们的微服务，但现在我们称它们为 DGSs。这只是 Netflix 提出的一个术语。它是一个领域图服务。基本上，它只是一个 GraphQL 服务。实际上，它没有什么特别之处，但我们称它们为 DGSs。一个 DGS 只是一个 Java 微服务，但它有一个 GraphQL 终端点。它有一个 GraphQL API。这也意味着它有一个模式，因为我们说对于 GraphQL，你总是有一个模式。有趣的是，从设备的角度来看，比如从你的电视的角度来看，有一个大的 GraphQL 模式。GraphQL 模式包含了我们渲染 LOLOMO 所需的所有可能数据。你的设备并不在乎后端可能有一大堆不同的微服务，以及这些不同的微服务可能会提供部分模式。在微服务的另一侧，在这个例子中，我们的 LOLOMO DGS 正在定义一个类型 show，只有一个标题。图像 DGS 可以扩展该类型 show 并添加一个艺术品 URL。这两个不同的 DGS 互相不知道对方，只知道有一个 show 类型。它们可以在相同的类型上贡献模式的部分。他们所需要做的就是将他们的模式发布到联合网关。现在联合网关知道如何与 DGS 通信，因为它们都有一个 /GraphQL 终端点。就是这样。它知道这些不同部分的模式，所以如果一个查询过来，我们要求获取标题和艺术品 URL，它知道它必须调用这些不同的 DGS，并获取它所需要的数据。从非常高的层面来看，并不比之前有太大的不同，但在细节上有很多不同之处。

我们还要在这里改变我们的故事。首先，我们不再有任何 API 的重复。我们不再需要后端为前端，因为 GraphQL 作为 API 已经足够灵活，由于字段选择，我们不再需要创建那些特定设备的 API。这也意味着我们不再需要为 UI 工程师进行服务器端开发了。这很棒。我们确实有一个模式可以合作。这很重要，因为现在我们已经缩小了 UI 开发人员和后端工程师之间的差距，因为他们现在可以共同合作一个模式，并弄清楚，哦，我们需要以什么格式获取什么数据？非常重要的是，我们不再有任何 Java 客户端库了，因为联合网关只需知道如何与通用的 GraphQL 服务通信。它不需要特定的代码来调用特定的 API。一切都只是 GraphQL。它只需要知道如何与 GraphQL 服务通信。这就是全部。它全部基于 GraphQL 规范。我们不再需要特定的代码来调用特定的微服务了。

## 这对我们的Java堆栈意味着什么？

现在我们来看，这如何改变我们的Java堆栈？现在我们不再需要Rx、Hystrix或类似的东西，因为以前我们需要这些是因为我们需要特定的代码来调用，好的，我想调用这个微服务，然后这个微服务，同时，还有另一个微服务。我们需要一个API来做到这一点。我们不再需要了，因为这现在由GraphQL联合规范来处理了。这并不完全正确，因为联合网关本身实际上仍在使用Web客户端来调用不同的DGS，而这仍然是响应式的。然而，它不再使用任何特定于这个微服务的代码。实际上，这是一个非常简单的Web客户端代码片段，它知道，好的，我必须调用这三个服务，就去做吧。这都是GraphQL，所以非常简单。所有的DGS和后端的其他微服务都只是普通的Java应用程序。它们没有任何特定的地方需要进行响应式编程。

## 微服务中的“微”

在我们深入了解Java堆栈的其他部分之前，我想稍微谈一下微服务中的“微”这个概念，因为这是另一件人们似乎对实际运作方式感到困惑的事情。确实，一个微服务拥有特定的功能或数据集。更重要的是，这样的微服务由一个团队拥有。这是关于微服务的一个非常重要的部分。在这种GraphQL联合架构中更为真实，因为现在更容易将事物分割成不同的微服务并使其运作得非常顺畅。然而，不要被这些微服务的规模所迷惑，因为Netflix中的许多所谓微服务在代码库方面比我在许多其他公司工作过的大型单体应用还要大。其中一些系统非常庞大。那里有很多代码。当然，当它们被部署时，它们可能会被部署在成千上万个AWS实例的集群上。它们真的一点都不小。这也回答了一个问题，我应该使用微服务吗？这取决于你的团队规模。你是否只有一个团队负责一切，而且只是一个小团队？如果你在这里添加微服务，那么在那一点上你只是增加了复杂性而没有任何好的理由。如果你想将团队分成更小的团队，基本上，仅仅因为团队规模，那么将较大的系统分割成较小的部分也是有意义的，这样每个团队就可以拥有和运营一个或多个这些服务。

## Netflix的Java

是时候真正深入了解 Java 方面的事情了。我们现在在更高层次上知道我们如何以及在哪里使用 Java。现在我们谈论它实际上是什么样子。我们现在主要在使用 Java 17。是时候了。我们已经在积极测试和推广 Java 21。Java 21 刚刚正式发布。我们只是使用常规的 Azul Zulu JVM。这只是一个 OpenJDK 构建。我们不构建自己的 JVM，也没有计划去构建自己的 JVM。尽管有一个非常有趣的 Reddit 帖子声称我们这样做了。我们真的没有，也没有兴趣这样做。OpenJDK 真的非常棒。我们有大约 2800 个 Java 应用程序。这些主要是各种大小的微服务。然后大约有 1500 个内部库。其中一些是实际的库，许多只是客户端库，基本上只是坐在 gRPC 或 REST 服务的前面。对于我们的构建系统，我们使用 Gradle，而在 Gradle 之上我们有 Nebula，这是一组开源的 Gradle 插件。Nebula 最重要的方面，我强烈建议您深入研究一下，是第一次解析库。正如您所知，Java 有一个扁平的类路径。您在给定时间只能有一个版本的库，如果您有多个版本，会发生有趣的事情。为了防止这些有趣的事情发生，您真的只想选择一个版本，基本上 Nebula 会处理这些。Nebula 的下一个功能是版本锁定。基本上，您将获得可重现的构建，您总是使用相同的库版本集合构建，直到您明确升级。这使得所有过程都非常可重现。我们几乎完全使用 IntelliJ 作为我们的 IDE。在过去几年中，我们还投入了大量精力来开发 IntelliJ 插件，以帮助开发人员做正确的事情。

## Java 17 升级

我们大部分都在使用Java 17。这实际上是一件大事，因为这很尴尬，但在年初时，我们大部分还在使用Java 8。Java 8已经很老了。为什么我们还在使用Java 8呢？因为我们早就有Java 11和Java 17可用了很长时间了。不知何故，我们就是没有升级。其中一个原因是直到大约一年前，我们约一半的微服务，尤其是那些较大的微服务，仍然在使用我们旧的应用程序堆栈。那不是Spring。那是一个基于Guice的自制东西，还有很多旧的Java EE API，很多旧的不再维护的库。当我们最初开始升级到Java 11时，很多这些旧库都不兼容。然后开发人员就有了这种升级很困难，会导致问题，我可能就不要做了的印象。另一方面，对于开发人员来说，感知到的好处也非常有限，因为如果你比较Java 8和Java 17，肯定有一些不错的语言特性。仅仅文本块就足够让我升级，但这并不是什么大不了的事。8和17之间的差异很好，但并不像改变你的生活那么大。我们更期待移动到Kotlin，而不是仅仅升级到JDK。

当我们最终开始推动升级到Java 17时，我们看到了一些非常有趣的事情。我们发现在17与Java 8相比，CPU使用率提高了约20%，而没有任何代码更改。这完全是因为G1的改进，我们大部分使用的垃圾收集器。在我们运行的规模下，20%更好的CPU使用率是一件大事。这可能是很多钱。说到G1，G1是我们目前大部分工作负载使用的垃圾收集器。我们已经测试了所有可用的不同垃圾收集器。总的来说，G1通常是我们在权衡中得到最好的平衡。也有一些例外，例如我们的代理Zuul。它运行在Shenandoah上，那是低暂停时间的垃圾收集器。对于大多数工作负载，Shenandoah的表现不如G1。虽然G1不再那么令人兴奋，但它仍然非常出色。

## Java 21+

现在我们终于推动到了Java 17，大部分服务已经升级完毕，而且我们现在也有Java 21可用了。我们已经测试了好几个月了。现在事情真的变得很令人兴奋。第一个令人兴奋的是，如果你正在使用Java 17，升级到Java 21 几乎没有任何操作。这非常容易。你不会像从Java 8升级到更高版本时那样遇到问题。此外，还有很多更有趣的特性。我非常兴奋的第一个显而易见的特性是虚拟线程。这只是复制粘贴，它来自于JEP，Java 21虚拟线程的规范。它旨在使基于简单的请求线程样式编写的服务器应用在接近最优硬件利用率时扩展。听起来很不错。如果你正在使用基于servlet的东西，比如Spring Web MVC或者任何其他基于servlet的框架，请求线程就是你得到的东西。请求进来，Tomcat或者其他服务器给它一个线程。这个线程基本上就是所有工作发生或者开始发生的地方，一直持续到请求完成。这是一种非常简单且易于理解的编程风格，所有的框架都是基于这个的。它有一些可扩展性限制，因为在系统中有效运行的线程数量是有限的。如果有大量请求进来，正如我们显而易见的有，那么线程数就成为了限制系统扩展的因素。改变这种模型真的非常重要。当然，与此相对的是再次采用响应式，例如使用WebFlux。这同样会让你进入响应式编程，同样伴随我们之前讨论过的所有复杂性。

现在，我认为虚拟线程可能是自 Lambdas 以来最令人兴奋的 Java 特性。我认为在未来，它真的会改变我们编写和扩展 Java 代码的方式。我认为最终它可能会进一步减少响应式代码的使用，因为实际上再也没有必要了。它只是消除了那种复杂性。我们已经在生产环境中运行了大约一个月的虚拟线程，并对其进行了一些实验。稍后我会更详细地谈谈这方面。然后，Java 21 中另一个有趣的特性是新的垃圾收集器或更新的垃圾收集器，因为 ZGZ 并不新鲜。这在之前的版本中已经可用了。他们现在将其变成了分代的，这使得它比 G1 作为垃圾收集器提供了更多的好处。这将使得 ZGC 更适合更广泛的工作负载。它仍然专注于低暂停时间，但它将适用于更广泛的使用场景。现在说还为时过早，因为我们还没有对此进行足够的测试，但我们预计 ZGC 现在将成为我们很多工作负载和服务的真正性能升级。再次强调，这些事情对我们来说非常重要，我们可以在资源上节省很多费用。Shenandoah 现在也是分代的，但这仍然处于预览阶段。同样，我们将尝试并看看会发生什么。垃圾收集真的是一个太复杂的话题，你不能仅仅通过知道，把这个垃圾收集器和这个弹簧装进去，然后所有的一切就像魔术般地超级快。事实并非如此。这是一个你只能尝试一下，然后稍微调整一下，再尝试一下，然后找到最佳状态的业务。我们还没有完全达到那个状态。我们预计在那里会看到一些非常有趣的事情。最后，在 Java 21 中，你也有很多很好的语言特性。我们现在在 Java 语言中引入了数据导向编程的概念。这真的很不错。这是记录和模式匹配等元素的结合。目前 Java 的情况相当不错。

## 虚拟线程

回到虚拟线程。尽管我说这是一件大事，并且可能会改变我们编写代码和扩展代码的方式，但这并不是免费的午餐。你不能只是在你的实例上启用 Java 21，然后通过虚拟线程的魔法，所有东西都运行得更快。事情不是那么简单。首先，我们必须修改我们的框架库，以及在某种程度上修改应用程序代码，才能真正开始利用虚拟线程，这是第一步。有一些明显的地方我们可以这样做，并且已经开始尝试，比如 Tomcat 连接池。再次强调，这些是线程池，在那里为每个请求提供线程。这似乎是一个相当明显的地方，我们可以简单地使用虚拟线程代替。在启用它之前，您已经在生产中运行了一些启用了虚拟线程的大服务。它并不会自动使事情变得更快，因为您还需要做其他事情才能真正利用它。它也不会使事情变得更糟。如果您可以安全地启用这个功能，有时会从中获得一些好处，有时并不会真正改变它，因为它并不是限制因素。这可能是您应该首先尝试的事情。在 Spring 中的异步任务执行，同样是一个线程池，在那里通常会有其他网络调用的阻塞代码。虚拟线程似乎是一个很好的候选者，因此我们在那里启用了它。然后一个真正重要的问题，我们还没有真正深入探讨过，但我预计这将是一个改变游戏规则的问题，就是我们如何执行 GraphQL 查询。潜在地，对于 GraphQL，每个字段都可以并行获取。这使得在虚拟线程上实际执行更有意义，因为这通常是在代码中进行更多的网络调用等工作。在那里，虚拟线程就显得非常合理，但我们必须实施并测试它，可能需要一点时间才能找到最佳模型。

然后我们有一些其他看起来很明显的地方。例如，我们为 gRPC 客户端有一个线程工作池，用于处理对外服务的 gRPC 调用。这似乎是一个很明显的地方，好像我们可以在那里加入虚拟线程。然后我们发现，实际上性能下降了几个百分点。原来这些 gRPC 客户端的工作池非常消耗 CPU。如果你在那里加入虚拟线程，实际上会使情况变得更糟。这并不一定是坏事。这只是我们必须学习的东西。这表明这不是免费午餐。我们实际上必须弄清楚，在哪里有意义，在哪里没有意义，并在适当的地方实现虚拟线程，基本上。好消息是，这在大多数情况下都是框架工作。我们可以作为一个平台团队来做，我们可以在我们正在使用的开源库中来做。然后我们的开发人员基本上会得到更快的应用程序。这很好。在 Spring 6.1 或 Spring Boot 3.2 中，正在进行大量工作，以便默认支持虚拟线程，这将在下个月发布。我们可能会在明年初的某个时候采用这项技术。然后在 GitHub 上有一个非常有趣的讨论正在进行中，关于在 GraphQL Java 中改变 GraphQL 查询执行，或者甚至可能重写它以充分利用虚拟线程。这还没有确定。这是一场正在进行中的讨论。如果你在这个领域，我认为这绝对是一个值得贡献的事情。然后对于用户代码，因为所有这些其他东西大部分都是框架代码，我认为结构化并发是另一个我们将看到大量替代反应式代码的地方。因为结构化并发最终为我们提供了处理类似扇出和再聚合的 API。在 Java 21 中，结构化并发仍处于预览阶段。看起来非常接近最终版本，所以我认为至少安全地开始尝试和测试这些东西是可行的。然后再进一步，我们还会得到作用域值，这是与虚拟线程相关的另一个新规范即将发布。这将为我们提供一种基本上摆脱 ThreadLocal 的方法。这再次与框架相关的工作。这只是一个类似于 ThreadLocal 的东西，但更加优雅和高效。

## Spring Boot Netflix

我已经稍微提到过，我们在使用Spring Boot。大约一年前，我们完全标准化了Spring Boot的使用。一年前，大约50%的应用程序仍然使用我们自己编写的、基于Guice的Java堆栈，但是已经不再维护，并且使用了一堆非常过时的Java EE库。我们没有真正推动将所有东西都迁移到Spring Boot上。所有新的应用程序已经基于Spring Boot构建。这变得非常混乱，特别是因为那个旧的自家框架并没有得到很好的维护。我们付出了很大的努力，仅仅是将所有服务迁移到Spring Boot上。这次迁移主要是许多团队付出了大量的心血和汗水。从一个编程模型转到另一个编程模型并不容易。作为平台团队，我们提供了大量的工具支持，例如IntelliJ插件，尽可能地处理代码迁移和配置迁移等。尽管如此，这还是需要大量的工作。相当痛苦。不过，现在我们使用Spring Boot，我们有了一个统一的框架，使得每个人的工作都变得更加轻松。我们试图主要使用最新版本的开源Spring Boot。我们将使用3.1版本，并尽可能与开源社区保持密切联系，因为这是我们获得最大利益的地方。此外，我们需要与我们的Netflix生态系统和基础设施进行大量集成。这就是我们所说的Spring Boot Netflix，基本上只是我们在Spring Boot之上构建的一整套模块。这基本上是按照Spring Boot本身的方式开发的，所以有很多自动配置。在这里，我们添加了诸如gRPC客户端和服务器支持之类的内容，这些内容与我们的SSO堆栈（用于认证和授权）紧密集成。您可以获得可观察性，例如跟踪、指标和分布式日志记录。我们有一整套HTTP客户端，负责处理mTLS，同时也提供了可观察性和与安全堆栈集成。我们使用内嵌的Tomcat部署所有这些应用程序，这在Spring Boot应用程序中非常标准化。

为了给出特性的概念，看起来是怎样的。例如，我们有一个 gRPC Spring 客户端。这看起来非常像 Spring，但是这是我们添加的一些内容。基本上，这引用了一个属性文件，描述了 gRPC 服务，告诉服务的位置。它配置了故障转移行为。这样，你可以只需使用一个额外的注解来调用另一个 gRPC 服务的 Java API。通过这样做，你还可以免费获得完整的可观察性。对于任何请求，无论是 gRPC 还是 HTTP，你都可以通过跟踪、指标和所有这些可用的内容免费获取可观察性。另一个例子可能是与 Spring 安全集成，这样我们就可以获取我们的 SSO 颜色。即使在冷链中有很多服务，你基本上也可以获得用户，这称为你的服务。正如我所说的，我们还与 Spring Security 集成，根据我们自己的认证模型进行基于角色的认证。

## 为什么选择 Spring Boot？

你可能会想，为什么我们使用 Spring Boot，而不是一些其他更花哨的框架？因为，在过去几年中，Java 领域有很多创新框架可用。Spring Boot 确实是最流行的 Java 框架，这并不一定使它更好，但在使用开源社区时确实提供了很大的支持。对于 Spring Boot 来说，这真的很重要，因为可以访问文档、培训和所有这些内容。更重要的是，我认为，只是看看 Spring 框架，多年来它一直被良好地维护着。我想我大约15年前开始使用 Spring 框架。实际上，这相当令人惊讶，因为这个框架在多年来一直如此稳定和良好地发展，因为它并不是15年前的同一个东西，但很多概念仍然存在。基本上，这给了我们很多对 Spring 团队的信任，也相信在未来，这将是一个非常好的地方。

## 通往 Spring Boot 3 的道路

大约一年前，Spring Boot 3发布了，这是一件大事，因为Spring Boot 3实际上只涉及到了Java生态系统，我认为，因为Java生态系统在某种程度上有些停滞不前。第一个原因是，如果你看看Java的开源生态系统，它一直停留在Java 8上，因为很多公司都还停留在Java 8上，没有人愿意成为第一个打破这种情况的人。公司没有升级是因为一切在Java 8上都运行良好。现在，Spring团队终于说，我们已经完成了Java 8，Java 17是你的新基线。现在我们基本上强制整个社区说，好吧，我们将使用Java 17，一切都可以重新开始运转了。现在我们可以开始利用那些新的语言特性。虽然它只是基于Java 17，但我们实际上也可以开始使用Java 21，底层使用虚拟线程。这正是他们正在做的。第二部分是关于Javax到Jakarta的混乱，多亏了Oracle。这只是一个简单的命名空间更改，但对于库生态系统来说却非常复杂，因为一个库可以使用Javax或Jakarta，这使得它要么与一个兼容，要么与另一个兼容。现在这非常痛苦，因为Spring团队现在说，好吧，如果你只使用Jakarta，现在整个生态系统可以开始运转了，因为它产生了如此大的影响。我们终于摆脱了他们一直困在的那个点。要想转移到这些新东西仍然是一个很大的变化，所以转移到Spring Boot 3并没有完成，我们已经做了很多工具工作来实现这一点。可能最有趣的是，我们开源了一个Gradle插件，在构建解析时进行字节码转换。当你下载一个artifact，一个JAR文件时，如果你使用的是Spring Boot 3，它将把Javax转换为Jakarta，这样就可以在运行时解决整个命名空间问题，而不需要更改你的库。这让我们摆脱了困境。

## DGS框架

然后我谈了很多关于 DGS。DGS 不是一个概念，GraphQL 联邦是概念。DGS 框架只是一个框架，我们用它来构建我们的 GraphQL 服务在 Java 中。大约三四年前，当我们开始采用 GraphQL 和 GraphQL 联邦这条路线时，真的没有合适的、成熟的 Java 框架适合我们使用在我们的规模上。当时有 GraphQL Java，这是一个更低级的 GraphQL 库。那个库很好，我们正在它的基础上构建。这对我们来说是完全关键的，但它对直接在应用程序中使用来说太低级了，至少在我看来是这样。随着 v1 出现，这是一个基于注解的编程模型的 Spring Boot GraphQL 框架。我们需要像模式类型的代码生成，还有联邦的支持以及所有这些东西。这正是你在 DGS 框架中获得的。大约，我想大约三年前，我们决定开源 DGS 框架。它在 GitHub 上。这里有一个非常庞大的社区。现在许多公司都在使用它。这也正是我们在 Netflix 使用的版本，所以我们没有使用分支或其他任何东西。它在过去几年里发展得非常好。

你可能会想知道，如果你实际上在 GraphQL 和 Spring 领域，你可能已经看到在 Spring Boot 3 中，Spring 团队也增加了 GraphQL 支持，他们称之为 Spring GraphQL。对更大的社区来说，这并不理想，因为现在社区将不得不在 DGS 框架和 Spring GraphQL 之间做出选择，好吧，我要赌 DGS 框架吗？还是选择 Spring GraphQL？两者都很有趣，都很棒。两者都有一个有趣的功能集，但是不同的功能集。我该怎么做选择呢？我可以告诉你有关 DGS 框架的优势，并且如何更好地发展、更快等等，这些目前可能是真实的，因为我们已经存在了一段时间了。但问题并不在于这个，问题是你不应该被迫做出选择。 在过去的几个月中，我们一直在与 Spring 团队合作，以便在这两个框架之间实现完全集成。基本上，你可以在同一个应用程序中结合 DGS 和 Spring GraphQL 编程模型及其功能，它们会愉快地共存。这是因为我们都使用 GraphQL Java 作为底层库。这就是所有东西是如何连接在一起的。我们真正深度集成了框架。我们还在进行最后的完善，然后可能会在 2024 年初发布。至少这给你一个想法。如果你今天选择 DGS 框架并不重要。它不会让你陷入困境，无法利用 Spring 团队带来的功能，因为很快你就可以非常好地结合两者。

## 问题与答案

参与者 1：你们还在使用 Zuul 吗？

Bakker：是的。Zuul 实际上是在每一个请求前面充当代理。Zuul 主要负责流量控制，并非我们之前提到的 API 服务器。Zuul 位于 DGS 联合架构或旧架构的前端。

参与者 2：你提到 Java 升级在那里的感知价值有限。我觉得这很有意思。我认为很多企业倾向于如果没问题就不要修复它，[听不清 00:44:02]。你们是如何改变这种看法的，或者说是 Spring 升级促使你们做了这个升级？

Bakker：不，实际上主要的故事是性能的提升。我们可以说，性能提升了 20%。这个数字在不同的服务中会有所不同，具体意义也不同。但这个数字是真实的。能够这么说，这让很多服务的负责人对此更感兴趣，也促使高层领导推动说，这将节省成本，去做吧。这实际上是最有帮助的事情。Spring Boot 升级是事后发生的，也促使了这个问题，但发生在此之后。

参与者 3：在 OpenJDK 方面有很多进步，那么从 8 到 17，直接跳过了 11 吗？

Bakker：我们有服务在 Java 11 上运行，因为计划是从 8 到 11 再到 17。在 Java 11 上，我们有服务运行，但并没有真正起飞，因为效益不足。我们主要是从 8 直接升级到了 17。

参与者 3：关于收集器的一些讨论，他提到，Shenandoah 和 ZGC 会有一些影响，例如停止一切暂停和后台收集。这其中存在一些权衡，但在减少内存集合方面进行了很多改进。

参与者 4：你提到你们需要 20%，但是你们是如何确保有时间来进行实验的？你们是如何说服利益相关者说，我们将花一些时间在一些服务上进行升级，然后证明其价值的？

Bakker：有一个平台团队的好处，就像我们有的那样。如果我看我的时间，我可以做任何我想做的事情。如果我认为在垃圾收集实验中有一些有趣的失败，实际上我并不是主要做性能工作的人，其实有其他更擅长的人。这只是一个例子。如果有潜在的失败，如果你能获得时间来试验和玩耍，基本上，因为我们的时间只是一两个人，就像水中的一滴。

参与者 5：你有没有看到虚拟线程和传统线程在相同请求数和响应方面的内存占用差异？第二个问题是关于 GraphQL 和传统 SOAP 的对比，因为 SOAP 在我认为那时非常珍贵的时候就被 REST 取代了，你的网络如果不经常传输大量数据，那时非常重要。现在数据很便宜，所以有模式在客户端和服务器之间传输的劣势。我看到 GraphQL 现在也有同样的问题，现在我们有另一个查询和模式，在客户端和服务器之间传输。你如何看待 REST、SOAP 和 GraphQL 在这种推测中的表现？

Bakker：我认为 SOAP 在概念上有几点。例如，有一个模式这一点是好的。它非常难以使用和复杂，做正确的事情的开销太大了。然后 REST，至少是每个人都在使用的 REST 的方式，另一个极端，像没有模式，什么都没有定义。你只是随便扔一些数据，一切都好了。我认为 GraphQL 位于这两者之间。它对开发者来说没有太多的开销来实现模式。非常简单。比 SOAP 使用起来要容易得多。你确实会得到一个模式，这消除了只在模式中具有 REST 的许多缺点。感觉它找到了 API 的甜蜜点。也许如果我再过 10 年回到这里，我会像，“GraphQL，一个糟糕的想法。我们怎么会到达那里？”你知道怎么回事。现在，它感觉像是一个甜蜜点。

有一个差异，这就是为什么我们必须非常小心地结束虚拟线程，替换传统的线程池。这取决于这些线程池是否非常 CPU 密集，这样做或者不做都没有多大意义。内存占用似乎并不是一个重要因素。我们在那里没有看到任何显著的波动。再次强调，现在一切都处于非常早期阶段，我们只是在尝试一切。我们还没有完全弄清楚。从记忆中看来一切都很简单。

参与者 6：那我只是在想你们 Kotlin 的使用百分比是多少，看起来怎么样？

Bakker：这相当少。有段时间我们有一些团队，包括我的团队，对Kotlin非常感兴趣。DGS框架本身是用Kotlin编写的，尽管它主要面向Java应用程序。这是我的选择。我们的微服务也是用Kotlin编写的。我们唯一看到的Kotlin的缺点是我们在开发工具上的投入更多，例如IntelliJ插件和基于Gradle的自动化工具，以帮助进行与Spring的这些版本升级相关的工作。如果你必须处理多种语言，这对于平台团队的故事要难得多。因为即使是来自同一个JetBrains的IntelliJ插件，如果你想同时使用Java和Kotlin，你仍然需要在IntelliJ中写两次检查。这只是更多的工作。如果每个人都愉快地使用Java，对于平台团队来说就容易得多。但这并不意味着Kotlin不好。我们只看到了Kotlin的好处，它确实运行得相当不错。它是一种很棒的语言。

**查看更多[带有转录的演讲](https://www.infoq.com/transcripts/presentations/)**
