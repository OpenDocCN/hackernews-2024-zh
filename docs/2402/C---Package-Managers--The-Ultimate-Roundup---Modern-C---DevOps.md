<!--yml

category: 未分类

日期：2024-05-29 13:20:52

-->

# C++包管理器：终极综述 | 现代C++ DevOps

> 来源：[https://moderncppdevops.com/pkg-mngr-roundup/](https://moderncppdevops.com/pkg-mngr-roundup/)

C++的依赖管理之路经历了许多转变。早期的几年以手动库集成和复杂的构建脚本为特点，带来了重大挑战。然而，这一格局自那时起已经发生了变化，出现了一系列设计用来简化工作流程、最重要的是减轻开发者负担的复杂包管理器。

参与其中，探究这些多样化解决方案的优劣，让您能够做出明智的选择，征服C++项目中的依赖管理挑战。

## C++包管理器综述：优势和劣势[​](#comprehensive-list-of-c-package-managers-strengths-and-weaknesses "C++包管理器综述：优势和劣势的直接链接")

为了帮助您在这个多样化的环境中驾驭自如，让我们一起来*综合概述*用作C++包管理器的流行工具，途中突出它们的优势和劣势。这个列表根据相关性排序，基于诸如作为包管理器的工作效果和在生态系统中的突出程度等因素。

这个列表提供了不断变化的C++包管理格局的一个快照，但旅程并没有结束！还需要更多的反馈。您尝试过这些解决方案吗？还有遗漏的隐藏宝藏吗？觉得顺序不对吗？请在社交媒体的评论中分享您的经验和建议。

### 1\. vcpkg[​](#1-vcpkg "1\. vcpkg的直接链接")

Vcpkg是一个跨平台的C和C++库包管理器，在Windows、Linux和macOS上简化依赖获取和管理。由微软开发，它提供了一个全面的库目录，可以在本地构建，并与流行的开发环境无缝集成，并且使用命令行方便。

教程视频：[link](https://youtu.be/Ae9EePOIouU?si=fbiY7aOiAag0MCRk)

+   **优势：**

    +   大型且日益增长的库存储库

    +   易于使用

    +   与[Visual Studio](https://devblogs.microsoft.com/cppblog/vcpkg-is-now-included-with-visual-studio/)的集成良好

    +   对Windows开发有很好的支持

+   **弱点：**

    +   主要集中在开源库

    +   有限的自定义构建配置支持

    +   每次机器重新构建所有依赖项

### 2\. Conan[​](#2-conan "2\. Conan的直接链接")

Conan是一个强大而灵活的C和C++包管理器，旨在简化不同平台和构建系统之间的依赖管理。使用Conan，开发者可以轻松声明、安装和管理项目的依赖关系，确保第三方库的无缝集成，而无需繁琐的手动配置。Conan支持公共和私有包资源库，并且有助于高效依赖解析、版本管理和包重用，使开发者能够轻松简化C和C++开发工作流程。

教程视频：[link](https://youtu.be/T-5t9de1XyI?si=mRsi_Y-tnuPIsLUM)

+   **优势：**

    +   大型且日益增长的库存储库

    +   灵活且功能强大的[企业功能](https://blog.conan.io/2023/11/28/Conan-new-features-2-0-14.html)

    +   支持二进制和基于源代码的包

    +   可以管理自定义构建配置

+   **弱点：**

    +   对于中等规模项目来说，学习曲线更陡峭

    +   需要更明确的包信息

### 3\. Xrepo[​](#3-xrepo "3\. Xrepo的直接链接")

Xmake/Xrepo是一个现代化的跨平台构建系统，旨在高效编译和管理C、C++和其他编程语言项目。专注于简单性、灵活性和速度，xmake通过提供直观的基于Lua的配置文件简化了构建过程，允许开发人员简洁地描述其项目的构建要求和依赖关系。

+   **优势:**

    +   为跨平台开发设计

    +   支持更多构建系统的附加功能

    +   可以管理[构建配置](https://xmake.io/#/manual/custom_toolchain)

+   **劣势:**

    +   相对于其他选项，它是比较新的和不够成熟

    +   较小的社区和生态系统

### 4\. Spack[​](#4-spack "4\. Spack的直达链接")

Spack是科学计算和HPC环境的包管理器，可在各种架构和编译器上进行软件安装和管理，从而促进了研究和计算工作流程中的可重现性和高效协作。

+   **优势:**

    +   优秀用于科学计算和高性能计算（HPC）

    +   支持各种编译器和[构建系统](https://spack.readthedocs.io/en/latest/build_systems.html)

    +   可以管理复杂的依赖关系

+   **劣势:**

    +   可能设置和使用具有挑战性

    +   不太适合通用开发

### 5\. Hunter[​](#5-hunter "5\. Hunter的直达链接")

Hunter是一个面向C和C++项目的CMake驱动的包管理器，提供了一种简化的方式来管理依赖关系并将其集成到构建过程中，为C++项目的高效开发和合作提供了便利。

+   **优势:**

    +   简单易用

    +   适用于查找和安装特定库

    +   与CMake集成良好

+   **劣势:**

    +   需要大量[修改构建脚本](https://hunter.readthedocs.io/en/latest/quick-start/simple.html)来添加支持

    +   较小的库存储库

    +   不够灵活以管理复杂的依赖关系

### 6\. CPM[​](#6-cpm "6\. CPM的直达链接")

CPM（CMake Package Manager）是一个轻量级的包管理器，集成在项目的`CMakeLists.txt`中，可以简化依赖管理，并将外部库无缝集成到C++项目中。

+   **优势:**

    +   设计的简单易用

    +   适用于管理中小型项目的依赖关系

    +   与CMake集成良好

+   **劣势:**

    +   较小的库存储库

    +   需要[大量修改构建脚本](https://github.com/cpm-cmake/CPM.cmake/wiki/More-Snippets#rang)

    +   不如Conan那样灵活用于管理复杂的依赖关系

    +   目前没有太多活跃或开发

## 构建系统和环境管理器[​](#build-systems-and-environment-managers "构建系统和环境管理器的直达链接")

这些工具可以双管齐下。

### 7\. Meson[​](#7-meson "7\. Meson的直达链接")

Meson是一个旨在高效编译和管理C、C++和其他编程语言项目的快速且用户友好的构建系统，为简化的开发工作流程提供了简单性、速度和跨平台支持。

+   **优势:**

+   **劣势:**

    +   不是主要的包管理器，而是一个构建系统

    +   需要比其他选项更多的配置

### 8\. Bazel[​](#8-bazel "8\. Bazel的直达链接")

Bazel是谷歌开发的一个强大和可扩展的构建系统，支持包括C++在内的多种编程语言，并为大规模软件项目提供正确性、可重现性和速度。

+   **优势:**

    +   非常强大和灵活

    +   可以管理大型而复杂的项目

    +   适用于分布式构建

+   **劣势:**

### 9\. NixOS[​](#9-nixos "9\. NixOS的直达链接")

Nix软件包管理器是NixOS和其他Linux发行版中使用的功能强大且纯函数的软件包管理器。它使用户能够以可复制并且隔离的方式管理软件包和配置，从而实现原子升级和回滚。

+   **优势:**

    +   具有原子升级的纯函数包管理。

    +   跨环境的可重现构建。

    +   声明式系统配置和包管理。

    +   以隔离的包环境为重点的安全性。

+   **弱点：**

    +   由于函数式范式而存在陡峭的学习曲线。

    +   社区规模较小的平台较少。

    +   包选择可能不如专用管理器集中。

### 10\. Build2[​](#10-build2 "直达链接至 10\. Build2")

Build2 是一款为 C 和 C++ 项目设计的现代高效的构建系统，为管理依赖关系和构建软件提供了简单性、可扩展性和可靠性。

+   **优势：**

    +   涵盖整个项目生命周期：创建、开发、测试和交付。

    +   旨在使用现代构建原理重建 C++ 生态系统。

    +   跨平台和编译器的统一一致接口。

+   **弱点：**

    +   相对较新的依赖管理新功能。

    +   与已建立的工具相比，社区和生态系统较小。

    +   可能需要更多的配置和脚本知识才能充分利用。

### 11\. SCons[​](#11-scons "直达链接至 11\. SCons")

SCons 是一个用 Python 编写的软件构建工具，为 C 和 C++ 项目提供了灵活和可定制的构建系统，强调项目构建的简单性和易用性。

+   **优势：**

    +   用于管理构建系统。

    +   可与其他包管理器如 Conan 一起使用。

+   **弱点：**

    +   主要不是一个包管理器，而是一个构建系统。

    +   需要比其他一些选项更多的配置。

    +   依赖管理是一个附加的包装器。

### 12\. Tipi.Build[​](#12-tipibuild "直达链接至 12\. Tipi.Build")

Tipi.build 是一款为 C++ 项目设计的多功能和可定制的构建系统，以简单性和灵活性为设计理念，提供高效的基于云的工作流程。

教程视频：[链接](https://youtu.be/cxNDmugjlFk?si=fUnr7I73CTHWVZeJ)

+   **优势：**

    +   基于云的构建分发与缓存。

    +   旨在使用现代构建原理重建 C++ 生态系统。

    +   支持重用预编译的二进制文件。

+   **弱点：**

    +   相对于某些选项而言，相对较新且成熟度较低。

    +   与已建立的工具相比，社区和生态系统规模较小。

    +   可能需要更多的配置和脚本知识才能充分利用。

### 13\. SoupBuild[​](#13-soupbuild "直达链接至 13\. SoupBuild")

SoupBuild 是一个分布式构建系统，几乎没有兼容性定义。这类似于 Bazel 和 Vcpkg 的地盘，分别合并成一个受到 cargo 启发的构建工具链。

+   **优势：**

    +   定义了 ABI 的兼容性。

    +   重新构建源代码并分发构建。

+   **弱点：**

    +   对不同工具链的支持有限。

    +   非常偏执。

    +   仅处于 Alpha 预览阶段。

### 14\. Pixi（prefix-dev）[​](#14-pixi-prefix-dev "直达链接至 14\. Pixi（prefix-dev）")

+   **优势：**

    +   简化的体验与类似于 Cargo 的 CLI。

    +   项目内的多语言支持。

    +   项目特定的环境和自动锁定文件。

    +   建立在 conda 的包生态系统之上。

+   **弱点：**

    +   相对较新且成熟度较低，社区和生态系统较小。

    +   与专门的管理器相比，C++ 包选择有限。

    +   由于多语言管理而可能存在的潜在复杂性。

### 15\. Mamba[​](#15-mamba "直达链接至 15\. Mamba")

+   **优势：**

    +   针对速度优化的 conda 的重新实现。

    +   基于现有的依赖解析器实现。

    +   轻量级客户端，具有一组核心功能以提高易用性。

    +   建立在 conda 的包生态系统之上。

+   **弱点：**

    +   相对较新且成熟度较低，社区和生态系统较小。

    +   与专用管理器相比，C++ 包选择有限。

    +   可能会引入与标准 C++ 构建系统和工具的挑战。

### 16\. Gradle[​](#16-gradle "直达链接至 16\. Gradle")

[Gradle](https://gradle.org/) 是一种以其灵活性和可扩展性而闻名的构建自动化工具，主要用于 Java 项目，但也支持通过插件支持其他语言如 C++。它处理软件的依赖管理、编译、测试和打包。

+   **优势：**

    +   在管理包括C++在内的各种依赖关系的复杂构建系统方面经得起考验。

    +   设计用于跨平台开发

    +   与Java和其他生态系统的集成

+   **弱点：**

    +   不是主要的C++软件包管理器

    +   仓库有限。虽然存在像Gradle CppPlugin和CMakePlugin这样的插件，但C++软件包仓库不如专用管理器广泛。

    +   与一些C++特定工具相比，学习曲线更陡峭。

    +   对于简单的C++项目性能开销较大

### 17\. Conda[​](#17-conda "17\. Conda的直接链接")

[Conda](https://docs.conda.io/en/latest/)是一个多功能的软件包管理器和环境管理系统，主要用于Python，但也支持其他语言如C++和R。它简化了依赖关系管理，并实现了在不同平台上轻松创建、共享和复制软件环境。

+   **优势：**

    +   成熟并且已建立了广泛的软件包生态系统，涵盖了各种语言。

    +   跨平台兼容性。

    +   对于项目或系统具有灵活的环境管理。

    +   复杂情景下的强大依赖关系管理。

+   **弱点：**

    +   与较简单的工具（如Hunter或CPM）相比，学习曲线更陡峭。

    +   不是专门为C++开发设计的，需要额外的设置来处理C++软件包。

    +   C++软件包选择可能比专用C++软件包管理器小。

### 18\. BitBake[​](#18-bitbake "18\. BitBake的直接链接")

Yocto项目的 [BitBake](https://docs.yoctoproject.org/bitbake/dev/index.html) 是一个完整的嵌入式Linux系统创建环境。BitBake是Yocto中用于管理整个构建过程的构建工具，包括编译源代码、打包软件和为目标设备创建最终操作系统映像。

+   **优势：**

    +   在Yocto项目中实现简化的工作流程，从源代码到最终映像管理依赖关系。

    +   通过在Yocto配置中严格控制软件包版本，确保一致的构建。

+   **弱点：**

    +   主要设计用于Yocto项目和嵌入式开发，不太适合一般的C/C++项目。

    +   严重依赖于从源代码构建依赖关系，可能耗时。

    +   对于初学者来说，管理Yocto配方中的依赖关系可能会很复杂。

    +   与一些软件包管理器相比，版本约束。

### 19\. CMake的FetchContent[​](#19-cmakes-fetchcontent "19\. CMake的FetchContent的直接链接")

+   **优势：**

    +   无缝集成避免了外部工具和复杂性。

    +   支持各种下载方法（git、存档等）并允许定制。

    +   在配置步骤中允许使用内容（如头文件）。

+   **弱点：**

    +   主要用于下载，而不是高级依赖关系管理。

    +   需要复杂设置的脚本知识。

    +   缺乏仓库和版本控制等功能。

这是一个额外的提醒。你不应该考虑这些，但它们值得称赞。

### 20\. Buckaroo[​](#20-buckaroo "20\. Buckaroo的直接链接")

Buckaroo是为使用Buck构建系统的C++开发人员设计的软件包管理器，简化了依赖管理，并将其集成到项目中，以实现高效的开发工作流程。

+   **优势：**

    +   面向具有许多依赖关系的大型项目设计

    +   可以管理复杂的构建系统

    +   与其他Buckaroo工具很好地集成

+   **弱点：**

### 21\. Biicode[​](#21-biicode "21\. Biicode的直接链接")

+   **优势：**

    +   专注于依赖管理，易于使用

+   **弱点：**

### 22\. CGet[​](#22-cget "22\. CGet的直接链接")

[CGet](https://cget.readthedocs.io/en/latest/)是一个专为与CMake和非CMake软件包一起工作而设计的软件包管理器。它提供了一种灵活的方式，可以从目录、文件URL或Github存储库安装软件包。

+   **优势：**

    +   CGet可以管理CMake和非CMake软件包，使其成为各种项目需求的多功能工具。

    +   它可以从各种来源安装包，包括目录、文件 URL 和 Git 仓库。甚至还有 [recipes](https://github.com/pfultz2/cget-recipes) 的概念。支持使用 `requirements.txt`。

    +   与 CMake 完美集成，可以在项目的构建系统中轻松进行包管理。

+   **弱点：**

    +   不再维护。

    +   尽管它可以处理非 CMake 包，但 CGet 的核心功能围绕着 CMake，这可能使其对于没有 CMake 依赖的项目不太合适。

### 23\. Teaport[​](#23-teaport "23\. Teaport的直接链接")

[Teaport](https://bitbucket.org/benman/teaport/src/master/) 是专为 C++ 项目设计的依赖管理器，受到 CocoaPods 简单和灵活性的启发。它优先利用现有工具，并专注于提供依赖管理和构建系统之间的分离。

+   **优点：**

    +   支持依赖来源的灵活性，支持 Git 仓库、目录和 ZIP 存档。这满足了多样化的项目结构，并简化了依赖获取。

    +   利用版本锁定文件（`project.teaspec.lock`）来保证通过锁定确切的依赖版本而实现可复制的构建。

    +   支持多个依赖变体，可以根据特定要求进行选择（例如，不同的架构或库版本）。

+   **弱点：**

    +   不再维护。

    +   对于分发类似 `scp`、`ssh` 和 `rsync` 这样的源码的基本文件复制依赖。与具有负载均衡器或 CDN 的 HTTP 相比，扩展性较差。

### 24\. C++ 存档网络[​](#24-c-archive-network "24\. C++ 存档网络的直接链接")

+   **优点：**

    +   支持 [Waf](https://waf.io/) 构建系统

+   **弱点：**

    +   不再主要设计用于 C++ 开发

## 选择正确的包管理器[​](#choosing-the-right-package-manager "选择正确的包管理器的直接链接")

最适合你的 C++ 包管理器取决于你的具体需求和偏好。考虑因素包括：

+   **项目的规模和范围：** 对于小型项目，像 CPM 或 Hunter 这样的简单管理器可能已经足够了。对于较大的项目，像 Conan 这样的更强大的管理器可能是必需的。

+   **你需要的库的类型：** 如果你主要需要开源库，vcpkg 是一个不错的选择。如果你需要更专业或行业特定的库，Spack 可能是一个更好的选择。

+   **你的经验水平：** 如果你是新手 C++ 包管理器用户，vcpkg 或 Conan 是非常不错的选择，可以让你很快上手。

最终，选择一个 C++ 包管理器的最佳方法是尝试几种不同的选项，看看哪个最适合你。

+   2024-02-13: 添加了由 u/mjklaim 建议的 Mamba

+   2024-02-20: 由 u/mwasplund 建议添加了 SoupBuild

+   2024-04-07:

    +   将 NixOS 移动到列表上方，因为在包选择和平台限制方面与其能够创建专用环境之间存在差异。

    +   将 Buckaroo 移动到荣誉提名中，因为已经三年没有更新了。

    +   添加了 BitBake

+   2024-04-11: 从 [cppreference](https://en.cppreference.com/w/cpp/links/libs#Package_managers) 添加了 CGet 和 Teaport
