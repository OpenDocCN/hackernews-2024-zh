- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:51:23'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: A gentle introduction to automated reasoning - Amazon Science
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.amazon.science/blog/a-gentle-introduction-to-automated-reasoning](https://www.amazon.science/blog/a-gentle-introduction-to-automated-reasoning)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This week, Amazon Science added [automated reasoning](https://www.amazon.science/research-areas/automated-reasoning)
    to its list of research areas. We made this change because of the impact that
    automated reasoning is having here at Amazon. For example, Amazon Web Services’
    customers now have direct access to automated-reasoning-based features such as
    [IAM Access Analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/what-is-access-analyzer.html),
    [S3 Block Public Access](https://aws.amazon.com/blogs/aws/amazon-s3-block-public-access-another-layer-of-protection-for-your-accounts-and-buckets/),
    or [VPC Reachability Analyzer](https://docs.aws.amazon.com/vpc/latest/reachability/what-is-reachability-analyzer.html).
    We also see Amazon development teams [integrating automated-reasoning tools](https://www.amazon.science/blog/how-automated-reasoning-improves-the-prime-video-experience)
    into their development processes, raising the bar on the [security](https://www.amazon.science/latest-news/how-awss-automated-reasoning-group-helps-make-aws-and-other-amazon-products-more-secure),
    [durability](https://www.amazon.science/blog/aws-team-wins-best-paper-award-for-work-on-automated-reasoning),
    availability, and quality of our products.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this article is to provide a gentle introduction to automated reasoning
    for the industry professional who knows nothing about the area but is curious
    to learn more. All you will need to make sense of this article is to be able to
    read a few small C and Python code fragments. I will refer to a few specialist
    concepts along the way, but only with the goal of introducing them in an informal
    manner. I close with links to some of our favorite publicly available tools, videos,
    books, and articles for those looking to go more in-depth.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a simple example. Consider the following C function:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Take a few moments to answer the question *“Could *f* ever return false?”*
    This is not a trick question: I’ve purposefully used a simple example to make
    a point.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the answer with exhaustive testing, we could try executing the following
    doubly nested test loop, which calls *f* on all possible pairs of values of the
    type unsigned int:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unfortunately, even on modern hardware, this doubly nested loop will run for
    a *very long* time. I compiled it and ran it on a 2.6 GHz Intel processor for
    over 48 hours before giving up.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Why does testing take so long? Because UINT_MAX is typically 4,294,967,295,
    there are 18,446,744,065,119,617,025 separate *f* calls to consider. On my 2.6
    GHz machine, the compiled test loop called *f* approximately 430 million times
    a second. But to test all 18 quintillion cases at this performance, we would need
    over 1,360 years.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: When we show the above code to industry professionals, they almost immediately
    work out that *f* can't return false as long as the underlying compiler/interpreter
    and hardware are correct. How do they do that? They *reason* about it. They remember
    from their school days that *x + y* can be rewritten as *y + x* and conclude that
    *f* always returns true.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Re:Invent 2021 keynote address by Peter DeSantis, senior vice president for
    utility computing at Amazon Web Services
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Skip to
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[15:49](https://youtu.be/9NEQbFLtDmg?t=949)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: for a discussion of Amazon Web Services' work on automated reasoning.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'An *automated* reasoning tool does this work for us: it attemptsto answer questions
    about a program (or a logic formula) by using known techniques from mathematics.
    In this case, the tool would use algebra to deduce that *x + y == y + x* can be
    replaced with the simple expression true.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Automated-reasoning tools can be incredibly fast, even when the domains are
    infinite (e.g., unbounded mathematical integers rather than finite C ints). Unfortunately,
    the tools may answer *“Don’t know” *in some instances. We'll see a famous example
    of that below.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The *science* of automated reasoning is essentially focused on driving the
    frequency of these *“Don’t know”* answers down as far as possible: the less often
    the tools report *"Don''t know"* (or time out while trying), the more useful they
    are.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Today’s tools are able to give answers for programs and queries where yesterday’s
    tools could not. Tomorrow’s tools will be even more powerful. We are seeing rapid
    progress in this field, which is why at Amazon, we are increasingly getting so
    much value from it. In fact, we see automated reasoning forming its own Amazon-style
    virtuous cycle, where more input problems to our tools drive improvements to the
    tools, which encourages more use of the tools.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: A slightly more complex example. Now that we know the rough outlines of what
    automated reasoning is, the next small example gives a slightly more realistic
    taste of the sort of complexity that the tools are managing for us.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or, alternatively, consider a similar Python program over unbounded integers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Try to answer this question: *“Does *g* always eventually return control back
    to its caller?”*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: When we show this program to industry professionals, they usually figure out
    the right answer quickly. A few, especially those who are aware of results in
    theoretical computer science, sometimes mistakenly think that we can't answer
    this question, with the rationale *“This is an example of the *[*halting problem*](https://en.wikipedia.org/wiki/Halting_problem)*,
    which has been proved insoluble”. *In fact, we *can *reason about the halting
    behavior for *specific* programs, including this one. We’ll talk more about that
    later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the reasoning that most industry professionals use when looking at this
    problem:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In the case where *y* is not positive, execution jumps to the end of the function *g*.
    That’s the easy case.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If, in every iteration of the loop, the value of the variable *x* decreases,
    then eventually, the loop condition *x* > *y* will fail, and the end of *g* will
    be reached.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of *x* always decreases only if *y* is always positive, because only
    then does the update to x (i.e., *x* = *x* - *y*) decrease *x*. But *y*’s positivity
    is established by the conditional expression, so *x* always decreases.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The experienced programmer will usually worry about underflow in the *x* = *x*
    - *y* command of the C program but will then notice that *x* > *y* before the
    update to *x* and thus cannot underflow.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: If you carried out the three steps above yourself, you now have a very intuitive
    view of the type of thinking an automated-reasoning tool is performing on our
    behalf when reasoning about a computer program. There are many nitty-gritty details
    that the tools have to face (e.g., heaps, stacks, strings, pointer arithmetic,
    recursion, concurrency, callbacks, etc.), but there’s also decades of research
    papers on techniques for handling these and other topics, along with various practical
    tools that put these ideas to work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Automated reasoning can be applied to both policies *(top)* and code *(bottom)*.
    In both cases, an essential step is reasoning about what's *always* true.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The main takeaway is that automated-reasoning tools are usually working through
    the three steps above on our behalf: Item 1 is reasoning about the program’s *control
    structure*. Item 2 is reasoning about what is *eventually* true within the program.
    Item 3 is reasoning about what is *always* true in the program.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Note that configuration artifacts such as AWS resource policies, VPC network
    descriptions, or even makefiles can be thought of as code. This viewpoint allows
    us to use the same techniques we use to reason about C or Python code to answer
    questions about the *interpretation* of configurations. It’s this insight that
    gives us tools like IAM Access Analyzer or VPC Reachability Analyzer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: ''
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An end to testing?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: As we saw above when looking at *f* and *g*, automated reasoning can be dramatically
    faster than exhaustive testing. With tools available today, we can show properties
    of *f* or *g* in milliseconds, rather than waiting lifetimes with exhaustive testing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we throw away our testing tools now and just move to automated reasoning?
    Not quite. Yes, we can dramatically reduce our dependency on testing, but we will
    not be completely eliminating it any time soon, if ever. Consider our first example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Recall the worry that a buggy compiler or microprocessor could in fact cause
    an executable program constructed from this source code to return false. We might
    also need to worry about the language runtime. For example, the C math library
    or the Python garbage collector might have bugs that cause a program to misbehave.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: What’s interesting about testing, and something we often forget, is that it’s
    doing much more than just telling us about the C or Python source code. It’s also
    testing the compiler, the runtime, the interpreter, the microprocessor, etc. A
    test failure could be rooted in any of those tools in the stack.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Automated reasoning, in contrast, is usually applied to just one layer of that
    stack — the source code itself, or sometimes the compiler or the microprocessor.
    What we find so valuable about reasoning is it allows us to clearly define both
    what we *do* know and what we *do not* know about the layer under inspection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the models of the surrounding environment (e.g., the compiler or
    the procedure calling our procedure) used by the automated-reasoning tool make
    our assumptions *very* precise. Separating the layers of the computational stack
    helps make better use of our time, energy, and money and the capabilities of the
    tools today and tomorrow.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we will almost always need to make assumptions about *something *when
    usingautomated reasoning — for example, the principles of physics that govern
    our silicon chips. Thus, testing will never be fully replaced. We will want to
    perform end-to-end testing to try and validate our assumptions as best we can.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: ''
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An impossible program
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: I previously mentioned that automated-reasoning tools sometimes return *“Don’t
    know”* rather than *“yes”* or *“no”*. They also sometimes run forever (or time
    out), thus never returning an answer. Let’s look at the famous "halting problem"
    program, in which we know tools *cannot* return *“yes”* or *“no”*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have an automated-reasoning API, called *terminates*, that returns
    *“yes” *if a C function always terminates or *“no” *when the function could execute
    forever. As an example, we could build such an API using the tool described [here](https://vimeo.com/81641895)
    (shameless self-promotion of author’s previous work). To get the idea of what
    a termination tool can do for us, consider two basic C functions, *g* (from above),
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'and g2:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For the reasons we have already discussed, the function *g* always returns control
    back to its caller, so *terminates(g)* should return true. Meanwhile, *terminates(g2)*
    should return false because, for example, *g2(5, 0)* will never terminate.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the difficult function. Consider *h*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that it's recursive. What’s the right answer for *terminates(h)*? The
    answer cannot be "yes". It also cannot be "no". Why?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that *terminates(h)* were to return "yes". If you read the code of *h*,
    you’ll see that in this case, the function does not terminate because of the conditional
    statement in the code of *h* that will execute the infinite loop *while(1){}*.
    Thus, in this case, the *terminates(h)* answer would be wrong, because *h* is
    defined recursively, calling terminates on itself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下*terminates(h)*返回“是”的情况。如果你阅读*h*的代码，你会看到，因为*h*代码中的条件语句会执行无限循环*while(1){}*，所以这个函数在这种情况下不会终止。因此，在这种情况下，*terminates(h)*的答案是错误的，因为*h*被递归定义，调用自身。
- en: Similarly, if *terminates(h)* were to return "no", then *h* would in fact terminate
    and return control to its caller, because the *if* case of the conditional statement
    is not met, and there is no else branch. Again, the answer would be wrong. This
    is why the *“Don’t know”* answer is actually unavoidable in this case.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果*terminates(h)*返回“否”，那么*h*实际上会终止并返回控制给它的调用者，因为条件语句的*if*分支不满足，并且没有else分支。再次，答案是错误的。这就是为什么在这种情况下*“不知道”*的答案实际上是不可避免的。
- en: The program *h* is a variation of examples given in Turing’s [famous 1936 paper](https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf)
    on decidability and [Gödel’s incompleteness theorems](https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems)
    from 1931\. These papers tell us that problems like the halting problem cannot
    be “solved”, if by*“*solved*” *we mean that the solution procedure itself always
    terminates and answers either *“yes”* or *“no”* but never *“Don’t know”*. But
    that is not the definition of “solved” that many of us have in mind. For many
    of us, a tool that sometimes times out or occasionally returns *“Don’t know”*
    but, when it gives an answer, always gives the right answer is good enough.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 程序*h*是图灵的 [1936 年著名论文](https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf)
    上和 [哥德尔不完备定理](https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems)
    上的例子的一个变体。这些论文告诉我们，像停机问题这样的问题是不能被“解决”的，如果我们所说的“解决”是指解决过程本身总是终止并且始终给出*“是”*或*“否”*的答案，但从来不是*“不知道”*。但这并不是我们心目中“解决”的定义。对于我们许多人来说，一个工具，有时会超时或偶尔返回*“不知道”*，但当它给出一个答案时，总是给出正确答案，这是足够好的。
- en: 'This problem is analogous to airline travel: we know it’s not 100% safe, because
    crashes have happened in the past, and we are sure that they will happen in the
    future. But when you land safely, you *know* it worked that time. The goal of
    the airline industry is to reduce failure as much as possible, even though it’s
    in principle unavoidable.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题类似于航空旅行：我们知道它并不百分之百安全，因为过去发生过事故，而且我们确定将来也会发生。但当你安全降落时，你*知道*那次是成功的。航空工业的目标是尽可能地减少失败，即使从原理上讲是不可避免的。
- en: 'To put that in the context of automated reasoning: for some programs, like
    *h*, we can never improve the tool enough to replace the *"Don''t know"* answer.
    But there are many other cases where today''s tools answer *"Don''t know"*, but
    future tools may be able to answer *"yes"* or *"no"*. The modern scientific challenge
    for automated-reasoning subject-matter experts is to get the practical tools to
    return *“yes”* or *“no” *as often as possible. As an example of current work,
    check out CMU professor and [Amazon scholar](https://www.amazon.science/scholars)
    [Marijn Heule](https://www.cs.cmu.edu/~mheule/) and his [quest to solve the Collatz
    termination problem](https://www.quantamagazine.org/computer-scientists-attempt-to-corner-the-collatz-conjecture-20200826/).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个放在自动推理的背景下：对于一些程序，例如*h*，我们永远无法改进工具以取代“不知道”的答案。但有许多其他情况，今天的工具会回答“不知道”，但未来的工具可能能够更多地回答“是”或“否”。自动推理专业人员的现代科学挑战是尽可能频繁地使实际工具返回“是”或“否”。作为当前工作的一个例子，请查看
    CMU 教授和 [亚马逊学者](https://www.amazon.science/scholars) [Marijn Heule](https://www.cs.cmu.edu/~mheule/)
    及其 [解决柯拉茨终止问题](https://www.quantamagazine.org/computer-scientists-attempt-to-corner-the-collatz-conjecture-20200826/)
    的努力。
- en: 'Another thing to keep in mind is that automated-reasoning tools are regularly
    trying to solve “intractable” problems, e.g.*,* problems in the [NP](https://news.mit.edu/2009/explainer-pnp)
    complexity class. Here, the same thinking applies that we saw in the case of the
    halting problem: automated-reasoning tools have powerful heuristics that often
    work around the intractability problem for specific cases, but those heuristics
    can (and sometimes do) fail, resulting in *“Don’t know”* answers or impractically
    long execution time. The science is to improve the heuristics to minimize that
    problem.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的事情是，自动推理工具经常在尝试解决“棘手”的问题，例如 [NP](https://news.mit.edu/2009/explainer-pnp)
    复杂性类中的问题。在这里，我们看到了与停机问题类似的思维方式：自动推理工具具有强大的启发式方法，通常可以解决特定情况下的难题，但这些启发式方法有时会失败，导致“不知道”的答案或不切实际的长时间执行。科学就是改进这些启发式方法以尽量减少这个问题。
- en: ''
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nomenclature
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 术语
- en: 'A host of names are used in the scientific literature to describe interrelated
    topics, of which automated reasoning is just one. Here’s a quick glossary:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 科学文献中使用了许多名词来描述相关主题，其中自动推理只是其中之一。以下是一个快速词汇表：
- en: A *logic* is a formal and mechanical system for defining what is true and untrue.
    Examples: [propositional logic](https://en.wikipedia.org/wiki/Propositional_calculus) or [first-order
    logic](https://en.wikipedia.org/wiki/First-order_logic).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逻辑*是一个形式化和机械化的系统，用于定义什么是真和什么是假。例如：[命题逻辑](https://en.wikipedia.org/wiki/Propositional_calculus)或[一阶逻辑](https://en.wikipedia.org/wiki/First-order_logic)。'
- en: 'A *theorem* is a true statement in logic. Example: the [four-color theorem](https://en.wikipedia.org/wiki/Four_color_theorem).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定理*是逻辑上的真实陈述。例如：[四色定理](https://en.wikipedia.org/wiki/Four_color_theorem)。'
- en: 'A *proof* is a valid argument in logic of a theorem. Example: Gonthier''s [proof
    of the four-color theorem](http://www.ams.org/notices/200811/tx081101382p.pdf).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*证明*是一个定理的逻辑上有效的论证。例如：Gonthier的[四色定理证明](http://www.ams.org/notices/200811/tx081101382p.pdf)。'
- en: A *mechanical theorem prover* is a semi-automated-reasoning tool that checks
    a machine-readable expression of a proof often written down by a human. These
    tools often require human guidance. Example: [HOL-light](https://github.com/jrh13/hol-light/),
    from Amazon researcher [John Harrison](https://www.cl.cam.ac.uk/~jrh13/).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Formal verification* is the use of theorem proving when applied to models
    of computer systems to prove desired properties of the systems. Example: the [CompCert
    verified C compiler](https://compcert.org/doc/).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Formal methods* is the broadest term, meaning simply the use of logic to reason
    formally about models of systems.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automated reasoning* focuses on the automation of formal methods.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *semi-automated-reasoning* tool is one that requires hints from the user but
    still finds valid proofs in logic.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, we have a choice of monikers when working in this space. At
    Amazon, we’ve chosen to use automated reasoning, as we think it best captures
    our ambition for automation and scale. In practice, some of our internal teams
    use both automated and *semi-*automated reasoning tools, because the scientists
    we've hired can often get semi-automated reasoning tools to succeed where the
    heuristics in fully automated reasoning might fail. For our externally facing
    customer features, we currently use only fully automated approaches.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: ''
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next steps
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: In this essay, I’ve introduced the idea of automated reasoning, with the smallest
    of toy programs. I haven’t described how to handle realistic programs, with heap
    or concurrency. In fact, there are a wide variety of automated-reasoning tools
    and techniques, solving problems in all kinds of different domains, some of them
    quite narrow. To describe them all and the many branches and sub-disciplines of
    the field (e.g. “SMT solving”, “higher-order logic theorem proving”, “separation
    logic”) would take thousands of blogs posts and books.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Automated reasoning goes back to the early inventors of computers. And logic
    itself (which automated reasoning attempts to solve) is thousands of years old.
    In order to keep this post brief, I’ll stop here and suggest further reading.
    Note that it’s very easy to get lost in the weeds reading depth-first into this
    area, and you could emerge more confused than when you started. I encourage you
    to use a bounded depth-first search approach, looking sequentially at a wide variety
    of tools and techniques in only some detail and then moving on, rather than learning
    only one aspect deeply.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: ''
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suggested books:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: ''
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'International conferences/workshops:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: ''
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tool competitions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: ''
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some tools:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: ''
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interviews of Amazon staff about their use of automated reasoning:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: ''
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AWS Lectures aimed at customers and industry:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: ''
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AWS talks aimed at the automated-reasoning science community:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[Debugging Network Reachability with Blocked Paths](https://ucl-pplv.github.io/CAV21/poster_P_215/),
    CAV''21'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Embedded World 2021: Formally Verifying the FreeRTOS IPC Mechanism](https://www.youtube.com/watch?v=Y_DeKKhbNUs),
    Embedded World ''21'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Formal reasoning about the security of Amazon Web Services](https://youtu.be/JfjLKBO27nw),
    FLoC 2018 plenary lecture'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Formal reasoning about the security of Amazon Web Services](https://www.youtube.com/watch?v=9lPR0d2uijo),
    OOPSLA/SPLASH 2018 keynote lecture'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How I learned to stop worrying and start applying automated reasoning](https://ucl-pplv.github.io/CAV21/poster_facc_10/),
    FACC''21 (other relevant talks at [FACC website](https://ucl-pplv.github.io/CAV21/workshop_facc/))'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[On automated reasoning for compliance certification](https://ucl-pplv.github.io/CAV21/poster_facc_10/),
    CAV workshop on Formal Approaches to Certifying Compliance (FACC)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pre-Deployment Security Assessment for Cloud Services through Semantic Reasoning](https://ucl-pplv.github.io/CAV21/poster_P_315/),
    CAV''21'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Provable Security at AWS](https://www.youtube.com/watch?v=bO-vfLpFI3I), USENIX
    Enigma 2019'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Skip to 30mins in]: [SideTrail: Verifying Time-Balancing of Cryptosystems](https://www.facebook.com/ze.jaloto/videos/10157040968367975/)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[跳到30分钟处]: [SideTrail: 验证加密系统的时间平衡](https://www.facebook.com/ze.jaloto/videos/10157040968367975/)'
- en: '[Stratified abstraction of access control policies](https://www.youtube.com/watch?v=TjSQ1P3tM2I),
    CAV''20'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[分层抽象的访问控制策略](https://www.youtube.com/watch?v=TjSQ1P3tM2I)，CAV''20'
- en: '[Verified Cryptographic Code for Everybody](https://ucl-pplv.github.io/CAV21/poster_P_46/),
    CAV''21'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[《Verified Cryptographic Code for Everybody》](https://ucl-pplv.github.io/CAV21/poster_P_46/)，CAV''21'
- en: '[What is automated reasoning? How Is it Used at AWS?](https://www.youtube.com/watch?v=sS-x_NQ-CsI)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[什么是自动推理？在AWS中如何使用？](https://www.youtube.com/watch?v=sS-x_NQ-CsI)'
- en: ''
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AWS blog posts and informational videos:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: AWS博客文章和信息视频：
- en: ''
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some course notes by Amazon Scholars who are also university professors:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊学者兼大学教授的一些课程笔记：
- en: ''
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A fun deep track:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的深度内容：
- en: Some algorithms found in the automated theorem provers we use today date as
    far back as 1959, when [Hao Wang used automated reasoning to prove the theorems
    from](https://dl.acm.org/doi/abs/10.1147/rd.41.0002) [*Principia Mathematica*](https://dl.acm.org/doi/abs/10.1147/rd.41.0002).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们使用的自动定理证明器中发现的一些算法可以追溯到1959年，当时[Hao Wang用自动推理证明了](https://dl.acm.org/doi/abs/10.1147/rd.41.0002)[*Principia
    Mathematica*](https://dl.acm.org/doi/abs/10.1147/rd.41.0002)中的定理。
