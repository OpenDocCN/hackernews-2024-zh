<!--yml

类别：未分类

日期：2024年05月27日 14:33:50

-->

# Figma矢量网络背后的工程技术

> 来源：[https://alexharri.com/blog/vector-networks](https://alexharri.com/blog/vector-networks)

<main class="css-fkkl8v">

# Figma矢量网络背后的工程技术

2019年11月24日

Adobe Illustrator在[1987年](https://www.youtube.com/watch?v=sT8Y7o-zsVw)引入了画笔工具，作为创建和修改路径的工具。自那时以来，画笔工具已经广泛使用，以至于它已经成为图形设计行业的事实标志。

自其引入以来，画笔工具的功能在过去30年里并没有发生显著变化。只需点击和拖动即可创建平滑曲线。设计师们已经学会了如何使用它，并且在它的特殊性周围进行了工作。

画笔工具

但是Figma觉得他们可以改进一些关于画笔工具如何工作的方面，所以他们试图重新设计它。他们改进了画笔工具，不再仅仅用于处理传统路径，而是创建了他们称之为矢量网络的工具。

在本文中，我们将讨论什么是矢量网络以及它们试图解决的问题。在定义了矢量网络之后，我们将看看如果要实现它们，你可能面临的一些工程挑战。

这篇文章可以被看作是一个对非常有趣的问题空间的介绍，同时也是对那些有兴趣利用矢量网络部分功能进行未来应用的人的资源。我希望它能成功地为那些初次接触新概念和想法的开发者，以及希望更多了解他们熟悉和热爱工具的设计师提供价值。

我将首先阐明画笔工具背后的核心概念，然后我们将转向Figma的矢量网络。

## 路径

画笔工具用于创建和操作路径。

如果你以前使用过像[Illustrator](https://www.adobe.com/products/illustrator.html)这样的图形软件，你就曾经使用过路径。路径是一系列可能形成或不形成循环的线条和曲线。

一些路径

左侧的路径是一个环路，而右侧的路径不是。这两者都是有效的路径。

路径的主要特征是它们形成一个单一连续的不间断链条。这意味着每个节点只能连接到一个或两个其他节点。

无效的路径

然而，如果你将它们正确地放置在一起，你可以用多条路径构建这些形状。

使用多条路径创建更复杂的形状

通过组合多条路径，你可以创建任何想象得到的形状。

例如，这个啤酒杯只是五条不同路径的组合，经过特定的位置和缩放。

### 路径的基本组成部分

一条路径由两个东西组成，即点和线。

点和线

点被称为**节点**（或顶点），而线被称为**边**。

它们一起形成一条路径

任何路径都可以被描述为一系列节点和边。

这条路径可以描述为节点序列`(0, 1, 2, 3, 4)`。它也可以被看作是构成它的边的序列。边的列表将是`(0, 1)`，`(1, 2)`，`(2, 3)`，`(3, 4)`，`(4, 0)`。

您可以将其视为小时候玩的[连线游戏](https://www.google.com/search?q=dot+to+dot+for+kids&tbm=isch)：按照点的顺序绘制路径的边缘。

但是与孩童在纸上编号点之间画线不同，这是一台冷酷的计算机在笛卡尔坐标系上进行计算。

## 边

边是一对节点之间的连接。在视觉上，边是从节点`a`到节点`b`的一条线。

但是这条线可以用很多种不同的方式绘制。如何描述这些不同类型的线呢？

边可以分为两类，直线和曲线。

直边看起来很简单，只是从`a`到`b`的一条直线。但是曲边是如何定义的呢？

### 贝塞尔曲线

曲边是[贝塞尔曲线](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)。贝塞尔曲线是由四个点定义的一种特殊类型的曲线。

我们边的两个节点的位置构成了曲线的起点和终点。这两个节点各有一个*控制点*。

在大多数应用程序中，这些控制点显示为从各自节点延伸出的*把手*。这些把手用于控制曲线的形状。

贝塞尔曲线可以链接在一起以创建单个曲线无法绘制的更复杂的形状。它们还可以与直线组合以创造一些酷炫的设计。

但这些把手具体在做什么呢？它们如何告诉计算机绘制曲线的方式？

计算机通过将曲线分割成直线并绘制各个线段来绘制曲线。

您将曲线分割为更多线段，曲线将变得更加平滑。

因此，要绘制曲线，我们需要知道如何获得组成曲线的不同点。如果我们计算足够多的点，我们就能得到一条平滑的曲线。

### 计算贝塞尔曲线上的一个点

让我们计算曲线的25%点。我们可以通过连接控制点绘制第三条蓝线来开始。

然后对于每条蓝线，我们在该线的25%点处画一个蓝点。

接下来，在三个蓝点之间绘制两条绿线。

然后我们重复与蓝点相同的步骤。在绿线的25%点处画绿点。

然后再加一条红线连接新创建的绿点。

然后我们在红线的25%点处添加一个红点。

就这样，我们计算出了曲线25%点的位置。

从现在开始，我们将通过`t`值来引用曲线上的点，其中`t`是从`0`到`1`的数字。在上面的例子中，点将在`t=0.25`（25%）处。

t=0.25、t=0.5和t=0.75

计算参数`t`处的点的这种方式称为[De Casteljau算法](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)，也可以用于细分贝塞尔曲线。使用我们沿途创建的点，我们还可以将贝塞尔曲线分成两个较小的贝塞尔曲线。

贝塞尔曲线是非常神奇的东西。通过调整手柄来塑造曲线感觉非常自然，将它们链接在一起可以创建详细和复杂的形状。

对于计算机而言，它们稳定且计算成本低廉。因此，它们被用于从[矢量图形](https://helpx.adobe.com/illustrator/using/drawing-pen-curvature-or-pencil.html#draw_curves_with_the_pen_tool)到[动画曲线](https://www.austinsaylor.com/blog/2015/3/20/4-after-effects-graph-editor-basics-you-need-to-know)和[汽车车身](https://en.wikipedia.org/wiki/Pierre_B%C3%A9zier#B%C3%A9zier_curve)的各种用途。

你可以在[Jason Davies的网站](https://www.jasondavies.com/animated-bezier/)看到贝塞尔曲线的交互演示。看着一系列直线追踪出平滑的曲线是非常迷人的。

来自[https://jasondavies.com/animated-bezier](https://jasondavies.com/animated-bezier)

## 路径的创造性限制

在本文的早些时候，路径被定义为一系列可能形成环路的直线和曲线。

路径是单一连续链的事实是一个相当大的限制。

这意味着使用单一路径无法实现三路交叉。要创建三路交叉，必须使用两个或更多路径。这意味着处理不同路径的定位和分组。这也意味着对单一路径的更改可能会导致多个其他路径的更改。

但那只是例行公事。经验丰富的设计师知道路径的行为，他们可以事先进行合理规划，而不必真正考虑它。对于静态设计，如果设计得当，创建多少路径和图层并不重要。

但对于某些情况，路径所施加的约束会导致很多摩擦。

## 矢量网络

2016年，Figma [推出了矢量网络](https://www.figma.com/blog/introducing-vector-networks/)。他们通过允许任意两个节点无限制地连接来解除了“单一连续”的限制。

> “矢量网络通过允许任意两点之间的线条和曲线，改进了路径模型，而不要求它们全部连接成单一链。”

来源：[https://www.figma.com/blog/introducing-vector-networks/](https://www.figma.com/blog/introducing-vector-networks/)

立方体是展示矢量网络的典型例子。

通过传统路径，您至少需要创建3条不同的路径来描述此形状。

对于一个看似简单且常见的形状来说，这创造了很多摩擦。要修改立方体，您必须修改两个或三个不同的路径。但是使用矢量网络，您只需抓住一条边并移动它，形状就会表现得如您所期望的那样。

因此，如果您想要增加立方体的挤压，您只需抓住两条适当的边并将它们移动在一起。

这是Figma矢量网络的主要卖点。易于使用。

矢量网络不会让你创造以前不能用其他工具创造的东西，但它确实消除了在创建过程中的许多阻力。

而且你可以更进一步。比如说你想在立方体的侧面添加一个孔。

只需从选择和复制立方体的边开始。然后您可以复制这些边并将它们缩放到所需的大小。

就像这样，您就有了一个带孔的立方体。

要使这个洞看起来可信，你只需内部边缘。

同样，矢量网络可能不允许您创建以前无法创建的东西。相反，它们使以前不可能的工作流变得可能。

## 创建矢量网络

了解了什么是矢量网络后，我们现在可以看看如何实施它们。

### 图

矢量网络背后的主要数据结构是图。图可以被看作是节点和边的集合。

图

### 节点

一个图可以有任意数量的节点。在我们的目的中，节点有两个属性，一个唯一的`id`和一个`position`。

### 边

边是两个节点之间的连接。每条边由两个*边部分*组成。边部分包含一个节点的id和一个可选的控制点。

标签`n0`和`n1`将用于分别引用边的起始和结束节点。控制点将被标记为`cp0`和`cp1`。

如果省略了边的控制点，该边就变成了一条直线。

## 填补孔洞

来源：[https://www.figma.com/blog/introducing-vector-networks/](https://www.figma.com/blog/introducing-vector-networks/)

在使用矢量网络时，填充工具允许您“切换”图的不同“区域”的填充。

这些区域可以被定义为一个环形的节点`id`序列，一个循环，如果你愿意的话。

这个循环序列被称为*循环*。在上面的例子中，循环由节点`n0`、`n1`、`n3`、`n4`、`n5`、`n6`和`n7`组成。这些循环将被写成`(0, 1, 3, 4, 5, 6, 7)`。

如果您要计算循环中不同的视觉上可区分的“区域”的数量，您的答案可能是三个，但您可能会轻松找到超过三个循环。

这是什么使得这个正确或者不正确？

序列`(0, 1, 2, 3, 4, 5, 6, 7)`是一个循环，并且循环，但这并不是我们寻找的。这个问题可以通过你可能在Facebook上看到的“多少个三角形”谜题来说明。

这个图像中有多少个三角形？

您应该能够计算出 24 个不同的三角形，具体取决于您选择包括哪些区域。

但这不是我们想要的。我们需要找到的是 16 个小区域。

我们需要一种方法来找到图中的*“小循环”*。

## 最小循环基础

这篇关于[最小循环基础](https://www.geometrictools.com/Documentation/MinimalCycleBasis.pdf)的论文比大多数其他学术论文少了一些内容（而且还有图片！）。其目标是：

> …来计算形成图形循环基础的最小循环数。

### “最小循环基础”是什么意思？

这只是一种指代图形的“小区域”的花哨方式。您可以把它们想象成图形的“视觉上不同”的区域。封闭区域。

### 左边还是右边？

找到“最小循环基础”的主要工具将确定基于左或右选择哪条边。

我们应该去 `a` 还是 `b`？

我们将按照顺时针和逆时针来思考。

`curr` 表示当前，`prev` 表示前一个

当向左行进时，我们选择相对于前一个边最逆时针的边（CCW）。

逆时针

在向右行进时，我们选择相对于前一个边最顺时针的边（CW）。

顺时针

### 算法

我们将找到之前看到的图的最小循环基础。

第一步是选择图中最左边的节点。

当从第一个节点出发时，我们希望顺时针走（CW）。但是相对于哪条边呢？

对于第一个节点，我们想象前一个边“在”当前边的下方。然后我们选择相对于那个边的顺时针边。

在这种情况下，相对于 `prev`，`a` 更顺时针，所以我们将走向 `a`。

在第一次行走后，我们开始选择逆时针边。

在这种情况下，那是 `b`。我们重复之前的步骤，并继续选择逆时针边，直到我们达到原始节点。

当我们再次到达原始节点时，就找到了一个循环。

现在我们在图中有了第一个小循环。

找到循环后，从图中移除循环的第一条边。

第一条边 `(n0 n1)` 被移除了

然后，去除循环中前两个节点的*纤维*。

在这种情况下，我们只有一个单一的纤维

纤维是只有一个相邻边的节点。把它们想象成是死胡同。找到一个纤维时，我们还会检查单个相邻节点是否也是纤维。这确保了下一个循环的第一个节点有两个相邻节点。稍后我们会看到一个例子。

现在我们选择下一个循环中的第一个节点。在我们的图中，有两个同样左边的节点。

当这种情况发生时，我们选择底部节点，这里是 `n1`。

然后我们从之前的过程中重复。从底部的第一个节点顺时针，然后从前一个节点逆时针，直到找到第一个节点。

我们找到了循环 `(1, 2, 3)`。

现在我们有循环 `(0, 1, 3, 4, 5, 6, 7)` 和 `(1, 2, 3)`。

然后我们去除循环的第一条边和之前的纤维。我们从去除与循环的前两个节点相连的纤维开始。

我们继续直到没有任何纤维剩余。

找到下一个循环是显而易见的。

顺时针然后逆时针

现在我们拥有了图的所有循环。

这是我们图形的最小循环基础！现在我们可以随意切换这些周期的填充。

## 数学计算

我想深入探讨相对于另一条边缘的顺时针性如何确定。

理解本节的唯一先决条件是[vectors](https://www.mathsisfun.com/algebra/vectors.html)；从二维坐标系的一个点指向另一个点的箭头。

i = (1, 0)，j = (0, 1)

有两个向量位于原点，`i`和`j`，我们可以这样创建一个正方形。

对于单位向量`(1, 0)`和`(0, 1)`，正方形的面积为1。

我们可以用任意两个向量做同样的事情。

这个形状被称为*平行四边形*。平行四边形有一个我们关心的特性，即它们的面积等于其行列式的绝对值。

这听起来可能像行话，但对我们来说行列式确实非常有用。看看当我们逐个将一对一正方形的向量移动在一起时会发生什么。

当向量靠近时，它们的面积变小。当向量平行时，行列式和面积变为0。

此时要问的自然问题是，当我们继续前进时，蓝箭头是否在绿箭头的右侧？

行列式变为负数！

当蓝色向量`j`在绿色向量`i`的左侧时，平行四边形的行列式变为负值。反之则为正。

对我们的使用情况的含义是，我们可以检查两个向量的行列式是正还是负，以确定一个向量是在另一个向量的左侧还是右侧。

无论方向如何，因为平行四边形的面积不取决于创建它的向量的方向。

当向量的方向相对于彼此改变时，行列式会改变。

有了这个知识作为我们的武器，我们可以创建一个函数，`det(i, j)`，它接受两个向量并返回行列式。

当`j`在`i`的左侧（逆时针）时，函数将返回一个正值。

### 应用数学

假设我们在查找循环的中间，并且我们正在决定是移动到`n0`还是`n1`。

让我们将其移入坐标系统。

我们将从`a`开始。

我们想要得到从`curr`到`a`的向量，我们通过从`curr`减去`a`来做到这一点。我们将这个新向量称为`da`。

我们可以使用`prev`对`curr`做同样的事情。

现在我们可以通过计算`da`和`dcurr`形成的平行四边形的行列式来确定`a`是否在`curr`的左侧。

注意顺序很重要。如果我们使用`da`作为`i`，那么面积是负的。如果我们将其用作`j`，它变为正数。

我们可以用`b`做同样的事情。

有了这些信息作为我们的武器，我们知道`a`、`b`和`curr`是左还是右。

我们如何处理这些信息？

## 绿色区域

我们将集中在确定`da`相对于`curr`是否比`db`更逆时针方向。简单来说，`da`是否在`db`的左边？

如果`da`相对于`dcurr`更逆时针，可以说`da`比`db`*更好*。

第一步是确定`dcurr`和`db`之间的角度是否凸。

这种“凸性”可以更容易地通过将`dcurr`向后移动并想象一个弧来可视化，如下所示：

角度是凸的

如果角度是凸的，我们将使用以下表达式来检查`da`是否比`db`更好。

∨ 符号代表数学中的逻辑或运算符。

让我们来看看这个表达式的各个部分。

`da`是否相对于`dcurr`是逆时针的？

是否`da`相对于`db`是逆时针方向的？

我发现在脑海中很难将这个形象化，所以我认为两个不同的表达式创建了一个“绿色区域”，在这个区域中`da`比`db`更好。

对于表达式的第一部分（`da`是否在`dcurr`的左边），绿色区域看起来是这样的。

表达式的第二部分询问`da`是否在`db`的左边。绿色区域看起来是这样的。

而且由于这是一个或表达式，这些子表达式中的任何一个为真都将导致`a`比`b`更好。因此，绿色区域看起来是这样的：

`a`是否比`b`更好？

我们用这个来确定角度凸度时`a`的优势。

但如果从`dcurr`到`db`的角度是凹的呢？

然后表达式看起来是这样的：

这里唯一改变的是逻辑或运算符（∨）变成了逻辑与运算符（∧）。

让我们看看使用这个表达式时绿色区域会发生什么变化。

`da`是否在`dcurr`的左边？

`da`是否在`db`的左边？

而且因为这些子表达式由逻辑与连接，绿色区域看起来是这样的：

使用这种方法，我们可以始终得到最逆时针或最顺时针的节点。而且最棒的是，这种方法不受旋转影响，计算成本很低。

### 计算行列式

给定两个向量，可以用这个公式计算[determinant](https://en.wikipedia.org/wiki/Determinant)：

## 图中的交集

让我们稍微回到我们的图上。

这个图是最简单、最乐观的情况。这个图只有直线，并且没有两条线相交。

这个盒状区域有一个交集。边缘`(0, 2)`穿过边缘`(1, 3)`。

有了交集，上面的区域看起来是可以填充的。但定义“填充区域”却相当困难。

为什么定义这个区域如此困难？考虑这个矩形和线。

边缘`(4, 5)`与`(0, 1)`和`(2, 3)`有两个交集。

假设线左侧的区域被填充。如果我们将线移到左边会发生什么？

显然区域会缩小，但如果我们继续并将线移到矩形外部会怎样？下面哪种结果应该是正确的，为什么？

在这种情况下，感觉矩形应该是空的。但如果我们把线移到右边呢？

应该填充吗？当然，但如果我们移动线条，而不是上下移动，那么当线条不再分隔两个部分时，矩形应该填充还是清空？

## 扩展图形

这是我认为 Figma 解决这个问题的方式。我称之为“扩展图形”，但 Figma 的工程师可能使用不同的术语来描述它。

扩展图形意味着获取每个交点，创建一个节点在交点处，然后拆分在该点相交的边。

这是原始图形：

边`(0, 2)`与边`(1, 3)`相交。在扩展后，图形将如下所示：

新节点`5`将被添加到交点处。

边`(0, 2)`和`(1, 3)`已被移除，并被边`(0, 5)`、`(5, 2)`、`(1, 5)`和`(5, 3)`替换。

图的结构已经改变了

这是一个示意图，应该更清晰地说明问题。

扩展交点

### 多个交点

对于具有单个交点的线边来说，这些步骤相当简单。但是每条边都可以有多个其他边与其相交，两条三次贝塞尔曲线可以创建9个交点。

这使事情变得有些复杂。让我们看看贝塞尔线交点的情况。

处理这个问题的最佳方法是将边的交点视为与其相交的边的独立部分。

`t`值从曲线的起点0到终点1

线条在`t = 0.3`和`t = 0.7`处有两个交点。贝塞尔曲线有两个交点，但在`t = 0.25`和`t = 0.75`处。

在继续这个示例之前，我想引入另一种边的思考方式，因为我相信这将有助于更好地理解问题。

### 重复边

两个节点可以通过不同的边连接多次。

在这个图中，由节点对`(2, 3)`表示的边可以表示连接`n2`和`n3`的两条边中的任意一条。

为了解决这个问题，我们将为每条边分配一个唯一的`id`。

对于大多数未来的示例，我仍然会根据它们连接的节点来引用边，因为我觉得这样更容易理解。但对于下一个示例，最好分开节点和边。

### 交点映射

我们可以按以下方式组织边的交点数据：

在边的交点处创建节点

当我们遇到交点时，我们创建一个节点，其位置位于交点处。然后我们将交点添加到一个*交点映射*中，该映射将包含每条边的交点，对应一个`t`值和一个`nodeId`。这些交点按`t`值排序。

对于具有最低`t`值的交点，我们创建一个边，第一个*边部分*具有原始边的第一个边部分的`nodeId`。第二个边部分应包含交点的`nodeId`。这样创建了边`(2, 4)`。

后续边将使第一个边部分的`nodeId`成为前一个交点的`nodeId`，第二个`nodeId`成为当前交点的`nodeId`。在此示例中，该边是`(4, 5)`。

对于每条具有任何交点的边，将创建一个额外的边。

第一个边部分的`nodeId`将是最后一个交点的`nodeId`，第二个边部分的`nodeId`将是原始边的第二个边部分的`nodeId`。

这有点啰嗦，希望这张图有助于更好地理解那些字母串。

将边的交点与创建这些交点的边分开，使得思考变得更容易。这减轻了多个边相互交叉可能引起的复杂性。

## 自相交。

三次贝塞尔曲线可以自相交。

不幸的是，这意味着必须检查每一条三次贝塞尔边是否自相交。这是一个涉及查找贝塞尔曲线在哪两个不同的`t`值处相交的有趣问题，但我不会在这里详细介绍如何找到这些值。

一旦您有了`t`值，自相交贝塞尔曲线可以扩展如下：

蓝色节点应对用户不可见。

我们插入`n3`，因为具有边界的节点，在边界的两端都有自身的边界是有问题的，但应该对用户隐藏。

交错自相交贝塞尔的环。

在第一次机会时移除`n3`。

## 弯曲的边。

早些时候我们讨论了CW-CCW图遍历算法，以找到最小循环基（小区域）。

找到与`curr`相邻的更好的（逆时针最多的）点。

但是论文中描述的算法是设计用来处理由直线连接的不相交节点的。引入由三次贝塞尔定义的边增加了显著的复杂性。

选择哪条边，蓝色还是绿色？

在上面的例子中，我们可以通过使用行列式找出蓝色边优于绿色边的信息。我们仍在定义更好来表示逆时针最多的边。

当处理三次贝塞尔曲线时，天真的解决方案是将贝塞尔曲线转换为由曲线起始点和结束点定义的线。

但是当一个边曲线超过另一个边时，这个想法就会崩溃。

糟糕

让我们重新审视贝塞尔曲线并试着从那里工作。

观察到曲线起始处的切线`n0`与从`n0`到`cp0`的线平行。因此，为了得到边开始处的方向，我们可以使用线`(n0, cp0)`。

为了清晰起见，我们边的开始`n0`与`curr`相同。

因此，通过将由三次贝塞尔定义的边转换为由`(n0, cp0)`定义的线，我们得到曲线的*初始*角度。

当看到“曲线周围”的情况时，这似乎是一个不错的解决方案。

看起来我们已经解决了这个问题。对吧？

### 没有交点。

在我们继续研究更多边缘情况之前，理解任何解决方案都假设在决定要遍历的边缘时不会有两条边相交是有帮助的。

这是不允许的

我们遍历的图的边缘在计算图的循环（最小循环基础）时不能有任何交点。

我们只能在*扩展的图*上操作。

就像我们前面讨论的那样，扩展图是一个用新节点和边替换所有交点的图。因此，如果原始的用户定义图有任何交点，它们必须在我们找到图的循环之前扩展。

与上述相同的边缘，但扩展了

## 平行边缘

下一个边缘情况是两条边平行（指向相同方向）。

如果线条方向相同，没有更多信息的情况下确定哪一个更好是不可能的。

这里有几种可能的解决方案，控制点为平行的情况。

### 在`t`处的点

如果我们只是在曲线上取例如`t = 0.1`的点会怎样呢？

这对于长度相似的曲线产生了正确的结果，但如果一条曲线明显比另一条长，我们很容易就能打破这个结果。

这与我们之前看到的“曲线环绕”情况实际上是同一个问题。

### 在长度处的点

我们可以考虑在曲线上某个长度处取一个固定`t`值的点。长度由较小曲线上的某点决定，例如在`t=0.1`处。

我尚未尝试实施这一点，因为我有另一个有效的解决方案，但如果它能解决所有边缘情况，这可能是一个可行且高效的解决方案。

### 激光！

下一个解决方案有点神秘，但可以产生正确的结果。这是我目前正在使用的解决方案。

我们从每个贝塞尔曲线在`t = 0.05`处分割（上图夸大）。然后我们将每个部分tesselate成n个点。

然后，对于tesselated bezier的每个点，我们检查从`n0`到该点的线是否与另一条边相交。

在这个尺度上很难看清楚发生了什么，所以让我们放大一点。

当一个点与另一条边相交时，我们使用它之前的点。

发现了一个交点

让我们放大一点。

靠近交点

对于另一条边，我们没有交点。

在这种情况下，我们只需使用边缘的末端作为方向线。

使用这种方法，我们生成了似乎代表各自曲线的线段。

这也适用于“曲线环绕”情况。

但对于“后面的曲线”情况却失败了。

这会产生绿色边缘作为更CCW边缘，这是错误的。

我对这个问题的解决方案是向前一个边缘的方向射出无限激光。

然后我们检查tesselated bezier的点是否与这个激光相交。

但是从`n0`到这些点的线永远不会与激光相交。

直接穿过

相反，我们可以从当前点到前一个点创建一条线，并在交点测试中使用它。

当我们相交激光时，我们使用前一个点。前一个点始终位于激光的正确侧。

我们使用的点

就像这样，我们有了一个解决方案。

## 平行，但是反向！

也有可能是蓝色或绿色的边，分别是`a`和`b`，与从`curr`到`prev`的边平行。

`a`与`prev`平行

找到更好边缘的过程遵循与上述类似的过程，因此我们将很快涵盖这一点。

有两种情况：

### A或B与`Prev`平行，但不是两者都平行

如果`a`或`b`中的一条边与`prev`平行，我们可以简单地将平行边与`prev`比较。

如果平行边在`prev`的顺时针方向，那么平行边更好。

如果平行边是`prev`的逆时针方向，那么另一条边更好。

想一想为什么这是正确的。

如果一条边与`prev`平行并且向顺时针弯曲，另一条边不与`prev`平行，则平行边尽可能地逆时针。这意味着另一条边的绿色区域完全为空。

如果平行边逆时针弯曲，反之亦然，因为它尽可能地顺时针。这意味着另一条边的绿色区域是整个圆。

### A和B都与Prev平行

使用与之前相同的激光解决方案，这种情况已经涵盖了。

## 循环中的循环

现在我们将稍微看看填充。

让我们看一个基本示例，图中有一个循环嵌套在另一个循环内部。

你期望图形的区域像这样定义：

但目前为止，如果你悬停在外围区域上，你会得到一个不同的、令人不满意的结果。

但这是有道理的。让我们看一看图中的节点。

循环`(0, 1, 2, 3)`描述了我们想要的区域的外边界，但我们还没有描述区域的“内边界”。

让我们看看我们可以如何做到这一点。

### 偶数-奇数规则

告诉计算机如何绘制2D形状的轮廓是相当简单的。但是如果你想要填充这个形状，怎么告诉计算机什么是“内部”和什么是“外部”呢？

找出一个点是否在形状内部的一种方法是从该点向任意方向发射无限激光，并计算它穿过多少“墙”。

如果激光与奇数面墙相交，则位于形状内部。否则，它位于形状外部。

相交1面墙，我们在形状内部

相交4面墙，我们在形状外部

这适用于任何2D形状，无论你选择哪个点和向哪个方向发射激光。

这也有助于嵌套路径的情况。

这给了我们一个定义形状“内部边界”的想法。

### 减少闭合路径

让我们看一个图形，一个循环嵌套在另一个循环内部，但是有一条边连接两个循环的节点。

这将导致我们如何考虑嵌套循环，并让我们更深入地理解如何考虑它们。

让我们找出循环。我们使用和往常一样的顺时针和逆时针方法。

使用这种方法，我们似乎绕过内部循环进行了一个小小的绕道。

当我们到达起始节点时，这就是循环的样子。

这是我们第一次看到跨越一个节点两次（`n3`和`n4`）。当我们观察这个循环在整个图中的方向时，会出现一些有趣的东西。

我们开始逆时针旅行，但当我们穿过从外部循环到内部循环的边缘时，我们旅行的方向似乎发生了翻转。

我暂时声明，我们想要将外部循环与内部循环分开，并将它们之间的边缘视为不存在。我稍后会解释为什么，这里解释如何操作。

我们将所有重复的节点，本例中为`n3`，从循环中移除。我们还移除任何位于两个重复节点之间的节点。

你可能会注意到`n4`也被重复了，但因为它“在”`n3`移除的部分循环内，我们可以忽略它。

我们留下一个重复节点的实例，然后我们得到如果*交叉*不存在时将找到的循环。

然后我们标记连接外部循环与内部循环的边缘。我称这些标记的边缘为*交叉*。

外-内循环组合可能有多个交叉点。

在这种情况下，我们标记所有与连接到外部循环的节点相邻的边缘为一个交叉。

完成所有这些后，我们的循环看起来像这样：

## 子循环

我将不再提到“内部”和“外部”循环，而是称之为子循环和父循环。这将更容易思考多个循环相对于彼此的关系。

说到这里，让我们引入第三个循环。

当我们悬停在最外层的循环上时，你期望会发生什么？

由于偶奇规则，最内层的循环也被填充了！

为了解决这个问题，我们可以引入*直接子循环*的概念。

父循环（蓝色）及其直接子循环（绿色）

父循环可能有多个直接子循环。但由于非交叉规则，子循环只能有一个父循环。

让我们看看这是如何运作的。

这个图中有一个矩形，我们最外层的循环，它有两个直接子循环：一个菱形和一个沙漏。菱形有两个直接子循环，而沙漏有三个直接子循环。

我们将从矩形及其直接子循环开始。我们将它们命名为`c0`，`c1`和`c2`。

用户决定填充其中一些循环，而另一些则留空。

`c0`和`c1`被填充了，而`c2`是空的。

让我们用灰色填充，没有描边地绘制这张图。在绘制这张图时，我们从最外层的循环`c0`开始。

左边的图形与右边的渲染图

由于`c0`已经填充，我们将其绘制出来。如果它没有被填充，我们可以跳过绘制它。我们可以从矩形中射出激光，看到它与矩形的边界相交一次，因此我们可以预期根据偶奇规则它将被填充。

这可能看起来非常明显，但在我们继续之前，明确规定游戏规则是很好的。

接下来，我们想要绘制`c1`，也就是图中的钻石。它被填充了，就像矩形一样，所以我们也应该绘制它。但是，如果我们尝试绘制钻石，我们会得到错误的结果。

我们的激光在绘制两个形状时相交，当它们具有相同的填充设置时。

我们交叉了偶数个墙壁，所以我们处于形状的“外部”。

因此，为了绘制用户想要的图像，我们可以简单地跳过绘制钻石，因为父循环隐式地绘制了具有相同填充设置的直接子循环。

沙漏`c2`应该是空的。在这种情况下，仅仅不绘制它似乎是一个合理的结论。但由于父循环（矩形）已经绘制了沙漏，好像它是填充的，我们需要通过绘制沙漏来“翻转”填充。

再次，如果我们尝试使用激光交叉法，我们看到交叉点的数量是2，一个偶数。根据偶数-奇数规则，偶数个墙壁意味着你处于形状的“外部”。

现在我们已经绘制了矩形及其直接子循环，我们可以继续处理这些直接子循环的直接子循环。

当处理`c3`和`c4`时，即`c1`的直接子循环时，我们可以将它们视为`c0`的直接子循环，因为`c1`具有相同的填充设置。

对于`c3`，我们想要“翻转”填充设置，因此我们将其绘制出来。但是对于`c4`，由于它与其父循环具有相同的填充设置，我们不绘制它。

偶数个交叉点，所以我们在形状的外面。

我们可以以相同的方式考虑`c5`、`c6`和`c7`。当渲染它们时，我们不在乎它们是填充的还是空的。我们在乎的是它们与父循环的填充是否相同。

我们只需要绘制循环，如果它们的父循环与它们自身的填充设置相反。如果它们具有相同的填充设置，我们不必绘制它们。

这意味着在绘制循环时，首先绘制最外层的“填充”循环，然后查看该循环的子循环。如果一个子循环与其父循环具有相同的填充设置，则不应绘制它。

## 连续循环

一个图可能有多个“循环簇”。

我使用短语*连续循环*来描述这些循环的“紧密性”，如果可以这么说的话。我经常把这些连续的循环组想象成不同的颜色。

找到这些连续循环可以通过深度优先遍历完成：

从循环的第一个节点开始

染上你找到的每个节点

但是记住*交叉*吗？在搜索中，您可能不会通过标记为交叉的边缘爬到相邻节点。

因此，最终，我们的颜色实际上是这样的：

取这一组连续的循环，嵌套在另一组连续的循环中：

由于非交叉规则，我们知道如果一组连续循环中的一个节点位于不在该组中的循环内部，那么所有这些节点都在内部。

这个“连续循环”的想法表面上可能不是本文中最有趣的部分，但我发现在处理向量网络时它很有用。

## 部分展开

当悬停在由交点定义的区域时，我们显示了扩展图形的一个循环。

以这个三角形为例。

如果我们悬停在其区域之一上，我们会看到一个由尚不存在的节点定义的区域。

蓝色条纹区域代表的是如果用户点击鼠标左键将“切换”其填充状态的区域。此区域不存在于用户定义的图形上，而是存在于原始图形的扩展版本上的一个循环中。

展开的图

当用户点击以切换区域填充状态时，我们首先必须扩展用于存在的节点和边的图形。

展开的图

但通过这样做，我们扩展了两个我们不需要扩展以描述区域的交叉点。这些扩展具有破坏性质，应尽可能避免。

相反，我们可以*部分展开*图形，只展开定义所选循环的交点。

部分展开的图

这使我们能够尽可能保留原始图形，同时仍能定义填充。

### 实现部分展开

基本实现是相当简单的。当您创建扩展图形时，只需向每个扩展节点添加一些元数据，告诉您用于创建它的原始图形的哪两条边以及这些交点发生在什么`t`值。

然后当点击循环时，迭代每个节点。如果节点存在于扩展图中但不存在于原始图中，则将其添加到一个新的部分展开的图中。

这里有一些边缘案例，但我将不在此进行详细讨论。

## 被省略的主题

这里有一些我决定在本文中省略的主题。去试试看吧！

### 连接

Figma提供了三种连接类型。圆形、尖角和方形。如何实现这些不同类型的连接？

### 描边对齐

Figma还提供了三种方式来对齐图形的描边：中心、内部和外部。

如何确定图中的内部或外部，当图中没有循环时会发生什么？

### 布尔运算

Figma，像大多数矢量图形工具一样，提供了[布尔运算](https://help.figma.com/article/65-boolean-operations)。如何实现这些？

[Paper.js](http://paperjs.org/)是开源的，具有路径的布尔运算，也许你可以从这里开始？

## 未来的主题

这些是我未来想要探索的一些更开放性的功能和想法。

### 使用填充的另一种工作方式

有几种方式可以替代Figma允许用户处理填充的方式。

我感兴趣探索的一个可能解决方案是使用多个不同的“填充层”，这些层使用一个矢量对象作为参考。这将解决“一个图形，多种颜色”的问题，而无需复制层并保持多个矢量对象同步，如果以后要进行更改。

### 给图形添加动画效果

借助类似于 After Effects 的表达式和基于参考的系统，当你将它与矢量网络结合使用时，你可以实现什么？

或许我们可以利用类似于[Blender 的着色器编辑器](https://docs.blender.org/manual/en/latest/editors/shader_editor/index.html)或[Fusion 的基于节点的工作流](https://www.blackmagicdesign.com/products/fusion/visualeffects)的节点编辑器？

这里有很多探索的空间，我对深入研究这个主题非常兴奋。

## 总结

感谢阅读这篇文章！希望它作为对我认为非常有趣的问题空间的一个良好介绍。我在学校和工作之余一直在解决这个问题。这是我正在开发的 Web 动画编辑器加运行时的一部分。我打算将修改版的矢量网络作为几个功能的核心。

我已经在实现矢量网络上工作了半年多。在创建、修改和扩展图形方面，这个矢量编辑器非常强大。但是在修改填充状态时遇到的边缘案例已经困扰我很长时间了。

我希望在发布这篇文章之前能有一个完全可工作的演示版，但要使其对不是我自己的人可用，还需要几个月时间使其足够稳定。

项目背后的大思路是开发一款专门为 Web 上创建和运行动态动画而设计的动画软件。我将在稍后的时间分享更多关于这个项目的信息。

我也觉得 Figma 的矢量网络非常酷，但在网上很难找到相关资料。我希望这篇文章能帮助弥补我在查找矢量网络信息时遇到的信息匮乏。

</main>
