<!--yml

类别：未分类

日期：2024-05-27 14:43:33

-->

# 我不关心内存安全

> 来源：[https://www.linkedin.com/pulse/i-dont-care-memory-safety-david-chisnall](https://www.linkedin.com/pulse/i-dont-care-memory-safety-david-chisnall)

对于一个已经在硬件内存安全上工作了十多年的人来说，这可能是一个奇怪的说法，因此我可能需要澄清一下。我关心内存安全，就像我关心加法一样。如果它工作了，我就可以在其上构建有趣的东西。实际上，我想要构建的大多数有趣的东西都依赖它作为核心基石。如果加法不起作用，我就没有办法推理程序中的任何东西。

内存安全也一样。对我来说，70%的安全漏洞来自于内存安全缺失并不是内存安全重要的原因。它重要的原因是单个内存安全漏洞可以完全破坏我所依赖的所有保证。越界访问或释放后使用的错误可以在程序的任何地方泄露或损坏任意状态。如果我认为某个东西对我的线程是私有的，因为我的程序中没有任何地方存储了对它的引用，其他线程都访问不到，但只要我的程序是内存安全的，这就是真的；如果我认为一个对象是不可变的，因为我没有暴露任何修改它的API，并且我的类型系统说它是不可变的，那只有在我的程序是内存安全的情况下，这才是正确的。

一旦我的程序包含了一个内存安全错误，这些属性就不再成立，即使你已经正式验证了其中的一些。EverCrypt项目进行了非凡的工作，生产了经过正式验证的（包括抵抗侧信道攻击的）加密库，但是经过正式验证的程序只有在公理成立时才具有这些属性。如果你没有内存安全，那么这些公理就不成立。

如果你有了内存安全，那么你就可以开始构建有趣的东西。我开始研究内存安全，是因为我想要丰富的组件系统。在90年代，各种平台提供了丰富的组件模型。Word文档可以嵌入COM控件，这些控件嵌入了其他丰富的应用程序。其中大多数都消失了，因为从第三方运行任意代码是危险的。唯一安全做到这点的程序就是Web浏览器（它们被设计用于做这件事以及其他什么都不做）。

2005年，我参加了Alan Kay的演讲。他的一个重要揭示是，他的幻灯片实际上不是PowerPoint演示文稿，而是一个Smalltalk程序。在中间，他画了一些昆虫，然后编写了一些代码，让它们在嵌入的图像和视频边缘奔跑。他问了一个合理的问题：“为什么你要使用一个不是编程语言的程序？”不幸的是，如果您交换文档，这意味着运行来自其他人的任意代码。想象一下能够从互联网上获取代码，并将其嵌入到您发送给其他人的文档中，而不用担心它会危害您的（或他们的）系统。

您可以开始使用WebAssembly执行一些操作，但然后您会遇到一个普遍的问题：

隔离很容易，（安全）共享很困难。

我们知道如何实现安全隔离。几十年来，它已被用于保护核弹发射系统。您有一台未连接到其他计算机的计算机。然后您将其放在一个锁着的房间里。然后在外面放上持枪的人，并告诉他们射击试图进入并且不应该进入的人。

对于低风险系统，您可以放弃持枪的人，甚至甚至关闭的房间。这就是为什么商品硬件上的内存管理单元（MMUs）改变了世界。多个程序可以运行，一个程序中的错误不会导致另一个程序崩溃（或整个系统），但它们可以访问相同的文件集。两个用户可以共享相同的系统，并且内核可以赋予他们访问私有和共享文件集的权限。

由于缺乏内存安全性，我们无法拥有美好的东西。

这就是为什么我对带有星号的内存安全性不感兴奋。星号像“只要没有人猜出一个4位数”（MTE）。或者，如果您需要伪造三个指针进行全面妥协，只要没有人猜出一个12位数。所以，如果您遇到Windows或Android内存安全漏洞，您只有可能操纵4,096个用户中的一个，给您大约五百万个系统（假设您只能尝试一次），而且您很可能被发现那些您没有被破坏的系统中的一些。

或者星号像“只要您不使用unsafe关键字，unsafe包，或sun.misc.Unsafe包”（Rust，Go，Java），或“只要您不使用任何来自不安全语言的代码”（所有内存安全语言）。我想使用不安全语言的代码！GitHub有超过一千三百亿行的C/C++代码，我真的不想重写（或支付别人重写）成一种安全语言。

我希望能够重用那些代码，但限制它们的bug。我希望能够在调用它时知道，它可以通过我传递的指针写入，但不能访问任何未共享的内容。我希望它不能访问我的进程中的任何内容（更不用说我的计算机其他地方的内容了），除非我明确授予了它的权限。我希望不用担心它存在bug，因为我可以明确限制其影响范围，而不是那种内存安全错误暗示的远程神秘行为。

这正是[CHERI](http://chericpu.org/?trk=article-ssr-frontend-pulse_little-text-block)设计让我（以及其他所有人）能够构建的系统类型。

我们能够减少内存安全错误的数量，或者使它们更难利用，这是件好事。在安全语言中重写代码可以消除一类故障，并使世界变得更美好，如果你有重写的机会成本，那就请尽情去做吧！部署这些缓解措施意味着攻击者只能控制五百万台机器，而不是二十亿台，大大降低了他们可能造成的损害。然而，这些方法不能让我构建激动人心的系统。

大多数关于[CHERI](https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/cheri-publications.html?trk=article-ssr-frontend-pulse_little-text-block)的发表作品都集中在运行现有软件上。

我们[能够运行整个现代POSIX兼容的内核和用户空间以及大量内存安全软件](https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/201904-asplos-cheriabi.pdf?trk=article-ssr-frontend-pulse_little-text-block)对于采用至关重要，因为那是现在世界上存在的软件，但这只是低估了如果你能把内存安全视为像整数算术一样可靠的东西，可以做的事情（而且比浮点算术的工作方式更易于理解）。

通过[CHERIoT](https://github.com/microsoft/cheriot-rtos?trk=article-ssr-frontend-pulse_little-text-block)，我们已经开始展示这个世界的一瞥。你可以拿现有的C/C++代码重新编译，使其在CHERIoT隔离区中运行。你可以理所当然地认为，任何越界访问和使用后释放的问题都会被捕获。这意味着，你可以通过传递指针与另一个隔离区共享对象。你可以依赖这样一个事实，即如果你向另一个隔离区传递了指向栈上对象的指针（或者任何你明确标记为短暂的指针），任何试图捕获该指针的尝试都会被捕获。你可以通过提供没有写权限的指针来共享缓冲区的只读视图，或者通过提供没有传递写权限的复杂数据结构的指针来共享它。

你可以使用罗伯特·沃森（[Robert Watson](https://uk.linkedin.com/in/robert-watson-3747a6253?trk=article-ssr-frontend-pulse_little-mention)）所说的“软件开发的吸尘器模型”：把你的吸尘器对准互联网，吸取你需要的所有组件，然后发货。现在你可以审计每个第三方组件可以访问的内容。因为即使是汇编代码也必须遵循内存安全的核心规则，你可以编写关于它们应该能访问什么内容的策略，并在签署固件镜像之前对它们进行审计。仅仅猜测包含一些重要数据或代码的地址并不能让你访问那块内存。你可以编写安全的代码，而不必担心整类错误，并且可以避免部署昂贵的安全更新来沙盒化组件。最重要的是，你可以通过查看其接口了解一段代码的安全属性。

CHERIoT专注于小型系统，因为可以用提供比现有硬件更安全和可用的抽象的东西替换整个操作系统。即使是在这里，我们也仅仅开始了解记忆安全性（包括引用完整性和控制流完整性）在构建系统的其他部分时可能带来的可能性。从商用CHERI硬件出货到消费者操作系统能够依赖它进行核心抽象可能需要至少十年。

能让我兴奋的是：能够在复杂系统中深度嵌入不受信任的代码，并与其他部分的不受信任代码之间进行丰富的通信。

希望在那个世界见到你们所有人。
