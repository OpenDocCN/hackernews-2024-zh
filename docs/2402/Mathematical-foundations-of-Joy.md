<!--yml

category: 未分类

date: 2024-05-29 13:19:38

-->

# Joy 的数学基础

> 来源：[https://hypercubed.github.io/joy/html/j02maf.html](https://hypercubed.github.io/joy/html/j02maf.html)

# Joy 的数学基础

*作者：曼弗雷德·冯·图恩*

*摘要:* Joy 是一种功能性编程语言，不基于将函数应用于参数，而是基于函数的组合。本文描述了该语言的理论基础。Joy 程序的表示将程序连接的语法单子映射到函数组合的语义单子。Joy 不使用 lambda 抽象，而是使用程序引用，高阶函数可以通过将引用程序解引用为一阶函数来模拟。

*关键词:* 功能性编程，语法和语义单子，函数组合，程序的引用和解引用，组合子，递归定义的消除。

* * *

# 介绍

Joy 程序由仅有的两个构造器构建而成：*连接* 和 *引用*。

连接是一个二元构造器，由于它是可结合的，最好用中缀表示法来书写，因此不需要括号。由于连接是其类别中唯一的二元构造器，Joy 中最好不用显式符号来表示。

引用是一个一元构造器，其操作数是一个程序。在 Joy 中，程序的引用用方括号括起来来表示。最终，所有程序都是由原子程序构建而成的，这些原子程序没有任何部分。

Joy 语义必须解释原子程序的含义，以及连接程序的含义如何依赖于其部分的含义，以及引用程序的含义是什么。此外，它还必须解释在什么条件下可以用等效的部分替换另一部分，同时保留整个程序的含义。

Joy 程序表示接受一个参数并产生一个值的函数。参数和值都是由至少三个组成部分构成的*状态*。主要组成部分是*栈*，其他组成部分在此处不需要。Joy 语义的许多细节依赖于程序的具体属性。

然而，Joy 语言语义的核心在于以下几点：

> 两个程序的连接表示由这两个程序表示的函数的组合。

函数组合是可结合的，因此表示映射程序连接的关联语法操作到函数组合的关联语义操作。程序的引用表示一个函数，该函数接受任何状态作为参数，并以相同的状态作为值返回，只是引用被推入栈中。

连接的一部分可以被另一个表示相同函数的部分替换，同时保留整个连接的表示。

在执行时，可以用另一个表示相同函数的引用程序替换一个引用程序，这种情况在 Joy 的组合子提供的上下文中进行。这些组合子像其他语言中的高阶函数一样表示函数。

上述内容可以总结如下：设 `P`、`Q1`、`Q2` 和 `R` 是程序，`C` 是一个组合子。那么这个原则成立：

```

        IF          Q1      ==      Q2
        THEN     P  Q1  R   ==   P  Q2  R
        AND        [Q1] C   ==     [Q2] C

```

这一原则是*Joy 代数*推理的首要规则，涉及 Joy 程序的等价性，因此也涉及由这些程序表示的函数的同一性。在代数中，少数法则可以在没有组合子的情况下表达，但大多数需要一个或多个组合子来表达。

本文的其余部分组织如下。接下来的几节将讨论程序的串联和函数的组合。其中第一节回顾了称为幺半群的某些代数结构，以及它们之间的同态映射。在接下来的一节中，Joy 程序的含义被证明是从语法幺半群到语义幺半群的同态映射。最后一节详细解释了语义幺半群，特别是函数的组合和单位函数。

其他部分涉及引用和组合子。第一部分处理不涉及栈的组合子，第二部分处理涉及栈的组合子。下一节说明了这些非常基本的组合子如何在没有显式定义的情况下模拟递归。总结部分重述了主要结论，并暗示与范畴论的联系。

# 幺半群和同态映射

Joy 的设计受到了[{Quine71}](refs.html#%7BQuine71%7D)和[{Backus78}](refs.html#%7BBackus78%7D)的启发，他们在完全不同的领域研究了如何消除某种类型的变量，以及如何通过组合子完成它们的工作。而他们的工作则基于先驱者Schönfinkel和Curry。Backus 认为，应该基于产生强大且清晰的数学规律的原则选择编程语言的概念。特别是，他倾向于允许简单代数操作的概念，在可能的情况下通过组合子或高阶函数替换变量。在这些目标的指导下，他的研究最终形成了语言*FP*。Joy 语言为实现相同目标提供了一种非常不同的解决方案。Paulson [{Paulson92}](refs.html#%7BPaulson92%7D) 曾指出，“将编程与纯数学结合到一个形式框架中是困难的”。Joy 试图完成这一任务。

Joy 语言的优雅主要源于其语法的简单代数结构和语义的简单代数结构，以及这两种结构如此相似。特别是，这两种结构都是*幺半群*，将语法映射到语义的意义函数是*同态映射*。

单调和同态从抽象代数中很熟悉。*单调* `M`包括一个非空集`{m, m1, m2 ...}`和一个二元操作，写成中缀形式`"."`。特殊元素必须是二元操作的左右*单位元素*，并且二元操作必须是*结合*的。符号表示，对于集合中的所有`x`, `y`和`z`，

```

        m . x   =   x   =   x . m
        (x . y) . z   =   x . (y . z)

```

例如，这些都是单调：带有`0`作为单位元素和加法作为二元操作的整数，或带有`1`作为单位元素和乘法作为二元操作的整数。逻辑中的两个例子是带有假性作为单位元素和析取作为二元操作的真值，或带有真实性作为单位元素和合取作为二元操作的真值。集合论中的两个例子是带有空集作为单位元素和集合并作为二元操作的集合，或者带有全集作为单位元素和集合交作为二元操作的集合。在上述例子中，二元操作是可交换的，但这对单调来说并非必要。另外两个例子包括具有空列表作为单位元素和连接作为二元操作的列表，或具有空字符串作为单位元素和连接作为二元操作的字符串。连接*不*是可交换的。

因为结合律，不需要括号。而且，如果没有其他二元操作，中缀运算符本身可以省略，并且通过并置表示操作。单位元素通常称为恒元素，但在Joy中这个词已经有不同的含义。单位元素有时也称为中性元素。

单位元素应与*零元素*区分开来，后者与乘法中的数字`0`交互的方式类似：包含零因子的乘积等于零。在逻辑中，假性是合取的零元素，真实性是析取的零元素。对于集合，空集是交的零元素，全集是并的零元素。在交换单调中，通常只有一个零元素。

设`M`是由`{m, m1 ..}`组成的一个单调，`N`是由`{n, n1 ..}`组成的另一个单调。如果函数`h`从`{m, m1 ..}`到`{n, n1 ..}`的映射被称为*同态*，当且仅当它将单位元素映射到单位元素，并且与二元操作交换：

```

        h(m)  =  n                      h(x . y)  =  h(x) . h(y)

```

在第二个等式中，左边的二元操作是`M`的，右边的是`N`的。一个例子是对数函数，它是从乘法单调到加法单调的同态。另一个同态的例子是列表的`size`（或长度）函数，它将列表单调映射到加法单调：空列表的大小为零，两个列表连接的大小是两个列表大小的和：

```

        log(1)  =  0                    log(x * y)  =  log(x) + log(y)
        size([])  =  0                  size(x ++ y)  =  size(x) + size(y)

```

（在最后两个方程中，符号`[]`和`++`用于空列表和串联。）其他例子是接受列表（或字符串）作为参数并返回其元素集合的函数。因此，此函数删除重复项并忽略顺序。它将列表单子映射到具有空集为单位和并集为二元操作的集合单子。

可以在不是单子的其他代数上定义同态。例如群、环、域和布尔代数。它们在通用代数和范畴论中被研究。一个特殊的同态可以被描述为令人惊叹：这是哥德尔的语法算术化 - 对于理论公式的所有语法操作都映射到其哥德尔数的相应算术操作。（参见例如[{Mendelson64}](refs.html#%7BMendelson64%7D).）

在命题逻辑中，公式的等价类构成了具有多个元素的布尔代数。估值是从该代数到两元布尔代数的同态。可以进一步深入：公式的意义是使其为真的估值集合。然后，意义函数是从等价类的布尔代数到估值集合的布尔代数的同态。这种情况在语义学中很典型：意义函数是一个同态。Joy 也是如此 - 意义函数是从 Joy 语法到 Joy 语义的同态。

# 一个语法单子和一个语义单子

Joy 程序的*语法*非常简单：基本构件是原子程序，更大的程序通过串联形成作为程序构建的主要模式之一。串联是可结合的，因此不需要括号。此外，串联是唯一的二元构造器，因此不需要显式符号，因此串联可以通过并置来表示。具有左右单位元素`id`也是很有用的，这些元素共同构成了语法单子。

现在让我们来谈谈*语义*。在介绍中提到，Joy 使用后缀表示法来评估算术表达式。为了加两个数，它们被推送到堆栈上，然后由它们的和替换。这种术语很有帮助，但在几个方面可能会误导。措辞暗示了一种过程化或命令式的解释：Joy 程序由诸如“push this”、“push that”、“pop these”和“push their sum”等命令组成。但 Joy 并不是过程化的，在这里描述的是一个纯函数式语言。

然而，命令的术语确实暗示了一些有用的东西。命令在执行时会产生变化。确切地说，变化取决于命令的性质。但在最一般的术语中，改变的是系统的状态。特别是后缀表达式的执行会改变堆栈的状态。对于每个变化，都有一个前状态和一个后状态。

所以，变化本质上是将状态作为参数并产生状态作为值的函数。只有一个前状态，因此它们是单参数函数。因此它们可以被组合。两个函数的复合可以作为状态的参数应用，并产生通过先将一个函数应用于参数，然后将另一个函数应用于结果值而获得的状态作为值。这基本上是Joy的语义：所有程序表示从状态到状态的函数。

状态不必是堆栈的状态。仅仅是后缀表达式的评估在堆栈上如此方便。但表达式的评估绝不是一切。接下来，堆栈是状态的一个重要部分，但对于许多目的来说，忽略整个状态是有用的。

*函数复合*的操作是可结合的，并且有一个左和右单位元素，*恒等函数*。总体上它们构成语义单子。意义函数将句法单子映射到语义单子。两个程序的连接表示由这两个程序表示的函数的复合，而连接的单位元素表示复合的单位元素。

# 函数复合和恒等函数

如果*程序* `P` 和 `Q` 表示相同的函数，则*函数* `P` 和 `Q` 是*相同的*。如果对它们的定义域交集中的所有值它们产生相同的值，则两个函数是相同的。这将被写成

```

        P   ==   Q

```

符号`==`将用于表示Joy函数的身份。该符号不属于Joy语言，而属于其元语言。函数之间的*身份关系*显然是*自反*、*对称*和*传递*的。此外，在较大的上下文中如组合中，相同的东西是无法分辨的。因此，*相同物的替换*可以用作推理规则：

```

        IF             Q1      ==      Q2
        THEN        P  Q1  R   ==   P  Q2  R

```

符号`id`将用于表示*恒等函数*。函数复合是可结合的，并且恒等函数是左单位和右单位，这一事实由以下表达：

```

        (P  Q)  R   ==   P  (Q  R)
        id  P   ==   P   ==   P  id

```

该符号可以用来表达看起来像数字身份的东西；例如

```

        2  3  +   ==   5

```

表达左边三个*函数*的组合与右边一个*函数*的相同。左边，前两个函数将*数字* 2 和 3 推入堆栈，第三个函数将它们替换为它们的和。右边，该函数推入*数字* 5。左边和右边对所有堆栈作为参数定义，并生成相同的堆栈作为值。因此，左边和右边是相同的。

但是很重要的是要非常清楚方程的意思。四个符号 `2`、`3`、`+` 和 `5` 每个代表一个以堆栈作为参数且生成堆栈作为值的函数。这三个*数字符号* `2`、`3` 和 `5` 分别代表*函数*，适用于所有参数堆栈。它们的返回值是类似参数堆栈的另一个堆栈，只不过顶部添加了一个新的*数字*，即 2、3 和 5。

符号 `+` 并*不*表示两个数字的二元函数，而是像所有 Joy 函数一样，只接受一个参数。该参数必须是一个顶部两个元素为数字的堆栈。返回的值是另一个堆栈，其顶部两个数字被它们的和替换。由此可见，上述方程*不*表达数字的同一性，而是*函数*的同一性。

组合的结合性对于*柯里化*有一定的影响：标准和柯里化操作符之间没有区别。考虑以下例子

```

        (2  3)  +   ==   2  (3  +)

```

左边的 `+` 接受由 `(2 3)` 提供的两个参数。右边的 `+` 给出一个参数 `3`。生成的函数 `(3 +)` 期望一个参数，它将加上 `3`。由于结合性，两边是相同的，因此不需要括号。

设 `P` 是一个将 `m` 个值推入堆栈的程序。设 `Q` 是一个期望堆栈上有 `n` 个值的程序，其中 `m` <= `n`。现在考虑它们的连接 `P Q`。对于 `Q` 期望的 `n` 个值，`P` 提供了 `m` 个。因此，程序 `P Q` 只需要堆栈上的 `n - m` 个值。

* * *

+++HERE+++ 关联与柯里化

* * *

在数学的发展中，对数字 `0` 的显式符号是一个相当近期的创新。该符号使人们可以说的不仅仅是 `0` 是加法的单位元。类似地，在函数的代数中，对于恒等函数的显式符号使得可以陈述许多定律成为可能。这对 Joy 中的函数尤为重要。以下是一些例子：

在算术中，`0`和`1`是加法和乘法的单位元素，因此加`0`或乘以`1`没有效果。对于列表，空列表是一个单位元素，因此左侧或右侧的连接没有效果。同样在逻辑中，虚假和真实是析取和合取的单位元素，因此与虚假的合取和与真实的合取没有区别。此外，在逻辑中，析取和合取是幂等的，因此与重复的元素进行析取或合取会产生原始元素。对于任何堆栈，交换顶部两个元素两次没有净效果，并且复制顶部元素然后弹出副本也没有净效果。

还有许多定律：双重否定没有净效果，两次反转序列仍然是原始的，以及取继承者和前驱者的数字 - 无论顺序如何 - 都不会产生净效果。在*Joy的代数*中，这些由以下表达：

```

        0  +   ==   id                  1  *   ==   id
        []  concat   ==   id            []  swap  concat   ==   id
        false  or   ==   id             true  and   ==   id
        dup  and   ==   id              dup  or   ==   id
        swap  swap   ==   id            dup  pop   ==   id
        not  not   ==   id              reverse  reverse   ==   id
        succ  pred   ==   id            pred  succ   ==   id

```

注意，这些定律表达时不需要任何变量。

身份函数是函数组合的左右单位元素。在此适当地指出，还有一个*左零元素*和一个*右零元素*。两个这样的元素`l`和`r`对于所有程序`P`满足以下条件：

```

        l  P   ==   l                   P  r   ==   r

```

由于函数组合不是可交换的，两个零元素并不相同。在Joy语言中，左零元素`l`是`abort`操作符，它忽略其后的任何程序。右零元素`r`是`clearstack`操作符，它清空堆栈，因此忽略可能在其前执行的任何计算。这两个操作符具有一定的理论兴趣，并且偶尔会有用。

# 引用、反引用和组合子

任何方括号括起来的程序称为*引用程序*或*引用*。方括号中的引用`[5]`的长度或`size`是`1`，而方括号中的引用`[2 3 +]`的长度是`3`。然而，正如前面提到的，方括号中的两个程序表示相同的函数。这表明我们不能互换它们的引用：

```

        [5]  size   =/=   [2 3 +]  size

```

禁止替换的是方括号引用。因此，引用产生不透明的上下文，引用是一种内涵构造。

然而，在某些上下文中，可以在引用之间进行替换。这些上下文中，引用内容不被视为被动数据，而是作为主动程序处理。在Joy语言中，这种处理归因于*组合子*，其实质上反引用其一个或多个参数。

`i`组合子期望在堆栈顶部引用一个程序。它弹出该程序并执行它。因此，如果引用程序`[P]`刚刚被推送到堆栈上，那么`i`组合子将执行`P`：

```

        [P]  i   ==   P

```

例如，以下四个程序都计算相同的函数 - 接受任何堆栈作为参数并返回值为另一个堆栈，该堆栈与参数堆栈相似，但顶部推入数字`5`。

```

         2  3  +                         5
        [2  3  +] i                     [5] i

```

如果程序`P`计算恒等函数，则应用`i`组合器的效果就是恒等函数的效果：

```

        [id]  i   ==   id               []  i   ==   id

```

另一条定律是：

```

        i  ==  []  cons  i  i

```

两个程序`P`和`Q`可能看起来非常不同 - 例如，它们的大小可能不同。但可能它们计算相同的函数。在这种情况下，它们引用的去引用也会计算相同的函数：

因此

```

        IF       P       ==    Q
        THEN    [P]  i   ==   [Q]  i

```

现在假设一个引用程序`[P]`位于栈顶。它可以使用`i`组合器执行。但它也可以首先作为一个被动数据结构进行操作。例如，可以推送引用`[i]`，然后使用`cons`运算符将`[P]`插入到`[i]`中，得到`[[P] i]`。如果这通过`i`组合器执行会发生什么？内部的`[P]`引用被推送，然后内部的`i`组合器被执行。因此，其净效果就是执行`P`。

因此

```

        [i]  cons  i   ==   i

```

注意，可以在不引用`[P]`的情况下陈述这一定律。但它可能有助于明确一个后果：

```

        [P]  [i]  cons  i   ==   [[P] i]  i   ==   [P]  i   ==   P

```

`i`组合器只是其中之一。另一个是`b`组合器，它期望栈顶有两个引用的程序。它弹出这两个引用程序，并且首先执行栈顶的程序，然后继续执行第二个程序。因此，在刚刚推送了两个程序`[P]`和`[Q]`的特殊情况下，`b`组合器将按照它们被推送的顺序执行它们：

```

        [P]  [Q]  b   ==   P  Q

```

由此可见，`b`组合器实际上去引用了它的两个参数，因此可以用等效的程序替换它们中的任何一个或两个：

```

        IF       P1  ==  P2     AND    Q1  ==  Q2
        THEN    [P1]  [Q1]  b   ==   [P2]  [Q2]  b

```

如果两个程序都计算恒等函数，则`b`组合器的效果是恒等函数。如果两个程序中的任何一个计算恒等函数，则其效果等同于执行另一个程序，这等同于将`i`组合器应用于另一个程序：

```

        []  []  b   ==   id
        []  b   ==   i
        []  swap  b   ==   i

```

第二个等式可以反转，这表明`i`组合器可以根据`b`组合器来*定义*。

引用是序列，序列可以连接。在Joy中，字符串、列表，更一般地说，引用可以使用`concat`运算符连接。如果刚刚推送了`[P]`和`[Q]`，则它们可以连接成`[P Q]`。通过`i`组合器执行结果连接的效果就是执行这两个程序，这也可以通过应用`b`组合器来实现：

```

        [P]  [Q]  concat  i   ==   P  Q   ==   [P]  [Q]  b

```

但是两个引用的程序并不必须立即推送到连接或`b`组合器的应用之前。相反，它们可以从较小的部分构建或从某些较大的引用中提取。因此，更一般的法则是：

```

        concat  i   ==   b

```

方程可以反过来，因此`b`组合器可以用`i`组合器来*定义*。这两个组合器的*名称*`i`和`b`之所以选择这样的名字，是因为它们与*组合逻辑*中的*I组合器*和*B组合器*相似。标准文本为[{Curry58}](refs.html#%7BCurry58%7D)，但其他书籍中也有很好的阐述，例如[{Burge75}](refs.html#%7BBurge75%7D)。

# 基于堆栈的组合器

前两个组合器需要一个或两个带引号的程序作为参数，但这些参数只需放在一个约定好的位置上，不需要在堆栈上。如果数据位于堆栈上，那么有几个组合器才有意义。

有时需要操作堆栈的不是顶部而是顶部下面的项目。这就是`dip`组合器的用途。它的行为类似于`i`组合器，通过在堆栈顶部执行一个引用，但它会保持位于引用下面的项目不变。具体来说，它期望一个程序`[P]`，在其下面是另一个项目`X`。它弹出这两个项目，保存`X`，执行`P`，然后恢复`X`。

例如，在以下示例中，保存和恢复的项目是`4`：

```

        2  3  4  [+]  dip  ==   5  4

```

如果一个程序计算恒等函数，那么应用`dip`组合器的效果就是计算恒等函数：

```

        [id]  dip   ==   id             []  dip   ==   id

```

假设一个程序`[P]`位于堆栈顶部，首先将其复制，然后使用`dip`在原始`[P]`的下面执行副本。现在原始的已经被恢复，但假设现在显式弹出它。净效果与仅使用`i`组合器执行原始`[P]`相同：

```

        i   ==   dup  dip  pop

```

假设堆栈顶部有两个程序`[P]`和`[Q]`，其中`[Q]`位于顶部。要执行`[P]`并将`[Q]`保存在上面的一种方法是：首先推入`[i]`。现在`[Q]`是第二个元素。执行`dip`将保存`[Q]`并在堆栈上执行`[i]`，现在堆栈顶部有`[P]`。这相当于执行`[P]`，之后`[Q]`被恢复。

假设现在需要执行`[Q]`，这可以通过`i`组合器轻松完成。所有这些的净效果与先执行`[P]`，然后执行`[Q]`是相同的，这可以通过`b`组合器完成。因此

```

        b   ==   [i]  dip  i

```

最后两个方程表明`dip`组合器可以用来*定义*`i`组合器和`b`组合器。反之则不可能。

最后两个方程还用来说明Joy程序的代数操作。在最后一个方程中，`i`组合器出现了两次，一次带引号，一次无引号。根据前一个方程，这两个出现都可以替换，结果是

```

        b   ==   [dup dip pop]  dip  dup  dip  pop

```

未引用出现的替换没有问题。但其他替换需要说明。引用的出现只能在去引用的上下文中替换，在这种情况下，`dip`组合器提供了这样的上下文。

再次假设栈上有两个引用程序`[P]`和`[Q]`。如果执行`dip`组合器，它将导致执行栈顶引用`[Q]`的同时保存并稍后恢复`[P]`。假设接下来执行`i`组合器，这将导致恢复的`[P]`被执行。因此，这两个组合器的净效果是首先执行`P`，然后执行`Q`。同样的效果也可以通过先交换`[P]`和`[Q]`，使`[P]`置于顶部，然后执行`b`组合器来实现。左定律下表达了同样的事情。右定律也表明了定义`b`组合器的另一种方式。

```

        dip  i   ==   swap  b           b   ==   swap  dip  i
                                        b   ==   swap  dip  dup  dip  pop

```

函数组合是可结合的，因此以下内容成立：

```

        [P]  [Q]  b  [R]  i   ==   [P]  i  [Q]  [R]  b

```

要消除此方程式中的三个引用，请注意它们可以写在两侧，前提是适当应用`b`组合器和`i`组合器。对于左侧来说，这很容易：

```

        [P]  [Q]  b  [R]  i   ==   [P]  [Q]  [R]  [b] dip i

```

对于右侧来说，稍微有些困难，因为`i`组合器必须应用于由两个其他引用所遮蔽的`[P]`。在这种情况下，必须使用`dip`组合器作用于自身，如下所示：

```

        [P]  i  [Q]  [R]  b   ==   [P]  [Q]  [R]  [[i] dip]  dip  b

```

将两个右侧合并并取消共同的三个引用，我们得到以下表达函数组合结合律的方式：

```

        [b]  dip  i   ==   [[i] dip]  dip  b

```

在此定律中，我们甚至可以根据早期的定义替换`i`组合器和`b`组合器：

```

        [swap  dip  dup  dip  pop]  dip  dup  dip  pop
   ==   [[dup  dip  pop]  dip]  dip  swap  dip  dup  dip  pop

```

可以取消两侧的最终`pop`，但不能取消两侧的前终止`dip`。这个不太可能的定律也表达了函数组合的结合性。但最优雅地表达结合性的方式是使用`dip`组合器的变种，称为`dipd`，可以这样定义：

```

        dipd   ==   [dip]  cons  dip

```

随后，可通过以下方式表达结合律：

```

        [b]  dip  i   ==   [i]  dipd  b

```

([{Henson87}](refs.html#%7BHenson87%7D)批评了FP系统的展示，最初由[{Backus78}](refs.html#%7BBackus78%7D)提出，因为它们虽然在证明中使用了这一效果，但未给出相应的定律。)

紧接着的`dip`组合器与`i`组合器的组合有时对于将栈顶的几个元素排列成适合执行位于栈顶的引用程序`[P]`是有用的。

这就是做法：首先推入另一个引用程序`[Q]`，并使用`dip`组合器执行它。这将保存并恢复`[P]`，但会按照`[Q]`的方式排列栈。然后通过`i`组合器执行恢复的`[P]`。根据选择的`[Q]`，`[Q]`、`dip`组合器和`i`组合器的三部分组合将准备好栈，以执行`[P]`。

由于这样的组合仍然需要堆栈上的`[P]`，因此任何这样的组合都具有组合子的效果。以下是一些有时有用的简单选择的`[Q]`的示例。这些组合子的名称之所以被选择，是因为它们与*组合逻辑*中的*K组合子*、*W组合子*和*C组合子*相似。

```

        k   ==   [pop]  dip  i
        w   ==   [dup]  dip  i
        c   ==   [swap] dip  i

```

# 更一般的法则

假设堆栈顶部有一个引用程序`[P]`。这现在可以由某个组合子，比如`C`执行。或者，可以推送引用`[C]`，然后使用`cons`运算符将之前的`[P]`插入到后面的引用中，这样就生成了`[[P] C]`。当然，这可以由`i`组合子执行。当这发生时，内部的`[P]`被推送，部分撤销了`cons`操作。但然后`C`将被执行。其净效果与前面的替代方法相同。因此我们有：对于所有运算符或组合子`C`

```

        [C]  cons  i   ==   C

```

应当指出，这个定理也适用于运算符，比如`O`，而不仅仅是组合子`C`。

再假设堆栈顶部有一个引用程序`[P]`。它可以由某个组合子`C`执行，或者可以这样做：推送引用`[i]`，用`cons`将之前的`[P]`插入其中，现在执行`C`。`cons`操作产生了`[[P] i]`，当这个被`C`执行时，内部的`[P]`部分地撤销了`cons`。然后`i`组合子实际上执行了这个。其净效果就是执行`C`。因此对于所有组合子`C`

```

        [i]  cons  C   ==   C

```

上述两条法则可以结合：对于所有组合子`C`

```

        [i]  cons  C   ==   [C]  cons  i

```

到目前为止，我们只遇到了一个需要两个引用参数的组合子 - `b`组合子。但是Joy语言有大量的组合子，它们需要两个、三个甚至四个引用参数。以下是那些期望至少有两个引用程序作为参数的组合子。对于这样的组合子，前三个法则保持不变，但也有以下变化：

```

        [i]  cons  cons  C   ==   C
        [C]  cons  cons  i   ==   C
        [i]  cons  cons  C   ==   [C]  cons cons  i

```

这个原则推广到至少有三个引用参数的组合子，允许三个`cons`操作的发生。

最后，第二条法则推广到组合子的所有参数：任何一个参数`[P]`都可以被`[[P] i]`替换。当然，这个替换可以通过将`[P]`与`[i]`进行`cons`操作来构造。当然，对于所有引用参数都可以这样做。如果只有一个参数`[P]`，那么将其`cons`到`[i]`中以生成`[[P] i]`就足够简单，就像第二条法则一样。

如果有两个参数`[P]`和`[Q]`，将它们改变为`[[P] i]`和`[[Q] i]`已经变得非常乏味。如果有三个或更多的引用参数，那么生成这三个变化的程序可能会相当复杂。

Joy有一个组合子可以使用函数对列表的元素进行`map`，生成一个包含应用函数结果的相同长度的列表。几个特殊形式的参数不是任意列表，而是来自堆栈的指定数量的一个、两个、三个等元素。这些是`app1`组合子、`app2`组合子、`app3`组合子等。这些组合子正好用于生成组合子参数所需的更改。对于需要一个、两个或三个引用参数的组合子`C1`、`C2`和`C3`，以下法则成立：

```

        [[i] cons]  app1  C1   ==   C1
        [[i] cons]  app2  C2   ==   C2
        [[i] cons]  app3  C3   ==   C3

```

对于组合子C3的说明：

```

         [P]      [Q]      [R]    [[i] cons]  app3  C3
   ==   [[P] i]  [[Q] i]  [[R] i]                   C3
   ==    [P]      [Q]      [R]                      C3

```

从计算角度来看，当引用被用作组合子的参数时，将`[P]`替换为`[[P] i]`当然是毫无意义的。但在用Joy编写的Joy解释器中，这些替换是无价的。这个解释器本质上是一个复杂的组合子，恰当地称为`joy`，它必须像`i`组合子一样行为。在`joy`组合子的定义中，所有组合子的实现都使用上述映射组合子，但用`[[joy] cons]`代替`[[i] cons]`。

# 消除定义

大型软件的一个问题涉及相互依赖部分的复杂性和使接口精简的需求。在某种程度上，这是信息隐藏的问题，编程语言通过各种方式实现这一点。大多数语言都有局部符号，比如函数的形式参数和过程的局部变量。许多语言具有完整的块结构，允许函数和过程的声明嵌套，因此在外部不可见。一些语言具有模块或其他编译单元，允许在更大的程序组件中进一步隐藏信息。Joy以不同的方式解决这个问题 -- 首先最小化需要隐藏的信息。主要问题大多源于命名函数和过程的声明及其命名的形式参数。

有几个原因可能需要声明一个函数，

1.  它需要递归，或者

1.  它在程序的几个看似无关的地方都是必需的，或者

1.  它使程序更清晰。

第三个原因总是有效的。在Joy中，第二个原因远不那么强烈，第一个几乎没有力量。

Joy有大量的组合子，允许计算通常通过递归定义的匿名函数。它还有允许在某些相关模式中重复调用这些函数的组合子。Joy程序使用适当的组合子允许计算具有匿名形式参数的匿名函数。

考虑在（虚构的）函数式语言中对*阶乘*函数进行以下递归定义和使用：

```

    LET  factorial(n)  =  if n = 0 then 1 else n * factorial(n - 1)
     IN  factorial(5)

```

第二行的调用应返回`120`。乔伊有多种方法可以进行基本上相同的计算，而不引入*名称* `factorial` 和不引入形式参数 `n` 的*名称*。其中几种方法仍然是基于递归定义，并且长度大致相同。其中两种是基于定义具有*线性递归*和*原始递归*的模型。正如所有语言一样，使用*累积参数*可以完全避免递归，但这不是这里的重点。

平凡的`i`和`dip`组合子显然不是为了递归而设计的，因此它们能够用于模拟递归而不命名函数或其形式参数将是一种惊喜。为了使递归成为可能，必须使匿名函数的每次调用都能够再次访问自身，这通过在堆栈顶部给它自己的体作为引用参数来实现。这是通过始终先复制引用体然后使用`i`组合子执行复制来实现的。`dip`组合子可以用于访问引用体下面的堆栈。唯一需要的另一个组合子是`ifte`组合子，它实现了与上面传统定义中的`if-then-else`相同类型的两路分支。

这是程序：

```

1           5
2           [  [pop  0  =]
3              [pop  pop  1]
4              [  [dup  1  -]  dip
5                 dip  i
6                 *  ]
7              ifte  ]
8           dup  i

```

行号仅用于参考。执行从第1行开始，将实际参数 `5` 推入堆栈。然后将从第2行到第7行的长引用推入堆栈。这个引用是函数体，对应于传统定义的右侧。执行继续到第8行，其中长引用被复制，顶部副本由 `i` 组合子执行。此执行的效果是将第2行和第3行的两个短引用以及第4行到第6行的较长引用推入堆栈。因此，在这一点上，堆栈包含参数 `5`，并且以上四个引用。

但现在，`ifte` 组合子在第7行执行。它弹出最后三个引用并将它们保存在其他地方。然后执行 if-部分，即来自第2行的保存的引用。这将弹出现在堆栈顶部的函数体，从第2行到第7行。这将显示该参数是一个数字，并将其与`0`进行比较。

比较将产生一个真值，`ifte` 组合子将使用它来确定是执行从第3行保存的 then 部分，还是执行从第4行到第6行保存的 else 部分。在任何情况下，堆栈首先恢复到执行 if-部分之前的状态：再次将函数的引用体置于堆栈顶部，并且以下是这个特定调用的实际参数。如果最近的比较通过 if-部分是真的，那么将执行从第3行保存的 then 部分。

这导致函数体和实际参数从堆栈中弹出，并被`1`替换，即`0`的阶乘。另一方面，如果最近的比较为假，则执行从第4行到第6行保存的else部分。为了后续的乘法运算，参数必须被复制，并且顶部的副本必须被减少。由于函数体的存在，复制和减少是通过第4行的`dip`组合子完成的。

此时堆栈上的前三个元素是这次调用的原始参数，然后是递减的副本，顶部是函数的引用体。现在必须计算递减副本的阶乘，这次调用可能需要再次访问函数体。因此，不能简单地通过`i`组合子执行函数体，而是在第5行先复制函数体，然后通过`i`组合子执行副本。执行该复制的函数体最终将终止，然后顶部两个元素将是原始参数和其递减副本的阶乘。然后在第6行将这两个数字相乘，得到此调用参数的所需阶乘。这完成了从第4行到第6行else部分的执行。无论then部分还是else部分被执行，`ifte`组合子的执行都已完成。

这完成了在第2行到第7行函数体的执行。它也完成了在第5行或第8行触发此函数体执行的任何`i`组合子的执行。最终在第8行的`i`组合子的执行也将完成，此时第1行的参数`5`将被其阶乘`120`替换，如所需。

需要做两点简短的评论：首先，程序的*描述*是以一种心理上有帮助的命令式或过程化方式给出的。但这并不改变所有Joy程序及其所有部分表示函数的事实。其次，可以通过在第5行和第8行的两次调用`i`组合子中使用`dup dip pop`替换，仅使用`dip`组合子和`ifte`组合子来编写该程序。

当然，这个程序是一次*技艺的展示*，它既难看又低效。使用更合适的组合子可以编写更简洁和高效的程序。特别是，不必重复推送和保存引用的if部分、then部分和else部分。同时，不需要重复复制引用的函数体，因此当它位于顶部时，这三部分不必绕过函数体。事实上，if部分的本质和大部分else部分已经集成到了`primrec`组合子中，用于原始递归。整个程序如下：

```

        5  [1]  [*]  primrec

```

如前所述，甚至可以消除递归的使用，而采用使用累积参数的更高效的循环组合子。

# 总结

本文试图解释语言Joy的理论基础。通过总结以下真实情况，语义的大部分被概括如下：

```

        2  3  +   ==   7  2 -
        dup  +   ==   2  *
        dip  i   ==   swap  b

```

第一个*似乎*表达了数字的身份。第二个*似乎*表达了函数的身份，这两个函数都会将它们在栈上期望的给定数字加倍。第三个*似乎*表达了函数式的身份，或者说是二阶函数，它们将两个一阶函数作为参数并组合它们。

虽然这些阅读有时有所帮助，但Joy语义的统一确实促使了不同的解释。所有三个等式都表达了Joy函数的身份，这些函数接受一个参数栈并生成一个值栈。

*范畴论*这一数学学科处理的是单参数函数。所有Joy函数也属于这种类型。事实上，所有的幺半群都是范畴的特例，因此Joy的语法幺半群与Joy的语义幺半群都是范畴。因此，应该期望一些基本的联系。特别是，Joy与笛卡尔闭范畴相关，并与"组合抽象机器"*CAM*有关，请参见例如[{Poigne92}](refs.html#%7BPoigne92%7D)。

该论文[j00ovr](J00OVR.HTML)包含对Joy的概述，并参考了处理Joy特定方面的其他论文。

* * *
