["```\n[1](#hl-0-1)SHA256(\"Foo\") == [ 44,  38, 180, 107, 104, 255, 198, 143, [2](#hl-0-2) 249, 155,  69,  60,  29,  48,  65,  52, [3](#hl-0-3) 19,  66,  45, 112, 100, 131, 191, 160, [4](#hl-0-4) 249, 138,  94, 136,  98, 102, 231, 174] [5](#hl-0-5) [6](#hl-0-6)Base64(SHA256(\"Foo\")) == LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564= \n```", "```\n[1](#hl-0-1)<svg viewBox=\"-1 -1 2 2\" xmlns=\"http://www.w3.org/2000/svg\"> [2](#hl-0-2) <!-- ... --> [3](#hl-0-3)</svg> \n```", "```\n[1](#hl-1-1)<svg overflow=\"visible\" viewBox=\"-1 -1 2 2\" xmlns=\"http://www.w3.org/2000/svg\"> [2](#hl-1-2) <path d=\"M 0,0 L 0,-1 A 1,1,0,0,1,1,0 z\" fill=\"IndianRed\" stroke=\"black\" stroke-width=\"0.01\" /> [3](#hl-1-3) <path d=\"M 0,0 L 1,0 A 1,1,0,0,1,0,1 z\" fill=\"LightCoral\" stroke=\"black\" stroke-width=\"0.01\" /> [4](#hl-1-4) <path d=\"M 0,0 L 0,1 A 1,1,0,0,1,-1,0 z\" fill=\"Salmon\" stroke=\"black\" stroke-width=\"0.01\" /> [5](#hl-1-5) <path d=\"M 0,0 L -1,0 A 1,1,0,0,1,0,-1 z\" fill=\"DarkSalmon\" stroke=\"black\" stroke-width=\"0.01\" /> [6](#hl-1-6)</svg> \n```", "```\n *`[1](#hl-2-1)fn to_color(byte: u8)  -> String { [2](#hl-2-2) let  h  =  byte  >>  4; [3](#hl-2-3) let  s  =  (byte  >>  2)  &  0x03; [4](#hl-2-4) let  l  =  byte  &  0x03; [5](#hl-2-5) [6](#hl-2-6) let  normalized_h  =  (h  as  f32)  /  16.0; [7](#hl-2-7) let  normalized_s  =  (s  as  f32)  /  4.0; [8](#hl-2-8) let  normalized_l  =  (l  as  f32)  /  4.0; [9](#hl-2-9) [10](#hl-2-10) let  h  =  360.0  *  normalized_h; [11](#hl-2-11) let  s  =  20.0  +  80.0  *  normalized_s; [12](#hl-2-12) let  l  =  40.0  +  50.0  *  normalized_l; [13](#hl-2-13) [14](#hl-2-14) format!(\"hsl({h}, {s}%, {l}%)\") [15](#hl-2-15)}`* \n```", "```\n *`[1](#hl-3-1)fn to_color(normalized_theme: f32,  byte: u8)  -> String { [2](#hl-3-2) let  h  =  byte  >>  4; [3](#hl-3-3) let  s  =  (byte  >>  2)  &  0x03; [4](#hl-3-4) let  l  =  byte  &  0x03; [5](#hl-3-5) [6](#hl-3-6) let  normalized_h  =  (h  as  f32)  /  16.0; [7](#hl-3-7) let  normalized_s  =  (s  as  f32)  /  4.0; [8](#hl-3-8) let  normalized_l  =  (l  as  f32)  /  4.0; [9](#hl-3-9) [10](#hl-3-10) let  h  =  360.0  *  normalized_theme  +  120.0  *  normalized_h; [11](#hl-3-11) let  s  =  20.0  +  80.0  *  normalized_s; [12](#hl-3-12) let  l  =  40.0  +  50.0  *  normalized_l; [13](#hl-3-13) [14](#hl-3-14) format!(\"hsl({h}, {s}%, {l}%)\") [15](#hl-3-15)} [16](#hl-3-16) [17](#hl-3-17)fn calculate_theme(bytes: &[u8])  -> f32 { [18](#hl-3-18) let  theme  =  bytes.iter() [19](#hl-3-19) .fold(0u8,  |acc,  byte|  acc  ^  byte); [20](#hl-3-20) (theme  as  f32)  /  (u8::MAX  as  f32) [21](#hl-3-21)} [22](#hl-3-22) [23](#hl-3-23)fn generate_paths(hash: [u8;  32])  { [24](#hl-3-24) let  theme  =  calculate_theme(&hash); [25](#hl-3-25) [26](#hl-3-26) let  colors  =  hash.iter() [27](#hl-3-27) .cloned() [28](#hl-3-28) .map(|byte|  to_color(theme,  byte)) [29](#hl-3-29) .collect::<Vec<_>>(); [30](#hl-3-30) [31](#hl-3-31) unimplemented!(\"Generate SVG paths.\"); [32](#hl-3-32)}`* \n```", "```\n *`[1](#hl-4-1)fn to_color(normalized_theme: f32,  normalized_ring_theme: f32,  byte: u8)  -> String { [2](#hl-4-2) let  h  =  byte  >>  4; [3](#hl-4-3) let  s  =  (byte  >>  2)  &  0x03; [4](#hl-4-4) let  l  =  byte  &  0x03; [5](#hl-4-5) [6](#hl-4-6) let  normalized_h  =  (h  as  f32)  /  16.0; [7](#hl-4-7) let  normalized_s  =  (s  as  f32)  /  4.0; [8](#hl-4-8) let  normalized_l  =  (l  as  f32)  /  4.0; [9](#hl-4-9) [10](#hl-4-10) let  h  =  360.0  *  normalized_theme [11](#hl-4-11) +  120.0  *  normalized_ring_theme [12](#hl-4-12) +  30.0  *  normalized_h; [13](#hl-4-13) let  s  =  20.0  +  80.0  *  normalized_s; [14](#hl-4-14) let  l  =  40.0  +  50.0  *  normalized_l; [15](#hl-4-15) [16](#hl-4-16) format!(\"hsl({h}, {s}%, {l}%)\") [17](#hl-4-17)} [18](#hl-4-18) [19](#hl-4-19)fn calculate_theme(bytes: &[u8])  -> f32 { [20](#hl-4-20) let  theme  =  bytes.iter().fold(0u8,  |acc,  byte|  acc  ^  byte); [21](#hl-4-21) (theme  as  f32)  /  (u8::MAX  as  f32) [22](#hl-4-22)} [23](#hl-4-23) [24](#hl-4-24)fn generate_paths(hash: [u8;  32])  { [25](#hl-4-25) let  theme  =  calculate_theme(&hash); [26](#hl-4-26) let  ring_themes  =  hash [27](#hl-4-27) .windows(8) [28](#hl-4-28) .map(calculate_theme) [29](#hl-4-29) .collect::<Vec<_>>(); [30](#hl-4-30) [31](#hl-4-31) let  colors  =  hash [32](#hl-4-32) .iter() [33](#hl-4-33) .cloned() [34](#hl-4-34) .enumerate() [35](#hl-4-35) .map(|(idx,  byte)|  to_color(theme,  ring_themes[idx  %  8],  byte)) [36](#hl-4-36) .collect::<Vec<_>>(); [37](#hl-4-37) [38](#hl-4-38) unimplemented!(\"Generate SVG paths.\"); [39](#hl-4-39)}`* \n```"]