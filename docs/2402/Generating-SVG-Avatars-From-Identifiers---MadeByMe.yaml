- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»åˆ«ï¼šæœªåˆ†ç±»
- en: 'date: 2024-05-29 13:23:02'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024-05-29 13:23:02
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Generating SVG Avatars From Identifiers - MadeByMe
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»æ ‡è¯†ç¬¦ç”ŸæˆSVGå¤´åƒ - MadeByMe
- en: æ¥æºï¼š[https://madebyme.today/projects/generating-svg-avatars-from-identifiers/](https://madebyme.today/projects/generating-svg-avatars-from-identifiers/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://madebyme.today/projects/generating-svg-avatars-from-identifiers/](https://madebyme.today/projects/generating-svg-avatars-from-identifiers/)
- en: <main class="main">
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="main">
- en: When you create a new social service on the internet, one of the things you
    need to think about is how to make a userâ€™s space feel like their own. Services
    like [GitHub](https://github.blog/2013-08-14-identicons/), Roll20, or [Reddit](https://www.reddit.com/r/reddit/comments/vtkmni/introducing_collectible_avatars/)
    generate â€” or allow you to generate â€” a custom avatar (i.e. [Identicons](https://en.wikipedia.org/wiki/Identicon))
    for your account. Avatar auto-generation is especially neat, as it does not require
    any engagement from the user. Letâ€™s try to figure that out on our own.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ‚¨åœ¨äº’è”ç½‘ä¸Šåˆ›å»ºä¸€ä¸ªæ–°çš„ç¤¾äº¤æœåŠ¡æ—¶ï¼Œæ‚¨éœ€è¦è€ƒè™‘å…¶ä¸­ä¸€ä»¶äº‹ï¼Œå³å¦‚ä½•ä½¿ç”¨æˆ·çš„ç©ºé—´æ„Ÿè§‰åƒè‡ªå·±çš„ã€‚åƒ[GitHub](https://github.blog/2013-08-14-identicons/)ã€Roll20æˆ–[Reddit](https://www.reddit.com/r/reddit/comments/vtkmni/introducing_collectible_avatars/)è¿™æ ·çš„æœåŠ¡ä¼šç”Ÿæˆ
    â€”â€” æˆ–å…è®¸æ‚¨ç”Ÿæˆ â€”â€” è‡ªå®šä¹‰å¤´åƒï¼ˆå³[Identicons](https://en.wikipedia.org/wiki/Identicon)ï¼‰ä¾›æ‚¨çš„å¸æˆ·ä½¿ç”¨ã€‚è‡ªåŠ¨ç”Ÿæˆå¤´åƒå°¤å…¶ä¸é”™ï¼Œå› ä¸ºå®ƒä¸éœ€è¦ç”¨æˆ·çš„ä»»ä½•å‚ä¸ã€‚è®©æˆ‘ä»¬è¯•ç€è‡ªå·±è§£å†³è¿™ä¸ªé—®é¢˜ã€‚
- en: I think this blog post is one of those things which are easier to understand
    if youâ€™d see the end result first. So, for those interested hereâ€™s a spoiler.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è®¤ä¸ºè¿™ç¯‡åšæ–‡æ˜¯é‚£ç§å…ˆçœ‹æœ€ç»ˆç»“æœä¼šæ›´å®¹æ˜“ç†è§£çš„äº‹ç‰©ä¹‹ä¸€ã€‚å› æ­¤ï¼Œå¯¹äºæœ‰å…´è¶£çš„äººï¼Œè¿™é‡Œæœ‰ä¸ªå‰§é€ã€‚
- en: 'This is the end result:'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æœ€ç»ˆç»“æœï¼š
- en: Avatar for identifier "Foo".
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: æ ‡è¯†ç¬¦â€œFooâ€çš„å¤´åƒã€‚
- en: The avatar has 24 segments and consists of 24 [`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement)
    tags. The coordinates describing paths are static, but their colors are generated
    from [SHA-256](https://en.wikipedia.org/wiki/SHA-2) of the identifier.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: å¤´åƒæœ‰24ä¸ªéƒ¨åˆ†ï¼Œç”±24ä¸ª[`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement)æ ‡ç­¾ç»„æˆã€‚æè¿°è·¯å¾„çš„åæ ‡æ˜¯é™æ€çš„ï¼Œä½†å®ƒä»¬çš„é¢œè‰²æ˜¯æ ¹æ®æ ‡è¯†ç¬¦çš„[SHA-256](https://en.wikipedia.org/wiki/SHA-2)ç”Ÿæˆçš„ã€‚
- en: '[PRE0]'
  id: totrans-split-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The rest of this blog post focuses on translating the byte array into an avatar
    that looks *nice*.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬åšæ–‡çš„å…¶ä½™éƒ¨åˆ†ä¾§é‡äºå°†å­—èŠ‚æ•°ç»„ç¿»è¯‘æˆä¸€ä¸ªçœ‹èµ·æ¥*ä¸é”™*çš„å¤´åƒã€‚
- en: '[#](#svg-scaffolding) SVG scaffolding'
  id: totrans-split-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[#](#svg-scaffolding) SVGç»“æ„'
- en: Letâ€™s think how to prepare the SVGâ€™s structure. We know that each segment must
    be its own [`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement) element,
    so we can color them individually with the [fill](https://www.w3.org/TR/SVG2/painting.html#SpecifyingFillPaint)
    property. Generating annuluses sectors can be challenging â€” it would require using
    two(!) [arcs](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands),
    which is way too much â€” instead, we can cheat a little and create overlapping
    circle sectors. It will make paths simpler and requires only one(!) arc.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è€ƒè™‘å¦‚ä½•å‡†å¤‡SVGçš„ç»“æ„ã€‚æˆ‘ä»¬çŸ¥é“æ¯ä¸ªéƒ¨åˆ†å¿…é¡»æ˜¯è‡ªå·±çš„[`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement)å…ƒç´ ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨[fill](https://www.w3.org/TR/SVG2/painting.html#SpecifyingFillPaint)å±æ€§åˆ†åˆ«å¯¹å®ƒä»¬ä¸Šè‰²ã€‚ç”Ÿæˆç¯å½¢æ‰‡åŒºå¯èƒ½å…·æœ‰æŒ‘æˆ˜æ€§
    â€”â€” è¿™éœ€è¦ä½¿ç”¨ä¸¤ä¸ª(!)[arcs](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands)ï¼Œè¿™å®åœ¨å¤ªå¤šäº†
    â€”â€” ç›¸åï¼Œæˆ‘ä»¬å¯ä»¥ç¨å¾®ä½œå¼Šï¼Œåˆ›å»ºé‡å çš„åœ†å½¢æ‰‡åŒºã€‚è¿™å°†ä½¿è·¯å¾„æ›´ç®€å•ï¼Œåªéœ€è¦ä¸€ä¸ª(!)arcã€‚
- en: 'Starting with the `<svg>` tag we get:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: ä»`<svg>`æ ‡ç­¾å¼€å§‹ï¼š
- en: '[PRE1]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Paths generation gets much easier if the center of â€œcirclesâ€ is in $(0, 0)$.
    We can do that by setting the `viewBox` property as shown above: top-left corner
    is $(-1, -1)$, width is $2$, and height is $2$.'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœâ€œåœ†åœˆâ€çš„ä¸­å¿ƒä½äº$(0, 0)$ï¼Œåˆ™è·¯å¾„ç”Ÿæˆä¼šå˜å¾—æ›´åŠ å®¹æ˜“ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½®`viewBox`å±æ€§æ¥å®ç°ï¼šå·¦ä¸Šè§’ä¸º$(-1, -1)$ï¼Œå®½åº¦ä¸º$2$ï¼Œé«˜åº¦ä¸º$2$ï¼Œå¦‚ä¸Šæ‰€ç¤ºã€‚
- en: OK. Now we need to create circle sectors. SVG has some tags for constructing
    [basic shapes](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Basic_Shapes)
    (like circles, rectangles, or ellipses). Sadly, pizza slices are *not* considered
    as â€œbasicâ€, so thereâ€™s no `<pizza-slice>` to help us here. Instead, we need to
    use the [`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement) tag.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½äº†ã€‚ç°åœ¨æˆ‘ä»¬éœ€è¦åˆ›å»ºåœ†å½¢æ‰‡åŒºã€‚SVGæœ‰ä¸€äº›ç”¨äºæ„å»º[åŸºæœ¬å½¢çŠ¶](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Basic_Shapes)ï¼ˆå¦‚åœ†åœˆã€çŸ©å½¢æˆ–æ¤­åœ†ï¼‰çš„æ ‡ç­¾ã€‚å¯æƒœçš„æ˜¯ï¼ŒæŠ«è¨ç‰‡å¹¶ä¸è¢«è®¤ä¸ºæ˜¯â€œåŸºæœ¬â€çš„ï¼Œæ‰€ä»¥è¿™é‡Œæ²¡æœ‰`<pizza-slice>`æ¥å¸®åŠ©æˆ‘ä»¬ã€‚ç›¸åï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨[`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement)æ ‡ç­¾ã€‚
- en: '[#](#making-pizza-slices-pizza) Making pizza slices ğŸ•'
  id: totrans-split-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[#](#making-pizza-slices-pizza) åˆ¶ä½œæŠ«è¨ç‰‡ ğŸ•'
- en: 'The [`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement) tag is nice,
    because it allows you to construct any complex shape. For it to work we need to
    describe how we want our shape to look like with its special [path data](https://www.w3.org/TR/SVG2/paths.html#PathData)
    syntax. Itâ€™s fairly complex, but we only need to grasp 4 of its commands:'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`<path>` æ ‡ç­¾å¾ˆå¥½ï¼Œå› ä¸ºå®ƒå…è®¸æ‚¨æ„å»ºä»»ä½•å¤æ‚çš„å½¢çŠ¶ã€‚è¦ä½¿å…¶å·¥ä½œï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨å…¶ç‰¹æ®Šçš„ [è·¯å¾„æ•°æ®](https://www.w3.org/TR/SVG2/paths.html#PathData)
    è¯­æ³•æ¥æè¿°æˆ‘ä»¬å¸Œæœ›å½¢çŠ¶çœ‹èµ·æ¥çš„æ–¹å¼ã€‚å®ƒéå¸¸å¤æ‚ï¼Œä½†æˆ‘ä»¬åªéœ€è¦æŒæ¡å…¶ 4 ä¸ªå‘½ä»¤ï¼š'
- en: the [absolute **â€œmovetoâ€**](https://www.w3.org/TR/SVG2/paths.html#PathDataMovetoCommands)
    command â€” which establishes a new initial point,
  id: totrans-split-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ç»å¯¹ **â€œmovetoâ€**](https://www.w3.org/TR/SVG2/paths.html#PathDataMovetoCommands)
    æŒ‡ä»¤ â€” ç”¨äºè®¾å®šæ–°çš„èµ·å§‹ç‚¹ï¼Œ'
- en: the [absolute **â€œlinetoâ€**](https://www.w3.org/TR/SVG2/paths.html#PathDataLinetoCommands)
    command â€” which draws a line from the current point to the given $(x, y)$,
  id: totrans-split-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ç»å¯¹ **â€œlinetoâ€**](https://www.w3.org/TR/SVG2/paths.html#PathDataLinetoCommands)
    æŒ‡ä»¤ â€” ç”¨äºä»å½“å‰ç‚¹ç”»ä¸€æ¡åˆ°ç»™å®š $(x, y)$ çš„ç›´çº¿ï¼Œ'
- en: the [absolute elliptical arc curve](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands)
    command â€” which draws an elliptical arc from the current point to the given $(x,
    y)$,
  id: totrans-split-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ç»å¯¹æ¤­åœ†å¼§æ›²çº¿](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands)
    æŒ‡ä»¤ â€” ç”¨äºä»å½“å‰ç‚¹ç”»ä¸€æ¡åˆ°ç»™å®š $(x, y)$ çš„æ¤­åœ†å¼§ï¼Œ'
- en: the [**â€œclosepathâ€**](https://www.w3.org/TR/SVG2/paths.html#PathDataClosePathCommand)
    command â€” which ends the current path by connecting it back to its initial point.
  id: totrans-split-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**â€œclosepathâ€**](https://www.w3.org/TR/SVG2/paths.html#PathDataClosePathCommand)
    æŒ‡ä»¤ â€” ç”¨äºé€šè¿‡å°†å½“å‰è·¯å¾„è¿æ¥å›å…¶èµ·å§‹ç‚¹æ¥ç»“æŸå½“å‰è·¯å¾„ã€‚'
- en: 'To start easy, letâ€™s consider an example with 4 pizza slices:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç®€å•èµ·è§ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªæœ‰ 4 ä¸ªæŠ«è¨å—çš„ä¾‹å­ï¼š
- en: '[PRE2]'
  id: totrans-split-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It renders to:'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒå‘ˆç°ä¸ºï¼š
- en: $ r_1 = 1 $
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: $ r_1 = 1 $
- en: '*Note*'
  id: totrans-split-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '*æ³¨æ„*'
- en: '*I added `overflow="visible"` to the SVG tag, because â€” with a non-zero stroke
    â€” the image is *slightly* bigger than its `viewBox` and the stroke lines get cut
    off at $(-1, 0)$, $(1, 0)$, $(0, 1)$, and $(-1, 0)$.*'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*æˆ‘åœ¨ SVG æ ‡ç­¾ä¸­æ·»åŠ äº† `overflow="visible"`ï¼Œå› ä¸ºå¸¦æœ‰éé›¶æè¾¹çš„å›¾åƒ*ç•¥å¤§*äºå…¶ `viewBox`ï¼Œå¹¶ä¸”æè¾¹åœ¨ $(-1,
    0)$ï¼Œ$(1, 0)$ï¼Œ$(0, 1)$ å’Œ $(-1, 0)$ å¤„è¢«æˆªæ–­ã€‚*'
- en: '*We can see an interesting patter here: coordinates of the [**â€œlinetoâ€**](https://www.w3.org/TR/SVG2/paths.html#PathDataLinetoCommands)
    command are the same, as the coordinates of the [elliptical arc curve](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands)
    command of the *previous* element.*'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™é‡Œæœ‰ä¸€ä¸ªæœ‰è¶£çš„æ¨¡å¼ï¼š[**â€œlinetoâ€**](https://www.w3.org/TR/SVG2/paths.html#PathDataLinetoCommands)
    æŒ‡ä»¤çš„åæ ‡ä¸*å‰ä¸€ä¸ª*å…ƒç´ çš„ [æ¤­åœ†å¼§æ›²çº¿](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands)
    æŒ‡ä»¤çš„åæ ‡ç›¸åŒã€‚*'
- en: '**Ok, but how to divide these slices into halves?* â€” you may ask.*'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¥½çš„ï¼Œä½†æ˜¯å¦‚ä½•å°†è¿™äº›å—åˆ’åˆ†æˆä¸¤åŠå‘¢ï¼Ÿ* â€” ä½ å¯èƒ½ä¼šé—®ã€‚*'
- en: '*To do that we need to find the points in the middle of the arcs.*'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°å¼§çº¿ä¸­ç‚¹çš„ç‚¹ã€‚*'
- en: '*<svg xmlns="http://www.w3.org/2000/svg" id="slices-with-points" overflow="visible"
    viewBox="-1 -1 2 2"><text x=".70710678118" y="-.70710678118" text-anchor="start"
    dominant-baseline="text-top">(ax, ay)</text><text x=".70710678118" y=".70710678118"
    text-anchor="start" dominant-baseline="hanging">(bx, by)</text><text x="-.70710678118"
    y="-.70710678118" text-anchor="end" dominant-baseline="text-top">(cx, cy)</text><text
    x="-.70710678118" y=".70710678118" text-anchor="end" dominant-baseline="hanging">(dx,
    dy)</text></svg>*'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*<svg xmlns="http://www.w3.org/2000/svg" id="slices-with-points" overflow="visible"
    viewBox="-1 -1 2 2"><text x=".70710678118" y="-.70710678118" text-anchor="start"
    dominant-baseline="text-top">(ax, ay)</text><text x=".70710678118" y=".70710678118"
    text-anchor="start" dominant-baseline="hanging">(bx, by)</text><text x="-.70710678118"
    y="-.70710678118" text-anchor="end" dominant-baseline="text-top">(cx, cy)</text><text
    x="-.70710678118" y=".70710678118" text-anchor="end" dominant-baseline="hanging">(dx,
    dy)</text></svg>*'
- en: '*$ r_1 = 1 $*'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*$ r_1 = 1 $*'
- en: '*Fortunately â€” since the circleâ€™s middle point is $(0, 0)$ and the arc points
    are in the middle of their arcs â€” we know that the absolute value of their coordinates
    is the same. So, our diagram simplifies to:*'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*å¹¸è¿çš„æ˜¯ â€” ç”±äºåœ†çš„ä¸­å¿ƒç‚¹æ˜¯ $(0, 0)$ï¼Œå¼§çº¿ç‚¹ä½äºå…¶å¼§çº¿ä¸­ç‚¹ â€” æˆ‘ä»¬çŸ¥é“å®ƒä»¬çš„åæ ‡çš„ç»å¯¹å€¼æ˜¯ç›¸åŒçš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„å›¾è¡¨ç®€åŒ–ä¸ºï¼š*'
- en: '*<svg xmlns="http://www.w3.org/2000/svg" id="slices-with-same-points" overflow="visible"
    viewBox="-1 -1 2 2"><text x=".70710678118" y="-.70710678118" text-anchor="start"
    dominant-baseline="text-top">(a, -a)</text><text x=".70710678118" y=".70710678118"
    text-anchor="start" dominant-baseline="hanging">(a, a)</text><text x="-.70710678118"
    y="-.70710678118" text-anchor="end" dominant-baseline="text-top">(-a, -a)</text><text
    x="-.70710678118" y=".70710678118" text-anchor="end" dominant-baseline="hanging">(-a,
    a)</text></svg>*'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*<svg xmlns="http://www.w3.org/2000/svg" id="slices-with-same-points" overflow="visible"
    viewBox="-1 -1 2 2"><text x=".70710678118" y="-.70710678118" text-anchor="start"
    dominant-baseline="text-top">(a, -a)</text><text x=".70710678118" y=".70710678118"
    text-anchor="start" dominant-baseline="hanging">(a, a)</text><text x="-.70710678118"
    y="-.70710678118" text-anchor="end" dominant-baseline="text-top">(-a, -a)</text><text
    x="-.70710678118" y=".70710678118" text-anchor="end" dominant-baseline="hanging">(-a,
    a)</text></svg>*'
- en: '*$ r_1 = 1 $*'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*$ r_1 = 1 $*'
- en: '*Great. ğŸ‘Œ*'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*å¤ªå¥½äº†ã€‚ ğŸ‘Œ*'
- en: '*Now we can use the equation of a circle to find the middle points.*'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*ç°åœ¨æˆ‘ä»¬å¯ä»¥ä½¿ç”¨åœ†çš„æ–¹ç¨‹æ‰¾åˆ°ä¸­é—´ç‚¹ã€‚*'
- en: '*$ \begin{aligned} (x - x_0)^2 + (y - y_0)^2 &= r^2 \\[0.25em] (a - 0)^2 +
    (a - 0)^2 &= 1^2 \\[0.25em] 2a^2 &= 1 \\[0.25em] a^2 &= \frac{1}{2} \\[0.25em]
    a &= \sqrt{\frac{1}{2}} \end{aligned} $*'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*$ \begin{aligned} (x - x_0)^2 + (y - y_0)^2 &= r^2 \\[0.25em] (a - 0)^2 +
    (a - 0)^2 &= 1^2 \\[0.25em] 2a^2 &= 1 \\[0.25em] a^2 &= \frac{1}{2} \\[0.25em]
    a &= \sqrt{\frac{1}{2}} \end{aligned} $*'
- en: '*By adding four more pizza slices we get:*'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*å†åŠ å››ç‰‡æŠ«è¨æˆ‘ä»¬å¾—åˆ°ï¼š*'
- en: '*$ r_1 = 1 $*'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*$ r_1 = 1 $*'
- en: '*[#](#layers-of-pizza) Layers of pizza*'
  id: totrans-split-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*[#](#layers-of-pizza) æŠ«è¨çš„å±‚æ¬¡*'
- en: '*The next step is to create additional (smaller) layers of circle sectors.
    Letâ€™s say we want three circles; thereâ€™re two obvious ways of selecting division
    points: equal radii, or equal areas. Equal radii is simpler, so letâ€™s try this
    one first.*'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä¸‹ä¸€æ­¥æ˜¯åˆ›å»ºé¢å¤–ï¼ˆæ›´å°ï¼‰çš„åœ†æ‰‡å½¢å±‚ã€‚å‡è®¾æˆ‘ä»¬æƒ³è¦ä¸‰ä¸ªåœ†ï¼›é€‰æ‹©åˆ†å‰²ç‚¹æœ‰ä¸¤ç§æ˜æ˜¾çš„æ–¹æ³•ï¼šç­‰åŠå¾„æˆ–ç­‰é¢ç§¯ã€‚ç­‰åŠå¾„æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥æˆ‘ä»¬å…ˆè¯•è¯•è¿™ä¸ªã€‚*'
- en: '*If the outermost circle has a radius of $1$, then the middle circle will have
    a radius of $0.\overline{6}$, and the smallest one will have $0.\overline{3}$.*'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*å¦‚æœæœ€å¤–é¢çš„åœ†åŠå¾„ä¸º$1$ï¼Œé‚£ä¹ˆä¸­é—´çš„åœ†å°†ä¸º$0.\overline{6}$ï¼Œæœ€å°çš„å°†ä¸º$0.\overline{3}$ã€‚*'
- en: '*$ r_1 = 1 \quad\text{and}\quad r_2 = 0.\overline{6} \quad\text{and}\quad r_3
    = 0.\overline{3} $*'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*$ r_1 = 1 \quad\text{å’Œ}\quad r_2 = 0.\overline{6} \quad\text{å’Œ}\quad r_3 =
    0.\overline{3} $*'
- en: '*Not that it matters, but the smallest circle is a little *too* small for my
    liking. But, before we decide, we need to see circles with equal areas first.*'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*è™½ç„¶è¿™å¹¶ä¸é‡è¦ï¼Œä½†æˆ‘ä¸å¤ªå–œæ¬¢æœ€å°çš„åœ†å¤ªå°äº†ã€‚ä½†åœ¨å†³å®šä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆçœ‹çœ‹ç­‰é¢ç§¯çš„åœ†ã€‚*'
- en: '*$ \begin{aligned} \Pi r_1^2 - \Pi r_2^2 = \Pi r_2^2 - \Pi r_3^2 \quad&\text{and}\quad
    \Pi r_2^2 - \Pi r_3^2 = \Pi r_3^2 \\[0.25em] 1 - r_2^2 = r_2^2 - r_3^2 \quad&\text{and}\quad
    r_2^2 - r_3^2 = r_3^2 \\[0.25em] 1 = 2r_2^2 - r_3^2 \quad&\text{and}\quad r_2^2
    = 2r_3^2 \\[0.25em] 1 = 3r_3^2 \quad&\text{and}\quad r_2^2 = 2r_3^2 \\[0.25em]
    r_3 = \sqrt{\frac{1}{3}} \quad&\text{and}\quad r_2 = \sqrt{\frac{2}{3}} \end{aligned}
    $*'
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*$ \begin{aligned} \Pi r_1^2 - \Pi r_2^2 = \Pi r_2^2 - \Pi r_3^2 \quad&\text{å’Œ}\quad
    \Pi r_2^2 - \Pi r_3^2 = \Pi r_3^2 \\[0.25em] 1 - r_2^2 = r_2^2 - r_3^2 \quad&\text{å’Œ}\quad
    r_2^2 - r_3^2 = r_3^2 \\[0.25em] 1 = 2r_2^2 - r_3^2 \quad&\text{å’Œ}\quad r_2^2
    = 2r_3^2 \\[0.25em] 1 = 3r_3^2 \quad&\text{å’Œ}\quad r_2^2 = 2r_3^2 \\[0.25em] r_3
    = \sqrt{\frac{1}{3}} \quad&\text{å’Œ}\quad r_2 = \sqrt{\frac{2}{3}} \end{aligned}
    $*'
- en: '*Which gives us this avatar:*'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*è¿™ç»™äº†æˆ‘ä»¬è¿™ä¸ªå¤´åƒï¼š*'
- en: '*$ r_1 = 1 \quad\text{and}\quad r_2 = \sqrt{\frac{2}{3}} \quad\text{and}\quad
    r_3 = \sqrt{\frac{1}{3}} $*'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*$ r_1 = 1 \quad\text{å’Œ}\quad r_2 = \sqrt{\frac{2}{3}} \quad\text{å’Œ}\quad r_3
    = \sqrt{\frac{1}{3}} $*'
- en: '*Which is also not ideal, but the other way around&mldr; I was tinkering with
    the radii a bit and I think I found a [middle ground](https://en.wikipedia.org/wiki/Arithmetic_mean)
    with which Iâ€™m happy.*'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*è¿™ä¹Ÿä¸ç†æƒ³ï¼Œä½†åè¿‡æ¥è¯´&mldr; æˆ‘ç¨å¾®è°ƒæ•´äº†åŠå¾„ï¼Œæˆ‘è§‰å¾—æˆ‘æ‰¾åˆ°äº†ä¸€ä¸ª[æŠ˜è¡·æ–¹æ¡ˆ](https://en.wikipedia.org/wiki/Arithmetic_mean)ï¼Œæˆ‘æ„Ÿåˆ°å¾ˆæ»¡æ„ã€‚*'
- en: '*$ r_1 = 1 \quad\text{and}\quad r_2 = \frac{0.\overline{6} + \sqrt{\frac{2}{3}}}{2}
    \quad\text{and}\quad r_3 = \frac{0.\overline{3} + \sqrt{\frac{1}{3}}}{2} $*'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*$ r_1 = 1 \quad\text{å’Œ}\quad r_2 = \frac{0.\overline{6} + \sqrt{\frac{2}{3}}}{2}
    \quad\text{å’Œ}\quad r_3 = \frac{0.\overline{3} + \sqrt{\frac{1}{3}}}{2} $*'
- en: '*Radii in the circles above are the arithmetic average of the equal radii variant
    and the equal areas variant.*'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä»¥ä¸Šåœ†ä¸­çš„åŠå¾„æ˜¯ç­‰åŠå¾„å˜ä½“å’Œç­‰é¢ç§¯å˜ä½“çš„ç®—æœ¯å¹³å‡å€¼ã€‚*'
- en: '*[#](#working-with-colors) Working with colors*'
  id: totrans-split-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*[#](#working-with-colors) ä½¿ç”¨é¢œè‰²*'
- en: '*With the SVG structure out of the way we can focus on selecting quasi-random
    colors for the circle segments based on the identifierâ€™s hash. [SHA-256](https://en.wikipedia.org/wiki/SHA-2)
    hashes have 32 bytes; itâ€™s more than we need â€” assuming we need a single byte
    per circle sector â€” which gives us another benefit: we can slide in the 4^(th)
    circle, if we want to.*'
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*å®ŒæˆSVGç»“æ„åï¼Œæˆ‘ä»¬å¯ä»¥ä¸“æ³¨äºæ ¹æ®æ ‡è¯†ç¬¦çš„å“ˆå¸Œé€‰æ‹©å‡†éšæœºé¢œè‰²æ¥å¡«å……åœ†å½¢æ®µã€‚[SHA-256](https://zh.wikipedia.org/wiki/SHA-2)å“ˆå¸Œæœ‰32å­—èŠ‚ï¼›è¿™æ¯”æˆ‘ä»¬éœ€è¦çš„å¤š
    â€”â€” å‡è®¾æˆ‘ä»¬éœ€è¦æ¯ä¸ªåœ†å½¢æ‰‡åŒºä¸€ä¸ªå­—èŠ‚ â€”â€” è¿™ç»™æˆ‘ä»¬å¸¦æ¥å¦ä¸€ä¸ªå¥½å¤„ï¼šå¦‚æœéœ€è¦ï¼Œæˆ‘ä»¬å¯ä»¥æ’å…¥ç¬¬4ä¸ªåœ†ã€‚*'
- en: '*For now though, letâ€™s talk about the colors. If weâ€™d use [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV),
    we can split each byte into 4 pieces: 4 bits for hue (since itâ€™s the most dominant),
    2 bits for saturation, and 2 bits for lightness. Pathâ€™s [fill](https://www.w3.org/TR/SVG2/painting.html#SpecifyingFillPaint)
    property accepts any [paint](https://www.w3.org/TR/SVG2/painting.html#SpecifyingPaint)
    value, which basically means we need to format our color to a standard CSSâ€™s hue.*'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä¸è¿‡ï¼Œç°åœ¨è®©æˆ‘ä»¬æ¥è°ˆè°ˆé¢œè‰²ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨[HSL](https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV)æ¨¡å‹ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ¯ä¸ªå­—èŠ‚åˆ†æˆ4ä¸ªéƒ¨åˆ†ï¼š4ä½ç”¨äºè‰²è°ƒï¼ˆå› ä¸ºå®ƒæ˜¯æœ€æ˜¾è‘—çš„ï¼‰ï¼Œ2ä½ç”¨äºé¥±å’Œåº¦ï¼Œ2ä½ç”¨äºäº®åº¦ã€‚è·¯å¾„çš„[fill](https://www.w3.org/TR/SVG2/painting.html#SpecifyingFillPaint)å±æ€§æ¥å—ä»»ä½•[paint](https://www.w3.org/TR/SVG2/painting.html#SpecifyingPaint)å€¼ï¼Œè¿™åŸºæœ¬ä¸Šæ„å‘³ç€æˆ‘ä»¬éœ€è¦å°†æˆ‘ä»¬çš„é¢œè‰²æ ¼å¼åŒ–ä¸ºæ ‡å‡†CSSçš„è‰²è°ƒã€‚*'
- en: '[PRE3]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Alright, letâ€™s generate an avatar for `"foo"` and see how it looks like.*'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*å¥½äº†ï¼Œè®©æˆ‘ä»¬ä¸º`"foo"`ç”Ÿæˆä¸€ä¸ªå¤´åƒï¼Œçœ‹çœ‹å®ƒæ˜¯ä»€ä¹ˆæ ·å­ã€‚*'
- en: '*Avatar for "foo".*'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*"foo"çš„å¤´åƒã€‚*'
- en: '*Well, it does not look terrible, but itâ€™s not eye-catching either. To be perfectly
    honest, we should expect something like this; [SHA-256](https://en.wikipedia.org/wiki/SHA-2)
    returns (and for that matter all other hash functions too) a quasi-random values.
    If we convert those *raw* bytes to fill colors, weâ€™ll get quasi-random colors.
    To make it nicer we need to modify our algorithm slightly; we need to calculate
    a global theme, if you will, for the avatar, so that a part of circle segments''
    colors come from that theme. We can do that by folding all hash bytes into a single
    one with XOR.*'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*å—¯ï¼Œå®ƒçœ‹èµ·æ¥å¹¶ä¸å¯æ€•ï¼Œä½†ä¹Ÿä¸å¤ªå¸å¼•äººã€‚è¯´å®è¯ï¼Œæˆ‘ä»¬åº”è¯¥é¢„æ–™åˆ°è¿™æ ·çš„ç»“æœï¼›[SHA-256](https://zh.wikipedia.org/wiki/SHA-2)è¿”å›ï¼ˆä»¥åŠå…¶ä»–æ‰€æœ‰å“ˆå¸Œå‡½æ•°ï¼‰å‡†éšæœºå€¼ã€‚å¦‚æœæˆ‘ä»¬å°†è¿™äº›*åŸå§‹*å­—èŠ‚è½¬æ¢ä¸ºå¡«å……é¢œè‰²ï¼Œæˆ‘ä»¬å°†å¾—åˆ°å‡†éšæœºçš„é¢œè‰²ã€‚ä¸ºäº†ä½¿å®ƒæ›´å¥½çœ‹ï¼Œæˆ‘ä»¬éœ€è¦ç¨å¾®ä¿®æ”¹æˆ‘ä»¬çš„ç®—æ³•ï¼›æˆ‘ä»¬éœ€è¦è®¡ç®—ä¸€ä¸ªå…¨å±€ä¸»é¢˜ï¼Œå¦‚æœå¯ä»¥çš„è¯ï¼Œä¸ºå¤´åƒçš„éƒ¨åˆ†åœ†ç¯é¢œè‰²ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†æ‰€æœ‰å“ˆå¸Œå­—èŠ‚æŠ˜å æˆä¸€ä¸ªå•ä¸€å­—èŠ‚æ¥å®ç°è¿™ä¸€ç‚¹ã€‚*'
- en: '[PRE4]'
  id: totrans-split-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*This code renders:*'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*è¿™æ®µä»£ç æ¸²æŸ“å¦‚ä¸‹ï¼š*'
- en: '*Avatar for "foo" with a theme.*'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*"foo"çš„å¸¦æœ‰ä¸»é¢˜çš„å¤´åƒã€‚*'
- en: '*It looks rather good, if I say so myself. The solution works as itâ€™s suppose
    to: it *most probably* produces different avatars for different identifiers ([hash
    collisions](https://en.wikipedia.org/wiki/Hash_collision) do happen) and they
    look acceptable. However, the rings seem to *phase* into each other â€” their colors
    are too similar. We could experiment with another theme: a ring theme â€” which
    would be a XOR-fold of all bytes that represent a single ring â€” and check the
    results.*'
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*æˆ‘è§‰å¾—å®ƒçœ‹èµ·æ¥ç›¸å½“ä¸é”™ã€‚è¿™ä¸ªè§£å†³æ–¹æ¡ˆæŒ‰ç…§é¢„æœŸè¿è¡Œï¼šå®ƒ*å¾ˆå¯èƒ½*ä¸ºä¸åŒçš„æ ‡è¯†ç¬¦ç”Ÿæˆä¸åŒçš„å¤´åƒï¼ˆ[å“ˆå¸Œç¢°æ’](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E)ç¡®å®ä¼šå‘ç”Ÿï¼‰ï¼Œå®ƒä»¬çœ‹èµ·æ¥æ˜¯å¯ä»¥æ¥å—çš„ã€‚ç„¶è€Œï¼Œè¿™äº›ç¯ä¼¼ä¹*ç›¸ä½*è¿›å…¥å½¼æ­¤
    â€”â€” å®ƒä»¬çš„é¢œè‰²å¤ªç›¸ä¼¼äº†ã€‚æˆ‘ä»¬å¯ä»¥å°è¯•å¦ä¸€ä¸ªä¸»é¢˜ï¼šä¸€ä¸ªç¯ä¸»é¢˜ â€”â€” å®ƒå°†æ˜¯ä»£è¡¨å•ä¸ªç¯çš„æ‰€æœ‰å­—èŠ‚çš„XORæŠ˜å  â€”â€” å¹¶æ£€æŸ¥ç»“æœã€‚*'
- en: '[PRE5]'
  id: totrans-split-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*With the final touch we get:*'
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*åŠ ä¸Šæœ€åçš„ä¿®é¥°ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š*'
- en: '*Avatar for "foo" with a global theme and a ring theme.*'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*"foo"çš„å…¨å±€ä¸»é¢˜å’Œç¯ä¸»é¢˜å¤´åƒã€‚*'
- en: '*Which is exactly the thing that hides in the spoiler block at the top. If
    you restrained yourself and didnâ€™t check it out: congratulations. Now feel free
    to do so. ğŸ˜ƒ*'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*è¿™æ­£æ˜¯éšè—åœ¨é¡¶éƒ¨å‰§é€å—ä¸­çš„ä¸œè¥¿ã€‚å¦‚æœä½ å…‹åˆ¶ä½äº†è‡ªå·±æ²¡æœ‰å»æŸ¥çœ‹ï¼šæ­å–œä½ ã€‚ç°åœ¨å¯ä»¥éšæ„æŸ¥çœ‹äº†ã€‚ ğŸ˜ƒ*'
- en: '*[#](#conclusions) Conclusions*'
  id: totrans-split-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*[#](#conclusions) ç»“è®º*'
- en: '*Working on this blog post has been an effort I wanted to make to better understand
    how SVGs work from the inside, as well as, a challenge to reverse-engineer ideas
    from [Representing SHA-256 Hashes As Avatars](https://francoisbest.com/posts/2021/hashvatars).*'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ’°å†™è¿™ç¯‡åšæ–‡æ˜¯æˆ‘åŠªåŠ›æƒ³è¦æ›´å¥½åœ°ç†è§£SVGå†…éƒ¨å·¥ä½œåŸç†çš„åŠªåŠ›ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªä»[Representing SHA-256 Hashes As Avatars](https://francoisbest.com/posts/2021/hashvatars)ä¸­é€†å‘å·¥ç¨‹æ€æƒ³çš„æŒ‘æˆ˜ã€‚*'
- en: '*Iâ€™m not working on any service which would benefit from these avatars. If
    I happen to work on one in the future Iâ€™ll for sure like to try them out. To make
    this solution easier to re-use in other places, Iâ€™ve made a Rust crate called
    [`svg_avatars`](https://crates.io/crates/svg_avatars), which implements this exact
    solution. The crate is fairly minimal, so if anyone has any idea on how to enhance
    it, Iâ€™d love to hear from you/check out your PRs.*'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*æˆ‘ç›®å‰æ²¡æœ‰ä¸ºä»»ä½•å—ç›Šäºè¿™äº›å¤´åƒçš„æœåŠ¡å·¥ä½œã€‚å¦‚æœå°†æ¥æˆ‘åšäº†ä¸€ä¸ªè¿™æ ·çš„æœåŠ¡ï¼Œæˆ‘è‚¯å®šä¼šè¯•è¯•å®ƒä»¬ã€‚ä¸ºäº†è®©è¿™ä¸ªè§£å†³æ–¹æ¡ˆæ›´å®¹æ˜“åœ¨å…¶ä»–åœ°æ–¹é‡ç”¨ï¼Œæˆ‘åšäº†ä¸€ä¸ªåä¸º[`svg_avatars`](https://crates.io/crates/svg_avatars)çš„
    Rust åŒ…ï¼Œå®ƒå®ç°äº†è¿™ä¸ªç¡®åˆ‡çš„è§£å†³æ–¹æ¡ˆã€‚è¿™ä¸ªåŒ…éå¸¸ç®€æ´ï¼Œå¦‚æœæœ‰äººæœ‰ä»»ä½•æå‡å®ƒçš„æƒ³æ³•ï¼Œæˆ‘ä¼šå¾ˆä¹æ„å¬å–æ‚¨çš„æ„è§æˆ–æŸ¥çœ‹æ‚¨çš„ PRã€‚*'
- en: '*As a closing thought, one of the parameters of the [absolute elliptical arc
    curve](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands) command
    is the `sweep-flag` parameter. It allows you to determine, whether an arc should
    be a smiley face or a sad face. If the parameter is `1` â€” as it is in our case
    â€” then the arc is a sad face. However, if youâ€™d flip the flags to be `0`, then
    all arcs become smiley faces&mldr;*'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä½œä¸ºç»“æŸæ€è€ƒï¼Œ[ç»å¯¹æ¤­åœ†å¼§æ›²çº¿](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands)å‘½ä»¤çš„ä¸€ä¸ªå‚æ•°æ˜¯
    `sweep-flag` å‚æ•°ã€‚å®ƒå…è®¸æ‚¨ç¡®å®šå¼§æ˜¯ç¬‘è„¸è¿˜æ˜¯å“­è„¸ã€‚å¦‚æœå‚æ•°æ˜¯ `1` â€” å°±åƒæˆ‘ä»¬çš„æƒ…å†µä¸€æ · â€” é‚£ä¹ˆå¼§æ˜¯å“­è„¸ã€‚ç„¶è€Œï¼Œå¦‚æœæ‚¨å°†æ ‡å¿—ç¿»è½¬ä¸º `0`ï¼Œé‚£ä¹ˆæ‰€æœ‰çš„å¼§éƒ½ä¼šæˆä¸ºç¬‘è„¸&mldr;*'
- en: '**Smiley-face* avatar for "foo".*'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Smiley-face* å¤´åƒç”¨äº "foo"ã€‚*'
- en: '*&mldr;and the avatar [emerges](https://en.wikipedia.org/wiki/Emergence) as
    a spiderweb. Who does not love a single-line-change feature for Spooktober.*'
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*&mldr;å¹¶ä¸”å¤´åƒ[å‡ºç°](https://en.wikipedia.org/wiki/Emergence)ä¸ºä¸€ä¸ªèœ˜è››ç½‘ã€‚è°ä¸å–œæ¬¢ Spooktober
    çš„å•è¡Œæ›´æ”¹åŠŸèƒ½ã€‚*'
- en: </main>
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
