- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 13:23:02'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Generating SVG Avatars From Identifiers - MadeByMe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://madebyme.today/projects/generating-svg-avatars-from-identifiers/](https://madebyme.today/projects/generating-svg-avatars-from-identifiers/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <main class="main">
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new social service on the internet, one of the things you
    need to think about is how to make a user‚Äôs space feel like their own. Services
    like [GitHub](https://github.blog/2013-08-14-identicons/), Roll20, or [Reddit](https://www.reddit.com/r/reddit/comments/vtkmni/introducing_collectible_avatars/)
    generate ‚Äî or allow you to generate ‚Äî a custom avatar (i.e. [Identicons](https://en.wikipedia.org/wiki/Identicon))
    for your account. Avatar auto-generation is especially neat, as it does not require
    any engagement from the user. Let‚Äôs try to figure that out on our own.
  prefs: []
  type: TYPE_NORMAL
- en: I think this blog post is one of those things which are easier to understand
    if you‚Äôd see the end result first. So, for those interested here‚Äôs a spoiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the end result:'
  prefs: []
  type: TYPE_NORMAL
- en: Avatar for identifier "Foo".
  prefs: []
  type: TYPE_NORMAL
- en: The avatar has 24 segments and consists of 24 [`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement)
    tags. The coordinates describing paths are static, but their colors are generated
    from [SHA-256](https://en.wikipedia.org/wiki/SHA-2) of the identifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The rest of this blog post focuses on translating the byte array into an avatar
    that looks *nice*.
  prefs: []
  type: TYPE_NORMAL
- en: '[#](#svg-scaffolding) SVG scaffolding'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let‚Äôs think how to prepare the SVG‚Äôs structure. We know that each segment must
    be its own [`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement) element,
    so we can color them individually with the [fill](https://www.w3.org/TR/SVG2/painting.html#SpecifyingFillPaint)
    property. Generating annuluses sectors can be challenging ‚Äî it would require using
    two(!) [arcs](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands),
    which is way too much ‚Äî instead, we can cheat a little and create overlapping
    circle sectors. It will make paths simpler and requires only one(!) arc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the `<svg>` tag we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Paths generation gets much easier if the center of ‚Äúcircles‚Äù is in $(0, 0)$.
    We can do that by setting the `viewBox` property as shown above: top-left corner
    is $(-1, -1)$, width is $2$, and height is $2$.'
  prefs: []
  type: TYPE_NORMAL
- en: OK. Now we need to create circle sectors. SVG has some tags for constructing
    [basic shapes](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Basic_Shapes)
    (like circles, rectangles, or ellipses). Sadly, pizza slices are *not* considered
    as ‚Äúbasic‚Äù, so there‚Äôs no `<pizza-slice>` to help us here. Instead, we need to
    use the [`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement) tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[#](#making-pizza-slices-pizza) Making pizza slices üçï'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`<path>`](https://www.w3.org/TR/SVG2/paths.html#PathElement) tag is nice,
    because it allows you to construct any complex shape. For it to work we need to
    describe how we want our shape to look like with its special [path data](https://www.w3.org/TR/SVG2/paths.html#PathData)
    syntax. It‚Äôs fairly complex, but we only need to grasp 4 of its commands:'
  prefs: []
  type: TYPE_NORMAL
- en: the [absolute **‚Äúmoveto‚Äù**](https://www.w3.org/TR/SVG2/paths.html#PathDataMovetoCommands)
    command ‚Äî which establishes a new initial point,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the [absolute **‚Äúlineto‚Äù**](https://www.w3.org/TR/SVG2/paths.html#PathDataLinetoCommands)
    command ‚Äî which draws a line from the current point to the given $(x, y)$,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the [absolute elliptical arc curve](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands)
    command ‚Äî which draws an elliptical arc from the current point to the given $(x,
    y)$,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the [**‚Äúclosepath‚Äù**](https://www.w3.org/TR/SVG2/paths.html#PathDataClosePathCommand)
    command ‚Äî which ends the current path by connecting it back to its initial point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start easy, let‚Äôs consider an example with 4 pizza slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It renders to:'
  prefs: []
  type: TYPE_NORMAL
- en: $ r_1 = 1 $
  prefs: []
  type: TYPE_NORMAL
- en: '*Note*'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*I added `overflow="visible"` to the SVG tag, because ‚Äî with a non-zero stroke
    ‚Äî the image is *slightly* bigger than its `viewBox` and the stroke lines get cut
    off at $(-1, 0)$, $(1, 0)$, $(0, 1)$, and $(-1, 0)$.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*We can see an interesting patter here: coordinates of the [**‚Äúlineto‚Äù**](https://www.w3.org/TR/SVG2/paths.html#PathDataLinetoCommands)
    command are the same, as the coordinates of the [elliptical arc curve](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands)
    command of the *previous* element.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ok, but how to divide these slices into halves?* ‚Äî you may ask.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*To do that we need to find the points in the middle of the arcs.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*<svg xmlns="http://www.w3.org/2000/svg" id="slices-with-points" overflow="visible"
    viewBox="-1 -1 2 2"><text x=".70710678118" y="-.70710678118" text-anchor="start"
    dominant-baseline="text-top">(ax, ay)</text><text x=".70710678118" y=".70710678118"
    text-anchor="start" dominant-baseline="hanging">(bx, by)</text><text x="-.70710678118"
    y="-.70710678118" text-anchor="end" dominant-baseline="text-top">(cx, cy)</text><text
    x="-.70710678118" y=".70710678118" text-anchor="end" dominant-baseline="hanging">(dx,
    dy)</text></svg>*'
  prefs: []
  type: TYPE_NORMAL
- en: '*$ r_1 = 1 $*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fortunately ‚Äî since the circle‚Äôs middle point is $(0, 0)$ and the arc points
    are in the middle of their arcs ‚Äî we know that the absolute value of their coordinates
    is the same. So, our diagram simplifies to:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*<svg xmlns="http://www.w3.org/2000/svg" id="slices-with-same-points" overflow="visible"
    viewBox="-1 -1 2 2"><text x=".70710678118" y="-.70710678118" text-anchor="start"
    dominant-baseline="text-top">(a, -a)</text><text x=".70710678118" y=".70710678118"
    text-anchor="start" dominant-baseline="hanging">(a, a)</text><text x="-.70710678118"
    y="-.70710678118" text-anchor="end" dominant-baseline="text-top">(-a, -a)</text><text
    x="-.70710678118" y=".70710678118" text-anchor="end" dominant-baseline="hanging">(-a,
    a)</text></svg>*'
  prefs: []
  type: TYPE_NORMAL
- en: '*$ r_1 = 1 $*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Great. üëå*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Now we can use the equation of a circle to find the middle points.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*$ \begin{aligned} (x - x_0)^2 + (y - y_0)^2 &= r^2 \\[0.25em] (a - 0)^2 +
    (a - 0)^2 &= 1^2 \\[0.25em] 2a^2 &= 1 \\[0.25em] a^2 &= \frac{1}{2} \\[0.25em]
    a &= \sqrt{\frac{1}{2}} \end{aligned} $*'
  prefs: []
  type: TYPE_NORMAL
- en: '*By adding four more pizza slices we get:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*$ r_1 = 1 $*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[#](#layers-of-pizza) Layers of pizza*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The next step is to create additional (smaller) layers of circle sectors.
    Let‚Äôs say we want three circles; there‚Äôre two obvious ways of selecting division
    points: equal radii, or equal areas. Equal radii is simpler, so let‚Äôs try this
    one first.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*If the outermost circle has a radius of $1$, then the middle circle will have
    a radius of $0.\overline{6}$, and the smallest one will have $0.\overline{3}$.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*$ r_1 = 1 \quad\text{and}\quad r_2 = 0.\overline{6} \quad\text{and}\quad r_3
    = 0.\overline{3} $*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Not that it matters, but the smallest circle is a little *too* small for my
    liking. But, before we decide, we need to see circles with equal areas first.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*$ \begin{aligned} \Pi r_1^2 - \Pi r_2^2 = \Pi r_2^2 - \Pi r_3^2 \quad&\text{and}\quad
    \Pi r_2^2 - \Pi r_3^2 = \Pi r_3^2 \\[0.25em] 1 - r_2^2 = r_2^2 - r_3^2 \quad&\text{and}\quad
    r_2^2 - r_3^2 = r_3^2 \\[0.25em] 1 = 2r_2^2 - r_3^2 \quad&\text{and}\quad r_2^2
    = 2r_3^2 \\[0.25em] 1 = 3r_3^2 \quad&\text{and}\quad r_2^2 = 2r_3^2 \\[0.25em]
    r_3 = \sqrt{\frac{1}{3}} \quad&\text{and}\quad r_2 = \sqrt{\frac{2}{3}} \end{aligned}
    $*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Which gives us this avatar:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*$ r_1 = 1 \quad\text{and}\quad r_2 = \sqrt{\frac{2}{3}} \quad\text{and}\quad
    r_3 = \sqrt{\frac{1}{3}} $*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Which is also not ideal, but the other way around&mldr; I was tinkering with
    the radii a bit and I think I found a [middle ground](https://en.wikipedia.org/wiki/Arithmetic_mean)
    with which I‚Äôm happy.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*$ r_1 = 1 \quad\text{and}\quad r_2 = \frac{0.\overline{6} + \sqrt{\frac{2}{3}}}{2}
    \quad\text{and}\quad r_3 = \frac{0.\overline{3} + \sqrt{\frac{1}{3}}}{2} $*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Radii in the circles above are the arithmetic average of the equal radii variant
    and the equal areas variant.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[#](#working-with-colors) Working with colors*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*With the SVG structure out of the way we can focus on selecting quasi-random
    colors for the circle segments based on the identifier‚Äôs hash. [SHA-256](https://en.wikipedia.org/wiki/SHA-2)
    hashes have 32 bytes; it‚Äôs more than we need ‚Äî assuming we need a single byte
    per circle sector ‚Äî which gives us another benefit: we can slide in the 4^(th)
    circle, if we want to.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*For now though, let‚Äôs talk about the colors. If we‚Äôd use [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV),
    we can split each byte into 4 pieces: 4 bits for hue (since it‚Äôs the most dominant),
    2 bits for saturation, and 2 bits for lightness. Path‚Äôs [fill](https://www.w3.org/TR/SVG2/painting.html#SpecifyingFillPaint)
    property accepts any [paint](https://www.w3.org/TR/SVG2/painting.html#SpecifyingPaint)
    value, which basically means we need to format our color to a standard CSS‚Äôs hue.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Alright, let‚Äôs generate an avatar for `"foo"` and see how it looks like.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Avatar for "foo".*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Well, it does not look terrible, but it‚Äôs not eye-catching either. To be perfectly
    honest, we should expect something like this; [SHA-256](https://en.wikipedia.org/wiki/SHA-2)
    returns (and for that matter all other hash functions too) a quasi-random values.
    If we convert those *raw* bytes to fill colors, we‚Äôll get quasi-random colors.
    To make it nicer we need to modify our algorithm slightly; we need to calculate
    a global theme, if you will, for the avatar, so that a part of circle segments''
    colors come from that theme. We can do that by folding all hash bytes into a single
    one with XOR.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*This code renders:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Avatar for "foo" with a theme.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*It looks rather good, if I say so myself. The solution works as it‚Äôs suppose
    to: it *most probably* produces different avatars for different identifiers ([hash
    collisions](https://en.wikipedia.org/wiki/Hash_collision) do happen) and they
    look acceptable. However, the rings seem to *phase* into each other ‚Äî their colors
    are too similar. We could experiment with another theme: a ring theme ‚Äî which
    would be a XOR-fold of all bytes that represent a single ring ‚Äî and check the
    results.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*With the final touch we get:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Avatar for "foo" with a global theme and a ring theme.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Which is exactly the thing that hides in the spoiler block at the top. If
    you restrained yourself and didn‚Äôt check it out: congratulations. Now feel free
    to do so. üòÉ*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[#](#conclusions) Conclusions*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working on this blog post has been an effort I wanted to make to better understand
    how SVGs work from the inside, as well as, a challenge to reverse-engineer ideas
    from [Representing SHA-256 Hashes As Avatars](https://francoisbest.com/posts/2021/hashvatars).*'
  prefs: []
  type: TYPE_NORMAL
- en: '*I‚Äôm not working on any service which would benefit from these avatars. If
    I happen to work on one in the future I‚Äôll for sure like to try them out. To make
    this solution easier to re-use in other places, I‚Äôve made a Rust crate called
    [`svg_avatars`](https://crates.io/crates/svg_avatars), which implements this exact
    solution. The crate is fairly minimal, so if anyone has any idea on how to enhance
    it, I‚Äôd love to hear from you/check out your PRs.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a closing thought, one of the parameters of the [absolute elliptical arc
    curve](https://www.w3.org/TR/SVG2/paths.html#PathDataEllipticalArcCommands) command
    is the `sweep-flag` parameter. It allows you to determine, whether an arc should
    be a smiley face or a sad face. If the parameter is `1` ‚Äî as it is in our case
    ‚Äî then the arc is a sad face. However, if you‚Äôd flip the flags to be `0`, then
    all arcs become smiley faces&mldr;*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smiley-face* avatar for "foo".*'
  prefs: []
  type: TYPE_NORMAL
- en: '*&mldr;and the avatar [emerges](https://en.wikipedia.org/wiki/Emergence) as
    a spiderweb. Who does not love a single-line-change feature for Spooktober.*'
  prefs: []
  type: TYPE_NORMAL
- en: </main>
  prefs: []
  type: TYPE_NORMAL
