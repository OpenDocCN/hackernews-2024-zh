["```\n*/// The number of standard SI apples.*\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\nstruct MetricApples(i64);\n\nimpl std::ops::Add for MetricApples {\n  type Output = Self;\n  fn add(self, other: Self) -> Self {\n    MetricApples(self.0 + other.0)\n  }\n} \n```", "```\n*/// MetricApples hold the number of standard SI apples.*\ntype MetricApples int64\n\nfunc main() {\n  a, b := MetricApples(2), MetricApples(3)\n  // Go allows us to add, multiply, and divide MetricApples.\n  // Note that all these operations give us MetricApples back, which doesnâ€™t always make sense.\n  // Apples times apples should give apples squared.\n  // Dividing apples should give a dimensionless number.\n  fmt.Printf(\"%[1]T %[1]d, %[2]T %[2]d, %[3]T %[3]d\\n\", a+b, a*b, b/a)\n} \n```", "```\ntrait DomainType {\n  */// The primitive type representing the domain value.*\n  type Representation; */// Creates a domain value from its representation value.*\n  fn from_repr(repr: Representation) -> Self;\n\n  */// Extracts the representation value from the domain value.*\n  fn to_repr(self) -> Representation;\n} \n```", "```\ntrait Eq {\n  */// Returns true if two values are equal.*\n  fn eq(&self, other: &Self) -> bool;\n}\n\ntrait IdentifierLike: DomainType + Eq {} \n```", "```\ntrait Ord: Eq {\n  */// Compares two values.*\n  fn cmp(&self, other: &Self) -> Ordering;\n}\n\ntrait VectorSpace {\n  */// The scalar type is usually the same as the [Representation](#representation-type) type.*\n  type Scalar;\n\n  */// Returns the additive inverse of the value.*\n  fn neg(self) -> Self;\n\n  */// Adds two vectors.*\n  fn add(self, other: Self) -> Self;\n\n  */// Subtracts the other vector from self.*\n  fn sub(self, other: Self) -> Self;\n\n  */// Multiplies the vector by a scalar.*\n  fn mul(self, factor: Scalar) -> Self;\n\n  */// Divides the vector by a scalar.*\n  fn div(self, factor: Scalar) -> Self;\n}\n\ntrait AmountLike: IdentifierLike + VectorSpace + Ord {} \n```", "```\ntrait LocusLike: IdentifierLike + Ord {\n  */// The type representing the distance between two positions.*\n  type Distance: AmountLike;\n\n  */// The origin for the absolute coordinate system.*\n  const ORIGIN: Self;\n\n  */// Moves the point away from the origin by the specified distance.*\n  fn add(self, other: Distance) -> Self;\n\n  */// Returns the distance between two points.*\n  fn sub(self, other: Self) -> Distance;\n} \n```", "```\ntrait QuantityLike<DimA>: AmountLike {\n  */// Multiplies two quantities.*\n  fn mul<O: QuantityLike<DimB>>(self, other: O)\n    -> impl QuantityLike<AddUnitPowers<DimA, DimB>>;\n\n  */// Divides self by the specified quantity.*\n  fn div<O: QuantityLike<DimB>>(self, other: O)\n    -> impl QuantityLike<SubUnitPowers<DimA, DimB>>;\n} \n```"]