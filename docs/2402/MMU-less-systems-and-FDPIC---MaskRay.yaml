- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:04:44'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: MMU-less systems and FDPIC | MaskRay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://maskray.me/blog/2024-02-20-mmu-less-systems-and-fdpic](https://maskray.me/blog/2024-02-20-mmu-less-systems-and-fdpic)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This article describes ABI and toolchain considerations about systems without
    a Memory Management Unit (MMU). We will focus on FDPIC and the in-development
    FDPIC ABI for RISC-V, with updates as I delve deeper into the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded systems often lack MMUs, relying on real-time operating systems (RTOS)
    like VxWorks or special Linux configurations (`CONFIG_MMU=n`). In these systems,
    the offset between the text and data segments is often not knwon at compile time.
    Therefore, a dedicated register is typically set to somewhere in the data segment
    and writable data is accessed relative to this register.
  prefs: []
  type: TYPE_NORMAL
- en: Why is the offset not knwon at compile time? There are primarily two reasons.
  prefs: []
  type: TYPE_NORMAL
- en: First, eXecute in Place (XIP), where code resides in ROM while the data segment
    is copied to RAM. Therefore, the offset between the text and data segments is
    often not knwon at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Second, all processes share the same address space without MMU. However, it
    is still desired for these processes to share text segments. Therefore needs a
    mechanism for code to find its corresponding data.
  prefs: []
  type: TYPE_NORMAL
- en: '## Compiler support for unknown text-data segment offset'
  prefs: []
  type: TYPE_NORMAL
- en: '`-msep-data`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GCC's m68k port [added `-msep-data`](https://gcc.gnu.org/pipermail/gcc-patches/2003-September/113699.html)
    in 2003-10.
  prefs: []
  type: TYPE_NORMAL
- en: Add -msep-data and -mid-shared-library support for uClinux. These are two special
    PIC variants that allow executing linux applications in ROM filesystems without
    loading an additional copy in memory (XIP).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With -msep-data, references to global data are made through register A5 which
    is loaded with a pointer to the start of the data/bss segment allocated in RAM.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The -mid-shared-library option allows using a special shared library flavour
    that allows allocationg a distinct data/bss section for each process without the
    need to relocate code in both library and application.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`-msep-data` is PIC only and updates `-fno-pic` to `-fPIE`. In this mode, a5
    is read-only and holds the address of `_GLOBAL_OFFSET_TABLE_`. When not used with
    `-mid-shared-library`, `-fPIC -msep-data` is unnecessary. Just stick with `-fPIE
    -msep-data`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`-mid-shared-library`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[This option](https://gcc.gnu.org/onlinedocs/gcc/M680x0-Options.html#:~:text=mid)
    was added to GCC''s m68k port along with `-msep-data`. The documentation says:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate code that supports shared libraries via the library ID method. This
    allows for execute-in-place and shared libraries in an environment without virtual
    memory management. This option implies -fPIC.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`-mid-shared-library` is PIC only and updates `-fno-pic` to `-fPIE`. You compile
    a source file with `-mid-shared-library -mshared-library-id=n`, and the functions
    will be attached to library ID n. At function entry a5 points to an array that
    maps a library ID to the corresponding GOT base address. The compiler generates
    `move.l -(n+1)*4(%a5),%a5` to obtain the actual GOT base address. The a5 will
    then be used to access the corresponding data segment.'
  prefs: []
  type: TYPE_NORMAL
- en: '`gcc/config/bfin` added `-msep-data` in 2006.'
  prefs: []
  type: TYPE_NORMAL
- en: '`-mno-pic-data-is-text-relative`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This ARM option is similar to `-msep-data` and only makes sense with `-fpie`/`-fpic`.
    In 2013, `-mno-pic-data-is-text-relative`, generalized from the ARM [VxWorks RTP](https://gcc.gnu.org/pipermail/gcc-patches/2007-May/217111.html)
    port, was [added](https://inbox.sourceware.org/gcc-patches/000001cedf74%24bd1bf710%243753e530%24@arm.com/)
    to assume that text and data segments don''t have a fixed displacement. On non-VxWorks-RTP
    targets, `-mno-pic-data-is-text-relative` implies [`-msingle-pic-base`](https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html#index-msingle-pic-base):'
  prefs: []
  type: TYPE_NORMAL
- en: Treat the register used for PIC addressing as read-only, rather than loading
    it in the prologue for each function. The runtime system is responsible for initializing
    this register with an appropriate value before execution begins.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: r9 is used as the static base (`arm_pic_register`) in the position-independent
    data model to access the data segment. Since r9 is not changed, dynamic linking
    seems unsupported as a DSO needs a different data segment.
  prefs: []
  type: TYPE_NORMAL
- en: GCC's s390x port added `-mno-pic-data-is-text-relative` in 2017 [for kpatch](https://github.com/dynup/kpatch/commit/10002f5aa671de2878252aaa48f585457d39638a)
    (live kernel patching).
  prefs: []
  type: TYPE_NORMAL
- en: '`-fropi` and `-frwpi`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clang ARM's `-fropi` and `-frwpi` are special `-fno-pic` variants that only
    intended for static linking. While regular `-fno-pic` assumes absolute addressing
    for both code data, `-fropi` and `-frwpi` add a twist by enforcing relative addressing
    based on specific assumptions about relocation. Both options consider the text-data
    segment offset unknown at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: '`-fropi` assumes code and read-only data will be relocated at runtime, making
    absolute addressing unsuitable. Instead, PC-relative addressing is used. The `.ARM.attributes`
    section contains `Tag_ABI_PCS_RO_data: 1` like `-fpic`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-frwpi` assumes writable data will be relocated at runtime, making absolute
    addressing unsuitable. Instead, writable data is accessed relative to the static
    base register. The `.ARM.attributes` section contains `Tag_ABI_PCS_RW_data: 2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `-fropi` and `-frwpi` together to require relative addressing for
    both code and data. Compared with `-fno-pic -frwpi`, `-fno-pic -fropi -frwpi`
    needs one more instruction to retrieve a function address.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of semantics, I think `-fno-pic -fropic -frwpic` is identical to `-fpie
    -mno-pic-data-is-text-relative` with hidden visibility declarations. In practice,
    GCC `-fpie -mno-pic-data-is-text-relative` utilizes GOT-relative relocations (`R_ARM_GOT_BREL`),
    not MOVW/MOVT instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '`-mfdpic`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will discuss this in detal later.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler option summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`-msep-data` and `-mno-pic-data-is-text-relative` are the same, relying on
    `-fpie/-fpic` semantics to enforce relative addressing for the text segment. `-fropi`
    and `-frwpi` offer finer control. You can choose to use relative addressing for
    text segment only (`-fropi`), data segment only (using `-frwpi`), or both.'
  prefs: []
  type: TYPE_NORMAL
- en: Neither `-msep-data` nor `-fropi -frwpi` supports shared libraries. `-msep-data`'s
    variant `-mid-shared-library` provides a library ID based shared library, which
    works for some cases but is inflexible.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's review OS support. While I'm not an RTOS expert, let's explore Linux's
    executable file loaders and see how they handle MMU-less scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Linux binfmt loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`fs/Kconfig.binfmt` defines a few loaders.'
  prefs: []
  type: TYPE_NORMAL
- en: '`BINFMT_ELF` defaults to y and depends on `MMU`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BINFMT_ELF_FDPIC` defaults to y when `BINFMT_ELF` is not selected. A few architecture
    support `BINFMT_ELF_FDPIC` for NOMMU. ARM supports FDPIC even with a MMU.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BINFMT_FLAT` is provided for a few architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, both `BINFMT_ELF_FDPIC` and `BINFMT_FLAT` can be used for MMU-less
    systems. `BINFMT_FLAT` is a very old solution that does not allow dynamic linking
    while `BINFMT_ELF_FDPIC` supports dynamic linking.
  prefs: []
  type: TYPE_NORMAL
- en: BTW, `BINFMT_AOUT`, removed in 2022, had been supported for alpha/arm/x86-32.
  prefs: []
  type: TYPE_NORMAL
- en: Binary flat format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux''s `BINFMT_FLAT` refers to an object file format used by [μClinux](https://en.wikipedia.org/wiki/%CE%9CClinux):
    Binary Flat format (BFLT). [https://myembeddeddev.blogspot.com/2010/02/uclinux-flat-file-format.html](https://myembeddeddev.blogspot.com/2010/02/uclinux-flat-file-format.html)
    has an introduction. BFLT is an executable file only format, not used for relocatable
    files. An executable file is typically converted from ELF using [elf2flt](https://github.com/uclinux-dev/elf2flt).
    `ld-elf2flt` is a ld wrapper that invokes `elf2flt` when the option `-elf2flt`
    is seen.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux's `BINFMT_FLAT` supports both version 2 (`OLD_FLAT_VERSION`) and version
    4\. Version 4 supports eXecute in Place (XIP), where code resides in ROM while
    the data segment is copied to RAM. Therefore, the offset between the text and
    data segments is often not knwon at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Greg added [ID-based shared library support](https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=3d97dc2d349e6630bced9ced2ca7d0c7b52e49bc)
    to be used with [`-mid-shared-library`](#mid-shared-library) in 2003, which was
    [removed](https://git.kernel.org/linus/70578ff3367dd4ad8f212a9b5c05cffadabf39a8)
    in April 2022\. The code supported one executable and at most 3 shared libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tooling for shared library support seems to be called eXtended FLAT (XFLAT).
    It is a limited shared library scheme that disallows global variable sharing.
    Quoting [XFLAT FAQ](https://xflat.sourceforge.net/XFlatFAQ.html):'
  prefs: []
  type: TYPE_NORMAL
- en: XFLAT provides an alternative mechanism to bind and relocate functions using
    a thunk layer that is inserted between each inter-module function call. However,
    without a GOT it is not possible to bind and relocate data. In short, with no
    GOT XFLAT cannot support sharing of global variables between program and shared
    library modules.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FDPIC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FDPIC can be seen as an extended `-mno-pic-data-is-text-relative` mode that
    utilizes function descriptors to support PIC register changes for dynamic linking.
    A FDPIC executable can be loaded using either the regular Linux ELF loader for
    MMU systems or `fs/binfmt_elf_fdpic.c` for MMU-less systems. `fs/binfmt_elf_fdpic.c`
    has been [available](https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=be3e0ada7b264efa8714b1ff6203c2c29fcc61c5)
    since 2002\. It supports both MMU and NOMMU configurations but does not support
    `ET_EXEC` executables in NOMMU mode. Each architecture that supports FDPIC defines
    an `EI_OSABI` value to be checked by the loader.
  prefs: []
  type: TYPE_NORMAL
- en: Several architectures define a FDPIC ABI.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a summary.
  prefs: []
  type: TYPE_NORMAL
- en: The read-only sections, which can be shared, are commonly referred to as the
    "text segment", whereas the writable sections are non-shared and commonly referred
    to as the "data segment". Functions and certain data symbols (`.rodata`) reside
    in the text segment, while other data symbols and the GOT reside in the data segment.
    Special entries called "canonical function descriptors" also reside in the GOT.
  prefs: []
  type: TYPE_NORMAL
- en: A call-clobbered register is reserved as the FDPIC register, used to access
    the data segment. Upon entry to a function, the FDPIC register holds the address
    of `_GLOBAL_OFFSET_TABLE_`. The text segment can be referenced using PC-relative
    addressing. The data segment including GOT is referenced using indirect FDPIC-register-relative
    addressing. We will see later that sometimes it's unknown whether a non-preemptible
    symbol resides in the text segment or the data segment, in which case GOT-indirect
    addressing with the FDPIC register has to be used.
  prefs: []
  type: TYPE_NORMAL
- en: A function call is called external if the destination may reside in another
    module, which has a different data segment and therefore needs a different FDPIC
    register value. Therefore, an external function call needs to update the FDPIC
    register as well as changing the program counter (PC). The FDPIC register can
    be spilled into a stack slot or a call-saved register, if the caller needs to
    reference the data segment later. The FDPIC register is call-clobbered to [allow
    external tail calls](/blog/2021-09-19-all-about-procedure-linkage-table#got-setup-is-expensive-without-pc-relative-addressing)
    and avoid PLT saving the register.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function pointer, including calling a PLT entry, also sets both the
    FDPIC register and PC. When the address of a function is taken, the address of
    its canonical function descriptor is obtained, not that of the entry point. The
    descriptor, resides in the GOT, contains pointers to both the function's entry
    point and its FDPIC register value. The two GOT entries are relocated by a dynamic
    relocation of type `R_*_FUNCDESC_VALUE` (e.g. [`R_FRV_FUNCDESC_VALUE`](https://www.fsfla.org/~lxoliva/writeups/FR-V/FDPIC-ABI.txt#:~:text=The%20R_FRV_FUNCDESC_VALUE%20relocation%20is%20used%20to)).
  prefs: []
  type: TYPE_NORMAL
- en: If the symbol is preemptible, the code sequence loads a GOT entry. When the
    symbol is a function, the GOT entry is relocated by a dynamic relocation `R_*_FUNCDESC`
    and will contain the address of the function descriptor address.
  prefs: []
  type: TYPE_NORMAL
- en: Let's checkout examples taking addresses of functions and variables.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Function access in FDPIC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Canonical function descriptors are stored in the GOT, and their access depends
    on whether the referenced function is preemptible or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'For non-preemptible functions: the address of the descriptor is directly computed
    by adding an offset to the FDPIC register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For preemptible functions: a GOT entry is loaded first. This entry, relocated
    by a `R_*_FUNCDESC` dynamic relocation, holds the final address of the function
    descriptor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, when linking a DSO, an `R_ARM_GOTOFFFUNCDESC` relocation referencing
    a hidden symbol results in a linker error. This error likely arises because the
    generated `R_ARM_FUNCDESC_VALUE` dynamic relocation requires a dynamic symbol.
    While this can be implemented using an `STB_LOCAL STT_SECTION` dynamic symbol,
    GNU ld currently lacks support for this approach.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Let's try sh4. `sh4-linux-gnu-gcc -fpic -mfdpic -O2 q.c -shared -nostdlib` allows
    taking the address of a hidden function but not a protected function (my [pending
    fix](https://sourceware.org/pipermail/binutils/2024-February/132519.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Then, let's see a global variable initialized by the address of a function and
    a C++ virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'TODO: `-fexperimental-relative-c++-abi-vtables`'
  prefs: []
  type: TYPE_NORMAL
- en: Data access in FDPIC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GOT-indirect addressing is required for accessing data symbols under two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Preemptible symbols: Traditional GOT requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-preemptible symbols with potential data segment placement: This includes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writable data symbols: This covers both locally declared (`int var;`) and externally
    declared (`extern int var;`) non-const variables.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Potential dynamic initialization: `const A a; extern const int var;`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Certain guaranteed constant initialization: `extern constinit const int *const
    extern_const;`. Constant initialization may require a relocation, e.g. `constinit
    const int *const extern_const = &var;`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic relocations `R_*_RELATIVE` and `R_*_GLOB_DAT` do not use the standard
    `+ load_base` semantics. It seems that musl fdpic doesn't support the special
    `R_*_RELATIVE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the referenced data symbol is non-preemptible and guaranteed to be in the
    text segment, we can use PC-relative addressing. However, this scenario is remarkably
    rare in practice. The most likely use case is like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'GCC''s arm port does not seem to utilize PC-relative addressing. We can try
    GCC''s SuperH port:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: It optimizes `addr_hidden_var` but not `addr_ro_hidden_var`.
  prefs: []
  type: TYPE_NORMAL
- en: Thread-local storage in FDPIC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ARM FDPIC ABI* defines static TLS relocations `R_ARM_TLS_GD32_FDPIC, R_ARM_TLS_LDM32_FDPIC,
    R_ARM_TLS_IE32_FDPIC` to be relative to GOT, as opposed to their non-FDPIC counterpart
    relative to PC.'
  prefs: []
  type: TYPE_NORMAL
- en: PLT in FDPIC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PLT entry needs to update the FDPIC register as well as changing the program
    counter (PC). binutils' arm port uses the following code sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy binding could be implemented, but it is difficult if the architecture does
    not allow atomic updates of two words. binutils' arm port just disable lazy binding.
  prefs: []
  type: TYPE_NORMAL
- en: Let's inspect an example involving consecutive function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'If GCC implements `-fno-plt`, it can use the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Relative relocations and `.rofixup` section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike standard `R_*_RELATIVE` relocations that use "*loc += load_base" semantics,
    the load address in FDPIC mode is dependent on the containing segment. The following
    code adapted fro musl demonstrates the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `-pie` and `-shared` links, a dynamic section is present, and non-preemptible
    function and data pointers are relocated by `R_*_FUNCDESC_VALUE` and `R_*_RELATIVE`
    dynamic relocations. For `-no-pie` links, the situation varies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic links: A dynamic section is present. We can still use dynamic relocations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static links: There is no dynamic section. In the non-FDPIC, there is even
    no relocation (other than `R_*_IRELATIVE`, unsupported in musl/uclibc-ng).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FDPIC executables of type `ET_EXEC` present a unique challenge: while the text
    segment has a fixed address, the data segment has an unknown address at link time
    and require relocations. To address this, a linker-created section named `.rofixup`
    was introduced in the first FDPIC ABI (FR-V), and later adopted by other FDPIC
    ABIs.'
  prefs: []
  type: TYPE_NORMAL
- en: '`.rofixup` holds non-preemptible function and data pointers, which have `R_*_RELATIVE`
    semantics. The last entry of `.rofixup` is special and holds the address of `_GLOBAL_OFFSET_TABLE_`.
    In a `-pie` or `-shared` link, `.rofixup` has only one entry. `__ROFIXUP_LIST__`
    and `__ROFIXUP_END__` are defined as encapsulation symbols of `.rofixup`.'
  prefs: []
  type: TYPE_NORMAL
- en: At run time, the loader sets the FDPIC register to the relocated `_GLOBAL_OFFSET_TABLE_`
    value before traferring control to the entry point of the executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Reflections on FDPIC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FDPIC can be seen as:'
  prefs: []
  type: TYPE_NORMAL
- en: An extended `-msep-data`/`-mno-pic-data-is-text-relative` mode that utilizes
    function descriptors to support PIC register changes for dynamic linking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fixed [PPC64 ELFv1 function descriptors ABI](/blog/2023-02-26-linker-notes-on-power-isa#ppc64-elfv1-function-descriptors).
    However, PPC64 ELFv1's trick of `st_value` referring to the function descriptor
    is better than the existing FDPIC ABIs (sh, arm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FDPIC resembles PPC64 ELFv2 TOC where the FDPIC register is set by the caller
    instead of the callee, avoiding global/local entry and tail call complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '`-fno-pic -mfdpic` with hidden visibility declarations can replace `-fno-pic
    -fropi -frwpi`, though clobbered r9 across function calls has slight overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-fPIE -mfdpic` with hidden visibility declarations can replace `-fPIE -msep-data`,
    though setting the call-clobbered FDPIC register has slight overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mfdpic` often generates smaller code than `-mno-fdpic` on architectures where
    PC-relative addressing is expensive. This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'sh4: Lacks PC-relative addressing entirely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'arm: Needs `LDR` with `.word _GLOBAL_OFFSET_TABLE_-(.LPIC0+4)`, which is expensive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since FDPIC works effectively even on systems with MMUs, it raises the intriguing
    possibility of replacing the standard calling ABI entirely.
  prefs: []
  type: TYPE_NORMAL
- en: '`-mfdpic` enables FDPIC code generation. GCC''sh port got [FDPIC support](https://gcc.gnu.org/git/gitweb.cgi?p=gcc.git;h=1e44e857e05c165f6f01aeb56a7a43ee765bfc99)
    in 2015\. `-mfpic` implies `-fPIE`, so `-fno-pic -mfdpic` and `-fPIE -mfdpic`
    have the same codegen behavior. `-fPIC -mfdpic` may have different generated code
    as it additionally sets `flag_shlib`.'
  prefs: []
  type: TYPE_NORMAL
- en: The cfgexpand pass calls `sh_get_fdpic_reg_initial_val` to retrieve the FDPIC
    register value from a pseudo register, and register the pseudo register for the
    first invocation. At the start of the ira (Integrated Register Allocator) pass,
    `allocate_initial_values` initializes the pseudo register to the hard register
    r12 at the function entry point. sh is the only port that defines `TARGET_ALLOCATE_INITIAL_VALUE`.
  prefs: []
  type: TYPE_NORMAL
- en: In GCC's arm port, `-fno-pic -mfdpic` generated code does not work.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, external function calls save and restore r9.
  prefs: []
  type: TYPE_NORMAL
- en: 'gas''s arm port needs `--fdpic` to assemble FDPIC-related relocation types.
    GCC configured with a `arm*-*-uclinuxfdpiceabi` target utilizes `arm/uclinuxfdpiceabi.h`
    and transforms `-mfdpic` to `--fdpic` when assembling a file. For other targets,
    `-Wa,--fdpic` is needed to assemble the output. [[PATCH] arm: Support -mfdpic
    for more targets](https://gcc.gnu.org/pipermail/gcc-patches/2024-February/646436.html)
    will make `-Wa,--fdpic` unneeded.'
  prefs: []
  type: TYPE_NORMAL
- en: '`-mfdpic -mtls-dialect=gnu2` is not supported. The ARM FDPIC ABI uses `ldr`
    to load a 32-bit constant embedded in the text segment. The offset is used to
    materialize the address of a GOT entry (canonical function descriptor, address
    of the canonical function descriptor, or address of data).'
  prefs: []
  type: TYPE_NORMAL
- en: You can configure binutils with `--target=arm-unknown-uclinuxfdpiceabi` to get
    a BFD linker that supports FDPIC emulations.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: GNU ld' arm port fails on `R_ARM_GOTOFFFUNCDESC` referencing a hidden function
    symbol ([PR31408](https://sourceware.org/bugzilla/show_bug.cgi?id=31408)).
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In `-no-pie` mode, certain non-function references that require a `.rofixup`
    entrie leads to a segfault ([PR31407](https://sourceware.org/bugzilla/show_bug.cgi?id=31407)).
  prefs: []
  type: TYPE_NORMAL
- en: Global/weak non-hidden symbols referenced by `R_ARM_FUNCDESC` are unnecessarily
    exported ([PR31409](https://sourceware.org/bugzilla/show_bug.cgi?id=31407)).
  prefs: []
  type: TYPE_NORMAL
- en: RISC-V FDPIC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several proposals exist for defining FDPIC-like ABIs to work for MMU-less systems.
  prefs: []
  type: TYPE_NORMAL
- en: Undoubtly, GP should be used as the FDPIC register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading a constant near code (like ARM) is not efficient. Instead, consider
    a two-instruction sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Use hi20 and lo12 instructions to generate an offset relative to the GP register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `c.add a0, gp` to compute the address of the GOT entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maciej's code sequence supports both function and data access through indirect
    GP-relative addressing. We can easily enhance it by adding `R_RISCV_RELAX` to
    enable linker relaxation and improve performance. Additionally, for consistency
    with similar notations on x86-64 and AArch64 ("gotpcrel"), let's adopt "gotgprel"
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'For data access, the code sequence is followed by instructions like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function descriptors and data have different semantics, requiring two relocation
    types. Stefan O''Rear proposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R_RISCV_FUNCDESC_GOTGPREL_HI`: Find or create two GOT entries for the canonical
    function descriptor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R_RISCV_GOTGPREL_HI`: For or create a GOT for the symbol, and return an offset
    from the FDPIC register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing inspiration from ARM FDPIC, two additional relocation types are needed
    for TLS. This results in a 4-type scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'RISC-V FDPIC: optimization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Addressing performance concerns is crucial. Stefan suggests an "indirect-to-relative
    optimization and relaxation scheme":'
  prefs: []
  type: TYPE_NORMAL
- en: '`R_RISCV_PIC_ADD`: Tags `c.add rX, gp` to enable optimization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R_RISCV_INTERMEDIATE_LOAD`: Tags `ld rY, <gotgprel_lo12>(rX)` to enable optimization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indirect GP-relative addressing can be optimized to direct GP-relative addressing
    under specific conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-preemptible functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-preemptible data in the data segment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: GOT-indirect addressing can be optimized to PC-relative for non-preemptible
    data in the text segment.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: GOT-indirect addressing can be optimized to absolute addressing for non-preemptible
    data in the text segment.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This can be used for `SHN_ABS` and unresolved undefined weak symbols. With `-no-pie`
    linking, regular symbols are elligible for this optimization as well. However,
    linkers may choose not to implement this since the added complexity might outweigh
    the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'RISC-V FDPIC: thread-local storage'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To handle TLSDESC, we introduce a new relocation type: `R_RISCV_TLSDESC_GPREL_HI`.
    This type instructs the linker to find or create two GOT entries unless optimized
    to local-exec or init-exec. The combined hi20 and lo12 offsets compute the GP-relative
    offset to the first GOT entry.'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Existing relocation types, `R_RISCV_TLSDESC_LOAD_LO12` and `R_RISCV_TLSDESC_ADD_LO12`,
    are extended to work with `R_RISCV_TLSDESC_GPREL_HI`.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'For initial-exec TLS model, we need a new pseudoinstruction, say, `la.tls.ie.fd
    rX, sym`. It expands to:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Stefan's scheme defines `R_RISCV_PIC_LO12_I` as an alias for `R_RISCV_PCREL_LO12_I`.
    Since the symbol is GP-relative instead of PC-relative, avoiding `PCREL` in the
    relocation type name makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Stefan's 11-type scheme adds `R_RISCV_PIC_ADDR_LO12_I` to be associated with
    `ld rX, 0(rX)` instead. I have not yet figured out the reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: 'RISC-V FDPIC: `-fno-plt`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regular [`-fno-plt`](/blog/2021-09-19-all-about-procedure-linkage-table#fno-plt)
    code loads the `.got.plt` entry using PC-relative addressing and performs an indirect
    branch. The FDPIC `-fno-plt` variant needs to load both the FDPIC register and
    the destination address.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: libc implementations with FDPIC support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: uclibc-ng supports AArch32, Blackfin, and FR-V.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: musl supports SuperH.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
