- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:04:44'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: MMU-less systems and FDPIC | MaskRay
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://maskray.me/blog/2024-02-20-mmu-less-systems-and-fdpic](https://maskray.me/blog/2024-02-20-mmu-less-systems-and-fdpic)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This article describes ABI and toolchain considerations about systems without
    a Memory Management Unit (MMU). We will focus on FDPIC and the in-development
    FDPIC ABI for RISC-V, with updates as I delve deeper into the topic.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Embedded systems often lack MMUs, relying on real-time operating systems (RTOS)
    like VxWorks or special Linux configurations (`CONFIG_MMU=n`). In these systems,
    the offset between the text and data segments is often not knwon at compile time.
    Therefore, a dedicated register is typically set to somewhere in the data segment
    and writable data is accessed relative to this register.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: Why is the offset not knwon at compile time? There are primarily two reasons.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: First, eXecute in Place (XIP), where code resides in ROM while the data segment
    is copied to RAM. Therefore, the offset between the text and data segments is
    often not knwon at compile time.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: Second, all processes share the same address space without MMU. However, it
    is still desired for these processes to share text segments. Therefore needs a
    mechanism for code to find its corresponding data.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: '## Compiler support for unknown text-data segment offset'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: '`-msep-data`'
  id: totrans-split-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GCC's m68k port [added `-msep-data`](https://gcc.gnu.org/pipermail/gcc-patches/2003-September/113699.html)
    in 2003-10.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: Add -msep-data and -mid-shared-library support for uClinux. These are two special
    PIC variants that allow executing linux applications in ROM filesystems without
    loading an additional copy in memory (XIP).
  id: totrans-split-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With -msep-data, references to global data are made through register A5 which
    is loaded with a pointer to the start of the data/bss segment allocated in RAM.
  id: totrans-split-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The -mid-shared-library option allows using a special shared library flavour
    that allows allocationg a distinct data/bss section for each process without the
    need to relocate code in both library and application.
  id: totrans-split-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`-msep-data` is PIC only and updates `-fno-pic` to `-fPIE`. In this mode, a5
    is read-only and holds the address of `_GLOBAL_OFFSET_TABLE_`. When not used with
    `-mid-shared-library`, `-fPIC -msep-data` is unnecessary. Just stick with `-fPIE
    -msep-data`.'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: '`-mid-shared-library`'
  id: totrans-split-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[This option](https://gcc.gnu.org/onlinedocs/gcc/M680x0-Options.html#:~:text=mid)
    was added to GCC''s m68k port along with `-msep-data`. The documentation says:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: Generate code that supports shared libraries via the library ID method. This
    allows for execute-in-place and shared libraries in an environment without virtual
    memory management. This option implies -fPIC.
  id: totrans-split-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`-mid-shared-library` is PIC only and updates `-fno-pic` to `-fPIE`. You compile
    a source file with `-mid-shared-library -mshared-library-id=n`, and the functions
    will be attached to library ID n. At function entry a5 points to an array that
    maps a library ID to the corresponding GOT base address. The compiler generates
    `move.l -(n+1)*4(%a5),%a5` to obtain the actual GOT base address. The a5 will
    then be used to access the corresponding data segment.'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '`gcc/config/bfin` added `-msep-data` in 2006.'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: '`-mno-pic-data-is-text-relative`'
  id: totrans-split-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This ARM option is similar to `-msep-data` and only makes sense with `-fpie`/`-fpic`.
    In 2013, `-mno-pic-data-is-text-relative`, generalized from the ARM [VxWorks RTP](https://gcc.gnu.org/pipermail/gcc-patches/2007-May/217111.html)
    port, was [added](https://inbox.sourceware.org/gcc-patches/000001cedf74%24bd1bf710%243753e530%24@arm.com/)
    to assume that text and data segments don''t have a fixed displacement. On non-VxWorks-RTP
    targets, `-mno-pic-data-is-text-relative` implies [`-msingle-pic-base`](https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html#index-msingle-pic-base):'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: Treat the register used for PIC addressing as read-only, rather than loading
    it in the prologue for each function. The runtime system is responsible for initializing
    this register with an appropriate value before execution begins.
  id: totrans-split-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: r9 is used as the static base (`arm_pic_register`) in the position-independent
    data model to access the data segment. Since r9 is not changed, dynamic linking
    seems unsupported as a DSO needs a different data segment.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: GCC's s390x port added `-mno-pic-data-is-text-relative` in 2017 [for kpatch](https://github.com/dynup/kpatch/commit/10002f5aa671de2878252aaa48f585457d39638a)
    (live kernel patching).
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: '`-fropi` and `-frwpi`'
  id: totrans-split-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clang ARM's `-fropi` and `-frwpi` are special `-fno-pic` variants that only
    intended for static linking. While regular `-fno-pic` assumes absolute addressing
    for both code data, `-fropi` and `-frwpi` add a twist by enforcing relative addressing
    based on specific assumptions about relocation. Both options consider the text-data
    segment offset unknown at compile time.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: '`-fropi` assumes code and read-only data will be relocated at runtime, making
    absolute addressing unsuitable. Instead, PC-relative addressing is used. The `.ARM.attributes`
    section contains `Tag_ABI_PCS_RO_data: 1` like `-fpic`.'
  id: totrans-split-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-frwpi` assumes writable data will be relocated at runtime, making absolute
    addressing unsuitable. Instead, writable data is accessed relative to the static
    base register. The `.ARM.attributes` section contains `Tag_ABI_PCS_RW_data: 2`.'
  id: totrans-split-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `-fropi` and `-frwpi` together to require relative addressing for
    both code and data. Compared with `-fno-pic -frwpi`, `-fno-pic -fropi -frwpi`
    needs one more instruction to retrieve a function address.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: In terms of semantics, I think `-fno-pic -fropic -frwpic` is identical to `-fpie
    -mno-pic-data-is-text-relative` with hidden visibility declarations. In practice,
    GCC `-fpie -mno-pic-data-is-text-relative` utilizes GOT-relative relocations (`R_ARM_GOT_BREL`),
    not MOVW/MOVT instructions.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: '`-mfdpic`'
  id: totrans-split-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will discuss this in detal later.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: Compiler option summary
  id: totrans-split-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`-msep-data` and `-mno-pic-data-is-text-relative` are the same, relying on
    `-fpie/-fpic` semantics to enforce relative addressing for the text segment. `-fropi`
    and `-frwpi` offer finer control. You can choose to use relative addressing for
    text segment only (`-fropi`), data segment only (using `-frwpi`), or both.'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: Neither `-msep-data` nor `-fropi -frwpi` supports shared libraries. `-msep-data`'s
    variant `-mid-shared-library` provides a library ID based shared library, which
    works for some cases but is inflexible.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's review OS support. While I'm not an RTOS expert, let's explore Linux's
    executable file loaders and see how they handle MMU-less scenarios.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: Linux binfmt loaders
  id: totrans-split-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`fs/Kconfig.binfmt` defines a few loaders.'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: '`BINFMT_ELF` defaults to y and depends on `MMU`.'
  id: totrans-split-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BINFMT_ELF_FDPIC` defaults to y when `BINFMT_ELF` is not selected. A few architecture
    support `BINFMT_ELF_FDPIC` for NOMMU. ARM supports FDPIC even with a MMU.'
  id: totrans-split-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BINFMT_FLAT` is provided for a few architectures.'
  id: totrans-split-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, both `BINFMT_ELF_FDPIC` and `BINFMT_FLAT` can be used for MMU-less
    systems. `BINFMT_FLAT` is a very old solution that does not allow dynamic linking
    while `BINFMT_ELF_FDPIC` supports dynamic linking.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: BTW, `BINFMT_AOUT`, removed in 2022, had been supported for alpha/arm/x86-32.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: Binary flat format
  id: totrans-split-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux''s `BINFMT_FLAT` refers to an object file format used by [μClinux](https://en.wikipedia.org/wiki/%CE%9CClinux):
    Binary Flat format (BFLT). [https://myembeddeddev.blogspot.com/2010/02/uclinux-flat-file-format.html](https://myembeddeddev.blogspot.com/2010/02/uclinux-flat-file-format.html)
    has an introduction. BFLT is an executable file only format, not used for relocatable
    files. An executable file is typically converted from ELF using [elf2flt](https://github.com/uclinux-dev/elf2flt).
    `ld-elf2flt` is a ld wrapper that invokes `elf2flt` when the option `-elf2flt`
    is seen.'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: Linux's `BINFMT_FLAT` supports both version 2 (`OLD_FLAT_VERSION`) and version
    4\. Version 4 supports eXecute in Place (XIP), where code resides in ROM while
    the data segment is copied to RAM. Therefore, the offset between the text and
    data segments is often not knwon at compile time.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: Greg added [ID-based shared library support](https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=3d97dc2d349e6630bced9ced2ca7d0c7b52e49bc)
    to be used with [`-mid-shared-library`](#mid-shared-library) in 2003, which was
    [removed](https://git.kernel.org/linus/70578ff3367dd4ad8f212a9b5c05cffadabf39a8)
    in April 2022\. The code supported one executable and at most 3 shared libraries.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: 'The tooling for shared library support seems to be called eXtended FLAT (XFLAT).
    It is a limited shared library scheme that disallows global variable sharing.
    Quoting [XFLAT FAQ](https://xflat.sourceforge.net/XFlatFAQ.html):'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用于共享库支持的工具似乎称为eXtended FLAT（XFLAT）。这是一种限制的共享库方案，不允许全局变量共享。引用[XFLAT FAQ](https://xflat.sourceforge.net/XFlatFAQ.html)：
- en: XFLAT provides an alternative mechanism to bind and relocate functions using
    a thunk layer that is inserted between each inter-module function call. However,
    without a GOT it is not possible to bind and relocate data. In short, with no
    GOT XFLAT cannot support sharing of global variables between program and shared
    library modules.
  id: totrans-split-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XFLAT提供了一种替代机制，用于通过插入在每个模块间函数调用之间的Thunk层来绑定和重定位函数。然而，没有GOT，无法绑定和重定位数据。简而言之，没有GOT，XFLAT无法支持程序和共享库模块之间的全局变量共享。
- en: FDPIC
  id: totrans-split-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FDPIC
- en: FDPIC can be seen as an extended `-mno-pic-data-is-text-relative` mode that
    utilizes function descriptors to support PIC register changes for dynamic linking.
    A FDPIC executable can be loaded using either the regular Linux ELF loader for
    MMU systems or `fs/binfmt_elf_fdpic.c` for MMU-less systems. `fs/binfmt_elf_fdpic.c`
    has been [available](https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=be3e0ada7b264efa8714b1ff6203c2c29fcc61c5)
    since 2002\. It supports both MMU and NOMMU configurations but does not support
    `ET_EXEC` executables in NOMMU mode. Each architecture that supports FDPIC defines
    an `EI_OSABI` value to be checked by the loader.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: FDPIC可以看作是一种扩展的`-mno-pic-data-is-text-relative`模式，它利用函数描述符支持动态链接的PIC寄存器更改。FDPIC可执行文件可以使用常规的Linux
    ELF加载器加载到MMU系统或使用`fs/binfmt_elf_fdpic.c`加载到无MMU系统中。自2002年以来，`fs/binfmt_elf_fdpic.c`一直[可用](https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=be3e0ada7b264efa8714b1ff6203c2c29fcc61c5)。它支持MMU和NOMMU配置，但不支持NOMMU模式下的`ET_EXEC`可执行文件。支持FDPIC的每个架构都定义了一个要由加载器检查的`EI_OSABI`值。
- en: Several architectures define a FDPIC ABI.
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 几种架构定义了FDPIC ABI。
- en: Here is a summary.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个摘要。
- en: The read-only sections, which can be shared, are commonly referred to as the
    "text segment", whereas the writable sections are non-shared and commonly referred
    to as the "data segment". Functions and certain data symbols (`.rodata`) reside
    in the text segment, while other data symbols and the GOT reside in the data segment.
    Special entries called "canonical function descriptors" also reside in the GOT.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以共享的只读段通常称为“文本段”，而可写段是非共享的，通常称为“数据段”。函数和某些数据符号（`.rodata`）驻留在文本段中，而其他数据符号和GOT驻留在数据段中。特殊条目称为“规范函数描述符”也驻留在GOT中。
- en: A call-clobbered register is reserved as the FDPIC register, used to access
    the data segment. Upon entry to a function, the FDPIC register holds the address
    of `_GLOBAL_OFFSET_TABLE_`. The text segment can be referenced using PC-relative
    addressing. The data segment including GOT is referenced using indirect FDPIC-register-relative
    addressing. We will see later that sometimes it's unknown whether a non-preemptible
    symbol resides in the text segment or the data segment, in which case GOT-indirect
    addressing with the FDPIC register has to be used.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被调用破坏的寄存器作为FDPIC寄存器保留，用于访问数据段。进入函数时，FDPIC寄存器保存了`_GLOBAL_OFFSET_TABLE_`的地址。文本段可以使用PC相对寻址引用。包括GOT在内的数据段使用间接FDPIC寄存器相对寻址引用。稍后我们将看到，有时不确定一个不可抢占符号驻留在文本段还是数据段，此时必须使用带有FDPIC寄存器的GOT间接寻址。
- en: A function call is called external if the destination may reside in another
    module, which has a different data segment and therefore needs a different FDPIC
    register value. Therefore, an external function call needs to update the FDPIC
    register as well as changing the program counter (PC). The FDPIC register can
    be spilled into a stack slot or a call-saved register, if the caller needs to
    reference the data segment later. The FDPIC register is call-clobbered to [allow
    external tail calls](/blog/2021-09-19-all-about-procedure-linkage-table#got-setup-is-expensive-without-pc-relative-addressing)
    and avoid PLT saving the register.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用称为外部调用，如果目标可能驻留在另一个模块中，该模块具有不同的数据段，因此需要不同的FDPIC寄存器值。因此，外部函数调用需要更新FDPIC寄存器以及改变程序计数器（PC）。如果调用者需要稍后引用数据段，则FDPIC寄存器可以溢出到堆栈插槽或调用保存的寄存器。FDPIC寄存器被调用破坏，以[允许外部尾调用](/blog/2021-09-19-all-about-procedure-linkage-table#got-setup-is-expensive-without-pc-relative-addressing)，并避免PLT保存该寄存器。
- en: Calling a function pointer, including calling a PLT entry, also sets both the
    FDPIC register and PC. When the address of a function is taken, the address of
    its canonical function descriptor is obtained, not that of the entry point. The
    descriptor, resides in the GOT, contains pointers to both the function's entry
    point and its FDPIC register value. The two GOT entries are relocated by a dynamic
    relocation of type `R_*_FUNCDESC_VALUE` (e.g. [`R_FRV_FUNCDESC_VALUE`](https://www.fsfla.org/~lxoliva/writeups/FR-V/FDPIC-ABI.txt#:~:text=The%20R_FRV_FUNCDESC_VALUE%20relocation%20is%20used%20to)).
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: If the symbol is preemptible, the code sequence loads a GOT entry. When the
    symbol is a function, the GOT entry is relocated by a dynamic relocation `R_*_FUNCDESC`
    and will contain the address of the function descriptor address.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: Let's checkout examples taking addresses of functions and variables.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: Function access in FDPIC
  id: totrans-split-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Canonical function descriptors are stored in the GOT, and their access depends
    on whether the referenced function is preemptible or not.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: 'For non-preemptible functions: the address of the descriptor is directly computed
    by adding an offset to the FDPIC register.'
  id: totrans-split-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For preemptible functions: a GOT entry is loaded first. This entry, relocated
    by a `R_*_FUNCDESC` dynamic relocation, holds the final address of the function
    descriptor.'
  id: totrans-split-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, when linking a DSO, an `R_ARM_GOTOFFFUNCDESC` relocation referencing
    a hidden symbol results in a linker error. This error likely arises because the
    generated `R_ARM_FUNCDESC_VALUE` dynamic relocation requires a dynamic symbol.
    While this can be implemented using an `STB_LOCAL STT_SECTION` dynamic symbol,
    GNU ld currently lacks support for this approach.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: Let's try sh4. `sh4-linux-gnu-gcc -fpic -mfdpic -O2 q.c -shared -nostdlib` allows
    taking the address of a hidden function but not a protected function (my [pending
    fix](https://sourceware.org/pipermail/binutils/2024-February/132519.html)).
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: Then, let's see a global variable initialized by the address of a function and
    a C++ virtual table.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
- en: 'TODO: `-fexperimental-relative-c++-abi-vtables`'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
- en: Data access in FDPIC
  id: totrans-split-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GOT-indirect addressing is required for accessing data symbols under two conditions:'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Preemptible symbols: Traditional GOT requirement.'
  id: totrans-split-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-preemptible symbols with potential data segment placement: This includes'
  id: totrans-split-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writable data symbols: This covers both locally declared (`int var;`) and externally
    declared (`extern int var;`) non-const variables.'
  id: totrans-split-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Potential dynamic initialization: `const A a; extern const int var;`'
  id: totrans-split-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Certain guaranteed constant initialization: `extern constinit const int *const
    extern_const;`. Constant initialization may require a relocation, e.g. `constinit
    const int *const extern_const = &var;`'
  id: totrans-split-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic relocations `R_*_RELATIVE` and `R_*_GLOB_DAT` do not use the standard
    `+ load_base` semantics. It seems that musl fdpic doesn't support the special
    `R_*_RELATIVE`.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
- en: 'If the referenced data symbol is non-preemptible and guaranteed to be in the
    text segment, we can use PC-relative addressing. However, this scenario is remarkably
    rare in practice. The most likely use case is like the following:'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-split-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
- en: 'GCC''s arm port does not seem to utilize PC-relative addressing. We can try
    GCC''s SuperH port:'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-split-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-split-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
- en: It optimizes `addr_hidden_var` but not `addr_ro_hidden_var`.
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
- en: Thread-local storage in FDPIC
  id: totrans-split-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ARM FDPIC ABI* defines static TLS relocations `R_ARM_TLS_GD32_FDPIC, R_ARM_TLS_LDM32_FDPIC,
    R_ARM_TLS_IE32_FDPIC` to be relative to GOT, as opposed to their non-FDPIC counterpart
    relative to PC.'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
- en: PLT in FDPIC
  id: totrans-split-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PLT entry needs to update the FDPIC register as well as changing the program
    counter (PC). binutils' arm port uses the following code sequence.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-split-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-split-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
- en: Lazy binding could be implemented, but it is difficult if the architecture does
    not allow atomic updates of two words. binutils' arm port just disable lazy binding.
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
- en: Let's inspect an example involving consecutive function calls.
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-split-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-split-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-split-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-split-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
- en: 'If GCC implements `-fno-plt`, it can use the following code sequence:'
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-split-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-split-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
- en: Relative relocations and `.rofixup` section
  id: totrans-split-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike standard `R_*_RELATIVE` relocations that use "*loc += load_base" semantics,
    the load address in FDPIC mode is dependent on the containing segment. The following
    code adapted fro musl demonstrates the behavior:'
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-split-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-split-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
- en: 'In `-pie` and `-shared` links, a dynamic section is present, and non-preemptible
    function and data pointers are relocated by `R_*_FUNCDESC_VALUE` and `R_*_RELATIVE`
    dynamic relocations. For `-no-pie` links, the situation varies:'
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic links: A dynamic section is present. We can still use dynamic relocations.'
  id: totrans-split-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static links: There is no dynamic section. In the non-FDPIC, there is even
    no relocation (other than `R_*_IRELATIVE`, unsupported in musl/uclibc-ng).'
  id: totrans-split-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FDPIC executables of type `ET_EXEC` present a unique challenge: while the text
    segment has a fixed address, the data segment has an unknown address at link time
    and require relocations. To address this, a linker-created section named `.rofixup`
    was introduced in the first FDPIC ABI (FR-V), and later adopted by other FDPIC
    ABIs.'
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
- en: '`.rofixup` holds non-preemptible function and data pointers, which have `R_*_RELATIVE`
    semantics. The last entry of `.rofixup` is special and holds the address of `_GLOBAL_OFFSET_TABLE_`.
    In a `-pie` or `-shared` link, `.rofixup` has only one entry. `__ROFIXUP_LIST__`
    and `__ROFIXUP_END__` are defined as encapsulation symbols of `.rofixup`.'
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
- en: At run time, the loader sets the FDPIC register to the relocated `_GLOBAL_OFFSET_TABLE_`
    value before traferring control to the entry point of the executable.
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-split-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-split-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
- en: Reflections on FDPIC
  id: totrans-split-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FDPIC can be seen as:'
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
- en: An extended `-msep-data`/`-mno-pic-data-is-text-relative` mode that utilizes
    function descriptors to support PIC register changes for dynamic linking.
  id: totrans-split-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fixed [PPC64 ELFv1 function descriptors ABI](/blog/2023-02-26-linker-notes-on-power-isa#ppc64-elfv1-function-descriptors).
    However, PPC64 ELFv1's trick of `st_value` referring to the function descriptor
    is better than the existing FDPIC ABIs (sh, arm).
  id: totrans-split-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FDPIC resembles PPC64 ELFv2 TOC where the FDPIC register is set by the caller
    instead of the callee, avoiding global/local entry and tail call complexity.
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
- en: '`-fno-pic -mfdpic` with hidden visibility declarations can replace `-fno-pic
    -fropi -frwpi`, though clobbered r9 across function calls has slight overhead.'
  id: totrans-split-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-fPIE -mfdpic` with hidden visibility declarations can replace `-fPIE -msep-data`,
    though setting the call-clobbered FDPIC register has slight overhead.'
  id: totrans-split-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mfdpic` often generates smaller code than `-mno-fdpic` on architectures where
    PC-relative addressing is expensive. This includes:'
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
- en: 'sh4: Lacks PC-relative addressing entirely.'
  id: totrans-split-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'arm: Needs `LDR` with `.word _GLOBAL_OFFSET_TABLE_-(.LPIC0+4)`, which is expensive.'
  id: totrans-split-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since FDPIC works effectively even on systems with MMUs, it raises the intriguing
    possibility of replacing the standard calling ABI entirely.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
- en: '`-mfdpic` enables FDPIC code generation. GCC''sh port got [FDPIC support](https://gcc.gnu.org/git/gitweb.cgi?p=gcc.git;h=1e44e857e05c165f6f01aeb56a7a43ee765bfc99)
    in 2015\. `-mfpic` implies `-fPIE`, so `-fno-pic -mfdpic` and `-fPIE -mfdpic`
    have the same codegen behavior. `-fPIC -mfdpic` may have different generated code
    as it additionally sets `flag_shlib`.'
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
- en: The cfgexpand pass calls `sh_get_fdpic_reg_initial_val` to retrieve the FDPIC
    register value from a pseudo register, and register the pseudo register for the
    first invocation. At the start of the ira (Integrated Register Allocator) pass,
    `allocate_initial_values` initializes the pseudo register to the hard register
    r12 at the function entry point. sh is the only port that defines `TARGET_ALLOCATE_INITIAL_VALUE`.
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
- en: In GCC's arm port, `-fno-pic -mfdpic` generated code does not work.
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
- en: In addition, external function calls save and restore r9.
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
- en: 'gas''s arm port needs `--fdpic` to assemble FDPIC-related relocation types.
    GCC configured with a `arm*-*-uclinuxfdpiceabi` target utilizes `arm/uclinuxfdpiceabi.h`
    and transforms `-mfdpic` to `--fdpic` when assembling a file. For other targets,
    `-Wa,--fdpic` is needed to assemble the output. [[PATCH] arm: Support -mfdpic
    for more targets](https://gcc.gnu.org/pipermail/gcc-patches/2024-February/646436.html)
    will make `-Wa,--fdpic` unneeded.'
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
- en: '`-mfdpic -mtls-dialect=gnu2` is not supported. The ARM FDPIC ABI uses `ldr`
    to load a 32-bit constant embedded in the text segment. The offset is used to
    materialize the address of a GOT entry (canonical function descriptor, address
    of the canonical function descriptor, or address of data).'
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
- en: You can configure binutils with `--target=arm-unknown-uclinuxfdpiceabi` to get
    a BFD linker that supports FDPIC emulations.
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-split-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-split-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
- en: GNU ld' arm port fails on `R_ARM_GOTOFFFUNCDESC` referencing a hidden function
    symbol ([PR31408](https://sourceware.org/bugzilla/show_bug.cgi?id=31408)).
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-split-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-split-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-split-197
  prefs: []
  type: TYPE_NORMAL
- en: In `-no-pie` mode, certain non-function references that require a `.rofixup`
    entrie leads to a segfault ([PR31407](https://sourceware.org/bugzilla/show_bug.cgi?id=31407)).
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
- en: Global/weak non-hidden symbols referenced by `R_ARM_FUNCDESC` are unnecessarily
    exported ([PR31409](https://sourceware.org/bugzilla/show_bug.cgi?id=31407)).
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
- en: RISC-V FDPIC
  id: totrans-split-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several proposals exist for defining FDPIC-like ABIs to work for MMU-less systems.
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
- en: Undoubtly, GP should be used as the FDPIC register.
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading a constant near code (like ARM) is not efficient. Instead, consider
    a two-instruction sequence:'
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
- en: Use hi20 and lo12 instructions to generate an offset relative to the GP register.
  id: totrans-split-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `c.add a0, gp` to compute the address of the GOT entry.
  id: totrans-split-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maciej's code sequence supports both function and data access through indirect
    GP-relative addressing. We can easily enhance it by adding `R_RISCV_RELAX` to
    enable linker relaxation and improve performance. Additionally, for consistency
    with similar notations on x86-64 and AArch64 ("gotpcrel"), let's adopt "gotgprel"
    notation.
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-split-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-split-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-split-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
- en: 'For data access, the code sequence is followed by instructions like:'
  id: totrans-split-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Function descriptors and data have different semantics, requiring two relocation
    types. Stefan O''Rear proposes:'
  id: totrans-split-213
  prefs: []
  type: TYPE_NORMAL
- en: '`R_RISCV_FUNCDESC_GOTGPREL_HI`: Find or create two GOT entries for the canonical
    function descriptor.'
  id: totrans-split-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R_RISCV_GOTGPREL_HI`: For or create a GOT for the symbol, and return an offset
    from the FDPIC register.'
  id: totrans-split-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing inspiration from ARM FDPIC, two additional relocation types are needed
    for TLS. This results in a 4-type scheme.
  id: totrans-split-216
  prefs: []
  type: TYPE_NORMAL
- en: 'RISC-V FDPIC: optimization'
  id: totrans-split-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Addressing performance concerns is crucial. Stefan suggests an "indirect-to-relative
    optimization and relaxation scheme":'
  id: totrans-split-218
  prefs: []
  type: TYPE_NORMAL
- en: '`R_RISCV_PIC_ADD`: Tags `c.add rX, gp` to enable optimization'
  id: totrans-split-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R_RISCV_INTERMEDIATE_LOAD`: Tags `ld rY, <gotgprel_lo12>(rX)` to enable optimization'
  id: totrans-split-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indirect GP-relative addressing can be optimized to direct GP-relative addressing
    under specific conditions:'
  id: totrans-split-221
  prefs: []
  type: TYPE_NORMAL
- en: Non-preemptible functions
  id: totrans-split-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-preemptible data in the data segment
  id: totrans-split-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-split-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-split-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-split-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
- en: GOT-indirect addressing can be optimized to PC-relative for non-preemptible
    data in the text segment.
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-split-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-split-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-split-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-split-234
  prefs: []
  type: TYPE_NORMAL
- en: GOT-indirect addressing can be optimized to absolute addressing for non-preemptible
    data in the text segment.
  id: totrans-split-235
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-split-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-split-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-split-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-split-240
  prefs: []
  type: TYPE_NORMAL
- en: This can be used for `SHN_ABS` and unresolved undefined weak symbols. With `-no-pie`
    linking, regular symbols are elligible for this optimization as well. However,
    linkers may choose not to implement this since the added complexity might outweigh
    the benefits.
  id: totrans-split-241
  prefs: []
  type: TYPE_NORMAL
- en: 'RISC-V FDPIC: thread-local storage'
  id: totrans-split-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To handle TLSDESC, we introduce a new relocation type: `R_RISCV_TLSDESC_GPREL_HI`.
    This type instructs the linker to find or create two GOT entries unless optimized
    to local-exec or init-exec. The combined hi20 and lo12 offsets compute the GP-relative
    offset to the first GOT entry.'
  id: totrans-split-243
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-split-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-split-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-split-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-split-248
  prefs: []
  type: TYPE_NORMAL
- en: Existing relocation types, `R_RISCV_TLSDESC_LOAD_LO12` and `R_RISCV_TLSDESC_ADD_LO12`,
    are extended to work with `R_RISCV_TLSDESC_GPREL_HI`.
  id: totrans-split-249
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-split-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|'
  id: totrans-split-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-split-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-split-254
  prefs: []
  type: TYPE_NORMAL
- en: 'For initial-exec TLS model, we need a new pseudoinstruction, say, `la.tls.ie.fd
    rX, sym`. It expands to:'
  id: totrans-split-255
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-split-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|'
  id: totrans-split-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-split-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|'
  id: totrans-split-260
  prefs: []
  type: TYPE_NORMAL
- en: Stefan's scheme defines `R_RISCV_PIC_LO12_I` as an alias for `R_RISCV_PCREL_LO12_I`.
    Since the symbol is GP-relative instead of PC-relative, avoiding `PCREL` in the
    relocation type name makes sense.
  id: totrans-split-261
  prefs: []
  type: TYPE_NORMAL
- en: Stefan's 11-type scheme adds `R_RISCV_PIC_ADDR_LO12_I` to be associated with
    `ld rX, 0(rX)` instead. I have not yet figured out the reasoning.
  id: totrans-split-262
  prefs: []
  type: TYPE_NORMAL
- en: 'RISC-V FDPIC: `-fno-plt`'
  id: totrans-split-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regular [`-fno-plt`](/blog/2021-09-19-all-about-procedure-linkage-table#fno-plt)
    code loads the `.got.plt` entry using PC-relative addressing and performs an indirect
    branch. The FDPIC `-fno-plt` variant needs to load both the FDPIC register and
    the destination address.
  id: totrans-split-264
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-split-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|'
  id: totrans-split-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-split-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|'
  id: totrans-split-269
  prefs: []
  type: TYPE_NORMAL
- en: libc implementations with FDPIC support
  id: totrans-split-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: uclibc-ng supports AArch32, Blackfin, and FR-V.
  id: totrans-split-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: musl supports SuperH.
  id: totrans-split-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
