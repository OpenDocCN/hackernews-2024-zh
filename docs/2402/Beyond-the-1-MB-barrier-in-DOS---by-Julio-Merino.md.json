["```\n`Physical Address    CPU Register\n----------------    ------------\n0800h-0805h         None\n0806h-0807h         MSW\n0808h-0815h         None\n0816h-0817h         TR\n0818h-0819h         Flag word\n081Ah-081Bh         IP\n081Ch-081Dh         LDT\n081Eh-081Fh         DS\n0820h-0821h         SS\n0822h-0823h         CS\n0824h-0825h         ES\n0826h-0827h         DI\n0828h-0829h         SI\n082Ah-082Bh         BP\n082Ch-082Dh         SP\n082Eh-082Fh         BX\n0830h-0831h         DX\n0832h-0833h         CX\n0834h-0835h         AX\n0836h-083Bh         ES descriptor cache\n083Ch-0841h         CS descriptor cache\n0842h-0847h         SS descriptor cache\n0848h-084Dh         DS descriptor cache\n084Eh-0853h         GDTR\n0854h-0859h         LDT descriptor cache\n085Ah-085Fh         IDTR\n0860h-0865h         TSS descriptor cache`\n```", "```\n`;;; Null descriptor.\n                dq 0\n\n;;; Code descriptor for this binary.  The base address needs fixup at\n;;; runtime to point to the location where the code was loaded.\nCODE_DESC       equ 1 << 3\n                dw 0ffffh       ; Low 16 bits of the limit.\ncode_base_low   dw 0            ; Low 16 bits of the base address.\ncode_base_mid   db 0            ; Middle 8 bits of the base address.\n                db 10011110b    ; Code/data, exec, conforming, read allowed.\n                db 00000000b    ; Not 4KB, 16-bit, no long mode, limit 00h.\ncode_base_high  db 0            ; High 8 bits of the base address.\n\n;;; Data/stack descriptor for this binary.  The base address needs fixup\n;;; at runtime to point to the location where the code was loaded.\nDATA_DESC       equ 2 << 3\n                dw 0ffffh       ; Low 16 bits of the limit.\ndata_base_low   dw 0            ; Low 16 bits of the base address.\ndata_base_mid   db 0            ; Middle 8 bits of the base address.\n                db 10010010b    ; Code/data, data, grows up, read-write.\n                db 00000000b    ; Not 4KB, 16-bit, no long mode, limit 00h.\ndata_base_high  db 0            ; High 8 bits of the base address.\n\n;;; Linear data descriptor covering the full 4 GB address space.  No fixup\n;;; necessary.\nLINEAR_DESC     equ 3 << 3\n                dw 0ffffh       ; Low 16 bits of the limit.\n                dw 0            ; Low 8 bits of the base address.\n                db 0            ; Middle 8 bits of the base address.\n                db 10010010b    ; Code/data, data, grows up, read-write.\n                db 11001111b    ; 4KB, 16-bit, no long mode, limit=0fh.\n                db 0            ; High 8 bits of the base address.`\n```", "```\n`gdt_desc        equ $-gdt\ngdt_base        dd 0`\n```", "```\n `;; Assume CS = DS = ES = SS (COM file or boot sector).\n    mov [real_cs], cs\n\n    ;; Populate the GDT code and data descriptors with our actual base address\n    ;; so that the built-in code offsets work once we enter protected mode.\n    xor eax, eax\n    mov ax, cs\n    shl eax, 4\n    mov [code_base_low], ax\n    mov [data_base_low], ax\n    shr eax, 16\n    mov [code_base_mid], al\n    mov [data_base_mid], al\n    mov [code_base_high], ah\n    mov [data_base_high], ah\n\n    ;; Populate the GDT descriptor with the linear address of the GDT.\n    xor eax, eax\n    mov eax, ds\n    shl eax, 4\n    add eax, gdt\n    mov [gdt_base], eax`\n```", "```\n `;; Disable the Non-Maskable Interrupt (NMI) and interrupts.\n    in al, 70h\n    or al, 80h\n    out 70h, al\n    in al, 71h\n    cli\n\n    ;; Enable the A20 gate.\n    in al, 92h\n    or al, 2\n    out 92h, al`\n```", "```\n `;; Load the GDT.\n    lgdt [gdt_desc]\n\n    ;; Enable protected mode.\n    mov eax, cr0\n    or eax, 1\n    mov cr0, eax\n\n    ;; Flush out the processor pipeline and reload CS.\n    jmp CODE_DESC:protected_mode`\n```", "```\n`protected_mode:\n    ;; Set up the data and stack segments.\n    mov ax, DATA_DESC\n    mov ds, ax\n    mov ss, ax`\n```", "```\n `;; Store a message in extended memory.  We are in protected mode so this\n    ;; works by design.\n    mov ax, LINEAR_DESC         ; Load the linear address space in ES.\n    mov es, ax\n    mov esi, msg                ; Point DS:[ESI] to our message.\n    mov edi, EXTENDED_ADDR      ; Point ES:[EDI] to extended memory.\n    mov ecx, MSGLEN\n    o32 rep movsb               ; Must use 32-bit addressing.`\n```", "```\n `;; Set up FS as an \"unreal mode\" segment.\n    mov ax, LINEAR_DESC\n    mov fs, ax\n    ;; ... but restore ES to have standard real mode limits.  Not strictly\n    ;; necessary but helps to prove our example.\n    mov ax, DATA_DESC\n    mov es, ax`\n```", "```\n `;; Disable protected mode.\n    mov eax, cr0\n    and eax, ~1\n    mov cr0, eax\n\n    ;; And now return to real mode with a far jump.\n    pushf\n    push word [real_cs]\n    push unreal_mode\n    iret`\n```", "```\n`unreal_mode:\n    ;; Reload real mode COM segment layout.\n    mov bx, cs\n    mov ds, bx\n    mov es, bx\n    mov ss, bx`\n```", "```\n `;; Reenable the NMI and interrupts.\n    sti\n    in al, 70h\n    and al, 7fh\n    out 70h, al\n    in al, 71h`\n```", "```\n `;; Fetch the message from extended memory by using a large offset.  This\n    ;; would not work in real mode or VM86 (even with 32-bit addressing), but\n    ;; does because we are actually in unreal mode.\n    xor ax, ax                  ; Clear FS to show its high limits remain.\n    mov fs, ax\n    mov esi, EXTENDED_ADDR      ; Point FS:[ESI] to extended memory.\n    mov edi, msgcopy            ; Point ES:[EDI] to our buffer.\n    mov ecx, MSGLEN\n    o32 fs rep movsb            ; Must use 32-bit addressing.`\n```", "```\n `;; Print the message we fetched from extended mode.\n    mov ah, 40h\n    mov bx, 1\n    mov cx, MSGLEN\n    mov dx, msgcopy             ; Remember this was all ... at first!\n    int 21h\n\n    ;; And jump back to DOS.\n    mov ax, 4c00h\n    int 21h`\n```", "```\n`<bochs:2> sreg\nes:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=7\n        Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed\ncs:0x000f, dh=0x00009300, dl=0x00f0ffff, valid=3\n        Data segment, base=0x000000f0, limit=0x0000ffff, Read/Write, Accessed\nss:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=7\n        Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed\nds:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=3\n        Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed\nfs:0x0000, dh=0x00cf9300, dl=0x0000ffff, valid=11\n        Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed\ngs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7\n        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed\nldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1\ntr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1\ngdtr:base=0x0000000000011c72, limit=0x20\nidtr:base=0x0000000000000000, limit=0x3ff`\n```", "```\n`nasm -o unreal.com unreal.asm`\n```", "```\n`C:\\>DOOM\nDOS/4GW Protected Mode Run-time  Version 1.97\nCopyright (c) Rational Systems, Inc. 1990-1994`\n```"]