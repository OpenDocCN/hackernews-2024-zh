["```\nfunction extendedEuclidean(a, b) {\n    // Base cases\n    if (a === 0) {\n        return [b, 0, 1];\n    }\n\n    let [gcd, x1, y1] = extendedEuclidean(b % a, a);\n\n    // Calculate x and y using results of recursive call\n    let x = y1 - Math.floor(b / a) * x1;\n    let y = x1;\n\n    return [gcd, x, y];\n}\n\nfunction modularInverse(a, m) {\n    let [gcd, x, y] = extendedEuclidean(a, m);\n    if (gcd !== 1) {\n        // Modular inverse does not exist if gcd(a, m) != 1\n        return null;\n    } else {\n        // Ensure x is positive\n        x = (x % m + m) % m;\n        return x;\n    }\n}\n\nfunction modularExponentiation(base, exponent, modulus) {\n    if (modulus === 1) return 0;\n\n    let result = 1;\n    base = base % modulus; // Reduce base modulo modulus to handle large base values efficiently\n\n    while (exponent > 0) {\n\n        if (exponent % 2 === 1) {\n            result = (result * base) % modulus;\n        }\n\n        exponent = Math.floor(exponent / 2);\n        base = (base * base) % modulus;\n    }\n\n    return result;\n}\n\nfunction generateRSAKeys(p, q) {\n    let n = p * q;\n    let lambdaN = lcm(p - 1, q - 1);\n    let e = 65537;\n    let d = euclideanAlgorithm(e, lambdaN)[0];\n    if (d < 0) d += lambdaN;\n    return { publicKey: { e, n }, privateKey: { d, n } };\n}\n\nfunction encrypt(message, publicKey) {\n    return modularExponentiation(message, publicKey.e, publicKey.n);\n}\n\nfunction decrypt(ciphertext, privateKey) {\n    return modularExponentiation(ciphertext, privateKey.d, privateKey.n);\n}\n\n// Testing\nlet keys = generateRSAKeys(31337, 31357);\nlet publicKey = keys.publicKey;\nlet privateKey = keys.privateKey;\nlet message = 80087;\nlet encrypted = encrypt(message, publicKey);\nlet decrypted = decrypt(encrypted, privateKey);\n\nconsole.log(decrypted);\n```"]