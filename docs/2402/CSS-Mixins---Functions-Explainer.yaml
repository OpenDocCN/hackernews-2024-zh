- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 14:49:17'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:49:17'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: CSS Mixins & Functions Explainer
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS Mixins & Functions Explainer
- en: 来源：[https://css.oddbird.net/sasslike/mixins-functions/](https://css.oddbird.net/sasslike/mixins-functions/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://css.oddbird.net/sasslike/mixins-functions/](https://css.oddbird.net/sasslike/mixins-functions/)
- en: <main><details data-alert="note" open=""><summary>Note:</summary></details>
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: <main><details data-alert="note" open=""><summary>注意：</summary></details>
- en: Author
  id: totrans-split-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作者
- en: Miriam Suzanne
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: Miriam Suzanne
- en: (Based heavily on a custom-function proposal by Tab Atkins)
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: （基于 Tab Atkins 提出的自定义函数提案）
- en: Intro
  id: totrans-split-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: 'In order to reduce code repetition, ensure consistency across a project, and
    encourage best practice, authors have often turned to third-party CSS pre-processors
    (Sass, Less, PostCSS, Stylus, etc) to define custom reusable ‘macros’. These generally
    fall into two categories:'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少代码重复，确保项目中的一致性，并鼓励最佳实践，作者们通常转向第三方 CSS 预处理器（如 Sass、Less、PostCSS、Stylus 等）来定义自定义可重用的“宏”。这些通常分为两个类别：
- en: '**Functions** return CSS *values* – like a string, color, or length. They can
    only be used *inside* the value space of a CSS property.'
  id: totrans-split-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Functions** 返回 CSS *值* - 如字符串、颜色或长度。它们只能在 CSS 属性的*值空间内*使用。'
- en: '**Mixins** return CSS *declarations* or entire *rule blocks*. They can only
    be used *outside* the value space of a CSS property.'
  id: totrans-split-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mixins** 返回 CSS *声明* 或整个 *规则块*。它们只能用于 CSS 属性的*值空间之外*。'
- en: 'CSS already provides a wide range of built-in functions, such as `calc()`,
    `minmax()`, and many more. Ideally, custom functions would work in a similar way,
    but prefixed with a dashed-ident to avoid future compatibility issues. For a simple example:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 已经提供了广泛的内置函数，例如 `calc()`、`minmax()` 等等。理想情况下，自定义函数将以类似的方式工作，但会使用破折号标识以避免未来的兼容性问题。举个简单的例子：
- en: '[PRE0]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'CSS does not yet have built-in mixins, though several have been proposed in
    discussions of this feature. A simple mixin might look something like this:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 目前尚未内置混合，尽管在讨论此功能时提出了几个建议。一个简单的混合可能看起来像这样：
- en: '[PRE1]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Discussion
  id: totrans-split-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'There are several other relevant discussions in the CSS Working Group, that
    predate this proposal:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CSS 工作组中还有几个与此提案前置的讨论：
- en: (If there are more I haven’t found, please [let me know](https://github.com/oddbird/css-sandbox/issues).)
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: （如果我还没有找到更多，请 [告诉我](https://github.com/oddbird/css-sandbox/issues)。）
- en: Summary & Goals
  id: totrans-split-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结与目标
- en: 'Features often change as they move from (generally imperative) pre-processors
    into CSS – taking on different affordances and constraints appropriate for a declarative,
    client-side language:'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着它们从（一般为命令式的）预处理器进入 CSS，功能通常会发生变化 - 采用适合声明式、客户端语言的不同功能和约束：
- en: How would CSS-native mixins and functions differ from pre-processors?
  id: totrans-split-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 原生混合和函数与预处理器有何不同？
- en: What extra functionality or limitations come from providing these features in
    the browser?
  id: totrans-split-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中提供这些功能会带来什么额外的功能或限制？
- en: From a language/implementation perspective mixins and functions are entirely
    distinct features – they live at different levels of the syntax, and come with
    different complications. If we pursue both, we likely want to define them at different
    levels of a specification, or even in different specifications.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从语言/实现的角度来看，混合和函数是完全不同的功能 - 它们存在于语法的不同级别，并带有不同的复杂性。如果我们同时追求这两者，我们可能希望在规范的不同级别定义它们，甚至在不同的规范中。
- en: 'Removing the reliance on pre-processors would further simplify maintenance
    for CSS authors, while providing new client-side functionality:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 消除对预处理器的依赖将进一步简化 CSS 作者的维护工作，同时提供新的客户端功能：
- en: Passing cascaded custom-properties as arguments.
  id: totrans-split-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将级联自定义属性传递作为参数。
- en: Adding media/support and other client-side conditions.
  id: totrans-split-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加媒体/支持和其他客户端条件。
- en: My goal here is to explore what would be possible with each feature, where we
    could re-use syntax between them, and how we might move forward with implementing them.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里的目标是探索每个功能的可能性，我们可以在它们之间重复使用语法，并且我们如何推进它们的实现。
- en: I am not expecting this to be the final shape for either feature, but I want
    to capture the state of the conversation, and help move it forward. If these features
    are officially adopted by the working group, further development can be broken
    into individual specs and issues.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不期望这对任一功能来说是最终形态，但我希望捕捉对话的状态，并推动其进展。如果这些功能被工作组正式采纳，进一步的开发可以拆分为单独的规范和问题。
- en: Author Interest
  id: totrans-split-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作者兴趣
- en: 'There is some (incomplete) data from the HTTP Archive project that can help
    us understand how authors are using Sass currently:'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 来自HTTP存档项目的一些（不完整）数据可以帮助我们了解作者当前如何使用Sass：
- en: 'I also ran a small [survey on Mastodon](https://front-end.social/@mia/110833306689188274):'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在Mastodon上进行了一项小的[调查](https://front-end.social/@mia/110833306689188274)：
- en: “What are the most common custom functions or mixins that you define/use in
    a css pre-processor?”
  id: totrans-split-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “在CSS预处理器中，您定义/使用的最常见的自定义函数或mixin是什么？”
- en: 'The answers included:'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 答案包括：
- en: (Functions) Conversion from pixel to `rem` units
  id: totrans-split-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (Functions) 将像素转换为 `rem` 单位
- en: (Functions) random number generators
  id: totrans-split-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (Functions) 随机数生成器
- en: (Functions) Color contrast
  id: totrans-split-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (Functions) 颜色对比度
- en: (Mixins) Named shorthands for common media queries
  id: totrans-split-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (Mixins) 命名常见媒体查询的简写
- en: (Mixins) Generating output from object for-each loops (like Sass Maps)
  id: totrans-split-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (Mixins) 从对象的forEach循环生成输出（如Sass Maps）
- en: (Mixins) Reusable component styles
  id: totrans-split-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (Mixins) 可重用的组件样式
- en: (Mixins) Complex solutions, like scroll-shadows or gradient text
  id: totrans-split-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (Mixins) 复杂的解决方案，如滚动阴影或渐变文本
- en: (Both) Fluid typography settings
  id: totrans-split-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (Both) 流体排版设置
- en: (Both) Complex `calc()` shorthands for various situations
  id: totrans-split-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (Both) 复杂的 `calc()` 简写，适用于各种情况
- en: Some of these would be possible to achieve in CSS with a declarative syntax,
    without additional new functionality. Others (like loops) would require imperative
    control structures.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些可以通过CSS的声明语法来实现，无需额外的新功能。其他一些（如循环）则需要命令式的控制结构。
- en: While some of these (like `random()`) are already being discussed for built-in
    functions, others (like `color-contrast()`) may be simpler to solve in user-space.
    It has been very difficult for the CSSWG to settle on a long-term solution for
    the entire platform, while an individual team would be more able to change their
    approach gradually over time. By capturing that logic in a single place (like
    a custom function), many changes could be made without any invasive re-write of
    the code base.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其中一些（如 `random()` ）已经在讨论内置函数中讨论，但其他一些（如 `color-contrast()` ）可能更简单地在用户空间中解决。对于整个平台，CSSWG很难达成长期解决方案，而单个团队则更能够随着时间逐渐改变其方法。通过在单一位置（如自定义函数）中捕捉该逻辑，可以在无需对代码基础进行任何侵入性重写的情况下进行许多更改。
- en: 'The ability to declare this logic in CSS rather than a pre-processor would
    provide several benefits:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在CSS中声明这种逻辑，而不是在预处理器中，将带来几个好处：
- en: '*Reduce the external dependencies* and build steps required in order to generate
    the code'
  id: totrans-split-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少生成代码所需的外部依赖项* 和构建步骤'
- en: '*Reduce the file size delivered* from the server (though this may be negligible
    after compression & increased client-side processing)'
  id: totrans-split-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少从服务器传送的文件大小*（尽管在压缩和增加客户端处理后可能是可以忽略的）'
- en: '*use custom properties as arguments* so that the mixins or functions could
    respond to changes in the cascade'
  id: totrans-split-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用自定义属性作为参数*，使mixin或函数能够响应级联变化'
- en: '*use media/container/support conditions* as part of the internal logic'
  id: totrans-split-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将媒体/容器/支持条件*作为内部逻辑的一部分'
- en: Defining parameters
  id: totrans-split-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义参数
- en: 'Both functions and mixins rely on a `<parameter-list>` syntax. Each `<parameter>`
    in the `<parameter-list>` consists of three parts:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和mixin都依赖于 `<parameter-list>` 语法。 `<parameter-list>` 中的每个 `<parameter>` 都由三个部分组成：
- en: '`<name>` (required) which is a `dashed-ident`'
  id: totrans-split-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<name>`（必需），是`dashed-ident`'
- en: '`<syntax>` (default: `*`) similar to the `syntax` descriptor in `@property`'
  id: totrans-split-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<syntax>`（默认：`*`），类似于`@property`中的`syntax`描述符'
- en: '`<default-value>` (default: `guaranteed invalid`) which is any value that matches
    the syntax'
  id: totrans-split-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<default-value>`（默认：`guaranteed invalid`），即匹配语法的任何值'
- en: Defining all three aspects in the function prelude (name, type, and default)
    can make the syntax over-complicated. My initial proposal included special `@property`-like
    descriptor blocks to make that possible.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数开头定义这三个方面（名称、类型和默认值）可能会使语法过于复杂化。我的最初提案包括特殊的类似于`@property`的描述块，以实现这一点。
- en: Since then, the discussion has moved towards a more concise approach using a
    comma-separated list.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 自那时以来，讨论已经转向了使用逗号分隔列表的更简洁的方法。
- en: 'Authors can provide names only:'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作者只能提供名称：
- en: '[PRE2]'
  id: totrans-split-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Optionally, they can also provide a default value:'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，它们还可以提供一个默认值：
- en: '[PRE3]'
  id: totrans-split-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <details data-alert="note" open=""><summary>Note:</summary></details>
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: <details data-alert="note" open=""><summary>注：</summary></details>
- en: 'Finally, authors could define a syntax for any parameter, using the `type()`
    function along side the name. This would work with or without default values:'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作者可以定义任何参数的语法，使用 `type()` 函数并与名称一起。这将适用于有或无默认值的情况：
- en: '[PRE4]'
  id: totrans-split-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Defining a function: the `@function` rule'
  id: totrans-split-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数：`@function` 规则
- en: 'In order to define a custom function, we need several bits of information:'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个自定义函数，我们需要几个信息：
- en: '`function-name` (required)'
  id: totrans-split-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function-name`（必需）'
- en: '`parameter-list` (optional - see above)'
  id: totrans-split-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameter-list`（可选 - 参见上文）'
- en: Some amount of internal logic using `function-rules`
  id: totrans-split-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`function-rules`的一些内部逻辑
- en: A returned `result` value
  id: totrans-split-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的`result`值
- en: 'The proposed syntax (with a few adjustments) could look something like:'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 提议的语法（稍作调整）可能看起来像这样：
- en: '[PRE5]'
  id: totrans-split-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `function-name` is a dashed-ident. If multiple functions have the same name,
    then functions in a higher cascade layer take priority, and functions defined
    later have priority within a given cascade layer. This matches the behavior of
    other name-defining at-rules.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`function-name`是一个虚线标识符。如果多个函数具有相同的名称，则较高层级中的函数具有优先权，并且在给定级联层内后定义的函数具有优先权。这与其他定义名称的at-rules的行为相匹配。'
- en: It may also be useful to define an intended ‘return type’ (e.g. `color` or `length`)
    for the function, so that it can be validated at parse time. Like custom properties,
    there is still a chance that a function’s output will be *invalid at computed
    value time*, but we can at least ensure that the function is intended to return
    an appropriate syntax for the context where it is being called.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个预期的“返回类型”（例如`color`或`length`）可能也会很有用，这样可以在解析时进行验证。与自定义属性类似，函数的输出在计算值时仍然可能是*无效的*，但我们至少可以确保函数意图返回适合调用上下文的合适语法。
- en: 'Extending the above syntax, I would imagine re-using the `type()` function
    in the prelude:'
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展上述语法，我想象在序文中重复使用`type()`函数：
- en: '[PRE6]'
  id: totrans-split-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I would expect `<syntax>` to allows the same [subset of CSS Types](https://developer.mozilla.org/en-US/docs/Web/CSS/@property/syntax#values)
    provided by the `syntax` descriptor of the `@property` rule. Maybe it would be
    possible to remove the requirement for quotes around a syntax in this context?
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我期望`<syntax>`允许与`@property`规则的`syntax`描述符提供的CSS类型的相同子集。也许在这种情况下可以去掉语法周围的引号要求？
- en: Returning values
  id: totrans-split-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: 'There have been several syntax options discusses for returning a `<result>`
    value, but it seems to me like the simplest and most familiar would be a descriptor
    called something like `result` or `output`. This would help re-enforce the declarative
    nature of functions, since it can be treated similar to other declarations: the
    last `result` is used if multiple are present.'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了几种语法选项以返回`<result>`值，但我觉得最简单和最熟悉的可能是类似`result`或`output`的描述符。这将有助于加强函数的声明性质，因为它可以像其他声明一样处理：如果有多个声明，则使用最后一个`result`。
- en: 'Like custom properties:'
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义属性类似：
- en: The `<result>` can contain any valid CSS value-space syntax
  id: totrans-split-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<result>`可以包含任何有效的CSS值空间语法'
- en: This value has `invalid at computed value time` behavior
  id: totrans-split-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此值在计算值时间为`invalid at computed value time`
- en: Since functions exist in the value space, `<function-rules>` will not contain
    any other (non-custom) CSS properties, so the single `result` descriptor should
    stand out. If multiple results are encountered, the last result takes precedence
    (consistent with other descriptors and properties). This is discussed in more
    detail below.
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数存在于值空间中，`<function-rules>`将不包含任何其他（非自定义）CSS属性，因此单个`result`描述符应该很显眼。如果遇到多个结果，则最后一个结果优先（与其他描述符和属性一致）。这在下文中详细讨论。
- en: <details data-alert="note" open=""><summary>Note:</summary></details>
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: <details data-alert="note" open=""><summary>注意：</summary></details>
- en: Function rules
  id: totrans-split-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数规则
- en: The `<function-rules>` can include custom property declarations (which are scoped
    to the function), as well as conditional at-rules (which may contain further nested
    custom properties and `result`s). Element-specific conditions (such as container
    queries) would be resolved for each element that calls the function.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`<function-rules>`可以包括自定义属性声明（这些属性的作用域限定为函数内部），以及条件性at-rules（可能包含进一步嵌套的自定义属性和`result`）。元素特定的条件（如容器查询）将为调用该函数的每个元素解析。'
- en: My assumption would be that custom properties defined inside the function are
    not available on elements where the function is called. However, it’s clear that
    authors will expect to reference external custom properties from inside functions
    – using some variation of dynamic scope, and ‘shadowing’ behavior.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我的假设是，在函数内定义的自定义属性在调用该函数的元素上不可用。然而，作者们显然期望从函数内部引用外部自定义属性 - 使用某种动态范围的变体和“阴影”行为。
- en: As far as I can tell, only custom properties, args/variables, and conditional
    rules are useful inside a function definition. Functions have no output besides
    their returned value, so nested selectors, built-in properties, and name-defining
    rules are not necessary or meaningful. I don’t think there’s any need for these
    things to invalidate the entire function, but they should be ignored and discarded.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 据我所知，仅在函数定义内部有用的是自定义属性、参数/变量和条件规则。函数除了返回值外没有输出，因此嵌套选择器、内置属性和命名规则都是不必要或无意义的。我认为这些东西没有必要使整个函数无效，但应该被忽略和丢弃。
- en: 'An example function using conditional rules to return one of multiple values:'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件规则返回多个值的示例函数：
- en: '[PRE7]'
  id: totrans-split-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some functions will also want access to contextual variables on the calling
    elements. To avoid fully dynamic scoping of custom properties, Tab has proposed
    a second list of properties that should be available in the function:'
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数还希望从调用元素的上下文变量中获取访问权限。为了避免完全动态作用域的自定义属性，Tab建议在函数中提供第二个属性列表，这些属性应该在函数中可用：
- en: '[PRE8]'
  id: totrans-split-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <details data-alert="note" open=""><summary>Note:</summary></details>
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: <details data-alert="note" open=""><summary>注意：</summary></details>
- en: Calling functions
  id: totrans-split-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'Custom functions can be called from the value space of any property, with the
    name of the functions, followed by parenthesis and a comma-separated list of arguments:'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从任何属性的值空间调用自定义函数，函数的名称后跟括号和逗号分隔的参数列表：
- en: '[PRE9]'
  id: totrans-split-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we do (eventually) want to support named arguments, it would ideally use
    a familiar declaration syntax:'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们（最终）希望支持命名参数，最好使用熟悉的声明语法：
- en: '[PRE10]'
  id: totrans-split-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If positional and named arguments are allowed in the same function call, the
    common convention is to require all positional values come before any named values
    to avoid confusion:'
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许在同一函数调用中使用位置和命名参数，则常见约定是要求所有位置值位于任何命名值之前，以避免混淆：
- en: '[PRE11]'
  id: totrans-split-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need to allow a broad syntax for argument values – including values that
    contain commas. There’s an active discussion about the best way to handle this
    more generally in [issue #9539](https://github.com/w3c/csswg-drafts/issues/9539).
    Custom functions should use whatever solution is agreed on there.'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要允许广泛的参数值语法 - 包括包含逗号的值。关于如何更普遍地处理这个问题，有一个关于最佳处理方式的活跃讨论 [issue #9539](https://github.com/w3c/csswg-drafts/issues/9539)。自定义函数应使用那里商定的任何解决方案。'
- en: Putting it all together
  id: totrans-split-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容组合在一起
- en: 'Adapting the fluid ratio function above to the proposed syntax:'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述流体比率函数适应建议的语法：
- en: '[PRE12]'
  id: totrans-split-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We could also consider moving the `mix()` logic into the function:'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以考虑将`mix()`逻辑移入函数中：
- en: '[PRE13]'
  id: totrans-split-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Defining a mixin: the `@mixin` rule'
  id: totrans-split-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个mixin：`@mixin`规则
- en: Rather than returning a single value, mixins return entire declarations and
    potentially entire nested rule blocks. While much of the function syntax could
    be re-purposed, we would need an additional way to manage property scoping – clearly
    marking what rule blocks are internal, and which should be part of the output.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: mixins不仅返回单个值，还返回整个声明和潜在的整个嵌套规则块。虽然可以重用大部分函数语法，但我们需要一种额外的方式来管理属性作用域 - 明确标记哪些规则块是内部的，哪些应该是输出的一部分。
- en: '[PRE14]'
  id: totrans-split-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again, when there are multiple mixins that use the same name, the last mixin
    with that name takes precedence.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，当存在多个使用相同名称的mixin时，具有该名称的最后一个mixin占优势。
- en: Mixin rules and output
  id: totrans-split-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mixin规则和输出
- en: 'The simplest approach to nested rules and output would be to treat the inside
    of a mixin definition the same as any rule-block nested context. Anything we can
    put inside a rule block can be put inside a mixin, and will be output where the
    mixin is called (with any parameters being replaced first). This will work for
    many simpler cases:'
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 处理嵌套规则和输出的最简单方法是将mixin定义内部视为任何规则块嵌套上下文。我们可以放置在规则块中的任何东西都可以放置在mixin中，并且将在调用mixin时输出（首先替换任何参数）。这对于许多更简单的情况都适用：
- en: '[PRE15]'
  id: totrans-split-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-split-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This approach doesn’t allow the mixin to contain any internal logic scoped to
    the mixin itself. Mixins should be able to use internally scoped custom-properties,
    and also optionally *output* custom properties as part of the returned rule block.
    As things stand, this doesn’t seem relevant to anything other than custom properties.
    Built-in properties, selectors, and at-rules are only useful for their output.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不允许mixin包含任何仅作用于mixin本身的内部逻辑。Mixin应能够使用内部作用域的自定义属性，并且作为返回的规则块的一部分可选地*输出*自定义属性。在目前的情况下，这似乎与除自定义属性外的任何内容都无关。内置属性、选择器和at-rules仅对其*输出*有用。
- en: Given that this issue is specific to custom properties, we could consider a
    flag such as `!private`. That flag could be interesting for custom properties
    in other contexts, but I won’t follow that path unless there’s interest. Alternatively,
    we could explicitly mark blocks of content with either `@output` or `@private`
    at-rules.
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这个问题特定于自定义属性，我们可以考虑一个标志，比如`!private`。该标志对于其他上下文中的自定义属性可能很有趣，但除非有兴趣，我不会沿着这条路走。或者，我们可以明确地用`@output`或`@private`规则标记内容块。
- en: 'Applying mixins: the (new) `@apply` rule'
  id: totrans-split-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用mixin：（新的）`@apply`规则
- en: 'In order to apply a mixin, we use an `@apply` rule:'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用一个mixin，我们使用一个`@apply`规则：
- en: '[PRE17]'
  id: totrans-split-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `<argument-list>` syntax should ideally match the function argument notation.
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`<argument-list>`语法应该理想地匹配函数参数的表示法。'
- en: 'When the mixin is resolved, the output of the mixin is inserted where the apply
    rule was called:'
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当mixin解析时，mixin的输出将插入到调用apply规则的位置：
- en: '[PRE18]'
  id: totrans-split-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is an additional question about how to handle mixin output at the top
    level of the document (not nested inside a selector):'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个额外的问题，关于如何处理文档顶层（不是嵌套在选择器内部）的mixin输出：
- en: '[PRE19]'
  id: totrans-split-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As long as there is a selector wrapping the output, this should not be an issue.
    Even if that selector is simply the parent reference `&`, that has a well-defined
    behavior at the top level of documents – referring to the current `:scope`. However,
    if the result is bare declarations without any selector, they should be discarded
    and ignored.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有一个包装输出的选择器，这不应该是一个问题。即使该选择器只是父级引用`&`，在文档的顶层具有明确定义的行为——指的是当前`:scope`。然而，如果结果是裸声明而没有任何选择器，它们应该被丢弃和忽略。
- en: 'Another example, from a Sass mixin I’ve used on occasion:'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，来自我偶尔使用的一个Sass mixin：
- en: '[PRE20]'
  id: totrans-split-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Layers of complexity
  id: totrans-split-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂度的层次
- en: The popular Sass functions and mixins demonstrate a range of different input
    needs, from relatively static shorthands, to fully imperative control structures.
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的Sass函数和mixin展示了一系列不同的输入需求，从相对静态的速记法到完全命令控制结构。
- en: Simple shorthands
  id: totrans-split-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的速记法
- en: A `clearfix` mixin often has no exposed ‘parameters’, and no internal logic.
    When the mixin is invoked, it will output the same code every time. This is useful
    for maintaining DRY code (Don’t Repeat Yourself),
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearfix` mixin通常没有公开的‘参数’和内部逻辑。当调用mixin时，它每次都会输出相同的代码。这对于保持DRY代码（不要重复你自己）非常有用，'
- en: 'Static mixins like this end up very similar to ‘utility classes’ such as `.clearfix`.
    However, mixins still have the advantage that they can be applied in CSS, rather
    than HTML. The need for CSS control comes into focus when combined with `@media`/`@container`
    and other conditional logic. There is currently no way in CSS to write this code
    without defining all the custom properties twice:'
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种静态mixin最终与‘实用类’如`.clearfix`非常相似。然而，mixin仍然具有在CSS中应用而不是HTML中的优势。当与`@media`/`@container`和其他条件逻辑结合时，CSS控制的需求变得尤为重要。目前在CSS中没有办法写这段代码而不是两次定义所有自定义属性：
- en: '[PRE21]'
  id: totrans-split-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Most of the existing proposals around this use-case would combine conditional
    logic with selector logic, so that both can be defined at once. In Sass, we might
    fix this instead by providing a `dark-mode` mixin that can be used multiple times
    to output the same declarations with only minimal repetition:'
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种用例的大多数现有提案将条件逻辑与选择器逻辑结合在一起，以便同时定义两者。在Sass中，我们可以通过提供一个`dark-mode` mixin来修复这个问题，该mixin可以多次使用以仅仅最小重复输出相同的声明：
- en: '[PRE22]'
  id: totrans-split-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using Container Style Queries might also be an option here. They can be somewhat
    *mixin-like*, but come with all the limitations of container queries. If we set
    a custom property `--mode` on the root `html` element, we have to assign properties
    on a different element than we query:'
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器样式查询在这里也可能是一个选择。它们可以有点像*mixin*，但也带有所有容器查询的限制。如果我们在根`html`元素上设置自定义属性`--mode`，我们必须在不同的元素上分配属性，而不是我们查询的元素：
- en: '[PRE23]'
  id: totrans-split-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That can cause several problems:'
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致几个问题：
- en: There are optimizations and features specific to the root, that can’t be replicated
    on other elements.
  id: totrans-split-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些优化和特性特定于根，无法在其他元素上复制。
- en: In other component contexts, it’s likely to require extra markup.
  id: totrans-split-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他组件上下文中，可能需要额外的标记。
- en: While no-parameter mixins like these are somewhat common, it’s much less common
    to have a function without parameters, since a simple value can be captured in
    a variable or custom property instead.
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些无参数的mixin有些常见，但是没有参数的函数要少得多，因为简单值可以捕获在变量或自定义属性中。
- en: Built-in conditions
  id: totrans-split-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置条件
- en: 'It can also be useful to provide mixins that have no author-facing parameters,
    but still contain internal logic and conditional statements – using `@supports`,
    `@media`, or `@container`:'
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
  zh: 提供没有作者可见参数但仍包含内部逻辑和条件语句的混合物也可能非常有用，例如使用`@supports`、`@media`或`@container`：
- en: '[PRE24]'
  id: totrans-split-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A mixin like this might even reference external values by relying on custom
    properties without accepting explicit override parameters:'
  id: totrans-split-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类似这样的混合物甚至可以依赖于自定义属性而不接受显式的覆盖参数引用外部值：
- en: '[PRE25]'
  id: totrans-split-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Accepting parameters
  id: totrans-split-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受参数
- en: 'The most common reason to use a function or mixin is the ability to define
    parameters that alter the output based on different input. For example, a `darken()`
    function would accept two parameters: a color, and an amount to darken that color.'
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数或混合物的最常见原因是能够定义根据不同输入改变输出的参数。例如，一个`darken()`函数将接受两个参数：一个颜色和一个要加深该颜色的量。
- en: In many cases (like `darken()`) the internal function logic can be represented
    by an inline calculation using existing CSS features. In those situations, a custom
    function could still provide more concise and easy-to-use shorthand around a more
    complex `calc()` or relative color adjustment.
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下（如`darken()`），内部函数逻辑可以通过使用现有的CSS特性进行内联计算来表示。在这些情况下，自定义函数仍然可以提供更简洁易用的快捷方式，用于更复杂的`calc()`或相对颜色调整。
- en: Parameter conditions
  id: totrans-split-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数条件
- en: 'Once we allow both parameters and conditional logic, the next step would be
    to allow parameters to be used in the conditions themselves. For example:'
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们允许使用参数和条件逻辑，下一步将是允许在条件本身中使用参数。例如：
- en: '[PRE26]'
  id: totrans-split-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Imperative control flow
  id: totrans-split-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式控制流
- en: 'Some use-cases require more complex ‘flow control’ such as loops. For example,
    a combination of mixins might generate a full color-palette based on a single
    origin color. In Sass, it might looks something like this:'
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用例需要更复杂的“流控制”，如循环。例如，混合使用可能根据单个原始颜色生成完整的色板。在Sass中，可能看起来像这样：
- en: '[PRE27]'
  id: totrans-split-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The resulting output CSS would be:'
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出的CSS将是：
- en: '[PRE28]'
  id: totrans-split-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I think it would be reasonable to draw a boundary here, since CSS is a declarative
    language. Adding imperative flows would likely cause confusion around the execution model.
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在这里设定一个边界是合理的，因为CSS是一种声明性语言。添加命令式流程可能会导致执行模型上的混乱。
- en: Detailed discussion and open questions
  id: totrans-split-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细讨论和开放问题
- en: Other result syntaxes for functions
  id: totrans-split-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数的其他结果语法
- en: Both Lea and I have noted that it would be useful if authors could rely on cascade
    ‘order of appearance’ to provide ‘fallback’ return values. Sadly, however, that
    sort of parse-time fallback is not possible with dynamic computed-value-time features
    like custom properties or functions.
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我和Lea都注意到，如果作者可以依赖级联的“出现顺序”来提供“回退”返回值，这将非常有用。然而，遗憾的是，对于像自定义属性或函数这样的动态计算值时特性，这种解析时的回退是不可能的。
- en: 'I initially proposed an at-rule syntax (`@return`), arguing that:'
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初提议使用一个at-rule语法（`@return`），认为：
- en: It helps distinguish the final returned value from any internal logic like custom
    properties and nested rules
  id: totrans-split-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于区分最终返回的值与像自定义属性和嵌套规则这样的内部逻辑
- en: Result is not a property, but looks a lot like one
  id: totrans-split-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果不是一个属性，但看起来非常像一个
- en: However, `result` does act like a property in many ways, and would help to re-enforce
    our familiarity with declarative execution. While many imperative languages allow
    an ‘eager’ *first-takes-precedence* function return, CSS and other declarative
    languages generally uses a *last-takes-precedence* approach. For the same reason,
    we should avoid active words like `return` that suggest the evaluation is linear
    and can be cut short.
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`result`在很多方面确实像一个属性，并且有助于强化我们对声明性执行的熟悉感。虽然许多命令式语言允许“急切”地优先返回函数，CSS和其他声明性语言通常采用“后者优先”的方法。出于同样的原因，我们应该避免像`return`这样暗示评估是线性且可以被中断的积极词语。
- en: François Remy has proposed setting a custom property with the same name as the
    function, and that property is treated as the resulting value. Lea Verou suggested
    making the property name customizable in the prelude.
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
  zh: François Remy建议设置一个与函数同名的自定义属性，并将该属性视为结果值。Lea Verou建议在序言中使属性名可定制化。
- en: I prefer a syntax that is more consistent and reliable. I don’t see any utility
    that comes from allowing this functionality to be renamed in each function, or
    requiring that name to be determined by authors, or putting it in the author’s
    custom-ident name space. Those all seem to me like ways of inviting typos and
    confusion, without any clear gain.
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢一种更一致和可靠的语法。我没有看到任何允许每个函数中的此功能重命名或要求作者确定该名称的实用性，或将其放入作者自定义标识名称空间中的效益。这些对我来说似乎都是邀请拼写错误和混淆的方法，没有明显的收益。
- en: Matching the function name seems to me extra fragile – as you could never rename
    one without also updating the other. Still, either approach could work, and provide
    the same basic behavior. We can continue to bike-shed the details.
  id: totrans-split-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，匹配函数名称似乎过于脆弱——因为您永远无法重命名一个而不更新另一个。尽管如此，任一方法都可能有效，并提供相同的基本行为。我们可以继续对细节进行讨论。
- en: Passing nested content to mixins
  id: totrans-split-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将嵌套内容传递给混合器
- en: 'Another common feature of Sass mixins is the ability to pass nested content
    blocks into a mixin, and have the mixin place that content in a specific context.
    This seems like a feature that could be supported in CSS as well, but would require
    another mixin-specific at-rule (or similar placeholder). I’ll call it `@nested`
    for now:'
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
  zh: Sass混合器的另一个常见特性是能够将嵌套内容块传递到混合器中，并使混合器将该内容放置在特定的上下文中。这似乎是CSS中可以支持的功能，但需要另一个特定于混合器的at-rule（或类似的占位符）。我暂时称之为`@nested`：
- en: '[PRE29]'
  id: totrans-split-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The expected behavior would be the same as writing:'
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的行为应与以下写法相同：
- en: '[PRE30]'
  id: totrans-split-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This seems like something that could be added later, if necessary.
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，这似乎是可以稍后添加的东西。
- en: Invalid function fallbacks
  id: totrans-split-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无效函数回退
- en: Sadly, last-takes-precedence `@return` behavior doesn’t provide the same benefit
    here that it has in the cascade – where invalid declarations can be discarded
    at parse time, falling back on previously declared values. In order to achieve
    that, we would need to limit functions so that they are the only value in a property.
    I don’t think that tradeoff makes sense for the use-cases I’ve seen.
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，在这里，最后起作用的`@return`行为未能提供与级联相同的好处——在解析时可以丢弃无效声明，回退到先前声明的值。为了实现这一点，我们需要限制函数，使其成为属性中唯一的值。我认为这种权衡在我看到的用例中没有意义。
- en: I’m also not sure it makes sense to provide function-defined fallback values
    to return when arguments provided have invalid syntax. Ideally, function fallbacks
    would be modeled after variable fallbacks – established where the function is
    called, rather than where it is defined. It’s hard to see where this would fit
    in the proposed syntax.
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我也不确定在提供具有无效语法的参数时提供函数定义的回退值是否有意义。理想情况下，函数回退应该模仿变量回退——在调用函数的地方建立，而不是在定义函数的地方。很难看出这将适合提议的语法中的哪个位置。
- en: 'One option would be a `var()`-like wrapper function:'
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选项是类似于`var()`的包装函数：
- en: '[PRE31]'
  id: totrans-split-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We could even use the existing `var()`, but that would result in functions and
    custom properties sharing a single namespace, which might not be ideal. Maybe
    the proposed function for `first-supported()` would also be an option that has
    broader use? This likely needs more bike-shedding.
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用现有的`var()`，但这将导致函数和自定义属性共享单一命名空间，这可能不是理想的情况。也许`first-supported()`的提议函数也是一个具有更广泛用途的选项？这可能需要更多的讨论。
- en: Using parameters in conditional rules
  id: totrans-split-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在条件规则中使用参数
- en: 'Above, I used an example with conditional output using media queries inside
    the function. Authors may reasonably wish to take this farther and use parameters
    to define the media queries themselves:'
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我使用了一个在函数内部使用媒体查询进行条件输出的示例。作者可能希望进一步使用参数来定义媒体查询本身：
- en: '[PRE32]'
  id: totrans-split-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a very common use of pre-processor mixins, and a common use-case for
    the proposed inline `if()` and `media()` functions as well.
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预处理器混合器的一个非常常见的用法，也是提议的内联`if()`和`media()`函数的常见用例。
- en: As I understand it, that will not be possible as written above, for the same
    reasons `var()` is not currently allowed in media-query conditions. However, the
    issues are specific to cascaded values that need to be resolved at computed value
    time. Passing static arguments from a parameter should not pose the same problem.
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
  zh: 据我所理解，出于与当前不允许在媒体查询条件中使用`var()`相同的原因，按上述方式实现将不可能。然而，问题特定于需要在计算值时间解决的级联值。从参数传递静态参数不应造成相同的问题。
- en: 'If we had a new way of accessing values passed in – I’ll use `arg()` for the
    sake of argument – simple value substitution should be possible:'
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一种新的访问传入值的方式 - 我将使用`arg()`作为论点 - 简单的值替换应该是可能的：
- en: '[PRE33]'
  id: totrans-split-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the above example, the `padding` declaration would be valid since a static
    value can be passed along to the media query `arg()` – but the `margin` declaration
    would fail since it supplies a custom property to a media query condition.
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`padding`声明将是有效的，因为可以将静态值传递给媒体查询`arg()` - 但是`margin`声明将会失败，因为它向媒体查询条件提供了自定义属性。
- en: It’s not clear to me if parameters used this way would need to be explicitly
    marked in advance for any reason? As proposed here, it would be up to function
    authors to document and communicate which parameters can accept cascading variables,
    and which can not.
  id: totrans-split-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我不清楚参数是否需要提前明确标记任何原因？如本文所述，这将由函数作者来记录和传达哪些参数可以接受级联变量，哪些不能。
- en: Argument conditions and loops
  id: totrans-split-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数条件和循环
- en: 'With both mixins and functions it can be useful to have conditions based on
    the arguments passed in. For example, we might want to pass in one of several
    established keywords, and return a different value depending which keyword is used:'
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于混合物和函数，基于传入的参数进行条件判断可能很有用。例如，我们可能希望传入几个已建立的关键字之一，并根据使用的关键字返回不同的值：
- en: '[PRE34]'
  id: totrans-split-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It’s not clear to me if the proposed `@when`/`@else` features can be adapted
    to this use-case, or if it would need to be a distinct set of similar flow controls.
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我不清楚提议的`@when`/`@else`功能是否可以适应这种用例，或者是否需要一个类似流控制的独立集合。
- en: Similarly, as we saw in the tint-shade example earlier, it can be useful to
    loop over a set number of repetitions (for loop) or a set list of items (each loop).
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，正如我们在前面的色调示例中看到的那样，循环遍历一组重复次数（for循环）或一组项目列表（each循环）可能会很有用。
- en: While these would be helpful features for authors, they are not required for
    (or dependent on) an initial implementation of mixins or functions. They feel
    like distinct features that would go well together.
  id: totrans-split-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些对作者来说是有用的功能，但它们并不是混合物或函数的初始实施所必需的（或依赖的）。它们感觉像是可以很好地组合在一起的独特功能。
- en: Can we allow the `<calc-sum>` syntax?
  id: totrans-split-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们可以允许`<calc-sum>`语法吗？
- en: 'This question was raised by [Brandon McConnell](https://github.com/w3c/csswg-drafts/issues/7490#issuecomment-1256880496)
    in the ‘Declarative Custom Functions’ issue (see point 5, even though it’s not
    specific to recursion). The goal is to provide custom functions that take raw
    calc expressions, without being explicitly wrapped in a nested `calc()` function,
    similar to the way other math functions work:'
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题由[Brandon McConnell](https://github.com/w3c/csswg-drafts/issues/7490#issuecomment-1256880496)在‘声明性自定义函数’问题中提出（参见第5点，尽管它与递归无关）。目标是提供可以接受原始calc表达式的自定义函数，而不必显式地包装在嵌套的`calc()`函数中，类似于其他数学函数的工作方式：
- en: '[PRE35]'
  id: totrans-split-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On the one hand, custom property substitution makes it trivial to capture expressions,
    and later call them inside a `calc()` function. This already works:'
  id: totrans-split-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，自定义属性替换使得捕获表达式变得微不足道，并且稍后可以在`calc()`函数内调用它们。这已经可以工作：
- en: '[PRE36]'
  id: totrans-split-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To take it farther, we would need to expose the `<calc-sum>` grammar as a valid
    syntax for authors to use.
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步发展，我们需要将`<calc-sum>`语法公开为作者可以使用的有效语法。
- en: It might also be worth considering what other syntax/types would be useful to
    expose – either for parameters specifically, or for property registration more
    generally. It seems ideal to me if those lists can be kept in alignment.
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
  zh: 也许考虑到对参数特别有用的其他语法/类型也是值得的，或者更广泛地用于属性注册。如果这些列表能保持对齐，那对我来说似乎是理想的。
- en: What about `@extend`?
  id: totrans-split-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@extend`怎么样？'
- en: 'In Sass, mixins without parameters also overlap with the `@extend` feature,
    which is used to combine related classes – one as an ‘extension’ of the other.
    In most cases, that has the same intended result as a no-parameter-mixin:'
  id: totrans-split-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sass中，没有参数的混合物也与`@extend`功能重叠，用于组合相关类 - 其中一个作为另一个的‘扩展’。在大多数情况下，这与没有参数的混合物具有相同的预期结果：
- en: '[PRE37]'
  id: totrans-split-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The difference is that a class definition can be compiled from multiple rule
    blocks in different style sheets, while a mixin generally has one centralized
    definition. This is part of the reason extensions have become less common in Sass
    – it can be difficult to reason about their impact. For now, I think mixins would
    provide the similar functionality without the same complexity.
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于类定义可以从不同样式表中的多个规则块编译，而混合物通常有一个集中的定义。这是Sass中扩展变得不太常见的部分原因 - 很难理解它们的影响。目前来看，我认为混合物可以提供类似的功能而不会带来同样的复杂性。
- en: If we are interested in exploring `@extend` at some point, Tab has already written
    an [unofficial draft specification](http://tabatkins.github.io/specs/css-extend-rule/)
    that we can build from.
  id: totrans-split-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有兴趣在某个时候探索`@extend`，Tab已经撰写了一个[非官方草案规范](http://tabatkins.github.io/specs/css-extend-rule/)，我们可以依此构建。
- en: Can functions be chained, or call themselves?
  id: totrans-split-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数可以链式调用，或者调用自身吗？
- en: I would expect that it should be possible to chain function/mixin calls together.
    A theme-generating mixin should be able to reference a single-color generating
    mixin or function internally.
  id: totrans-split-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我期望应该可以将函数/混合物调用链在一起。一个生成主题的混合物应该能够在内部引用一个单色生成混合物或函数。
- en: It’s less clear to me if recursive function calls are possible or necessary.
    There are likely use-cases for recursion as a form of looping, but I’m not sure
    how central they are. This doesn’t seem like a feature requirement in level 1.
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，递归函数调用是否可能或必要不太清楚。循环的形式可能需要使用递归，但我不确定它们有多核心。在级别1中，这似乎不是一个功能要求。
- en: Keyframe-based mixins for interpolated values?
  id: totrans-split-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于关键帧的混合物用于插值数值？
- en: There has been a lot of recent discussion around [interpolating values between
    breakpoints](https://github.com/w3c/csswg-drafts/issues/6245#issuecomment-1715416464)
    for e.g. responsive typography. Conceptually, animation keyframes work well for
    defining the steps involved – but in this case the result is not technically animated,
    and interpolated values should ideally not be removed to the animation origin.
  id: totrans-split-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最近围绕[在断点之间插值数值](https://github.com/w3c/csswg-drafts/issues/6245#issuecomment-1715416464)进行了大量讨论，例如响应式排版。在概念上，动画关键帧很适合定义涉及的步骤
    - 但在这种情况下，结果在技术上并不是动画的，而且插值数值理想情况下不应该移动到动画的起点。
- en: To get around that, the most recent proposals involves a new property (tentatively
    `interpolate`) that would accept a keyframes name and timeline, then ‘expand in
    place’ to represent the declarations in the referenced `@keyframes` rule.
  id: totrans-split-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，最新的提案涉及一个新属性（暂定为`interpolate`），该属性将接受关键帧名称和时间线，然后‘原地扩展’以表示引用的`@keyframes`规则中的声明。
- en: '[PRE38]'
  id: totrans-split-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alan Stearns has pointed out in conversations that this is a very mixin-like
    behavior, and suggested treating keyframes as an existing form of mixin, rather
    than a new property. Given the same keyframes above, we could consider a syntax like:'
  id: totrans-split-216
  prefs: []
  type: TYPE_NORMAL
  zh: Alan Stearns在对话中指出，这是一种非常类似混合物的行为，并建议将关键帧视为混合物的一种现有形式，而不是一种新的属性。鉴于上述关键帧，我们可以考虑类似以下的语法：
- en: '[PRE39]'
  id: totrans-split-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If that clutters the mixin namespace, another approach might be requiring dashed-ident
    mixin names, and providing some built-in mixins such as:'
  id: totrans-split-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样会使混合物命名空间混乱，另一种方法可能是要求使用破折号标识混合物名称，并提供一些内置混合物，比如：
- en: '[PRE40]'
  id: totrans-split-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Prior art
  id: totrans-split-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先前的艺术
- en: The `@apply` Rule (abandoned)
  id: totrans-split-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@apply`规则（已废弃）'
- en: <details data-alert="note" open=""><summary>Links:</summary></details>
  id: totrans-split-222
  prefs: []
  type: TYPE_NORMAL
  zh: <details data-alert="note" open=""><summary>链接：</summary></details>
- en: 'At one point, there was a plan for custom properties to act as a form of mixin,
    using the `@apply` rule. That proposal was abandoned as the wrong approach for
    several related reasons:'
  id: totrans-split-223
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一个计划，即使用`@apply`规则，使自定义属性作为混合物的一种形式。由于几个相关的原因，该提案被放弃了：
- en: Custom properties are value-level syntax, while mixins are declaration-level
  id: totrans-split-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义属性是值级别的语法，而混合物是声明级别的
- en: It doesn’t make sense for mixin definitions to be passed around in the cascade
  id: totrans-split-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合物定义在级联中传递是没有意义的
- en: 'These are not difficult issues to avoid. I’m working from the premise that:'
  id: totrans-split-226
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这些问题并不困难。我是从以下前提出发工作的：
- en: Both function and mixins should be *defined* globally, and not rely on any element-aware
    aspects of the cascade.
  id: totrans-split-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和混合物都应该在全局范围内*定义*，而不依赖于级联中的任何元素感知方面。
- en: Similar to e.g. `@keyframes`, function and mixin definitions would still resolve
    name conflicts using global cascade features like *layers* and *order of appearance*.
  id: totrans-split-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与例如`@keyframes`类似，函数和混合物的定义仍然会使用全局级联特性如*层次*和*出现顺序*来解决名称冲突。
- en: Functions are applied in the *value* space, while mixins are applied in the
    *declaration* space.
  id: totrans-split-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应用于*值*空间，而混合物应用于*声明*空间。
- en: Container Style Queries (partially implemented)
  id: totrans-split-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器样式查询（部分实现）
- en: <details data-alert="note" open=""><summary>Links:</summary></details>
  id: totrans-split-231
  prefs: []
  type: TYPE_NORMAL
  zh: <details data-alert="note" open=""><summary>链接:</summary></details>
- en: 'The `style()` feature of `@container` can sometimes be used to approximate
    mixin behavior. There are several recent [posts](https://front-end.social/@chriscoyier/110821892737745155)
    and [articles](https://chriskirknielsen.com/blog/future-themes-with-container-style-queries/)
    written about that approach. However, style queries share the limitation of other
    container queries: *we can’t style the container being queried*.'
  id: totrans-split-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`@container`的`style()`功能有时可以用于近似混合行为。近期有几篇关于这种方法的[帖子](https://front-end.social/@chriscoyier/110821892737745155)和[文章](https://chriskirknielsen.com/blog/future-themes-with-container-style-queries/)。然而，样式查询与其他容器查询共享限制：*我们不能样式化正在查询的容器*。'
- en: Container queries are designed as a *conditional selector* mechanism, for responding
    to changes in context. The ancestor/descendant limitation is required for browsers
    to separate selector-matching from value-resolution on a given element.
  id: totrans-split-233
  prefs: []
  type: TYPE_NORMAL
  zh: 容器查询被设计为一种*条件选择器*机制，用于响应上下文变化。祖先/后代限制对于浏览器分离在给定元素上的选择器匹配与值解析是必需的。
- en: However, *mixins do not alter selection*, they only ‘bundle’ existing CSS rules
    and declarations for re-use. Ideally, these two features should work well together,
    so that contextual conditions can change the arguments passed to a given mixin.
  id: totrans-split-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*混合物不会改变选择*，它们只是‘打包’现有的CSS规则和声明以便重复使用。理想情况下，这两个功能应该能够很好地配合，以便上下文条件可以改变传递给特定混合物的参数。
- en: Custom Properties (implemented)
  id: totrans-split-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义属性（已实现）
- en: <details data-alert="note" open=""><summary>Links:</summary></details>
  id: totrans-split-236
  prefs: []
  type: TYPE_NORMAL
  zh: <details data-alert="note" open=""><summary>链接:</summary></details>
- en: 'We can also use custom properties to approximate some basic mixins and functions.
    While these tricks can be useful, they involve significant complexity, caveats,
    and limitations:'
  id: totrans-split-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用自定义属性来近似一些基本的混合物和函数。尽管这些技巧可能很有用，但它们涉及到显著的复杂性、注意事项和限制：
- en: Each ‘function/mixin’ and ‘argument’ is a custom property, which can only have
    a single resolved value per element
  id: totrans-split-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个‘函数/混合物’和‘参数’都是一个自定义属性，每个元素只能有一个解析后的值。
- en: Arguments are substituted in the function/mixin *before the computed value inherits*,
    so the logic has to be defined on every element that should re-calculate a result
  id: totrans-split-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算值继承之前，函数/混合物中的参数被替换，因此逻辑必须在每个需要重新计算结果的元素上定义。
- en: Mixins and functions in pre-processors
  id: totrans-split-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预处理器中的混合物和函数
- en: <details data-alert="note" open=""><summary>Links:</summary></details>
  id: totrans-split-241
  prefs: []
  type: TYPE_NORMAL
  zh: <details data-alert="note" open=""><summary>链接:</summary></details>
- en: 'In addition to parameters, Sass mixins can accept *content blocks*. An example
    [from the documentation](https://sass-lang.com/documentation/at-rules/mixin/#content-blocks):'
  id: totrans-split-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除了参数外，Sass混合物还可以接受*内容块*。来自[文档](https://sass-lang.com/documentation/at-rules/mixin/#content-blocks)的一个例子：
- en: '[PRE41]'
  id: totrans-split-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That might be a useful feature for CSS mixins as well. It would be required
    for the use-case of creating named conditions. That use-case may also be solved
    by the proposed `@when` rule and ‘custom media queries’ feature.
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能也是CSS混合物的一个有用特性。这对于创建命名条件的用例是必需的。该用例也可能通过建议的`@when`规则和‘自定义媒体查询’功能来解决。
- en: Sass provides some built-in core functions, but (so far) does not provide core
    mixins. Likely for that reason, the HTTP Archive report lists several commonly-used
    built-in functions (`if()`, and `darken()`), but only the most commonly used custom
    mixin name (`clearfix`).
  id: totrans-split-245
  prefs: []
  type: TYPE_NORMAL
  zh: Sass提供了一些内置的核心函数，但（到目前为止）并未提供核心混合物。因此，HTTP归档报告列出了几个常用的内置函数（`if()`和`darken()`），但只列出了最常用的自定义混合物名称（`clearfix`）。
- en: Existing Proposal for Custom Functions
  id: totrans-split-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现有的自定义函数提案
- en: In July of 2022, Johannes Odland proposed ‘[Declarative custom functions](https://github.com/w3c/csswg-drafts/issues/7490)’
    in the CSS Working Group issue tracker. Since then, the proposal has gone through
    several revisions and updates.
  id: totrans-split-247
  prefs: []
  type: TYPE_NORMAL
  zh: 2022年7月，Johannes Odland在CSS工作组问题跟踪器中提出了‘[声明性自定义函数](https://github.com/w3c/csswg-drafts/issues/7490)’。自那时以来，该提案经历了几次修订和更新。
- en: 'The current (2023-08-08) proposal in that thread suggests that:'
  id: totrans-split-248
  prefs: []
  type: TYPE_NORMAL
  zh: 该线程中当前（2023-08-08）的提案建议如下：
- en: Functions would be resolved at the same time as variable substitution
  id: totrans-split-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数将在变量替换的同时解析。
- en: Function parameters defined with a CSSOM ‘syntax’ can be validated at parse
    time (like `@property`-registered variables)
  id: totrans-split-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSSOM‘语法’定义的函数参数可以在解析时进行验证（类似于`@property`注册的变量）。
- en: This would be a declarative version of the more full-featured Houdini API feature
  id: totrans-split-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将是更完整功能的Houdini API特性的声明版本
- en: 'There are also several example use-cases, such as this function for fluid typography:'
  id: totrans-split-252
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个示例用例，比如这个用于流体排版的函数：
- en: '[PRE42]'
  id: totrans-split-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <details data-alert="warn"><summary>Unit division in math functions:</summary></details>
  id: totrans-split-254
  prefs: []
  type: TYPE_NORMAL
  zh: <details data-alert="warn"><summary>数学函数中的单位划分：</summary></details>
- en: 'Or a function for generating checkerboard background-images:'
  id: totrans-split-255
  prefs: []
  type: TYPE_NORMAL
  zh: 或用于生成棋盘背景图像的函数：
- en: '[PRE43]'
  id: totrans-split-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For these use-case, custom functions could be a simple wrapper for inserting
    parameters into existing functions like `calc()`. Tab Atkins has suggested a math-only
    version of this would be simplest to implement. While that might be a useful first-step,
    it quickly falls short of the use-cases I’ve seen. I would prefer to start with
    a more fully-featured approach, and work backwards to an attainable level 1 implementation
    if needed.
  id: totrans-split-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些用例，自定义函数可以是将参数插入现有函数（如`calc()`）的简单包装器。Tab Atkins建议，这种仅数学版本可能是最简单实现的方式。虽然这可能是一个有用的第一步，但很快就无法满足我所见到的用例。我更愿意从更完整功能的方法开始，然后逐步朝着可实现的一级实现方向前进。
- en: 'In addition to some bike-shedding of the syntax, there are several more open
    questions in the thread:'
  id: totrans-split-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语法上的一些琐碎问题外，线程中还有几个更为开放的问题：
- en: Can authors provide a fallback output for invalid arguments?
  id: totrans-split-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者是否可以为无效参数提供回退输出？
- en: Would it be helpful to include default parameter values in the function definition?
  id: totrans-split-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数定义中包含默认参数值是否有帮助？
- en: Can function authors define internally-scoped custom properties?
  id: totrans-split-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作者是否可以定义内部作用域的自定义属性？
- en: Can authors use conditional at-rules inside the function logic?
  id: totrans-split-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者是否可以在函数逻辑内使用条件性at-rules？
- en: Can functions expose a parameter that accepts bare calculations (without `calc()`
    syntax) similar to `clamp()` etc?
  id: totrans-split-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数能否公开接受裸算术计算（不使用`calc()`语法）的参数，类似于`clamp()`等？
- en: Can functions perform recursive function calls?
  id: totrans-split-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数能否执行递归函数调用？
- en: Can functions be called with named (rather than positional) arguments?
  id: totrans-split-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数能否使用命名（而非位置）参数进行调用？
- en: I hope to expand on this proposal, and explore some of those questions along
    the way.
  id: totrans-split-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望在这个提议的基础上进行扩展，并探索其中的一些问题。
- en: Acknowledgments
  id: totrans-split-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 致谢
- en: 'This proposal is based on an [existing discussion](https://github.com/w3c/csswg-drafts/issues/7490)
    with input from:'
  id: totrans-split-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提议基于一个[现有讨论](https://github.com/w3c/csswg-drafts/issues/7490)，得到了以下几位的参与：
- en: Johannes Odland
  id: totrans-split-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Johannes Odland
- en: David Baron
  id: totrans-split-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: David Baron
- en: Brian Kardell
  id: totrans-split-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brian Kardell
- en: Tab Atkins-Bittner
  id: totrans-split-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tab Atkins-Bittner
- en: '@jimmyfrasche'
  id: totrans-split-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@jimmyfrasche'
- en: Brandon McConnell
  id: totrans-split-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brandon McConnell
- en: Lea Verou
  id: totrans-split-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lea Verou
- en: 'I’ve also incorporated feedback along the way from:'
  id: totrans-split-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在路上，我还整合了以下几位的反馈：
- en: Nicole Sullivan
  id: totrans-split-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nicole Sullivan
- en: Anders Hartvoll Ruud
  id: totrans-split-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anders Hartvoll Ruud
- en: Rune Lillesveen
  id: totrans-split-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rune Lillesveen
- en: Alan Stearns
  id: totrans-split-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alan Stearns
- en: Yehonatan Daniv
  id: totrans-split-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yehonatan Daniv
- en: Emilio Cobos Álvarez
  id: totrans-split-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emilio Cobos Álvarez
- en: François Remy
  id: totrans-split-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: François Remy
- en: Steinar H Gunderson
  id: totrans-split-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Steinar H Gunderson
- en: Matt Giuca
  id: totrans-split-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matt Giuca
- en: Todo
  id: totrans-split-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 待办事项
- en: </main>
  id: totrans-split-287
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
