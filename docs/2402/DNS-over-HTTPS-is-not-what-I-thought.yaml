- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:31:16'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: DNS over HTTPS is not what I thought
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.petefreitag.com/blog/dns-over-https/](https://www.petefreitag.com/blog/dns-over-https/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A few months ago I was on a mission to remove some of the old broken links on
    my blog. I started blogging back in 2002, so many of the sites that I linked to
    twenty years ago were no longer active, or no longer under the same ownership.
    I decided to start this task by weeding out any domains that no longer resolved
    over DNS.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: While I knew of a few traditional methods to query DNS, I thought this was a
    good chance to explore the *DNS over HTTPS* or *DoH* protocol. It is a fairly
    *new* standard for accessing DNS records over an encrypted https connection. The
    RFC (8484) was published in October of 2018.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: What is cool about DNS over HTTPS is that, well, it uses HTTPS. Because HTTP
    clients are plentiful and well understood by many developers, it *should* make
    for a pretty simple implementation.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: DNS Query using curl
  id: totrans-split-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose we want to query the `A` record for example.com, we can make a request
    using curl like this:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this case I''m using CloudFlare''s public DNS over HTTPS server `cloudflare-dns.com`,
    but we can also use Google''s public DNS over HTTPS server: `dns.google` with
    curl like this:'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Really the only thing slightly tricky about this, is that you have to pass
    the http request header:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From there it is just a matter of passing in the name that you want to look
    up, and the DNS record type using query string parameters.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The response we''ll get from the server looks something like this:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you were to make a request for a hostname that does not have an A record,
    you might get a response like this:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You''ll notice in this case that there is no `Answer` array, and the `Status`
    is `3` instead of `0`. The status of 3 corresponds to the NXDOMAIN (code 3) response
    from a DNS server. Here are some of the possible status values:'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '`0` (NOERROR): The dns query was successful'
  id: totrans-split-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` (FORMERR): The dns query format was invalid.'
  id: totrans-split-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` (SERVFAIL): The server failed to process the dns query due to a problem.'
  id: totrans-split-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` (NXDOMAIN): The queried domain name does not exist.'
  id: totrans-split-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4` (NOTIMP): The server does not support the requested query type.'
  id: totrans-split-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5` (REFUSED): The server refuses to answer the query for policy reasons.'
  id: totrans-split-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes it pretty easy to see if the DNS query was successful or not.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you are probably wondering what those boolean keys are:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: '`TC` (Truncated) - Indicates whether the response has been truncated due to
    size limitations.'
  id: totrans-split-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RD` (Recursion Desired) - Indicates whether the client requested recursive
    resolution.'
  id: totrans-split-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RA` (Recursion Available) - Whether the server supports recursive resolution'
  id: totrans-split-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AD` (Authentic Data) - Indicates if the response has been validated using
    DNSSEC (Domain Name System Security Extensions)'
  id: totrans-split-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CD` (Checking Disabled) - Whether the client has requested that DNSSEC validation
    be disabled.'
  id: totrans-split-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not RFC 8484, DoH!
  id: totrans-split-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It turns out what I was using is not actually the RFC 8484 DNS over HTTPS, but
    rather an implementation inspired by a 2013 draft specification called *JSON format
    to represent DNS data draft-bortzmeyer-dns-json-01*.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现我使用的实际上并不是RFC 8484 DNS over HTTPS，而是受2013年草案规范启发的一种实现，称为*用于表示DNS数据的JSON格式草案-bortzmeyer-dns-json-01*。
- en: 'This actual RCF 8484 DNS over HTTPS specification is much much harder to work
    with, because you have to send binary encoded messages confirming to RFC 1035\.
    For example if you want to send a A record lookup of `www.example.com` you could
    do it like this:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实际的RFC 8484 DNS over HTTPS规范要难得多，因为你必须发送符合RFC 1035的二进制编码消息。例如，如果你想要发送对`www.example.com`的A记录查找，你可以这样做：
- en: '[PRE5]'
  id: totrans-split-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The dns query is a url safe base64 encoding of the binary DNS record request.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: DNS查询是对二进制DNS记录请求的URL安全的Base64编码。
- en: I'm using `cat -v` to show the response since the binary response contains characters
    your terminal will hide by default.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`cat -v`来显示响应，因为二进制响应包含你的终端默认隐藏的字符。
- en: In summary
  id: totrans-split-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: It was interesting to find out that what I thought was *DNS over HTTPS* is actually
    not what the RFC 8484 standard defines. What CloudFlare, and Google provide is
    just a really handy JSON api implementation based upon a 2013 IETF Internet-Draft.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 发现我所认为的*DNS over HTTPS*实际上并不符合RFC 8484标准是很有趣的。CloudFlare和Google提供的只是基于2013年IETF互联网草案的一个非常方便的JSON
    API实现。
- en: There is in fact an RFC 8427 titled *Representing DNS Messages in JSON*, but
    this is not the format that CloudFlare / Google's servers are using. It is more
    closely aligned to provide a mapping from the binary format to a JSON representation.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有一篇题为*在JSON中表示DNS消息*的RFC 8427，但这不是CloudFlare / Google服务器使用的格式。它更接近于将二进制格式映射到JSON表示。
- en: I'll probably stick to using the JSON api, rather than the actual DNS over HTTPS
    protocol, but it's good to know there is a difference.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能会继续使用JSON API，而不是真正的DNS over HTTPS协议，但知道有所区别还是很好的。
