- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ç±»ï¼šæœªåˆ†ç±»
- en: 'date: 2024-05-27 14:29:40'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024-05-27 14:29:40
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'RISC-V Assembler: Arithmetic - Project F'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RISC-V æ±‡ç¼–å™¨ï¼šç®—æœ¯ - é¡¹ç›® F
- en: æ¥æºï¼š[https://projectf.io/posts/riscv-arithmetic/](https://projectf.io/posts/riscv-arithmetic/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://projectf.io/posts/riscv-arithmetic/](https://projectf.io/posts/riscv-arithmetic/)
- en: â€œRISC architecture is going to change everything.â€ â€” [Acid Burn](https://tvtropes.org/pmwiki/pmwiki.php/Film/Hackers)
  id: totrans-split-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: â€œRISC æ¶æ„å°†æ”¹å˜ä¸€åˆ‡ã€‚â€ â€” [é…¸æ€§çƒ§ä¼¤](https://tvtropes.org/pmwiki/pmwiki.php/Film/Hackers)
- en: In the last few years, weâ€™ve seen an explosion of RISC-V CPU designs, especially
    on FPGA. Thankfully, RISC-V is ideal for assembly programming with its compact,
    easy-to-learn instruction set. This series will help you learn and understand
    32-bit RISC-V instructions (RV32) and the RISC-V ABI. The first part looks at
    load immediate, addition, and subtraction. Weâ€™ll also cover sign extension and
    pseudoinstructions.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿‡å»å‡ å¹´é‡Œï¼Œæˆ‘ä»¬çœ‹åˆ°äº† RISC-V CPU è®¾è®¡çš„çˆ†ç‚¸å¼å¢é•¿ï¼Œç‰¹åˆ«æ˜¯åœ¨ FPGA ä¸Šã€‚å¹¸è¿çš„æ˜¯ï¼ŒRISC-V ä»¥å…¶ç´§å‡‘ã€æ˜“å­¦çš„æŒ‡ä»¤é›†éå¸¸é€‚åˆæ±‡ç¼–ç¼–ç¨‹ã€‚æœ¬ç³»åˆ—å°†å¸®åŠ©æ‚¨å­¦ä¹ å’Œç†è§£
    32 ä½ RISC-V æŒ‡ä»¤ï¼ˆRV32ï¼‰å’Œ RISC-V ABIã€‚ç¬¬ä¸€éƒ¨åˆ†å°†ä»‹ç»åŠ è½½ç«‹å³æ•°ã€åŠ æ³•å’Œå‡æ³•ã€‚æˆ‘ä»¬è¿˜å°†æ¶µç›–ç¬¦å·æ‰©å±•å’Œä¼ªæŒ‡ä»¤ã€‚
- en: Share your thoughts with @WillFlux on [Mastodon](https://mastodon.social/@WillFlux)
    or [Twitter](https://twitter.com/WillFlux). If you like what I do, [sponsor me](https://github.com/sponsors/WillGreen).
    ğŸ™
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ @WillFlux åœ¨ [Mastodon](https://mastodon.social/@WillFlux) æˆ– [Twitter](https://twitter.com/WillFlux)
    åˆ†äº«æ‚¨çš„æƒ³æ³•ã€‚å¦‚æœæ‚¨å–œæ¬¢æˆ‘çš„å·¥ä½œï¼Œè¯· [èµåŠ©æˆ‘](https://github.com/sponsors/WillGreen)ã€‚ ğŸ™
- en: RISC-V Instruction Sets
  id: totrans-split-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RISC-V æŒ‡ä»¤é›†
- en: 'RISC-V handles processors of different sizes with separate but consistent instruction
    sets:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: RISC-V ä½¿ç”¨å•ç‹¬ä½†ä¸€è‡´çš„æŒ‡ä»¤é›†å¤„ç†ä¸åŒå¤§å°çš„å¤„ç†å™¨ï¼š
- en: '**RV32** - 32-bit RISC-V with 32 general-purpose registers'
  id: totrans-split-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RV32** - 32 ä½ RISC-Vï¼Œå…·æœ‰ 32 ä¸ªé€šç”¨å¯„å­˜å™¨'
- en: '**RV64** - 64-bit RISC-V with 32 general-purpose registers'
  id: totrans-split-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RV64** - 64 ä½ RISC-Vï¼Œå…·æœ‰ 32 ä¸ªé€šç”¨å¯„å­˜å™¨'
- en: '**RV32E** - Reduced 32-bit RISC-V with 16 general-purpose registers'
  id: totrans-split-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RV32E** - ç²¾ç®€ç‰ˆ 32 ä½ RISC-Vï¼Œå…·æœ‰ 16 ä¸ªé€šç”¨å¯„å­˜å™¨'
- en: Iâ€™ll be focusing on RV32, but the other instruction sets work in a similar way.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å°†ä¸“æ³¨äº RV32ï¼Œä½†å…¶ä»–æŒ‡ä»¤é›†çš„å·¥ä½œæ–¹å¼ç±»ä¼¼ã€‚
- en: The base **integer** instruction set for RV32 is **RV32I** ("**I**" stands for
    integer). RV32I contains the essential RISC-V instructions, such as arithmetic,
    memory access, and branching.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: RV32 çš„åŸºæœ¬**æ•´æ•°**æŒ‡ä»¤é›†ä¸º RV32Iï¼ˆâ€œIâ€ ä»£è¡¨æ•´æ•°ï¼‰ã€‚RV32I åŒ…å«äº†åŸºæœ¬çš„ RISC-V æŒ‡ä»¤ï¼Œå¦‚ç®—æœ¯ã€å†…å­˜è®¿é—®å’Œåˆ†æ”¯ã€‚
- en: CPU Registers
  id: totrans-split-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU å¯„å­˜å™¨
- en: 'RV32I has 32 general-purpose registers: **x0** to **x31**. These registers
    are 32 bits wide.'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: RV32I å…·æœ‰ 32 ä¸ªé€šç”¨å¯„å­˜å™¨ï¼š**x0** åˆ° **x31**ã€‚è¿™äº›å¯„å­˜å™¨å®½åº¦ä¸º 32 ä½ã€‚
- en: '**x0** is hard-wired to **0** (zero). You can use the other registers as you
    see fit, but there is an **ABI** (application binary interface) to make life easier
    for programmers and allow code from different developers to interoperate. My examples
    use the temporary registers **t0-t6**. Iâ€™ll cover all the ABI registers in my
    post on [functions](/posts/riscv-jump-function#rv32-abi-registers), but you donâ€™t
    need to worry about them for now.'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**x0** è¢«ç¡¬ç¼–ç ä¸º **0**ï¼ˆé›¶ï¼‰ã€‚æ‚¨å¯ä»¥è‡ªç”±ä½¿ç”¨å…¶ä»–å¯„å­˜å™¨ï¼Œä½†æœ‰ä¸€ä¸ªåº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ¥å£ï¼ˆABIï¼‰ï¼Œä½¿å¾—ç¨‹åºå‘˜ç”Ÿæ´»æ›´åŠ è½»æ¾ï¼Œå¹¶å…è®¸æ¥è‡ªä¸åŒå¼€å‘è€…çš„ä»£ç äº’æ“ä½œã€‚æˆ‘çš„ç¤ºä¾‹ä½¿ç”¨ä¸´æ—¶å¯„å­˜å™¨
    **t0-t6**ã€‚æˆ‘å°†åœ¨æˆ‘çš„å…³äº [å‡½æ•°](/posts/riscv-jump-function#rv32-abi-registers) çš„æ–‡ç« ä¸­æ¶µç›–æ‰€æœ‰
    ABI å¯„å­˜å™¨ï¼Œä½†ç°åœ¨æ‚¨ä¸éœ€è¦æ‹…å¿ƒå®ƒä»¬ã€‚'
- en: With that briefest of introductions out of the way, letâ€™s get started on the
    instructions.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: ä»‹ç»ç»“æŸåï¼Œè®©æˆ‘ä»¬å¼€å§‹å­¦ä¹ è¿™äº›æŒ‡ä»¤ã€‚
- en: 'Itâ€™s simple to load an immediate (constant) value into a register with load
    immediate **li**:'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨åŠ è½½ç«‹å³æŒ‡ä»¤ **li** å°†å¸¸é‡å€¼åŠ è½½åˆ°å¯„å­˜å™¨ä¸­éå¸¸ç®€å•ï¼š
- en: '**rd** is the destination register, and **imm** is a 32-bit immediate.'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**rd** æ˜¯ç›®æ ‡å¯„å­˜å™¨ï¼Œ**imm** æ˜¯ 32 ä½ç«‹å³æ•°ã€‚'
- en: 'Load immediate examples:'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: ç«‹å³åŠ è½½ç¤ºä¾‹ï¼š
- en: '[PRE0]'
  id: totrans-split-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*ProTip: Hexadecimal literals are prefixed with **0x**.*'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä¸“ä¸šæç¤ºï¼šåå…­è¿›åˆ¶å­—é¢é‡ä»¥ **0x** ä¸ºå‰ç¼€ã€‚*'
- en: Pseudoinstructions
  id: totrans-split-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ä¼ªæŒ‡ä»¤
- en: RISC-V registers are 32 bits wide. RISC-V instructions are 32 bits wide. An
    instruction needs room for an opcode and registers, so it canâ€™t hold a 32-bit
    immediate. How does **li** manage it? Load immediate is not a RISC-V instruction
    but a **pseudoinstruction**.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: RISC-V å¯„å­˜å™¨å®½åº¦ä¸º 32 ä½ã€‚RISC-V æŒ‡ä»¤ä¹Ÿæ˜¯ 32 ä½å®½ã€‚æŒ‡ä»¤éœ€è¦ç©ºé—´æ¥å­˜æ”¾æ“ä½œç å’Œå¯„å­˜å™¨ï¼Œå› æ­¤æ— æ³•å®¹çº³ 32 ä½ç«‹å³æ•°ã€‚é‚£ä¹ˆ **li**
    å¦‚ä½•å¤„ç†å‘¢ï¼ŸåŠ è½½ç«‹å³æ•°ä¸æ˜¯ä¸€ä¸ª RISC-V æŒ‡ä»¤ï¼Œè€Œæ˜¯ä¸€ä¸ª**ä¼ªæŒ‡ä»¤**ã€‚
- en: Pseudoinstructions are translated into one or more real instructions by the
    assembler. Pseudoinstructions are syntactic sugar that makes assembly code easier
    to write *and* easier to understand. Weâ€™ll see many examples in this series, and
    you can see a complete list in [standard RISC-V pseudoinstructions](https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#-a-listing-of-standard-risc-v-pseudoinstructions).
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: Donâ€™t worry if this doesnâ€™t make sense right now. Weâ€™ll come back to load immediate
    once weâ€™ve discussed RISC-V arithmetic.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: Addition
  id: totrans-split-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RISC-V has two add instructions: for adding registers together and adding an
    immediate to a register.'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Where **rd** is the destination register, **rs rs1 rs2** are source registers,
    and **imm** is a 12-bit immediate.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of adding registers:'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Examples of adding an immediate to a register:'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**addi** can add an immediate value in the range -2048 to 2047\. RISC-V has
    no increment or decrement instructions; **addi** handles them too.'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Not content with addition and subtraction, **addi** is also behind two common
    pseudoinstructions:'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The **mv** (move) instruction copies one register to another. **mv** is **addi**
    with an immediate value of 0, so nothing is added. The move instruction can only
    copy between registers, it canâ€™t access memory.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Move example (note the destination is the first register given):'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The **nop** instruction advances the program counter but makes no other changes.
    We have a standard **nop** encoding to make programmer intent clear and avoid
    the instruction being optimised away.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: Sign Extension
  id: totrans-split-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RISC-V immediates are sign-extended. The most significant bit (MSB) fills the
    remaining bits to create a 32-bit value. A 12-bit RISC-V immediate can represent
    -2048 to 2047 inclusive.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Sign extension of -2047 decimal (MSB=1):'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: '`1000 0000 0000 -> 1111 1111 1111 1111 1111 1000 0000 0000`'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Sign extension of 1033 decimal (MSB=0):'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: '`0100 0000 1001 -> 0000 0000 0000 0000 0000 0100 0000 1001`'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: Using a signed immediate, we can add and subtract with **addi** (see examples
    above) or jump forwards or backwards in our code (discussed in [Jump and Function](/posts/riscv-jump-function/)).
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: 'RISC-Vâ€™s designers made several small decisions that have an oversized impact
    on the simplicity and power of the instruction set: sign extending immediates
    is one of them.'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: Subtraction
  id: totrans-split-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **sub** instruction subtracts registers. Subtracting an immediate is handled
    by **addi** (above).
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The **neg** pseudoinstruction negates a register value: positive numbers become
    negative and vice-versa. Negate only takes one source register because it uses
    **sub** with the zero register **x0** as the first source.'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtraction examples:'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*ProTip: the destination register comes first in RISC-V assembler.*'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: Looking for more arithmetic? Check out my post on RISC-V [multiplication and
    division](/posts/riscv-multiply-divide/).
  id: totrans-split-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Load upper immediate sets the upper 20 bits of a register with an immediate
    value and zeros the lower 12 bits. Another way of looking at **lui** is that it
    left shifts the immediate by 12 bits.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ è½½ä¸Šä½ç«‹å³æ•°å°†ä¸€ä¸ªå¯„å­˜å™¨çš„å‰20ä½è®¾ç½®ä¸ºç«‹å³å€¼å¹¶å°†ä½12ä½æ¸…é›¶ã€‚ä»å¦ä¸€ä¸ªè§’åº¦çœ‹**lui**ï¼Œå®ƒå°†ç«‹å³æ•°å·¦ç§»12ä½ã€‚
- en: '[PRE8]'
  id: totrans-split-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is best seen with some examples:'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åœ¨ä¸€äº›ä¾‹å­ä¸­æœ€ä¸ºæ˜æ˜¾ï¼š
- en: '[PRE9]'
  id: totrans-split-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**lui** accepts immediates in the range 0x00000-0xFFFFF.'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**lui**æ¥å—èŒƒå›´åœ¨0x00000-0xFFFFFçš„ç«‹å³æ•°ã€‚'
- en: Your assembler will error if you use numbers outside this range, including negative
    numbers.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½¿ç”¨è¶…å‡ºæ­¤èŒƒå›´çš„æ•°å­—ï¼ŒåŒ…æ‹¬è´Ÿæ•°ï¼Œä½ çš„æ±‡ç¼–å™¨ä¼šæŠ¥é”™ã€‚
- en: '[PRE10]'
  id: totrans-split-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If out of range, GNU assembler returns `Error: lui expression not in range
    0..1048575`'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦‚æœè¶…å‡ºèŒƒå›´ï¼ŒGNUæ±‡ç¼–å™¨ä¼šè¿”å›`Error: lui expression not in range 0..1048575`'
- en: Now weâ€™ve met **addi** and **lui**, weâ€™re ready to deconstruct **li**.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»äº†è§£äº†**addi**å’Œ**lui**ï¼Œæˆ‘ä»¬å‡†å¤‡å¥½è§£æ„**li**äº†ã€‚
- en: Load upper immediate **lui** sets the upper 20 bits and add immediate **addi**
    adds a 12-bit immediate. Together these two instructions can load a 32-bit immediate
    into a register.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ è½½ä¸Šä½ç«‹å³æ•°**lui**è®¾ç½®å‰20ä½å¹¶ä¸”åŠ ä¸Šç«‹å³æ•°**addi**ã€‚è¿™ä¸¤æ¡æŒ‡ä»¤ä¸€èµ·å¯ä»¥å°†ä¸€ä¸ª32ä½ç«‹å³æ•°åŠ è½½åˆ°ä¸€ä¸ªå¯„å­˜å™¨ä¸­ã€‚
- en: 'Letâ€™s see how the assembler does this for our earlier **li** examples:'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹æ±‡ç¼–å™¨å¦‚ä½•å¤„ç†æˆ‘ä»¬ä¹‹å‰çš„**li**ä¾‹å­ï¼š
- en: '[PRE11]'
  id: totrans-split-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first three examples fit into 12 bits, so they only need **addi**:'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: å‰ä¸‰ä¸ªä¾‹å­é€‚åˆ12ä½ï¼Œå› æ­¤åªéœ€è¦**addi**ï¼š
- en: '[PRE12]'
  id: totrans-split-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember that the **x0** register is hard-wired to 0 (zero).
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½ï¼Œ**x0**å¯„å­˜å™¨æ˜¯ç¡¬è¿æ¥åˆ°0ï¼ˆé›¶ï¼‰çš„ã€‚
- en: 'The **t3** (0x100000) example fits in the upper 20 bits, so it only needs **lui**:'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**t3**ï¼ˆ0x100000ï¼‰çš„ä¾‹å­é€‚åˆå‰20ä½ï¼Œå› æ­¤åªéœ€è¦**lui**ï¼š'
- en: 'The **t4** (4100) example is a little too large for 12 bits (2^(12) + 4 = 4100),
    so we need **lui** then **addi**:'
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**t4**ï¼ˆ4100ï¼‰çš„ä¾‹å­ç¨å¾®å¤§äº†ä¸€ç‚¹è¶…å‡ºäº†12ä½ï¼ˆ2^(12) + 4 = 4100ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦**lui**ç„¶å**addi**ï¼š'
- en: '[PRE13]'
  id: totrans-split-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The **t5** (0xFACE) example is a sneaky one:'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**t5**ï¼ˆ0xFACEï¼‰çš„ä¾‹å­å¾ˆæ£˜æ‰‹ï¼š'
- en: '[PRE14]'
  id: totrans-split-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The obvious answer of adding 0xACE to 0xF wonâ€™t work because **addi** sign
    extends the 12-bit immediate. Looking at 0xACE in binary, we see the most significant
    bit is 1:'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ˆæ˜æ˜¾ï¼Œå°†0xACEåŠ ä¸Š0xFçš„ç­”æ¡ˆæ˜¯ä¸è¡Œçš„ï¼Œå› ä¸º**addi**ä¼šå¯¹12ä½ç«‹å³æ•°è¿›è¡Œç¬¦å·æ‰©å±•ã€‚æŸ¥çœ‹0xACEçš„äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æœ€é«˜ä½æ˜¯1ï¼š
- en: '`1010 1100 1110 -> 1111 1111 1111 1111 1111 1010 1100 1110`'
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`1010 1100 1110 -> 1111 1111 1111 1111 1111 1010 1100 1110`'
- en: 'The result of the sign extension is negative: -1330 (-0x532).'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¦å·æ‰©å±•çš„ç»“æœä¸ºè´Ÿæ•°ï¼š-1330ï¼ˆ-0x532ï¼‰ã€‚
- en: '`0xF000 - 0x532 = 0xEACE`'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`0xF000 - 0x532 = 0xEACE`'
- en: 'To correct for the sign extension, we need to add 1 to the **lui** immediate:
    `0xF + 0x1 = 0x10`.'
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æ ¡æ­£ç¬¦å·æ‰©å±•ï¼Œæˆ‘ä»¬éœ€è¦å°†**lui**çš„ç«‹å³æ•°åŠ 1ï¼š`0xF + 0x1 = 0x10`ã€‚
- en: Any 12-bit immediate whose most significant bit is 1 will suffer from this issue.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: ä»»ä½•æœ€é«˜æœ‰æ•ˆä½ä¸º1çš„12ä½ç«‹å³æ•°éƒ½ä¼šé‡åˆ°è¿™ä¸ªé—®é¢˜ã€‚
- en: 'However, the solution is simple: use **li** and the assembler will take care
    of it for you. :)'
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè§£å†³æ–¹æ¡ˆå¾ˆç®€å•ï¼šä½¿ç”¨**li**ï¼Œæ±‡ç¼–å™¨ä¼šä¸ºä½ å¤„ç†å®ƒã€‚:)
- en: Whatâ€™s Next?
  id: totrans-split-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥åšä»€ä¹ˆï¼Ÿ
- en: If you enjoyed this post, please [sponsor me](https://github.com/sponsors/WillGreen).
    Sponsors help me create more FPGA and RISC-V projects for everyone, *and* they
    get early access to blog posts and source code. ğŸ™
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å–œæ¬¢è¿™ç¯‡æ–‡ç« ï¼Œè¯·[èµåŠ©æˆ‘](https://github.com/sponsors/WillGreen)ã€‚èµåŠ©è€…å¸®åŠ©æˆ‘ä¸ºå¤§å®¶åˆ›å»ºæ›´å¤šçš„FPGAå’ŒRISC-Vé¡¹ç›®ï¼Œ*å¹¶ä¸”*ä»–ä»¬å¯ä»¥æå‰è®¿é—®åšå®¢æ–‡ç« å’Œæºä»£ç ã€‚ğŸ™
- en: The second part of *RISC-V Assembler* covers **[Logical Instructions](/posts/riscv-logical)**.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*RISC-V Assembler*çš„ç¬¬äºŒéƒ¨åˆ†æ¶µç›–äº†**[é€»è¾‘æŒ‡ä»¤](/posts/riscv-logical)**ã€‚'
- en: 'Other parts of this series include: [Load Store](/posts/riscv-load-store/)
    and [Branch Set](/posts/riscv-branch-set/). Or check out all my [FPGA & RISC-V
    Tutorials](/tutorials/) and my series on early [Macintosh History](https://systemtalk.org/post/macintosh-history-8510/).'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç³»åˆ—çš„å…¶ä»–éƒ¨åˆ†åŒ…æ‹¬ï¼š[åŠ è½½å­˜å‚¨](/posts/riscv-load-store/)å’Œ[åˆ†æ”¯é›†](/posts/riscv-branch-set/)ã€‚æˆ–æŸ¥çœ‹æ‰€æœ‰æˆ‘çš„[FPGAå’ŒRISC-Væ•™ç¨‹](/tutorials/)ä»¥åŠæ—©æœŸçš„[Macintoshå†å²](https://systemtalk.org/post/macintosh-history-8510/)ç³»åˆ—ã€‚
- en: Acknowledgements
  id: totrans-split-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è‡´è°¢
- en: Thanks to [jtruk](https://mastodon.social/@jtruk) and [Daniel Mangum](http://danielmangum.com)
    for suggestions and corrections.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: æ„Ÿè°¢[jtruk](https://mastodon.social/@jtruk)å’Œ[Daniel Mangum](http://danielmangum.com)æä¾›çš„å»ºè®®å’Œä¿®æ­£ã€‚
- en: References
  id: totrans-split-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å‚è€ƒèµ„æ–™
