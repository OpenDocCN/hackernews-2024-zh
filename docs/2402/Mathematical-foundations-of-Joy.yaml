- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-29 13:19:38'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-29 13:19:38'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Mathematical foundations of Joy
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Joy 的数学基础
- en: 来源：[https://hypercubed.github.io/joy/html/j02maf.html](https://hypercubed.github.io/joy/html/j02maf.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://hypercubed.github.io/joy/html/j02maf.html](https://hypercubed.github.io/joy/html/j02maf.html)
- en: Mathematical foundations of Joy
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Joy 的数学基础
- en: '*by Manfred von Thun*'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*作者：曼弗雷德·冯·图恩*'
- en: '*Abstract:* Joy is a functional programming language which is not based on
    the application of functions to arguments but on the composition of functions.
    This paper describes the theoretical basis of the language. The denotation of
    Joy programs maps a syntactic monoid of program concatenation to a semantic monoid
    of function composition. Instead of lambda abstraction Joy uses program quotation,
    and higher order functions can be simulated by first order functions which dequote
    quoted programs.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*摘要:* Joy 是一种功能性编程语言，不基于将函数应用于参数，而是基于函数的组合。本文描述了该语言的理论基础。Joy 程序的表示将程序连接的语法单子映射到函数组合的语义单子。Joy
    不使用 lambda 抽象，而是使用程序引用，高阶函数可以通过将引用程序解引用为一阶函数来模拟。'
- en: '*Keywords:* functional programming, syntactic and semantic monoids, function
    composition, quotation and dequotation of programs, combinators, elimination of
    recursive definitions.'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*关键词:* 功能性编程，语法和语义单子，函数组合，程序的引用和解引用，组合子，递归定义的消除。'
- en: '* * *'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Introduction
  id: totrans-split-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Joy programs are built from smaller programs by just two constructors: *concatenation*
    and *quotation*.'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: Joy 程序由仅有的两个构造器构建而成：*连接* 和 *引用*。
- en: Concatenation is a binary constructor, and since it is associative it is best
    written in infix notation and hence no parentheses are required. Since concatenation
    is the only binary constructor of its kind, in Joy it is best written without
    an explicit symbol.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是一个二元构造器，由于它是可结合的，最好用中缀表示法来书写，因此不需要括号。由于连接是其类别中唯一的二元构造器，Joy 中最好不用显式符号来表示。
- en: Quotation is a unary constructor which takes as its operand a program. In Joy
    the quotation of a program is written by enclosing it in square brackets. Ultimately
    all programs are built from atomic programs which do not have any parts.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 引用是一个一元构造器，其操作数是一个程序。在 Joy 中，程序的引用用方括号括起来来表示。最终，所有程序都是由原子程序构建而成的，这些原子程序没有任何部分。
- en: The semantics of Joy has to explain what the atomic programs mean, how the meaning
    of a concatenated program depends on the meaning of its parts, and what the meaning
    of a quoted program is. Moreover, it has to explain under what conditions it is
    possible to replace a part by an equivalent part while retaining the meaning of
    the whole program.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: Joy 语义必须解释原子程序的含义，以及连接程序的含义如何依赖于其部分的含义，以及引用程序的含义是什么。此外，它还必须解释在什么条件下可以用等效的部分替换另一部分，同时保留整个程序的含义。
- en: Joy programs denote functions which take one argument and yield one value. The
    argument and the value are *state*s consisting of at least three components. The
    principal component is a *stack*, and the other components are not needed here.
    Much of the detail of the semantics of Joy depends on specific properties of programs.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: Joy 程序表示接受一个参数并产生一个值的函数。参数和值都是由至少三个组成部分构成的*状态*。主要组成部分是*栈*，其他组成部分在此处不需要。Joy 语义的许多细节依赖于程序的具体属性。
- en: 'However, central to the semantics of Joy is the following:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Joy 语言语义的核心在于以下几点：
- en: The concatenation of two programs denotes the composition of the functions denoted
    by the two programs.
  id: totrans-split-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 两个程序的连接表示由这两个程序表示的函数的组合。
- en: Function composition is associative, and hence denotation maps the associative
    syntactic operation of program concatenation onto the associative semantic operation
    of function composition. The quotation of a program denotes a function which takes
    any state as argument and yields as value the same state except that the quotation
    is pushed onto the stack.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是可结合的，因此表示映射程序连接的关联语法操作到函数组合的关联语义操作。程序的引用表示一个函数，该函数接受任何状态作为参数，并以相同的状态作为值返回，只是引用被推入栈中。
- en: One part of a concatenation may be replaced by another part denoting the same
    function while retaining the denotation of the whole concatenation.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的一部分可以被另一个表示相同函数的部分替换，同时保留整个连接的表示。
- en: One quoted program may be replaced by another denoting the same function only
    in a context where the quoted program will be dequoted by being executed. Such
    contexts are provided by the *combinator*s of Joy. These denote functions which
    behave like higher order functions in other languages.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，可以用另一个表示相同函数的引用程序替换一个引用程序，这种情况在 Joy 的组合子提供的上下文中进行。这些组合子像其他语言中的高阶函数一样表示函数。
- en: 'The above may be summarised as follows: Let `P`, `Q1`, `Q2` and `R` be programs,
    and let `C` be a combinator. Then this principle holds:'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容可以总结如下：设 `P`、`Q1`、`Q2` 和 `R` 是程序，`C` 是一个组合子。那么这个原则成立：
- en: '[PRE0]'
  id: totrans-split-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The principle is the prime rule of inference for the *algebra of Joy* which
    deals with the equivalence of Joy programs, and hence with the identity of functions
    denoted by such programs. A few laws in the algebra can be expressed without combinators,
    but most require one or more combinators for their expression.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则是*Joy 代数*推理的首要规则，涉及 Joy 程序的等价性，因此也涉及由这些程序表示的函数的同一性。在代数中，少数法则可以在没有组合子的情况下表达，但大多数需要一个或多个组合子来表达。
- en: The remainder of this paper is organised as follows. The next sections deal
    with program concatenation and function composition. The first of these reviews
    certain algebras called monoids, and homomorphisms between them. In the following
    section the meaning of Joy programs is shown to be a homomorphism from a syntactic
    monoid to a semantic monoid. The last of these sections explains the semantic
    monoid in a little more detail, in particular function composition and the identity
    function.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的其余部分组织如下。接下来的几节将讨论程序的串联和函数的组合。其中第一节回顾了称为幺半群的某些代数结构，以及它们之间的同态映射。在接下来的一节中，Joy
    程序的含义被证明是从语法幺半群到语义幺半群的同态映射。最后一节详细解释了语义幺半群，特别是函数的组合和单位函数。
- en: The other sections deal with quotations and combinators. The first treats combinators
    that do not involve the stack, the second those that do. The next section illustrates
    how these very basic combinators can be used to emulate recursion without explicit
    definitions. The summary section recapitulates the main conclusions and hints
    at a connection with category theory.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其他部分涉及引用和组合子。第一部分处理不涉及栈的组合子，第二部分处理涉及栈的组合子。下一节说明了这些非常基本的组合子如何在没有显式定义的情况下模拟递归。总结部分重述了主要结论，并暗示与范畴论的联系。
- en: Monoids and homomorphisms
  id: totrans-split-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幺半群和同态映射
- en: The design of Joy was motivated by [{Quine71}](refs.html#%7BQuine71%7D) and
    [{Backus78}](refs.html#%7BBackus78%7D) who in quite different fields examine how
    variables of one kind or another can be eliminated and how their work can be done
    by combinators. In turn their work is based on the pioneers Schönfinkel and Curry.
    Backus has argued that concepts of programming languages should be selected on
    the basis of yielding strong and clean mathematical laws. In particular he favours
    concepts that allow simple algebraic manipulations, where possible replacing variables
    by combinators or higher order functions. With these goals in mind his research
    culminated in the language *FP*. The language Joy offers a very different solution
    to the same goals. Paulson [{Paulson92}](refs.html#%7BPaulson92%7D) remarked that
    "Programming and pure mathematics are difficult to combine into one formal framework".
    Joy attempts this task.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: Joy 的设计受到了[{Quine71}](refs.html#%7BQuine71%7D)和[{Backus78}](refs.html#%7BBackus78%7D)的启发，他们在完全不同的领域研究了如何消除某种类型的变量，以及如何通过组合子完成它们的工作。而他们的工作则基于先驱者Schönfinkel和Curry。Backus
    认为，应该基于产生强大且清晰的数学规律的原则选择编程语言的概念。特别是，他倾向于允许简单代数操作的概念，在可能的情况下通过组合子或高阶函数替换变量。在这些目标的指导下，他的研究最终形成了语言*FP*。Joy
    语言为实现相同目标提供了一种非常不同的解决方案。Paulson [{Paulson92}](refs.html#%7BPaulson92%7D) 曾指出，“将编程与纯数学结合到一个形式框架中是困难的”。Joy
    试图完成这一任务。
- en: Much of the elegance of Joy is due to the simple algebraic structure of its
    syntax and the simple algebraic structure of its semantics and to the fact that
    the two structures are so similar. In particular, the two structures are *monoid*s
    and the meaning function which maps syntax into semantics is a *homomorphism*.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: Joy 语言的优雅主要源于其语法的简单代数结构和语义的简单代数结构，以及这两种结构如此相似。特别是，这两种结构都是*幺半群*，将语法映射到语义的意义函数是*同态映射*。
- en: Monoids and homomorphisms are familiar from abstract algebra. A *monoid* `M`
    consists of a nonempty set `{m, m1, m2 ...}` including a special element `m`,
    and a binary operation, written, say, as infix period `"."`. The special element
    has to be a left and right *unit element* for the binary operation, and the binary
    operation has to be *associative*. In symbols, for all `x`, `y` and `z` from the
    set,
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单调和同态从抽象代数中很熟悉。*单调* `M`包括一个非空集`{m, m1, m2 ...}`和一个二元操作，写成中缀形式`"."`。特殊元素必须是二元操作的左右*单位元素*，并且二元操作必须是*结合*的。符号表示，对于集合中的所有`x`,
    `y`和`z`，
- en: '[PRE1]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, these are monoids: the integers with `0` as the unit element and
    addition as the binary operation, or the integers with `1` as the unit element
    and multiplication as the binary operation. Two examples from logic are the truth
    values with falsity as the unit element and disjunction as the binary operation,
    or truth as the unit element and conjunction as the binary operation. Two examples
    from set theory are sets with the nullset as the unit element and set union as
    the binary operation, or the universal set as the unit element and set intersection
    as the binary operation. It so happens that in the preceding examples the binary
    operation is commutative, but this is not essential for monoids. Two other examples
    consists of lists with the empty list as the unit element and concatenation as
    the binary operation, or strings of characters with the empty string as the unit
    element and concatenation as the binary operation. Concatenation is *not* commutative.'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这些都是单调：带有`0`作为单位元素和加法作为二元操作的整数，或带有`1`作为单位元素和乘法作为二元操作的整数。逻辑中的两个例子是带有假性作为单位元素和析取作为二元操作的真值，或带有真实性作为单位元素和合取作为二元操作的真值。集合论中的两个例子是带有空集作为单位元素和集合并作为二元操作的集合，或者带有全集作为单位元素和集合交作为二元操作的集合。在上述例子中，二元操作是可交换的，但这对单调来说并非必要。另外两个例子包括具有空列表作为单位元素和连接作为二元操作的列表，或具有空字符串作为单位元素和连接作为二元操作的字符串。连接*不*是可交换的。
- en: Because of the associative law, parentheses are not needed. Also, if there are
    no other binary operations, the infix operator itself can be omitted and the operation
    indicated by juxtaposition. Unit elements are often called identity elements,
    but the word "identity" is already needed with a different meaning in Joy. Unit
    elements are sometimes called neutral elements, too.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为结合律，不需要括号。而且，如果没有其他二元操作，中缀运算符本身可以省略，并且通过并置表示操作。单位元素通常称为恒元素，但在Joy中这个词已经有不同的含义。单位元素有时也称为中性元素。
- en: 'Unit elements should be distinguished from *zero element*s, which behave the
    way the number `0` interacts with multiplication: a product containing a zero
    factor is equal to zero. In logic falsity is the zero element for conjunction,
    and truth is the zero element for disjunction. For sets the nullset is the zero
    element for intersection, and the universal set is the zero element for union.
    In commutative monoids there is always at most one zero element.'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 单位元素应与*零元素*区分开来，后者与乘法中的数字`0`交互的方式类似：包含零因子的乘积等于零。在逻辑中，假性是合取的零元素，真实性是析取的零元素。对于集合，空集是交的零元素，全集是并的零元素。在交换单调中，通常只有一个零元素。
- en: 'Let `M` over `{m m1 ..}` and `N` over `{n n1 ..}` be two monoids. A function
    `h` from `{m m1 ..}` to `{n n1 ..}` is called a *homomorphism* if and only if
    it maps unit elements onto unit elements and commutes with the binary operation:'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 设`M`是由`{m, m1 ..}`组成的一个单调，`N`是由`{n, n1 ..}`组成的另一个单调。如果函数`h`从`{m, m1 ..}`到`{n,
    n1 ..}`的映射被称为*同态*，当且仅当它将单位元素映射到单位元素，并且与二元操作交换：
- en: '[PRE2]'
  id: totrans-split-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the second equation, the binary operation on the left is that of `M`, and
    the one on the right is that of `N`. One example is the logarithm function which
    is a homomorphism from the multiplicative monoid onto the additive monoid. Another
    example of a homomorphism is the `size` (or length) function on lists which maps
    the list monoid onto the additive monoid: the size of the empty list is zero,
    and the size of the concatenation of two lists is the sum of the sizes of the
    two lists:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个等式中，左边的二元操作是`M`的，右边的是`N`的。一个例子是对数函数，它是从乘法单调到加法单调的同态。另一个同态的例子是列表的`size`（或长度）函数，它将列表单调映射到加法单调：空列表的大小为零，两个列表连接的大小是两个列表大小的和：
- en: '[PRE3]'
  id: totrans-split-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: (In the last two equations, the symbols `[]` and `++` are used for the empty
    list and for concatenation.) Other examples are the function which takes a list
    (or string) as argument and returns the set of its elements. So this function
    removes duplicates and forgets order. It maps the list monoid onto the set monoid
    with the nullset as the unit and union as the binary operation.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: （在最后两个方程中，符号`[]`和`++`用于空列表和串联。）其他例子是接受列表（或字符串）作为参数并返回其元素集合的函数。因此，此函数删除重复项并忽略顺序。它将列表单子映射到具有空集为单位和并集为二元操作的集合单子。
- en: 'Homomorphisms can be defined over other algebras which are not monoids. Examples
    are groups, rings, fields and Boolean algebras. They are studied in universal
    algebra and in category theory. One particular homomorphism can only be described
    as mind-blowing: this is Gödel''s arithmetisation of syntax - all syntactic operations
    on formulas of a theory are mapped onto corresponding arithmetic operations on
    their Gödel numbers. (See for example [{Mendelson64}](refs.html#%7BMendelson64%7D).)'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在不是单子的其他代数上定义同态。例如群、环、域和布尔代数。它们在通用代数和范畴论中被研究。一个特殊的同态可以被描述为令人惊叹：这是哥德尔的语法算术化
    - 对于理论公式的所有语法操作都映射到其哥德尔数的相应算术操作。（参见例如[{Mendelson64}](refs.html#%7BMendelson64%7D).）
- en: 'In propositional logic the equivalence classes of formulas constitute a Boolean
    algebra of many elements. A valuation is a homomorphism from that algebra to the
    two element Boolean algebra of truth values. One can go further: the meaning of
    a formula is the set of valuations that make it true. The meaning function then
    is a homomorphism from the Boolean algebra of equivalence classes to the Boolean
    algebra of sets of valuations. This situation is typical in semantics: the meaning
    function is a homomorphism. The same holds for Joy - the meaning function is a
    homomorphism from Joy syntax to Joy semantics.'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在命题逻辑中，公式的等价类构成了具有多个元素的布尔代数。估值是从该代数到两元布尔代数的同态。可以进一步深入：公式的意义是使其为真的估值集合。然后，意义函数是从等价类的布尔代数到估值集合的布尔代数的同态。这种情况在语义学中很典型：意义函数是一个同态。Joy
    也是如此 - 意义函数是从 Joy 语法到 Joy 语义的同态。
- en: A syntactic monoid and a semantic monoid
  id: totrans-split-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个语法单子和一个语义单子
- en: 'The *syntax* of Joy programs is very simple: the basic building blocks are
    atomic programs, and larger programs are formed by concatenation as one of the
    main modes of program construction. Concatenation is associative, and hence no
    parentheses are required. Also, concatenation is the only binary constructor,
    so no explicit symbol is required, and hence concatenation can be expressed by
    juxtaposition. It is useful to have a left and right unit element `id`. Collectively
    these constitute the syntactic monoid.'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: Joy 程序的*语法*非常简单：基本构件是原子程序，更大的程序通过串联形成作为程序构建的主要模式之一。串联是可结合的，因此不需要括号。此外，串联是唯一的二元构造器，因此不需要显式符号，因此串联可以通过并置来表示。具有左右单位元素`id`也是很有用的，这些元素共同构成了语法单子。
- en: 'Now to the *semantics*. In the introduction it was said that Joy uses postfix
    notation for the evaluation of arithmetic expressions. To add two numbers they
    are pushed onto a stack and then replaced by their sum. This terminology is helpful
    but can be misleading in several ways. The phrasing suggest a procedural or imperative
    interpretation: Joy programs consist of commands such as push this, push that,
    pop these and push their sum. But there is nothing procedural about Joy, as described
    here it is a purely functional language.'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来谈谈*语义*。在介绍中提到，Joy 使用后缀表示法来评估算术表达式。为了加两个数，它们被推送到堆栈上，然后由它们的和替换。这种术语很有帮助，但在几个方面可能会误导。措辞暗示了一种过程化或命令式的解释：Joy
    程序由诸如“push this”、“push that”、“pop these”和“push their sum”等命令组成。但 Joy 并不是过程化的，在这里描述的是一个纯函数式语言。
- en: However, the terminology of commands does suggest something useful. Commands,
    when executed, produce changes. Exactly what is changed depends on the nature
    of the command. But in the most general terms what changes is the state of a system.
    In particular the execution of a postfix expression produces changes in the state
    of a stack. For each change there is a before-state and an after-state. The after-state
    of one change is the before-state of the next change.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，命令的术语确实暗示了一些有用的东西。命令在执行时会产生变化。确切地说，变化取决于命令的性质。但在最一般的术语中，改变的是系统的状态。特别是后缀表达式的执行会改变堆栈的状态。对于每个变化，都有一个前状态和一个后状态。
- en: 'So, changes are essentially functions that take states as arguments and yield
    states as values. There is only one before-state, so they are functions of one
    argument. Therefore they can be composed. The composite of two functions can be
    applied to a state as argument and yields as value the state that is obtained
    by first applying the one function to the argument and then applying the other
    function to the resulting value. This is essentially the semantics of Joy: All
    programs denote functions from states to states.'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，变化本质上是将状态作为参数并产生状态作为值的函数。只有一个前状态，因此它们是单参数函数。因此它们可以被组合。两个函数的复合可以作为状态的参数应用，并产生通过先将一个函数应用于参数，然后将另一个函数应用于结果值而获得的状态作为值。这基本上是Joy的语义：所有程序表示从状态到状态的函数。
- en: The state does not have to be the state of a stack. It just so happens that
    evaluation of postfix expressions is so conveniently done on a stack. But evaluation
    of expressions is by no means everything. In what follows, the stack is an essential
    part of the state, but for many purposes it is useful to ignore the whole state
    altogether.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 状态不必是堆栈的状态。仅仅是后缀表达式的评估在堆栈上如此方便。但表达式的评估绝不是一切。接下来，堆栈是状态的一个重要部分，但对于许多目的来说，忽略整个状态是有用的。
- en: The operation of *function composition* is associative and there is a left and
    right unit element, the *identity function*. Collectively they comprise the semantic
    monoid. The meaning function maps a syntactic monoid onto a semantic monoid. The
    concatenation of two programs denotes the composition of the functions denoted
    by the two programs, and the unit element of concatenation denotes the unit element
    of composition.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数复合*的操作是可结合的，并且有一个左和右单位元素，*恒等函数*。总体上它们构成语义单子。意义函数将句法单子映射到语义单子。两个程序的连接表示由这两个程序表示的函数的复合，而连接的单位元素表示复合的单位元素。'
- en: Function composition and the identity function
  id: totrans-split-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数复合和恒等函数
- en: If the *programs* `P` and `Q` denote the same function, then the *functions*
    `P` and `Q` are *identical*. Two functions are identical if for all values in
    the intersection of their domains they yield the same value. This will be written
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*程序* `P` 和 `Q` 表示相同的函数，则*函数* `P` 和 `Q` 是*相同的*。如果对它们的定义域交集中的所有值它们产生相同的值，则两个函数是相同的。这将被写成
- en: '[PRE4]'
  id: totrans-split-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The symbol `==` will be used to denote the identity of Joy functions. The symbol
    does not belong to the language Joy but to its metalanguage. The *identity relation*
    between functions is clearly *reflexive*, *symmetric* and *transitive*. Furthermore,
    identicals are indiscernible in larger contexts such as compositions. Hence *substitution*
    of identicals can be used as a rule of inference:'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 符号`==`将用于表示Joy函数的身份。该符号不属于Joy语言，而属于其元语言。函数之间的*身份关系*显然是*自反*、*对称*和*传递*的。此外，在较大的上下文中如组合中，相同的东西是无法分辨的。因此，*相同物的替换*可以用作推理规则：
- en: '[PRE5]'
  id: totrans-split-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The symbol `id` will be used to denote the *identity function*. The fact that
    function composition is associative and that the identity function is a left and
    right unit is expressed by
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 符号`id`将用于表示*恒等函数*。函数复合是可结合的，并且恒等函数是左单位和右单位，这一事实由以下表达：
- en: '[PRE6]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The notation can be used to express what *look* like identities of numbers;
    for example
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该符号可以用来表达看起来像数字身份的东西；例如
- en: '[PRE7]'
  id: totrans-split-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: expresses that the composition of the three *functions* on the left is identical
    with the one *function* on the right. On the left, the first two functions push
    the *numbers* 2 and 3 onto the stack, and the third replaces them by their sum.
    On the right, the function pushes the *number* 5\. The left and the right are
    defined for all stacks as arguments and yield the same stack as value. Hence the
    left and the right are identical.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表达左边三个*函数*的组合与右边一个*函数*的相同。左边，前两个函数将*数字* 2 和 3 推入堆栈，第三个函数将它们替换为它们的和。右边，该函数推入*数字*
    5。左边和右边对所有堆栈作为参数定义，并生成相同的堆栈作为值。因此，左边和右边是相同的。
- en: But it is important to be quite clear what the equation says. Each of the four
    symbols `2`, `3`, `+` and `5` denotes a function which takes a stack as argument
    and yields a stack as value. The three *numerals* `2`, `3` and `5` denote *functions*
    which are defined for all argument stacks. They yield as values other stacks which
    are like the argument stacks except that a new *number*, 2, 3 and 5 has been pushed
    on top.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是很重要的是要非常清楚方程的意思。四个符号 `2`、`3`、`+` 和 `5` 每个代表一个以堆栈作为参数且生成堆栈作为值的函数。这三个*数字符号*
    `2`、`3` 和 `5` 分别代表*函数*，适用于所有参数堆栈。它们的返回值是类似参数堆栈的另一个堆栈，只不过顶部添加了一个新的*数字*，即 2、3 和
    5。
- en: The symbol `+` does *not* denote a *binary* function of two numbers, but like
    all Joy functions it takes one argument only. That argument has to be a stack
    whose top two elements are numbers. The value returned is another stack which
    has the top two numbers replaced by their sum. It follows that the above equation
    does *not* express the identity of numbers but the identity of *functions*.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `+` 并*不*表示两个数字的二元函数，而是像所有 Joy 函数一样，只接受一个参数。该参数必须是一个顶部两个元素为数字的堆栈。返回的值是另一个堆栈，其顶部两个数字被它们的和替换。由此可见，上述方程*不*表达数字的同一性，而是*函数*的同一性。
- en: 'The associativity of composition has as a consequence about *currying*: that
    there is no difference between standard and curried operators. Consider the example'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的结合性对于*柯里化*有一定的影响：标准和柯里化操作符之间没有区别。考虑以下例子
- en: '[PRE8]'
  id: totrans-split-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On the left the `+` takes two parameters supplied by `(2 3)`. On the right `+`
    is given one parameter, `3`. The resulting function `(3 +)` expects one parameter
    to which it will add `3`. Because of associativity the two sides are identical
    and hence no parentheses are required.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的 `+` 接受由 `(2 3)` 提供的两个参数。右边的 `+` 给出一个参数 `3`。生成的函数 `(3 +)` 期望一个参数，它将加上 `3`。由于结合性，两边是相同的，因此不需要括号。
- en: Let `P` be a program which pushes `m` values onto the stack. Let `Q` be a program
    which expects `n` values on the stack, `m` <= `n`. Now consider their concatenation
    `P Q`. Of the `n` expected by `Q`, `n` will be supplied by `P`. So the program
    `P Q` only expects `n - m` values on the stack.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 设 `P` 是一个将 `m` 个值推入堆栈的程序。设 `Q` 是一个期望堆栈上有 `n` 个值的程序，其中 `m` <= `n`。现在考虑它们的连接 `P
    Q`。对于 `Q` 期望的 `n` 个值，`P` 提供了 `m` 个。因此，程序 `P Q` 只需要堆栈上的 `n - m` 个值。
- en: '* * *'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: +++HERE+++ assoc and curry
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: +++HERE+++ 关联与柯里化
- en: '* * *'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'In the development of mathematics an explicit notation for the number `0` has
    been a rather recent innovation. The symbol enables one to say more than just
    that `0` is a unit element for addition. Similarly, in the algebra of functions
    an explicit symbol for the identity function makes it possible to state many laws.
    This is particularly true for the functions in Joy. The following are some examples:'
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学的发展中，对数字 `0` 的显式符号是一个相当近期的创新。该符号使人们可以说的不仅仅是 `0` 是加法的单位元。类似地，在函数的代数中，对于恒等函数的显式符号使得可以陈述许多定律成为可能。这对
    Joy 中的函数尤为重要。以下是一些例子：
- en: In arithmetic `0` and `1` are unit elements for addition and multiplication,
    so adding `0` or multiplying by `1` have no effect. For lists the empty list is
    a unit element, so concatenation on the left or the right has no effect. Similarly
    in logic, falsity and truth are unit elements for disjunction and conjunction,
    so disjoining with falsity and conjoining with truth make no difference. Also
    in logic, disjunction and conjunction are idempotent, so disjoining or conjoining
    with a `dup`licate yields the original. For any stack it holds that `swap`ping
    the top two elements twice has no net effect, and that duplicating the top element
    and then `pop`ping off the duplicate has no net effect.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在算术中，`0`和`1`是加法和乘法的单位元素，因此加`0`或乘以`1`没有效果。对于列表，空列表是一个单位元素，因此左侧或右侧的连接没有效果。同样在逻辑中，虚假和真实是析取和合取的单位元素，因此与虚假的合取和与真实的合取没有区别。此外，在逻辑中，析取和合取是幂等的，因此与重复的元素进行析取或合取会产生原始元素。对于任何堆栈，交换顶部两个元素两次没有净效果，并且复制顶部元素然后弹出副本也没有净效果。
- en: 'There are many more laws: double negation has no net effect, reversing a sequence
    twice just leaves the original, and taking the successor and the predeccessor
    of a number - in either order - produces no net effect. In the *algebra of Joy*
    these are expressed by the following:'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多定律：双重否定没有净效果，两次反转序列仍然是原始的，以及取继承者和前驱者的数字 - 无论顺序如何 - 都不会产生净效果。在*Joy的代数*中，这些由以下表达：
- en: '[PRE9]'
  id: totrans-split-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that no variables were needed to express these laws.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些定律表达时不需要任何变量。
- en: 'The identity function is a left and right unit element with respect to function
    composition. It is appropriate to remark here that there is also a *left zero
    element* and there is a *right zero element*. Two such elements `l` and `r` satisfy
    the following for all programs `P`:'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: 身份函数是函数组合的左右单位元素。在此适当地指出，还有一个*左零元素*和一个*右零元素*。两个这样的元素`l`和`r`对于所有程序`P`满足以下条件：
- en: '[PRE10]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since function composition is not commutative, the two zero elements are not
    identical. In Joy the left zero `l` is the `abort` operator, it ignores any program
    following it. The right zero `r` is the `clearstack` operator, it empties the
    stack and hence ignores any calculations that might have been done before. The
    two operators have some theoretical interest, and they are occasionally useful.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数组合不是可交换的，两个零元素并不相同。在Joy语言中，左零元素`l`是`abort`操作符，它忽略其后的任何程序。右零元素`r`是`clearstack`操作符，它清空堆栈，因此忽略可能在其前执行的任何计算。这两个操作符具有一定的理论兴趣，并且偶尔会有用。
- en: Quotation, dequotation and combinators
  id: totrans-split-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用、反引用和组合子
- en: 'Any program enclosed in square brackets is called a *quoted program* or *quotation*.
    The length or `size` of the quotation `[5]` is `1`, and the size of the quotation
    `[2 3 +]` is `3`. However, as noted earlier, the two programs inside the brackets
    denote the same function. What this shows is that we cannot substitute their quotations
    for each other:'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方括号括起来的程序称为*引用程序*或*引用*。方括号中的引用`[5]`的长度或`size`是`1`，而方括号中的引用`[2 3 +]`的长度是`3`。然而，正如前面提到的，方括号中的两个程序表示相同的函数。这表明我们不能互换它们的引用：
- en: '[PRE11]'
  id: totrans-split-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What forbids the substitution is the quotation - by the square brackets. So
    quotations produce opaque contexts, quotation is an intensional constructor.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止替换的是方括号引用。因此，引用产生不透明的上下文，引用是一种内涵构造。
- en: However, there are contexts where substitution is permissable across quotations.
    These are contexts where the content of the quote is not treated as a passive
    datum but as an active program. In Joy such treatment is due to *combinator*s
    which in effect dequote one or more of their parameters.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些上下文中，可以在引用之间进行替换。这些上下文中，引用内容不被视为被动数据，而是作为主动程序处理。在Joy语言中，这种处理归因于*组合子*，其实质上反引用其一个或多个参数。
- en: 'The `i` combinator expects a quoted program on top of the stack. It pops that
    program and executes it. So, if the quoted program `[P]` has just been pushed
    onto the stack, then the `i` combinator will execute `P`:'
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`组合子期望在堆栈顶部引用一个程序。它弹出该程序并执行它。因此，如果引用程序`[P]`刚刚被推送到堆栈上，那么`i`组合子将执行`P`：'
- en: '[PRE12]'
  id: totrans-split-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For example, each of the following four programs compute the same function -
    the one which takes any stack as argument and returns as value another stack which
    is like the argument stack but has the number `5` pushed on top.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下四个程序都计算相同的函数 - 接受任何堆栈作为参数并返回值为另一个堆栈，该堆栈与参数堆栈相似，但顶部推入数字`5`。
- en: '[PRE13]'
  id: totrans-split-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the program `P` computes the identity function, then the effect of applying
    the `i` combinator is that of the identity function:'
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序`P`计算恒等函数，则应用`i`组合器的效果就是恒等函数的效果：
- en: '[PRE14]'
  id: totrans-split-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another law is this:'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一条定律是：
- en: '[PRE15]'
  id: totrans-split-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Two programs `P` and `Q` may look very different - for example, they may differ
    in their sizes. But it could be that the compute the same function. In that case
    the dequotations of their quotations also compute the same function:'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 两个程序`P`和`Q`可能看起来非常不同 - 例如，它们的大小可能不同。但可能它们计算相同的函数。在这种情况下，它们引用的去引用也会计算相同的函数：
- en: Hence
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此
- en: '[PRE16]'
  id: totrans-split-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Suppose now that a quoted program, `[P]`, is on top of the stack. It could then
    be executed with the `i` combinator. But it could also be manipulated as a passive
    data structure first. For example, one could push the quotation `[i]` and then
    use the `cons` operator to insert `[P]` into `[i]` to give `[[P] i]`. What happens
    if this is executed by the `i` combinator? The internal `[P]` quote is pushed,
    and then the internal `i` combinator is executed. So the net effect is that of
    executing `P`.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设一个引用程序`[P]`位于栈顶。它可以使用`i`组合器执行。但它也可以首先作为一个被动数据结构进行操作。例如，可以推送引用`[i]`，然后使用`cons`运算符将`[P]`插入到`[i]`中，得到`[[P]
    i]`。如果这通过`i`组合器执行会发生什么？内部的`[P]`引用被推送，然后内部的`i`组合器被执行。因此，其净效果就是执行`P`。
- en: Hence
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此
- en: '[PRE17]'
  id: totrans-split-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that it has been possible to state this law without reference to the quoted
    program `[P]`. But it may help to spell out a consequence:'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以在不引用`[P]`的情况下陈述这一定律。但它可能有助于明确一个后果：
- en: '[PRE18]'
  id: totrans-split-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `i` combinator is only one of many. Another is the `b` combinator which
    expects two quoted programs on top of the stack. It pops them both and then executes
    the program that was second on the stack and continues by executing the program
    that was on top of the stack. So, in the special case where two programs `[P]`
    and `[Q]` have just been pushed onto the stack, the `b` combinator will execute
    them in the order in which they have been pushed:'
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`组合器只是其中之一。另一个是`b`组合器，它期望栈顶有两个引用的程序。它弹出这两个引用程序，并且首先执行栈顶的程序，然后继续执行第二个程序。因此，在刚刚推送了两个程序`[P]`和`[Q]`的特殊情况下，`b`组合器将按照它们被推送的顺序执行它们：'
- en: '[PRE19]'
  id: totrans-split-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It follows that the `b` combinator actually dequotes both of its parameters,
    and hence either or both can be replaced by an equivalent program:'
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可见，`b`组合器实际上去引用了它的两个参数，因此可以用等效的程序替换它们中的任何一个或两个：
- en: '[PRE20]'
  id: totrans-split-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If both programs compute the identity function, then the effect of the `b`
    combinator is the identity function. If either of the two programs computes the
    identity function, then the effect is the same as that of executing the other,
    which is the same as applying the `i` combinator to the other:'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个程序都计算恒等函数，则`b`组合器的效果是恒等函数。如果两个程序中的任何一个计算恒等函数，则其效果等同于执行另一个程序，这等同于将`i`组合器应用于另一个程序：
- en: '[PRE21]'
  id: totrans-split-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The second equation could be reversed, and this shows that the `i` combinator
    could be *defined* in terms of the `b` combinator.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个等式可以反转，这表明`i`组合器可以根据`b`组合器来*定义*。
- en: 'Quotations are sequences, and sequences can be concatenated. In Joy strings,
    lists and, more generally, quotations can be concatenated with the `concat` operator.
    If `[P]` and `[Q]` have just been pushed, then they can be concatenated to become
    `[P Q]`. The resultant concatenation can be executed by the `i` combinator. The
    net effect is that of executing the two programs, and that is also achieved by
    applying the `b` combinator:'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 引用是序列，序列可以连接。在Joy中，字符串、列表，更一般地说，引用可以使用`concat`运算符连接。如果刚刚推送了`[P]`和`[Q]`，则它们可以连接成`[P
    Q]`。通过`i`组合器执行结果连接的效果就是执行这两个程序，这也可以通过应用`b`组合器来实现：
- en: '[PRE22]'
  id: totrans-split-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But the two quoted programs do not have to be pushed immediately before the
    concatenation or the application of the `b` combinator. Instead they could have
    been constructed from smaller parts or extracted from some larger quotation. Hence
    the more general law:'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是两个引用的程序并不必须立即推送到连接或`b`组合器的应用之前。相反，它们可以从较小的部分构建或从某些较大的引用中提取。因此，更一般的法则是：
- en: '[PRE23]'
  id: totrans-split-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The equation could be reversed, hence the `b` combinator could be *defined*
    in terms of the `i` combinator. The *names* `i` and `b` of the two combinators
    have been chosen because of their similarity to the *I combinator* and *B combinator*
    in *combinatory logic*. The standard text is [{Curry58}](refs.html#%7BCurry58%7D),
    but good expositions are to be found in many other books, for example [{Burge75}](refs.html#%7BBurge75%7D).
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 方程可以反过来，因此`b`组合器可以用`i`组合器来*定义*。这两个组合器的*名称*`i`和`b`之所以选择这样的名字，是因为它们与*组合逻辑*中的*I组合器*和*B组合器*相似。标准文本为[{Curry58}](refs.html#%7BCurry58%7D)，但其他书籍中也有很好的阐述，例如[{Burge75}](refs.html#%7BBurge75%7D)。
- en: Stack oriented combinators
  id: totrans-split-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于堆栈的组合器
- en: The two previous combinators require one or two quoted programs as parameters,
    but the parameters merely have to be in an agreed place, they do not need to be
    on a stack. There are several combinators which only make sense if the data are
    located on a stack.
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个组合器需要一个或两个带引号的程序作为参数，但这些参数只需放在一个约定好的位置上，不需要在堆栈上。如果数据位于堆栈上，那么有几个组合器才有意义。
- en: Sometimes it is necessary to manipulate the stack not at the top but just below
    the top. That is what the `dip` combinator is for. It is behaves like the `i`
    combinator by executing one quotation on top of the stack, except that it leaves
    the item just below the quotation unchanged. In detail, it expects a program `[P]`
    and below that another item `X`. It pops both, saves `X`, executes `P` and then
    restores `X`.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要操作堆栈的不是顶部而是顶部下面的项目。这就是`dip`组合器的用途。它的行为类似于`i`组合器，通过在堆栈顶部执行一个引用，但它会保持位于引用下面的项目不变。具体来说，它期望一个程序`[P]`，在其下面是另一个项目`X`。它弹出这两个项目，保存`X`，执行`P`，然后恢复`X`。
- en: 'For example, in the following the saved and restored item is `4`:'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下示例中，保存和恢复的项目是`4`：
- en: '[PRE24]'
  id: totrans-split-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If a program computes the identity function, then the effect of applying the
    `dip` combinator is to compute the identity function:'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序计算恒等函数，那么应用`dip`组合器的效果就是计算恒等函数：
- en: '[PRE25]'
  id: totrans-split-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Suppose a program `[P]` is on top of the stack, and it is first duplicated
    and then the copy executed with `dip` just below the original `[P]`. Now the original
    has been restored, but suppose it is now popped explicitly. The net effect was
    the same as executing just the original `[P]` with the `i` combinator:'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个程序`[P]`位于堆栈顶部，首先将其复制，然后使用`dip`在原始`[P]`的下面执行副本。现在原始的已经被恢复，但假设现在显式弹出它。净效果与仅使用`i`组合器执行原始`[P]`相同：
- en: '[PRE26]'
  id: totrans-split-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Suppose that there are two programs `[P]` and `[Q]` on top of the stack, with
    `[Q]` on top. It is required to execute `[P]` while saving `[Q]` above. One way
    to do that is this: First push `[i]`. Now `[Q]` is the second element. Executing
    `dip` will save `[Q]` and execute `[i]` on the stack which now has `[P]` on the
    top. That amounts to executing `[P]`, and after that `[Q]` is restored.'
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设堆栈顶部有两个程序`[P]`和`[Q]`，其中`[Q]`位于顶部。要执行`[P]`并将`[Q]`保存在上面的一种方法是：首先推入`[i]`。现在`[Q]`是第二个元素。执行`dip`将保存`[Q]`并在堆栈上执行`[i]`，现在堆栈顶部有`[P]`。这相当于执行`[P]`，之后`[Q]`被恢复。
- en: Suppose further that it is now required to execute `[Q]`, and that is easily
    done with the `i` combinator. The net effect of all this is the same as executing
    first `[P]` and then `[Q]`, which could have been done with the `b` combinator.
    Hence
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在需要执行`[Q]`，这可以通过`i`组合器轻松完成。所有这些的净效果与先执行`[P]`，然后执行`[Q]`是相同的，这可以通过`b`组合器完成。因此
- en: '[PRE27]'
  id: totrans-split-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last two equations show that the `dip` combinator could be used to *define*
    both the `i` combinator and the `b` combinator. The reverse is not possible.
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方程表明`dip`组合器可以用来*定义*`i`组合器和`b`组合器。反之则不可能。
- en: The last two equations also serve to illustrate algebraic manipulation of Joy
    programs. In the last equation the `i` combinator occurs twice, once quoted and
    once unquoted. Both occurrences can be replaced in accordance with the previous
    equation, and this yields
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方程还用来说明Joy程序的代数操作。在最后一个方程中，`i`组合器出现了两次，一次带引号，一次无引号。根据前一个方程，这两个出现都可以替换，结果是
- en: '[PRE28]'
  id: totrans-split-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The substitution of the unquoted occurrence is unproblematic. But the other
    substitution requires comment. Quoted occurrences can be substituted only in a
    context of dequotation, and in this case such a context is given by the `dip`
    combinator.
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: 未引用出现的替换没有问题。但其他替换需要说明。引用的出现只能在去引用的上下文中替换，在这种情况下，`dip`组合器提供了这样的上下文。
- en: Again suppose that there are two quoted programs `[P]` and `[Q]` on the stack.
    If the `dip` combinator is executed next, it will cause the topmost quotation
    `[Q]` to be executed while saving and later restoring `[P]` below. Suppose that
    the `i` combinator is executed next, this will cause the restored `[P]` to be
    executed. So the net effect of the two combinators is to execute first `P` and
    then `Q`. That same effect could have been achieved by first swapping `[P]` and
    `[Q]` around, so that `[P]` is on top, and then executing the `b` combinator.
    This is expressed in the left law below. The right law says the same thing, and
    it shows another way in which the `b` combinator could have been defined.
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设栈上有两个引用程序`[P]`和`[Q]`。如果执行`dip`组合器，它将导致执行栈顶引用`[Q]`的同时保存并稍后恢复`[P]`。假设接下来执行`i`组合器，这将导致恢复的`[P]`被执行。因此，这两个组合器的净效果是首先执行`P`，然后执行`Q`。同样的效果也可以通过先交换`[P]`和`[Q]`，使`[P]`置于顶部，然后执行`b`组合器来实现。左定律下表达了同样的事情。右定律也表明了定义`b`组合器的另一种方式。
- en: '[PRE29]'
  id: totrans-split-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Function composition is associative, and hence the following holds:'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是可结合的，因此以下内容成立：
- en: '[PRE30]'
  id: totrans-split-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To eliminate the three quotations from this equation observe that they can
    be written on the left of both sides provided that the `b` combinator and the
    `i` combinator are applied appropriately. For the left side this is easy:'
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要消除此方程式中的三个引用，请注意它们可以写在两侧，前提是适当应用`b`组合器和`i`组合器。对于左侧来说，这很容易：
- en: '[PRE31]'
  id: totrans-split-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the right side it is a little harder since the `i` combinator has to be
    applied to `[P]` which is obscured not by one but two other quotations. The `dip`
    combinator has to be used on itself in this case, as follows:'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于右侧来说，稍微有些困难，因为`i`组合器必须应用于由两个其他引用所遮蔽的`[P]`。在这种情况下，必须使用`dip`组合器作用于自身，如下所示：
- en: '[PRE32]'
  id: totrans-split-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Combining the two right hand sides and cancelling the common three quotations
    we obtain the following to expressing the associativity of function composition:'
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个右侧合并并取消共同的三个引用，我们得到以下表达函数组合结合律的方式：
- en: '[PRE33]'
  id: totrans-split-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this law we can even replace the `i` combinator and the `b` combinator in
    accordance with earlier definitions:'
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此定律中，我们甚至可以根据早期的定义替换`i`组合器和`b`组合器：
- en: '[PRE34]'
  id: totrans-split-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It is possible to cancel the final `pop` on both sides, but it is not possible
    to cancel the prefinal `dip` on both sides. This unlikely law also expresses the
    associativity of function composition. But the most elegant way of expressing
    the associativity is by using a variant of the `dip` combinator, called `dipd`,
    which might be defined by
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可以取消两侧的最终`pop`，但不能取消两侧的前终止`dip`。这个不太可能的定律也表达了函数组合的结合性。但最优雅地表达结合性的方式是使用`dip`组合器的变种，称为`dipd`，可以这样定义：
- en: '[PRE35]'
  id: totrans-split-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then the associativity can be expressed by
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，可通过以下方式表达结合律：
- en: '[PRE36]'
  id: totrans-split-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ([{Henson87}](refs.html#%7BHenson87%7D) criticises presentations of FP-systems,
    originally due to [{Backus78}](refs.html#%7BBackus78%7D) in that they give no
    law to this effect although they use it in proofs.)
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: ([{Henson87}](refs.html#%7BHenson87%7D)批评了FP系统的展示，最初由[{Backus78}](refs.html#%7BBackus78%7D)提出，因为它们虽然在证明中使用了这一效果，但未给出相应的定律。)
- en: The combination of the `dip` combinator immediately followed by the `i` combinator
    is sometimes useful for arranging the top few elements on the stack in a form
    that is suitable for executing a quoted program `[P]` that is at the top of the
    stack.
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着的`dip`组合器与`i`组合器的组合有时对于将栈顶的几个元素排列成适合执行位于栈顶的引用程序`[P]`是有用的。
- en: 'This is how it is done: first another quoted program `[Q]` is pushed, and executed
    using the `dip` combinator. This will save and restore the `[P]`, but arrange
    the stack in accordance with `[Q]`. Then the restored `[P]` is executed by the
    `i` combinator. Depending on the `[Q]` that is chosen, the three part combination
    of `[Q]`, the `dip` combinator and the `i` combinator will prepare the stack for
    the execution of `[P]`.'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是做法：首先推入另一个引用程序`[Q]`，并使用`dip`组合器执行它。这将保存并恢复`[P]`，但会按照`[Q]`的方式排列栈。然后通过`i`组合器执行恢复的`[P]`。根据选择的`[Q]`，`[Q]`、`dip`组合器和`i`组合器的三部分组合将准备好栈，以执行`[P]`。
- en: Since such a combination still requires the `[P]` on the stack, any such combination
    has the effect of a combinator. The following illustrate some simple choices of
    `[Q]` that are sometimes useful. The names of these combinators have been chosen
    because of their similarity to the *K combinator*, *W combinator* and the *C combinator*
    in *combinatory logic*.
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这样的组合仍然需要堆栈上的`[P]`，因此任何这样的组合都具有组合子的效果。以下是一些有时有用的简单选择的`[Q]`的示例。这些组合子的名称之所以被选择，是因为它们与*组合逻辑*中的*K组合子*、*W组合子*和*C组合子*相似。
- en: '[PRE37]'
  id: totrans-split-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: More general laws
  id: totrans-split-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更一般的法则
- en: 'Suppose that there is a quoted program `[P]` on top of the stack. This could
    now be executed by some combinator, say `C`. Alternatively, one could push the
    quotation `[C]` and then use the `cons` operator to insert the earlier `[P]` into
    the later quotation, and this produces `[[P] C]`. This of course may be executed
    by the `i` combinator. When that happens the inner `[P]` is pushed, thus partly
    undoing the `cons` operation. But then `C` will be executed. The net effect is
    the same as the earlier alternative. So we have: For all operators or combinators
    `C`'
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设堆栈顶部有一个引用程序`[P]`。这现在可以由某个组合子，比如`C`执行。或者，可以推送引用`[C]`，然后使用`cons`运算符将之前的`[P]`插入到后面的引用中，这样就生成了`[[P]
    C]`。当然，这可以由`i`组合子执行。当这发生时，内部的`[P]`被推送，部分撤销了`cons`操作。但然后`C`将被执行。其净效果与前面的替代方法相同。因此我们有：对于所有运算符或组合子`C`
- en: '[PRE38]'
  id: totrans-split-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It should be remarked that this theorem also holds for operators, say `O`, instead
    of combinators `C`.
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: 应当指出，这个定理也适用于运算符，比如`O`，而不仅仅是组合子`C`。
- en: 'Again suppose that there is a quoted program `[P]` on top of the stack. It
    could be executed by some combinator `C`, or one could do this: push the quotation
    `[i]`, `cons` the earlier `[P]` into that and now execute `C`. The `cons` operation
    produced `[[P] i]` and when this is executed by `C`, the inner `[P]` is pushed
    partly undoing the `cons`. Then the `i` combinator actually executes this. The
    net effect is that of just executing `C`. Hence for all combinators `C`'
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再假设堆栈顶部有一个引用程序`[P]`。它可以由某个组合子`C`执行，或者可以这样做：推送引用`[i]`，用`cons`将之前的`[P]`插入其中，现在执行`C`。`cons`操作产生了`[[P]
    i]`，当这个被`C`执行时，内部的`[P]`部分地撤销了`cons`。然后`i`组合子实际上执行了这个。其净效果就是执行`C`。因此对于所有组合子`C`
- en: '[PRE39]'
  id: totrans-split-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The two laws above may be combined: for all combinators C'
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两条法则可以结合：对于所有组合子`C`
- en: '[PRE40]'
  id: totrans-split-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'So far we have only encountered one combinator which takes two quoted parameters
    - the `b` combinator. But Joy has a large number of combinators which take two,
    three or even four quoted parameters. The following concerns combinators which
    expect at least two quoted programs as parameters. For such combinators the first
    three laws holds unchanged, but these variations also hold:'
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只遇到了一个需要两个引用参数的组合子 - `b`组合子。但是Joy语言有大量的组合子，它们需要两个、三个甚至四个引用参数。以下是那些期望至少有两个引用程序作为参数的组合子。对于这样的组合子，前三个法则保持不变，但也有以下变化：
- en: '[PRE41]'
  id: totrans-split-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The principle generalises to combinators with at least three quoted parameters,
    by allowing three `cons` operations to occur.
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则推广到至少有三个引用参数的组合子，允许三个`cons`操作的发生。
- en: 'Finally, the second law generalises to all parameters of a combinator: any
    one parameter `[P]` can be replaced by `[[P] i]`. The replacement can of course
    be constructed by `cons`ing `[P]` into `[i]`. That of course may be done for all
    quotation parameters. If there is just the one parameter `[P]`, then `cons`ing
    it into `[i]` to produce `[[P] i]` is easy enough, as in the second law.'
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第二条法则推广到组合子的所有参数：任何一个参数`[P]`都可以被`[[P] i]`替换。当然，这个替换可以通过将`[P]`与`[i]`进行`cons`操作来构造。当然，对于所有引用参数都可以这样做。如果只有一个参数`[P]`，那么将其`cons`到`[i]`中以生成`[[P]
    i]`就足够简单，就像第二条法则一样。
- en: If there are two parameters `[P]` and `[Q]` it already becomes tedious to change
    them to `[[P] i]` and `[[Q] i]`. If there are three or more quotation parameters,
    then the program to produce the three changes could be rather obscure.
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个参数`[P]`和`[Q]`，将它们改变为`[[P] i]`和`[[Q] i]`已经变得非常乏味。如果有三个或更多的引用参数，那么生成这三个变化的程序可能会相当复杂。
- en: 'Joy has a combinator which can use a function to `map` the elements of a list
    to a list of the same length containing the results of applying the function.
    Several special forms take as a parameter not an arbitrary list but a specified
    number of one, two, three and so on elements from the stack. These are the `app1`
    combinator, the `app2` combinator, the `app3` combinator and so on. These are
    just the right combinators to produce the changes required for the parameters
    of a combinator. The following laws hold for combinators `C1`, `C2` and `C3` requiring
    one, two or three quotation parameters:'
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
  zh: Joy有一个组合子可以使用函数对列表的元素进行`map`，生成一个包含应用函数结果的相同长度的列表。几个特殊形式的参数不是任意列表，而是来自堆栈的指定数量的一个、两个、三个等元素。这些是`app1`组合子、`app2`组合子、`app3`组合子等。这些组合子正好用于生成组合子参数所需的更改。对于需要一个、两个或三个引用参数的组合子`C1`、`C2`和`C3`，以下法则成立：
- en: '[PRE42]'
  id: totrans-split-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To illustrate for a combinator C3:'
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组合子C3的说明：
- en: '[PRE43]'
  id: totrans-split-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Computationally it is of course pointless to replace a quotation such as `[P]`
    by `[[P] i]` if the quotations are being used as parameters for a combinator.
    But the replacements are invaluable in a Joy interpreter written in Joy. This
    interpreter is essentially a complex combinator, appropriately called `joy`, and
    it has to behave just like the `i` combinator. In the definition of the `joy`
    combinator, the implementation of all combinators uses the above mapping combinators
    but with `[[joy] cons]` instead of `[[i] cons]`.
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算角度来看，当引用被用作组合子的参数时，将`[P]`替换为`[[P] i]`当然是毫无意义的。但在用Joy编写的Joy解释器中，这些替换是无价的。这个解释器本质上是一个复杂的组合子，恰当地称为`joy`，它必须像`i`组合子一样行为。在`joy`组合子的定义中，所有组合子的实现都使用上述映射组合子，但用`[[joy]
    cons]`代替`[[i] cons]`。
- en: Elimination of Definitions
  id: totrans-split-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除定义
- en: One of the problems of large pieces of software concerns the complexity of interdependent
    parts and the need to make interfaces lean. To some extent this is a matter of
    information hiding, and programming languages achieve this in various ways. Most
    have local symbols such as formal parameters of functions and local program variables
    of procedures. Many have full block structure allowing declarations of functions
    and procedures to be nested and hence invisible from the outside. Some have modules
    or other compilation units which allow further information hiding in larger program
    components. Joy approaches the problem in a different way -- the information that
    needs to be hidden is minimised in the first place. Mostly the problem arises
    from declarations of named functions and procedures and their named formal parameters.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
  zh: 大型软件的一个问题涉及相互依赖部分的复杂性和使接口精简的需求。在某种程度上，这是信息隐藏的问题，编程语言通过各种方式实现这一点。大多数语言都有局部符号，比如函数的形式参数和过程的局部变量。许多语言具有完整的块结构，允许函数和过程的声明嵌套，因此在外部不可见。一些语言具有模块或其他编译单元，允许在更大的程序组件中进一步隐藏信息。Joy以不同的方式解决这个问题
    -- 首先最小化需要隐藏的信息。主要问题大多源于命名函数和过程的声明及其命名的形式参数。
- en: There are several reasons why one might want to declare a function, because
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因可能需要声明一个函数，
- en: it requires recursion, or
  id: totrans-split-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要递归，或者
- en: it is needed in several seemingly unrelated places in a program, or
  id: totrans-split-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在程序的几个看似无关的地方都是必需的，或者
- en: it makes the program clearer.
  id: totrans-split-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使程序更清晰。
- en: The third reason is always valid. In Joy the second reason is much less compelling,
    and the first has almost no force at all.
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个原因总是有效的。在Joy中，第二个原因远不那么强烈，第一个几乎没有力量。
- en: Joy has a large number of combinators which permit computation of anonymous
    functions which are normally defined recursively. It also has combinators that
    permit repeated calls of such functions in some related patterns. Joy programs
    which use suitable combinators to allow the computation of anonymous functions
    with anonymous formal parameters.
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
  zh: Joy有大量的组合子，允许计算通常通过递归定义的匿名函数。它还有允许在某些相关模式中重复调用这些函数的组合子。Joy程序使用适当的组合子允许计算具有匿名形式参数的匿名函数。
- en: 'Consider the following recursive definition and use of the *factorial* function
    in a (fantasy) functional language:'
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在（虚构的）函数式语言中对*阶乘*函数进行以下递归定义和使用：
- en: '[PRE44]'
  id: totrans-split-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The call in the second line should return `120`. Joy has a number of ways of
    doing essentially the same computation without introducing the *name* `factorial`
    and without introducing the *name* of the formal parameter `n`. Several of these
    ways are still modelled on the recursive definition and have approximately the
    same length. Two of them are based on the fact that the definition has the pattern
    of *linear recursion*, indeed *primitive recursion*. As in all languages the use
    of *accumulating parameter*s can avoid the recursion altogether, but that is not
    the point here.
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行的调用应返回`120`。乔伊有多种方法可以进行基本上相同的计算，而不引入*名称* `factorial` 和不引入形式参数 `n` 的*名称*。其中几种方法仍然是基于递归定义，并且长度大致相同。其中两种是基于定义具有*线性递归*和*原始递归*的模型。正如所有语言一样，使用*累积参数*可以完全避免递归，但这不是这里的重点。
- en: The humble `i` and `dip` combinators were certainly not designed for recursion,
    so it will come as a surprise that they can be used to emulate recursion without
    naming the function or its formal parameter. To make the recursion possible, every
    call of the anonymous function must be able to access itself again, and this is
    done by giving it its own body as a quoted parameter on the top of the stack.
    This is achieved by always duplicating the quoted body first and then using the
    `i` combinator to execute the duplicate. The `dip` combinator can be used to access
    the stack below the quoted body. The only other combinator needed is the `ifte`
    combinator which achieves the same kind of two-way branching as the `if-then-else`
    in the conventional definition above.
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
  zh: 平凡的`i`和`dip`组合子显然不是为了递归而设计的，因此它们能够用于模拟递归而不命名函数或其形式参数将是一种惊喜。为了使递归成为可能，必须使匿名函数的每次调用都能够再次访问自身，这通过在堆栈顶部给它自己的体作为引用参数来实现。这是通过始终先复制引用体然后使用`i`组合子执行复制来实现的。`dip`组合子可以用于访问引用体下面的堆栈。唯一需要的另一个组合子是`ifte`组合子，它实现了与上面传统定义中的`if-then-else`相同类型的两路分支。
- en: 'This is the program:'
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序：
- en: '[PRE45]'
  id: totrans-split-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The line numbers are only included for reference. Execution begins in line 1
    by pushing the actual parameter `5` onto the stack. Then the long quotation extending
    from line 2 to line 7 is pushed onto the stack. This quotation is the body of
    the function, it corresponds to the right hand side of the conventional definition.
    Execution continues in line 8 where the long quotation is duplicated and the top
    copy is executed by the `i` combinator. This execution has the effect of pushing
    the two short quotations in lines 2 and 3 and also the longer quotation in lines
    4 to 6\. So at this point the stack contains the parameter `5` and above that
    four quotations.
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
  zh: 行号仅用于参考。执行从第1行开始，将实际参数 `5` 推入堆栈。然后将从第2行到第7行的长引用推入堆栈。这个引用是函数体，对应于传统定义的右侧。执行继续到第8行，其中长引用被复制，顶部副本由
    `i` 组合子执行。此执行的效果是将第2行和第3行的两个短引用以及第4行到第6行的较长引用推入堆栈。因此，在这一点上，堆栈包含参数 `5`，并且以上四个引用。
- en: But now the `ifte` combinator in line 7 executes. It pops the last three quotations
    and saves them elsewhere. Then it executes the if-part, the saved quotation from
    line 2\. That will pop what is now the top of the stack, the body of the function
    from lines 2 to 7. This exposes the number which is the parameter, and it is compared
    with `0`.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，`ifte` 组合子在第7行执行。它弹出最后三个引用并将它们保存在其他地方。然后执行 if-部分，即来自第2行的保存的引用。这将弹出现在堆栈顶部的函数体，从第2行到第7行。这将显示该参数是一个数字，并将其与`0`进行比较。
- en: 'The comparison will yield a truth value which the `ifte` combinator will use
    to determine whether to execute the saved then-part from line 3 or the saved else-part
    from lines 4 to 6\. In either case the stack is first restored to what it was
    before the if-part was executed: the quoted body of the function is again on top
    of the stack and below it is the actual parameter for this particular call. If
    the most recent comparison by the if-part was true, then the saved then-part from
    line 3 is executed.'
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
  zh: 比较将产生一个真值，`ifte` 组合子将使用它来确定是执行从第3行保存的 then 部分，还是执行从第4行到第6行保存的 else 部分。在任何情况下，堆栈首先恢复到执行
    if-部分之前的状态：再次将函数的引用体置于堆栈顶部，并且以下是这个特定调用的实际参数。如果最近的比较通过 if-部分是真的，那么将执行从第3行保存的 then
    部分。
- en: This results in the body and the actual parameter being popped off the stack
    and replaced by `1`, the factorial of `0`. On the other hand, if the most recent
    comparison was false, then the saved else-part from lines 4 to 6 is executed.
    For the later multiplication the parameter has to be duplicated and the top duplicate
    has to be decremented. Since the body of the function is in the way, the duplicating
    and decrementing is done via the `dip` combinator in line 4.
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致函数体和实际参数从堆栈中弹出，并被`1`替换，即`0`的阶乘。另一方面，如果最近的比较为假，则执行从第4行到第6行保存的else部分。为了后续的乘法运算，参数必须被复制，并且顶部的副本必须被减少。由于函数体的存在，复制和减少是通过第4行的`dip`组合子完成的。
- en: At this point the top three elements on the stack are the original parameter
    for this call, then the decremented duplicate, and right on top of that the quoted
    body of the function. It is now necessary to compute the factorial of the decremented
    duplicate, and this call may need access to the body again. So the body cannot
    be simply executed by the `i` combinator, but first the body is duplicated in
    line 5 and then the duplicate is executed by the `i` combinator. Execution of
    that duplicate body will eventually terminate, and then the top two elements will
    be the original parameter and the factorial of what was its decremented duplicate.
    The two numbers are now multiplied in line 6, yielding the required factorial
    of the parameter for this call. This completes the execution of the else-part
    from lines 4 to 6\. Irrespective of whether the then-part or the else-part was
    executed, the execution of the `ifte` combinator is now complete.
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此时堆栈上的前三个元素是这次调用的原始参数，然后是递减的副本，顶部是函数的引用体。现在必须计算递减副本的阶乘，这次调用可能需要再次访问函数体。因此，不能简单地通过`i`组合子执行函数体，而是在第5行先复制函数体，然后通过`i`组合子执行副本。执行该复制的函数体最终将终止，然后顶部两个元素将是原始参数和其递减副本的阶乘。然后在第6行将这两个数字相乘，得到此调用参数的所需阶乘。这完成了从第4行到第6行else部分的执行。无论then部分还是else部分被执行，`ifte`组合子的执行都已完成。
- en: This completes the execution of the body of the function in lines 2 to 7\. It
    also completes the execution of whichever occurrence of the `i` combinator in
    lines 5 or 8 triggered this execution of the body. Ultimately the execution of
    the `i` combinator in line 8 will have completed, and at this point the parameter
    `5` from line 1 will have been replaced by its factorial `120` as required.
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了在第2行到第7行函数体的执行。它也完成了在第5行或第8行触发此函数体执行的任何`i`组合子的执行。最终在第8行的`i`组合子的执行也将完成，此时第1行的参数`5`将被其阶乘`120`替换，如所需。
- en: 'Two short comments are in order: Firstly, the *description* of the program
    was given in an imperative or procedural mode which is psychologically helpful.
    But this does not change the fact that all Joy programs and all their parts denote
    functions. Secondly, the program can be written using only the `dip` combinator
    and the `ifte` combinator by substituting `dup dip pop` for the two calls of the
    `i` combinator in lines 5 and 8.'
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做两点简短的评论：首先，程序的*描述*是以一种心理上有帮助的命令式或过程化方式给出的。但这并不改变所有Joy程序及其所有部分表示函数的事实。其次，可以通过在第5行和第8行的两次调用`i`组合子中使用`dup
    dip pop`替换，仅使用`dip`组合子和`ifte`组合子来编写该程序。
- en: Of course this program is a *tour de force*, it is ugly and inefficient. With
    more suitable combinators much crisper and more efficient programs can be written.
    In particular, the repeated pushing and saving of the quoted if-part, then-part
    and else-part is not necessary. Also, the repeated duplication of the quoted body
    is not necessary, and consequently the three parts do not have to work around
    the quoted body when it is in the way on the top. In fact, the essence of the
    if-part and most of the else-part are built into the `primrec` combinator for
    primitive recursion. The entire program then is
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个程序是一次*技艺的展示*，它既难看又低效。使用更合适的组合子可以编写更简洁和高效的程序。特别是，不必重复推送和保存引用的if部分、then部分和else部分。同时，不需要重复复制引用的函数体，因此当它位于顶部时，这三部分不必绕过函数体。事实上，if部分的本质和大部分else部分已经集成到了`primrec`组合子中，用于原始递归。整个程序如下：
- en: '[PRE46]'
  id: totrans-split-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As mentioned before, even the use of recursion can be eliminated in favour of
    a more efficient loop combinator which uses an accumulating parameter.
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，甚至可以消除递归的使用，而采用使用累积参数的更高效的循环组合子。
- en: Summary
  id: totrans-split-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This paper has attempted to explain the theoretical foundations of the language
    Joy. Much of the semantics is summarised by observing that the following are true:'
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本文试图解释语言Joy的理论基础。通过总结以下真实情况，语义的大部分被概括如下：
- en: '[PRE47]'
  id: totrans-split-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first *seems* to express the identity of numbers. The second *seems* to
    express the identity of functions which both double a given number which they
    expect on the stack. The third *seems* to express the identity of functionals,
    or second order functions which take two first order functions as parameter and
    compose them.
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个*似乎*表达了数字的身份。第二个*似乎*表达了函数的身份，这两个函数都会将它们在栈上期望的给定数字加倍。第三个*似乎*表达了函数式的身份，或者说是二阶函数，它们将两个一阶函数作为参数并组合它们。
- en: While these readings are sometimes helpful, the unity of Joy semantics really
    forces a different interpretation. All three equations express identity of Joy
    functions which take one argument stack and yield one value stack.
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些阅读有时有所帮助，但Joy语义的统一确实促使了不同的解释。所有三个等式都表达了Joy函数的身份，这些函数接受一个参数栈并生成一个值栈。
- en: The mathematical discipline of *category theory* deals with functions of one
    arguments. All Joy functions are of that kind, too. In fact all monoids are special
    cases of categories, so Joy's syntactic monoid of concatenation and Joy's semantic
    monoid of function composition are categories. So some fundamental connections
    should be expected. In particular, Joy is related to Cartesian closed categories,
    and to the "Combinatory Abstract Machine" *CAM*, see for example [{Poigne92}](refs.html#%7BPoigne92%7D).
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*范畴论*这一数学学科处理的是单参数函数。所有Joy函数也属于这种类型。事实上，所有的幺半群都是范畴的特例，因此Joy的语法幺半群与Joy的语义幺半群都是范畴。因此，应该期望一些基本的联系。特别是，Joy与笛卡尔闭范畴相关，并与"组合抽象机器"*CAM*有关，请参见例如[{Poigne92}](refs.html#%7BPoigne92%7D)。'
- en: The paper [j00ovr](J00OVR.HTML) contains an overview of Joy and references to
    other papers dealing with specific aspects of Joy.
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该论文[j00ovr](J00OVR.HTML)包含对Joy的概述，并参考了处理Joy特定方面的其他论文。
- en: '* * *'
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
