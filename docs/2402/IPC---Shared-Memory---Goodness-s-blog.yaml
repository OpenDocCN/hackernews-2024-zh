- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: æœªåˆ†ç±»'
- en: 'date: 2024-05-27 14:31:08'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:31:08'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: IPC - Shared Memory | Goodnessâ€™s blog
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPC - Shared Memory | Goodness's blog
- en: æ¥æºï¼š[https://goodyduru.github.io/os/2024/01/31/ipc-shared-memory.html](https://goodyduru.github.io/os/2024/01/31/ipc-shared-memory.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://goodyduru.github.io/os/2024/01/31/ipc-shared-memory.html](https://goodyduru.github.io/os/2024/01/31/ipc-shared-memory.html)
- en: In the previous article, we covered the [Message Queues](https://goodyduru.github.io/os/2023/11/13/ipc-message-queues.html)
    IPC mechanism. This article will cover another one called Shared Memory.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†[æ¶ˆæ¯é˜Ÿåˆ—](https://goodyduru.github.io/os/2023/11/13/ipc-message-queues.html)çš„IPCæœºåˆ¶ã€‚æœ¬æ–‡å°†ä»‹ç»å¦ä¸€ç§ç§°ä¸ºå…±äº«å†…å­˜çš„æœºåˆ¶ã€‚
- en: Before discussing shared memory and how it can be used for IPC, we must know
    why such a thing as â€œShared Memoryâ€ exists since we know that all the processes
    share the RAM they should be sharing memory. The thing is, they share and donâ€™t
    share. This admittedly contradictory event is due to the magic of memory addressing.
    Letâ€™s talk about that for a bit.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¨è®ºå…±äº«å†…å­˜åŠå…¶åœ¨IPCä¸­çš„ç”¨é€”ä¹‹å‰ï¼Œæˆ‘ä»¬å¿…é¡»äº†è§£ä¸ºä»€ä¹ˆä¼šå­˜åœ¨â€œå…±äº«å†…å­˜â€è¿™ç§ä¸œè¥¿ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“æ‰€æœ‰è¿›ç¨‹å…±äº«å®ƒä»¬åº”è¯¥å…±äº«çš„RAMã€‚é—®é¢˜åœ¨äºï¼Œå®ƒä»¬æ—¢å…±äº«åˆä¸å…±äº«ã€‚è¿™ç§æ˜æ˜¾çŸ›ç›¾çš„ç°è±¡å½’å› äºå†…å­˜å¯»å€çš„é­”åŠ›ã€‚è®©æˆ‘ä»¬ç¨å¾®è°ˆè°ˆè¿™ä¸ªé—®é¢˜ã€‚
- en: Memory Addressing
  id: totrans-split-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å†…å­˜å¯»å€
- en: 'There are two modes of addressing memory: **physical** and **virtual**^([[1]](#footer-note-1)).
    In physical addressing mode, when a process reads data from a memory address,
    the CPU gets it from the same address in RAM and hands it over to the process.
    Ditto for writes. Physical addressing was the only way to access the RAM in early
    microprocessors and is still used in many embedded computers.'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: è®¿é—®å†…å­˜æœ‰ä¸¤ç§æ¨¡å¼ï¼š**ç‰©ç†**å’Œ**è™šæ‹Ÿ**^([[1]](#footer-note-1))ã€‚åœ¨ç‰©ç†å¯»å€æ¨¡å¼ä¸‹ï¼Œå½“ä¸€ä¸ªè¿›ç¨‹ä»å†…å­˜åœ°å€è¯»å–æ•°æ®æ—¶ï¼ŒCPUä»RAMä¸­çš„ç›¸åŒåœ°å€è·å–æ•°æ®å¹¶äº¤ç»™è¿›ç¨‹ã€‚å†™å…¥ä¹Ÿæ˜¯å¦‚æ­¤ã€‚æ—©æœŸå¾®å¤„ç†å™¨åªèƒ½é€šè¿‡ç‰©ç†å¯»å€æ–¹å¼è®¿é—®RAMï¼Œåœ¨è®¸å¤šåµŒå…¥å¼è®¡ç®—æœºä¸­ä»åœ¨ä½¿ç”¨ã€‚
- en: Physical addressing is fine when only one process is expected to run on the
    computer. It is a disaster for a multi-process system. For example, if 2 different
    processes, A and B, are up simultaneously, A could write to a memory address B
    also reads from. Even worse, A could write to a memory address containing part
    of Bâ€™s executable code even if B is the kernel process.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: å½“åªæœ‰ä¸€ä¸ªè¿›ç¨‹é¢„æœŸåœ¨è®¡ç®—æœºä¸Šè¿è¡Œæ—¶ï¼Œç‰©ç†å¯»å€æ˜¯å¯ä»¥æ¥å—çš„ã€‚ä½†å¯¹äºå¤šè¿›ç¨‹ç³»ç»Ÿæ¥è¯´ï¼Œå®ƒæ˜¯ç¾éš¾æ€§çš„ã€‚ä¾‹å¦‚ï¼Œå¦‚æœåŒæ—¶è¿è¡Œä¸¤ä¸ªä¸åŒçš„è¿›ç¨‹Aå’ŒBï¼ŒAå¯èƒ½ä¼šå†™å…¥Bä¹Ÿè¯»å–çš„å†…å­˜åœ°å€ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œå³ä½¿Bæ˜¯å†…æ ¸è¿›ç¨‹ï¼ŒAä¹Ÿå¯èƒ½ä¼šå†™å…¥åŒ…å«Bå¯æ‰§è¡Œä»£ç ä¸€éƒ¨åˆ†çš„å†…å­˜åœ°å€ã€‚
- en: The above issue is one of the reasons why virtual addressing is the memory address
    mode used in many microprocessor architectures today^([[2]](#footer-note-2)).
    In virtual addressing mode, when a process reads data from a memory address, this
    memory address is translated to a physical address by the [MMU](https://en.wikipedia.org/wiki/Memory_management_unit),
    and the data stored at that physical address is fetched from and handed over to
    the process. This is done without the knowledge of the process.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°é—®é¢˜æ˜¯ä¸ºä»€ä¹ˆè™šæ‹Ÿå¯»å€æ˜¯å½“ä»Šè®¸å¤šå¾®å¤„ç†å™¨æ¶æ„ä¸­ä½¿ç”¨çš„å†…å­˜åœ°å€æ¨¡å¼ä¹‹ä¸€çš„åŸå› ä¹‹ä¸€^([[2]](#footer-note-2))ã€‚åœ¨è™šæ‹Ÿå¯»å€æ¨¡å¼ä¸‹ï¼Œå½“ä¸€ä¸ªè¿›ç¨‹ä»å†…å­˜åœ°å€è¯»å–æ•°æ®æ—¶ï¼Œè¿™ä¸ªå†…å­˜åœ°å€ä¼šè¢«è½¬æ¢ä¸ºç‰©ç†åœ°å€ï¼Œç”±[å†…å­˜ç®¡ç†å•å…ƒï¼ˆMMUï¼‰](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83)æ¥å®Œæˆï¼Œç„¶åä»è¯¥ç‰©ç†åœ°å€è¯»å–æ•°æ®å¹¶äº¤ç»™è¿›ç¨‹ã€‚è¿™ä¸€åˆ‡éƒ½åœ¨è¿›ç¨‹çš„ä¸çŸ¥æƒ…ä¸‹å®Œæˆã€‚
- en: This address translation is done using the help of a [**Page Table**](https://en.wikipedia.org/wiki/Page_table).
    The Page Table stores the mapping between virtual and physical addresses in [page](https://en.wikipedia.org/wiki/Page_(computer_memory))^([[3]](#footer-note-3))
    units. Every process has its page table and allows the process to reference **almost^([[4]](#footer-note-4))**
    all the addresses up to the tableâ€™s maximum address^([[5]](#footer-note-5))
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§åœ°å€è½¬æ¢æ˜¯é€šè¿‡[**é¡µè¡¨**](https://zh.wikipedia.org/wiki/%E9%A1%B5%E8%A1%A8)æ¥å®Œæˆçš„ã€‚é¡µè¡¨ä»¥[é¡µ](https://zh.wikipedia.org/wiki/%E9%A1%B5_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98))å•å…ƒå­˜å‚¨è™šæ‹Ÿåœ°å€å’Œç‰©ç†åœ°å€ä¹‹é—´çš„æ˜ å°„^([[3]](#footer-note-3))ã€‚æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªå·±çš„é¡µè¡¨ï¼Œå¹¶å…è®¸è¿›ç¨‹å¼•ç”¨æ¥è¿‘**å‡ ä¹^([[4]](#footer-note-4))**æ‰€æœ‰çš„åœ°å€ç›´åˆ°è¡¨çš„æœ€å¤§åœ°å€^([[5]](#footer-note-5))ã€‚
- en: Virtual addressing allows multiple processes to co-exist without stepping on
    each other toes. If our 2 processes from the earlier example try to access the
    same memory address, that address will point to two different addresses in the
    RAM. So, memory address 4523 could translate to 9619 for A and 86443 for B. This
    means they donâ€™t share virtual memory but share physical memory.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: è™šæ‹Ÿå¯»å€å…è®¸å¤šä¸ªè¿›ç¨‹å…±å­˜è€Œä¸ä¼šäº’ç›¸å¹²æ‰°ã€‚å¦‚æœæˆ‘ä»¬çš„ä¸¤ä¸ªè¿›ç¨‹å°è¯•è®¿é—®åŒä¸€å†…å­˜åœ°å€ï¼Œé‚£ä¹ˆè¯¥åœ°å€å°†åœ¨RAMä¸­æŒ‡å‘ä¸¤ä¸ªä¸åŒçš„åœ°å€ã€‚å› æ­¤ï¼Œå†…å­˜åœ°å€4523å¯èƒ½å¯¹åº”äºAçš„9619å’ŒBçš„86443ã€‚è¿™æ„å‘³ç€å®ƒä»¬ä¸å…±äº«è™šæ‹Ÿå†…å­˜ä½†å…±äº«ç‰©ç†å†…å­˜ã€‚
- en: If processes can only use virtual memory, which cannot be shared, how can they
    communicate using Shared Memory? Letâ€™s look at that.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¿›ç¨‹åªèƒ½ä½¿ç”¨æ— æ³•å…±äº«çš„è™šæ‹Ÿå†…å­˜ï¼Œå®ƒä»¬å¦‚ä½•ä½¿ç”¨å…±äº«å†…å­˜è¿›è¡Œé€šä¿¡å‘¢ï¼Ÿè®©æˆ‘ä»¬æ¥çœ‹çœ‹è¿™ä¸ªé—®é¢˜ã€‚
- en: Shared Memory
  id: totrans-split-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å…±äº«å†…å­˜
- en: Shared memory is a segment of memory shared between processes. The segment of
    physical memory is mapped to each processâ€™s virtual memory via their page tables.
    Once this is done, the process can read and write to this segment just like with
    other segments. Any data written to this segment is visible to other participating
    processes. The segmentâ€™s virtual address could differ for each participating process,
    though it has only one physical address.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: å…±äº«å†…å­˜æ˜¯åœ¨è¿›ç¨‹ä¹‹é—´å…±äº«çš„ä¸€æ®µå†…å­˜ã€‚ç‰©ç†å†…å­˜æ®µé€šè¿‡å®ƒä»¬å„è‡ªçš„é¡µè¡¨æ˜ å°„åˆ°æ¯ä¸ªè¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜ä¸­ã€‚ä¸€æ—¦å®Œæˆæ˜ å°„ï¼Œè¿›ç¨‹å°±å¯ä»¥åƒå¤„ç†å…¶ä»–æ®µä¸€æ ·è¯»å†™è¿™ä¸€æ®µã€‚å†™å…¥æ­¤æ®µçš„ä»»ä½•æ•°æ®å¯¹å…¶ä»–å‚ä¸è¿›ç¨‹å¯è§ã€‚è™šæ‹Ÿåœ°å€å¯èƒ½å› å‚ä¸è¿›ç¨‹çš„ä¸åŒè€Œä¸åŒï¼Œå°½ç®¡åªæœ‰ä¸€ä¸ªç‰©ç†åœ°å€ã€‚
- en: As with [Message Queues](https://goodyduru.github.io/os/2023/11/13/ipc-message-queues.html#message-queues),
    there are two kinds of Shared Memory - System V and POSIX. This article will focus
    on System V.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸[æ¶ˆæ¯é˜Ÿåˆ—](https://goodyduru.github.io/os/2023/11/13/ipc-message-queues.html#message-queues)ä¸€æ ·ï¼Œå…±äº«å†…å­˜åˆ†ä¸ºä¸¤ç§
    - System V å’Œ POSIXã€‚æœ¬æ–‡å°†é‡ç‚¹ä»‹ç» System Vã€‚
- en: Creating or accessing a Shared Memory segment requires a unique integer key.
    If a unique key isnâ€™t used, an outsider process might communicate with your processes,
    which could be annoying or, even worse, damaging. This key can be hardcoded in
    each of the participating processes, or it could be generated. Hardcoding the
    key reduces the chances of uniqueness because an outsider process could have the
    same key hardcoded in it. The key generation should be done in a way that guarantees
    that all participating processes will reproduce the same key. Fortunately, a function
    that (almost) guarantees uniqueness and is deterministic exists. This function
    is called [`ftok`](https://man7.org/linux/man-pages/man3/ftok.3.html). It accepts
    an existing file path and an integer. As long as the file pointed to by the path
    isnâ€™t recreated, `ftok` will return the same result. All the participating processes
    need to do is call the `ftok` function with the same file path and integer which
    will generate the same key. Extra security steps could include ensuring that the
    file is only accessible to the participating processes.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ›å»ºæˆ–è®¿é—®å…±äº«å†…å­˜æ®µéœ€è¦ä¸€ä¸ªå”¯ä¸€çš„æ•´æ•°é”®ã€‚å¦‚æœæ²¡æœ‰ä½¿ç”¨å”¯ä¸€é”®ï¼Œå¤–éƒ¨è¿›ç¨‹å¯èƒ½ä¸æ‚¨çš„è¿›ç¨‹è¿›è¡Œé€šä¿¡ï¼Œè¿™å¯èƒ½å¾ˆçƒ¦äººï¼Œç”šè‡³æ›´ç³Ÿç³•ã€‚æ­¤é”®å¯ä»¥åœ¨æ¯ä¸ªå‚ä¸è¿›ç¨‹ä¸­ç¡¬ç¼–ç ï¼Œæˆ–è€…å¯ä»¥ç”Ÿæˆã€‚ç¡¬ç¼–ç é”®ä¼šé™ä½å”¯ä¸€æ€§çš„æœºä¼šï¼Œå› ä¸ºå¤–éƒ¨è¿›ç¨‹å¯èƒ½åœ¨å…¶ä¸­ä¹Ÿç¡¬ç¼–ç ç›¸åŒçš„é”®ã€‚é”®çš„ç”Ÿæˆåº”è¯¥ç¡®ä¿æ‰€æœ‰å‚ä¸è¿›ç¨‹éƒ½èƒ½ç”Ÿæˆç›¸åŒçš„é”®ã€‚å¹¸è¿çš„æ˜¯ï¼Œæœ‰ä¸€ä¸ªï¼ˆå‡ ä¹ï¼‰ä¿è¯å”¯ä¸€æ€§ä¸”æ˜¯ç¡®å®šæ€§çš„å‡½æ•°å­˜åœ¨ã€‚æ­¤å‡½æ•°ç§°ä¸º[`ftok`](https://man7.org/linux/man-pages/man3/ftok.3.html)ã€‚å®ƒæ¥å—ä¸€ä¸ªç°æœ‰æ–‡ä»¶è·¯å¾„å’Œä¸€ä¸ªæ•´æ•°ä½œä¸ºå‚æ•°ã€‚åªè¦è·¯å¾„æŒ‡å‘çš„æ–‡ä»¶æœªè¢«é‡æ–°åˆ›å»ºï¼Œ`ftok`
    å°±ä¼šè¿”å›ç›¸åŒçš„ç»“æœã€‚æ‰€æœ‰å‚ä¸è¿›ç¨‹åªéœ€è¦ä½¿ç”¨ç›¸åŒçš„æ–‡ä»¶è·¯å¾„å’Œæ•´æ•°è°ƒç”¨ `ftok` å‡½æ•°ï¼Œå°±ä¼šç”Ÿæˆç›¸åŒçš„é”®ã€‚é¢å¤–çš„å®‰å…¨æ­¥éª¤å¯ä»¥åŒ…æ‹¬ç¡®ä¿æ–‡ä»¶ä»…å¯¹å‚ä¸è¿›ç¨‹å¯è®¿é—®ã€‚
- en: 'Once a key is generated, a process can use it to get or create a shared memory
    segment by calling the [`shmget`](https://man7.org/linux/man-pages/man3/shmget.3p.html)
    function. This function accepts 3 parameters: the key, the size of the shared
    memory, and a flag. If the key isnâ€™t associated with a shared memory segment and
    the **IPC_CREAT** bit is set in the flag, a shared memory segment is created whose
    size is set to the size parameter. On creating a segment, the function returns
    an id. If the key has an existing shared memory segment, an id for that existing
    segment is returned even if the flag has its **IPC_CREAT** bit set. Errors can
    happen for several reasons which, the man page covers. Permissions can be defined
    in the flag using the same format as [file permissions](https://www.multacom.com/faq/password_protection/file_permissions.htm).'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦ç”Ÿæˆäº†ä¸€ä¸ªé”®ï¼Œè¿›ç¨‹å¯ä»¥ä½¿ç”¨å®ƒæ¥é€šè¿‡è°ƒç”¨[`shmget`](https://man7.org/linux/man-pages/man3/shmget.3p.html)å‡½æ•°è·å–æˆ–åˆ›å»ºä¸€ä¸ªå…±äº«å†…å­˜æ®µã€‚æ­¤å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šé”®ã€å…±äº«å†…å­˜çš„å¤§å°å’Œä¸€ä¸ªæ ‡å¿—ã€‚å¦‚æœé”®æœªä¸å…±äº«å†…å­˜æ®µå…³è”ï¼Œå¹¶ä¸”æ ‡å¿—ä¸­è®¾ç½®äº†**IPC_CREAT**ä½ï¼Œå°†åˆ›å»ºä¸€ä¸ªå¤§å°ä¸º
    size å‚æ•°çš„å…±äº«å†…å­˜æ®µã€‚åœ¨åˆ›å»ºæ®µæ—¶ï¼Œå‡½æ•°è¿”å›ä¸€ä¸ª idã€‚å¦‚æœé”®å…·æœ‰ç°æœ‰çš„å…±äº«å†…å­˜æ®µï¼Œåˆ™è¿”å›è¯¥ç°æœ‰æ®µçš„ idï¼Œå³ä½¿æ ‡å¿—è®¾ç½®äº†**IPC_CREAT**ä½ä¹Ÿæ˜¯å¦‚æ­¤ã€‚æœ‰å¤šç§åŸå› å¯èƒ½å¯¼è‡´é”™è¯¯ï¼Œè¿™äº›åœ¨
    man æ‰‹å†Œä¸­æœ‰æ‰€æ¶µç›–ã€‚æƒé™å¯ä»¥é€šè¿‡ä¸[file permissions](https://www.multacom.com/faq/password_protection/file_permissions.htm)ç›¸åŒçš„æ ¼å¼åœ¨æ ‡å¿—ä¸­å®šä¹‰ã€‚
- en: 'After successfully getting the shared memory id, the virtual memory address
    of the shared memory segment is returned by the [`shmat`](https://man7.org/linux/man-pages/man3/shmat.3p.html)
    function. This function accepts 3 parameters: the shared memory id obtained from
    `shmget`, the virtual memory address the process would like the segment to be
    mapped, and a flag. The OS will pick an address if the address parameter is set
    to zero. A memory address is returned on successful execution of the function.'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: æˆåŠŸè·å–å…±äº«å†…å­˜ id åï¼Œå…±äº«å†…å­˜æ®µçš„è™šæ‹Ÿå†…å­˜åœ°å€å°†ç”± [`shmat`](https://man7.org/linux/man-pages/man3/shmat.3p.html)
    å‡½æ•°è¿”å›ã€‚æ­¤å‡½æ•°æ¥å— 3 ä¸ªå‚æ•°ï¼šä» `shmget` è·å–çš„å…±äº«å†…å­˜ idï¼Œè¿›ç¨‹å¸Œæœ›å°†æ®µæ˜ å°„åˆ°çš„è™šæ‹Ÿå†…å­˜åœ°å€ï¼Œä»¥åŠä¸€ä¸ªæ ‡å¿—ã€‚å¦‚æœåœ°å€å‚æ•°è®¾ç½®ä¸ºé›¶ï¼Œæ“ä½œç³»ç»Ÿå°†é€‰æ‹©ä¸€ä¸ªåœ°å€ã€‚å‡½æ•°æ‰§è¡ŒæˆåŠŸåè¿”å›ä¸€ä¸ªå†…å­˜åœ°å€ã€‚
- en: After a memory address is returned, a process can communicate with other processes
    by just reading and writing to the address. There are no special functions for
    reading and writing to the address. These are done using the same methods as reading
    and writing to other addresses.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›å†…å­˜åœ°å€åï¼Œè¿›ç¨‹å¯ä»¥é€šè¿‡ä»…è¯»å–å’Œå†™å…¥åœ°å€ä¸å…¶ä»–è¿›ç¨‹é€šä¿¡ã€‚è¯»å–å’Œå†™å…¥åœ°å€ä¸è¯»å–å’Œå†™å…¥å…¶ä»–åœ°å€ä½¿ç”¨ç›¸åŒçš„æ–¹æ³•è¿›è¡Œï¼Œæ²¡æœ‰ç‰¹æ®Šçš„å‡½æ•°ã€‚
- en: When a process has finished communicating, it can detach the segment from its
    address space by calling the [`shmdt`](https://man7.org/linux/man-pages/man3/shmdt.3p.html)
    function. The function accepts only one parameter, the virtual memory address
    obtained from `shmat`. Once this function is called, the address becomes invalid,
    and interacting with it could cause a Segmentation Fault.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: å½“è¿›ç¨‹å®Œæˆé€šä¿¡æ—¶ï¼Œå¯ä»¥é€šè¿‡è°ƒç”¨ [`shmdt`](https://man7.org/linux/man-pages/man3/shmdt.3p.html)
    å‡½æ•°å°†æ®µä»å…¶åœ°å€ç©ºé—´åˆ†ç¦»ã€‚è¯¥å‡½æ•°ä»…æ¥å—ä¸€ä¸ªå‚æ•°ï¼Œå³ä» `shmat` è·å–çš„è™šæ‹Ÿå†…å­˜åœ°å€ã€‚ä¸€æ—¦è°ƒç”¨æ­¤å‡½æ•°ï¼Œåœ°å€å°†å˜ä¸ºæ— æ•ˆï¼Œä¸ä¹‹äº¤äº’å¯èƒ½å¯¼è‡´æ®µé”™è¯¯ã€‚
- en: Detaching the segment does not destroy it, even if all the participating processes
    detach from it. Destroying it is done by calling
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ç¦»æ®µä¸ä¼šé”€æ¯å®ƒï¼Œå³ä½¿æ‰€æœ‰å‚ä¸çš„è¿›ç¨‹éƒ½ä»ä¸­åˆ†ç¦»ã€‚é€šè¿‡è°ƒç”¨é”€æ¯ `shmctl(id, IPC_RMID, NULL);`
- en: shmctl(id, IPC_RMID, NULL);
  id: totrans-split-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`shmctl(id, IPC_RMID, NULL);`'
- en: The `id` parameter is the shared memory segmentâ€™s id obtained from `shmget`.
    The `IPC_RMID` is a constant, meaning the removal of the segment. In addition
    to destroying a segment, [`shmctl`](https://man7.org/linux/man-pages/man3/shmctl.3p.html)
    can also be used to configure a segment.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` å‚æ•°æ˜¯ä» `shmget` è·å–çš„å…±äº«å†…å­˜æ®µ idã€‚`IPC_RMID` æ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œè¡¨ç¤ºåˆ é™¤æ®µã€‚é™¤äº†é”€æ¯æ®µå¤–ï¼Œ[`shmctl`](https://man7.org/linux/man-pages/man3/shmctl.3p.html)
    è¿˜å¯ç”¨äºé…ç½®æ®µã€‚'
- en: A list of all the shared memory segments on a system can be gotten by this command
    `ipcs -m`.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è¿™ä¸ªå‘½ä»¤ `ipcs -m` å¯ä»¥å¾—åˆ°ç³»ç»Ÿä¸Šæ‰€æœ‰çš„å…±äº«å†…å­˜æ®µçš„åˆ—è¡¨ã€‚
- en: Enough talk. Letâ€™s take a look at an example in Python.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: è¶³å¤Ÿçš„è®¨è®ºã€‚è®©æˆ‘ä»¬çœ‹çœ‹ Python ä¸­çš„ä¸€ä¸ªç¤ºä¾‹ã€‚
- en: Show me the code
  id: totrans-split-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ç»™æˆ‘çœ‹çœ‹ä»£ç 
- en: This example will demonstrate two processes communicating using a shared memory
    in Python. Python does not provide out-of-the-box shared memory support. Instead,
    I made use of the excellent [sysv-ipc](https://semanchuk.com/philip/sysv_ipc/#shared_memory)
    library. You can find the pip package [here](https://pypi.org/project/sysv-ipc/).
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤ç¤ºä¾‹å°†æ¼”ç¤ºä¸¤ä¸ªè¿›ç¨‹åœ¨ Python ä¸­ä½¿ç”¨å…±äº«å†…å­˜è¿›è¡Œé€šä¿¡ã€‚Python ä¸æä¾›å¼€ç®±å³ç”¨çš„å…±äº«å†…å­˜æ”¯æŒã€‚ç›¸åï¼Œæˆ‘ä½¿ç”¨äº†ä¼˜ç§€çš„ [sysv-ipc](https://semanchuk.com/philip/sysv_ipc/#shared_memory)
    åº“ã€‚ä½ å¯ä»¥åœ¨ [è¿™é‡Œ](https://pypi.org/project/sysv-ipc/) æ‰¾åˆ° pip åŒ…ã€‚
- en: 'Hereâ€™s the client code:'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å®¢æˆ·ç«¯ä»£ç ï¼š
- en: '[PRE0]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A temp file is (optionally) created to ensure that it exists. The ftok function
    is called with the file path and an integer. The shared memory segment is (optionally)
    created and accessed. This returns a shared memory object. A loop is run where
    a message containing a byte string is sent. To prevent the process from processing
    a message that it sent, a while loop runs that puts the process to sleep and receives
    a message. The while loop stops if the message differs from the one sent, signifying
    that the message was sent from another process. This while loop is a very primitive
    form of communication synchronization. The message received is decoded and printed,
    and then the loop continues. The loop is ended when *ROUNDS* messages are sent.
    Afterward, an *end* message is sent to signify that the client is done.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç¡®ä¿ä¸´æ—¶æ–‡ä»¶å­˜åœ¨ï¼ˆå¯é€‰ï¼‰ï¼Œè°ƒç”¨ ftok å‡½æ•°æ—¶ä½¿ç”¨æ–‡ä»¶è·¯å¾„å’Œä¸€ä¸ªæ•´æ•°ã€‚å…±äº«å†…å­˜æ®µè¢«ï¼ˆå¯é€‰ï¼‰åˆ›å»ºå¹¶è®¿é—®ã€‚è¿™å°†è¿”å›ä¸€ä¸ªå…±äº«å†…å­˜å¯¹è±¡ã€‚æ‰§è¡Œä¸€ä¸ªå¾ªç¯ï¼Œå…¶ä¸­å‘é€åŒ…å«å­—èŠ‚å­—ç¬¦ä¸²çš„æ¶ˆæ¯ã€‚ä¸ºé˜²æ­¢è¿›ç¨‹å¤„ç†å®ƒå‘é€çš„æ¶ˆæ¯ï¼Œè¿è¡Œä¸€ä¸ª
    while å¾ªç¯ï¼Œä½¿è¿›ç¨‹è¿›å…¥ç¡çœ å¹¶æ¥æ”¶æ¶ˆæ¯ã€‚å¦‚æœæ¶ˆæ¯ä¸å‘é€çš„æ¶ˆæ¯ä¸åŒï¼Œåˆ™æ­¤ while å¾ªç¯åœæ­¢ï¼Œè¡¨ç¤ºè¯¥æ¶ˆæ¯æ¥è‡ªå¦ä¸€ä¸ªè¿›ç¨‹ã€‚æ­¤ while å¾ªç¯æ˜¯éå¸¸åŸå§‹çš„é€šä¿¡åŒæ­¥å½¢å¼ã€‚æ¥æ”¶åˆ°çš„æ¶ˆæ¯è¢«è§£ç å¹¶æ‰“å°ï¼Œç„¶åå¾ªç¯ç»§ç»­ã€‚å½“å‘é€
    *ROUNDS* æ¶ˆæ¯åï¼Œå¾ªç¯ç»“æŸã€‚ç„¶åå‘é€ä¸€ä¸ª *end* æ¶ˆæ¯ï¼Œè¡¨ç¤ºå®¢æˆ·ç«¯å·²å®Œæˆã€‚
- en: Messages sent and received are byte strings, not regular strings, and thus have
    to be encoded and decoded accordingly.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: å‘é€å’Œæ¥æ”¶çš„æ¶ˆæ¯æ˜¯å­—èŠ‚å­—ç¬¦ä¸²ï¼Œè€Œä¸æ˜¯å¸¸è§„å­—ç¬¦ä¸²ï¼Œå› æ­¤å¿…é¡»è¿›è¡Œç›¸åº”çš„ç¼–ç å’Œè§£ç ã€‚
- en: Hereâ€™s the server code
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯æœåŠ¡å™¨ç«¯çš„ä»£ç 
- en: '[PRE1]'
  id: totrans-split-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The server code sets up the shared memory segment similarly to the client code.
    Because `ftok` is called with the exact same parameters as the one in the client
    code, the generated key value will be the same. A message is sent and a while
    loop runs that ensures the message received isnâ€™t the same as the sent message.
    A loop is run, which checks that the first character of the received message isnâ€™t
    equal to *e* which signifies that *end* wasnâ€™t received. Inside this loop, the
    received message is printed, and a different message is sent. Once sent, another
    message check runs as a while loop. The message is then received and decoded.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: æœåŠ¡å™¨ç«¯çš„ä»£ç ä¸å®¢æˆ·ç«¯ä»£ç ç±»ä¼¼åœ°è®¾ç½®äº†å…±äº«å†…å­˜æ®µã€‚å› ä¸º `ftok` ä½¿ç”¨çš„å‚æ•°ä¸å®¢æˆ·ç«¯ä»£ç ä¸­çš„å®Œå…¨ç›¸åŒï¼Œç”Ÿæˆçš„å¯†é’¥å€¼ä¹Ÿå°†ç›¸åŒã€‚å‘é€ä¸€æ¡æ¶ˆæ¯ï¼Œè¿è¡Œä¸€ä¸ª
    while å¾ªç¯ï¼Œç¡®ä¿æ¥æ”¶åˆ°çš„æ¶ˆæ¯ä¸å’Œå‘é€çš„æ¶ˆæ¯ç›¸åŒã€‚è¿è¡Œä¸€ä¸ªå¾ªç¯ï¼Œæ£€æŸ¥æ¥æ”¶åˆ°çš„æ¶ˆæ¯çš„ç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯å¦ä¸ç­‰äº *e*ï¼Œè¿™æ„å‘³ç€æ²¡æœ‰æ¥æ”¶åˆ° *end*ã€‚åœ¨è¿™ä¸ªå¾ªç¯ä¸­ï¼Œæ‰“å°æ¥æ”¶åˆ°çš„æ¶ˆæ¯ï¼Œå¹¶å‘é€å¦ä¸€æ¡æ¶ˆæ¯ã€‚å‘é€åï¼Œå†æ¬¡è¿è¡Œæ¶ˆæ¯æ£€æŸ¥çš„å¾ªç¯ã€‚ç„¶åæ¥æ”¶å¹¶è§£ç æ¶ˆæ¯ã€‚
- en: The loop stops once the *end* message is received. The file for generating the
    key and the shared memory segment are deleted. The program then exits.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æ¥æ”¶åˆ° *end* æ¶ˆæ¯ï¼Œå¾ªç¯å°±ä¼šåœæ­¢ã€‚ç”¨äºç”Ÿæˆå¯†é’¥å’Œå…±äº«å†…å­˜æ®µçš„æ–‡ä»¶å°†è¢«åˆ é™¤ã€‚ç„¶åç¨‹åºé€€å‡ºã€‚
- en: Performance
  id: totrans-split-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ€§èƒ½
- en: Shared message is super fast. There isnâ€™t much difference between it and the
    fastest IPC mechanism (mmap). [IPC-Bench](https://github.com/goldsborough/ipc-bench#benchmarked-on-intelr-coretm-i5-4590s-cpu--300ghz-running-ubuntu-20041-lts)
    benchmarked 1,659,291 1KB messages per second on an Intel(R) Core(TM) i5-4590S
    CPU @ 3.00GHz running Ubuntu 20.04.1 LTS. Thatâ€™s super fast.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: å…±äº«æ¶ˆæ¯é€Ÿåº¦è¶…å¿«ã€‚ä¸æœ€å¿«çš„ IPC æœºåˆ¶ï¼ˆmmapï¼‰ä¹‹é—´çš„å·®å¼‚ä¸å¤§ã€‚[IPC-Bench](https://github.com/goldsborough/ipc-bench#benchmarked-on-intelr-coretm-i5-4590s-cpu--300ghz-running-ubuntu-20041-lts)
    åœ¨è¿è¡Œ Ubuntu 20.04.1 LTS çš„ Intel(R) Core(TM) i5-4590S CPU ä¸Šå¯¹æ¯ç§’ä¼ é€ 1,659,291 ä¸ªå¤§å°ä¸º
    1KB çš„æ¶ˆæ¯è¿›è¡Œäº†åŸºå‡†æµ‹è¯•ã€‚é€Ÿåº¦è¶…å¿«ã€‚
- en: Due to its blazing-fast speed and its similarity to the standard reading and
    writing to memory addresses, youâ€™d need to include some form of synchronization
    mechanism when using Shared Memory just as the code snippets above show.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºå…¶æå¿«çš„é€Ÿåº¦å’Œå…¶ç±»ä¼¼äºæ ‡å‡†çš„å†…å­˜åœ°å€è¯»å†™çš„ç‰¹æ€§ï¼Œä½¿ç”¨å…±äº«å†…å­˜æ—¶å¿…é¡»åƒä¸Šé¢çš„ä»£ç ç‰‡æ®µä¸€æ ·åŒ…æ‹¬æŸç§å½¢å¼çš„åŒæ­¥æœºåˆ¶ã€‚
- en: Demo Code
  id: totrans-split-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ¼”ç¤ºä»£ç 
- en: You can find my code that demonstrates Shared Memory on [GitHub](https://github.com/goodyduru/ipc-demos).
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¯ä»¥åœ¨[GitHub](https://github.com/goodyduru/ipc-demos)æ‰¾åˆ°æˆ‘å±•ç¤ºå…±äº«å†…å­˜çš„ä»£ç ã€‚
- en: Conclusion
  id: totrans-split-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: Shared Memory is an easy and fast IPC mechanism. It has a straightforward model
    for sending and receiving messages. Even then, using it comes with the complexity
    of including a synchronization mechanism. But once you get that right, its speed
    makes it worth it.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: å…±äº«å†…å­˜æ˜¯ä¸€ç§ç®€å•ä¸”å¿«é€Ÿçš„ IPC æœºåˆ¶ã€‚å®ƒæœ‰ä¸€ä¸ªç®€å•ç›´æ¥çš„æ¨¡å‹æ¥å‘é€å’Œæ¥æ”¶æ¶ˆæ¯ã€‚å³ä½¿å¦‚æ­¤ï¼Œä½¿ç”¨å®ƒéœ€è¦åŒ…æ‹¬åŒæ­¥æœºåˆ¶çš„å¤æ‚æ€§ã€‚ä½†ä¸€æ—¦æŒæ¡äº†è¿™ä¸€ç‚¹ï¼Œå®ƒçš„é€Ÿåº¦å°±ç‰©æœ‰æ‰€å€¼ã€‚
- en: The next article will cover another blazing-fast and familiar IPC mechanism
    called [Memory-Mapped Files](https://goodyduru.github.io/os/2024/03/18/ipc-mmap.html).
    Till then, take care of yourself and stay hydrated! âœŒğŸ¾
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€ç¯‡æ–‡ç« å°†ä»‹ç»å¦ä¸€ä¸ªæå¿«ä¸”å¸¸è§çš„ IPC æœºåˆ¶ï¼Œå«åš[å†…å­˜æ˜ å°„æ–‡ä»¶](https://goodyduru.github.io/os/2024/03/18/ipc-mmap.html)ã€‚åœ¨é‚£ä¹‹å‰ï¼Œå¥½å¥½ç…§é¡¾è‡ªå·±ï¼Œä¿æŒæ°´åˆ†ï¼âœŒğŸ¾
- en: '* * *'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
