["```\n#define motor     mat2x4  // [ [s, e23, e31, e12], [e01, e02, e03, e0123] ] \n#define line      mat2x3  // [ [e23, e31, e12], [e01, e02, e03] ]\n#define point     vec3    // [ e032, e013, e021 ] implied 1 e123\n#define direction vec3    // [ e032, e013, e021 ] implied 0 e123\n```", "```\n// 48 mul, 40 add\nexport const gp_mm = (a,b,res=new baseType(8)) => {\n  const a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5],a6=a[6],a7=a[7],\n        b0=b[0],b1=b[1],b2=b[2],b3=b[3],b4=b[4],b5=b[5],b6=b[6],b7=b[7];\n  res[0] = a0*b0-a1*b1-a2*b2-a3*b3;\n  res[1] = a0*b1+a1*b0+a3*b2-a2*b3;\n  res[2] = a0*b2+a1*b3+a2*b0-a3*b1;\n  res[3] = a0*b3+a2*b1+a3*b0-a1*b2;\n  res[4] = a0*b4+a3*b5+a4*b0+a6*b2-a1*b7-a2*b6-a5*b3-a7*b1;\n  res[5] = a0*b5+a1*b6+a4*b3+a5*b0-a2*b7-a3*b4-a6*b1-a7*b2;\n  res[6] = a0*b6+a2*b4+a5*b1+a6*b0-a1*b5-a3*b7-a4*b2-a7*b3;\n  res[7] = a0*b7+a1*b4+a2*b5+a3*b6+a4*b1+a5*b2+a6*b3+a7*b0;\n  return res;\n}\n```", "```\n// 48 mul, 40 add    \nmotor gp_mm( motor a, motor b ) {\n  return motor(\n         a[0].x*b[0].x   - dot(a[0].yzw, b[0].yzw), \n         a[0].x*b[0].yzw + b[0].x*a[0].yzw + cross(b[0].yzw, a[0].yzw),\n         a[0].x*b[1].xyz + b[0].x*a[1].xyz + cross(b[0].yzw, a[1].xyz) + cross(b[1].xyz, a[0].yzw) - b[1].w*a[0].yzw - a[1].w*b[0].yzw, \n         a[0].x*b[1].w + b[0].x*a[1].w + dot(a[0].yzw, b[1].xyz) + dot(a[1].xyz, b[0].yzw));\n}\n```", "```\n// 16 mul, 12 add\nmotor gp_rr( motor a, motor b ) {\n  return motor( a[0].x*b[0] + vec4( -dot(a[0].yzw, b[0].yzw), b[0].x*a[0].yzw + cross(b[0].yzw,a[0].yzw) ), vec4(0.) ); \n}\n```", "```\n// 21 mul, 18 add\npoint sw_mp( motor a, point b ) {\n  direction t = cross(b, a[0].yzw)  - a[1].xyz;\n  return  (a[0].x * t + cross(t, a[0].yzw) - a[0].yzw * a[1].w) * 2\\. + b;\n}\n```", "```\n// 18 mul, 12 add\ndirection sw_md( motor a, direction b ) {\n  direction t = cross(b, a[0].yzw);\n  return  (a[0].x * t + cross(t, a[0].yzw)) * 2\\. + b;\n}\n```", "```\n// 6 mul, 4 add\ndirection sw_mx( motor a ) {\n  return direction(\n    0.5 - a[0].w*a[0].w - a[0].z*a[0].z, \n    a[0].z*a[0].y - a[0].x*a[0].w, \n    a[0].w*a[0].y + a[0].x*a[0].z\n  );\n}\n```", "```\n// 21 mul, 5 add\nmotor normalize_m( motor a ) {\n  float s = 1\\. / length( a[0] );\n  float d = (a[1].w * a[0].x - dot( a[1].xyz, a[0].yzw ))*s*s;\n  return motor(a[0]*s, a[1]*s + vec4(a[0].yzw*(s*d),-a[0].x*s*d));\n}\n```", "```\n// 21 mul, 6 add\nmotor sqrt_m( motor R ) {\n  return normalize_m( motor( R[0].x + 1., R[0].yzw, R[1] ) ); \n}\n```", "```\n// 14 muls 5 add 1 div 1 acos 1 sqrt\nline log_m( motor M ) { \n  if (M[0].x == 1.) return line( vec3(0.), vec3(M[1].xyz) );\n  float a = 1./(1\\. - M[0].x*M[0].x), b = acos(M[0].x) * sqrt(a), c = a*M[1].w*(1\\. - M[0].x*b);\n  return line( b*M[0].yzw, b*M[1].xyz + c*M[0].wzy);\n}\n```", "```\n// 17 muls 8 add 2 div 1 sqrt 1 cos 1 sin\nmotor exp_b( line B ) {\n  float l = dot(B[0],B[0]);\n  if (l==0.) return motor( vec4(1., 0., 0., 0.), vec4(B[1], 0.) );\n  float a = sqrt(l), m = dot(B[0].xyz, B[1]), c = cos(a), s = sin(a)/a, t = m/l*(c-s);\n  return motor( c, s*B[0], s*B[1] + t*B[0].zyx, m*s );\n}\n```", "```\nexport const fromMatrix3 = M => {\n  // Shorthand.\n  var [m00,m01,m02,m10,m11,m12,m20,m21,m22] = M;\n\n  // Quick scale check \n  const scale = [hypot(m00,m01,m02),hypot(m10,m11,m12),hypot(m20,m21,m22)];\n  if (abs(scale[0]-1)>0.0001 || abs(scale[1]-1)>0.0001 || abs(scale[2]-1)>0.0001) {\n    const i = scale.map(s=>1/s);\n    m00 *= i[0]; m01 *= i[0]; m02 *= i[0];\n    m10 *= i[1]; m11 *= i[1]; m12 *= i[1];\n    m20 *= i[2]; m21 *= i[2]; m22 *= i[2];\n    if (abs(scale[0]/scale[1]-1)>0.0001 || abs(scale[1]/scale[2]-1)>0.0001) console.warn(\"non uniformly scaled matrix !\", scale);\n  }  \n\n  // Return a pure rotation (in motor format)\n  return normalize(   m00 + m11 + m22 > 0 ? [m00 + m11 + m22 + 1.0, m21 - m12, m02 - m20, m10 - m01, 0,0,0,0]:\n                   m00 > m11 && m00 > m22 ? [m21 - m12, 1.0 + m00 - m11 - m22, m01 + m10, m02 + m20, 0,0,0,0]:\n                                m11 > m22 ? [m02 - m20, m01 + m10, 1.0 + m11 - m00 - m22, m12 + m21, 0,0,0,0]:\n                                            [m10 - m01, m02 + m20, m12 + m21, 1.0 + m22 - m00 - m11, 0,0,0,0]);\n} \n```", "```\nexport const fromMatrix = M => {\n  // Shorthand.\n  var [m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,m23,m30,m31,m32,m33] = M;\n\n  // Return rotor as translation * rotation\n  return gp_mm( [1,0,0,0,-0.5*m30,-0.5*m31,-0.5*m32,0], fromMatrix3([m00,m01,m02,m10,m11,m12,m20,m21,m22]) );\n} \n```", "```\nvec3 worldPosition = sw_mp( toWorld, attrib_position );\nvec3 worldNormal   = sw_md( toWorld, attrib_normal );      \nvec4 worldTangent  = vec4(sw_md( toWorld, attrib_tangent.xyz ), attrib_tangent.w);\n```", "```\nvec4 project( const float n, const float f, const float minfov, float aspect, vec3 inpos ){\n  float cthf = cos(minfov/2.0) / sin(minfov/2.0);              // cotangent of half the minimal fov.\n  float fa = 2.*f*n/(n-f), fb = (n+f)/(n-f);                   // all of these can be precomputed constants.\n  vec2 fit = cthf * vec2(-1.0/aspect, 1.0);                    // fit vertical.\n  return vec4( inpos.xy * fit, fa - fb*inpos.z, inpos.z );\n}\n```", "```\nfloat handedness = sign(1/tangentRotor.x)\n```", "```\n// Normalize, Orthogonalize\nnormal  = normalize( normal );\ntangent = normalize( sub(tangent, mul(normal, dot(normal,tangent) ) ) );\n// Calculate the bitangent.\nlet bitangent = normalize(cross(normal, tangent));\n// Now setup the matrix explicitely.\nlet mat = [...tangent, ...bitangent, ...normal];\n// Convert to motor and store.\nlet motor = fromMatrix3( mat );\n// Use the double cover to encode the handedness.\n// in GA language, this means we are using half of the double cover to distinguish even and odd versors.\nif (Math.sign(motor[0])!=tangents[i*4+3]) motor = motor.map(x=>-x);\n```", "```\n// 9 muls, 8 adds\nvoid extractNormalTangent( motor a, out direction normal, out direction tangent ) {\n  float yw = a[0].y * a[0].w;\n  float xz = a[0].x * a[0].z;\n  float zz = a[0].z * a[0].z;\n\n  normal  = direction( yw - xz, a[0].z*a[0].w + a[0].y*a[0].x, 0.5 - zz - a[0].y*a[0].y );\n  tangent = direction( 0.5 - zz - a[0].w*a[0].w, a[0].z*a[0].y - a[0].x*a[0].w, yw + xz );\n}\n```", "```\n// Now transform our vertex using the motor from object to worldspace.\nworldPosition = sw_mp(toWorld, attrib_position);\n\n// Concatenate the world motor and the tangent frame.\nmotor tangentRotor = gp_rr( toWorld, motor(attrib_tangentRotor,vec4(0.)) );\n\n// Next, extract world normal and tangent from the tangentFrame rotor.\nextractNormalTangent(tangentRotor, worldNormal, worldTangent.xyz);\nworldTangent.w = sign(1.0 / attrib_tangentRotor.x); // trick to disambiguate negative zero!\n```", "```\n// Grab the 4 bone motors.\nmotor b1 = motors[int(attrib_joints.x)];\nmotor b2 = motors[int(attrib_joints.y)];\nmotor b3 = motors[int(attrib_joints.z)];\nmotor b4 = motors[int(attrib_joints.w)];\n\n// Blend them together, always use short path.\nmotor r = attrib_weights.x * b1;\nif (dot(r[0],b2[0])<=0.0) b2 = -b2;\nr += attrib_weights.y * b2;\nif (dot(r[0],b3[0])<=0.0) b3 = -b3;\nr += attrib_weights.z * b3;\nif (dot(r[0],b4[0])<=0.0) b4 = -b4;\nr += attrib_weights.w * b4;\n\n// Now renormalize and combine with object to world\ntoWorld = gp(toWorld, normalize_m(r)); \n```"]