- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-29 13:22:49'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024年5月29日13:22:49
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Asynchronous clean-up
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步清理
- en: 来源：[https://without.boats/blog/asynchronous-clean-up/](https://without.boats/blog/asynchronous-clean-up/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://without.boats/blog/asynchronous-clean-up/](https://without.boats/blog/asynchronous-clean-up/)
- en: One problem with the design of async Rust is what do about async clean-up code.
    Consider that you have a type representing some object or operation (like an async
    IO handle) and it runs clean up code when you are done using it, but that clean
    up code itself is also non-blocking and could yield control. Async Rust has no
    good way to handle this pattern today.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Rust异步设计中的一个问题是如何处理异步清理代码。考虑这样一种情况，您有一种类型，表示某个对象或操作（比如异步IO句柄），在使用完毕时运行清理代码，但清理代码本身也是非阻塞的，并且可能会让出控制。异步Rust目前没有很好地处理这种模式的方法。
- en: 'The nicest solution seems to be to just use the mechanism that already exists:
    destructors. If only you could `await` inside a destructor, everything would seem
    to be solved. Alas, this would present several problems, and I personally do not
    believe it is realistic to imagine Rust gaining this feature in the same way that
    destructors work.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的解决方案似乎是只是使用已经存在的机制：析构函数。如果只能在析构函数内部使用`await`，一切似乎都会解决。遗憾的是，这会带来几个问题，我个人认为想象Rust获得这个特性的方式与析构函数的工作方式相同是不现实的。
- en: 'The first problem is this: what happens if you drop the the value in a non-async
    scope? It’s not possible to `await` there! There are two options: either the async
    destructor doesn’t run (considered too easy a mistake to make), or there is a
    type-checking rule that prevents users from dropping values with async destructors
    in non-async scopes. The second solution reduces to undroppable types, which I
    will discuss later in this post: this rule is just undroppable types with an exception
    to allow them to be dropped in an async scope. What I can say with certainty is
    that undroppable types, even with an exception, would be very difficult to add
    to Rust.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先的问题是：如果在非异步范围中丢弃值会发生什么？那里不可能使用`await`！有两种选择：要么异步析构函数不会运行（考虑到这种错误太容易犯），要么有一条类型检查规则阻止用户在非异步范围中丢弃具有异步析构函数的值。第二种解决方案要么为空析构类型，这个以后我会在本文中讨论：这个规则只是除了在异步范围中允许它们被丢弃的类型外，为空析构类型。我可以确定的是，即使有了这个例外，为空析构类型也很难添加到Rust中。
- en: 'The second problem is the way that the state of the async destructor would
    impact the state of any future any containing it. This is actually a re-emergence
    of the problems with async methods, but now applied to any generic type (because
    you don’t know of a generic type `T` has an async destructor). The first problem
    is that you have any trait object, when it drops, what happens if it has an async
    destructor? This introduces the same object safety issues as async methods: you
    have nowhere to store the future returned by the async destructor of a trait object.
    The second problem is that you want to send a value to a different thread, that
    state of its async destructor also needs to be `Send`. This is the same problem
    that motivated RTN, except that now its a problem for *every* generic type being
    moved to another thread, not only types on which you explicitly call an async
    method. I wrote about this problem years and years ago, but it seems to have been
    misunderstood and ignored since then.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是异步析构函数的状态如何影响包含它的未来的任何状态。这实际上是异步方法的问题的重新出现，但现在适用于任何泛型类型（因为你不知道泛型类型`T`是否具有异步析构函数）。第一个问题是：当您有任何trait对象时，当它被丢弃时，如果它有异步析构函数会发生什么？这引入了与异步方法相同的对象安全问题：您没有地方存储trait对象的异步析构函数返回的未来。第二个问题是：当您希望将一个值发送到另一个线程时，其异步析构函数的状态也需要是`Send`。这是促使RTN产生的同样的问题，只不过现在它是对于*每个*被移动到另一个线程的泛型类型，而不仅仅是在显式调用异步方法的类型上。多年前我写过这个问题，但似乎自那时以来一直被误解和忽视。
- en: The third problem is that users are concerned about having implicit await points
    added to their future without them realizing it. Therefore there would need to
    be some restriction that not only doesn’t allow these types to be dropped in a
    non-async scope, but also makes it so that they are destructed at an already explicit
    `await` point. This would make the rules around when their async destructors run
    very different from other destructors, if its even possible to make them coherent.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个问题是用户关心是否会在未意识到的情况下向他们的未来添加隐式的`await`点。因此，需要有一些限制，不仅不允许在非异步范围中丢弃这些类型，而且使其在已经明确的`await`点处被销毁。如果这样做，会使得它们的异步析构函数运行的规则与其他析构函数非常不同，如果可能的话。
- en: The fourth problem, I believe maybe never raised before, is that it is not the
    ideal code generation to run async destructors sequentially no matter what. For
    example, if I have two values that I am asynchronously dropping, possibly I want
    to `join` the destructors so they run concurrently. But doing this implicitly
    would be very risky, because maybe I actually carefully expect one to run before
    the other.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为第四个问题可能以前从未提出过，那就是无论如何，按顺序运行异步析构函数生成的代码并不是理想的代码生成。例如，如果我有两个我正在异步丢弃的值，也许我希望并发地`join`析构函数。但这样做隐式地是非常危险的，因为也许我实际上小心地希望一个在另一个之前运行。
- en: 'All of these problems hint at a different way to frame the problem of asynchronous
    clean-up: the problem is not that there is no async drop, but that destructors
    really only work when you can write a destructor function that returns `()`. Async
    clean-up is just a special case of clean-up which does not return `()`. In this
    case it returns a future, but there are also scenarios in which the issue is a
    lack of destructors that can return `Result`, for example.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都暗示了另一种方式来构架异步清理的问题：问题不在于没有异步丢弃，而在于析构函数只有在您能编写一个返回`()`的析构函数函数时才能正常运行。异步清理只是不返回`()`的清理的一种特例。在这种情况下它返回一个未来，但也有场景在其中问题是缺少可以返回`Result`的析构函数，例如。
- en: I want to explore the design space for asynchronous clean up and clean up code
    that returns values in general, without a focus on destructors specifically. The
    proposal I’ve fleshed out here, based heavily on the work of others (especially
    Eric Holk and Tyler Mandry), combines two distinct features - async future cancellation
    and a `do` &mldr; `final` construct - to enable users to write asynchronous clean
    up code that is consistently called. I will also show how these constructs are
    required for any sort of “linear type” mechanism in Rust, so rather than seeing
    them as alternative to type-based async clean up code, they should be seen as
    prerequisites that can be implemented in the nearer term.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我想探索异步清理和返回值的清理代码的设计空间，而不专注于析构函数。我在这里提出的提案，在很大程度上基于他人的工作（特别是Eric Holk和Tyler
    Mandry的工作），结合了两个不同的功能 - 异步未来取消和`do` &mldr; `final`结构 - 以使用户能够编写一致调用的异步清理代码。我还将展示这些结构对于Rust中的任何类型的“线性类型”机制都是必需的，因此，与其将它们视为基于类型的异步清理代码的替代方案，不如将它们视为可以在更近期实现的先决条件。
- en: Cancellation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消
- en: There are two reasons a future could need to clean up its state. The first would
    be that the future is ready, and is returning its final value. The second is that
    while the future was pending, the caller lost interest in it and canceled it.
    This section is about introducing an asynchronous cancellation mechanism, so that
    asynchronous clean-up can occur during cancellation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 未来可能需要清理其状态有两个原因。第一个原因是未来准备好并且正在返回其最终值。第二个原因是在未来处于挂起状态时，调用者失去了对它的兴趣并将其取消。本节介绍了一种异步取消机制，以便在取消期间进行异步清理。
- en: Canceling work is one of the big issues of concurrent programming, and different
    concurrency systems have different approaches. One way to frame the design space
    is to position designs for cancellation on a spectrum of *cooperativeness*. At
    one end you would have *non-cooperative cancellation*, in which a unit of work
    can be canceled without any handling within the work unit itself. At the other
    end you would have *cooperative cancellation*, in which a unit of work cannot
    be canceled and will be run until it finishes (you can implement cancellation
    in such a system by the work unit returning an `Option` or a nullable type, depending
    on your language, and having a mechanism for your work unit to receive a message
    to cancel it).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 取消工作是并发编程的一个重大问题，不同的并发系统有不同的方法。一个定位取消设计的方式是将取消设计放置在*合作性*的光谱上。在一端，你会有*非合作取消*，其中一个工作单元可以在不需要在工作单元内处理的情况下取消。在另一端，你会有*合作取消*，其中一个工作单元无法取消，并且将运行直到完成（你可以在这样的系统中通过工作单元返回一个`Option`或可为空类型来实现取消，并且有一个机制让你的工作单元接收到取消消息）。
- en: 'Go’s goroutines are cooperatively canceled; they can’t be canceled unless they
    explicitly opt into cancellation. POSIX threads can be non-cooperatively canceled
    by sending them `SIGKILL` with `pthread_kill(3)` (EDIT: this is wrong, because
    sending a POSIX thread `SIGKILL` will kill your whole process; I don’t have an
    example of fully non-cooperative cancellation available off the top of my head.)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的goroutine是合作取消的；除非它们明确选择取消，否则无法取消。POSIX线程可以通过使用`pthread_kill(3)`发送`SIGKILL`来进行非合作取消（编辑：这是错误的，因为向POSIX线程发送`SIGKILL`将杀死整个进程；我脑海中没有完全非合作取消的示例。）
- en: The problem with non-cooperative cancellation is that it might leave the program
    in a bad state, as that unit of work could have held locks or owned heap memory,
    which now will all be leaked. The problem with cooperative cancellation is that
    if a unit of work doesn’t opt into being canceled, it will run to completion even
    if its work is no longer necessary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 非合作取消的问题在于它可能会使程序处于糟糕的状态，因为那个工作单元可能会持有锁或拥有堆内存，现在所有这些都将被泄漏。合作取消的问题在于，如果一个工作单元不选择被取消，即使其工作不再必要，它也将运行到完成。
- en: Between these extremes there exists a range of what you might call *semi-cooperative
    cancellation* mechanisms. With these mechanisms, a unit of work might be moved
    into a control-flow path for cancellation, without its cooperation, but it can
    execute some specifically designated code to “clean up” its state as it is canceled.
    This is intended to find a middle ground between cooperative and non-cooperative
    cancellation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些极端之间存在一系列你可以称之为*半合作取消*机制。通过这些机制，一个工作单元可能会被移动到一个取消的控制流路径中，而不需要它的合作，但它可以执行一些特别指定的代码来“清理”其状态。这旨在找到合作和非合作取消之间的折中。
- en: 'Rust’s async model currently adopts a semi-cooperative cancellation model in
    practice: during any `await` point in a future, the future might be canceled.
    A correctly implemented runtime will run the destructor on that future, allowing
    it to clean up its state. However, that cancellation code must be entirely synchronous;
    to support asynchronous clean-up code, what is required is some form of *asynchronous
    semi-cooperative cancellation*, which I will just refer to as “async cancellation.”'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的异步模型目前在实践中采用半合作取消模型：在未来的任何`await`点期间，未来可能会被取消。一个正确实现的运行时将运行该未来的析构函数，允许它清理其状态。但是，该取消代码必须完全同步；为了支持异步清理代码，需要一种形式的*异步半合作取消*，我将简称为“异步取消”。
- en: 'Some additional nuance should be noted, if this isn’t already too complex.
    First, async Rust only supports cancellation at `await` points: except at an `await`
    point, the user can be assured the future will not be canceled. This is an implication
    of the fact that async Rust uses *cooperative scheduling*, in which units of work
    cannot be preempted and only yield control back to the scheduler when they choose
    to. This has its own pros and cons. Second, though cancellation in async Rust
    is semi-cooperative in practice, code authors cannot rely on cancellation for
    soundness: it is not undefined behavior to cancel a future without running its
    clean up code. This will we return to in a later section of the post.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够复杂，还应该注意到一些额外的细微差别。首先，async Rust 仅在 `await` 点支持取消：除了在 `await` 点之外，用户可以确保未来不会被取消。这是异步
    Rust 使用 *合作调度* 的结果，在其中工作单元不能被抢占，只有当它们选择时才将控制权返回给调度程序。这有它自己的优缺点。其次，尽管在实践中异步 Rust
    中的取消是半合作的，但代码作者不能依赖取消来保证正确性：取消未来而不运行其清理代码并不是未定义行为。我们将在本文的后面再回到这个问题。
- en: '`poll_cancel`'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`poll_cancel`'
- en: 'To support async cancellation, the traits for async units of work need to gain
    an API for canceling them asynchronously. This is `poll_cancel`, as in this change
    to the definition of `Future`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持异步取消，异步工作单元的特征需要获得一个用于异步取消的 API。这就是 `poll_cancel`，就像对 `Future` 定义的这个更改一样：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Eric Holk discussed this new API at length in a great [post](https://theincredibleholk.org/blog/2023/11/14/a-mechanism-for-async-cancellation/)
    last year. Some notes on this from my perspective follow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 去年，Eric Holk 在他的一篇很棒的 [博文](https://theincredibleholk.org/blog/2023/11/14/a-mechanism-for-async-cancellation/)
    中长篇大论地讨论了这个新 API。以下是我个人观点的一些注释。
- en: 'First, I would not immediately support an `on_cancel` extension to `Future`:
    I think that it does not make sense for ordinary async Rust (not written in the
    lower level poll register) to have clean-up that *only* runs on cancellation,
    and not whenever it finishes. I think there’s a risk of bugs here, because if
    a user writes a loop that never terminates in their cancellation code, the task
    will never actually be canceled. Then anything which cancels them non-concurrently,
    like `select!`, would also never terminate. Because this code only runs on cancellation,
    it would not be as likely to be tested for bugs like this. I would be interested
    in examples of code that users believe require cancellation-specific async code,
    though. Later in this post I’ll show a way to support async clean-up code that
    runs on both cancellation and normal completion.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我不会立即支持将 `on_cancel` 扩展到 `Future`：我认为对于普通的 async Rust（不是在更低级别的 poll 寄存器中编写的）来说，仅在取消时运行清理并不合理，而不是在任何时候完成时运行。我认为这里存在
    bug 的风险，因为如果用户在他们的取消代码中写了一个永不终止的循环，任务实际上就不会被取消。然后像 `select!` 这样的非并发地取消它们的任何东西也永远不会终止。因为这段代码只在取消时运行，所以不太可能测试出像这样的
    bug。不过，我会对用户认为需要特定于取消的异步代码的示例感兴趣。在本文的后面，我会展示一种同时支持取消和正常完成的异步清理代码的方法。
- en: 'This also alleviates the need for considering any sort of question about “what
    happens if you cancel the cancellation future,” and whether that is recursive
    or idempotent: once a future begins canceling, “canceling” it again is idempotent,
    because its already canceling; there is no second future to cancel.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这也消除了考虑“如果取消取消未来会发生什么”以及是否递归或幂等的任何问题的需要：一旦一个未来开始取消，“再次取消”它是幂等的，因为它已经取消了；没有第二个未来需要取消。
- en: Second, a critical addition would be to add `poll_cancel` to `AsyncIterator`
    as well. This would allow `AsyncIterator`s to also support async clean up on cancellation
    (including async generators). As a result of this, the code generation of `poll_cancel`
    on an async block or function would be more complex. First, it would call `poll_cancel`
    on whatever future was being awaited, if it was awaiting a future. Then, it would
    walk backwards to call `poll_cancel` on every `AsyncIterator` it was looping over
    with `for await`, canceling them as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一个关键的补充是将 `poll_cancel` 添加到 `AsyncIterator` 中。这将允许 `AsyncIterator` 也支持异步清理在取消时（包括异步生成器）。由于这个，异步块或函数上的
    `poll_cancel` 的代码生成会更复杂。首先，它会调用正在等待的任何未来的 `poll_cancel`，如果正在等待未来的话。然后，它会向后遍历，取消正在使用
    `for await` 循环的每个 `AsyncIterator` 上的 `poll_cancel`。
- en: Once these APIs are stabilized in the minimum supported Rust version of the
    frameworks, those frameworks should begin calling `poll_cancel` on any futures
    that they cancel. In this way, async Rust will come to support async cancellation
    on any runtime updated to the version which supports this mechanism. Though it
    won’t be an iron-clad guaranteed, in the same way that destructors are not an
    iron-clad guarantee, if you’re using a supportive version of any good runtime,
    your futures will consistently run their cancellation code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些 API 在框架的最低支持的 Rust 版本中稳定下来，这些框架应该开始在他们取消的任何 futures 上调用 `poll_cancel`。这样，async
    Rust 将支持异步取消在任何运行时上更新到支持此机制的版本。虽然这不会是一个铁定的保证，就像析构函数不是铁定的保证一样，但如果你使用一个支持的版本的任何好的运行时，你的
    futures 将一致运行他们的取消代码。
- en: Async unwinding
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步解绑
- en: Eric Holk touches on unwinding in his blog post, but I think there are some
    mistakes in his remarks. Here is my attempt to describe async unwinding behavior.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Eric Holk 在他的博文中提到了解绑，但我认为他的言论中存在一些错误。以下是我描述异步解绑行为的尝试。
- en: The unwinding path for a future would need to also call `poll_cancel`. The only
    complication that arises is what to do about calling `Pending`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持未来的取消，路径需要调用`poll_cancel`。唯一出现的复杂性是如何处理调用`Pending`。
- en: A new API, an async version of `catch_unwind`, would be added to the standard
    library. When this catches an unwinding that returned `Pending`, it would itself
    return `Pending` and unset the panic state. When it is polled again, it sets the
    panic state and polls itself, proceeding further through the `poll_cancel` method
    of the future it wraps. Eventually, `poll_cancel` returns ready, at which point
    the async `catch_unwind` returns with a panic error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'If `poll_cancel` returns `Pending` while unwinding not inside of the async
    `catch_unwind`, one of two choices can be made: either the entire process aborts,
    or control jumps immediately to the innermost `catch_unwind` without executing
    any further unwinding code. Probably the former is the safer choice.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: In addition to upgrading to handle cancellation, runtimes would need to upgrade
    to use the asynchronous version of `catch_unwind`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '`do` &mldr; `final`'
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second step to make async clean up work is totally separate from supporting
    async cancellation: it’s a way to do clean up other than destructors. This will
    solve several problems: first, it will solve the general “clean up with meaningful
    return values” problem (whether they return `Result` or `Future`) discussed earlier.
    Second, it will provide a way to do ad hoc clean up without the rigamarole of
    creating a custom guard type with a destructor, which code that needs to do one-off
    ad hoc clean up currently needs to do.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic concept is to add a new kind of block construct, which has a way
    to specify code that runs whenever that block exits. I’ve chosen the syntax `do`
    &mldr; `final`, because both of these are already reserved words without meaning
    in Rust. You can easily imagine other syntaxes: Go’s `defer` blocks are basically
    the same feature, but with less of the block structuring of this syntax.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code could exit the `do` block in 3 different ways: it could exit normally,
    `fallible_call` could return an error, or the block could panic. In all cases,
    the final block will be run before proceeding, so it will print the message `"exiting
    block"` whatever happens.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The `final` block must always evaluate to `()`, and the entire construct will
    evaluate to the type that the `do` block evaluates to.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'This reduces the pattern of “ad hoc guards” to relatively simple constructs.
    Consider this example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the user’s intent is to call `unbar` every time the closure exits, they
    will fail: if the closure exits by panicking or by returning an error, `unbar`
    will not be called. For this reason, ad hoc guard types are used in that scenario:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is quite a bit of code to have to add for this case. `do` &mldr; `final`
    blocks will make the whole thing simpler:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'They’re also helpful for handling errors in fallible clean up. Consider the
    case of closing a file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On a UNIX system, the file is closed in the call to `drop` by calling `close(2)`.
    What happens if that call returns an error? The standard library ignores it. This
    is partly because there’s not much you can do to respond to `close(2)` erroring,
    as a comment in the standard library elucidates:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: “Worse is better.”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a user may still want some level of control over what happens in this
    case, even if just to log that an error occurred (which can be used to assist
    in debugging any incident that may arise). Toward that end, `File` could also
    have a close method which returns a `Result`. Users would then be able to use
    `final` blocks to call that method and handle the error however they like, should
    it arise:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Awaiting in `final` blocks
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both of these use cases are completely separate from async clean up, but the
    feature is also useful for async clean up, because `final` blocks would be able
    to contain `await` expressions. For example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `poll_cancel` implementation for async scopes would also execute the `final`
    blocks for any `do` blocks that the future is currently within, in addition to
    the `poll_cancel` for the future being awaited and any async iterators being looped
    over.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 异步范围的`poll_cancel`实现还将执行任何当前处于`do`块中的`future`的`final`块，除了等待的`future`的`poll_cancel`和任何异步迭代器的循环。
- en: 'Thus, between async cancellation and `do` &mldr; `final`, a method of performing
    async clean up is achieved. The limitation of this, in contrast to async destructors,
    is that it is not tied to specific types: a socket type cannot guarantee that
    it will always be shutdown gracefully. This will be addressed in the later section
    on linear types.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过异步取消和`do` &mldr; `final`，实现了一种执行异步清理的方法。与异步析构函数相比的局限性在于它不与特定类型绑定：套接字类型不能保证始终优雅地关闭。这将在后面关于线性类型的部分中讨论。
- en: Before moving on to linear types, I have some notes on other control flow operators
    and their relationship to `final` blocks. There may be errors of reasoning in
    this section, I’m not confident I’ve correctly thought through the control flow
    possibilities.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向线性类型之前，我对其他控制流运算符及其与`final`块的关系有一些注释。这一部分可能存在推理错误，我不确定我是否已经正确地思考了控制流可能性。
- en: Early exit in `final` blocks
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`final`块中的早期退出
- en: 'One particular quirk of `final` blocks will be what to do if they early exit
    with a value, because the user might *already* be early exiting with a value.
    Consider:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`块的一个特别怪癖将是如果它们带有值早期退出，因为用户可能*已经*带有值早期退出。考虑：'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If `read` returns an error and we enter the `final` block, what happens then
    if close also returns an error? We can’t return *both* errors. There are only
    two options that I can imagine:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`read`返回错误并且我们进入`final`块，那么如果close也返回错误会发生什么呢？我们不能*同时*返回两个错误。我能想象到的只有两个选项：
- en: Disallow early exit in `final` blocks. This is the most restrictive, but leads
    to no confusing scenarios.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁止在`final`块中早期退出。这是最严格的，但不会导致混乱的情况。
- en: Allow early exit in `final` blocks, but drop the value if we are already early
    exiting. Only the original error will be returned.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许在`final`块中早期退出，但如果我们已经早期退出，则放弃该值。只返回原始错误。
- en: In the latter scenario, you would continue to execute any other `final` blocks
    further down even if this one early exited; just the remainder of this `final`
    block would not be executed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在后一种情况下，即使这个早期退出，您仍将继续执行任何其他`final`块，只是这个`final`块的其余部分将不会执行。
- en: Yielding from `final` blocks
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从`final`块中产生
- en: 'If early return from `final` blocks is permitted, note that `yield` could also
    be permitted. Consider:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许在`final`块中早期返回，则注意`yield`也可以被允许。考虑：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If `has_foo` never fails, this will yield `"elem has foo"` as many times as
    an `elem` in `iter` “has foo” and then one `"final yield"`. If it fails, it will
    return `"elem has foo"` every time before that, then enter the `final` block and
    yield the `"final yield"` value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`has_foo`从不失败，那么它将像`iter`中的`elem`一样多次产生`"elem has foo"`，然后产生一个`"final yield"`。如果它失败了，它将在那之前每次都返回`"elem
    has foo"`，然后进入`final`块并产生`"final yield"`值。
- en: Unwinding through `final` blocks
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过`final`块解绑
- en: Some special attention is needed for figuring out what happens when unwinding
    through `final` blocks that include control flow other than the ordinary control
    flow.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包括普通控制流以外的控制流的`final`块，需要特别注意解绑过程。
- en: 'For `await`, this is already covered by the discussion of async unwinding:
    if you are wrapped by an async `catch_unwind`, it will proceed as normal, otherwise
    it will either abort or stop unwinding.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`await`，这已经在异步取消的讨论中涵盖了：如果您被异步`catch_unwind`包裹，它将继续正常进行，否则它将中止或停止取消。
- en: If `yield` and early `return` operators are permitted in `final` blocks, these
    would need to escape this `final` block but drop the item. We would proceed with
    unwinding, skipping the remaining code inside of this particular `final` block.
    If it was a `yield`, we would not yield that value, instead we would exit the
    loop and continue unwinding.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`final`块中允许`yield`和早期`return`操作符，则这些操作符需要逃逸这个`final`块但丢弃该项。我们将继续解绑，跳过这个特定`final`块中剩余的代码。如果是`yield`，我们将不会产生该值，而是退出循环并继续解绑。
- en: Linear types
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性类型
- en: With async cancellation and `do` &mldr; `final` blocks, asynchronous clean-up
    is possible, but it can not be guaranteed that any particular asynchronous clean-up
    code will be run when a type goes out of scope. It’s already the case today that
    you can’t guarantee clean-up code runs when a type goes out of scope, asynchronous
    or not. There are two possible solutions to this problem, though they often are
    conflated under the single term “linear types,” so I’m going to refer to them
    with two distinct names.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过异步取消和`do` &mldr; `final`块，异步清理是可能的，但不能保证任何特定的异步清理代码在类型超出范围时都会运行。今天已经是这种情况了，即使不是异步的，你也不能保证清理代码在类型超出范围时运行。有两种可能的解决方案，尽管它们经常被合并成一个术语“线性类型”，所以我将用两个不同的名称来指代它们。
- en: The first solution would be to allow types to express as part of their contract
    that their destructor (remember, their normal, non-asynchronous, non-value-returning
    destructor) runs whenever they go out of scope. I call these *unforgettable types*.
    It would require adding a `Leak` auto trait and bounding any API which can cause
    a leak (like `mem::forget`) with that auto trait.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案将允许类型作为其合约的一部分表达其析构函数（请记住，它们的正常、非异步、非值返回析构函数）在它们超出范围时运行。我称这些为*难以忘怀的类型*。这将需要添加一个`Leak`自动特性，并用该自动特性限定任何可能导致泄漏的API（如`mem::forget`）。
- en: The second solution would be to allow types that cannot be dropped at all. This
    is actually what “linear types” means outside of the context of Rust, but I am
    going to call these *undroppable types* to avoid any confusion. Niko Matsakis
    has [written](https://smallcultfollowing.com/babysteps/blog/2023/03/16/must-move-types/)
    about adding this functionality under the term “must move types,” because such
    types must be moved, they cannot be dropped. I’m going look briefly at each of
    these as a solution to the problem, without considering the challenges of adding
    them to Rust or how they would impact other use cases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案是允许根本无法丢弃的类型。这实际上是“线性类型”在Rust上下文之外的含义，但我将其称为*不可丢弃的类型*，以避免任何混淆。尼科·马扎基斯已经[写过](https://smallcultfollowing.com/babysteps/blog/2023/03/16/must-move-types/)关于在术语“必须移动类型”下添加此功能，因为这些类型必须移动，不能被丢弃。我将简要看看这些作为问题的解决方案，而不考虑将它们添加到Rust或它们如何影响其他用例的挑战。
- en: Unforgettable types
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可忘记的类型
- en: 'This weaker limitation would not allow defining types with functionality like
    async destructors, but it would allow solving the [scoped task trilemma](/blog/the-scoped-task-trilemma):
    the scoped task API would return a future which is `!Leak`, guaranteeing that
    its destructor will run.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种较弱的限制不允许定义具有类似异步析构函数的功能的类型，但允许解决[作用域任务三难题](/blog/the-scoped-task-trilemma)：作用域任务API将返回一个`!Leak`的未来，保证其析构函数将运行。
- en: 'In practice, the API would ensure that it is asynchronously cleaned up almost
    all of the time, to a similar degree that even without unforgettable types, right
    now destructors almost always run. The async `scope` function would look something
    like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，API几乎总是异步清理，就像即使没有不可忘记的类型，现在析构函数几乎总是运行一样。异步`scope`函数将类似于以下内容：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because the `Scope` type would be `!Leak`, the future returned by this function
    would also be `!Leak`. If `poll_cancel` on that future is not called, the synchronous
    destructor will run: that will act as an “emergency backstop,” blocking this thread
    and ensuring memory safety. But as long as this is executed with a correctly implemented
    runtime, instead the asynchronous clean up code will run, ensuring that all the
    child tasks are awaited without blocking the thread.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Scope`类型将是`!Leak`，所以该函数返回的未来也将是`!Leak`。如果该未来上的`poll_cancel`未被调用，则同步析构函数将运行：这将充当“紧急备用”，阻止此线程并确保内存安全。但只要这是在正确实现的运行时中执行的，那么异步清理代码将运行，确保所有子任务都在不阻塞线程的情况下等待。
- en: Undroppable types
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可丢弃的类型
- en: Undroppable types allow expressing a wider variety of contracts in the types,
    but require more code to use correctly. This would involve adding the ability
    to define a type that does not implement `Drop`, and so cannot be dropped (this
    would be different from today where types that don’t implement `Drop` can still
    be dropped; remember we’re avoiding discussing the migration story in this post).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不可丢弃的类型允许在类型中表达更广泛的合约，但需要更多的代码才能正确使用。这将涉及添加定义不实现`Drop`的类型的能力，因此不能被丢弃（这将与今天不同，今天不实现`Drop`的类型仍然可以被丢弃；请记住，我们在本文中避免讨论迁移故事）。
- en: 'Whereas adding `Leak` impacts only a handful of APIs, `!Drop` would impact
    a large many more: any time you drop any generic value in any code path of that
    function, that type would need to be bound by `Drop`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 而添加`Leak`只会影响少数API，`!Drop`会影响更多：在该函数的任何代码路径中丢弃任何通用值时，该类型将需要被`Drop`绑定。
- en: 'Because undroppable types cannot be dropped, the only way to get rid of them
    is to destructure them. If they have private fields, they can only be destructured
    by calling a public method which destructures them internally; this lets the author
    of an undroppable type provide one or more clean up methods which *must* be called:
    users cannot forget to call it, because it will result in an error.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为不可丢弃的类型无法丢弃，所以摆脱它们的唯一方法是解构它们。如果它们有私有字段，则只能通过调用内部解构它们的公共方法来解构它们；这允许不可丢弃类型的作者提供一个或多个*必须*调用的清理方法：用户不能忘记调用它，因为这将导致错误。
- en: For example, an undroppable `File` type could expose a `close` method, which
    is the only way to get rid of that `File`. Users would get an error if they did
    not remember to close the `File` explicitly in their code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，不可丢弃的`File`类型可以公开一个`close`方法，这是摆脱该`File`的唯一方法。如果用户在代码中未显式记得关闭`File`，则会收到错误。
- en: 'Niko Matsakis proposes this as a way to implement async destructors: there
    would be some sort of `AsyncDrop` trait; types which are meant to have an async
    destructor would implement this trait but not `Drop`. Then there would be an `async_drop`
    function which you are meant to call explicitly on these types to run the clean
    up code. This is the only proposal for “async destructors” that I believe avoids
    all of the problems I listed earlier: instead of implicit async destructors, you
    use undroppable types that require you to explicitly call their async clean-up
    code.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尼科·马扎基斯提出这作为实现异步析构函数的一种方式：将会有某种`AsyncDrop`特质；意味着要有异步析构函数的类型将实现此特质，但不会实现`Drop`。然后将有一个`async_drop`函数，你应该显式在这些类型上调用它以运行清理代码。这是我认为避免了我之前列出的所有问题的“异步析构函数”的唯一提议：使用不可丢弃的类型，要求您显式调用它们的异步清理代码，而不是隐式的异步析构函数。
- en: In the scoped task API shown before, the `await_all_tasks` method would be the
    *only* way to destroy the `Scope` type, which would not implement `Drop`. This
    ensures that this method is ultimately called, solving the scoped task trilemma.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前显示的作用域任务API中，`await_all_tasks`方法将是销毁`Scope`类型的*唯一*方法，该方法不会实现`Drop`。这确保最终调用此方法，从而解决了作用域任务三难题。
- en: Async cancellation and `do` &mldr; `final` are prerequisite
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步取消和`do` &mldr; `final`是前提条件
- en: 'There was one issue with Niko Matsakis’s proposal about how undroppable types
    could be used for asynchronous clean up. Consider his description:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尼科·马扎基斯（Niko Matsakis）关于不可丢弃类型如何用于异步清理的建议存在一个问题。考虑他的描述：
- en: The simplest way to achieve “async drop” then would to define a trait `trait
    AsyncDrop { async fn async_drop(self); }` and then make the type “must move”.
    This will force callers to eventually invoke `async_drop(x).await`. We might want
    some syntactic sugar to handle `?` more easily, but that could come later.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现“异步丢弃”的最简单方法是定义一个特质`trait AsyncDrop { async fn async_drop(self); }`，然后使类型“必须移动”。这将强制调用者最终调用`async_drop(x).await`。我们可能希望有一些语法糖来更轻松地处理`?`，但那可能会在之后再讨论。
- en: 'What Matsakis fails to mention in this comment is the problem of the future
    returned by `async_drop` itself: what if you drop *that future*? Now the async
    destructor isn’t run to completion, violating the contract. The implication is
    that the future returned by `async_drop` must itself not implement `Drop`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在此评论中Matsakis未提及的一个问题是`async_drop`本身返回的未来：如果您丢弃*该未来*会怎么样？现在异步析构函数没有完全运行，违反了合同。这意味着`async_drop`返回的未来本身不能实现`Drop`。
- en: But how would you cancel a future which is not `Drop`? You would need an async
    cancellation path which evaluates the destructor. If a runtime wants to support
    tasks that have async destructors, it would have to guarantee that it either polls
    all tasks to completion, or if they are canceled it runs their async cancellation
    path to completion.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您如何取消不是`Drop`的未来？您需要一个异步取消路径来评估析构函数。如果运行时想支持具有异步析构函数的任务，它必须保证要么轮询所有任务完成，要么如果它们被取消，则运行它们的异步取消路径以完成。
- en: 'In other words, `poll_cancel` is a prerequisite of making undroppable types
    work. And when Matsakis alludes to “syntactic sugar to handle `?` more easily,”
    that is what `do` &mldr; `final` is meant to do: it allows you to hold an undroppable
    type across any code block that has an early return or a panic in it.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`poll_cancel`是使不可丢弃类型工作的先决条件。当Matsakis暗示“语法糖更容易处理`?`”时，`do` &mldr; `final`的目的是什么：它允许您在任何具有早期返回或其中出现panic的代码块中持有不可丢弃类型。
- en: These are also prerequisites for unforgettable types, because you need a combination
    of async cancellation and a `do` &mldr; `final` block to make the scoped task
    API asynchronously await all of the scoped tasks by default, without resorting
    to the blocking emergency backstop.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也是不可忘记类型的先决条件，因为您需要异步取消的组合和`do` &mldr; `final`块，以使作用域任务API默认异步等待所有作用域任务，而无需诉诸阻塞的紧急备用方案。
- en: What this means is that the other features in this post would also be prerequisites
    for either undroppable or unforgettable types. Because either definition of “linear”
    types would be a massive change to Rust, and one that seems unlikely to happen
    before 2027, the immediately actionable thing to do would be to add async cancellation
    and `do` &mldr; `final`, which will allow users to perform some sort of async
    clean up in the near term even without linear types.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着本文中的其他特性也将成为线性类型或不可忘记类型的先决条件。因为“线性”类型的任一定义都将是对Rust的重大改变，而且在2027年之前似乎不太可能发生，因此立即可执行的事情是添加异步取消和`do`
    &mldr; `final`，这将允许用户在短期内执行某种异步清理，即使没有线性类型也可以。
