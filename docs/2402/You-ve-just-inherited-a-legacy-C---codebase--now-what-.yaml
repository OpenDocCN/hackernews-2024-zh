- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-29 13:29:01'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-29 13:29:01
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: You've just inherited a legacy C++ codebase, now what?
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你刚刚继承了一个遗留的 C++ 代码库，现在该怎么办？
- en: 来源：[https://gaultier.github.io/blog/you_inherited_a_legacy_cpp_codebase_now_what.html](https://gaultier.github.io/blog/you_inherited_a_legacy_cpp_codebase_now_what.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://gaultier.github.io/blog/you_inherited_a_legacy_cpp_codebase_now_what.html](https://gaultier.github.io/blog/you_inherited_a_legacy_cpp_codebase_now_what.html)
- en: Published on 2024-02-29.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 发布日期为2024-02-29。
- en: You’ve just inherited a legacy C++ codebase, now what?
  id: totrans-split-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你刚刚继承了一个遗留的 C++ 代码库，现在该怎么办？
- en: '*This article was discussed on [Hacker News](https://news.ycombinator.com/item?id=39549486),
    [Lobster.rs](https://lobste.rs/s/lf8b9r/you_ve_just_inherited_legacy_c_codebase)
    and [Reddit](https://old.reddit.com/r/programming/comments/1b3143w/youve_just_inherited_a_legacy_c_codebase_now_what/).
    I’ve got great suggestions from the comments, see the addendum at the end!*'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*这篇文章在[Hacker News](https://news.ycombinator.com/item?id=39549486)、[Lobster.rs](https://lobste.rs/s/lf8b9r/you_ve_just_inherited_legacy_c_codebase)和[Reddit](https://old.reddit.com/r/programming/comments/1b3143w/youve_just_inherited_a_legacy_c_codebase_now_what/)上讨论过。从评论中得到了很好的建议，请看结尾的附录！*'
- en: You were minding your own business, and out of nowhere something fell on your
    lap. Maybe you started a new job, or perhaps changed teams, or someone experienced
    just left.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在自己做自己的事情，突然间有东西掉到你身上。也许你开始了一份新工作，或者换了团队，或者有经验的人离开了。
- en: And now you are responsible for a C++ codebase. It’s big, complex, idiosyncratic;
    you stare too long at it and it breaks in various interesting ways. In a word,
    legacy.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你要负责一个庞大、复杂、古怪的 C++ 代码库；你盯着它看时间太久，它会以各种有趣的方式崩溃。总之，它是遗留的。
- en: But somehow bugs still need to be fixed, the odd feature to be added. In short,
    you can’t just ignore it or better yet nuke it out of existence. It matters. At
    least to someone who’s paying your salary. So, it matters to you.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一些 bug 仍然需要修复，偶尔需要添加新功能。简而言之，你不能忽视它，更好的办法是不要把它完全消灭。它是重要的。至少对于支付你工资的人来说是重要的。所以，它对你很重要。
- en: What do you do now?
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你该怎么办？
- en: 'Well, fear not, because I have experience this many times in numerous places
    (the snarky folks in the back will mutter: what C++ codebase isn’t exactly like
    I described above), and there is a way out, that’s not overly painful and will
    make you able to actually fix the bugs, add features, and, one can dream, even
    rewrite it some day.'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕，因为我在许多地方多次经历过这种情况（背后那些讽刺的人会嘀咕：哪个 C++ 代码库不正如我所描述的那样），而且有一种方法可以走出困境，不会太痛苦，能让你实际修复
    bug、添加功能，甚至梦想中的某一天重写它。
- en: So join me on a recollection of what worked for me and what one should absolutely
    avoid.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，请跟我一起回顾对我有效的方法，以及应该绝对避免的事情。
- en: And to be fair to C++, I do not hate it (per se), it just happens to be one
    of these languages that people abuse and invariably leads to a horrifying mess
    and poor C++ is just the victim here and the C++ committee will fix it in C++45,
    worry not, by adding `std::cmake` to the standard library and you’ll see how it’s
    absolutely a game changer, and - Ahem, ok let’s go back to the topic at hand.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说 C++，我并不讨厌它（本质上），它只是被人滥用的一种语言，不可避免地导致了可怕的混乱，可怜的 C++ 只是这里的受害者，C++ 委员会将在 C++45
    中修复它，放心吧，通过将`std::cmake`加入标准库，你会看到它绝对是一个游戏改变者，啊- 咳咳，好吧，让我们回到话题。
- en: 'So here’s an overview of the steps to take:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里是要采取的步骤概述：
- en: Get it to work locally, by only doing the minimal changes required in the code
    and build system, ideally none. No big refactorings yet, even if itches really
    bad!
  id: totrans-split-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把它在本地运行起来，只需做必要的代码和构建系统的最小更改，最好是没有。即使痒得厉害也不要进行大规模重构！
- en: Get out the chainsaw and rip out everything that’s not absolutely required to
    provide the features your company/open source project is advertising and selling
  id: totrans-split-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿出电锯，除去一切不是绝对必要的东西，以提供公司/开源项目正在宣传和销售的功能。
- en: Make the project enter the 21st century by adding CI, linters, fuzzing, auto-formatting,
    etc
  id: totrans-split-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让项目进入 21 世纪，通过添加 CI、代码检查、模糊测试、自动格式化等。
- en: Finally we get to make small, incremental changes to the code, Rinse and repeat
    until you’re not awaken every night by nightmares of Russian hackers p@wning your
    application after a few seconds of poking at it
  id: totrans-split-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以对代码进行小的增量更改，反复操作，直到你在每个夜晚都不再因为俄罗斯黑客在几秒钟内轻松攻破你的应用程序而惊醒。
- en: If you can, contemplate rewrite some parts in a memory safe language
  id: totrans-split-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能的话，考虑用一种内存安全的语言重写部分内容
- en: The overarching goal is exerting the least amount of effort to get the project
    in an acceptable state in terms of security, developer experience, correctness,
    and performance. It’s crucial to always keep that in mind. It’s not about ‘clean
    code’, using the new hotness language features, etc.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最终目标是尽可能少地付出努力，以在安全性、开发人员体验、正确性和性能方面使项目达到可接受的状态。始终牢记这一点至关重要。这不是关于‘整洁的代码’，使用新潮的语言特性等等。
- en: Ok, let’s dive in!
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始吧！
- en: '*By the way, everything here applies to a pure C codebase or a mixed C and
    C++ codebase, so if that’s you, keep reading!*'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺便说一句，这里的一切都适用于纯 C 代码库或混合 C 和 C++ 代码库，所以如果你属于这一类，请继续阅读！*'
- en: '**Table of contents**'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**'
- en: Get buy-in
  id: totrans-split-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获得支持
- en: You thought I was going to compare the different sanitizers, compile flags,
    or build systems? No sir, before we do any work, we talk to people. Crazy, right?
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你以为我会比较不同的消毒剂、编译标志或者构建系统？不，先和人们交流。疯狂吧？
- en: 'Software engineering needs to be a sustainable practice, not something you
    burn out of after a few months or years. We cannot do this after hours, on a death
    march, or even, alone! We need to convince people to support this effort, have
    them understand what we are doing, and why. And that encompasses everyone: your
    boss, your coworkers, even non-technical folks. And who knows, maybe you’ll go
    on vacation and return to see that people are continuing this effort when you’re
    out of office.'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程需要成为一种可持续的实践，而不是你在几个月或几年后就会疲惫不堪的东西。我们不能在下班后、在一场死亡进程中，甚至是单打独斗中做到这一点！我们需要说服人们支持这一努力，让他们理解我们在做什么以及为什么要这么做。这包括每个人：你的老板、你的同事，甚至非技术人员。也许你去度假，回来时会发现人们在你不在办公室时继续推进这一努力。
- en: 'All of this only means: explain in layman terms the problem with a few simple
    facts, the proposed solution, and a timebox. Simple right? For example (to quote
    South Park: *All characters and events in this show—even those based on real people—are
    entirely fictional*):'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些只意味着：用简单的事实解释问题，提出解决方案并设定时间框架。简单吧？例如（引用 South Park 的话：*此节目中的所有角色和事件——即使是基于真实人物——都是虚构的*）：
- en: Hey boss, the last hire took 3 weeks to get the code building on his machine
    and make his first contribution. Wouldn’t it be nice if, with minimal effort,
    we could make that a few minutes?
  id: totrans-split-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿，老板，上一个新员工花了 3 周时间在他的机器上构建代码并进行了第一次贡献。如果我们能够以最小的努力让这个过程缩短到几分钟，那不是挺好的吗？
- en: Hey boss, I put quickly together a simple fuzzing setup (‘inputting random data
    in the app like a monkey and seeing what happens’), and it manages to crash the
    app 253 times within a few seconds. I wonder what would happen if people try to
    do that in production with our app?
  id: totrans-split-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿，老板，我快速地搭建了一个简单的模糊测试设置（‘向应用中输入随机数据，像猴子一样看会发生什么’），在几秒钟内成功让应用崩溃了 253 次。我在想，如果在生产环境中有人试图这样做，会发生什么？
- en: Hey boss, the last few urgent bug fixes took several people and 2 weeks to be
    deployed in production because the app can only be built by this one build server
    with this ancient operating system that has not been supported for 8 years (FreeBSD
    9, for the curious) and it kept failing. Oh by the way whenever this server dies
    we have no way to deploy anymore, like at all. Wouldn’t it be nice to be able
    to build our app on any cheap cloud instance?
  id: totrans-split-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿，老板，最近几个紧急 bug 修复需要多人参与，花了 2 周时间才在生产环境中部署完成，因为这个应用只能通过一个带有已经不再支持的古老操作系统的构建服务器构建（对于感兴趣的人来说是
    FreeBSD 9），而且它一直失败。哦，顺便说一句，每当这台服务器挂掉时，我们就没法部署了，完全没有办法。要不要考虑能够在任何廉价的云实例上构建我们的应用？
- en: Hey boss, we had a cryptic bug in production affecting users, it took weeks
    to figure out and fix, and it turns out if was due to undefined behavior (‘a problem
    in the code that’s very hard to notice’) corrupting data, and when I run this
    industry standard linter (‘a program that finds issues in the code’) on our code,
    it detects the issue instantly. We should run that tool every time we make a change!
  id: totrans-split-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿，老板，我们的生产环境出现了一个难以理解的 bug，影响了用户，花了几周时间才找到并修复。原来是由于未定义行为（‘在代码中很难注意到的问题’）导致数据损坏。当我在我们的代码上运行这个行业标准的代码检查工具（‘一个可以找出代码问题的程序’）时，它立即检测到了问题。每次修改代码时我们应该运行这个工具！
- en: Hey boss, the yearly audit is coming up and the last one took 7 months to pass
    because the auditor was not happy with what they saw. I have ideas to make that
    smoother.
  id: totrans-split-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿，老板，年度审计即将到来，上次审计因为审计员对所见情况不满意花了 7 个月才通过。我有一些想法可以让这次变得更顺利。
- en: Hey boss, there is a security vulnerability in the news right now about being
    able to decrypt encrypted data and stealing secrets, I think we might be affected,
    but I don’t know for sure because the cryptography library we use has been vendored
    (‘copy-pasted’) by hand with some changes on top that were never reviewed by anyone.
    We should clean that up and setup something so that we get alerted automatically
    if there is a vulnerability that affects us.
  id: totrans-split-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿老板，现在关于能够解密加密数据并窃取机密的安全漏洞正在新闻中，我认为我们可能会受到影响，但我不能确定，因为我们使用的密码库是手动‘复制-粘贴’并在其上进行了一些未经任何人审查的更改。我们应该清理一下，并设置一些东西，以便我们在受影响的漏洞发生时自动接收警报。
- en: 'And here’s what to avoid, again totally, super duper fictional, never-really-happened-to-me
    examples:'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些要避免的，完全是超级幻想，从未真正发生在我身上的例子：
- en: We are not using the latest C++ standard, we should halt all work for 2 weeks
    to upgrade, also I have no idea if something will break because we have no tests
  id: totrans-split-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有使用最新的 C++ 标准，我们应该停止所有工作 2 周来进行升级，同时我也不知道是否会出现问题，因为我们没有任何测试
- en: I am going to change a lot of things in the project on a separate branch and
    work on it for months. It’s definitely getting merged at some point! (*narrator’s
    voice:* it wasn’t)
  id: totrans-split-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将在一个单独的分支上对项目进行大量更改，并在几个月内进行工作。它肯定会在某个时候合并！（旁白：事实并非如此）
- en: We are going to rewrite the project from scratch, it should take a few weeks
    tops
  id: totrans-split-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从头开始重写项目，应该最多花几周时间
- en: We are going to improve the codebase, but no idea when it will be done or even
    what we are going to do exactly
  id: totrans-split-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将改进代码库，但不知道何时会完成或甚至我们确切要做什么
- en: 'Ok, let’s say that now you have buy-in from everyone that matters, let’s go
    over the process:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在你已经得到了所有重要人士的支持，让我们过一下流程：
- en: Every change is small and incremental. The app works before and works after.
    Tests pass, linters are happy, nothing was bypassed to apply the change (exceptions
    do happen but that’s what they are, exceptional)
  id: totrans-split-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次更改都是小而逐步的。应用程序在之前和之后都可以正常工作。测试通过，语法检查器也很满意，没有绕过任何内容来应用这些更改（例外情况确实会发生，但那只是例外）。
- en: If an urgent bug fix has to be made, it can be done as usual, nothing is blocked
  id: totrans-split-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果必须进行紧急的错误修复，可以像往常一样进行，没有任何阻碍
- en: Every change is a measurable improvement and can be explained and demoed to
    non experts
  id: totrans-split-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次更改都是可量化的改进，并且可以解释并向非专家演示
- en: If the whole effort has to be suspended or stopped altogether (because of priorities
    shifting, budget reasons, etc), it’s still a net gain overall compared to before
    starting it (and that gain is in some form *measurable*)
  id: totrans-split-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果整个工作必须暂停或完全停止（因为优先级转移、预算原因等），总体而言仍然比开始之前是一种净收益（而且这种收益以某种形式是*可量化*的）
- en: In my experience, with this approach, you keep everyone happy and can do the
    improvements that you really need to do.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，采用这种方法，你能让每个人都满意，并能进行真正需要做的改进。
- en: Alright, let’s get down to business now!
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在让我们开始吧！
- en: Write down the platforms you support
  id: totrans-split-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写下你支持的平台列表
- en: This is so important and not many projects do it. Write in the README (you do
    have a README, right?). It’s just a list of `<architecture>-<operating-system>`
    pair, e.g. `x86_64-linux` or `aarch64-darwin`, that your codebase officially supports.
    This is crucial for getting the build working on every one of them but also and
    we’ll see later, removing cruft for platforms you do *not* support.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要，但不是许多项目所做的。在 README 中写下来吧（你肯定有 README 吧？）。它只是你的代码库官方支持的`<架构>-<操作系统>`对的列表，例如
    `x86_64-linux` 或 `aarch64-darwin`。这对于使每一个平台上的构建工作都至关重要，而且稍后我们会看到，还可以删除你*不*支持的平台上的废物。
- en: If you want to get fancy, you can even write down which version of the architecture
    such as ARMV6 vs ARMv7, etc.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要搞高级的，甚至可以写下架构的版本，比如 ARMV6 vs ARMv7 等等。
- en: 'That helps answer important questions such as:'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于回答一些重要问题，比如：
- en: Can we rely on having hardware support for floats, or SIMD, or SHA256?
  id: totrans-split-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否可以依赖于硬件支持浮点数、SIMD 或 SHA256？
- en: Do we even care about supporting 32 bits?
  id: totrans-split-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否在乎支持 32 位？
- en: 'Are we ever running on a big-endian platform? (The answer is very likely: no,
    never did, never will - if you do, please email me with the details because that
    sounds interesting).'
  id: totrans-split-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否曾经在大端平台上运行过？（答案很可能是：没有，从未如此，将来也不会 - 如果您这样做了，请通过电子邮件告诉我详细信息，因为这听起来很有趣）。
- en: Can a `char` be 7 bits?
  id: totrans-split-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 能是 7 位吗？'
- en: 'And an important point: This list should absolutely include the developers
    workstations. Which leads me to my next point:'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的观点：这个列表绝对应该包括开发者的工作站。这让我想到了我的下一个观点：
- en: Get the build working on your machine
  id: totrans-split-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使构建在您的机器上正常工作
- en: You’d be amazed at how many C++ codebase in the wild that are a core part of
    a successful product earning millions and they basically do not compile. Well,
    if all the stars are aligned they do. But that’s not what I’m talking about. I’m
    talking about reliably, consistently building on all platforms you support. No
    fuss, no ‘I finally got it building after 3 weeks of hair-pulling’ (this brings
    back some memories). It just works(tm).
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您会惊讶地发现，有多少野生的C++代码库是成功产品的核心部分，赚取数百万美元，而它们基本上无法编译。嗯，如果所有条件都符合，它们可以。但这不是我的重点。我说的是在您支持的所有平台上可靠、一致地构建。没有麻烦，没有‘经过三周的拔头发终于搞定了’（这让我想起了一些回忆）。它只是工作（tm）。
- en: 'A small aparte here. I used to be really into Karate. We are talking 3, 4 training
    sessions a week, etc. And I distinctly remember one of my teachers telling me
    (picture a wise Asian sifu - hmm actually my teacher was a bald white guy… picture
    Steve Ballmer then):'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小插曲在这里。我曾经非常喜欢空手道。我们每周进行3到4次训练，等等。我清楚地记得我的一位老师告诉过我（想象一个睿智的亚洲师傅 - 嗯实际上我的老师是个秃头白人…
    想象一下史蒂夫·鲍尔默）：
- en: You do not yet master this move. Sometimes you do and sometimes you don’t, so
    you don’t. When eating with a spoon, do you miss your mouth one out of five times?
  id: totrans-split-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您还没有掌握这一步骤。有时您会做到，有时您不会，因此您不要强求。吃饭时，用汤匙吃，你有五次中就有一次不会把勺子送到嘴巴里吗？
- en: And I carried that with me as a Software Engineer. ‘The new feature works’ means
    it works every time. Not four out of five times. And so the build is the same.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件工程师，我一直秉持着这个理念。‘新功能可用’意味着它每次都有效。不是四次成功，一次失败。因此，构建也是如此。
- en: Experience has shown me that the best way to produce software in a fast and
    efficient way is to be able to build on your machine, and ideally even run it
    on your machine.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 经验告诉我，以快速和高效的方式生产软件的最佳方法是能够在您的机器上构建，理想情况下甚至在您的机器上运行。
- en: Now if your project is humongous that may be a problem, your system might not
    even have enough RAM to complete the build. A fallback is to rent a big server
    somewhere and run your builds here. It’s not ideal but better than nothing.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您的项目非常庞大，这可能会成为一个问题，您的系统甚至可能没有足够的内存来完成构建。后备方案是在某处租用一个大型服务器并在此运行您的构建。这不是最理想的，但总比什么都不强。
- en: Another hurdle is the code requiring some platform specific API, for example
    `io_uring` on Linux. What can help here is to implement a shim, or build inside
    a virtual machine on your workstation. Again, not ideal but better than nothing.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个障碍是代码需要一些特定平台的API支持，例如在Linux上的`io_uring`。在这里有所帮助的是实现一个适配器，或者在您的工作站上构建一个虚拟机。虽然不是最理想的，但总比没有强。
- en: I have done all of the above in the past and that works but building directly
    on your machine is still the best option.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我过去做过所有这些，效果很好，但直接在您的机器上构建仍然是最佳选择。
- en: Get the tests passing on your machine
  id: totrans-split-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的机器上使测试通过
- en: First, if there are no tests, I am sorry. This is going to be really difficult
    to do any change at all. So go write some tests before doing any change to the
    code, make them pass, and come back. The easiest way is to capture inputs and
    outputs of the program running in the real world and write end-to-end tests based
    on that, the more varied the better. It will ensure there are no regressions when
    making changes, not that the behavior was correct in the first place, but again,
    better than nothing.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果没有测试，我很抱歉。这将使得任何更改都变得非常困难。所以在对代码进行任何更改之前，先编写一些测试用例，并确保通过，然后再继续。最简单的方法是捕获程序在现实世界中运行的输入和输出，并基于此编写端到端测试，越多样化越好。这将确保在进行更改时没有回退，虽然行为是否一开始就是正确的，但总比什么都不做强。
- en: So, now you have a test suite. If some tests fail, disable them for now. Make
    them pass, even if the whole test suite takes hours to run. We’ll worry about
    that later.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在你有了一个测试套件。如果有些测试失败，暂时禁用它们。确保使其通过，即使整个测试套件运行需要几个小时。我们以后再来解决这个问题。
- en: Write down in the README how to build and test the application
  id: totrans-split-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在README中写下如何构建和测试应用程序的步骤
- en: Ideally it’s one command to build and one for testing. At first it’s fine if
    it’s more involved, in that case the respective commands can be put in a `build.sh`
    and `test.sh` that encapsulate the madness.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，构建和测试应该只需一个命令。起初，如果更复杂，可以将相应的命令放入`build.sh`和`test.sh`中，以封装这种混乱。
- en: The goal is to have a non C++ expert be able to build the code and run the tests
    without having to ask you anything.
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是使非C++专家能够构建代码并运行测试，而无需询问您任何事情。
- en: Here some folks would recommend documenting the project layout, the architecture,
    etc. Since the next step is going to rip out most of it, I’d say don’t waste your
    time now, do that at the end.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人会建议文档化项目布局、架构等。因为下一步将剥离大部分内容，所以我建议现在不要浪费时间，最后再做。
- en: Find low hanging fruits to speed up the build and tests
  id: totrans-split-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到加快构建和测试速度的低成本方法
- en: Emphasis on ‘low hanging’. No change of the build system, no heroic efforts
    (I keep repeating that in this article but this is so important).
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 强调“低成本”。不改变构建系统，不进行英雄主义的努力（我在本文中一直重复这一点，因为这非常重要）。
- en: 'Again, in a typical C++ project, you’d be amazed at how much work the build
    system is doing without having to do it at all. Try these ideas below and measure
    if that helps or not:'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在一个典型的 C++ 项目中，你会惊讶于构建系统在没有任何必要时所做的工作量。尝试下面的这些想法，看看是否有帮助：
- en: Building and running tests *of your dependencies*. In a project which was using
    `unittest++` as a test framework, built as a CMake subproject, I discovered that
    the default behavior was to build the tests of the test framework, and run them,
    every time! That’s crazy. Usually there is a CMake variable or such to opt-out
    of this.
  id: totrans-split-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下构建和运行依赖项的测试。在一个项目中，该项目将 `unittest++` 作为一个 CMake 子项目进行构建时，我发现默认行为是每次构建和运行测试框架的测试！这太疯狂了。通常有一个
    CMake 变量或者类似的东西可以选择退出这个行为。
- en: Building and running example programs *of your dependencies*. Same thing as
    above, the culprit that time was `mbedtls`. Again, setting a CMake variable to
    opt-out of that solved it.
  id: totrans-split-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下构建和运行依赖项的示例程序。和上面一样，这次的罪魁祸首是 `mbedtls`。再次，设置一个 CMake 变量来选择退出解决了这个问题。
- en: Building and running the tests of your project by default when it’s being included
    as a subproject of another parent project. Yeah the default behavior we just laughed
    at in our dependencies? It turns out we’re doing the same to other projects! I
    am no CMake expert but it seems that there is no standard way to exclude tests
    in a build. So I recommend adding a build variable called `MYPROJECT_TEST` unset
    by default and only build and run tests when it is set. Typically only developers
    working on the project directly will set it. Same with examples, generating documentation,
    etc.
  id: totrans-split-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，在将其作为另一个父项目的子项目包含时，构建和运行你的项目的测试。是的，我们刚才嘲笑过依赖项的默认行为？结果我们对其他项目也做了同样的事情！我不是
    CMake 专家，但似乎没有标准的方法来排除构建测试。因此，我建议添加一个名为 `MYPROJECT_TEST` 的构建变量，默认情况下未设置，仅在设置时构建和运行测试。通常只有直接在项目上工作的开发人员会设置它。示例和生成文档等情况也是如此。
- en: 'Building all of a third-party dependency when you only need a small part of
    it: `mbedtls` comes to mind as a good citizen here since it exposes many compile-time
    flags to toggle lots of parts you might not need. Beware of the defaults, and
    only build what you need!'
  id: totrans-split-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你只需要其一小部分时，构建所有第三方依赖项：`mbedtls` 是一个很好的例子，因为它暴露了许多编译时标志来切换你可能不需要的许多部分。注意默认值，并且仅构建你需要的部分！
- en: 'Wrong dependencies listed for a target leading to rebuilding the world when
    it does not have to: most build systems have a way to output the dependency graph
    from their point of view and that can really help diagnose these issues. Nothing
    feels worse than waiting for minutes or hours for a rebuild, when deep inside,
    you know it should have only rebuilt a few files.'
  id: totrans-split-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误地列出了一个目标的错误依赖项，导致在不必要时重新构建整个世界：大多数构建系统都有一种方法可以从它们的角度输出依赖图，这真的可以帮助诊断这些问题。没有比等待数分钟或数小时重新构建更糟糕的感觉，而你深知它应该只重新构建了几个文件。
- en: 'Experiment with a faster linker: `mold` is one that can be dropped in and really
    help at no cost. However that really depends on how many libraries are being linked,
    whether that’s a bottleneck overall, etc.'
  id: totrans-split-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一个更快的链接器：`mold` 是一个可以无成本地集成并真正帮助的链接器。但这真的取决于链接的库的数量，无论总体上是否成为瓶颈等等。
- en: 'Experiment with a different compiler, if you can: I have seen projects where
    clang is twice as fast as gcc, and others where there is no difference.'
  id: totrans-split-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以的话，尝试使用不同的编译器：我见过一些项目，clang 的速度是 gcc 的两倍，而另一些则没有区别。
- en: 'Once that’s done, here are a few things to additionally try, although the gains
    are typically much smaller or sometimes negative:'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些工作，这里有一些额外尝试的事情，尽管增益通常要小得多，有时甚至是负面的：
- en: 'LTO: off/on/thin'
  id: totrans-split-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LTO：关闭/开启/精简
- en: Split debug information
  id: totrans-split-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分调试信息
- en: Make vs Ninja
  id: totrans-split-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Make 或 Ninja
- en: The type of file system in use, and tweaking its settings
  id: totrans-split-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在使用的文件系统类型，以及调整其设置
- en: Once the iteration cycle feels ok, the code gets to go under the microscope.
    If the build takes ages, it’s not realistic to want to modify the code.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦迭代周期感觉良好，代码就要被放大镜检查。如果构建需要很长时间，想要修改代码就不现实了。
- en: Remove all unnecessary code
  id: totrans-split-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除所有不必要的代码。
- en: Dad, I see dead lines of code.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 爸爸，我看到死代码的截止日期了。
- en: (Get the reference? Well, ok then.)
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: （明白引用了吗？好的，那么。）
- en: I have seen 30%, sometimes more, of a codebase, being completely dead code.
    That’s lines of code you pay for every time you compile, you want to make a refactoring,
    etc. So let’s rip them out.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过 30% 甚至更多的代码库完全是死代码。这是每次编译都要支付代价的代码行，你想进行重构等等。所以我们来把它们剔除吧。
- en: 'Here are some ways to go about it:'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些处理方法：
- en: The compiler has a bunch of `-Wunused-xxx` warnings, e.g. `-Wunused-function`.
    They catch some stuff, but not everything. Every single instance of these warnings
    should be addressed. Usually it’s as easy as deleting the code, rebuilding and
    re-running the tests, done. In rare cases it’s a symptom of a bug where the wrong
    function was called. So I’d be somewhat reluctant to fully automate this step.
    But if you’re confident in your test suite, go for it.
  id: totrans-split-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器有一堆 `-Wunused-xxx` 警告，例如 `-Wunused-function`。它们可以捕获一些东西，但不是所有东西。每个这类警告的实例都应该被处理。通常只需删除代码，重新构建和重新运行测试即可完成。在罕见情况下，这可能是一个调用了错误函数的
    bug 的症状。所以我会对完全自动化这一步骤有些犹豫。但如果你对自己的测试套件有信心，可以尝试一下。
- en: Linters can find unused functions or class fields, e.g. `cppcheck`. In my experience
    there are quite a lot of false positives especially regarding virtual functions
    in the case of inheritance, but the upside is that these tools absolutely find
    unused things that the compilers did not notice. So, a good excuse for adding
    a linter to your arsenal, if not to the CI (more on that later).
  id: totrans-split-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linters 可以找到未使用的函数或类字段，例如 `cppcheck`。根据我的经验，特别是在继承中涉及虚函数时，这些工具可能会有相当多的误报，但好处是这些工具能够绝对找出编译器未注意到的未使用的东西。因此，如果没有添加到
    CI（稍后再说），向你的工具箱添加 linter 是一个很好的借口。
- en: I have seen more exotic techniques were the linker is instructed to put each
    function in its own section and print every time a section is removed because
    it’s detected to be unused at link time, but that results in so much noise e.g. about
    standard library functions being unused, that I have not found that really practical.
    Others inspect the generated assembly and compare which functions are present
    there with the source code, but that does not work for virtual functions. So,
    maybe worth a shot, depending on your case?
  id: totrans-split-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我见过更奇特的技术，其中链接器被指示将每个函数放在自己的部分，并在链接时打印每次删除部分时发生的事情，因为检测到该部分在链接时未使用，但这会导致很多关于未使用标准库函数的噪音，所以我认为这并不实用。其他人检查生成的汇编代码并比较哪些函数存在于源代码中，但对虚函数无效。所以，也许可以试试，根据你的情况而定？
- en: Remember the list of supported platforms? Yeah, time to put it to use to kill
    all the code for unsupported platforms. Code trying to support ancient versions
    of Solaris on a project that exclusively ran on FreeBSD? Out of the window it
    goes. Code trying to provide its own random number generator because maybe the
    platform we run on does not have one (of course it turned out that was never the
    case)? To the bin. Hundred of lines of code in case POSIX 2001 is not supported,
    when we only run on modern Linux and macOS? Nuke it. Checking if the host CPU
    is big-endian and swapping bytes if it is? Ciao (when was the last time you shipped
    code for a big-endian CPU? And if yes, how are you finding IBM?). That code introduced
    years ago for a hypothetical feature that never came? Hasta la vista.
  id: totrans-split-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还记得支持的平台列表吗？是的，现在是时候利用它来删除所有不支持平台的代码了。试图支持古老 Solaris 版本的代码，而项目专门在 FreeBSD 上运行？抛出窗外吧。试图提供自己的随机数生成器，因为也许我们运行的平台没有一个（当然，后来证明从未出现这种情况）？扔进垃圾桶。在我们仅运行在现代
    Linux 和 macOS 上时，检查是否支持 POSIX 2001 的代码？抹掉它。检查主机 CPU 是否为大端序并在是的情况下交换字节的代码？再见了（你最后一次为大端序
    CPU 发布代码是什么时候？如果是，你是如何找到 IBM 的？）。多年前为一个从未实现的假设功能引入的代码？告别了。
- en: And the bonus for doing all of this, is not only that you sped up the build
    time by a factor of 5 with zero downside, is that, if your boss is a tiny bit
    technical, they’ll love seeing PRs deleting thousands of lines of code. And your
    coworkers as well.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的额外好处不仅仅是将编译时间加速了 5 倍而没有任何不利因素，而且，如果你的老板有一点技术背景，他们会喜欢看到删除数千行代码的 PR。你的同事们也是如此。
- en: Linters
  id: totrans-split-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linters
- en: Don’t go overboard with linter rules, add a few basic ones, incorporate them
    in the development life cycle, incrementally tweak the rules and fix the issues
    that pop up, and move on. Don’t try to enable all the rules, it’s just a rabbit
    hole of diminishing returns. I have used `clang-tidy` and `cppcheck` in the past,
    they can be helpful, but also incredibly slow and noisy, so be warned. Having
    no linter is not an option though. The first time you run the linter, it’ll catch
    so many real issues that you’ll wonder why the compiler is not detecting anything
    even with all the warnings on.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不要对代码检查器规则过于苛刻，添加一些基本规则，将它们整合到开发生命周期中，逐步调整规则并修复出现的问题，然后继续前进。不要试图启用所有规则，这只是一个收益递减的兔子洞。过去我使用过`clang-tidy`和`cppcheck`，它们可能会有所帮助，但也可能非常慢且嘈杂，所以请注意。然而，没有代码检查器不是一个选择。第一次运行代码检查器时，它将捕获到许多真实问题，让你想知道为什么即使开启了所有警告，编译器也检测不到任何问题。
- en: Code formatting
  id: totrans-split-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码格式化
- en: Wait for the appropriate moment where no branches are active (otherwise people
    will have horrendous merge conflicts), pick a code style at random, do a one time
    formatting of the entire codebase (no exceptions), typically with `clang-format`,
    commit the configuration, done. Don’t waste any bit of saliva arguing about the
    actual code formatting. It only exists to make diffs smaller and avoid arguments,
    so do not argue about it!
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: 等待没有活跃分支的合适时机（否则人们将面临可怕的合并冲突），随机选择一种代码风格，对整个代码库进行一次性格式化（没有例外），通常使用`clang-format`，提交配置，完成。不要浪费口水争论实际的代码格式化。它只存在于减小差异和避免争论，所以不要为此争论！
- en: Sanitizers
  id: totrans-split-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[消毒剂](https://github.com/rxi/microui/pull/67)'
- en: Same as linters, it can be a rabbit hole, unfortunately it’s absolutely required
    to spot real, production affecting, hard to detect, bugs and to be able to fix
    them. `-fsanitize=address,undefined` is a good baseline. They usually do not have
    false positives so if something gets detected, go fix it. Run the tests with it
    so that issues get detected there as well. I even heard of people running the
    production code with some sanitizers enabled, so if your performance budget can
    allow it, it could be a good idea.
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与代码检查器一样，它可能是一条兔子洞，不幸的是，它绝对是必需的，以发现真正影响生产、难以检测的错误，并能够修复它们。`-fsanitize=address,undefined`是一个良好的基线。它们通常不会产生误报，因此如果检测到问题，立即修复它。运行测试以便在那里也发现问题。我甚至听说有人在生产环境中启用了一些消毒剂，所以如果你的性能预算允许的话，这可能是个好主意。
- en: If the compiler you (have to) use to ship the production code does not support
    sanitizers, you can at least use clang or such when developing and running tests.
    That’s when the work you did on the build system comes in handy, it should be
    relatively easy to use different compilers.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你（不得不）用于发布生产代码的编译器不支持消毒剂，至少在开发和运行测试时可以使用 clang 或类似的工具。这时，你在构建系统上的工作就派上了用场，使用不同的编译器应该相对容易。
- en: 'One thing is for sure: even in the best codebase in the world, with the best
    coding practices and developers, the second you enable the sanitizers, you absolutely
    will uncover horrifying bugs and memory leaks that went undetected for years.
    So do it. Be warned that fixing these can require a lot of work and refactorings.
    Each sanitizer also has options so it could be useful to inspect them if your
    project is a special snowflake.'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点是肯定的：即使是世界上最好的代码库，拥有最佳的编码实践和开发者，一旦启用消毒剂，你绝对会发现多年来未被察觉的可怕的错误和内存泄漏。所以，请务必这样做。请注意，修复这些问题可能需要大量的工作和重构。每种消毒剂都有选项，所以如果你的项目很特别，检查它们可能会有用。
- en: 'One last thing: ideally, all third-party dependencies should also be compiled
    with the sanitizers enabled when running tests, to spot [issues](https://github.com/rxi/microui/pull/67)
    in them as well.'
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事：理想情况下，运行测试时，所有第三方依赖项也应该启用消毒剂来编译，以便发现其中的问题。
- en: Add a CI pipeline
  id: totrans-split-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个持续集成流水线
- en: As Bryan Cantrill once said (quoting from memory), ‘I am convinced most firmware
    just comes out of the home directory of a developer’s laptop’. Setting up a CI
    is quick, free, and automates all the good things we have set up so far (linters,
    code formatting, tests, etc). And that way we can produce in a pristine environment
    the production binaries, on every change. If you’re not doing this already as
    a developer, I don’t think you really have entered the 21st century yet.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Bryan Cantrill 曾经说过（从记忆中引用），“我确信大多数固件都是从开发者笔记本的主目录中出来的”。建立持续集成是快速、免费的，并自动化了我们迄今为止设置的所有好东西（代码检查器、代码格式化、测试等）。这样，我们可以在一个清洁的环境中，对每一次更改都生产出生产二进制文件。如果你作为开发者还没有这样做，我认为你还没有真正进入21世纪。
- en: 'Cherry on the cake: most CI systems allow for running the steps on a matrix
    of different platforms! So you can demonstrably check that the list of supported
    platforms is not just theory, it is real.'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一笔：大多数持续集成系统允许在不同平台上运行步骤！因此你能明确验证支持的平台列表不仅仅是理论，而是实际存在的。
- en: Typically the pipeline just looks like `make all test lint fmt` so it’s not
    rocket science. Just make sure that issues that get reported by the tools (linters,
    sanitizers, etc) actually fail the pipeline, otherwise no one will notice and
    fix them.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的构建流程看起来如 `make all test lint fmt` 等，基本不需要多大的技术挑战。然而应确保工具（如 Linters、安全检查器等）报告的问题能终止流程，否则无人关注和解决这些问题。
- en: Incremental code improvements
  id: totrans-split-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 折腾代码的改进
- en: Well that’s known territory so I won’t say much here. Just that lots of code
    can often be dramatically simplified.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是已知领域，我不会在此多言。只是说很多代码往往可以大幅简化。
- en: I remember iteratively simplifying a complicated class that manually allocated
    and (sometimes) deallocated memory, was meant to handle generic things, and so
    on. All the class did, as it turned out, was allocate a pointer, later check whether
    the pointer was null or not, and…that’s it. Yeah that’s a boolean in my book.
    True/false, nothing more to it.
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆起我曾迭代简化一个原本用于手动分配和（有时）回收内存的复杂类。这个类本意是处理通用事物的，结果发现类所做的只是分配一个指针，随后检查指针是否为 null，仅此而已。实际上这是布尔值。是真还是假，罢了。
- en: I feel that’s the step that’s the hardest to timebox because each round of simplification
    opens new avenues to simplify further. Use your best judgment here and stay on
    the conservative side. Focus on tangible goals such as security, correctness and
    performance, and stray away from subjective criteria such as ‘clean code’.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我感觉到的难点在于时间规划，因为每一次简化都可能开启进一步简化的新途径。请凭直觉判断并保持保守态度。将安全、正确性及性能等具体目标放在首位，远离诸如“干净代码”的主观评价标准。
- en: 'In my experience, upgrading the C++ standard in use in the project can at times
    help with code simplifications, for example to replace code that manually increments
    iterators by a `for (auto x : items)` loop, but remember it’s just a means to
    an end, not an end in itself. If all you need is `std::clamp`, just write it yourself.'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: '据我经验，升级项目使用的C++标准有时可以帮助简化代码。例如用 `for (auto x : items)` 循环替代手动迭代计数代码。但记住，这只是一条达到目标的途径，而非目标本身。假如你只需
    `std::clamp` ，不妨自己写。'
- en: Rewrite in a memory safe language?
  id: totrans-split-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转为使用内存安全语言？
- en: I am doing this right now at work, and that deserves an article of its own.
    Lots of gotchas there as well. Only do this with a compelling reason.
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我目前在工作上正这样做，这值得单独写篇文章。内有诸多陷阱。仅在有足够理由的情况下才进行。
- en: Conclusion
  id: totrans-split-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Well, there you have it. A tangible, step-by-step plan to get out of the finicky
    situation that’s a complex legacy C++ codebase. I have just finished going through
    that at work on a project, and it’s become much more bearable to work on it now.
    I have seen coworkers, who previously would not have come within a 10 mile radius
    of the codebase, now make meaningful contributions. So it feels great.
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就是答案。一项可以实际执行、步步推进的计划，旨在应对复杂的遗留C++代码库引发的棘手问题。我在项目中刚完成了这个计划，现在处理起来更人性化了。原本不接触代码库的同事，现在也能贡献有意义的成果。所以真的感觉很棒。
- en: There are important topics that I wanted to mention but in the end did not,
    such as the absolute necessity of being able to run the code in a debugger locally,
    fuzzing, dependency scanning for vulnerabilities, etc. Maybe for the next article!
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有重要的话题我想提及，但最终未能包含，例如本地调试器运行代码的必要性、Fuzzing、漏洞扫描等。或许下篇文章可以讨论这些。
- en: If you go through this on a project, and you found this article helpful, shoot
    me an email! It’s nice to know that it helped someone.
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如若在某个项目上进行这种简化，并且觉得这篇文章有帮助，请发封邮件给我。知道这文章能帮助人真的很令人欣慰。
- en: 'Addendum: Dependency management'
  id: totrans-split-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补充：依赖管理
- en: '*This section is very subjective, it’s just my strong, biased opinion.*'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*此部分观点极具主观性，仅为我的强烈偏见。*'
- en: 'There’s a hotly debated topic that I have so far carefully avoided and that’s
    dependency management. So in short, in C++ there’s none. Most people resort to
    using the system package manager, it’s easy to notice because their README looks
    like this:'
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个备受争议的主题，我迄今为止都尽量避免谈及，那就是依赖管理。总之，C++中缺乏系统辅助。大多数人都转向使用系统包管理器。这在 README 文件中很容易发现：
- en: '[PRE0]'
  id: totrans-split-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Etc. I have done it myself. And I think this is a terrible idea. Here’s why:'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。我自己就实施过。我认为这是一个糟糕的想法。原因如下：
- en: The installation instructions, as we’ve seen above, are OS and distribution
    dependent. Worse, they’re dependent on the version of the distribution. I remember
    a project that took months to move from Ubuntu 20.04 to Ubuntu 22.04, because
    they ship different versions of the packages (if they ship the same packages at
    all), and so upgrading the distribution also means upgrading the 100 dependencies
    of your project at the same time. Obviously that’s a very bad idea. You want to
    upgrade one dependency at a time, ideally.
  id: totrans-split-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s always a third-party dependency that has no package and you have to
    build it from source anyway.
  id: totrans-split-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The packages are never built with the flags you want. Fedora and Ubuntu have
    debated for years whether to build packaged with the frame pointer enabled (they
    finally do since very recently). Remember the section about sanitizers? How are
    you going to get dependencies with sanitizer enabled? It’s not going to happen.
    But there are way more examples: LTO, `-march`, debug information, etc. Or they
    were built with a different C++ compiler version from the one you are using and
    they broke the C++ ABI between the two.'
  id: totrans-split-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to easily see the source of the dependency when auditing, developing,
    debugging, etc, *for the version you are currently using*.
  id: totrans-split-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to be able to patch a dependency easily if you encounter a bug, and
    rebuild easily without having to change the build system extensively
  id: totrans-split-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You never get the exact same version of a package across systems, e.g. when
    developer Alice is on macOS, Bob on Ubuntu and the production system on FreeBSD.
    So you have weird discrepancies you cannot reproduce and that’s annoying.
  id: totrans-split-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Corollary of the point above: You don’t know exactly which version(s) you are
    using across systems and it’s hard to produce a Bill of Material (BOM) in an automated
    fashion, which is required (or going to be required very soon? Anyway it’s a good
    idea to have it) in some fields.'
  id: totrans-split-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The packages sometimes do not have the version of the library you need (static
    or dynamic)
  id: totrans-split-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So you’re thinking, I know, I will use those fancy new package managers for
    C++, Conan, vcpkg and the like! Well, not so fast:'
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
- en: They require external dependencies so your CI becomes more complex and slower
    (e.g. figuring out which exact version of Python they require, which surely will
    be different from the version of Python your project requires)
  id: totrans-split-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They do not have all versions of a package. Example: [Conan and mbedtls](https://conan.io/center/recipes/mbedtls),
    it jumps from version `2.16.12` to `2.23.0`. What happened to the versions in
    between? Are they flawed and should not be used? Who knows! Security vulnerabilities
    are not listed anyways for the versions available! Of course I had a project in
    the past where I had to use version `2.17`…'
  id: totrans-split-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They might not support some operating systems or architectures you care about
    (FreeBSD, ARM, etc)
  id: totrans-split-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I mean, if you have a situation where they work for you, that’s great, it’s
    definitely an improvement over using system packages in my mind. It’s just that
    I never encountered (so far) a project where I could make use of them - there
    was always some blocker.
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，如果你的情况适用，那太好了，这绝对比在我的想法中使用系统包要好。只是到目前为止，我从未遇到过能够使用它们的项目 - 总是有一些阻碍。
- en: 'So what do I recommend? Well, the good old git submodules and compiling from
    source approach. It’s cumbersome, yes, but also:'
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我推荐什么呢？好吧，就是那种传统的git子模块和从源代码编译的方法。确实有些麻烦，但也有：
- en: It’s dead simple
  id: totrans-split-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它非常简单易用
- en: It’s better than manually vendoring because git has the history and the diff
    functionalities
  id: totrans-split-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它比手动维护更好，因为git具有历史记录和差异功能
- en: You know exactly, down to the commit, which version of the dependency is in
    use
  id: totrans-split-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以确切地知道，从提交到使用的依赖项版本都是哪个
- en: Upgrading the version of a single dependency is trivial, just run `git checkout`
  id: totrans-split-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级单个依赖项的版本非常简单，只需运行`git checkout`
- en: It works on every platform
  id: totrans-split-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它适用于每个平台
- en: You get to choose exactly the compilation flags, compiler, etc to build all
    the dependencies. And you can even tailor it per dependency!
  id: totrans-split-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以完全自定义编译标志、编译器等来构建所有依赖项。甚至可以为每个依赖项进行定制！
- en: Developers know it already even if they have no C++ experience
  id: totrans-split-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者即使没有C++经验也已经了解它
- en: Fetching the dependencies is secure and the remote source is in git. No one
    is changing that sneakily.
  id: totrans-split-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取依赖项是安全的，远程源在git中。没有人会偷偷改变它。
- en: 'It works recursively (i.e.: transitively, for the dependencies of your dependencies)'
  id: totrans-split-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它递归地工作（即：对依赖项的依赖项也是如此）
- en: Compiling each dependency in each submodule can be as simple as `add_subdirectory`
    with CMake, or `git submodule foreach make` by hand.
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个子模块中编译每个依赖项可以像使用CMake的`add_subdirectory`那样简单，或者手动使用`git submodule foreach
    make`。
- en: 'If submodules are really not an option, an alternative is to still compile
    from source but do it by hand, with one script, that fetches each dependency and
    builds it. Example in the wild: Neovim.'
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子模块真的不是一个选择，一个替代方法是仍然从源代码编译，但是手动进行，使用一个脚本，该脚本获取每个依赖项并构建它。现实中的例子：Neovim。
- en: Of course, if your dependency graph visualized in Graphviz looks like a Rorschach
    test and has to build thousands of dependencies, it is not easily doable, but
    it might be still possible, using a build system like Buck2, which does hybrid
    local-remote builds, and reuses build artifacts between builds from different
    users.
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你的依赖图在Graphviz中看起来像Rorschach测试，并且必须构建成千上万个依赖项，那么这并不容易实现，但仍然可能，使用像Buck2这样的构建系统，它进行混合本地-远程构建，并在不同用户的构建之间重用构建产物。
- en: If you look at the landscape of package managers for compiled languages (Go,
    Rust, etc), all of them that I know of compile from source. It’s the same approach,
    minus git, plus the automation.
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看编译语言（如Go、Rust等）的包管理器格局，我所知道的所有都是从源代码编译。这是相同的方法，减去git，加上自动化。
- en: 'Addendum: suggestions from readers'
  id: totrans-split-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录：读者的建议
- en: 'I’ve gathered here some great ideas and feedback from readers (sometimes it’s
    the almagamation of multiple comments from different people, and I am paraphrasing
    from memory so sorry if it’s not completely accurate):'
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我从读者那里收集了一些很棒的想法和反馈（有时是来自不同人的多条评论的综合，我是凭记忆在改编，如果不完全准确，还请谅解）：
- en: '*You should put more emphasis on tests (expanding the test suite, the code
    coverage, etc) - but also: a test suite in C++ is only worth anything when running
    it under sanitizers, otherwise you get lured into a false sense of safety.* 100%
    agree. Modifying complex foreign code without tests is just not possible in my
    opinion. And yes, sanitizers will catch so many issues in the tests that you should
    even consider running your tests suite multiple time in CI with different sanitizers
    enabled.'
  id: totrans-split-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你应该更加重视测试（扩展测试套件、代码覆盖率等）- 但同时：在C++中的测试套件只有在使用sanitizer时才有价值，否则你会陷入一种虚假的安全感。*
    百分之百同意。在没有测试支持的复杂外部代码中进行修改，在我看来根本不可能。而且，sanitizer会在测试中捕获到很多问题，你甚至应该考虑在CI中多次运行测试套件，启用不同的sanitizer。'
- en: '*vcpkg is a good dependency manager for C++ that solves all of your woes.*
    I’ve never got the chance to use it so I’ll add it to my toolbox to experiment
    with. If it matches the requirements I listed, as well as enabling cross-compilation,
    then yes it’s absolutely a win over git submodules.'
  id: totrans-split-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*vcpkg是一个解决所有问题的好的C++依赖管理器。* 我从未有机会使用它，所以我会把它加入我的工具箱进行实验。如果它符合我列出的要求，并且支持跨平台编译，那么它绝对胜过git子模块。'
- en: '*Nix can serve as a good dependency manager for C++.* I must admit that I was
    beaten into submission by Nix’s complexity and slowness. Maybe in a few years
    when it has matured?'
  id: totrans-split-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Nix 可以作为 C++ 的良好依赖管理器*。我必须承认，我被 Nix 的复杂性和缓慢击败了。也许几年后当它成熟了再说？'
- en: '*You should not invest so much time in refactoring a legacy codebase if all
    you are going to do is one bug fix a year.* Somewhat agree, but it really is a
    judgement call. In my experience it’s never one and only one bug fix, whatever
    management says. And all the good things such as removing dead code, sanitizers
    etc will be valuable even for the odd bug fix and also lead to noticing more bugs
    and fixing them. As one replier put it: *If you are going to own a codebase, then
    own it for real.*'
  id: totrans-split-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果你每年只修复一个 bug，就不要投入太多时间重构老代码库*。有些同意，但这真的是个判断问题。根据我的经验，从来不只是一个 bug，无论管理层怎么说。像移除死代码、进行消毒等所有好事都对偶尔的
    bug 修复有益，同时也会发现更多 bug 并修复它们。就像一个回复者所说的：“如果你打算拥有一个代码库，那就真正拥有它。”'
- en: '*It’s very risky to remove code, in general you never know for sure if it’s
    being used or not, and if someone relies on this exact behavior in the wild.*
    That’s true, that’s why I advocate for removing code that is never called using
    static analysis tools, so that you know *for sure*. But yes, when in doubt, don’t.
    My pet peeve here are virtual methods that are very resistant to static analysis
    (since the whole point is to pick which exact method to call at runtime), these
    usually cannot be as easily removed. Also, talk to your sales people, your product
    managers, heck even your users if you can. Most of the time, if you ask them whether
    a given feature or platform is in use or not, you’ll get a swift yes or no reply,
    and you’ll know how to proceed. We engineers sometimes forget that a 15 minute
    talk with people can simplify so much technical work.'
  id: totrans-split-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*删除代码非常风险，通常你永远不知道它是否被使用，以及是否有人依赖于这个确切的行为在实际中*。没错，这就是为什么我主张使用静态分析工具删除从未调用的代码，这样你就可以*确切*知道。但是，如果有疑问，还是不要删除为好。我在这里的急躁是虚拟方法，这些方法很难通过静态分析删除（因为整个目的是在运行时选择要调用的确切方法），这些方法通常不能轻易移除。此外，与销售人员、产品经理，甚至用户沟通。大多数时候，如果询问他们是否在使用特定功能或平台，你会迅速得到是或否的答复，然后就知道如何继续进行。我们工程师有时会忘记，与人们进行
    15 分钟的交流可以简化那么多技术工作。'
- en: '*Stick all your code in a LLM and start asking it questions*: As a anti LLM
    person, I must admit that this idea never crossed my mind. However I think it
    might be worth a shot, if you can do that in a legally safe way, ideally fully
    locally, and take everything with a grain a salt. I’m genuinely curious to see
    what answers it comes up with!'
  id: totrans-split-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将所有代码放在一个 LLM 中并开始向它提问*：作为一个反 LLM 的人，我必须承认从未想过这个主意。不过我认为如果可以在法律上安全的方式下完全本地化进行，并以谨慎的态度对待，这个想法可能值得一试。我真的很好奇看看它会得出什么答案！'
- en: '*There are tools that analyze the code and produce diagrams, class relationships
    etc to get an overview of the code*: I never used these tools but that’s a good
    idea and I will definitely try one in the future'
  id: totrans-split-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有工具可以分析代码并生成图表、类关系等，以便全面了解代码的概况*：我从未使用过这些工具，但这是个好主意，将来我一定会试试。'
- en: '*Step 0 should be to add the code in a source control system if that’s not
    the case already*: For sure. I was lucky enough to never encounter that, but heck
    yeah, even the worst source control system is better than no source control system
    at all. And I say this after having had to use Visual Source Safe, the one where
    modifying a file means acquiring an exclusive lock on it, that you then have to
    release manually.'
  id: totrans-split-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*步骤 0 应该是将代码添加到源代码控制系统中（如果还没有的话）*：当然。我很幸运从未遇到过这种情况，但是即便是最糟糕的源代码控制系统也比没有好。我说的是在曾经不得不使用
    Visual Source Safe 后这么说的，这种系统修改文件意味着需要独占锁定它，然后还要手动释放。'
- en: '*Setting up a CI should be step 1*: Fair point, I can totally see this perspective.
    I am quicker locally, but fair.'
  id: totrans-split-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置一个 CI 应该是第一步*：公平的观点，我完全理解这个角度。我在本地的速度更快，但公平。'
- en: '*Don’t be a code beauty queen, just do the fixes you need*: Amen.'
  id: totrans-split-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要成为代码美女，只需做你需要的修复*：Amen.'
- en: '*If you can drop a platform that’s barely used to reduce the combinatorial
    complexity, and that enables you to do major simplifications, go for it*: Absolutely.
    Talk to your sales people and stakeholders and try to convince them. In my case
    it was ancient FreeBSD versions long out of support, I think we used the security
    angle to convince everyone to drop them.'
  id: totrans-split-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果你可以放弃一个几乎不使用的平台以减少组合复杂性，并且这使你能够做出重大简化，那就去做吧*：完全正确。与你的销售人员和利益相关者交流，试图说服他们。在我的案例中，那些长期不再支持的古老FreeBSD版本，我想我们利用安全角度说服了每个人放弃它们。'
- en: '*Reproducible builds*: This topic came up and was quite the debate. Honestly
    I don’t think achieving a fully reproducible build in a typical C++ codebase is
    realistic. The compiler and standard library version alone are a problem since
    they usually are not considered in the build inputs. Achieving a reliable build
    though is definitely realistic. Docker came up on that topic. Now I have used
    Docker in anger since 2013 and I don’t think it brings as much value as people
    generally think it does. But again - if all you can do is get the code building
    inside Docker, it’s better than nothing at all.'
  id: totrans-split-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可重现构建*：这个话题被提了出来，并引起了激烈的辩论。老实说，我认为在典型的C++代码库中实现完全可重现的构建是不现实的。仅仅是编译器和标准库的版本就是一个问题，因为它们通常不被视为构建输入的一部分。但是实现可靠的构建绝对是现实的。在这个话题上提到了Docker。自2013年以来，我一直在愤怒地使用Docker，我认为它没有人们普遍认为的那么有价值。但再次强调
    - 如果你能让代码在Docker中编译通过，总比什么都不做要好。'
- en: '*Git can be instructed to ignore one commit e.g. the one formatting the whole
    codebase so that git blame still works and the history still makes sense*: Fantastic
    advice that I did not know before, so thanks! I’ll definitely try that.'
  id: totrans-split-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Git可以被指示忽略一个提交，例如整个代码库格式化的提交，以便git blame仍然有效，历史记录仍然有意义*：这是我以前不知道的绝佳建议，所以谢谢！我一定会尝试的。'
- en: '*Use the VCS statistics from the history to identify which parts of the codebase
    have the most churn and which ones get usually changed together*: I never tried
    that, it’s an interesting idea, but I also see lots of caveats. Probably worth
    a try?'
  id: totrans-split-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用VCS统计历史记录来识别代码库中变动最大的部分，以及通常一起更改的部分*：我从未尝试过这个方法，这是一个有趣的想法，但我也看到很多注意事项。也许值得一试？'
- en: '*This article applies not only to C++ but also to legacy codebases in other
    languages*: Thank you! I have the most experience in C++, so that was my point
    of view, but I’m glad to hear that. Just skip the C++-specific bits like sanitizers.'
  id: totrans-split-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*这篇文章不仅适用于C++，还适用于其他语言的遗留代码库*：谢谢！我在C++方面有最多的经验，所以那是我的观点，但我很高兴听到这一点。只需跳过与C++特定相关的部分，如代码检查器。'
- en: '*The book ‘Working effectively with Legacy Code’ has good advice*: I don’t
    think I have ever read it from start to finish, so thanks for the recommendation.
    I seem to recall I skimmed it and found it very object-oriented specific with
    lots of OOP design patterns, and that was not helpful to me at the time, but my
    memory is fuzzy.'
  id: totrans-split-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《与遗留代码有效地工作》这本书提供了很好的建议*：我不认为我曾经从头到尾地读过它，所以谢谢你的推荐。我记得我只是粗略地浏览了一下，发现它非常依赖面向对象，有很多面向对象的设计模式，那时对我来说并不有帮助，但我的记忆有些模糊了。'
- en: '*Generally, touch as little as possible, focus on what adds value (actual value,
    like, sales dollars).*: I agree generally (see the point: don’t be beauty queen),
    however in a typical big C++ codebase, the moment you start to examine it under
    the lens of security, you will find lots and lots a security vulnerabilities that
    need fixing. And that does not translate in a financial gain - it’s reducing risk.
    And I find that extremely valuable. Although, some fields are more sensitive than
    others.'
  id: totrans-split-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一般情况下，尽量少触及，专注于增加价值（实际价值，比如销售额）*：我基本同意（参见观点：不要成为美人鱼），但在典型的大型C++代码库中，一旦你从安全的角度审视它，你会发现大量的安全漏洞需要修复。这并不会带来财务收益
    - 它是在降低风险。而我觉得这非常有价值。尽管如此，某些领域比其他领域更敏感。'
- en: 'If you liked this article and you want to support me, and can afford it: [Donate](https://paypal.me/philigaultier?country.x=DE&locale.x=en_US)'
  id: totrans-split-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你喜欢这篇文章并且愿意支持我，并且负担得起的话：[捐赠](https://paypal.me/philigaultier?country.x=DE&locale.x=en_US)
