["```\nCREATE schema audit;\n\nCREATE TABLE audit.logged_actions (\n  schema_name TEXT NOT NULL,\n  table_name TEXT NOT NULL,\n  user_name TEXT,\n  action_tstamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT current_timestamp,\n  action TEXT NOT NULL CHECK (action IN ('I','D','U')),\n  original_data TEXT,\n  new_data TEXT,\n  query TEXT\n);\n```", "```\nCREATE OR REPLACE FUNCTION audit.if_modified_func() RETURNS TRIGGER AS $body$\nBEGIN\n  IF (TG_OP = 'UPDATE') THEN\n    INSERT INTO audit.logged_actions (schema_name,table_name,user_name,action,original_data,new_data,query)\n    VALUES (TG_TABLE_SCHEMA::TEXT,TG_TABLE_NAME::TEXT,session_user::TEXT,substring(TG_OP,1,1),ROW(OLD.*),ROW(NEW.*),current_query());\n    RETURN NEW;\n  elsif (TG_OP = 'DELETE') THEN\n    INSERT INTO audit.logged_actions (schema_name,table_name,user_name,action,original_data,query)\n    VALUES (TG_TABLE_SCHEMA::TEXT,TG_TABLE_NAME::TEXT,session_user::TEXT,substring(TG_OP,1,1),ROW(OLD.*),current_query());\n    RETURN OLD;\n  elsif (TG_OP = 'INSERT') THEN\n    INSERT INTO audit.logged_actions (schema_name,table_name,user_name,action,new_data,query)\n    VALUES (TG_TABLE_SCHEMA::TEXT,TG_TABLE_NAME::TEXT,session_user::TEXT,substring(TG_OP,1,1),ROW(NEW.*),current_query());\n    RETURN NEW;\n  END IF;\nEND;\n$body$\nLANGUAGE plpgsql;\n\nCREATE TRIGGER my_table_if_modified_trigger\nAFTER INSERT OR UPDATE OR DELETE ON my_table\nFOR EACH ROW EXECUTE PROCEDURE if_modified_func();\n```", "```\nINSERT INTO my_table(x,y) VALUES (1, 2);\nSELECT * FROM audit.logged_actions;\n```", "```\nCREATE OR REPLACE FUNCTION if_modified_func() RETURNS TRIGGER AS $body$\nBEGIN\n  IF (TG_OP = 'UPDATE') THEN\n    PEFORM pg_notify('data_changes', json_build_object(\n      'schema_name', TG_TABLE_SCHEMA::TEXT,\n      'table_name', TG_TABLE_NAME::TEXT,\n      'user_name', session_user::TEXT,\n      'action', substring(TG_OP,1,1),\n      'original_data', jsonb_build(OLD),\n      'new_data', jsonb_build(NEW)\n    )::TEXT);\n    RETURN NEW;\n  elsif (TG_OP = 'DELETE') THEN\n    PEFORM pg_notify('data_changes', json_build_object(\n      'schema_name', TG_TABLE_SCHEMA::TEXT,\n      'table_name', TG_TABLE_NAME::TEXT,\n      'user_name', session_user::TEXT,\n      'action', substring(TG_OP,1,1),\n      'original_data', jsonb_build(OLD)\n    )::TEXT);\n    RETURN OLD;\n  elsif (TG_OP = 'INSERT') THEN\n    PEFORM pg_notify('data_changes', json_build_object(\n      'schema_name', TG_TABLE_SCHEMA::TEXT,\n      'table_name', TG_TABLE_NAME::TEXT,\n      'user_name', session_user::TEXT,\n      'action', substring(TG_OP,1,1),\n      'new_data', jsonb_build(NEW)\n    )::TEXT);\n    RETURN NEW;\n  END IF;\nEND;\n$body$\nLANGUAGE plpgsql;\n\nCREATE TRIGGER my_table_if_modified_trigger\nAFTER INSERT OR UPDATE OR DELETE ON my_table\nFOR EACH ROW EXECUTE PROCEDURE if_modified_func();\n```", "```\nLISTEN data_changes;\n```", "```\nclass User < ApplicationRecord\n  after_commit :track_data_changes\n\n  private\n\n  def track_data_changes\n    AuditRecord.create!(auditable: self, changes: changes)\n  end\nend\n```", "```\nCREATE PUBLICATION my_publication FOR ALL TABLES;\n```", "```\nSELECT * FROM pg_create_logical_replication_slot('my_replication_slot', 'wal2json')\n```", "```\nSELECT * FROM pg_logical_slot_get_changes('my_replication_slot', NULL, NULL)\n```", "```\nCREATE OR REPLACE FUNCTION if_modified_func() RETURNS TRIGGER AS $body$\nBEGIN\n  PERFORM pg_logical_emit_message(true, 'my_message', 'ADDITIONAL_CONTEXT');\n\n  IF (TG_OP = 'DELETE') THEN\n    RETURN OLD;\n  ELSE\n    RETURN NEW;\n  END IF;\nEND;\n$body$\nLANGUAGE plpgsql;\n\nCREATE TRIGGER my_table_if_modified_trigger\nAFTER INSERT OR UPDATE OR DELETE ON my_table\nFOR EACH ROW EXECUTE PROCEDURE if_modified_func();\n```", "```\nimport { setContext } from \"@bemi-db/prisma\";\nimport express, { Request } from \"express\";\n\nconst app = express();\n\napp.use(\n  // Customizable context\n  setContext((req: Request) => ({\n    userId: req.user?.id,\n    endpoint: req.url,\n    params: req.body,\n  }))\n);\n```"]