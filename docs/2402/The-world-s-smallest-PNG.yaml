- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:34:10'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: The world's smallest PNG
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://evanhahn.com/worlds-smallest-png/](https://evanhahn.com/worlds-smallest-png/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <main class="content-page">
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: The world's smallest PNG
  id: totrans-split-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: by [Evan Hahn](/)
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: ', updated'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: Jan 21, 2024
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: (originally posted
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Jan 4, 2024
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: 'The smallest PNG file is 67 bytes. It’s a single black pixel. Here’s what it
    looks like, zoomed in 200×:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: '![A single black pixel.](img/d5beb8f4f56c3c6b2f3420d6d28cd29f.png)'
  id: totrans-split-15
  prefs: []
  type: TYPE_IMG
- en: Wow, what a beauty.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: 'This file has four sections:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The PNG signature, the same for every PNG: 8 bytes'
  id: totrans-split-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The image’s metadata, which includes its dimensions: 25 bytes'
  id: totrans-split-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The image’s pixel data: 22 bytes'
  id: totrans-split-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An “end of image” marker: 12 bytes'
  id: totrans-split-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of this post describes this file in more detail and tries to explain
    how PNGs work along the way.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: There’s a big twist at the end, if that excites you. But I hope you’re just
    excited to learn about PNGs.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 1: the PNG signature'
  id: totrans-split-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every single PNG, including this one, starts with the same 8 bytes. Encoded
    in hex, those bytes are:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-26
  prefs: []
  type: TYPE_PRE
- en: This is called the [**PNG signature**](https://www.w3.org/TR/2022/WD-png-3-20221025/#5PNG-file-signature).
    Try doing a hex dump on any PNG and you’ll see that it starts with these bytes.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: PNG decoders use the signature to ensure that they’re reading a PNG image. Typically,
    they reject the file if it doesn’t start with the signature. Data can get corrupted
    in various ways (ever had a file with the wrong extension?) and this helps address
    that.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Fun fact: if you decode these bytes as ASCII, you’ll see the letters “PNG”
    in there:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-30
  prefs: []
  type: TYPE_PRE
- en: 'So that’s the first 8 bytes. One part done! Here’s our “checklist”:'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: ~~PNG signature~~
  id: totrans-split-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Image metadata chunk
  id: totrans-split-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pixel data chunk
  id: totrans-split-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “End of image” chunk
  id: totrans-split-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What about the rest?
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the PNG is the image metadata, which is one of several **chunks**.
    What’s a chunk?
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: Quick intro to chunks
  id: totrans-split-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other than the PNG signature at the start, PNGs are made up of chunks.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Chunks have two logical pieces: a **type** and some **data bytes**. Types are
    things like “image header” or “text metadata”. The data depends on the type—the
    text metadata chunk is encoded differently from the image header chunk.'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: 'These logical pieces are encoded with [four fields](https://www.w3.org/TR/2022/WD-png-3-20221025/#5Chunk-layout).
    These fields are always in the same order for every chunk. They are:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: '**Length**: the number of bytes in the chunk’s data field (field #3 below).
    Encoded as a 4-byte integer.'
  id: totrans-split-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Chunk type**: the type of chunk this is. There are lots of different chunk
    types. Encoded as a 4-byte ASCII string, such as “IHDR” for “image header” or
    “tEXt” for “text metadata”.'
  id: totrans-split-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data**: the data for the chunk. See the “length” field for how many bytes
    there will be. Varies based on the chunk type. For example, the IHDR chunk encodes
    the image’s dimensions. May be empty, but usually isn’t.'
  id: totrans-split-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Checksum**: a checksum for the rest of the chunk, to make sure no data was
    corrupted. 4 bytes.'
  id: totrans-split-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, each chunk is a minimum of 12 bytes long (4 for the length,
    4 for the type, and 4 for the checksum).
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: Note that the “length” field is the size of the “data” field, *not* the entire
    chunk. If you want to know the whole size of the chunk, just add 12—4 bytes for
    the length, 4 bytes for the type, and 4 bytes for the checksum.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: You have some wiggle room but chunks have a specific order. For example, the
    image metadata chunk has to appear before the pixel data chunk. Once you reach
    the “image is done” chunk, the PNG is done.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: Our tiny PNG will have just three of these chunks.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: The first chunk of every PNG, including ours, is of type **IHDR**, short for
    [“image header”](https://www.w3.org/TR/2022/WD-png-3-20221025/#11IHDR).
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: Each chunk starts with the **length** of the data in that chunk.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: 'The IHDR chunk always has 13 bytes of associated data, as we’ll see in a moment.
    13 is `0D` in hex, which gets encoded like this:'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-53
  prefs: []
  type: TYPE_PRE
- en: 'The **chunk type** is next. This is another four bytes. “IHDR” is encoded as:'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
- en: This is just ASCII encoding. Chunk types are made up of ASCII letters. [The
    capitalization of each letter is significant.](https://www.w3.org/TR/2022/WD-png-3-20221025/#5Chunk-naming-conventions)
    For example, the first letter is capitalized which means it’s a required chunk.
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the chunk’s **data**. IHDR’s data happens to be 13 total bytes, arranged
    as follows:'
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: The first eight bytes encode the image’s width and height. Because this is a
    1×1 image, that’s encoded as `00 00 00 01 00 00 00 01`.
  id: totrans-split-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two bytes are the [bit depth](https://www.w3.org/TR/2022/WD-png-3-20221025/#3bitDepth)
    and [color type](https://www.w3.org/TR/2022/WD-png-3-20221025/#6Colour-values).
  id: totrans-split-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These values are probably the most confusing part of this PNG.
  id: totrans-split-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are five possible color types. Our image is black-and-white so we use
    the “greyscale” color type (encoded as `00`). If our image had color, we might
    use the “truecolor” type (encoded with `02`). There are three other color types
    which we don’t need today, but you can [read more about them in the PNG specification](https://www.w3.org/TR/2022/WD-png-3-20221025/#4Concepts.PNGImage).
  id: totrans-split-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you’ve picked a color type, you need to pick a bit depth. The bit depth
    depends on the color type, but usually means the number of bits per color channel
    in an image. For example, hex colors like `#FE9802` have a bit depth of eight—eight
    bits for red, eight bits for green, and eight bits for blue. Our all-black image
    doesn’t need all that&mldr;we only need *one* bit! The pixel is either completely
    black (`0`) or completely white (`1`)—in our case, it’s completely black.
  id: totrans-split-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we picked a more “expressive” color type and bit depth, we could make the
    same 1×1 image visually, but the file could be bigger because there could be more
    bits per pixel that we don’t actually need. For example, if we used the “truecolor”
    type and 16 bits per channel, each pixel would require 48 bits instead of just
    one—not necessary to encode “completely black”.
  id: totrans-split-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With bit depth of 1 and a color type of 0, we encode these two values with `00
    01`.
  id: totrans-split-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next byte is the [compression method](https://www.w3.org/TR/2022/WD-png-3-20221025/#10CompressionCM0).
    All PNGs set this to `00` for now. This is here just in case they want to add
    another compression method later. As far as I know, nobody has.
  id: totrans-split-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same story for the [filter method](https://www.w3.org/TR/2022/WD-png-3-20221025/#3filter).
    It’s always `00`.
  id: totrans-split-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last part of the chunk’s data is the [interlace method](https://www.w3.org/TR/2022/WD-png-3-20221025/#8InterlaceMethods).
    PNGs support progressive decoding which allows images to be partly rendered as
    they download. We aren’t going to use that feature so we set this to `00`.
  id: totrans-split-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, every chunk ends with a four-byte **checksum**. It uses [a common
    checksum function](https://www.w3.org/TR/2022/WD-png-3-20221025/#5CRC-algorithm)
    called CRC32, and uses the rest of the chunk as an input. Computing that checksum
    gives us the following bytes:'
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-69
  prefs: []
  type: TYPE_PRE
- en: 'All together, here’s the whole IHDR chunk:'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: '| Bytes | What? |'
  id: totrans-split-71
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-split-72
  prefs: []
  type: TYPE_TB
- en: '| `00 00 00 0D` | data length of 13 bytes |'
  id: totrans-split-73
  prefs: []
  type: TYPE_TB
- en: '| `49 48 44 52` | “IHDR” as ASCII |'
  id: totrans-split-74
  prefs: []
  type: TYPE_TB
- en: '| `00 00 00 01` | width |'
  id: totrans-split-75
  prefs: []
  type: TYPE_TB
- en: '| `00 00 00 01` | height |'
  id: totrans-split-76
  prefs: []
  type: TYPE_TB
- en: '| `01` | bit depth |'
  id: totrans-split-77
  prefs: []
  type: TYPE_TB
- en: '| `00` | color type |'
  id: totrans-split-78
  prefs: []
  type: TYPE_TB
- en: '| `00` | compression method |'
  id: totrans-split-79
  prefs: []
  type: TYPE_TB
- en: '| `00` | filter method |'
  id: totrans-split-80
  prefs: []
  type: TYPE_TB
- en: '| `00` | interlace method |'
  id: totrans-split-81
  prefs: []
  type: TYPE_TB
- en: '| `37 6E F9 24` | checksum |'
  id: totrans-split-82
  prefs: []
  type: TYPE_TB
- en: 'So that’s our first chunk! Let’s take another look at our checklist:'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: ~~PNG signature~~
  id: totrans-split-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ~~Image metadata chunk~~
  id: totrans-split-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pixel data chunk
  id: totrans-split-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “End of image” chunk
  id: totrans-split-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two more chunks to go—pixel data is next.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: pixel data chunk'
  id: totrans-split-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next chunk is **IDAT**, short for [“image data”](https://www.w3.org/TR/2022/WD-png-3-20221025/#11IDAT).
    This is where the actual pixels are encoded&mldr;or just one pixel, in our case.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that each chunk has four parts: the data’s *length*, the *chunk type*,
    the *data*, and a *checksum*.'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: 'This chunk will have 10 bytes of data. We’ll talk about *what* that data is
    shortly, but I promise it’s 10 bytes. Let’s encode that length:'
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-93
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s encode “IDAT” for the chunk type:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-95
  prefs: []
  type: TYPE_PRE
- en: Again, this is just ASCII, and I’m showing the hex-encoded values.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the interesting part: the image data.'
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
- en: 'First step: uncompressed pixels'
  id: totrans-split-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Image data is encoded in a series of [“scanlines”](https://www.w3.org/TR/2022/WD-png-3-20221025/#3scanline),
    and then compressed.
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
- en: A scanline represents a horizontal line of pixels. For example, a 123×456 image
    has 456 scanlines. In our case, we have just one scanline, because our image is
    just one pixel tall.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
- en: Scanlines start with something called a [filter type](https://www.w3.org/TR/2022/WD-png-3-20221025/#9Filter-types)
    which can improve compression, depending on your image. Our image is so small
    that this is irrelevant, so we use filter type 0, or “None”.
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
- en: After the filter type, each pixel is encoded with one or more bits, depending
    on the bit depth. In our case, we just need one bit per pixel—recall that we have
    a bit depth of 1; all black or all white.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
- en: If your pixel data doesn’t line up with a byte boundary—in other words, if it’s
    not a multiple of 8 bits—you pad the end of your scanline with zeroes. That’s
    true in our case, so we add seven padding bits to fill out a byte.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting that together (a zero byte to start the scanline, the single zero bit,
    and seven zero padding bits), our single scanline is:'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-105
  prefs: []
  type: TYPE_PRE
- en: Now it’s time to “compress” the data.
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Second step: “compression”'
  id: totrans-split-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we compress the scanline data&mldr;well, not quite.
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
- en: More accurately, we run it through a compression algorithm. Most of the time,
    compression algorithms produce smaller outputs—that’s the whole point! But sometimes,
    “compressing” tiny inputs actually produces *bigger* outputs because of some small
    overhead. Unfortunately for us, that’s what happens here. But the PNG file format
    makes us do it.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
- en: PNG image data is encoded in [the zlib format](https://www.rfc-editor.org/rfc/rfc1950)
    using the [DEFLATE compression algorithm](https://zlib.net/feldspar.html). DEFLATE
    is also used with [gzip](https://en.wikipedia.org/wiki/Gzip) and [ZIP](https://en.wikipedia.org/wiki/ZIP_(file_format)),
    two very popular compression formats.
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
- en: I won’t go in depth on DEFLATE here (in part because I am not an expert^(),
    but here’s what our chunk’s data contains:)
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
- en: 'The zlib header: 2 bytes'
  id: totrans-split-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One compressed DEFLATE block that encodes two literal zeroes^(: 4 bytes)'
  id: totrans-split-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The zlib checksum (this is separate from the PNG chunk checksum!): 4 bytes'
  id: totrans-split-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For more on how DEFLATE works, check out [“An Explanation of the DEFLATE Algorithm”](https://zlib.net/feldspar.html).
    I also recommend [infgen](https://github.com/madler/infgen/), a useful tool for
    inspecting DEFLATE streams.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
- en: 'All together, here are the ten data bytes:'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-117
  prefs: []
  type: TYPE_PRE
- en: Again, unfortunate that we had to run our two-byte scanline through an algorithm
    that made it *five times bigger*, but PNG makes us do it!
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
- en: With that, we can compute the PNG’s checksum field and finish off the chunk.
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
- en: '| Bytes | What? |'
  id: totrans-split-120
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-split-121
  prefs: []
  type: TYPE_TB
- en: '| `00 00 00 0A` | data length of 10 bytes |'
  id: totrans-split-122
  prefs: []
  type: TYPE_TB
- en: '| `49 44 41 54` | “IDAT” as ASCII |'
  id: totrans-split-123
  prefs: []
  type: TYPE_TB
- en: '| `78 01` | zlib header |'
  id: totrans-split-124
  prefs: []
  type: TYPE_TB
- en: '| `63 60 00 00` | “compressed” DEFLATE block |'
  id: totrans-split-125
  prefs: []
  type: TYPE_TB
- en: '| `00 02 00 01` | zlib checksum |'
  id: totrans-split-126
  prefs: []
  type: TYPE_TB
- en: '| `73 75 01 18` | chunk checksum |'
  id: totrans-split-127
  prefs: []
  type: TYPE_TB
- en: 'Just one more chunk to go! Taking a final look at our checklist before everything
    is crossed off:'
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
- en: ~~PNG signature~~
  id: totrans-split-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ~~Image metadata chunk~~
  id: totrans-split-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ~~Pixel data chunk~~
  id: totrans-split-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “End of image” chunk
  id: totrans-split-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s finish this up.
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: the end'
  id: totrans-split-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Poetically, PNGs end like they begin: with a small number of constant bytes.'
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
- en: '**IEND** is the final chunk, short for [“image trailer”](https://www.w3.org/TR/2022/WD-png-3-20221025/#11IEND).'
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The zero length is encoded with 4 zeroes:'
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-138
  prefs: []
  type: TYPE_PRE
- en: '“IEND” is then encoded:'
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-140
  prefs: []
  type: TYPE_PRE
- en: 'There’s no data in IEND chunks, so we just move onto the checksum. Because
    everything else in the chunk is constant, this checksum is always the same:'
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-142
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the whole trailer chunk:'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
- en: '| Bytes | What? |'
  id: totrans-split-144
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-split-145
  prefs: []
  type: TYPE_TB
- en: '| `00 00 00 00` | data length of 0 |'
  id: totrans-split-146
  prefs: []
  type: TYPE_TB
- en: '| `49 45 4E 44` | “IEND” as ASCII |'
  id: totrans-split-147
  prefs: []
  type: TYPE_TB
- en: '| `AE 42 60 82` | checksum |'
  id: totrans-split-148
  prefs: []
  type: TYPE_TB
- en: And our PNG is done!
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
- en: Admiring our work
  id: totrans-split-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here it is one more time, scaled up 200×:'
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
- en: '![A single black pixel.](img/d5beb8f4f56c3c6b2f3420d6d28cd29f.png)'
  id: totrans-split-152
  prefs: []
  type: TYPE_IMG
- en: Beautiful. It starts with the classic PNG signature, follows up with a bit of
    metadata, “compresses” the pixel data, and signs off with an empty chunk.
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
- en: And that’s the world’s smallest PNG!
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
- en: '&mldr;or is it?'
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The twist: there are lots of champions'
  id: totrans-split-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this post, I’ve said that this is the world’s smallest PNG. But
    that’s not quite true: it’s *tied* for first. There are several “world’s smallest
    PNGs”!'
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
- en: '*As long as we encode all pixel data in a single byte, we can tie for the world’s
    smallest PNG.*'
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could encode this 8×1 black image, which is also 67 bytes:'
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
- en: '![A black rectangle, 8 pixels wide and 1 pixel tall.](img/b95743e9e2abd57ea0ef739103e429ff.png)'
  id: totrans-split-160
  prefs: []
  type: TYPE_IMG
- en: This works because we use all eight bits are used to encode pixel data.
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
- en: 'With our 1×1 image, recall that seven bits were effectively “wasted” on padding.
    Here’s basically what happened:'
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
- en: '| Bits | What? |'
  id: totrans-split-163
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-split-164
  prefs: []
  type: TYPE_TB
- en: '| `0` | a black pixel |'
  id: totrans-split-165
  prefs: []
  type: TYPE_TB
- en: '| `0000000` | padding |'
  id: totrans-split-166
  prefs: []
  type: TYPE_TB
- en: 'An 8×1 image can encode eight black pixels like so:'
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
- en: '| Bits | What? |'
  id: totrans-split-168
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-split-169
  prefs: []
  type: TYPE_TB
- en: '| `00000000` | eight black pixels |'
  id: totrans-split-170
  prefs: []
  type: TYPE_TB
- en: 'Instead of adding more pixels, you could also add more color resolution. Many
    grey colors can be encoded in a single byte, letting us tie for first. For example,
    this 1×1 grey pixel is also 67 bytes:'
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
- en: '![A single grey pixel.](img/ce106dba64972531222763ae1a52ed9a.png)'
  id: totrans-split-172
  prefs: []
  type: TYPE_IMG
- en: Again, this “uses up” the whole byte we have available, unlike our 1×1 image.
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on this, my former coworker Jordan Rose published [“The Biggest Smallest
    PNG”](https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/) in response
    to this post. It shows the biggest 67-byte PNG: a 1×2064 black line.'
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-split-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PNGs start with a “signature”. The rest of the file is made up of chunks. Each
    chunk has a length, type, data, and checksum. Some chunks are always required,
    like the image header (IHDR) chunk.
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
- en: The smallest PNGs use the minimum number of chunks and the smallest possible
    data.
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Our PNGs are made up of four parts:'
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
- en: The constant PNG signature (8 bytes)
  id: totrans-split-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IHDR chunk, containing metadata (25 bytes)
  id: totrans-split-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IDAT chunk, image pixel data (22 bytes)
  id: totrans-split-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IEND chunk, an image trailer (12 bytes)
  id: totrans-split-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’re interested in learning more about PNGs interactively, I built [PNG
    Chunk Explorer](https://evanhahn.gitlab.io/png-explorer/), which lets you analyze
    PNGs. Try uploading your own images to see what they’re made of! (It doesn’t work
    well on mobile, apologies.)
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
- en: I also built [Single Color Image](https://singlecolorimage.com/), which generates
    monochromatic PNGs of arbitrary sizes. For example, you could generate a 12×34
    purple rectangle. The images should be small but I haven’t yet implemented the
    most sophisticated compression, so you might need to run its results through a
    PNG compressor to achieve the smallest sizes.
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I also wrote about the [*largest* possible PNG](/largest-possible-png/).
    There’s no theoretical file size limit, but there is a maximum number of pixels,
    and many decoders impose various limits.
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
- en: I hope this long post has given you a good understanding of the PNG file format.
    If you read this far and have anything to say, [let me know](/contact/)!
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
- en: </main>
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
