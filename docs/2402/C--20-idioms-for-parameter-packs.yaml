- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-29 13:25:38'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-29 13:25:38
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: C++20 idioms for parameter packs
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++20 中的参数包习惯
- en: 来源：[https://www.scs.stanford.edu/~dm/blog/param-pack.html](https://www.scs.stanford.edu/~dm/blog/param-pack.html)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://www.scs.stanford.edu/~dm/blog/param-pack.html](https://www.scs.stanford.edu/~dm/blog/param-pack.html)
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: C++11 introduced [variadic templates](https://timsong-cpp.github.io/cppwp/n4868/temp.variadic),
    which permit type-safe functions to accept a variable number of arguments. They
    also permit template types such as [`std::tuple`](https://en.cppreference.com/w/cpp/utility/tuple)
    that can hold a variable number of elements. The main language mechanism enabling
    variadic templates is [*parameter packs*](https://en.cppreference.com/w/cpp/language/parameter_pack),
    which hold an arbitrary number of values or types. Some things are easy to do
    with parameter packs—for instance, passing the values they comprise to a function.
    Other tasks are a bit trickier to accomplish, such as iterating over a parameter
    pack or extracting specific elements. However, these things can generally be accomplished
    through various idioms, some more unwieldy than others.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 引入了[可变模板](https://timsong-cpp.github.io/cppwp/n4868/temp.variadic)，允许类型安全的函数接受可变数量的参数。它们还允许像[`std::tuple`](https://en.cppreference.com/w/cpp/utility/tuple)这样的模板类型，它可以容纳可变数量的元素。启用可变模板的主要语言机制是[*参数包*](https://en.cppreference.com/w/cpp/language/parameter_pack)，它包含任意数量的值或类型。使用参数包可以轻松完成一些任务，例如将它们包含的值传递给函数。其他任务则有点棘手，例如迭代参数包或提取特定元素。但是，通过各种习惯用法通常可以完成这些任务，有些比其他习惯用法更笨拙。
- en: Between C++11 and C++20, the language gained several improvements to variadic
    templates. Improvements to other features, such as concepts and lambdas, have
    also created new options for manipulating parameter packs, thereby enabling new
    variadic template idioms. This post lays out a grab-bag of techniques for using
    parameter packs in C++20\. Ideally, cataloging these tricks makes it easier for
    people to do what they need with variadic templates. My interest in producing
    a clean C++20-focused exposition stems from a conjecture that variadic templates
    are easier to learn to use without the baggage of how we used to do things in
    C++17 and earlier. Moreover, even if a lot of the idioms are obvious at a high
    level, they provide a good context in which to showcase some of the new features
    of C++20.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 和 C++20 之间，语言对可变模板进行了多项改进。对其他功能的改进，例如概念和 lambda，还为操作参数包提供了新选项，从而使新的可变模板习惯成为可能。本文介绍了一系列用于在
    C++20 中使用参数包的技术。理想情况下，对这些技巧进行分类使人们更容易使用可变模板。我对生成一个干净的 C++20 重点阐述感兴趣，这源于一个猜想，即可变模板在没有
    C++17 和更早版本中的负担的情况下学习使用更容易。此外，即使许多习惯用法在高层次上是显而易见的，它们也提供了一个很好的背景，以展示 C++20 的一些新特性。
- en: Overview of variadic templates
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变模板概述
- en: 'A variadic template is a template whose definition captures a *parameter pack*
    in its template arguments or function arguments. A parameter pack is captured
    by introducing an identifier prefixed by an ellipsis, as in `...X`. Once captured,
    a parameter pack can later be used in a *pattern* expanded by an ellipsis (generally,
    but not always, to the right of the pattern). Pack expansion is conceptually equivalent
    to having one copy of the pattern for each element of the parameter pack. Here’s
    a silly example of a program that prints “`one two` ”:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可变模板是一种模板，其定义在其模板参数或函数参数中捕获*参数包*。通过引入以省略号为前缀的标识符来捕获参数包，例如 `...X`。一旦捕获，参数包可以稍后在由省略号扩展的*模式*中使用（通常但不总是在模式的右侧）。参数包展开在概念上等同于为参数包的每个元素拥有一个模式副本。这里有一个愚蠢的程序示例，打印“`one
    two`”：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `print_strings` function takes an arbitrary number of arguments, all of
    which are captured by the parameter pack `...s` in line 2\. In line 4, this parameter
    pack is expanded as `s...` to specify the values from which to construct an `initializer_list`.
    We then iterate over the `initializer_list` to print the strings.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_strings` 函数接受任意数量的参数，所有这些参数都被第 2 行的参数包 `...s` 捕获。在第 4 行，这个参数包被扩展为 `s...`，以指定构造
    `initializer_list` 的值。然后我们迭代 `initializer_list` 来打印字符串。'
- en: As a reminder, the appearance of the placholder `auto` in the arguments of `print_strings`
    makes `print_strings` an [abbreviated function template](https://timsong-cpp.github.io/cppwp/n4861/dcl.fct#18),
    which introduces an implicit template type parameter for each occurrence of the
    placeholder. The use of `auto&&` as opposed to `auto` or `auto&` is known as a
    [forwarding reference](https://timsong-cpp.github.io/cppwp/n4861/temp.deduct.call#3),
    which can accept both lvalue and rvalue references (a confusing syntax since in
    most contexts postfix `&&` matches only rvalue references). We need the universality
    of a forwarding reference because `"one"` is an lvalue (of type `const char(&)[4]`)
    while `std::string{"two"}` is a prvalue—the former cannot be captured by rvalue
    reference and the latter cannot be captured by non-const lvalue reference. Finally,
    note that the [type-constraint](https://en.cppreference.com/w/cpp/language/constraints)
    [`convertible_to`](https://en.cppreference.com/w/cpp/concepts/convertible_to)
    restricts the types that match the template argument; without this constraint,
    the program would still work, but invocations of `print_strings` with incompatible
    types would create less intuitive error messages and, worse, any overloads of
    the `print_strings` function would cause ambiguity errors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，在 `print_strings` 的参数中出现占位符 `auto` 使 `print_strings` 成为一个[缩写函数模板](https://timsong-cpp.github.io/cppwp/n4861/dcl.fct#18)，为占位符的每次出现引入了一个隐式模板类型参数。使用
    `auto&&` 而不是 `auto` 或 `auto&` 被称为[转发引用](https://timsong-cpp.github.io/cppwp/n4861/temp.deduct.call#3)，它可以接受左值引用和右值引用（这是一个令人困惑的语法，因为在大多数情况下，后缀
    `&&` 只匹配右值引用）。我们需要转发引用的普遍性，因为`"one"`是一个左值（类型为 `const char(&)[4]`），而 `std::string{"two"}`
    是一个 prvalue——前者不能被右值引用捕获，后者不能被非 const 左值引用捕获。最后，注意 [类型约束](https://en.cppreference.com/w/cpp/language/constraints)
    [`convertible_to`](https://en.cppreference.com/w/cpp/concepts/convertible_to)
    限制了与模板参数匹配的类型；没有这个约束，程序仍然可以工作，但是对于不兼容类型的 `print_strings` 调用会生成不太直观的错误消息，更糟糕的是，`print_strings`
    函数的任何重载都会导致模糊错误。
- en: Expanding parameter packs
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**扩展参数包**'
- en: 'A captured parameter pack must be used in a *pattern* that is *expanded* with
    an ellipsis (`...`). A pattern is a set of tokens containing the identifiers of
    one or more parameter packs. When a pattern contains more than one parameter pack,
    all packs must have the same length. This length determines the number of times
    the pattern is conceptually replicated in the expansion, once for each position
    in the expanded pack(s). Here’s a simple example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个捕获的参数包必须在一个*模式*中使用，并用省略号（`...`）*扩展*。模式是包含一个或多个参数包的标识符的一组标记。当一个模式包含多个参数包时，所有包必须具有相同的长度。这个长度决定了模式在扩展中被概念上复制的次数，每个位置在扩展包(s)中都有一次。这里有一个简单的例子：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In line 3, the function `expand` captures a template parameter pack `C` consisting
    of a sequence of zero or more types, all of which must be `char` because of our
    use of the [`std::same_as`](https://en.cppreference.com/w/cpp/concepts/same_as)
    concept. In line 5, we capture a function parameter pack `c` consisting of a sequence
    of values *c*[*i*] each of type *C*[*i*] for the *i*th position in parameter pack
    `C`. (Of course, in this example every *C*[*i*] is `char`.) We then see several
    contexts in which these packs are expanded:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 行，函数 `expand` 捕获一个模板参数包 `C`，它由一系列零个或多个类型组成，这些类型必须
- en: In line 7, `tuple<C...>` expands the pack `C` in a *template-argument-list*,
    while `tpl(c...)` expands `c` in an [*initializer-list*](https://timsong-cpp.github.io/cppwp/n4868/dcl.init.general#nt:initializer-list)
    (which, not to be confused with `std::initializer_list`, is the term in the C++
    grammar for comma-separated lists of expressions passed as arguments to function
    calls and constructors).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 7 行，`tuple<C...>` 在*模板参数列表*中扩展包 `C`，而 `tpl(c...)` 在[*初始化列表*](https://timsong-cpp.github.io/cppwp/n4868/dcl.init.general#nt:initializer-list)中扩展
    `c`（不要与 `std::initializer_list` 混淆，这是 C++ 语法中表示传递给函数调用和构造函数的逗号分隔表达式列表的术语）。
- en: In line 9, we expand the pattern `C(std::toupper(c))` in another initializer
    list. This is an example of a pattern with two packs, `C` and `c`, both of which
    have the same length and are expanded in lockstep. ([`std::toupper`](https://en.cppreference.com/w/cpp/string/byte/toupper)
    returns `int` rather than `char`, so its result requires a cast, though we could
    equivalently have written `char(std::toupper(c))...` in this case.)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 9 行，我们在另一个初始化列表中扩展模式 `C(std::toupper(c))`。这是一个有两个包 `C` 和 `c` 的模式的例子，它们的长度相同，并且以同步方式扩展。([`std::toupper`](https://en.cppreference.com/w/cpp/string/byte/toupper)
    返回的是 `int` 而不是 `char`，所以它的结果需要一个转换，虽然在这种情况下我们可以等效地写成 `char(std::toupper(c))...`。)
- en: In line 10, we again expand `c` in an initializer list.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 10 行，我们再次在初始化列表中扩展 `c`。
- en: 'In most cases, an expanded pattern is conceptually equivalent to a number of
    copies of the pattern equal to the size of the parameter pack. Unless otherwise
    noted, a pattern is expanded by appending an ellipsis (`...`). It is illegal to
    use a captured parameter pack except in a pattern expanded by an ellipsis. Here
    is the list of [contexts](https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#5)
    in which a pattern can be expanded:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，扩展模式在概念上等同于模式的副本数量等于参数包的大小。除非另有说明，否则模式通过附加省略号（`...`）来扩展是非法的。以下是可以扩展模式的[上下文](https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#5)的列表：
- en: In **initializer-lists** (as shown above), including pack expansion in the arguments
    to a function call. Conceptually, such a pack expansion is equivalent to a comma-separated
    list of instances of the pattern.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**初始化列表**（如上所示）中，在函数调用的参数中包含包扩展。概念上，这样的包扩展相当于模式实例的逗号分隔列表。
- en: 'In **base specifier lists**, to specify one base class for each member of a
    type parameter pack, e.g.:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**基类指定符列表**中，为类型参数包的每个成员指定一个基类，例如：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When initializing base classes in a **mem-initializer list** in a class constructor,
    the pack expansion initializes a list of base classes based on a type parameter
    pack:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类构造函数的**成员初始化列表**中初始化基类时，包扩展根据类型参数包初始化一系列基类：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In **template argument lists** as in `std::tuple<C...>`, the pack expands to
    the equivalent of a comma-separated list of template arguments.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**模板参数列表**中，如`std::tuple<C...>`，参数包扩展为等效于逗号分隔的模板参数列表。
- en: In lambda **capture lists**, the pattern expansion is equivalent to a comma-separated
    list of captures. E.g.,
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在lambda的**捕获列表**中，模式展开等同于一个逗号分隔的捕获列表。例如，
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside **function parameters** and **template parameters**, a pack expansion
    behaves like a comma separated list of patterns. An example in function parameters
    is the expansion `C` in the definition of `expand(C...c)`, [above](#expand-5).
    An example in template parameters is the expansion of `T` in `Inner`, here:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**函数参数**和**模板参数**中，包扩展的行为类似于模式的逗号分隔列表。在函数参数中的一个例子是`expand(C...c)`的定义中的扩展`C`，请参见[上文](#expand-5)。在模板参数中的一个例子是这里`Inner`的`T`的扩展：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note how in these these cases, the ellipsis plays double-duty, serving at once
    to expand one parameter pack and capture another. The `...` must always immediately
    precede the identifier of the captured parameter pack. This means the ellipsis
    falls in the middle of the pattern for arrays and function types, rather than
    at the end, but the pattern is still expanded as usual. For example:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，在这些情况下，省略号发挥了双重作用，既用于展开一个参数包又用于捕获另一个参数包。`...`必须始终紧接在捕获的参数包的标识符之前。这意味着省略号位于数组和函数类型的模式中间，而不是末尾，但模式仍然会像往常一样展开。例如：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In a **using declaration**, the pattern conceptually expands to a list of `using`
    declarations.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**using声明**中，该模式在概念上扩展为一系列`using`声明。
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Obviously a `using` pattern is most useful when the method `f` of each base
    class in the pack has a different type signature—otherwise invoking `f` would
    be ambiguous. See [multilambda](#multilambda) for a great use of `using` patterns.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很显然，当基类中每个方法`f`的类型签名不同时，`using`模式是最有用的——否则调用`f`将是模棱两可的。请参见[multilambda](#multilambda)以了解`using`模式的一个很好的用法。
- en: In an **alignment specifier**, the argument must be a single parameter pack
    and the ellipsis goes inside the `alignas` operator. The result is an alignment
    restriction compatible with all the types (if the pack expands to types) or all
    the powers of two (if the pack expands to integer powers of two). In the following
    example, the type `storage<int, void*>` would be aligned to an address compatible
    with both `int` and `void*`. (Note also the expansion `sizeof(T)...` inside braces
    to create a `std::initializer_list<std::size_t>` argument for `std::max`.)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**对齐说明符**中，参数必须是单个参数包，省略号放在`alignas`运算符内。结果是一个与所有类型兼容的对齐限制（如果参数包展开为类型）或所有二的幂次方（如果参数包展开为整数二的幂次方）。在下面的示例中，类型`storage<int,
    void*>`将对齐到既兼容`int`又兼容`void*`的地址。（还请注意，在花括号中展开的`sizeof(T)...`以创建一个`std::initializer_list<std::size_t>`参数用于`std::max`。）
- en: '[PRE8]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The [standard](https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#5.8)
    also allows for pack expansions inside **attribute lists**. However, this feature
    does not apply to any standard attributes, and must be intended for compiler-specific
    ones.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准还允许**属性列表**中存在包扩展。但是，这个特性不适用于任何标准属性，并且必须用于特定于编译器的属性。
- en: 'While a pack expansion mostly behaves like a series of copies of the pattern,
    it is [okay](https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#example-6)
    to have a pack of size zero even when the program wouldn’t otherwise be syntactically
    well formed. For example, while `f(x,)` and `struct MyStruct : {};` are not valid
    C++ syntax, `f(x, pack...)` and `struct MyStruct : Base... {};` are okay even
    with empty parameter packs for `pack` and `Base`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然包扩展在大多数情况下都像是模式的副本系列，但即使在程序在语法上不被合法形成时，也可以有一个大小为零的包。例如，虽然`f(x,)`和`struct
    MyStruct : {};`不是有效的C++语法，但`f(x, pack...)`和`struct MyStruct : Base... {};`即使`pack`和`Base`为空参数包时也是可以的。'
- en: 'A pattern may itself contain an expanded parameter pack, in which case there
    is no need for the inner and outer packs to contain the same number of elements.
    The expansion of the inner pack simply becomes part of the pattern around the
    outer pack. For example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模式本身可能包含一个已展开的参数包，在这种情况下，内部和外部包不需要包含相同数量的元素。内部包的展开只需成为外部包周围的模式的一部分。例如：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is worth noting that a pack expansion is *not* valid outside of the contexts
    listed above. In particular, you cannot expand a free-floating expression (though
    see [folds](#folds) below), and you cannot expand a `case` clause in a `switch`
    statement.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，包扩展在上述列出的上下文之外是*无效的*。特别是，您不能展开一个自由浮动的表达式（虽然请参阅下文的[折叠](#folds)），也不能展开`switch`语句中的`case`子句。
- en: '`sizeof...(pack)`'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`sizeof...(pack)`'
- en: The [`sizeof...` operator](https://timsong-cpp.github.io/cppwp/n4868/expr.sizeof#4)
    returns a `std::size_t` corresponding to the number of elements in a parameter
    pack. While technically considered a pack expansion, it only ever returns a single
    value. Unlike ordinary `sizeof`, the argument to `sizeof...` [must always be](https://timsong-cpp.github.io/cppwp/n4868/expr.unary#general-1)
    parenthesized and consist of a single identifier naming a parameter pack.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sizeof...`操作符](https://timsong-cpp.github.io/cppwp/n4868/expr.sizeof#4)返回一个与参数包中元素数量对应的`std::size_t`。虽然在技术上被认为是一个包扩展，但它只返回一个单一值。与普通的`sizeof`不同，`sizeof...`的参数[必须始终](https://timsong-cpp.github.io/cppwp/n4868/expr.unary#general-1)用括号括起来，并且必须由一个单一标识符命名参数包。'
- en: Folds
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 折叠
- en: 'Another special form of pack expansion is [folds](https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#10),
    introduced in C++17\. Above, we showed a function [`sum`](#sum) that summed a
    set of integers. This function can be implemented far more concisely with a fold:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种特殊形式的包扩展是[C++17](https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#10)中引入的折叠。上面，我们展示了一个函数[`sum`](#sum)，它对一组整数求和。这个函数可以用折叠来实现得更加简洁：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Folds are defined in terms of the grammar rule for a [*cast-expression*](https://timsong-cpp.github.io/cppwp/n4868/expr.cast#nt:cast-expression),
    which is a C++ expression whose outer operators bind at least a tightly (i.e.,
    have [precedence](https://en.cppreference.com/w/cpp/language/operator_precedence)
    at least as high as) the C-style cast operator `(Type) val`. As an example, `&p[5]`
    is a cast-expression, because the left-associative subscript (`[]`) operator binds
    more tightly than a cast, while the right associative address-of operator (`&`)
    has the same precedence as a cast. By contrast, the expression `3*i` is not a
    cast-expression, because binary `*` has lower precedence than a cast. Parenthesizing
    an expression with lower-precedence operators, such as `(3*i)`, makes it into
    a cast-expression.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠是根据[*cast-expression*](https://timsong-cpp.github.io/cppwp/n4868/expr.cast#nt:cast-expression)的语法规则定义的，这是一个C++表达式，其外部运算符至少与C风格的转换操作符`(Type)
    val`一样紧密地绑定。例如，`&p[5]`是一个cast-expression，因为左结合的下标（`[]`）运算符比转换更紧密，而右结合的取址运算符（`&`）与转换具有相同的优先级。相比之下，表达式`3*i`不是cast-expression，因为二元`*`的优先级低于转换。将具有较低优先级的操作符的表达式加括号，例如`(3*i)`，将其转换为cast-expression。
- en: There are four types of fold in C++. In these examples, let `pat` be a cast-expression
    containing one more more unexpanded parameter packs (i.e., a pattern). Let `e`
    be a normal cast-expression without any unexpanded parameter packs. Let *p*[1], …, *p*[*n*]
    be the instances of `pat` corresponding to each element captured by `pat`’s unexpanded
    parameter packs. Let ⊕ stand for any binary operator in the C++ grammar (`.*`,
    `->*`, `*`, `/`, `%`, `+`, `-`, `<<`, `>>`, `<=>`, `<`, `<=`, `>`, `>=`, `==`,
    `!=`, `&`, `^`, `|`, `&&`, `||`, `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`,
    `&=`, `^=`, `|=`, or the comma operator “`,`”).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中有四种折叠类型。在这些例子中，让 `pat` 是包含一个或多个未展开参数包（即模式）的cast-expression。让 `e` 是一个没有任何未展开参数包的普通cast-expression。让
    *p*[1], …, *p*[*n*] 是与由 `pat` 的未展开参数包捕获的每个元素对应的实例。让 ⊕ 代表C++语法中的任何二元运算符（`.*`, `->*`,
    `*`, `/`, `%`, `+`, `-`, `<<`, `>>`, `<=>`, `<`, `<=`, `>`, `>=`, `==`, `!=`,
    `&`, `^`, `|`, `&&`, `||`, `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`,
    `^=`, `|=`，或逗号运算符“`,`”）。
- en: A **binary left fold** has the form `(e`⊕`...`⊕`pat)` and is equivalent to `(((e` ⊕ *p*[1]`)` ⊕ *p*[2]`)` ⊕ ⋯`)` ⊕ *p*[*n*].
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**二元左折叠**的形式为`(e`⊕`...`⊕`pat)`，等同于`(((e` ⊕ *p*[1]`)` ⊕ *p*[2]`)` ⊕ ⋯`)` ⊕ *p*[*n*]。'
- en: A **unary left fold** has the form `(...`⊕`pat)` and is equivalent to `((`*p*[1] ⊕ *p*[2]`)` ⊕ ⋯`)` ⊕ *p*[*n*].
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**一元左折叠**的形式为`(...`⊕`pat)`，等同于`((`*p*[1] ⊕ *p*[2]`)` ⊕ ⋯`)` ⊕ *p*[*n*]。'
- en: A **binary right fold** has the form `(pat`⊕`...`⊕`e)` and is equivalent to
    *p*[1]⊕`(`*p*[2]⊕`(`⋯⊕`(`*p*[*n*]⊕`e)))`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**二元右折叠**的形式为`(pat`⊕`...`⊕`e)`，等同于 *p*[1]⊕`(`*p*[2]⊕`(`⋯⊕`(`*p*[*n*]⊕`e)))`。'
- en: A **unary right fold** has the form `(pat`⊕`...)` and is equivalent to *p*[1]⊕`(`*p*[2]⊕`(`⋯ ⊕ *p*[*n*]`))`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**一元右折叠**的形式为`(pat`⊕`...)`，等同于 *p*[1]⊕`(`*p*[2]⊕`(`⋯ ⊕ *p*[*n*]`)`)。'
- en: Note that parentheses are always required around a fold, regardless of context.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论上下文如何，都需要在折叠周围加括号。
- en: 'When the parameter pack is empty (has size 0), a binary fold is equivalent
    to `e`. A unary fold over an empty parameter pack is only permitted for 3 specific
    binary operators:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数包为空（大小为0）时，二元折叠等同于 `e`。只有对三个特定二元运算符之一进行的空参数包的一元折叠才被允许：
- en: If ⊕ is `&&`, then an empty unary fold is equivalent to `true`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ⊕ 是 `&&`，那么空的一元折叠等同于 `true`。
- en: If ⊕ is `||`, then an empty unary fold is equivalent to `false`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ⊕ 是 `||`，那么空的一元折叠等同于 `false`。
- en: If ⊕ is the comma operator `,`, then an empty unary fold is equivalent to `void()`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ⊕ 是逗号运算符 `,`，那么空的一元折叠等同于 `void()`。
- en: For all other binary operators, a unary fold over an empty parameter pack results
    in an ill-formed program.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他二元运算符，对空参数包的一元折叠将导致程序编译错误。
- en: Capturing parameter packs
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获参数包
- en: 'While parameter packs can be expanded in a variety of places, they can only
    be captured in a much more restricted set of contexts. There’s an appealing proposal
    for [allowing parameter packs in structured bindings](https://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1061r0.html),
    which would simplify a lot of idioms, but as of now there are only three contexts
    in which you can introduce a new pack: template parameter packs, function parameter
    packs, and init-capture packs. In all cases, the ellipsis must appear immediately
    to the left of the identifier capturing the parameter pack (`...X`).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然参数包可以在各种地方展开，但在更为受限制的一组上下文中只能捕获。[允许结构化绑定中的参数包](https://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1061r0.html)是一个诱人的提案，它将简化很多习惯用法，但截至目前，只有三种上下文可以引入新的包：模板参数包、函数参数包和初始化捕获包。在所有情况下，省略号必须立即出现在捕获参数包的标识符的左边（`...X`）。
- en: Template parameter packs
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板参数包
- en: 'Template parameter packs consist of types, templates, and values within the
    angle brackets of a template definition. Any normal template parameter can be
    turned into a pack by prefixing the identifier with an ellipsis. For example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数包由模板定义的尖括号内的类型、模板和值组成。通过在标识符前加上省略号，任何普通模板参数都可以转换为包。例如：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With two exceptions, a template parameter pack must generally be the last entry
    in the template parameter list. The first exception is for function templates,
    where template arguments can be inferred from the function arguments. So long
    as every template parameter following a captured parameter pack can be inferred,
    it is okay for the pack not to be last. The second exception is in template specializations,
    where captured packs may be used in the specialization. For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个例外情况外，模板参数包通常必须是模板参数列表中的最后一个条目。第一个例外情况是对于函数模板，模板参数可以从函数参数中推断出。只要在捕获的参数包后面的每个模板参数都可以被推断出，捕获包不必是最后一个。第二个例外情况是在模板特化中，捕获的包可以用于特化。例如：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A template parameter can also be an expansion of another parameter pack, as
    we saw in the definition of `Inner` [above](#Outer).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数也可以是另一个参数包的扩展，就像我们在[上文](#Outer)中定义`Inner`时看到的那样。
- en: Function parameter packs
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数参数包
- en: 'Function parameter packs consist of values in the argument list of a function.
    We’ve seen examples like `c` in [`expand(C...c)`](#expand-5) and `i` in [`sum(std::convertible_to<int>
    auto ...i)`](#sum2). There’s a big restriction that a function parameter pack
    must either itself be a pack expansion (as in `expand`) or else contain the placeholder
    `auto` (as in `sum`). Otherwise, the program is ill-formed. This is why all the
    examples make heavy use of `std::convertible_to`. The C++ committee [considered](https://wg21.link/p1219r0)
    but [rejected](https://github.com/cplusplus/papers/issues/297) allowing *homogeneous
    variadic function parameters*, which would have permitted the following simpler
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数包由函数的参数列表中的值组成。我们已经见过像 [`expand(C...c)`](#expand-5) 中的 `c` 和 [`sum(std::convertible_to<int>
    auto ...i)`](#sum2) 中的 `i` 这样的例子。有一个很大的限制，即函数参数包必须要么是一个包扩展（如 `expand` 中的情况），要么包含占位符
    `auto`（如 `sum` 中的情况）。否则，程序是非法的。这就是为什么所有的例子都大量使用 `std::convertible_to` 的原因。C++
    委员会[考虑过](https://wg21.link/p1219r0)，但[拒绝了](https://github.com/cplusplus/papers/issues/297)允许*同类可变函数参数*，这将允许以下更简单的代码：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Why not allow the above code? The problem lies in the fact that, for compatibility
    with really old C++, there are [two ways](https://timsong-cpp.github.io/cppwp/n4868/dcl.fct#nt:parameter-declaration-clause)
    of defining a [C-style variadic function](https://en.cppreference.com/w/cpp/language/variadic_arguments)
    function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不允许上面的代码呢？问题在于，为了与真正古老的 C++ 兼容，存在[两种方式](https://timsong-cpp.github.io/cppwp/n4868/dcl.fct#nt:parameter-declaration-clause)来定义[C
    风格的可变参数函数](https://en.cppreference.com/w/cpp/language/variadic_arguments)：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If C++ allowed homogeneous variadic function parameters, there would be an ambiguity
    between the older style of varargs definition above and a template function `printf`
    accepting a homogeneous parameter pack of `const char *` values. The standard
    unfortunately [requires](https://timsong-cpp.github.io/cppwp/n4868/dcl.fct#22)
    that the ambiguity be resolved in favor of the C-style varargs interpretation.
    The proposal to fix this did require an extra `template<>` in front of our definition
    of `sum`, which avoided the ambiguity. Moreover, if you give the parameter pack
    `i` a name, that also avoids any ambiguity. But the proposal lost anyway, so you
    can’t do that.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 C++ 允许同类可变函数参数，那么上面旧风格的 varargs 定义和接受 `const char *` 值的同类参数包的模板函数 `printf`
    之间将存在歧义。标准不幸地[要求](https://timsong-cpp.github.io/cppwp/n4868/dcl.fct#22)解决歧义，而支持
    C 风格的 varargs 解释。修复此问题的提案需要在我们对 `sum` 的定义前面添加一个额外的 `template<>`，以避免歧义。此外，如果给参数包
    `i` 起一个名字，也可以避免任何歧义。但是该提案还是失败了，所以你不能这样做。
- en: 'Is there a workaround for the lack of homogeneous variadic function parameters?
    The following two functions seem like reasonable substitutes for the illegal `f(int
    ...i)`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于缺乏同类可变函数参数的问题，以下两个函数似乎是违规 `f(int ...i)` 的合理替代品：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unfortunately, it is important to realize that neither is quite equivalent.
    When a parameter type is declared `int`, unlike `auto`, it triggers [integer conversion](https://en.cppreference.com/w/c/language/conversion#Integer_conversions).
    A concept such as `same_as` doesn’t change the type inferred by `auto`, it only
    restricts permissible types. Hence, calling `f1(0, sizeof(int))` won’t match the
    above function, because `sizeof(int)` is a `std::size_t`, so the second argument
    type is inferred as `std::size_t`, which fails the constraint test `std::same_as<int>`.
    The invocation `f2(0, sizeof(int))` is okay, but its arguments are of heterogeneous
    type, which means inside `f2` writing code such as `for (int n : { i... })` won’t
    work.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '不幸的是，重要的是要意识到，它们都不是完全等价的。当参数类型被声明为 `int` 时，不像 `auto`，它会触发[整数转换](https://en.cppreference.com/w/c/language/conversion#Integer_conversions)。一个诸如
    `same_as` 的概念并不会改变 `auto` 推断的类型，它只限制了允许的类型。因此，调用 `f1(0, sizeof(int))` 将不匹配上述函数，因为
    `sizeof(int)` 是一个 `std::size_t`，所以第二个参数的类型被推断为 `std::size_t`，它不能通过约束测试 `std::same_as<int>`。调用
    `f2(0, sizeof(int))` 是可以的，但它的参数是异构类型，这意味着在 `f2` 中编写诸如 `for (int n : { i... })`
    这样的代码是行不通的。'
- en: 'A workaround for `f2` is to use a cast in the pattern for expanding `i`, as
    in `for (int n : { int(i)... })`. This solution is perfectly fine for `int`. Unfortunately,
    for types with non-trivial constructors, such as `std::string`, `f2` can lead
    to gratuitous copies. For example, suppose that instead of taking `int`, we have
    a type `Obj`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 `f2` 的一个变通方法是在扩展 `i` 的模式中使用强制转换，如 `for (int n : { int(i)... })`。这种解决方案对于
    `int` 完全没问题。不幸的是，对于具有非平凡构造函数的类型，如 `std::string`，`f2` 可能会导致不必要的拷贝。例如，假设我们不是取 `int`，而是一个类型
    `Obj`：'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you call `good({})` or `good(Obj{})`, you will construct exactly one object
    of type `Obj`. If you call `bad({})`, the program is ill-formed (the compiler
    doesn’t know what type `{}` should be). If you call `bad(Obj{})`, then you will
    construct *two* objects of type `Obj`. First, a temporary will be constructed
    to pass into `bad`. Next, the cast expression in the fold will move-construct
    a second `Obj` object from the first. See the [homogeneous function parameter
    packs](#homogeneous-function-parameter-packs) idiom for a way to work around this
    problem.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用 `good({})` 或 `good(Obj{})`，你将会构造一个类型为 `Obj` 的对象。如果调用 `bad({})`，程序是非法的（编译器不知道
    `{}` 应该是什么类型）。如果调用 `bad(Obj{})`，那么你将会构造*两个*类型为 `Obj` 的对象。首先，将会构造一个临时对象传递给 `bad`。接下来，fold
    中的转换表达式将从第一个对象移动构造第二个 `Obj` 对象。请参阅[同类函数参数包](#homogeneous-function-parameter-packs)习语，以解决这个问题。
- en: Init-capture packs
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化捕获包
- en: 'The simplest way to capture a parameter pack in a lambda expression is simply
    to expand it into a conceptual list of values to capture, as seen [above](#capture-pattern).
    Sometimes, however, you want to capture variables with an explicit initializer.
    For example, if your function parameter pack contains rvalue references, it may
    be more efficient to move-initialize the lambda’s captures than to copy-initialize
    them. You can capture a parameter pack in the capture clause of a lambda by prefixing
    an identifier with an ellipsis. In this case, the initializer must be a pattern
    containing one or more packs (of the same length). Here’s an example that will
    avoid copying any temporary strings passed in as arguments:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获参数包在 lambda 表达式中的最简单方式就是将其展开为要捕获的值的概念列表，如[上文](#capture-pattern)所示。然而，有时候你想要捕获具有显式初始化程序的变量。例如，如果你的函数参数包含右值引用，将
    lambda 的捕获初始化为移动初始化可能比复制初始化更有效。你可以通过在标识符前加上省略号来在 lambda 的捕获子句中捕获参数包。在这种情况下，初始化程序必须是包含一个或多个相同长度的包的模式。以下是一个示例，它将避免复制传入的任何临时字符串作为参数：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Idioms
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惯用法
- en: 'Below is a collection of idioms for working with parameter packs. I place all
    the code in this blog post in the public domain, so feel free to cut and paste.
    To keep things concise, I’ve omitted include files, but the system library features
    used in the examples come from the following set of includes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些处理参数包的惯用语。我将本文中的所有代码放在公共领域中，所以请随意复制粘贴。为了简洁起见，我省略了包含文件，但是示例中使用的系统库特性来自以下包含文件集合：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Recursing over argument lists
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归参数列表
- en: 'The most basic variadic template idiom, probably already known to most people
    reading this blog post, is to iterate over the argument list recursively, using
    function overloading to differentiate the base case (no arguments) from the recursive
    case (one or more). A silly example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的可变模板惯用语，可能已经为阅读本文的大多数人所熟知的，是通过递归地迭代参数列表，使用函数重载来区分基本情况（无参数）和递归情况（一个或多个）。一个愚蠢的例子：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Of course, since C++17, many uses of recursion are better accomplished with
    folds:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，自从 C++17 以来，许多递归的使用都可以更好地通过折叠来实现：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Recursing over template parameters
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归模板参数
- en: Another common technique is to recurse over template parameters. This can be
    done to consume the elements of a parameter pack, produce elements of a parameter,
    or both. Here’s a simple example in which we recursively produce the arguments
    of a parameter pack. The goal is, at compile time, to produce a string corresponding
    to a number (so that you can safely use the string even in global initializers).
    We recurse over the parameter `N` so long as it is greater than 10, producing
    one digit at a time. Finally, when `N` is less than 10, we return a `char[]` from
    inside the `string_holder` template.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的技术是递归模板参数。这可以用来消耗参数包的元素，产生参数包的元素，或者两者兼而有之。下面是一个简单的例子，我们在其中递归产生参数包的参数。目标是，在编译时生成与数字对应的字符串（这样即使在全局初始化器中也可以安全使用该字符串）。我们对参数
    `N` 进行递归，只要它大于10，就一次产生一个数字。最后，当 `N` 小于 10 时，我们从 `string_holder` 模板内部返回一个 `char[]`。
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you want to consume and produce argument packs recursively, then you need
    to use some kind of holder type so as to accommodate multiple parameter packs
    simultaneously. The `string_holder` type above is an example of such a holder
    type. Suppose we want a function `add_commas` that adds a comma between every
    three characters of a string starting from the right. We can do this by consuming
    the argument pack of one `string_holder` while producing the argument pack of
    another:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要递归地消耗和生成参数包，则需要使用某种 holder 类型来容纳多个参数包。上面的 `string_holder` 类型就是这样一个 holder
    类型的示例。假设我们想要一个函数 `add_commas`，它在字符串中的每三个字符之间从右边开始添加一个逗号。我们可以通过消耗一个 `string_holder`
    的参数包同时生成另一个参数包来实现这一点：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Comma fold
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逗号折叠
- en: 'Often you want to do the same operation to every element in a parameter pack.
    While you can accomplish this by recursing over the parameter pack, it can be
    simpler to use a fold over the [comma operator](https://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator),
    which just sequences one expression after the other. To avoid any strange behavior
    in cases where the program overloads `operator,`, you can cast the expression
    to void. Here’s a simple example of a function that inserts an arbitrary number
    of elements into a container supporting an `insert` method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你想要对参数包中的每个元素执行相同的操作。虽然你可以通过递归参数包来实现这一点，但是使用 [逗号操作符](https://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator)
    的折叠可能更简单，它只是将一个表达式顺序排列在另一个表达式之后。为了避免在程序重载`operator,`的情况下产生任何奇怪的行为，你可以将表达式转换为 void。这里有一个简单的例子，演示了一个将任意数量的元素插入到支持`insert`方法的容器中的函数：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As always, remember that folds must be parenthesized, and that a bare expression
    cannot be expanded as a pattern. Neither of the following alternate function bodies
    for `multi_insert` would compile:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记住，折叠必须要用括号括起来，一个裸表达式不能作为模式进行展开。对于`multi_insert`的以下两个备用函数主体，都不会编译通过：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Short-circuiting `&&` and `||` folds
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短路`&&` 和 `||` 折叠
- en: 'Sometimes you want to iterate over a parameter pack until some condition holds.
    Of course, you can do this with recursion, simply ending the recursion when you
    hit the stop condition. However, the recursive approach can be cumbersome and
    require you to define several functions. As an alternative, you can fold over
    the logical `&&` and `||` operators, which *short-circuit* evaluation and stop
    doing anything the minute the condition is guaranteed to be true or false. Here’s
    an example of a function that finds the index of the first item in a tuple to
    satisfy some arbitrary predicate functor `f`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你想要迭代参数包直到某个条件成立。当然，你可以通过递归来实现这一点，简单地在达到停止条件时结束递归。然而，递归方法可能会很麻烦，并且需要你定义多个函数。作为一种替代方案，你可以通过逻辑
    `&&` 和 `||` 操作符进行折叠，它们会*短路*评估，并且在条件被保证为真或假的情况下立即停止执行任何操作。以下是一个查找元组中满足某个任意谓词函数
    `f` 的第一项的索引的函数示例：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Incidentally, while this has nothing to do with parameter packs, let me gratuitously
    plug C++20’s [safe integer comparison functions](https://en.cppreference.com/w/cpp/utility/intcmp).
    Had our lambda predicate read `return i > -1` instead of `std::cmp_greater(i,
    -1)`, the program would have printed `5`, because [`0U > -1` is false](https://en.cppreference.com/w/c/language/conversion#Integer_conversions).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，虽然这与参数包无关，让我毫无必要地宣传一下 C++20 的 [安全整数比较函数](https://en.cppreference.com/w/cpp/utility/intcmp)。如果我们的
    lambda 谓词写成 `return i > -1` 而不是 `std::cmp_greater(i, -1)`，程序会打印 `5`，因为 [`0U >
    -1` 是 false](https://en.cppreference.com/w/c/language/conversion#Integer_conversions)。
- en: Often the comma operator is handy to execute some action before testing the
    stop condition in a fold over a logical operator. For another example of the technique,
    see [this implementation of `operator<=>`](https://cor3ntin.github.io/posts/tuple/#-nothing-as-futuristic-as-a-spaceship)
    on a tuple-like type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在逻辑运算符的折叠中在测试停止条件之前执行某些操作时，逗号运算符非常方便。关于该技术的另一个示例，请参见 [这个关于 `operator<=>`
    的实现](https://cor3ntin.github.io/posts/tuple/#-nothing-as-futuristic-as-a-spaceship)
    在类似元组的类型上。
- en: Using lambda expressions to capture packs
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式捕获包
- en: While parameter packs can be expanded in many contexts, you sometimes need to
    deconstruct a template type to extract the parameter pack. This can be awkward
    because there are fewer contexts in which to capture a pack. Worst-case scenario,
    this can be done by defining a helper type or function, but this leads to a lot
    of code and exposes the private internals of your implementation. One way to keep
    things more self-contained is with a lambda expression.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然参数包可以在许多上下文中展开，但有时您需要解构模板类型以提取参数包。这可能有些棘手，因为可以捕获包的上下文较少。在最坏的情况下，可以通过定义辅助类型或函数来完成此操作，但这会导致大量代码，并暴露出您实现的私有内部。保持事物更加自包含的一种方法是使用
    lambda 表达式。
- en: Lambdas are particularly helpful in working with [tuples](https://en.cppreference.com/w/cpp/utility/tuple).
    Combining a lambda with `std::apply` lets you capture a parameter pack corresponding
    to the contents of a tuple.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 在使用 [tuples](https://en.cppreference.com/w/cpp/utility/tuple) 时特别有用。将
    lambda 与 `std::apply` 结合使用，让您捕获与元组内容对应的参数包。
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using lambdas to capture parameter packs is especially useful with [`std::integer_sequence<typename
    T, T...>`](https://en.cppreference.com/w/cpp/utility/integer_sequence), a trivial
    type akin to [`string_holder`](#string-holder) above, but for holding an arbitrary
    integer type `T`. Since `std::size_t` is often what you want, the alias `std::index_sequence<T...>`
    is equivalent to `std::integer_sequence<std::size_t, T...>`. To create `std::integer_sequence`
    types, you can use the type alias `std::make_integer_sequence<T, N>` (or the `std::size_t`-specific
    `std::make_index_sequence<N>`) to make an integer sequence containing the numbers
    from `0` through `N-1`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 lambda 捕获参数包对于 [`std::integer_sequence<typename T, T...>`](https://en.cppreference.com/w/cpp/utility/integer_sequence)
    尤其有用，这是一种类似于上面的 [`string_holder`](#string-holder) 的简单类型，但用于保存任意整数类型 `T`。由于通常希望使用
    `std::size_t`，因此别名 `std::index_sequence<T...>` 等同于 `std::integer_sequence<std::size_t,
    T...>`。要创建 `std::integer_sequence` 类型，您可以使用类型别名 `std::make_integer_sequence<T,
    N>`（或特定于 `std::size_t` 的 `std::make_index_sequence<N>`）来创建一个包含从 `0` 到 `N-1` 的数字的整数序列。
- en: 'Suppose you want to add two tuples, element by element. You could use two nested
    lambdas to expand the two tuples in succession, but this would be a bit awkward.
    Instead, you can use `std::make_index_sequence` to get the tuple indices, then
    use the indices in a pattern that accesses the elements of both tuples element
    by element. Here is the code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要逐个元素地添加两个元组。您可以使用两个嵌套的 lambda 依次展开两个元组，但这有点笨拙。相反，您可以使用 `std::make_index_sequence`
    来获取元组索引，然后在一种模式中使用索引访问两个元组的元素。以下是代码：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once again, life is better in C++20 because a lambda expression can have explicit
    type parameters, allowing us to capture the template parameter pack `...I` from
    the inferred `std::index_sequence` type of the function argument.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，在 C++20 中的生活更好，因为 lambda 表达式可以具有显式类型参数，从而允许我们从推断的函数参数的 `std::index_sequence`
    类型中捕获模板参数包 `...I`。
- en: Using lambda expressions to capture packs in requires clauses
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式在 requires 子句中捕获包
- en: You can also use lambdas in requires clauses. Suppose you want to define a [user-defined
    literal](https://en.cppreference.com/w/cpp/language/user_literal) `_hex` to create
    strings from a series of hexadecimal digits specifying bytes. For example, the
    constant `0x48656c6c6f21_hex` should be equivalent to `std::string{"Hello!"}`.
    The C++ standard [says](https://timsong-cpp.github.io/cppwp/n4868/over.literal#5)
    such an operator must be defined as exactly `template<char ...C> operator""_hex()`,
    where the template arguments are the characters of the literal. It might be nice
    to strip the first two characters (`'0'` and `'x'`) from the literal with different
    template parameters, but unfortunately C++ disallows alternate definitions such
    as `template<char Zero, char X, char ...C> operator""_hex()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在 requires 子句中使用 lambda。假设您想要定义一个 [用户定义的字面值](https://en.cppreference.com/w/cpp/language/user_literal)
    `_hex`，以从指定字节的一系列十六进制数字创建字符串。例如，常量 `0x48656c6c6f21_hex` 应等同于 `std::string{"Hello!"}`。C++
    标准 [规定](https://timsong-cpp.github.io/cppwp/n4868/over.literal#5) 这样的操作符必须定义为
    `template<char ...C> operator""_hex()`，其中模板参数是字面值的字符。也许希望使用不同的模板参数剥离字面值的前两个字符（`'0'`
    和 `'x'`），但不幸的是，C++ 禁止了诸如 `template<char Zero, char X, char ...C> operator""_hex()`
    这样的备选定义。
- en: 'Here’s one possible implementation, where we simply create an array from the
    template arguments and iterate over the characters, skipping the first two:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种可能的实现，我们只需从模板参数创建一个数组，然后遍历字符，跳过前两个：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Unfortunately, there are a few problems with this code. First, nothing requires
    the constant to start with `0x`. For example, you could type a decimal constant
    `1234_hex`, and the result would be nonsense (the first two digits skipped). We
    could also feed in a floating point number such as `0xa98.76p0_hex`, which is
    allowed by the language, and we would get nonsense. To prevent this, we could
    maybe sprinkle some `static_assert` statements in the code, but: A) We’d rather
    the `operator""_hex` function simply not match than return confusing errors from
    within the function, or more confusingly still, a helper function, and B) We want
    all *except* the second character (`x`) to be valid hex characters, so a simple
    `&&` fold over all the digits won’t do the right thing.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码存在一些问题。首先，没有什么要求常量以`0x`开头。例如，您可以键入十进制常量`1234_hex`，结果将是无意义的（前两个数字被跳过）。我们也可以输入一个浮点数，例如`0xa98.76p0_hex`，这是语言允许的，我们会得到无意义的结果。为了防止这种情况，我们可以在代码中添加一些`static_assert`语句，但是：A)我们宁愿`operator""_hex`函数根本不匹配，也不要从函数内部返回混乱的错误，或者更令人困惑的是，一个辅助函数，和B)我们希望*除了*第二个字符（`x`）以外的所有字符都是有效的十六进制字符，因此简单的`&&`对所有数字进行折叠不会产生正确的结果。
- en: 'Of course, this could be handled by defining custom helper types and maybe
    a dedicated concept, but a cleaner solution is just to unpack the parameter pack
    with a lambda right in the requires clause:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可以通过定义自定义助手类型和可能的专用概念来处理，但更清洁的解决方案是在要求子句中使用lambda解压参数包：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note how we take advantage of the fact that, as of C++17, lambdas are implicitly
    `constexpr` when possible. Note also that C++20 requires most string operations
    to be `constexpr`, in which case the above function could be `consteval` rather
    than merely `constexpr`. Unfortunately, as of this writing, `constexpr` strings
    aren’t supported by the standard libraries available in common linux distributions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何利用了C++17的事实，即lambda在可能时隐式为`constexpr`。还要注意，C++20要求大多数字符串操作是`constexpr`，在这种情况下，上面的函数可能是`consteval`而不仅仅是`constexpr`。不幸的是，截至本文撰写时，常见Linux发行版中的标准库不支持`constexpr`字符串。
- en: 'By the way, here’s an alternative way of implementing this user-defined literal
    with [`string_holder`](#string-holder) and [`std::make_index_sequence`](#integer-sequence):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这是用[`string_holder`](#string-holder)和[`std::make_index_sequence`](#integer-sequence)实现此用户定义字面量的另一种方法：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using `decltype` on lambda expressions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在lambda表达式上使用`decltype`
- en: 'Sometimes you want to modify the types in a parameter pack in a context where
    it is inconvenient to capture the parameter pack. For instance, suppose you want
    a way to take a `std::tuple` type and generate another type corresponding to pointers
    to the types in the tuple. The brute-force approach would be to introduce helper
    types to leverage partial specialization, but the result is rather unwieldy:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望在不方便捕获参数包的上下文中修改参数包中的类型。例如，假设您想要一种方法，可以接受`std::tuple`类型并生成与元组中类型对应的指针类型。粗暴的方法是引入辅助类型以利用部分特化，但结果相当笨重：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Fortunately, C++20 lets us use lambdas in unevaluated contexts, which means
    that instead of defining helper types, you can often use a lambda expression inside
    of `decltype` to achieve what you want. In this case, we can produce an entirely
    self-contained definition of `tuple_ptrs` as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C++20允许我们在未评估的上下文中使用lambda，这意味着我们可以在`decltype`中使用lambda表达式来实现所需的功能，而不是定义辅助类型。在这种情况下，我们可以按照以下方式生成完全独立的`tuple_ptrs`定义：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Multilambda
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多元lambda
- en: 'Thus far, we’ve been writing generic lambdas in functions like [`tuple_add`](#tuple-add)
    that use overloaded syntax like the `+` operator to add numbers of different types.
    However, what if we want to write different (non-generic) lambdas for different
    types? We can implement a new variadic template type, `multilambda`, that constructs
    a function object comprising multiple lambdas with different type signatures.
    Here’s the implementation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在像[`tuple_add`](#tuple-add)这样的函数中编写通用lambda，使用重载的语法，如`+`运算符来添加不同类型的数字。但是，如果我们想为不同类型编写不同的（非通用的）lambda怎么办？我们可以实现一个新的可变模板类型，`multilambda`，它构造一个包含多个具有不同类型签名的lambda的函数对象。这是实现：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`multilambda` takes a bunch of lambda expressions or other callable objects
    as template parameters and makes them base classes. Then, by expanding the pattern
    `using L::operator()...;`, it brings all of the function call operators into scope,
    so that any of them can be called so long as there is no ambiguity. The final
    thing to note is that we are taking advantage of implicitly-generated [class template
    deduction guides](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)
    so as to construct a `multilambda` without having to supply explicit template
    parameters.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`multilambda`接受一堆lambda表达式或其他可调用对象作为模板参数，并将它们作为基类。然后，通过展开模式`using L::operator()...;`，它将所有函数调用运算符引入作用域，因此只要没有歧义，任何一个都可以被调用。最后需要注意的是，我们利用了隐式生成的[class
    template deduction guides](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)，以便构造一个`multilambda`而无需提供显式模板参数。'
- en: 'Note that you can use `decltype` on `multilambda` to do things concisely that
    would previously have required auxiliary structs for partial specialization. For
    example, here’s a [*concept*](https://en.cppreference.com/w/cpp/language/constraints)
    that checks whether a particular type is an instance of a particular template
    or a reference to an instance of that template:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以在`multilambda`上使用`decltype`来简洁地执行以前可能需要辅助结构进行部分特化的操作。例如，这是一个[*concept*](https://en.cppreference.com/w/cpp/language/constraints)，检查特定类型是否是特定模板的实例或对该模板的引用：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There’s one small issue with multilambda, which is that the copy constructor
    might do a little work to move lambdas into the structure. You can avoid this
    work by eliminating the constructor and directly initializing all of the superclasses,
    using a deduction guide to specify that the template types should be taken from
    the arguments:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 多lambda存在一个小问题，即复制构造函数可能会对lambda进行一些移动结构的工作。通过消除构造函数并直接初始化所有超类，可以避免这种工作，使用推导指南指定模板类型应从参数中获取：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Recursive types through inheritance
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过继承实现递归类型
- en: 'Sometimes you want to define a type that holds a variable number of arguments
    depending on a parameter pack. [`std::tuple`](https://en.cppreference.com/w/cpp/utility/tuple)
    is a good example of such a type. A good way to do this is through inheritance,
    using the derived class to hold one element, and the base class to hold the remaining
    elements. Here’s an example of a “heterogeneous list” with head and tail operations:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您想要定义一个根据参数包包含可变数量参数的类型。[`std::tuple`](https://en.cppreference.com/w/cpp/utility/tuple)就是这样一种类型的好例子。通过继承的方式来实现这一点是一个好方法，使用派生类来持有一个元素，基类来持有其余元素。下面是一个具有头部和尾部操作的“异构列表”的示例：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The basic idiom may already be familiar to the reader, but a few things are
    worth pointing out for people less familiar with C++20 and C++17\. First, note
    the use of the attribute [`[[no_unique_address]]`](https://en.cppreference.com/w/cpp/language/attributes/no_unique_address)
    on [line 14](#hlist-14). Without this attribute, the size of `HList<dummy<0>,
    dummy<1>, dummy<2>>` would be 3 bytes instead of 1 on [line 34](#hlist-34). Why?
    Because C++ requires most objects (other than bit fields) to have a unique address.
    However, there’s long been an exception called the [empty base optimization (EBO)](https://en.cppreference.com/w/cpp/language/ebo).
    Roughly speaking, given the following types:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读者来说，基本习惯可能已经很熟悉了，但对于不太熟悉C++20和C++17的人来说，有几点值得注意。首先，注意在[第14行](#hlist-14)上使用的属性[`[[no_unique_address]]`](https://en.cppreference.com/w/cpp/language/attributes/no_unique_address)。如果没有这个属性，`HList<dummy<0>,
    dummy<1>, dummy<2>>`的大小将会是3字节，而不是[第34行](#hlist-34)上的1字节。为什么？因为C++要求大多数对象（除了位字段之外）具有唯一地址。然而，长期以来已经存在一个叫做[空基类优化（EBO）](https://en.cppreference.com/w/cpp/language/ebo)的例外。粗略地说，给定以下类型：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: EBO states that `Base` need not increase the size of `Derived` so long as the
    first data member in `Derived` doesn’t also start with `Base`. In other words,
    `Base` is allowed to share the same address as any other object not of type `Base`.
    Before C++20, implementers of types such as `std::tuple` jumped through [quite
    a few hoops](https://cor3ntin.github.io/posts/tuple/) to exploit EBO to reduce
    tuple sizes. Now, however, we can use the [`[[no_unique_address]]`](https://en.cppreference.com/w/cpp/language/attributes/no_unique_address)
    attribute to apply the same logic as EBO to any structure field, not just the
    base class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: EBO表示，只要`Derived`中的第一个数据成员不是以`Base`开头，`Base`就不会增加`Derived`的大小。换句话说，`Base`被允许与不是`Base`类型的任何其他对象共享相同的地址。在C++20之前，诸如`std::tuple`之类的类型的实现者需要经过[不少艰辛的努力](https://cor3ntin.github.io/posts/tuple/)才能利用EBO来减小元组的大小。然而，现在，我们可以使用[`[[no_unique_address]]`](https://en.cppreference.com/w/cpp/language/attributes/no_unique_address)属性将相同的逻辑应用于任何结构字段，而不仅仅是基类。
- en: Note that despite this otimization, `HList<dummy<0>, dummy<0>, dummy<0>>` still
    has size 3 bytes, as seen on [line 35](#hlist-35), because each instance of the
    same type `dummy<0>` still needs a unique address. This makes a certain amount
    of sense. For example, the constructor of `dummy<0>` might decide to enter the
    object’s address in some global hash table, so while `dummy<1>` and `dummy<0>`
    would presumably have different hash tables, entering the same address twice into
    `dummy<0>`’s hash table could lead to confusion.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管进行了这种优化，`HList<dummy<0>, dummy<0>, dummy<0>>`的大小仍为3字节，如[第35行](#hlist-35)所示，因为相同类型`dummy<0>`的每个实例仍然需要一个唯一地址。这在某种程度上是有道理的。例如，`dummy<0>`的构造函数可能决定将对象的地址输入到某个全局哈希表中，因此，虽然`dummy<1>`和`dummy<0>`可能会有不同的哈希表，但在`dummy<0>`的哈希表中两次输入相同的地址可能会导致混乱。
- en: Another detail worth noting is the use of a [user-defined deduction guide](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)
    on [line 31](#hlist-31). This allows us to construct an `HList` without explicit
    template parameters, as in `HList{1, 2, 3, "hello"}`. The deduction guide is required
    because `HList::HList` takes arguments by forwarding reference, yet we need to
    make sure to infer non-reference types for the template parameters.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的另一个细节是在[第31行](#hlist-31)使用了[用户定义的推导指南](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)。这使我们能够构建一个`HList`，而无需显式模板参数，就像`HList{1,
    2, 3, "hello"}`一样。推导指南是必需的，因为`HList::HList`通过转发引用接受参数，但我们需要确保推断出模板参数的非引用类型。
- en: '`HList` lets us explore another good example application of [`std::make_index_sequence`](#integer-sequence),
    as well as of our [`is_template`](#is-template) concept above. Suppose we want
    to implement an `apply` function analogous to [`std::apply`](https://en.cppreference.com/w/cpp/utility/apply).
    We can do this by implementing a `get` function, then capturing an integer sequence
    of list indices to expand in `apply`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`HList`让我们探索另一个很好的例子应用[`std::make_index_sequence`](#integer-sequence)，以及上面提到的我们的[`is_template`](#is-template)概念。假设我们想要实现一个类似于[`std::apply`](https://en.cppreference.com/w/cpp/utility/apply)的`apply`函数。我们可以通过实现一个`get`函数，然后捕获一个要在`apply`中展开的列表索引的整数序列来实现这一点：'
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Homogeneous function parameter packs
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同质函数参数包
- en: As [previously mentioned](#homogeneous-intro), it is tricky to emulate a function
    taking a homogeneous variadic parameter pack without introducing extra copies
    of the argument. Suppose you want to implement a function equivalent to the (illegal)
    `good(Obj ...obj)` that accepts a variable number of arguments all of type `Obj`
    by value (meaning modification of the arguments in the function does not affect
    the calling context). We can of course write `good(std::convertible_to<Obj> auto&&
    ...t)`, but now we will capture a heterogeneous set of arguments. Some of these
    arguments may be values from which we need to construct an `Obj`, but others may
    already be an `Obj` constructed specifically for this function, as when someone
    calls `good(Obj{})`. In the latter case, we want to avoid constructing a *second*
    `Obj` from the one that was passed in as an argument. On the other hand, if the
    user called `good(obj)` where `obj` is a variable containing an existing `Obj`,
    then we must copy `obj`, since the call-by-value semantics we want require that
    modifications of argument variables inside `good` do not affect the variables
    passed in.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如[前文提到](#homogeneous-intro)，在不引入额外副本的情况下模拟接受同构可变参数包的函数是棘手的。假设你想要实现一个函数，相当于（非法的）`good(Obj
    ...obj)`，它接受一系列类型为 `Obj` 的参数值（这意味着在函数中修改参数不会影响调用上下文）。当然，我们可以写成 `good(std::convertible_to<Obj>
    auto&& ...t)`，但现在我们将捕获一组异构参数。其中一些参数可能是值，我们需要从中构造一个 `Obj`，但其他参数可能已经是为此函数专门构造的 `Obj`，例如当某人调用
    `good(Obj{})` 时。在后一种情况下，我们希望避免从传入的参数构造*第二个*`Obj`。另一方面，如果用户调用 `good(obj)`，其中 `obj`
    是包含现有 `Obj` 的变量，则我们必须复制 `obj`，因为我们想要的按值传递语义要求在 `good` 内部不影响传入的变量。
- en: 'When a new temporary `Obj` has been constructed as a function call argument,
    the inferred type of the argument will be the rvalue reference `Obj&&`. When an
    existing `obj` is being passed in, the type will be the lvalue reference `Obj&`
    (or possibly `const Obj&`). The trick is to define a function `local_copy` that
    will generate a new `Obj` in the later case, but return a reference to an existing
    temporary `Obj` in the former case. Here is the code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的临时 `Obj` 被构造为函数调用参数时，参数的推断类型将是右值引用 `Obj&&`。当一个现有的 `obj` 被传入时，类型将是左值引用 `Obj&`（或可能是
    `const Obj&`）。关键在于定义一个函数 `local_copy`，在后一种情况下生成一个新的 `Obj`，但在前一种情况下返回对现有临时 `Obj`
    的引用。以下是代码：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To understand the implementation and use of `local_copy`, you need to know
    a bunch of things about [C++ value categories](https://www.scs.stanford.edu/~dm/blog/decltype.html):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 `local_copy` 的实现和用法，您需要了解有关 [C++ 值类别](https://www.scs.stanford.edu/~dm/blog/decltype.html)
    的一些东西：
- en: When a function argument is a [**forwarding reference**](https://timsong-cpp.github.io/cppwp/n4861/temp.deduct.call#3),
    as in `template<typename T> void f(T &&t)`, the type `T` will be an lvalue reference
    (e.g., `Type&`) if `f` was invoked with an lvalue (e.g., some variable `obj`)
    and a non-reference (e.g., `Type`) if `f` was invoked with an rvalue (e.g., `Obj{}`).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当函数参数是一个[**转发引用**](https://timsong-cpp.github.io/cppwp/n4861/temp.deduct.call#3)，例如
    `template<typename T> void f(T &&t)`，如果 `f` 被用左值（例如某个变量 `obj`）调用，类型 `T` 将是一个左值引用（例如，`Type&`），如果
    `f` 被用右值（例如，`Obj{}`）调用，类型 `T` 将是一个非引用类型（例如，`Type`）。
- en: When you take a reference type `TR` and add an rvalue reference, you get back
    `TR`, meaning `TR&&` and `TR` are always the same type for a reference. When you
    add an lvalue reference to reference type `TR`, you always get back an lvalue
    reference, meaning `TR&` is always the same as `std::remove_reference_t<TR>&`.
    This is known as [**reference collapsing**](https://timsong-cpp.github.io/cppwp/n4861/dcl.ref#6),
    and it explains why, when an lvalue is passed to forwarding reference `f(T&&t)`,
    `T` can be inferred as an lvalue reference.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将一个引用类型 `TR` 和一个右值引用相加时，你会得到 `TR`，意味着 `TR&&` 和 `TR` 总是同一类型的引用。当你将左值引用添加到引用类型
    `TR` 时，你总是会得到一个左值引用，意味着 `TR&` 总是与 `std::remove_reference_t<TR>&` 相同。这被称为 [**引用折叠**](https://timsong-cpp.github.io/cppwp/n4861/dcl.ref#6)，并且解释了为什么当一个左值传递给转发引用
    `f(T&&t)` 时，`T` 可以被推断为左值引用。
- en: When treated as an expression, a variable `v` is always an lvalue, regardless
    of whether `v` was declared as a non-reference `T`, an lvalue-reference `T&`,
    or an rvalue-reference `T&&`. Hence, if you want a forwarding reference to be
    inferred as something other than an lvalue reference, you need to pass something
    other than a variable, such as a function call result (e.g., `std::forward<T>(t)`)
    or a cast (`static_cast<T&&>(t)`).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当作为表达式处理时，变量 `v` 总是一个左值，无论 `v` 是否被声明为非引用 `T`，左值引用 `T&`，还是右值引用 `T&&`。因此，如果你希望推断出的转发引用不是左值引用，你需要传递其他内容，例如函数调用结果（例如，`std::forward<T>(t)`）或转换（`static_cast<T&&>(t)`）。
- en: An expression that is an invocation of a function returning a non-reference,
    non-`void` type is of a category known as a *prvalue*. Since C++17, you can think
    of a prvalue as a set of instructions for how to create an object that has not
    yet been created. Hence, invoking `use_object` below creates only one `Obj`, namely
    `o`, because what `make_object()` returns is conceptually just a recipe saying,
    “Please initialize some `Obj` with the default initializer `{}`.”
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式作为非引用、非 `void` 类型的函数调用的结果时，被称为*纯右值*。自 C++17 起，你可以将纯右值视为一组说明如何创建尚未创建的对象的指令。因此，下面的调用
    `use_object` 只创建了一个 `Obj`，即 `o`，因为 `make_object()` 返回的是一个概念上的配方，即“请使用默认初始化器 `{}`
    初始化一些 `Obj`。”
- en: '[PRE40]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This behavior is sometimes known as [*mandatory copy elision*](https://en.cppreference.com/w/cpp/language/copy_elision).
    Another way to think about it is that even if the code for creating an `Obj` resides
    within the generated code for `make_object`, the compiler must arrange for the
    new `Obj` to reside in the stack frame that belongs to the calling function (`use_object`)
    so that the `Obj` isn’t destroyed on return from `make_object`.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种行为有时被称为[*强制复制省略*](https://en.cppreference.com/w/cpp/language/copy_elision)。另一种思考方式是，即使创建`Obj`的代码位于`make_object`生成的代码内部，编译器也必须安排新的`Obj`位于调用函数(`use_object`)的栈帧中，以免在从`make_object`返回时销毁`Obj`。
- en: When you declare a variable as `auto v = expression`, the type deduction rules
    [are the same](https://timsong-cpp.github.io/cppwp/n4861/dcl.type.auto.deduct#4)
    as for templates—meaning `v`’s type will be the non-reference type `T` inferred
    when invoking the template function `template<typename T> void f(T t)` with the
    same expression, i.e., `f(expression)`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您将变量声明为`auto v = expression`时，类型推导规则与模板相同——这意味着当使用相同表达式调用模板函数`template<typename
    T> void f(T t)`时，`v`的类型将是调用时推导的非引用类型`T`，即`f(expression)`。
- en: When you declare a variable as `decltype(auto) v = expression`, the type of
    `v` will be exactly `decltype(expression)`. `decltype` is confusing for the uninitiated,
    as the single keyword does two totally different things, often depending on something
    as trivial as extra parentheses ([details here](https://www.scs.stanford.edu/~dm/blog/decltype.html#decltype-overview)).
    However, when `decltype` is applied to a function call expression, the type is
    always exactly the return type of the function, which can be a non-reference,
    lvalue-reference, or rvalue-reference.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您将变量声明为`decltype(auto) v = expression`时，`v`的类型将完全是`decltype(expression)`。`decltype`对于初学者来说可能很令人困惑，因为这个关键字做了两件完全不同的事情，通常取决于一些像额外括号这样的微不足道的东西（[详细信息在此](https://www.scs.stanford.edu/~dm/blog/decltype.html#decltype-overview)）。然而，当`decltype`应用于函数调用表达式时，类型总是函数的返回类型，可以是非引用、左值引用或右值引用。
- en: In `good1`, we need to construct a new `Obj` from the reference function argument
    in all cases except when the argument was a temporary object (i.e., `good1(Obj{})`).
    When the argument was a temporary, the inferred type `T` is `Obj` (meaning argument
    `t` has type `Obj&&`). If the argument was a variable of type `Obj`, then `T`
    will be inferred as `Obj&`, and we need to copy it to avoid modifying it. If the
    variable was anything other than an `Obj`, we need to construct an `Obj` from
    it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`good1`中，我们需要在所有情况下都从引用函数参数构造一个新的`Obj`，除非参数是临时对象（即`good1(Obj{})`）。当参数是临时对象时，推断出的类型`T`为`Obj`（意味着参数`t`的类型为`Obj&&`）。如果参数是类型为`Obj`的变量，则推断出的类型`T`将为`Obj&`，我们需要复制它以避免修改它。如果变量是除`Obj`之外的任何其他类型，则需要从中构造一个`Obj`。
- en: The goal of [`local_copy`](#local-copy-3) is to construct a new object of type
    `Want` from an argument of type `Have` unless the argument is already a temporary
    object of type `Want`, in which case it should just return a reference to the
    existing temporary object. The return type of the function uses [`std::conditional_t`](https://en.cppreference.com/w/cpp/types/conditional)
    to distinguish these two cases—it returns a new `Want` (meaning a prvalue) unless
    `Want` and `Have` are the same type, in which case it returns an rvalue reference
    to its input object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[`local_copy`](#local-copy-3)的目标是根据类型`Have`的参数构造一个新的`Want`对象，除非参数已经是类型`Want`的临时对象，在这种情况下，它应返回现有临时对象的引用。函数的返回类型使用[`std::conditional_t`](https://en.cppreference.com/w/cpp/types/conditional)来区分这两种情况——它返回一个新的`Want`（即一个prvalue），除非`Want`和`Have`是相同的类型，在这种情况下，它返回其输入对象的右值引用。'
- en: Notice that `local_copy` takes a `Have&` and not a `Have&&`, because it is intended
    to be used with variables, whose expression type will always be an lvalue and
    hence cannot be bound to an rvalue reference. (We explicitly specify the type
    of `Have` when invoking `local_copy`, so it can’t be a forwarding reference.)
    `local_copy` casts its return value to `Have&&`, which (through reference collapsing)
    is the same as `Have` when `Have` is an lvalue reference. It’s also possible that
    the argument was a temporary object of type other than `Obj`, in which case it
    is returned as an rvalue reference from which the return `Obj` is constructed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`local_copy`接受`Have&`而不是`Have&&`，因为它预期与变量一起使用，其表达式类型将始终是左值，因此不能绑定到右值引用。
    （我们在调用`local_copy`时明确指定了`Have`的类型，因此它不能是
- en: There are still a few cases in which `good1` behaves differently from the hypothetical
    homogeneous `good(Obj ...arg)`. If you call `good1(std::move(obj))`, no new `Obj`
    will be constructed from the argument, whereas ordinarily you would expect to
    move-construct a new `Obj`. Arguably this is a feature; since a moved object is
    left in an unspecified state, the main differences in semantics will be one fewer
    invocation of the move constructor `Obj::Obj(Obj&&)` (or copy constructor if `Obj`
    lacks a move constructor). Another difference is that you can call `good({})`
    and the `{}` will construct an `Obj`, since the argument type is known, whereas
    `good1({})` is illegal because the compiler doesn’t know the argument type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种情况下，`good1`的行为与假设的同质`good(Obj ...arg)`有所不同。如果调用`good1(std::move(obj))`，则不会从参数构造新的`Obj`，而通常您会期望移动构造一个新的`Obj`。可以说这是一种特性；因为移动对象留在未指定的状态，语义上的主要区别将是少一次调用移动构造函数`Obj::Obj(Obj&&)`（或者如果`Obj`缺乏移动构造函数，则复制构造函数）。另一个区别是，您可以调用`good({})`，而`{}`会构造一个`Obj`，因为参数类型已知，而`good1({})`是非法的，因为编译器不知道参数类型。
- en: 'By the way, if this all seems too complex, there is sometimes an alternative
    to variadic functions for homogenous argument lists—you can write functions to
    take an `initializer_list`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果这一切看起来太复杂，有时替代可变参数函数用于同质参数列表的另一种方法是，您可以编写接受`initializer_list`的函数：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The two disadvantages are that you’ll have to call the function with an extra
    set of braces, as in `alsmost_good3({obj, Obj{}})`, and that you only have `const`
    access to members of `std::initializer_list`, so it won’t work with our example
    `Obj` type, in which the `use()` method is not `const`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个缺点是您将不得不使用额外的一组大括号来调用该函数，如`alsmost_good3({obj, Obj{}})`，以及您只能对`std::initializer_list`的成员进行`const`访问，因此它不适用于我们的示例`Obj`类型，其中`use()`方法不是`const`。
- en: Array of function pointers
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数指针数组
- en: Sometimes you need to convert a runtime constant into a compile-time constant
    without manually writing out every possible value in a `switch` statement. The
    best way to do this is to initialize an array of function pointers using a parameter
    pack expansion.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要将运行时常量转换为编译时常量，而不是手动编写`switch`语句中的每个可能的值。这样做的最佳方法是使用参数包展开初始化函数指针数组。
- en: As an example, suppose you wish to serialize a [`std::variant`](https://en.cppreference.com/w/cpp/utility/variant)
    `v`. You can serialize the current type of the variant by serializing the number
    `v.index()`. Then you can serialize the body of the variant with [`std::visit`](https://en.cppreference.com/w/cpp/utility/variant/visit).
    To deserialize `v`, you must reverse the process. First, deserialize the index
    value `i`. Then set `v.index()` to `i` by setting `v` to contain its `i`th type.
    Finally, deserialize the contents with `std::visit`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您希望序列化[`std::variant`](https://en.cppreference.com/w/cpp/utility/variant)`v`。您可以通过序列化变体的当前类型来序列化数字`v.index()`。然后，您可以使用[`std::visit`](https://en.cppreference.com/w/cpp/utility/variant/visit)来序列化变体的主体。要反序列化`v`，您必须反转该过程。首先，反序列化索引值`i`。然后通过将`v`设置为包含其第`i`个类型来将`v.index()`设置为`i`。最后，使用`std::visit`反序列化内容。
- en: 'Unfortunately, the problem with this plan is that the inverse of `v.index()`—a
    method to *set* the index of the variant—does not exist. We could try to implement
    such a function by brute-force, but the result will be problematic:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，该计划的问题在于`v.index()`的逆过程——设置变体索引的方法——不存在。我们可以尝试通过蛮力来实现这样的功能，但结果将是有问题的：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The less serious problem with this code is that it is very tedious to write.
    Even though `emplace` really is a different function for each index of the variant,
    writing it out this way is painful. The more serious problem is that the above
    function only works for variants with exactly 3 cases. A variant with only 2 cases
    doesn’t have valid code for `emplace<2>`, so invoking `set_index` on such a type
    will fail to compile.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的较小问题是编写起来非常乏味。即使`emplace`对于变体的每个索引确实是一个不同的函数，按这种方式写出来也很痛苦。更严重的问题是上述函数仅适用于具有恰好3个案例的变体。只有2个案例的变体没有`emplace<2>`的有效代码，因此在这样的类型上调用`set_index`将无法编译。
- en: 'What we need is a way to take a runtime constant and convert it to a compile
    time constant we can supply as a template parameter to `v.emplace<`∘`>()`. We
    can represent compile-time constants with the template type [`std::integral_constant`](https://en.cppreference.com/w/cpp/types/integral_constant),
    which has a `constexpr` conversion operator returning the integral value represented
    by the type. Conceptually, we would like to do something like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一种方法，可以将运行时常量转换为我们可以作为模板参数提供给`v.emplace<`∘`>()`的编译时常量。我们可以使用模板类型[`std::integral_constant`](https://en.cppreference.com/w/cpp/types/integral_constant)表示编译时常量，该类型具有返回表示类型的整数值的`constexpr`转换操作符。在概念上，我们想做类似于这样的事情：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Of course, that doesn’t make sense because `0_const` and `1_const` are of different
    types. A function can only return one type (which obviously can’t depend on a
    runtime argument). In order for a function to produce a type dependent on a runtime
    parameter, instead of returning the type, the function needs to call an overloaded
    function object. We therefore must implement something like the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是没有意义的，因为`0_const`和`1_const`是不同类型的。函数只能返回一种类型（显然不能依赖于运行时参数）。为了让函数产生依赖于运行时参数的类型，而不是返回类型，函数需要调用一个重载的函数对象。因此，我们必须实现类似于以下内容的内容：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Okay, so now we know what the function should look like, but we still have the
    problem that it only works for a fixed number of values of `n`. Not even a fixed
    maximum, but a fixed number. However, we can fix this by taking the maximum value
    as a parameter, then using `std::make_index_sequence` to generate a parameter
    pack that we expand into an array of function pointers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们知道函数应该是什么样子了，但我们仍然有一个问题，即它仅适用于`n`的固定数量的值。甚至不是一个固定的最大值，而是一个固定的数量。但是，我们可以通过将最大值作为参数，然后使用`std::make_index_sequence`来生成参数包，将其展开为函数指针数组来解决这个问题。
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Some notes on the above code. First, note that [`invoke_array`](#with-n-15),
    because it is an array, must have all its elements be of the same type. Hence,
    we really do need [`detail::with_integral_constant`](#with-n-3) to be a function,
    rather than a lambda expression, to ensure all elements of the array have the
    same type. We could create an array of [`std::function<R(F&&)>`](https://en.cppreference.com/w/cpp/utility/functional/function),
    but `std::function::~function` is not a `constexpr` destructor, so then `invoke_array`
    could not be `constexpr`, which might inhibit some compiler optimizations. (Note
    in some cases, if you have non-generic lambdas with no variable capture, they
    can be [converted](https://timsong-cpp.github.io/cppwp/n4868/expr.prim.lambda#closure-7)
    to ordinary function pointers by [prefixing the lambda with `+`](https://timsong-cpp.github.io/cppwp/n4868/over.built#9),
    as in `+[]{}`.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上述代码的一些说明。首先，请注意，[`invoke_array`](#with-n-15)由于是数组，因此其所有元素都必须是相同类型。因此，我们确实需要[`detail::with_integral_constant`](#with-n-3)是一个函数，而不是一个lambda表达式，以确保数组的所有元素具有相同的类型。我们可以创建一个[`std::function<R(F&&)>`](https://en.cppreference.com/w/cpp/utility/functional/function)的数组，但是`std::function::~function`不是一个`constexpr`析构函数，因此`invoke_array`可能不是`constexpr`，这可能会抑制一些编译器优化。（注意，在某些情况下，如果您有没有变量捕获的非通用lambda，则可以通过在lambda前面加上`+`来将其转换为普通函数指针，如`+[]{}`。）
- en: Next, note that we supply the number of possible values, `N`, as the first template
    argument to [`with_n`](#with-n-12), and this argument is mandatory. By using `std::array::at`,
    we ensure that an exception will be thrown for out-of-bounds values of `n`. Note
    also that if we want to use `with_n` with a return type other than `void`, it
    must be supplied as the second template argument `R`. Since the code is different
    for each value of `n`, we can’t infer a return type. (Possibly we could do something
    fancy to compute a plausible return type using [`std::common_type_t`](https://en.cppreference.com/w/cpp/types/common_type),
    but it doesn’t seem worth the complexity.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意我们将可能值的数量 `N` 作为第一个模板参数提供给 [`with_n`](#with-n-12)，并且此参数是必需的。通过使用 `std::array::at`，我们确保对于
    `n` 的超出范围的值将抛出异常。还要注意，如果我们想要将 `with_n` 与除 `void` 之外的返回类型一起使用，它必须作为第二个模板参数 `R`
    提供。由于每个值的代码都不同，我们无法推断出返回类型。 （可能我们可以做一些花哨的事情来使用 [`std::common_type_t`](https://en.cppreference.com/w/cpp/types/common_type)
    计算一个合理的返回类型，但这似乎不值得复杂化。）
- en: 'As a reminder about [constraints](https://en.cppreference.com/w/cpp/language/constraints),
    the clause `{ std::variant_size_v<T>+0 } -> std::same_as<std::size_t>` is known
    as a *compound requirement*, and states that `decltype((`∘`))` of the expression
    in braces must satisfy the constraint to the right of the arrows. Since the expression
    `(std::variant_size_v<T>)` is probably an lvalue of type `const std::size_t&`,
    we just add 0 to turn it into a prvalue of type `std::size_t`, avoiding any worries
    about the const or references. An alternative would be to use our [`is_template`](#is-template)
    concept, as in:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 [constraints](https://en.cppreference.com/w/cpp/language/constraints) 的一个提醒，`{
    std::variant_size_v<T>+0 } -> std::same_as<std::size_t>` 子句被称为 *复合要求*，并声明了大括号中表达式的
    `decltype((∘))` 必须满足箭头右侧的约束。由于表达式 `(std::variant_size_v<T
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, note the importance of our [lambda](#with-n-29) in `set_index` accepting
    the parameter by value (`auto i`) and not by reference (`auto &&i` or `const auto
    &i`). Because of some quirkiness in how `constexpr` works, you [can’t](https://github.com/cplusplus/papers/issues/973)
    call `constexpr` methods (such as `std::integral_constant::operator std::size_t`)
    on a reference at compile time, only on a value. Hence, [line 30](#with-n-30)
    will cause a compilation error if `i` is a reference.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意我们在 `set_index` 中的 [lambda](#with-n-29) 参数的重要性，它接受值参数（`auto i`）而不是引用参数（`auto
    &&i` 或 `const auto &i`）。由于`constexpr`的一些怪异之处，你无法在编译时对引用调用`constexpr`方法（如`std::integral_constant::operator
    std::size_t`），只能对值调用。因此，如果`i`是引用，[第30行](#with-n-30) 将导致编译错误。
- en: Conclusion
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: As C++ evolves, many old, error-prone, and frankly disgusting idioms are no
    longer necessary and should be eliminated. For instance, you should never again
    rely on [SFINAE](https://en.cppreference.com/w/cpp/language/sfinae) now that we
    have [concepts](https://en.cppreference.com/w/cpp/language/constraints). Similarly,
    it’s time to update our variadic function idioms to leverage the new language
    features. Concepts now allow us to restrict the types in a function parameter
    pack. `constexpr`-by-default lambdas help us capture parameter packs even in contexts
    such as [requires clauses](#using-lambda-expressions-to-capture-packs-in-requires-clauses).
    The ability to use lambdas in unevaluated contexts lets us [avoid helper classes](#using-decltype-on-lambda-expressions)
    for many purposes. [Folds](#comma-fold) and [`if constexpr`](https://en.cppreference.com/w/cpp/language/if)
    can save us from implementing multiple overloaded functions for recursive and
    base cases. [Class template argument deduction](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)
    makes it possible to introduce types such as [`multilambda`](#multilambda) without
    helper functions to create them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++ 的发展，许多旧的、容易出错的、老旧的范式不再必要，应该被淘汰。例如，现在我们有了 [concepts](https://en.cppreference.com/w/cpp/language/constraints)，你再也不应该依赖
    [SFINAE](https://en.cppreference.com/w/cpp/language/sfinae)。同样，是时候更新我们的可变参数函数范式，以利用新的语言特性了。Concepts
    现在允许我们限制函数参数包中的类型。默认情况下的`constexpr` lambda 帮助我们在诸如 [requires clauses](#using-lambda-expressions-to-capture-packs-in-requires-clauses)
    这样的上下文中捕获参数包。在未评估的上下文中使用 lambda 的能力让我们避免了许多情况下的辅助类。[Folds](#comma-fold) 和 [`if
    constexpr`](https://en.cppreference.com/w/cpp/language/if) 可以节省我们为递归和基本情况实现多个重载函数。[Class
    template argument deduction](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)
    使我们能够引入诸如 [`multilambda`](#multilambda) 这样的类型，而无需使用辅助函数来创建它们。
- en: Unfortunately, effective use of variadic templates still involves some unwieldy
    idioms, in large part because of the asymmetry between expanding patterns (which
    works in many contexts) and capturing parameter packs (which often requires introducing
    otherwise unnecessary lambda expressions). If C++ adopts [parameter packs in structured
    bindings](https://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1061r0.html),
    this will go a long way towards further simplifying the use of parameter packs.
    Another nice feature would be [homogeneous variadic function parameters](https://wg21.link/p1219r0),
    though unfortunately that was [rejected](https://github.com/cplusplus/papers/issues/297)
    by the committee, so won’t be adopted in current form. Still, perhaps a future
    version of the standard could at least deprecate omitting the comma in declarations
    of old-style varargs functions, which is the main impediment.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有效使用可变参数模板仍然涉及一些笨拙的范式，这在很大程度上是因为扩展模式（在许多情况下可用）和捕获参数包之间的不对称性（通常需要引入其他不必要的
    lambda 表达式）。如果 C++ 采用 [structured bindings 中的参数包](https://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1061r0.html)，这将大大简化参数包的使用。另一个很好的功能是
    [同质可变参数函数参数](https://wg21.link/p1219r0)，但不幸的是，它被委员会 [拒绝了](https://github.com/cplusplus/papers/issues/297)，因此不会以当前形式被采纳。尽管如此，也许未来的标准版本至少可以废弃省略旧式
    varargs 函数声明中的逗号，这是主要的障碍。
- en: I hope the idioms I presented are useful to you. If you are still writing C++17-compatible
    code, I hope this post provides further motivation for you to abandon legacy compatibility
    and embrace the significant improvements in C++20.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我提供的习语对你有所帮助。如果你仍在编写与C++17兼容的代码，我希望这篇文章能进一步激励你放弃遗留的兼容性，拥抱C++20中的重大改进。
