- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 14:41:05'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:41:05'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Implementing System-Versioned Tables in Postgres
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Postgres中实施系统版本表
- en: 来源：[https://hypirion.com/musings/implementing-system-versioned-tables-in-postgres](https://hypirion.com/musings/implementing-system-versioned-tables-in-postgres)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://hypirion.com/musings/implementing-system-versioned-tables-in-postgres](https://hypirion.com/musings/implementing-system-versioned-tables-in-postgres)
- en: I like Postgres, but there are things I really wish they would implement. For
    example, the [SQL:2011](https://en.wikipedia.org/wiki/SQL:2011) spec adds support
    for system-versioned tables. Unfortunately, Postgres and SQLite are basically
    the only SQL databases that don’t yet support it. While it has been discussed
    in length at the [postgreqsl-hackers’ mailing list](https://www.postgresql.org/message-id/flat/CALAY4q-cXCD0r4OybD%3Dw7Hr7F026ZUY6%3DLMsVPUe6yw_PJpTKQ%40mail.gmail.com),
    it seems like the discussion and implementation efforts have been silent in all
    of 2023.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢Postgres，但也有些功能我真希望它们能实现。例如，[SQL:2011](https://en.wikipedia.org/wiki/SQL:2011)
    规范添加了对系统版本表的支持。不幸的是，Postgres 和 SQLite 基本上是唯一还不支持它的 SQL 数据库。尽管在 [postgreqsl-hackers
    邮件列表](https://www.postgresql.org/message-id/flat/CALAY4q-cXCD0r4OybD%3Dw7Hr7F026ZUY6%3DLMsVPUe6yw_PJpTKQ%40mail.gmail.com)
    上已经广泛讨论了这个问题，但似乎在整个 2023 年里，讨论和实施工作都没有进展。
- en: Now, there are extensions out there that implement versioning – [`temporal_tables`](https://clarkdave.net/2015/02/historical-records-with-postgresql-and-temporal-tables-and-sql-2011/)
    being the most popular I think – but none are supported for managed Postgres instances
    on e.g. Azure or AWS. This means that if we want system-versioned tables, we’re
    forced to make it ourselves.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，市面上有一些实现版本控制的扩展，[`temporal_tables`](https://clarkdave.net/2015/02/historical-records-with-postgresql-and-temporal-tables-and-sql-2011/)
    可能是最流行的，但我认为没有一个在例如 Azure 或 AWS 上的托管 Postgres 实例上得到支持。这意味着，如果我们想要系统版本表，我们只能自己动手实现。
- en: I’m not going to spend paragraph after paragraph explaining why I want temporal
    tables before we go to the actual implementation, but I’d like to note that I
    want to use these tables primarily for user data, generated by users when they
    click/type something on a webpage. They can be used for other things, but if you
    have time series, want to do event sourcing or online analytical processing, you
    should probably pick some technology suited for that task instead of throwing
    temporal tables at it.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际实施之前，我不打算花费段落来解释为什么我想要临时表，但我想指出，我主要想使用这些表来存储用户数据，这些数据由用户在网页上点击/输入时生成。它们也可以用于其他用途，但如果您有时间序列、想要进行事件溯源或在线分析处理，您应该选择一些适合该任务的技术，而不是随意使用临时表。
- en: If you’re only after the end result, feel free to go to my GitHub repository
    [time-travelling-todo-lists-in-postgres](https://github.com/hypirion/time-travelling-todo-lists-in-postgres).
    It is a todo list app with time-travelling capabilities, using the implementation
    described here. There you’ll have information on how to use it yourself, how to
    query the past, as well as gotchas and common pitfalls.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只关心最终结果，请随意访问我的GitHub仓库 [time-travelling-todo-lists-in-postgres](https://github.com/hypirion/time-travelling-todo-lists-in-postgres)。这是一个具有时间旅行功能的待办事项应用程序，使用了这里描述的实现方法。在那里，你将获得如何自行使用它的信息，如何查询过去以及一些需要注意的问题和常见陷阱。
- en: The Implementation
  id: totrans-split-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'The implementation I’ve decided on consists of two tables for every table I
    want version controlled: A snapshot table for the current state, and a history
    table.'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定的实施方案包括为我想要版本控制的每个表创建两个表：一个快照表用于当前状态，一个历史表。
- en: <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 116.798 35.169"><text xml:space="preserve"
    x="30.997" y="45.291" transform="translate(-19.358 -27.08)"><tspan x="30.997"
    y="45.291">Snapshot</tspan><tspan x="30.997" y="50.582">Table</tspan></text><text
    xml:space="preserve" x="103.227" y="45.729" transform="translate(-19.358 -27.08)"><tspan
    x="103.227" y="45.729">History</tspan><tspan x="103.227" y="51.021">Table</tspan></text><text
    xml:space="preserve" x="69.26" y="33.634" transform="translate(-19.358 -27.08)"><tspan
    x="69.26" y="33.634">Inserts</tspan><tspan x="69.26" y="37.603">Updates</tspan><tspan
    x="69.26" y="41.572">Deletes</tspan></text></svg>
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 116.798 35.169"><text xml:space="preserve"
    x="30.997" y="45.291" transform="translate(-19.358 -27.08)"><tspan x="30.997"
    y="45.291">快照</tspan><tspan x="30.997" y="50.582">表</tspan></text><text xml:space="preserve"
    x="103.227" y="45.729" transform="translate(-19.358 -27.08)"><tspan x="103.227"
    y="45.729">历史</tspan><tspan x="103.227" y="51.021">表</tspan></text><text xml:space="preserve"
    x="69.26" y="33.634" transform="translate(-19.358 -27.08)"><tspan x="69.26" y="33.634">插入</tspan><tspan
    x="69.26" y="37.603">更新</tspan><tspan x="69.26" y="41.572">删除</tspan></text></svg>
- en: 'The snapshot table is the one used for the current state of the world and is
    the one you’ll usually work with: This works exactly like any other mutable in-place
    table you’re familiar with. The history table is the one you’ll use when you want
    to query through history.'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 快照表是用于当前世界状态的表，通常是您将要使用的表格：它与您熟悉的任何其他可变的就地表格完全相同。 历史表是在您想要通过历史查询时将要使用的表格。
- en: 'First off, we define the tables:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义表格：
- en: '[PRE0]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The history table contains the exact same fields as the snapshot table, but
    the first two columns in the table are a `history_id` field and the system time
    (`systime`) it was active. `lower(systime)` is when this version of the record
    was initially stored, and `upper(systime)` is when this record was no longer valid.
    When `upper(systime)` is infinity, the record has not yet been deleted. The interval
    can’t be empty obviously, as that wouldn’t match any time interval.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 历史表包含快照表中完全相同的字段，但表中的前两列是`history_id`字段和记录活动的系统时间（`systime`）。 `lower(systime)`是记录此版本的记录最初存储的时间，`upper(systime)`是此记录不再有效的时间。
    当`upper(systime)`是无穷大时，记录尚未删除。 显然，时间间隔不能为空，因为这将不匹配任何时间间隔。
- en: Next, we have a GiST index, which prevents us from having overlapping time intervals
    for the same primary key, and also speeds up queries on the history. You may want
    to add some more indices on the history table, depending on what kind of queries
    you want to do on it.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个GiST索引，它防止具有相同主键的时间间隔重叠，并且还加速了对历史的查询。 根据您希望在其上执行的查询类型，您可能需要在历史表上添加更多索引。
- en: 'Then we set up triggers for insert, update and delete:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为插入、更新和删除设置触发器：
- en: '[PRE1]'
  id: totrans-split-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is… long, to put it mildly, so let’s go through some common tricks all
    the three triggers (ab)use, and then go over some design decisions I’ve decided
    on for updates and deletes. We’ll get around to shortening it at the end.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是…… 长话短说，让我们来看看这些触发器中所有三种常见技巧的一些共同的把戏，然后再过一下我为更新和删除做出的设计决策。 最后我们来缩短它。
- en: Column Order Matters
  id: totrans-split-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列顺序很重要
- en: 'Whenever we insert new data into the history table, it will always be on this
    form:'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们将新数据插入历史表时，它将始终以此形式：
- en: '[PRE2]'
  id: totrans-split-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two parts of Postgres we abuse here. If we look at [the docs for
    INSERT](https://www.postgresql.org/docs/16/sql-insert.html), we’ll see the following
    paragraph:'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: Postgres中我们在这里滥用了两部分。 如果我们查看[INSERT的文档](https://www.postgresql.org/docs/16/sql-insert.html)，我们将看到以下段落：
- en: The target column names can be listed in any order. If no list of column names
    is given at all, the default is all the columns of the table in their declared
    order; or the first ***N*** column names, if there are only ***N*** columns supplied
    by the `VALUES` clause or ***`query`***. The values supplied by the `VALUES` clause
    or ***`query`*** are associated with the explicit or implicit column list left-to-right.
  id: totrans-split-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 目标列名可以按任何顺序列出。 如果根本没有列名列表，则默认为表格中所有列按其声明的顺序； 或者如果`VALUES`子句或`query`提供的列仅有***N***列，则与显式或隐式的列列表从左到右关联。
- en: 'The other is that `NEW.*` expands in the exact same order. In our case, `NEW.*`
    will expand into `NEW.mytable_id, NEW.data`, and that means it fits perfectly
    with the rows of `mytable_history`:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是`NEW.*`以完全相同的顺序扩展。 在我们的情况下，`NEW.*`将扩展为`NEW.mytable_id, NEW.data`，这意味着它与`mytable_history`表的行完美匹配：
- en: '[PRE3]'
  id: totrans-split-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is pretty clever, but it’s also hacky. For this to work, there are two
    things you have to get right:'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常聪明，但也很粗糙。 要使其工作，您必须做到两点：
- en: Column order MUST be identical after the `history_id` and `systime` columns.
  id: totrans-split-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`history_id`和`systime`列后，列顺序必须完全相同。
- en: Whenever you add new columns, you MUST add them in the same order to both tables.
  id: totrans-split-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当您添加新列时，必须以相同的顺序将其添加到两个表中。
- en: If you don’t do so, you will end up with broken inserts in the history table.
    Those will at best give you an error, but they can also silently corrupt your
    data.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不这样做，您将最终在历史表中得到损坏的插入。 在最好的情况下，它们会给您一个错误，但它们也可能悄无声息地破坏您的数据。
- en: I don’t like that, but there’s a reason why I don’t do
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我不喜欢那样，但我不这样做有一个原因
- en: '[PRE4]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: and that’s because it creates **a lot** of effort when you want to remove, rename
    or add a new column to the table. By omitting the list of target column names
    and expanding `NEW.*`, the query will automatically work whenever I decide to
    add, update or remove columns – provided I do it for both tables.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当您想要从表中删除、重命名或添加新列时，它会**极大地增加工作量**。 通过省略目标列名的列表并扩展`NEW.*`，只要我决定同时对两个表进行操作，查询就会自动工作。
- en: On System Time
  id: totrans-split-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在系统时间上
- en: If you haven’t worked with Postgres ranges before, the range queries may look
    a bit cryptic. The Postgres docs have an excellent description of [range types](https://www.postgresql.org/docs/16/rangetypes.html)
    and [range functions](https://www.postgresql.org/docs/16/functions-range.html),
    which should cover essentially everything related to them. I don’t use much of
    it though, so since I guess you don’t want to go through it all, I’ll just list
    up what the different parts do.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过 PostgreSQL 的范围类型，范围查询可能看起来有点神秘。PostgreSQL 文档对[范围类型](https://www.postgresql.org/docs/16/rangetypes.html)和[范围函数](https://www.postgresql.org/docs/16/functions-range.html)有出色的描述，这应该涵盖与它们相关的一切。虽然我没怎么用它，所以我猜你也不想详细阅读，我只是简单列出了不同部分的内容。
- en: The expression
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式
- en: 'creates the timestamptz range `[a, b)`: from *a*, up to and excluding *b*.
    If either *a* or *b* are `NULL`, then they are infinitely far in the past or future,
    respectively.'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 timestamptz 范围 `[a, b)`：从 *a* 开始，直到但不包括 *b*。如果 *a* 或 *b* 是 `NULL`，那么它们分别位于过去或未来的无限远处。
- en: '`lower(x)` returns the lower bound of the range, and `upper_inf(x)` returns
    true if the upper bound is infinite.'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower(x)` 返回范围的下限，而 `upper_inf(x)` 如果上限是无限的则返回真。'
- en: Finally, `systime @> NOW()` checks if `systime` contains `NOW()` – you can think
    of it as `a <= NOW() AND NOW() < b`.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`systime @> NOW()` 检查 `systime` 是否包含 `NOW()` – 你可以把它看作是 `a <= NOW() AND NOW()
    < b`。
- en: The reason for using ranges isn’t primarily because I want to use these functions,
    but rather because the GiST index ensures no overlap and makes me less worried
    that my queries will be super slow by accident.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用范围的原因并非主要是因为我想使用这些函数，而是因为 GiST 索引确保没有重叠，并且让我不那么担心我的查询会因为偶然而变得超级缓慢。
- en: Inserts
  id: totrans-split-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入
- en: 'With those two things described, inserts are more or less described in their
    entirety: We insert the row into the history table, saying it’s valid from the
    transaction start time until forever.'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 插入操作可以说已经描述得比较完整了：我们将行插入到历史表中，表明它从事务开始时间到永远都是有效的。
- en: Updates
  id: totrans-split-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新
- en: 'The update trigger looks like this:'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更新触发器如下所示：
- en: '[PRE5]'
  id: totrans-split-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is set up so that multiple updates in the same transaction will only produce
    a single history row. That’s intentional, because otherwise ordering would be
    harder to implement.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 设计成在同一个事务中进行多次更新只会生成一行历史记录。这是有意的，因为否则会更难实现排序。
- en: If you need multiple versions in the same transaction, you’ll have to replace
    the half-open interval (the default `[)`) with a closed one (`[]`). If not, you’ll
    end up with empty intervals, which aren’t tied to any timestamps. But now you
    have to handle identical states at a single timestamp, as multiple records can
    get the `[NOW(), NOW()]` interval. If the ordering matters in that case, you’ll
    have to add another ordering ID to get rows back in the inserted order.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在同一事务中有多个版本，你需要用闭合间隔(`[]`)替换半开间隔（默认为`[)`）。否则，你会得到空间隔，它们不与任何时间戳相关联。但现在你必须处理同一时间戳上相同状态的情况，因为多条记录可以得到`[NOW(),
    NOW()]`间隔。如果在这种情况下顺序很重要，你必须添加另一个排序 ID，以便按插入顺序获取行。
- en: I don’t need that, it’s complicated, and I don’t think it makes sense to have
    multiple states at a single point in time anyway. If you need that, you’re probably
    interested in an event table or something else instead.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我不需要这些，它太复杂了，而且我不认为在同一时间点有多个状态是有意义的。如果你需要这样做，你可能更感兴趣的是事件表或其他东西。
- en: Deletions
  id: totrans-split-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除
- en: '[PRE6]'
  id: totrans-split-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When it comes to atomicity, deletions are somewhat of an outlier. If you update
    and then delete something in the same transaction, what should you do? And uh..
    why would you do that in the first place?
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及原子性时，删除操作有点不同寻常。如果你在同一个事务中先更新再删除某些内容，你应该怎么做？而且，为什么首先要这样做呢？
- en: '“Update and delete” seems quite handy if you want to write down who deleted
    the object, in which case the deletion will look like this:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: “更新和删除”在你想要记录谁删除了对象时似乎非常方便，此时删除操作将如下所示：
- en: '[PRE7]'
  id: totrans-split-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '… however, it leaves you with an annoying record: The “delete” record, which
    isn’t really part of the history, but only contains some information about the
    deletion itself.'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: … 但会留下一个让你很烦恼的记录：那个“删除”记录，并不是历史的一部分，只包含有关删除本身的一些信息。
- en: 'I think it’s better to make a little bit of effort for these, even if you don’t
    have an immediate need for a changelog/audit log: Store the deletion information
    in a table. You could create one for all tables, or just one for everything depending
    on how lazy you are:'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为即使你没有立即需要更改日志/审计日志，也最好为此做出一点努力：将删除信息存储在一个表中。你可以为所有表创建一个表，或者根据你的懒惰程度仅创建一个表：
- en: '[PRE8]'
  id: totrans-split-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I can’t make a trigger out of this easily (or maybe not at all), because `deleted_by`
    is information we’ll have to pass down into the database somehow.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我很难（或者可能根本做不到）轻松地制作一个触发器，因为`deleted_by`是我们必须以某种方式传递到数据库中的信息。
- en: Annoying Conflicts
  id: totrans-split-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 令人讨厌的冲突
- en: 'While the triggers themselves don’t impact what you can and cannot do, the
    GiST index will blow up most attempts at concurrently updating the same item:'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然触发器本身不会影响你可以或不能做的事情，但GiST索引将使大多数同时更新相同项目的尝试失败。
- en: '[PRE9]'
  id: totrans-split-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will even fail if you do `SELECT .. FOR UPDATE`. When you have two transactions
    A and B coming in, if the transaction with the most recent `NOW()` timestamp gets
    the lock first, the second transaction will fail because `systime` ends up as
    an empty interval.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你使用`SELECT .. FOR UPDATE`也会失败。当两个事务A和B同时到达时，如果拥有最近的`NOW()`时间戳的事务首先获得锁定，第二个事务将失败，因为`systime`最终为空时间间隔。
- en: It’s annoying, but not a big deal for me at least. The tables where I need history
    usually never need write concurrency on the same ID. And if they do, it’s not
    hard to add a retry loop around the writes… though of course, it adds a pitfall
    you need to be aware of.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这很烦人，但至少不是什么大问题。我通常需要历史记录的表通常不需要在相同的ID上进行写并发。如果确实需要，添加一个重试循环以处理写入就不难……当然，这会增加你需要注意的陷阱。
- en: 'Trying to fix this by using `CLOCK_TIMESTAMP()` instead of `NOW()` will only
    make things worse in my opinion. If you desire to insert multiple items at the
    same time, usually none of them will have the same timestamp. That makes certain
    queries on the history table technically wrong:'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`CLOCK_TIMESTAMP()`而不是`NOW()`来修复这个问题只会让情况变得更糟，在我看来。如果你希望同时插入多个项目，通常它们的时间戳都不会相同。这会导致一些对历史表的查询在技术上是错误的：
- en: 'Imagine you have a list and list element table, and a user creates a new list
    with 10 elements. With `CLOCK_TIMESTAMP()`, you now end up with 11 different timestamps:
    One for the list root, and 10 for each list element. If you wondered what the
    list looked like when it was first created, you’d first have to fetch the list
    root. Then you have to fetch all elements that were in the list, say, as of 1
    second after it was created, to be relatively sure all the list elements are also
    returned. But any attempt at recreating the state at some arbitrary time in the
    past may end up with partial/corrupt results. For that reason, I highly recommend
    avoiding this, and rather using some other method to persist history if you really
    need it.'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个列表和列表元素表，用户创建了一个有10个元素的新列表。使用`CLOCK_TIMESTAMP()`后，你现在有了11个不同的时间戳：一个用于列表根，每个列表元素有10个。如果你想知道列表在最初创建时的样子，你首先需要获取列表根。然后，你必须获取所有在列表中的元素，比如说，在创建后1秒钟内，以确保所有列表元素也被返回。但是，任何试图在过去某个任意时间重建状态的尝试可能会导致部分/损坏的结果。因此，我强烈建议避免这样做，而是在确实需要时使用其他方法来持久化历史记录。
- en: Alternatives
  id: totrans-split-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代方案
- en: A trigger-based model seems to me like the best one if you have to use Postgres,
    but there are some alternatives you may want to consider.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须使用Postgres，基于触发器的模型对我来说似乎是最好的选择，但你可能想考虑一些替代方案。
- en: Do You Need The History?
  id: totrans-split-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你需要历史记录吗？
- en: 'There is added complexity here, and there is an increased chance of transactions
    failing because of overlapping timestamps that you can’t really prevent. That
    begs the question: Do you really need the history?'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里增加了复杂性，同时由于重叠的时间戳增加了事务失败的可能性，这是你无法真正防止的。这引出了一个问题：你真的需要历史记录吗？
- en: 'My “controversial” opinion is that, in this day and age, I feel the true question
    is really a matter of whether you can afford it performance-wise, and not whether
    it’s too complex. This particular implementation of persisting history is probably
    not very fast, but it is conceptually simple: Whenever you do something to a table,
    that action is stored in a history table. The original table is intentionally
    identical to what you’re used to. If you really don’t like the potential GiST
    conflicts, you can relax the constraints to get identical behaviour to what you’re
    used to. In that case, the only difference is the insert/delete/update performance.'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: Yes, there are many cases where it’s clearly bonkers to retain the history,
    but I also think many people assume storing the history is costlier than it actually
    is^(. If you’re not sure, try it and see how it goes. Since your original table
    will be untouched, it’s not hard to roll back.)
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: 'For me, there are two reasons I think you should consider it, even if you have
    no immediate plans to expose this to your users:'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: First, there will be a time when a specific customer needs their data rolled
    back to an earlier version. That could either be because of accidental deletes,
    rogue actors, or even a bad deployment that corrupted data for certain customers.
    While this doesn’t replace backups by a long shot, it’s a lot faster and easier
    to do
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It will of course end up being a little more complex than that in practice,
    depending on the data model and how fine-grained you want to be. But it’s less
    effort than setting up the backup server, bridging it with a foreign data wrapper,
    and then finally doing the inserts in exactly the same manner as above, before
    cleaning up the backup server afterwards.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: There are other cases too, like debugging a transient issue one of your users
    had. I could go on, but it feels like repeating the sales pitch for [Datomic](https://www.datomic.com/).
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The second reason relates to the gut reaction of saying “We don’t need it”:
    If you don’t have time travel abilities readily available, you can’t explore and
    play with them. This, in turn, means you won’t really think of them when developing
    new functionality for your customers. At the risk of sounding like a techbro:
    I think it stifles innovation. Do you *really* think there’s no value for it somewhere
    in your system in the future?'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, yeah, this sounds a lot like future-proofing. To be clear, YAGNI isn’t
    wrong, but I only think it only applies when there’s either
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: significant overhead (either in terms of implementation complexity or system
    performance)
  id: totrans-split-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: something that can be retroactively implemented (i.e. no data loss)
  id: totrans-split-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and system-versioned tables are neither.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: '… well, uh, let me clarify here. The current implementation I’ve shown you
    requires a lot of work when you make new tables. Which is a good transition to
    my next point:'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: Use a Database Suited for the Task
  id: totrans-split-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing all of these long triggers yourself just because Postgres doesn’t support
    it is a bit stupid. If you want an open-source alternative, perhaps MariaDB isn’t
    too bad? It supports [SQL:2011](https://mariadb.com/kb/en/system-versioned-tables/)
    and even has support for bitemporality if you want to go even further.
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Postgres不支持而自己编写所有这些长触发器有点愚蠢。如果你想要一个开源替代方案，也许MariaDB并不算太糟？它支持[SQL:2011](https://mariadb.com/kb/en/system-versioned-tables/)，甚至支持如果你想进一步的bitemporality。
- en: Of course, I’d be amiss if I didn’t mention [Datomic](https://www.datomic.com/).
    It is a great database, although not open-source, and language support is rather
    limited (only Java/Clojure officially). For the ones in Microsoft land, [SQL Server](https://learn.microsoft.com/en-us/sql/relational-databases/tables/temporal-tables?view=sql-server-ver16)
    has great support for SQL:2011 as well, from what I gather.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我不提到[Datomic](https://www.datomic.com/)，那就不太合适了。这是一个很棒的数据库，尽管不是开源的，语言支持相当有限（官方只支持Java/Clojure）。对于那些在微软领域的人，[SQL
    Server](https://learn.microsoft.com/en-us/sql/relational-databases/tables/temporal-tables?view=sql-server-ver16)据我所知对SQL:2011有很好的支持。
- en: As mentioned, this is aimed at user data generated by someone clicking or typing
    around on a webpage, mutating some content of theirs. But for IoT data, you’d
    like some other tool than temporal tables, and if you’re big enough, you probably
    want to use an OLAP database for OLAP stuff.
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，这是针对由某人在网页上点击或输入生成的用户数据。但对于物联网数据，你可能希望使用比时间表更好的工具，如果规模足够大，你可能希望使用OLAP数据库进行OLAP工作。
- en: Sloppy-Paste or Eldritch Horrors
  id: totrans-split-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粗制滥造或离奇恐怖
- en: I am stuck with Postgres, both because that’s what I already got, but also because
    I heavily use PostGIS. Migrating away is simply not an option, so I have to make
    do with what I have.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在被Postgres卡住了，一方面是因为这是我已经有的东西，另一方面是因为我大量使用PostGIS。迁移根本不是一个选择，所以我必须利用我所拥有的。
- en: What I like about the trigger solution is that it is – aside from the column
    expansion hack – not terribly hard to understand. The problem is that it’s very
    verbose, and after being burnt from a couple of copy-paste mistakes in the past,
    I’d rather have a single trigger for every table if possible.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢触发器解决方案的原因在于，除了列扩展黑客之外，理解起来并不是非常困难。问题在于它非常冗长，在过去由于几次复制粘贴错误，我宁愿每个表只有一个触发器。
- en: 'It is possible… though it does not look pretty. Here’s what the update trigger
    looks like after we make the history table and ID field into input parameters:'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的……尽管看起来并不美观。在我们将历史表和ID字段转换为输入参数后，更新触发器的样子如下：
- en: '[PRE11]'
  id: totrans-split-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (The insert and update triggers are similar, so I won’t go over them here.)
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: （插入和更新触发器相似，所以我这里不再赘述。）
- en: 'To factor out the history table and ID field, we have to use [`EXECUTE`](https://www.postgresql.org/docs/16/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN),
    which makes the entire thing feel even more hacky. It looks ugly, and if you’re
    not familiar with `EXECUTE` or the previously mentioned column expansion magic,
    it may feel outright eldritch. However, I think this is better than the first
    attempt at the trigger implementation for one big reason. And that is best shown
    by using it in practice:'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分离历史表和ID字段，我们必须使用[`EXECUTE`](https://www.postgresql.org/docs/16/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN)，这使得整个过程看起来更加黑客。它看起来很丑陋，如果你不熟悉`EXECUTE`或前面提到的列扩展魔法，可能会感觉完全离奇。不过，我认为这比第一次尝试的触发器实现要好得多。而这最好通过实际使用来展示：
- en: '[PRE12]'
  id: totrans-split-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is much less verbose to use if you want to retain history for multiple
    tables!
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保留多个表的历史记录，使用这种方式要少得多！
- en: While it’s true that the query can’t be type-checked ahead of time, the original
    trigger won’t be either. *We have to run them to verify that they don’t refer
    to wrong tables or ids*. If that’s the case, then we should pick the alternative
    that reduces the chance of a sloppy search-replace.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然查询无法提前进行类型检查，但原始触发器也不会。*我们必须运行它们来验证它们是否引用了错误的表或ID*。如果是这样，那么我们应该选择减少粗制滥造搜索替换机会的替代方案。
- en: 'And this new implementation does that! This trigger has the history table and
    the ID field in only two locations – the input arguments, whereas the original
    trigger implementation had them spread out all around in 7 different locations.
    Also, let’s face it: copy-pasting some big triggers for every single table we
    want system versioned just wouldn’t feel right.'
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个新实现正是如此！这个触发器只在两个位置有历史表和ID字段 - 输入参数中，而原始的触发器实现则在7个不同的位置散布着它们。另外，面对现实吧：对每个我们想要系统版本管理的表格复制粘贴一些大触发器真的不太合适。
- en: Summary
  id: totrans-split-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: The full implementation is over in the [time-travelling-todo-lists-in-postgres](https://github.com/hypirion/time-travelling-todo-lists-in-postgres)
    repository, and the triggers are in the migration file [`migrations/001_history_triggers.up.sql`](https://github.com/hypirion/time-travelling-todo-lists-in-postgres/blob/main/migrations/001_history_triggers.up.sql).
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的实现在[Postgres中的时间旅行待办事项列表](https://github.com/hypirion/time-travelling-todo-lists-in-postgres)仓库中，而触发器则在迁移文件[`migrations/001_history_triggers.up.sql`](https://github.com/hypirion/time-travelling-todo-lists-in-postgres/blob/main/migrations/001_history_triggers.up.sql)中。
- en: 'As I mentioned, this isn’t perfect: You have some big pitfalls related to table
    modifications, it adds a risk of having concurrent updates break, and other databases
    should have a much better implementation than my three triggers. It’s probably
    not suitable for large databases either.'
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，这并不完美：你会遇到一些与表格修改相关的大坑，它增加了并发更新中断的风险，而其他数据库应该有比我的三个触发器更好的实现。它可能也不适合大型数据库。
- en: But if you’re stuck with Postgres, I think this is fine. However, I think you
    should be aware of how the implementation works in detail, as there are a couple
    of ways to shoot yourself in the foot. And if you’ve come this far down, you hopefully
    do!
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你被迫使用Postgres，我认为这也可以。然而，我认为你应该详细了解实现的工作原理，因为有几种方法会让你自讨苦吃。而且如果你已经走到了这一步，希望你真的会注意！
