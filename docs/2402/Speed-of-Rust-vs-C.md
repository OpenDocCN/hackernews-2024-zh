<!--yml

类别：未分类

日期：2024-05-29 13:19:50

-->

# Rust 与 C 的速度比较

> 来源：[https://kornel.ski/rust-c-speed](https://kornel.ski/rust-c-speed)

用 Rust 编写的程序的运行时速度和内存使用应该与用 C 编写的程序大致相同，但这两种语言的编程风格差异很大，很难一概而论它们的速度。这是它们相同之处、C 更快的地方以及 Rust 更快的地方的总结。

免责声明：这并不意味着这是一个揭示这些语言无可辩驳真相的客观基准。理论上这些语言可以实现的能力与它们在实践中的应用有显著差异。这个比较基于我自己的主观经验，其中包括遇到截止日期、写入错误和懒惰。我使用 Rust 作为主要语言已有四年多，而之前使用 C 十年。我这里特别是与 C 进行比较，而不涉及与 C++ 比较，后者会有更多的“如果”和“但是”，我不想深入讨论。

简而言之：

+   Rust 的抽象是一把双刃剑。它们可以隐藏次优代码，但也使得算法改进和利用高度优化的库变得更容易。

+   我从不担心使用 Rust 会遇到性能瓶颈。总是有`unsafe`的逃逸口，可以进行非常底层的优化（而且通常不需要）。

+   无畏并发是真实的。尽管借用检查器偶尔会显得有些尴尬，但这在使并行编程变得*实用*方面得到了回报。

总的感觉是，如果我能花费无限的时间和精力，我的 C 程序理论上会和 Rust 一样快，甚至更快，因为理论上没有什么 Rust 能做而 C 做不到的。但实际上，C 的抽象较少，标准库较原始，依赖情况糟糕，而我没有时间每次都最优化地重造轮子。

### 两者都是“可移植汇编语言”

Rust 和 C 都可以控制数据结构的布局、整数大小、堆栈与堆内存分配、指针间接引用，并且通常能够将其转换为易于理解的机器码，而编译器几乎不会插入任何“魔法”。Rust 甚至承认字节有 8 位并且有符号整数可能溢出！

尽管 Rust 拥有像迭代器、特质和智能指针这样的高级构造，但它们设计成可以可预测地优化为直接的机器码（即“零成本抽象”）。Rust 类型的内存布局很简单，例如，可增长的字符串和向量的布局正是 `{byte*, capacity, length}`。Rust 没有像移动或复制构造函数这样的概念，因此对象的传递保证不会比传递指针或`memcpy`更复杂。

借用检查只是编译时的静态分析。它并不*执行*任何操作，生命周期信息甚至在代码生成之前完全被剥离。没有自动装箱或类似的聪明技巧。

Rust在“愚蠢”代码生成器方面还有一些不足之处是[展开](https://github.com/rust-lang/project-ffi-unwind)。虽然Rust不使用异常进行正常的错误处理，但恐慌（未处理的致命错误）可以选择像C++异常一样行为。可以在编译时禁用它（panic = abort），但即使这样，Rust也不喜欢与C++异常或`longjmp`混合使用。

### 同样老旧的LLVM后端

Rust与LLVM有很好的集成，因此支持链接时优化，包括ThinLTO甚至跨C/C++/Rust语言边界的内联。还有基于性能的优化。尽管`rustc`生成的LLVM IR比`clang`更冗长，但优化器仍然可以处理得很好。

我的一些C代码在使用GCC编译时可能比LLVM快一些，而且目前还没有[Rust的GCC前端](https://github.com/Rust-GCC/gccrs)，因此Rust在这方面有所欠缺。

理论上，由于更严格的不可变性和别名规则，Rust允许比C更好的优化，但实际上目前还没有实现。超越C的优化仍在LLVM中进行中，因此Rust尚未充分发挥其潜力。

### 两者允许手动调优，只有少数例外情况

Rust代码的低级和可预测性足以让我手动调优将其优化为什么样的汇编代码。Rust支持SIMD指令，对内联、调用约定等有良好控制。Rust与C相似到足以使C性能分析器通常可直接用于Rust（例如，我可以在一个Rust-C-Swift堆栈的程序上使用Xcode的Instruments）。

一般来说，当性能绝对关键且需要手动优化到最后一位时，优化Rust与优化C并没有太大不同。

有一些低级特性Rust没有适当的替代品：

+   *computed* goto。在Rust中，可以将“无聊”的`goto`用其他结构替换，如`loop {break}`。在C中，许多`goto`用于清理工作，而Rust由于RAII/destructors不需要。然而，有一个非标准的`goto *addr`扩展在解释器中非常有用。Rust无法直接执行（可以编写一个`match`并*希望*它会优化），但如果需要解释器，我会尝试利用[Cranelift JIT](https://lib.rs/crates/cranelift)。

+   `alloca`和C99的可变长度数组。即使在C中也是[有争议的](https://www.phoronix.com/scan.php?page=news_item&px=Linux-Kills-The-VLA)，因此Rust远离它们。

值得注意的是，Rust目前只支持一种16位架构。[一级支持](https://forge.rust-lang.org/platform-support.html)主要集中在32位和64位平台。

## Rust的小额外开销

然而，如果Rust没有手动调优，可能会引入一些低效率：

+   Rust的隐式类型转换和仅使用`usize`进行索引驱使用户在任何地方都使用这种类型，即使较小的类型也足够。这与在C中使用32位`int`作为流行选择形成对比。在64位平台上使用`usize`进行索引更容易优化，而无需依赖未定义行为，但额外的位可能会增加对寄存器和内存的压力。

+   在Rust中，对于字符串和切片，始终传递指针*和大小*。直到我将几个代码库从C移植到Rust，我才意识到有多少C函数只接受指向内存的指针，而不包含大小，并且希望一切顺利进行（大小间接从上下文中知道，或者仅仅假定足够大以完成任务）。

+   不是所有的边界检查都被优化掉。`for item in arr`或`arr.iter().for_each(…)`和它们一样高效，但如果需要`for i in 0..len {arr[i]}`这种形式，性能取决于LLVM优化器能否证明长度匹配。有时它无法证明，边界检查会阻碍自动向量化。当然，针对这种情况有各种安全和不安全的解决方法。

+   在Rust中，“巧妙”的内存使用被视为不良行为。在C中，任何手法都可以。例如，在C中，我可能会诱惑性地重用为一个目的分配的缓冲区，以供以后使用（这种技术称为HEARTBLEED）。对于可变大小数据，使用固定大小的缓冲区（例如`PATH_MAX`）是方便的，以避免（重新）分配不断增长的缓冲区。在惯用的Rust中，仍然可以对内存分配进行很多控制，并且可以执行基本的操作，如内存池、将多个分配组合成一个、预分配空间等，但总体上它倾向于引导用户朝向“乏味”的内存使用。

+   在借用检查规则使事情变得困难的情况下，简单的方法是进行额外的复制或使用引用计数。随着时间的推移，我学会了一些借用检查器的技巧，并调整了我的编码风格，使得这种情况不再经常发生。这从未成为一个*主要*问题，因为必要时总有“原始”指针作为后备。

    Rust的借用检查器因“讨厌双向链表”而臭名昭著，但幸运的是，现代硬件上的链表确实慢（缓存局部性差，无法向量化）。Rust标准库有链表，以及更快和借用检查器友好的容器可供选择。

    借用检查器无法容忍的另外两种情况是：内存映射文件（来自进程外的魔法更改违反了引用的不可变性和排他性语义）和自引用结构体（按值传递结构体会使其内部指针悬空）。这些情况要么使用和C语言中一样安全的原始指针，要么进行心智体操以在其周围创建安全的抽象。

+   对于 Rust 来说，单线程程序根本就不存在这个概念。Rust 允许个别数据结构为了性能而不是线程安全，但任何可以在线程之间共享的东西（包括全局变量）都必须同步或标记为 `unsafe`。

+   我总是忘记 Rust 的字符串支持一些廉价的原地操作，比如 `make_ascii_lowercase()`（直接等价于我在 C 中所做的），而不必要地使用支持 Unicode 的、复制的 `.to_lowercase()`。说到字符串，UTF-8 编码并不像看起来那么大的问题，因为字符串有 `.as_bytes()` 视图，所以如果需要可以以不考虑 Unicode 的方式处理它们。

+   libc 极力使 `stdout` 和 `putc` 保持相对较快。Rust 的 libstd 则没有那么多魔法，所以 I/O 如果没有包裹在 `BufWriter` 中，就不会被缓冲。我见过有人抱怨他们的 Rust 比 Python 慢，因为 Rust 按照字节逐个刷新结果，正如其所需。

### 可执行文件大小

每个操作系统都内置了大约 30MB 的标准 C 库，C 可执行文件可以免费获取，例如一个小的“Hello World” C 可执行文件实际上无法打印任何内容，它只能调用操作系统中附带的 `printf`。Rust 不能依赖操作系统内置 *Rust* 标准库，因此 Rust 可执行文件捆绑了自己的标准库（300KB 或更多）。幸运的是，这是一次性开销，可以通过 [减小](https://github.com/johnthagen/min-sized-rust) 来降低。对于嵌入式开发，可以关闭标准库，Rust 将生成“裸”代码。

就每个函数而言，Rust 代码的大小与 C 相当，但存在“泛型膨胀”的问题。泛型函数会为其使用的每种类型生成优化版本，因此可能会得到相同函数的 8 个版本。[`cargo-bloat`](https://lib.rs/cargo-bloat) 有助于找出这些问题。

在 Rust 中使用依赖非常简单。与 JS/npm 类似，有一种制作小型单一用途库的文化，但它们确实会累积。最终，我的所有可执行文件都包含了Unicode 标准化表、7 种不同的随机数生成器和支持 Brotli 的 HTTP/2 客户端。`cargo-tree` 对于去重和清理非常有用。

## Rust 的小胜利

我说了很多关于开销的话，但 Rust 也有能够更高效更快的地方：

+   C 库通常返回其数据结构的不透明指针，以隐藏实现细节并确保每个结构实例只有一个副本。这会造成堆分配和指针间接访问的成本。Rust 的内置隐私、单所有权规则和编码约定使得库能够在不需要间接访问的情况下公开其对象，这样调用者可以决定是将其放在堆上还是栈上。栈上的对象可以被非常有效地优化，甚至可以完全优化掉。

+   Rust默认可以内联来自标准库、依赖项和其他编译单元的函数。在C语言中，我有时不愿意分割文件或使用库，因为这会影响内联，并需要微观管理头文件和符号可见性。

+   结构体字段被重新排序以最小化填充。使用`-Wpadding`编译C语言代码会显示我经常忘记这个细节。

+   字符串在其“胖”指针中编码其大小。这使得长度检查快速进行，消除了意外的O(n²)字符串循环的风险，并允许在原地进行子字符串操作（例如将字符串拆分为标记），而不需要修改内存或复制添加`\0`终结符。

+   与C++模板类似，Rust为每种使用的类型生成通用代码的副本，因此像`sort()`这样的函数和哈希表这样的容器始终针对其类型进行优化。在C语言中，我必须在宏的hack之间选择，或者使用在`void*`上运行且运行时变量大小的效率较低的函数。

+   Rust迭代器可以组合成链，这些链一起进行优化。因此，我可以调用`it.buy().use().break().change().upgrade().mail()`，它会编译成一个`buy_use_break_change_mail_upgrade(it)`，优化为一次联合通行，而不是多次重写同一缓冲区。`(0..1000).map(|x| x*2).sum()` 编译为 `return 999000`。

+   类似地，存在`Read`和`Write`接口，允许函数流式传输未缓冲的数据。它们很好地组合在一起，因此我可以将数据写入流中，流可以在传输时即时计算数据的CRC，如果需要还可以添加帧/转义，压缩数据，并将其写入网络，所有这些操作都可以在一次调用中完成。我可以将这样的组合流作为输出流传递给我的HTML模板引擎，因此现在每个HTML标签都足够智能，可以自动发送经过压缩的内容。底层机制只是一堆简单的`next_stream.write(bytes)`调用的金字塔，所以技术上并没有什么能阻止我在C语言中做同样的事情，除了C语言中缺乏特性和通用性意味着实际上很难做到这一点，除非使用在运行时设置的回调，但这并不高效。

+   在C语言中过度使用线性搜索和链表是完全合理的，因为谁会去维护又一个半成品的哈希表实现呢？没有内置容器，依赖项令人头疼，所以我会采取捷径来完成工作。除非绝对必要，否则我不会费心编写一个复杂的B树实现。我会使用`qsort` + `bisect`，然后结束工作。相反，在Rust中，只需1到2行代码就可以获得各种高质量容器的实现。这意味着我的Rust程序每次都可以使用适当的、非常优化的数据结构。

+   这些天似乎所有事情都需要 JSON。Rust 的 `serde` 是世界上最快的 JSON 解析器之一，它直接解析成 Rust 结构体，因此使用解析后的数据非常快速和高效。

## Rust 的巨大胜利

Rust 强制所有代码和数据的线程安全，即使在第三方库中，即使那些代码的作者没有注意线程安全性。所有东西都要么保证特定的线程安全性，要么不允许跨线程使用。如果我编写的任何代码不是线程安全的，编译器会准确指出不安全的地方。

这与 C 的情况截然不同。通常情况下，除非清楚地文档说明，否则不能信任任何库函数是线程安全的。程序员需要确保所有代码都是正确的，编译器通常无法帮助解决任何问题。多线程的 C 代码承载更多的责任和风险，所以假装多核 CPU 只是一时的热潮，并且想象用户有更好的事情可做，显得非常有吸引力。

Rust 保证不存在数据竞争和内存不安全（例如跨线程使用后释放的 bug）。不仅仅是在仪器化构建中通过启发式方法或运行时发现的一些竞争，而是 *所有* 地方都没有数据竞争。这是救命的，因为数据竞争是最糟糕的并发 bug。它们会在用户的机器上发生，但不会在我的调试器中发生。还有其他类型的并发 bug，比如对锁定原语的不良使用导致高层次的逻辑竞争条件或死锁，Rust 无法消除它们，但通常更容易复现和修复。

在 C 中，我不敢在简单的 `for` 循环上使用超过一两个 OpenMP pragma。我曾尝试过更冒险的任务和线程，但每次都后悔不已。

Rust 拥有出色的数据并行性、线程池、队列、任务、无锁数据结构等库。借助这些构建块和类型系统强大的安全网，我可以轻松地并行化 Rust 程序。在某些情况下，仅仅将 `iter()` 替换为 `par_iter()` 就足以运行，如果编译通过，那就能工作了！这并不总是线性加速（阿姆达尔定律是残酷的），但通常能使工作量相对较少的情况下加速 2 倍至 3 倍。

Rust 和 C 库在文档线程安全性方面有一个有趣的区别。Rust 对线程安全性的特定方面有自己的词汇，例如 `Send` 和 `Sync`，还有 guards 和 cells。在 C 中，并没有类似于“你可以在一个线程上分配它，在另一个线程上释放它，但不能同时从两个线程使用”的说法。Rust 用数据类型描述线程安全性，这适用于所有使用它们的函数。而在 C 中，线程安全性通常在单个函数和配置标志的上下文中讨论。Rust 的保证通常是在编译时，或至少是无条件的。而在 C 中，常见的是“只有在设置 turboblub 选项为 7 时才是线程安全的”。

## 总结一下

Rust 在足够低级，以至于如果必要的话，可以像 C 一样优化以达到最大性能。高级抽象、简易内存管理以及丰富的库的可用性倾向于使 Rust 程序拥有更多的代码，做更多的事情，如果不加以控制，可能会导致膨胀。然而，Rust 程序也能够进行相当好的优化，有时比 C 还要好。虽然 C 适合在字节和指针级别编写最小化代码，但 Rust 具有强大的功能，可以高效地将多个函数甚至整个库组合在一起。

但最大的潜力在于，大多数 Rust 代码可以无畏地并行化，即使等效的 C 代码可能并行化起来太冒险。在这一方面，Rust 比 C 更成熟。
