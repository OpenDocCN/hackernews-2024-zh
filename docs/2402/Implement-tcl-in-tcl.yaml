- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:49:28'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Implement tcl in tcl
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://wiki.tcl-lang.org/page/Implement+tcl+in+tcl](https://wiki.tcl-lang.org/page/Implement+tcl+in+tcl)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Maybe someone has already done this. But the question in my mind is how much
    of Tcl can be implimented in Tcl itself. Obviously you can't implement system
    calls in Tcl, but you could implement just about everthing else. What commands/parts
    of Tcl would be in the minimal set? [Earl Johnson](/page/Earl+Johnson)
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: '"set" both scalar and array modes.'
  id: totrans-split-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"eval" command'
  id: totrans-split-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"unknown"'
  id: totrans-split-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"string index" command'
  id: totrans-split-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"string length" command'
  id: totrans-split-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"lindex" command'
  id: totrans-split-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"llength" command'
  id: totrans-split-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"list" command'
  id: totrans-split-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: what else???
  id: totrans-split-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Things that could be simulated in Tcl (theoretically)
  id: totrans-split-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: interpreters (design?).
  id: totrans-split-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: namespaces (design?).
  id: totrans-split-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: expr (design?).
  id: totrans-split-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: callstack (design?) .
  id: totrans-split-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: proc (design?) .
  id: totrans-split-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: if/while/switch/for/foreach.
  id: totrans-split-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: regexp (sounds hard) .
  id: totrans-split-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: package system (design?) .
  id: totrans-split-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: traces (design?).
  id: totrans-split-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: event loop (design?).
  id: totrans-split-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: glob (design?).
  id: totrans-split-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: expr
  id: totrans-split-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'regexp *([Lars H](/page/Lars+H): You get a bit of the way with [grammar_fa](/page/grammar%5Ffa).)*'
  id: totrans-split-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What I don't expect to be done
  id: totrans-split-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C API
  id: totrans-split-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Things that need system calls
  id: totrans-split-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other languages are self hosting like this
  id: totrans-split-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C => c compiler
  id: totrans-split-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python => PyPy
  id: totrans-split-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Smalltalk
  id: totrans-split-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Others??
  id: totrans-split-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course I expect that this TclTcl would be very slow, but interesting, and
    very easy to port to embedded systems.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: '[SS](/page/SS) 12Oct2004: One day for fun I implemented a subset of Tcl in
    Tcl, with some more work may run non trivial programs. Consider this program BSD-licensed.'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '* * *'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: 'I have got problems testing it (error: invalid command name "::macro::parser").'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: This is because the call to ::macro::parser doesn't reference any known function.
    When I changed the call to LctParser, everything worked for me. I have taken the
    liberty of making the change in the code above. -RL
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: 'I suppose also that the parser would have problems with some special ugly code
    as follow, which is accepted by the original tcl parser:'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Anyway programming tcl in tcl is very interesting idea if one wants to test
    experimental tcl interpreters or build in new functions which are not supported
    by original interpreter
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: '[Lars H](/page/Lars+H): I think several of those would actually be handled
    OK, but'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'is not (the only extra rule in command substitution nesting is that '']'' terminates
    a command in places where '';'' would, so brackets need not nest properly as LctSubstCmd
    assumes). Backslash substitution is missing entirely. Also the following isn''t
    handled correctly:'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The left brace only has special powers if it is the first character in a word.
    What worries me most about the above parser is however:'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: its use of a variable $inside (that is too simple to keep track of the state
    of a correct Tcl parser), and
  id: totrans-split-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the one big loop over characters in the input (hard to analyse, because there
    are so many cases to consider, and thus likely to buggy).
  id: totrans-split-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more complete Tcl parser, available here on this Wiki, see [parsetcl](/page/parsetcl).
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: '[Category Application](/page/Category+Application) - [Category Tcl Implementations](/page/Category+Tcl+Implementations)'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[应用类别](/page/Category+Application) - [Tcl 实现类别](/page/Category+Tcl+Implementations)'
