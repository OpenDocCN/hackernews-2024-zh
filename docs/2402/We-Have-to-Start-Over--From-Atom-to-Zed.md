<!--yml

category: 未分类

date: 2024-05-27 14:57:03

-->

# We Have to Start Over: From Atom to Zed

> 来源：[https://zed.dev/blog/we-have-to-start-over](https://zed.dev/blog/we-have-to-start-over)

# We Have to Start Over: From Atom to Zed

*在上一次与Nathan、Max和Antonio的对话之后——Zed的三位联合创始人——我仍然有很多问题要问：你们为什么做出了这些技术选择？Rust对Zed有多重要？你们是否有意识地决定如今拥有技术栈？你们如何决定什么要打磨和一劳永逸地建设，什么要更快地发布？*

*幸运的是，他们再次与我坐下来回答了我的问题。*

*接下来是我们一小时深度对话的编辑版实录。我尽量保持原意和意义，同时去掉了嗯嗯、喜欢、你知道的、以及会话中的停顿和修正。*

*(你可以在我们的YouTube频道观看完整对话](https://www.youtube.com/watch?v=w894KLbapLw)。)*

**Thorsten: 你们三个人一起工作了多久了？是10年吗？**

**Nathan**: Ungefähr. （德语，意为：“差不多是这样。”）

**Max**: 是的，差不多是这样。

**Antonio**: 我想大约是10年。2014年，是的。

**Thorsten: [Atom](https://en.wikipedia.org/wiki/Atom_(text_editor)) — 那是10年前。你们共同在Atom上工作，然后说“我们要建立Zed。”很明显你对想要构建的东西有一个愿景。你还做了一些非常独特的技术选择。你使用Rust，它支持GPU加速，CRDTs。我在想：这些技术选择与Zed的愿景有多大的关联？技术在其中扮演了多大的角色？**

**Nathan**: 我的看法是，对于Zed的愿景，从我来看，它只是Atom最初愿景的一个更精细和充实的版本，因为我认为我们在开始Atom时所做的技术选择以及技术成熟度水平都有所不足。

但我一直以来的目标是一个轻量级的编辑器，简约而我喜欢使用的，感觉像文本编辑器，但在需要时具有IDE的功能，而不会在体验上感到缓慢和UI上的沉重感，但仍然强大。这早期就是我想要的。并且要具备可扩展性。

你知道，我记得使用Emacs，觉得它很酷，你可以扩展它，但你在字符级别上操作。所以那也是最初的愿景的一部分，现在Max通过[Tree-sitter](https://tree-sitter.github.io/tree-sitter/)实现了。你知道，基本上是可脚本化的。我们现在还不能脚本化，但我们会到达那个地步。但当我们可以时，我们将拥有比仅仅在字符或者在Emacs中做的任何事情更丰富的文本表示。我想，他们现在可能也有这个功能，对吧？因为Max写了tree-sitter。

**Max：听说他们确实有。**

**Nathan：所以这很酷。但无论如何，那都是愿景的一部分。但事实证明，在Atom中并没有实现。我的意思是，当Chris聘请我来工作Atom时，我几乎没有加入[意味着：加入GitHub来工作Atom]，因为我害怕使用web技术，担心它不能达到预期的效果。

但老实说，我不知道当时我可以使用的东西是否会更好，因为当时没有Rust。所以只能用C，C++。我不知道，当我们创建Atom时，在基础算法等方面，我可能会遇到困难。而且在学习文本编辑的基本算法时，C++可能会让我进展缓慢。所以我觉得事情发生的方式是必须发生的。

我们在Atom到达了一个特定的阶段。到了2017年我们发布了[Teletype](https://github.com/atom/teletype)，感觉，好吧，不再是我们自己的无知在阻碍我们，实际上是平台在阻碍我们到了这一点。这确实是开始感觉的方式。就在JavaScript中，JavaScript中的数组...你以为你有一个对象数组，但实际上你有一个指向对象的指针数组。所以每次你遍历它，你都在追踪它。你无法控制内存。有一些垃圾收集器暂停正在发生，你无法控制。你只是看着这个该死的东西的概要。

**Thorsten：在你工作Atom时，是否有特定的时刻你曾说“哦，我希望我们用X来构建它”？还是一直有小问题积累成了大问题？安东尼奥现在点头了。**

**安东尼奥：说到在这个项目上工作了10年：我记得在Atom的我的第一个项目之一 —— 我不知道你还记得不，Nathan —— 就是加速行布局。基本上，我们发现行布局非常慢。我记得尝试在iframe中渲染行。我记得使用Canvas，测量文本，和所有这些API...我不知道，Canvas API和浏览器API不太一样，所以你无法正确测量文本。iframe的东西还有其他一些奇怪的问题。

在Atom中的经历总是让人觉得费尽周折，试图去做本来应该很简单的事情。布局一些行，并读取光标在这两个字符之间的位置。这似乎从根本上是可以做到的，但总是感觉工具不在我们的控制之中。它们离我们想要做的事情还差得很远。

**Nathan**: 那真是个噩梦。我是说，讽刺的是我们创建Electron是为了创造Atom，但我想象不出还有比用Electron来做代码编辑器更糟糕的应用了。对于一些更简单的东西，也许还行，内存占用确实很糟糕，但勉强能用。但对于代码编辑器来说，你根本无法像我认为你需要的那样直截了当地做这些事情。总是要费尽周折。

所以在2017年的某个时候，我记得坐在那里，在我的日记本Atom中写字 —— 那个晚上，我想到了：我们必须重新开始。我们必须重新开始，这样行不通，我们永远也达不到想要的目标。VS Code在让它走到了尽头时做了令人钦佩的工作。我相信技术会有增量改进，但我只是想要更多。

所以那时候的情况是：好的，我们应该怎么做呢？我一直在关注Rust，看过[Raph Levien](https://raphlinus.github.io/)关于Rust的一些文章。当时看来，这似乎是克服一些障碍的唯一可行路径。最初的想法是：我们是否可以用Rust编写这个东西的核心，同时保留Electron作为展示层呢？

所以我们就是一步一步地做出了我们选择的技术决策。即使在构建UI框架后，放弃了Electron，我们使用的是[Pathfinder](https://github.com/servo/pathfinder)，这是一个可以基本上做任意SVG展示的很酷的项目，但速度太慢了。所以我想：好的，我们要做自己的着色器？然后开始学习有关有符号距离场的知识。

真是挺有意思的。不是我不想解决更根本的问题，而是只能通过没有其他选择来迫使自己这么做。

我不应该说这只是我的想法，不仅仅是我。但这是从我的角度来看的……

**Thorsten: 听起来目标一直是尽可能快，尽可能轻量化。你们试图达到这个目标，但是用有的技术却做不到。然后Rust出现了。你们并不是从“我们需要一个GPU加速的编辑器”开始，而是从你们想要最快的编辑器开始，然后GPU加速是其中一种实现方式。是这样吗？**

**Nathan**: 是的，事实上，我们有这台计算机中的硬件，与其在某一时刻协商 DOM 节点在 DOM 中的情况，或者这些废话，我们可以直接问，这个像素应该是什么颜色？好的。如果我们可以编程决定屏幕上每个像素的颜色，或者尽可能并行地进行这样的决定 — 如果我们想要快一点，我们应该使用这个。

不过你知道的，我们有些勉强接受这一点，因为我根本不知道该怎么做。

**Thorsten: 现在，这有点是个棘手的问题，但我在过去三年里一直在用 Rust 进行开发，并且我的感受对它是复杂的。但两周前 Hacker News 上有人说，在 Zed 中的 find-all-matches 需要一秒钟，但在 Sublime Text 中它非常快，接近 200 毫秒。于是我和 Antonio 一起解决了这个问题，他编写了优化代码来处理缓冲区中的所有出现情况。但优化后的代码并不是“优化”代码：它没有使用任何不正当手段，没有 SIMD 或类似的东西。它是高级别的代码，其优化在于其假设不同：与其逐个循环执行任务，它的假设是找到所有结果。我们发布了这个优化后的版本，执行时间从 1 秒降低到了 4 毫秒。**

**Antonio**: 哈哈哈

**Thorsten: 我坐在那里，看着 4 毫秒，然后……嗯，我想：这会是一个愉快的午餐休息时间。但是 4 毫秒？像那样调用其他内部 API 的高级别代码？哇。所以我想问的是：Rust 有这些零成本抽象 — 你可以使用高层次的抽象来构建文本编辑器，但它仍然提供这种性能。你认为这是 Rust 的特定特性，还是如果你只是更好的 C++ 或者 C 程序员，你也可以用其他语言做到这一点？

**Antonio**: 也许你本来可以用 C 和 C++ 来做。我不知道。我是说，tree-sitter 是用 C 写的，对吧，Max？所以在 C 中写一个复杂的库或软件是可能的。不过每次我看 tree sitter 中的 C 代码时，我都会尖叫，因为对我来说太复杂了。我不知道。

就我个人而言，是的，Rust 处于一个很好的位置。如果不是编译时间太慢的话 — 这是我真的不喜欢的一件事，但也许是因为我们的项目太大了，我不知道。

但是确实很酷的是，你可以在这些抽象的基础上构建并仅仅依赖它们。我是说，我不确定零成本 — 每个抽象都有成本，我猜。

但总体而言，这个项目的问题在于…… 在 Atom 中，我们总是觉得不知道从哪里入手来提升性能。而在 Zed 中，我们可以做这个，也可以做那个，我们可以改进这个。就在上周，Nathan 和我讨论了如何改进 SumTree 的减法以更快地执行批量插入。

**Nathan**: 然后你实现了它，对吧？

**Antonio**: 是的。但是还没有发货。

**Nathan**: 太棒了。

**Max**: 我要说我们在 Atom 上确实做了很多 C++ — 我们做了很多。我们尝试过。而且它确实能工作，但是在 JavaScript 应用代码和 C++ 库代码之间有一个非常明显的区别。人们谈论性能时会说“把这个放到后台线程执行，不要在主线程执行”，我们会说“好的，我们可以做到”，但这意味着这里涉及的整个子系统需要完全放到 C++ 中以便共享内存。然后围绕此构建 JavaScript API，并确保它仍然看起来像是 JavaScript 代码的习惯用法，同时保留它在 JavaScript 写作时的所有这些特性。

只有在那之后，我们才能真正将这个任务移到后台线程。

写 JavaScript 代码与写 C++ 代码有很大的区别 — JavaScript 可以脚本化、可插拔和可覆盖 — 而 C++ 则具有核心能力，可以使用共享内存和多线程。

**Nathan**: Rust 被设计成多线程的。我记得当我尝试学习 Rust 并想要实现这个 [splay tree](https://en.wikipedia.org/wiki/Splay_tree)，因为 splay tree 在 Atom 中使用得非常频繁。至少有一段时间是这样 — 它实际上非常适合我们的需求，但它有父指针，非常像一个可变结构。

当我试图在 Rust 中构建这个时，这门语言与我作对。我想：这门语言真的能构建出任何真正的东西吗？其实我当时是有严重怀疑的。

所以我放弃了一段时间，然后又尝试了一次。这次我构建了一个写时复制的 B 树。以这种方式构建，使用了 `Arc`，这意味着它天生支持多线程。

当我按照语言和借用检查器的指示去做，按照 Rust 希望我做的方式去做时，感觉：哦，很酷。

现在我们有了这种表示 [ropes](https://en.wikipedia.org/wiki/Rope_(data_structure)) 的方法 — 这是 Zed 中的基本文本存储结构 — 在这种方法中，我们可以生成一个后台线程，这是 O(1) 的操作，只需将一个 `Arc` 推送到后台线程，并查看快照，等等。

这不仅仅是关于本地化的问题。我也认为 Rust 带来了创新。这门语言被设计成在多个线程和低级别上使用。

坦率地说，我觉得我可能有点像一个脚本小子，不太适合在 C++ 中表现良好。总是让我感到烦恼：这些可恶的文件，跳来跳去，所有这些深奥的规则。一个 C++ 大师能做到我们在 Rust 中做的吗？可能可以，但我不打算成为那种人。

**Thorsten**：所以 Antonio，你刚提到用 JavaScript 时，你不知道哪里能找到性能瓶颈。Max，你说，当你使用 C++ 或 JavaScript 时，想要实现一些异步操作时会感到一些限制。现在我们听说 Rust — 你可以突然在后台线程上异步执行操作，有更少的限制，你可以自由移动。**

**这让我想起了在 Zed 代码库中确实能看到的一些东西：你拥有整个栈。从做解析的 tree-sitter 到 GPU 加速的 UI 框架 GPUI，代码库中并没有很多第三方依赖。有一些库，但没有大型构建模块。**

**对你来说这有多重要？我们从顶到底完全掌握整个栈，完全理解它。这是有意识的选择还是因为 Max 构建了 tree-sitter，然后你做了这些，现在看看我们，我们重新构建了整个系统。**

**Max**：我不知道。我认为这有一些权衡，但到目前为止，能够随心所欲地决定我们想要的工作方式还是相当不错的。比如现在：我们想要使用 WASM 的语言扩展。Tree-sitter 本身并没有这个功能，但我们加了进去。

像这样的事情有很多。我们不想受限于可能无法完全按照我们希望方式呈现文本的某个 UI 框架，因为我们是文本编辑器，这很重要。但现在我们可以改变这一点。

感觉上并没有什么是禁忌的。

**Nathan**：我想说的是：这在我职业生涯早期与 jQuery 有关的经历非常影响我。jQuery 当时非常流行，我学习了 jQuery。我记得 [Yehuda](https://yehudakatz.com) 来到 [Pivotal](https://en.wikipedia.org/wiki/Pivotal_Labs)，讲解 jQuery，我觉得这太酷了。我被深深地震撼了。所以早期所有 Atom 的代码，信不信由你，全都是 jQuery。

而有趣的是，尽管学习了 jQuery，因为每个人都告诉我，“哦，你使用 jQuery 的原因是它可以在浏览器 API 的所有差异上提供抽象”，等等。我从来没有真正质疑过这一点。但后来有一天我坐下来只是简单地阅读了这些 DOM API。我觉得：你知道吗，这其实挺好的。也许会有一些缺失的功能或者其他什么问题 — 我不想贬低 jQuery，我认为它有它的作用 — 但我得出的结论是，如果我没有一个几乎能够满足我所有需求的抽象，那么我可能不想要这种抽象，而是去理解下面更底层的东西，并完全理解并做我需要做的事情。

这就是 GPUI 发生的事情。当我们在 2019 年开始开发 GPUI 时，已经有一些 UI 框架在进行中，但没有一个能满足我知道我们需要的功能。我也不理解它们。

但我知道我可以很容易地理解我们将依赖的基本原语 — 语言、图形框架。我知道我们可以学习这些东西，而且我们已经写了很多代码。如果我能建立一个我可以理解和学习的系统，那么我知道如果在底层系统上基本上是可能的，我们可以做我们需要做的事情。所以，对于 GPUI 至少是一种生存策略：我需要理解这一点，而理解它的最佳方法就是建立它。

**托尔斯滕**: 那有什么缺点？马克斯，你说有权衡。

**内森**: 花费太长了。很慢。

**安东尼奥 & 马克斯**: [笑]

**安东尼奥**: 引导新人也很棘手。你不能用所有人都熟悉的 X 框架，必须从头开始教这个代码库 — 你知道，30 万行代码。这是一个缺点。

但很酷的是，虽然这是一个缺点，同时也有其他人已经写过那些代码，并且可以向新人解释它。

或许会更慢，但再次，你保留了控制权。

**内森**: 我认为这是累积的。优势会累积，而劣势会折旧。有人刚刚在 GPUI 上构建了 [另一个应用](https://github.com/MatthiasGrandl/loungy)，所以现在我们有另一个利益相关者。拥有它的成本，我们将逐步摊销，拥有它的成本和好处将开始显现。

**托尔斯滕**: 有时人们会说：我只建立一次，然后再也不用碰它。而与之相反的可能是：你无法预测未来，[更差也更好](https://en.wikipedia.org/wiki/Worse_is_better)，等等。

**刚才你说的，自己建立一切会更慢，这里有一种“只为我们的使用场景构建一次并正确完成”的感觉：为我们想做的事情只需完美的抽象。与此同时，你们都有这种紧迫感。我的意思是，我四周加入，我觉得我们在快速前进，而且我们有很多事情要做。**

**你如何平衡这一点？你如何拥有你想要建立的巨大愿景，并在其中平衡说“我将编写着色器，我将完善我们如何渲染投影阴影或其他东西”？**

**内森**: 只建立你需要的东西，仅此而已，不多也不少，并且尽可能地构建得更好。然后，当事实证明它不完全是你需要的时候，在学习后愿意重新审视它。但我认为，如果你每一步都是有意义和谨慎地进行，而不是浪费时间推测你可能需要什么，那么……对我来说，这总是有效的。尽管有时可能需要一点时间。

**Antonio**: 我要补充一点：这是一个渐进过程。并不是说所有东西都必须完美地构建。或者至少我对我们写的大部分代码是这样感觉的。如果我们在写GPUI的东西，好吧，整个应用程序都依赖于GPUI，那就最好完美无瑕。或者是SumTree。这是代码库中到处都在使用的数据结构。我们真的想要把它搞定，因为它必须快速。

它必须完美地工作，这样我们才能在其基础上构建，对吧？这也反映在我们对这些事物进行的测试中。SumTree是随机测试的，因为我们希望确保所有这些边缘情况都能完美工作。

现在，当你朝边缘推进时——你所提到的性能改进，Thorsten，我们并没有花三个小时打磨它，对吧？这就像：无论如何完成任务，基本上就在边缘。我的意思是，我们应该对代码感到满意，我们应该始终努力尽可能地写出最好的代码，但我们不需要过度打磨它。

这是一个渐变过程。某件事情对核心越重要，它就越值得思考和质量。

**Nathan**: 我最喜欢编写的代码是那些我有权力编写的代码。哇，这有很多同音词。

用GPUI编写它时我玩得很开心，以至于我几乎觉得有点内疚。但我有权利编写这段代码，因为我写了第一个版本，我与之共处，我推动了它前进，当需要时我做出了妥协以使事情变得正确。

但现在是我们可以做得更好的时候。而且这样做是有意义的。而且我是知情的。我认为很多时候，当人们谈论像重写这样的事情时——如果你正在重写别人写的东西，对自己要更加怀疑。

但是如果你写了它，你与之共处，你付出了努力…… 这也有一些值得一说的地方：不要让完美主义妨碍学习。

**Thorsten: 如果我带着你们三个人……我不知道要对你们施加什么，你们不能搭建的，但是假设你们必须搭建，我不知道什么 —— 一个飞机的PID控制器。飞机软件，就是这样。**

**Nathan**: 核反应堆控制子系统。

**Thorsten: 你不了解领域，你还不知道你将如何构建它，你还不知道你将需要哪些部分。这就是你会说你需要不同方法的地方吗？不像在编辑器中，你对你想要的有一个强烈的愿景，你之前搭建了几个，所以现在你知道哪些部分重要。你事先知道，GPUI将是重要的。所以让我们花点时间来打磨它，正如Antonio所说的那样。**

**Max**: 我的意思是，我不知道核反应堆是不是一个好例子，但我确实觉得如果这是我们的第一个代码编辑器，...我们*确实*是“坏是更好”。这不是故意要糟糕，但我们曾采取更快、更脏的方法，然后识别出那些真正痛苦的地方来构建，以其更糟糕的形式。

但我认为，如果由于某些原因，Antonio、我和 Nathan 不得不建立一个...

**Nathan**: 也许选一些不那么关键的东西？

**Max**: ... 一个 Shopify 克隆或其他东西。我们可能会对此有不同的思维方式。我们不会知道哪些部分需要真正精雕细琢。

**Nathan**: 但如果我*真的*在建造核反应堆控制系统，我会使用拜占庭容错共识算法，让三个团队互相牵制对方的安全性，然后使它们在所有方面达成共识。但我不知道该怎么做。

**Antonio**: 还有一个例子，比核反应堆少了那么多关键任务的案例，但我们对数据结构并不了解，因此花了一些时间去学习它。Atom 和 Zed 今天驱动缓冲区的结构并不总是 CRDT。在研究阶段，Nathan 和我读了...我忘记了有多少篇论文。很多。目前我们使用的 CRDT 方法——我们仍然重写了两到三次——但方法基本相同。

所以我认为，这在经验中是有一部分的。我觉得你倾向于发展出一种感觉，知道需要花时间的事情和不那么重要的事情。

现在，话虽如此，我们确实重写了 CRDT 两到三次，但研究部分很重要。我不知道。

**Nathan**: 有趣的是，在发布的 Atom 中，缓冲区是一系列行的数组，JavaScript 字符串数组。而在 Zed 中，它是一个多线程友好的可快照复制写入 B 树，可以索引你能想象到的一切。或者我们所需要的一切。所以我们采取了“坏是更好”的策略。

但重新开始，它会再次是一系列行的数组吗？可能不是，因为看看这些时间边界。再多考虑一下，但是——再次——我通过像“坏是更好”的方式学到了这一点，然后让它变得真的很慢或在边缘情况下有问题，这实际上很重要。

**Thorsten**: 那么 Zed 最值得推崇的部分是什么？

**Nathan**: GPUI 看起来是相当完美的，我认为，因为我们刚刚重写了整个东西。

**Antonio**: 好问题。

**Max**: 我认为[`editor` crate](https://github.com/zed-industries/zed/tree/main/crates/editor)中的内容，那里有一系列不同的转换，将缓冲区的原始文本转换为你在屏幕上看到的行，它们会展开制表符并进行软换行，插入块装饰并处理折叠等等。所有这些层都采用统一的测试策略，即通过属性测试进行随机测试。所以我认为它们非常经过推敲。

多缓冲区也是如此，我们在其中将不同缓冲区的不同片段编织在一起。

**Nathan**: 我想称它们为，嗯…… 我只是想建议代码库的那一部分使用一种替代物质。我会说它有点镀上了血液。

**安东尼奥**: 哈！镀血。

**Thorsten: 你指的是编辑器和多缓冲区吗？**

**安东尼奥**: 是的。

**Nathan**: 是的。随机测试，我们在 2021 年的整天时间里，连续多天，只是在调试这些随机测试的失败，它们会发现一些关于这种复杂堆叠不同转换层的奇怪边缘情况 —— 我不是说它很华丽，但是复杂 —— 用于在屏幕上呈现事物的不同层次。因此，这只是粗劳力，对吧？找出边缘情况，然后通过减少日志来弄清它们为何发生，长时间以来我们都是手动做的。

**Thorsten: 当其中一个 bug 突然出现时，你有过恐慌的时刻吗？当属性测试抛出一个 bug，你是否觉得“也许整个东西都不起作用了？”还是说“好吧，这只是另一件需要修整的事情，如果不行，我们重写这个”？**

**安东尼奥**: 永远不要恐慌，这是随机测试的原则，永远不要恐慌。我对我们作为工程师的能力非常有信心，真的，也许我们必须重写整个东西，随机测试告诉我们这一点，但没关系，我们只是学到了一些东西，回到绘图板上重新来过。

**Nathan**: 让人害怕的是：这要花多长时间？我觉得李，我们的种子投资者，在某些时候也在问我们这个问题。但他一直支持我们，耐心等待，因为确实花了些时间。

但那段是用 Rust 写的。如果我们搞砸了，程序就会 panic。再见，噗。不仅仅是堆栈跟踪被扔到编辑器的某个角落，不，事情就这样结束了。

所以我们知道，要做好这些层次有多难。我们也知道别无选择，只能做对它们。但是，是的，我记得，安东尼奥，记得我们在软换行上工作，以及我们遇到的问题，当我们意识到我们需要的基本元素是这种能够表示补丁并能够组合这些补丁的能力时 —— 那时我有点出汗，想着“我们能搞定吗？” 然后安东尼奥搞定了。

**安东尼奥**：是的。但是支撑所有这些的——你知道，黄金镀层——又是一棵总和树。即使如此，如果我们重写它，还有一些改进的想法。

**内森**：我们前几天在谈论有多酷它会是。安东尼奥，你应用了我们讨论的一些想法：以更加流畅友好的方式构建所有这些层次。而且你做了一项优化，预览版将在下周发布。

**安东尼奥**：是的，我还需要为此开放 PR……

**内森**：为了能够更多地支持流输入，这样人们在打开大文件时不会完全没有反馈，而是开始更高效地加载事物——这是否需要重写呢？也许需要。也许不需要。我不知道。

**托斯滕**：有趣的是，这种重新编写或再次做的想法出现的频率。我们上次谈到过这个 [上次](/blog/why-the-big-rewrite)。持续学习。这不是：学习然后修复和打补丁。更多的是：我们学到了什么，所以现在让我们在考虑到这些学习的基础上重新做，而不是简单地打个补丁。这个问题多次出现，你可以在产品中看到。

**安东尼奥，每次我们讨论时，你都会说：以前我们是这样做的，*现在*我们是这样做的。就在昨天，我们基本上重写了处理 macOS 输入法系统的部分，因为安东尼奥说：我们不能把它留在这里，我们不希望另一个人掉进这个兔子洞，让我们在其上架一座桥。**

**内森**：不错。听到这个消息很好。我已经听说过这个。

**托斯滕**：我不知道这是否有意义，但我的最后一个问题是……对于很多软件，比如 SaaS 企业什么的，或者 Shopify 的克隆，我认为大多数用户并不关心使用什么技术，只要它对他们有效。我想知道：对于开发工具或编辑器，情况是否不同？使用的技术是否更加显著，或者用户更关心它？

**马克斯**：我认为这影响了我们可以得到的贡献类型。我们的许多用户，他们中的许多人都准备为了满足自己的需求向代码库贡献一些东西。

我认为能够轻松地对 Zed 做出贡献很重要。如果我们把所有东西都写在 C++ 中，我认为会有很多人想要改变 Zed 的某些东西，但不会像现在这样准备好自己去做出改变。

相比于几周前我们开源以来得到的贡献，这确实是很多。我认为人们喜欢它是用 Rust 写的。它很易于接近。人们可以轻松构建项目。他们不必学习如何使用 CMake 或其他工具来构建项目或使用 Gyp。他们只需使用 cargo 就可以了。

但是编译器的严格性也使我们作为这些贡献的接收端，通常能够充满信心地合并。我认为这真的很有帮助。

**Nathan**: Rust 是一款绝对漂亮的工具。它并非完美，但我喜爱它。但这对用户重要吗？我是说，我认为人们最终想要的是一个快速的编辑器。我们可以用，什么来写呢，Brainfuck？他们不会在意。但贡献的角度是非常有效的。

**Antonio**: 但我仍然想谈论性能，我只是认为我们被迫以某种方式做事情是因为性能。为什么我们有这个 GPU 加速的 UI 框架？因为性能需要达到某个水平。我们希望我们的帧率在三毫秒以下。我们可以在 CPU 上光栅化所有东西，我们可以使用某些可以做到这一点的东西，但是，没有。

在某种程度上，我们正在定位自己成为一款性能编辑器，因为我们想要一款性能编辑器。我想要一款性能编辑器。所以，选择几乎是... 我们几乎没有选择。

**Nathan**: 但现在有 Zig 了，我还不太了解 Zig，我还没有时间去了解它，但我尊敬的人们对它感到兴奋。看起来它与 Rust 在输出方面有一些相同的目标。我不清楚它在安全性方面牺牲了什么，或者它们如何处理这些问题。可能有一些实际上工作的实用解决方案，不像 Rust 那样严格，但在实践中有效，等等。

所以我对此很感兴趣。我感到很好奇，但是关于像单语言主义这样的事情还有很多需要说的，如果这有意义的话。服务器是用 Rust 写的，前端也是用 Rust 写的，但如果我能用十分之一的编译时间得到 Rust 的 99% 的好处...

**Thorsten**: 嗯，我可以告诉你关于 Zig 的一件事，Discord 上的一个人说他们正在用 Zig 写一个编辑器，但是 Zig 的一个完美的文本编辑器名称已经被取了：Zed。

* * *
