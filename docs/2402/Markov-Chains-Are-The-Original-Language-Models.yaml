- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 14:30:33'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 14:30:33
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Markov Chains Are The Original Language Models
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 马尔可夫链是最初的语言模型
- en: 来源：[https://elijahpotter.dev/articles/markov_chains_are_the_original_language_models](https://elijahpotter.dev/articles/markov_chains_are_the_original_language_models)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://elijahpotter.dev/articles/markov_chains_are_the_original_language_models](https://elijahpotter.dev/articles/markov_chains_are_the_original_language_models)
- en: Markov Chains are the Original Language Models
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 马尔可夫链是最初的语言模型
- en: '![An old car interior](img/bca28c3f1205854697bad5adf9ffa8c2.png)'
  id: totrans-split-7
  prefs: []
  type: TYPE_IMG
  zh: '![一个旧车内饰](img/bca28c3f1205854697bad5adf9ffa8c2.png)'
- en: '**Heads Up:** This article is a republished (with some tweaks on spelling,
    grammar and layout) version of an article I wrote in my senior year of high school
    for my Linear Algebra class. As such, the publish date is not quite correct.'
  id: totrans-split-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 这篇文章是我高中毕业年为线性代数课程写的一篇文章的修订版（拼写、语法和布局有些调整）。因此，发布日期并不完全正确。'
- en: The AI Buzz is Boring Now
  id: totrans-split-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AI热潮现在变得无聊了
- en: I've come to the conclusion that there are four stages to the current AI hype
    cycle in an individual person's brain, at least as it pertains to large language
    models. At the very least, these are the stages I went through.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我得出结论，个人大脑中当前AI炒作周期有四个阶段，至少在涉及大型语言模型方面是这样。至少，这是我经历的阶段。
- en: 'Stage One: Amazement'
  id: totrans-split-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一阶段：惊奇
- en: '"Wow! This is so cool! I can converse with a computer just like a real person!"'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: '"哇！这太酷了！我可以像和真人一样与计算机交流！"'
- en: This is where all the science fiction fantasies come to fruition. The possibilities
    seem endless. We can all kick back and relax now, right?
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有科幻幻想成真的地方。可能性似乎无限。我们现在可以坐下来放松了，对吗？
- en: 'Stage Two: Frustration'
  id: totrans-split-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二阶段：挫败
- en: '"Hmm... This isn''t as effective as I originally thought."'
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: '"嗯... 这并不像我最初想象的那么有效。"'
- en: It seems like the brand-new technology is really only applicable to the kinds
    of work no one wants to do anyway. What it **is** able to do doesn't provide too
    much value to you. It gets information and logic wrong often enough that it cannot
    be trusted for just about anything.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这种全新的技术确实只适用于那些无人愿意做的工作。它所能做的并没有给你带来太多价值。它经常出错，无法信任它处理任何事情。
- en: 'Stage Three: Confusion'
  id: totrans-split-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三阶段：困惑
- en: After stage two, you start to forget about it. But the hype is inescapable.
    Your friends bring it up. Your parents ask you about it when you go home for the
    holidays. Even your dentist tries to extol its virtues.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段过后，你开始忘记这些。但炒作无处不在。你的朋友们提到它。你回家过节时，父母问你这个。甚至你的牙医也试图夸耀它的优点。
- en: Even if you moved on it, no one else did. Could that mean that you were wrong?
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你对此有所行动，其他人却没有。这是否意味着你错了？
- en: 'Stage Four: Boredom'
  id: totrans-split-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第四阶段：无聊
- en: At this point the rate of new language models appearing has become faster than
    rate of new JavaScript frameworks (and just as annoying). You want to go back
    to your roots and start from scratch. You want the freedom of knowing the whole
    stack from start to finish. You don't want any of the ineffective magic.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，新语言模型的发布速度已经超过了新JavaScript框架的速度（同样让人讨厌）。你想回到自己的起点，从头开始。你想要知道整个技术栈的自由。你不想要任何无效的魔法。
- en: This is where I am right now. Want to go back to my roots. Some people work
    on old cars, even though they are less efficient. At the same time though, they
    are more fun to work on than new cars. I've decided to look into Markov chains.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我现在的状态。想回到我的起点。有些人喜欢修旧车，即使它们效率不高。与此同时，它们比新车更有趣。我决定研究一下马尔可夫链。
- en: Markov Chains
  id: totrans-split-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 马尔可夫链
- en: Below is a demonstration of my implementation of auto-completion using Markov
    Chains.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我使用马尔可夫链实现的自动补全的演示。
- en: Though it is written in Rust and compiled to WebAssembly, it is not particularly
    efficient. To find out why, continue down the page to my detailed explanation
    of the implementation.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它是用Rust编写并编译为WebAssembly，但它并不特别高效。要找出原因，请继续查看页面底部我对实现的详细解释。
- en: Controls
  id: totrans-split-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制
- en: You may use either "Choose Word" or your right arrow key [→] to let the system
    choose the next word. Alternatively, you can tap any of the [Possible Next Words]
    to do so yourself.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用"选择词"或您的右箭头键[→]让系统选择下一个单词。或者，您可以轻击任何[可能的下一个单词]自行操作。
- en: Explanation
  id: totrans-split-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释
- en: Markov chains, named after their inventor, Andrey Markov, are often used to
    model sequences of probabilistic events. That is, systems that cannot be modeled
    deterministically.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链，以其发明者安德烈·马尔可夫命名，通常用于建模概率事件的序列。也就是说，无法以确定性方式建模的系统。
- en: Example
  id: totrans-split-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Alice is at the grocery store. For every hour she is there, she has a 70% chance
    of leaving and going to the planetarium. Conversely, she has a 30% chance of staying.
    If Alice is already at the planetarium, she has a 10% chance of leaving and going
    to the grocery store and a 90% chance of staying. We can represent these probabilities
    as a table, where each column belongs to a start location, and each row belongs
    to a end location:'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝在杂货店。她在那里每呆一小时，有70%的机会离开去天文馆。相反，她有30%的机会留下来。如果爱丽丝已经在天文馆，她有10%的机会离开去杂货店，90%的机会留在那里。我们可以将这些概率表示为一个表格，其中每一列属于起始位置，每一行属于结束位置：
- en: '|  |  |  |'
  id: totrans-split-32
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '| --- | --: | --: |'
  id: totrans-split-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --: | --: |'
- en: '|  | Start at Grocery Store | Start at Planetarium |'
  id: totrans-split-34
  prefs: []
  type: TYPE_TB
  zh: '|  | 从杂货店开始 | 从天文馆开始 |'
- en: '| End at Grocery Store | 30% | 10% |'
  id: totrans-split-35
  prefs: []
  type: TYPE_TB
  zh: '| 结束于杂货店 | 30% | 10% |'
- en: '| End at Planetarium | 70% | 90% |'
  id: totrans-split-36
  prefs: []
  type: TYPE_TB
  zh: '| 结束于天文馆 | 70% | 90% |'
- en: If we already know Alice's location for sure, we can simply perform table lookups
    to predict her most likely next move. For example, we *know* she is at the grocery
    store right now. So by looking at row 2, column 1, we can be 70% confident she
    will be at the planetarium next hour. However, this doesn't work if we aren't
    sure of her location, or we want to predict more than one hour in advance. How
    do we predict her next move if we aren't certain of her current location? In the
    latter case, we might express her current location as another table.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经确切知道爱丽丝的位置，我们可以简单地进行表查找来预测她最可能的下一步动作。例如，我们*知道*她现在在杂货店。因此，通过查看第2行第1列，我们可以确信她有70%的概率下个小时会在天文馆。然而，如果我们不确定她的位置，或者我们想预测超过一小时的情况，这种方法就不适用了。如果我们不确定她当前的位置，我们该如何预测她的下一个动作？在后一种情况下，我们可能会把她当前的位置表达为另一个表格。
- en: '| Location | % Alice Present |'
  id: totrans-split-38
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | % 爱丽丝的存在 |'
- en: '| --- | --: |'
  id: totrans-split-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --: |'
- en: '| Grocery Store | 25% |'
  id: totrans-split-40
  prefs: []
  type: TYPE_TB
  zh: '| 杂货店 | 25% |'
- en: '| Planetarium | 75% |'
  id: totrans-split-41
  prefs: []
  type: TYPE_TB
  zh: '| 天文馆 | 75% |'
- en: 'How do we estimate Alice''s location in this new plane of possibility? In particular,
    how likely will Alice be at the Planetarium next hour? Since there is a 25% probability
    Alice is at the grocery store, we multiply that with the probility of her transitioning
    to the Planetarium: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>75</mn><mi mathvariant="normal">%</mi></mrow><annotation
    encoding="application/x-tex">25\% * 75\%</annotation></semantics></math>25%∗75%.
    Next, we add the result with the probability of being at the Planetarium multiplied
    with the probability of her staying: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>90</mn><mi mathvariant="normal">%</mi></mrow><annotation
    encoding="application/x-tex">75\% * 90\%</annotation></semantics></math>75%∗90%.
    In full, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>75</mn><mi mathvariant="normal">%</mi><mo>+</mo><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>90</mn><mi mathvariant="normal">%</mi><mo>=</mo><mn>85</mn><mi
    mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">25\%
    * 75\% + 75\% * 90\% = 85\%</annotation></semantics></math>25%∗75%+75%∗90%=85%.
    To see the probabilities as a table:'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的可能性平面上，我们如何估计爱丽丝的位置？特别是，下个小时爱丽丝在天文馆的可能性有多大？因为有25%的概率爱丽丝在杂货店，我们将这个概率乘以她转移到天文馆的概率：<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi mathvariant="normal">%</mi><mo>∗</mo><mn>75</mn><mi
    mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">25\%
    * 75\%</annotation></semantics></math>25%∗75%。接下来，我们将结果与她留在天文馆的概率乘以她留在那里的概率相加：<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>75</mn><mi mathvariant="normal">%</mi><mo>∗</mo><mn>90</mn><mi
    mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">75\%
    * 90\%</annotation></semantics></math>75%∗90%。总体来说，<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>75</mn><mi mathvariant="normal">%</mi><mo>+</mo><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>90</mn><mi mathvariant="normal">%</mi><mo>=</mo><mn>85</mn><mi
    mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">25\%
    * 75\% + 75\% * 90\% = 85\%</annotation></semantics></math>25%∗75%+75%∗90%=85%。将这些概率表示为表格：
- en: '| Next Location | Calculation | % Alice Present |'
  id: totrans-split-43
  prefs: []
  type: TYPE_TB
  zh: '| 下一个位置 | 计算 | % 爱丽丝的存在 |'
- en: '| --- | --- | --: |'
  id: totrans-split-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --: |'
- en: '| Grocery Store | <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>30</mn><mi mathvariant="normal">%</mi><mo>+</mo><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>10</mn><mi mathvariant="normal">%</mi></mrow><annotation
    encoding="application/x-tex">25\% * 30\% + 75\% * 10\%</annotation></semantics></math>25%∗30%+75%∗10%
    | 15% |'
  id: totrans-split-45
  prefs: []
  type: TYPE_TB
  zh: '| 杂货店 | <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>30</mn><mi mathvariant="normal">%</mi><mo>+</mo><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>10</mn><mi mathvariant="normal">%</mi></mrow><annotation
    encoding="application/x-tex">25\% * 30\% + 75\% * 10\%</annotation></semantics></math>25%∗30%+75%∗10%
    | 15% |'
- en: '| Planetarium | <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>70</mn><mi mathvariant="normal">%</mi><mo>+</mo><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>90</mn><mi mathvariant="normal">%</mi></mrow><annotation
    encoding="application/x-tex">25\% * 70\% + 75\% * 90\%</annotation></semantics></math>25%∗70%+75%∗90%
    | 85% |'
  id: totrans-split-46
  prefs: []
  type: TYPE_TB
  zh: '| 天文馆 | <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>70</mn><mi mathvariant="normal">%</mi><mo>+</mo><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>90</mn><mi mathvariant="normal">%</mi></mrow><annotation
    encoding="application/x-tex">25\% * 70\% + 75\% * 90\%</annotation></semantics></math>25%∗70%+75%∗90%
    | 85% |'
- en: The keen-eyed among you may have noticed that these operations look a lot like
    matrix multiplication. Instead of a table, we may represent these possible transitions
    as a matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation
    encoding="application/x-tex">T</annotation></semantics></math>T, and the Alice's
    current location as a vector <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math>s.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: '-   那些注意力集中的人可能会注意到，这些运算看起来很像矩阵乘法。我们可以将这些可能的转换表示为矩阵<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation
    encoding="application/x-tex">T</annotation></semantics></math>T，并且将爱丽丝当前位置表示为向量<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation
    encoding="application/x-tex">\vec{s}</annotation></semantics></math>s。'
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mo
    fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0.3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.9</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">T =
    \begin{bmatrix} 0.3 & 0.1 \\ 0.7 & 0.9 \end{bmatrix}</annotation></semantics></math>T=[0.30.7​0.10.9​]
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable
    rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">.</mi><mn>25</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">.</mi><mn>75</mn></mrow></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{s}
    = \begin{bmatrix} .25 \\ .75 \\ \end{bmatrix}</annotation></semantics></math>s=[.25.75​]
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mo
    fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0.3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.9</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">T =
    \begin{bmatrix} 0.3 & 0.1 \\ 0.7 & 0.9 \end{bmatrix}</annotation></semantics></math>T=[0.30.7​0.10.9​]
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable
    rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">.</mi><mn>25</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">.</mi><mn>75</mn></mrow></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{s}
    = \begin{bmatrix} .25 \\ .75 \\ \end{bmatrix}</annotation></semantics></math>s=[.25.75​]
- en: '**Note:** The location of each element remains the same as the table, even
    if we aren''t explicitly labeling the rows and columns.'
  id: totrans-split-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 每个元素的位置与表格相同，即使我们没有明确标记行和列。'
- en: 'Finding the next state matrix becomes as easy as multiplying the current location
    vector <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math>s
    by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation
    encoding="application/x-tex">T</annotation></semantics></math>T. To find further
    hours in the future, we do it more than once. For example, to estimate three hours
    in the future: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>T</mi><mi>T</mi><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">TTT\vec{s}</annotation></semantics></math>TTTs.
    We can condense this with an exponent: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mn>3</mn></msup><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">T^3\vec{s}</annotation></semantics></math>T3s
    or generalize it to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation
    encoding="application/x-tex">n</annotation></semantics></math>n hours with: <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mi>n</mi></msup><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">T^n\vec{s}</annotation></semantics></math>Tns.'
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 找到下一个状态矩阵就像将当前位置向量 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math>s
    乘以 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation
    encoding="application/x-tex">T</annotation></semantics></math>T 一样简单。要预测未来的更多小时，我们需要多次操作。例如，要预估三个小时后的情况：<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>T</mi><mi>T</mi><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">TTT\vec{s}</annotation></semantics></math>TTTs。我们可以使用指数简化这个过程：<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mn>3</mn></msup><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">T^3\vec{s}</annotation></semantics></math>T3s
    或者推广到 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation
    encoding="application/x-tex">n</annotation></semantics></math>n 小时：<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mi>n</mi></msup><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">T^n\vec{s}</annotation></semantics></math>Tns。
- en: Application to Text-Completion
  id: totrans-split-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适用于文本完成
- en: The principles above can be applied to a variety of probabilistic situations.
    Most relavant to this particular webpage, is text completion. We want to estimate
    the most likely next word to the user. Given the last word, what are the most
    likely next words? First, we need a dictionary.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述原则可以应用于各种概率情况。与此特定网页最相关的是文本完成。我们希望预估用户最可能的下一个词。给定最后一个词，最可能的下一个词是什么？首先，我们需要一个字典。
- en: The Dictionary
  id: totrans-split-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: It is trivial to build a dictionary from sample text. For the purposes of the
    explanation, we are going to start with an arbitrary dictionary.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从样本文本构建字典非常简单。为了解释的目的，我们将从任意的字典开始。
- en: '| Index | Word |'
  id: totrans-split-55
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 单词 |'
- en: '| --- | --- |'
  id: totrans-split-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | orange |'
  id: totrans-split-57
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 橙子 |'
- en: '| 1 | fruit |'
  id: totrans-split-58
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 水果 |'
- en: '| 2 | passion |'
  id: totrans-split-59
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 激情 |'
- en: '| 3 | cheese |'
  id: totrans-split-60
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 奶酪 |'
- en: '| 4 | not |'
  id: totrans-split-61
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 不 |'
- en: '| 5 | is |'
  id: totrans-split-62
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 是 |'
- en: Building the Transition Matrix
  id: totrans-split-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建转移矩阵
- en: To build our transition matrix, we need to count all the transitions that occur
    between possible words in our dictionary. In the interest of performance, my implementation
    converts the dictionary into a `HashMap<String, usize>`. Next, I go through the
    training text and match each word to it's index in the dictionary, effectively
    transforming the `String` into a `Vec<usize>`. For example, the phrase, "passion
    fruit is not orange, cheese is orange," becomes, `[ 2, 1, 5, 4, 0, 3, 5, 0 ]`.
    Next, the implementation iterates through each element in this vector, counting
    each transition. The counts are stored in another `HashMap` in the interest of
    performance, but is eventually converted into a matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation
    encoding="application/x-tex">C</annotation></semantics></math>C. Each row is the
    output word's index, and the column is the input word's index. For example, the
    transition `"fruit" (index 1) -> "is" (index 5)` occurs exactly once, so we record
    `1` in column 1, row 5.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的转换矩阵，我们需要计算字典中可能单词之间发生的所有转换。出于性能考虑，我的实现将字典转换为`HashMap<String, usize>`。接下来，我会遍历训练文本，并将每个单词与其在字典中的索引进行匹配，
    effectively transforming the `String` into a `Vec<usize>`。例如，短语“passion fruit
    is not orange, cheese is orange”，会变成`[ 2, 1, 5, 4, 0, 3, 5, 0 ]`。然后，实现会遍历这个向量中的每个元素，计算每个转换的次数。为了性能起见，这些计数会存储在另一个`HashMap`中，但最终会被转换成一个矩阵
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation
    encoding="application/x-tex">C</annotation></semantics></math>C。每一行都是输出单词的索引，而每一列是输入单词的索引。例如，转换“fruit”（索引1）->
    “is”（索引5）恰好发生了一次，所以我们在列1，行5记录`1`。
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mo
    fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center
    center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">C =
    \begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 1 \\ 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 &
    0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 \\ 0 & 1 & 0 & 1 &
    0 & 0 \end{bmatrix}</annotation></semantics></math>C=​000100​000001​010000​000001​100000​100010​​
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: \( C \)是一个矩阵，如下所示：
- en: Not a very interesting matrix, is it?
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵并不是很有趣，对吧？
- en: 'Each element needs to be converted into a probability. Take the sum of each
    column:'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素都需要转换为概率。计算每列的和：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo
    fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center
    center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation
    encoding="application/x-tex">\begin{bmatrix} 1 & 1 & 1 & 1 & 1 & 2 \end{bmatrix}</annotation></semantics></math>[1​1​1​1​1​2​]
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo
    fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center
    center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation
    encoding="application/x-tex">\begin{bmatrix} 1 & 1 & 1 & 1 & 1 & 2 \end{bmatrix}</annotation></semantics></math>[1​1​1​1​1​2​]
- en: Create a diagonal matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation
    encoding="application/x-tex">D</annotation></semantics></math>D composed of <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mtext>column sum</mtext></mfrac></mrow><annotation
    encoding="application/x-tex">\frac{1}{\text{column sum}}</annotation></semantics></math>column sum1​
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个由<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation
    encoding="application/x-tex">D</annotation></semantics></math>D组成的对角矩阵，其由<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mtext>列求和</mtext></mfrac></mrow><annotation
    encoding="application/x-tex">\frac{1}{\text{column sum}}</annotation></semantics></math>列求和组成。
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mo
    fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center
    center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">C =
    \begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0.5 \\ 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0
    & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0.5 \\ 0 & 1 & 0 &
    1 & 0 & 0 \end{bmatrix}</annotation></semantics></math>C=​000100​000001​010000​000001​100000​0.50000.50​​
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 **C** 是一个`6x6`的矩阵，表示如下：
- en: 'To finalize our Markov (a.k.a. transition) matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation
    encoding="application/x-tex">M</annotation></semantics></math>M, we simply perform:'
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成我们的马尔可夫（又名过渡）矩阵<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation
    encoding="application/x-tex">M</annotation></semantics></math>M，我们只需执行：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mo>=</mo><mi>D</mi><mi>C</mi></mrow><annotation
    encoding="application/x-tex">M = DC</annotation></semantics></math>M=DC
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mo>=</mo><mi>D</mi><mi>C</mi></mrow><annotation
    encoding="application/x-tex">M = DC</annotation></semantics></math>M=DC
- en: Using the transition matrix
  id: totrans-split-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用过渡矩阵
- en: 'There are two possible situations: the user is in the process of typing, or
    they have finished their last word. The latter is the easiest to implement. Scan
    the user''s text, and isolate the last word. Perform a lookup on the word list
    to identify it''s index. Create a new vector containing `0`s except for that index,
    which should contain a `1`. For example, if the last word was ''is'','
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能的情况：用户正在输入过程中，或者他们已经完成了最后一个单词。后者是最容易实现的。扫描用户的文本，并且分离出最后一个单词。对单词列表执行查找以确定其索引。创建一个新向量，其中包含`0`，除了该索引处应包含`1`。例如，如果最后一个单词是'is'，
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable
    rowspacing="0.16em" columnalign="center center center center center center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{s}
    = \begin{bmatrix} 0 & 0 & 0 & 0 & 0 & 1 \end{bmatrix}</annotation></semantics></math>s=[0​0​0​0​0​1​]
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable
    rowspacing="0.16em" columnalign="center center center center center center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{s}
    = \begin{bmatrix} 0 & 0 & 0 & 0 & 0 & 1 \end{bmatrix}</annotation></semantics></math>s=[0​0​0​0​0​1​]
- en: 'Run it through our transition matrix:'
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将其通过我们的过渡矩阵运行：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable
    rowspacing="0.16em" columnalign="center center center center center center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">M\vec{s}
    = \begin{bmatrix} 0.5 & 0 & 0 & 0 & 0.5 & 0 \end{bmatrix}</annotation></semantics></math>Ms=[0.5​0​0​0​0.5​0​]
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable
    rowspacing="0.16em" columnalign="center center center center center center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">M\vec{s}
    = \begin{bmatrix} 0.5 & 0 & 0 & 0 & 0.5 & 0 \end{bmatrix}</annotation></semantics></math>Ms=[0.5​0​0​0​0.5​0​]
- en: Meaning the most probable next choices are at indices `0` and `4`, which correspond
    to "orange" and "not" respectively. This is great for autocomplete. We can simply
    list the most probable options to the user.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着最有可能的下一个选择是在索引`0`和`4`，分别对应于"orange"和"not"。这对自动补全非常有用。我们可以简单地向用户列出最可能的选项。
- en: Text-Generation and Steady State
  id: totrans-split-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本生成和稳态
- en: It would be pretty neat if we could use this method to automagically generate
    text, right?
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 用这种方法自动产生文本会很棒，对吧？
- en: The Naive Solution
  id: totrans-split-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 天真的解决方案
- en: 'Each iteration, choose the most likely word from the set. Maybe randomize it
    a bit: choose a random word from the top 5 options. Unfortunately, there is an
    issue. All Markov chains are guaranteed to converge on a specific probabilistic
    state given enough iterations. In order to get text generation to work unpredictably
    and without converging, we need something a bit more complex.'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代，从集合中选择最可能的单词。也许可以稍微随机一些：从前五个选项中随机选择一个单词。不幸的是，这里有一个问题。所有马尔可夫链在足够的迭代次数后都保证会收敛到一个特定的概率状态。为了使文本生成工作变得不可预测且不收敛，我们需要一些更复杂的东西。
- en: My Solution
  id: totrans-split-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我的解决方案
- en: Create a square diagonal matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation
    encoding="application/x-tex">R</annotation></semantics></math>R with a side length
    equal to the length of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math>s.
    Fill the diagonal elements with random numbers between <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation
    encoding="application/x-tex">0</annotation></semantics></math>0 and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation
    encoding="application/x-tex">1</annotation></semantics></math>1. Then choose the
    word whose index corresponds with the highest value of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">R\vec{s}</annotation></semantics></math>Rs
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个边长等于<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation
    encoding="application/x-tex">\vec{s}</annotation></semantics></math>s长度的方形对角矩阵<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation
    encoding="application/x-tex">R</annotation></semantics></math>R。用介于<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation
    encoding="application/x-tex">0</annotation></semantics></math>0和<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation
    encoding="application/x-tex">1</annotation></semantics></math>1之间的随机数填充对角元素。然后选择索引与<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mover accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation
    encoding="application/x-tex">R\vec{s}</annotation></semantics></math>Rs的最高值相对应的单词。
