- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:30:33'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Markov Chains Are The Original Language Models
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://elijahpotter.dev/articles/markov_chains_are_the_original_language_models](https://elijahpotter.dev/articles/markov_chains_are_the_original_language_models)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Markov Chains are the Original Language Models
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![An old car interior](img/bca28c3f1205854697bad5adf9ffa8c2.png)'
  id: totrans-split-7
  prefs: []
  type: TYPE_IMG
- en: '**Heads Up:** This article is a republished (with some tweaks on spelling,
    grammar and layout) version of an article I wrote in my senior year of high school
    for my Linear Algebra class. As such, the publish date is not quite correct.'
  id: totrans-split-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The AI Buzz is Boring Now
  id: totrans-split-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I've come to the conclusion that there are four stages to the current AI hype
    cycle in an individual person's brain, at least as it pertains to large language
    models. At the very least, these are the stages I went through.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage One: Amazement'
  id: totrans-split-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"Wow! This is so cool! I can converse with a computer just like a real person!"'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: This is where all the science fiction fantasies come to fruition. The possibilities
    seem endless. We can all kick back and relax now, right?
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage Two: Frustration'
  id: totrans-split-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"Hmm... This isn''t as effective as I originally thought."'
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: It seems like the brand-new technology is really only applicable to the kinds
    of work no one wants to do anyway. What it **is** able to do doesn't provide too
    much value to you. It gets information and logic wrong often enough that it cannot
    be trusted for just about anything.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage Three: Confusion'
  id: totrans-split-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After stage two, you start to forget about it. But the hype is inescapable.
    Your friends bring it up. Your parents ask you about it when you go home for the
    holidays. Even your dentist tries to extol its virtues.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: Even if you moved on it, no one else did. Could that mean that you were wrong?
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage Four: Boredom'
  id: totrans-split-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point the rate of new language models appearing has become faster than
    rate of new JavaScript frameworks (and just as annoying). You want to go back
    to your roots and start from scratch. You want the freedom of knowing the whole
    stack from start to finish. You don't want any of the ineffective magic.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: This is where I am right now. Want to go back to my roots. Some people work
    on old cars, even though they are less efficient. At the same time though, they
    are more fun to work on than new cars. I've decided to look into Markov chains.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: Markov Chains
  id: totrans-split-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Below is a demonstration of my implementation of auto-completion using Markov
    Chains.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: Though it is written in Rust and compiled to WebAssembly, it is not particularly
    efficient. To find out why, continue down the page to my detailed explanation
    of the implementation.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: Controls
  id: totrans-split-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may use either "Choose Word" or your right arrow key [→] to let the system
    choose the next word. Alternatively, you can tap any of the [Possible Next Words]
    to do so yourself.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  id: totrans-split-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Markov chains, named after their inventor, Andrey Markov, are often used to
    model sequences of probabilistic events. That is, systems that cannot be modeled
    deterministically.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: Example
  id: totrans-split-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alice is at the grocery store. For every hour she is there, she has a 70% chance
    of leaving and going to the planetarium. Conversely, she has a 30% chance of staying.
    If Alice is already at the planetarium, she has a 10% chance of leaving and going
    to the grocery store and a 90% chance of staying. We can represent these probabilities
    as a table, where each column belongs to a start location, and each row belongs
    to a end location:'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |  |'
  id: totrans-split-32
  prefs: []
  type: TYPE_TB
- en: '| --- | --: | --: |'
  id: totrans-split-33
  prefs: []
  type: TYPE_TB
- en: '|  | Start at Grocery Store | Start at Planetarium |'
  id: totrans-split-34
  prefs: []
  type: TYPE_TB
- en: '| End at Grocery Store | 30% | 10% |'
  id: totrans-split-35
  prefs: []
  type: TYPE_TB
- en: '| End at Planetarium | 70% | 90% |'
  id: totrans-split-36
  prefs: []
  type: TYPE_TB
- en: If we already know Alice's location for sure, we can simply perform table lookups
    to predict her most likely next move. For example, we *know* she is at the grocery
    store right now. So by looking at row 2, column 1, we can be 70% confident she
    will be at the planetarium next hour. However, this doesn't work if we aren't
    sure of her location, or we want to predict more than one hour in advance. How
    do we predict her next move if we aren't certain of her current location? In the
    latter case, we might express her current location as another table.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: '| Location | % Alice Present |'
  id: totrans-split-38
  prefs: []
  type: TYPE_TB
- en: '| --- | --: |'
  id: totrans-split-39
  prefs: []
  type: TYPE_TB
- en: '| Grocery Store | 25% |'
  id: totrans-split-40
  prefs: []
  type: TYPE_TB
- en: '| Planetarium | 75% |'
  id: totrans-split-41
  prefs: []
  type: TYPE_TB
- en: 'How do we estimate Alice''s location in this new plane of possibility? In particular,
    how likely will Alice be at the Planetarium next hour? Since there is a 25% probability
    Alice is at the grocery store, we multiply that with the probility of her transitioning
    to the Planetarium: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>75</mn><mi mathvariant="normal">%</mi></mrow><annotation
    encoding="application/x-tex">25\% * 75\%</annotation></semantics></math>25%∗75%.
    Next, we add the result with the probability of being at the Planetarium multiplied
    with the probability of her staying: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>90</mn><mi mathvariant="normal">%</mi></mrow><annotation
    encoding="application/x-tex">75\% * 90\%</annotation></semantics></math>75%∗90%.
    In full, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>75</mn><mi mathvariant="normal">%</mi><mo>+</mo><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>90</mn><mi mathvariant="normal">%</mi><mo>=</mo><mn>85</mn><mi
    mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">25\%
    * 75\% + 75\% * 90\% = 85\%</annotation></semantics></math>25%∗75%+75%∗90%=85%.
    To see the probabilities as a table:'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: '| Next Location | Calculation | % Alice Present |'
  id: totrans-split-43
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --: |'
  id: totrans-split-44
  prefs: []
  type: TYPE_TB
- en: '| Grocery Store | <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>30</mn><mi mathvariant="normal">%</mi><mo>+</mo><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>10</mn><mi mathvariant="normal">%</mi></mrow><annotation
    encoding="application/x-tex">25\% * 30\% + 75\% * 10\%</annotation></semantics></math>25%∗30%+75%∗10%
    | 15% |'
  id: totrans-split-45
  prefs: []
  type: TYPE_TB
- en: '| Planetarium | <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>70</mn><mi mathvariant="normal">%</mi><mo>+</mo><mn>75</mn><mi
    mathvariant="normal">%</mi><mo>∗</mo><mn>90</mn><mi mathvariant="normal">%</mi></mrow><annotation
    encoding="application/x-tex">25\% * 70\% + 75\% * 90\%</annotation></semantics></math>25%∗70%+75%∗90%
    | 85% |'
  id: totrans-split-46
  prefs: []
  type: TYPE_TB
- en: The keen-eyed among you may have noticed that these operations look a lot like
    matrix multiplication. Instead of a table, we may represent these possible transitions
    as a matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation
    encoding="application/x-tex">T</annotation></semantics></math>T, and the Alice's
    current location as a vector <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math>s.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo>=</mo><mrow><mo
    fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0.3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.9</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">T =
    \begin{bmatrix} 0.3 & 0.1 \\ 0.7 & 0.9 \end{bmatrix}</annotation></semantics></math>T=[0.30.7​0.10.9​]
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable
    rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">.</mi><mn>25</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">.</mi><mn>75</mn></mrow></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{s}
    = \begin{bmatrix} .25 \\ .75 \\ \end{bmatrix}</annotation></semantics></math>s=[.25.75​]
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** The location of each element remains the same as the table, even
    if we aren''t explicitly labeling the rows and columns.'
  id: totrans-split-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finding the next state matrix becomes as easy as multiplying the current location
    vector <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math>s
    by <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation
    encoding="application/x-tex">T</annotation></semantics></math>T. To find further
    hours in the future, we do it more than once. For example, to estimate three hours
    in the future: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>T</mi><mi>T</mi><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">TTT\vec{s}</annotation></semantics></math>TTTs.
    We can condense this with an exponent: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mn>3</mn></msup><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">T^3\vec{s}</annotation></semantics></math>T3s
    or generalize it to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation
    encoding="application/x-tex">n</annotation></semantics></math>n hours with: <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mi>n</mi></msup><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">T^n\vec{s}</annotation></semantics></math>Tns.'
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: Application to Text-Completion
  id: totrans-split-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principles above can be applied to a variety of probabilistic situations.
    Most relavant to this particular webpage, is text completion. We want to estimate
    the most likely next word to the user. Given the last word, what are the most
    likely next words? First, we need a dictionary.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: The Dictionary
  id: totrans-split-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is trivial to build a dictionary from sample text. For the purposes of the
    explanation, we are going to start with an arbitrary dictionary.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: '| Index | Word |'
  id: totrans-split-55
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-split-56
  prefs: []
  type: TYPE_TB
- en: '| 0 | orange |'
  id: totrans-split-57
  prefs: []
  type: TYPE_TB
- en: '| 1 | fruit |'
  id: totrans-split-58
  prefs: []
  type: TYPE_TB
- en: '| 2 | passion |'
  id: totrans-split-59
  prefs: []
  type: TYPE_TB
- en: '| 3 | cheese |'
  id: totrans-split-60
  prefs: []
  type: TYPE_TB
- en: '| 4 | not |'
  id: totrans-split-61
  prefs: []
  type: TYPE_TB
- en: '| 5 | is |'
  id: totrans-split-62
  prefs: []
  type: TYPE_TB
- en: Building the Transition Matrix
  id: totrans-split-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To build our transition matrix, we need to count all the transitions that occur
    between possible words in our dictionary. In the interest of performance, my implementation
    converts the dictionary into a `HashMap<String, usize>`. Next, I go through the
    training text and match each word to it's index in the dictionary, effectively
    transforming the `String` into a `Vec<usize>`. For example, the phrase, "passion
    fruit is not orange, cheese is orange," becomes, `[ 2, 1, 5, 4, 0, 3, 5, 0 ]`.
    Next, the implementation iterates through each element in this vector, counting
    each transition. The counts are stored in another `HashMap` in the interest of
    performance, but is eventually converted into a matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation
    encoding="application/x-tex">C</annotation></semantics></math>C. Each row is the
    output word's index, and the column is the input word's index. For example, the
    transition `"fruit" (index 1) -> "is" (index 5)` occurs exactly once, so we record
    `1` in column 1, row 5.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mo
    fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center
    center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">C =
    \begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 1 \\ 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 &
    0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 \\ 0 & 1 & 0 & 1 &
    0 & 0 \end{bmatrix}</annotation></semantics></math>C=​000100​000001​010000​000001​100000​100010​​
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: Not a very interesting matrix, is it?
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Each element needs to be converted into a probability. Take the sum of each
    column:'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo
    fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center
    center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation
    encoding="application/x-tex">\begin{bmatrix} 1 & 1 & 1 & 1 & 1 & 2 \end{bmatrix}</annotation></semantics></math>[1​1​1​1​1​2​]
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: Create a diagonal matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation
    encoding="application/x-tex">D</annotation></semantics></math>D composed of <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mtext>column sum</mtext></mfrac></mrow><annotation
    encoding="application/x-tex">\frac{1}{\text{column sum}}</annotation></semantics></math>column sum1​
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mo
    fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center
    center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">C =
    \begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0.5 \\ 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0
    & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0.5 \\ 0 & 1 & 0 &
    1 & 0 & 0 \end{bmatrix}</annotation></semantics></math>C=​000100​000001​010000​000001​100000​0.50000.50​​
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: 'To finalize our Markov (a.k.a. transition) matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation
    encoding="application/x-tex">M</annotation></semantics></math>M, we simply perform:'
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mo>=</mo><mi>D</mi><mi>C</mi></mrow><annotation
    encoding="application/x-tex">M = DC</annotation></semantics></math>M=DC
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: Using the transition matrix
  id: totrans-split-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two possible situations: the user is in the process of typing, or
    they have finished their last word. The latter is the easiest to implement. Scan
    the user''s text, and isolate the last word. Perform a lookup on the word list
    to identify it''s index. Create a new vector containing `0`s except for that index,
    which should contain a `1`. For example, if the last word was ''is'','
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable
    rowspacing="0.16em" columnalign="center center center center center center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{s}
    = \begin{bmatrix} 0 & 0 & 0 & 0 & 0 & 1 \end{bmatrix}</annotation></semantics></math>s=[0​0​0​0​0​1​]
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Run it through our transition matrix:'
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable
    rowspacing="0.16em" columnalign="center center center center center center" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mn>0.5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo
    fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">M\vec{s}
    = \begin{bmatrix} 0.5 & 0 & 0 & 0 & 0.5 & 0 \end{bmatrix}</annotation></semantics></math>Ms=[0.5​0​0​0​0.5​0​]
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: Meaning the most probable next choices are at indices `0` and `4`, which correspond
    to "orange" and "not" respectively. This is great for autocomplete. We can simply
    list the most probable options to the user.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: Text-Generation and Steady State
  id: totrans-split-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would be pretty neat if we could use this method to automagically generate
    text, right?
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: The Naive Solution
  id: totrans-split-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each iteration, choose the most likely word from the set. Maybe randomize it
    a bit: choose a random word from the top 5 options. Unfortunately, there is an
    issue. All Markov chains are guaranteed to converge on a specific probabilistic
    state given enough iterations. In order to get text generation to work unpredictably
    and without converging, we need something a bit more complex.'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: My Solution
  id: totrans-split-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a square diagonal matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation
    encoding="application/x-tex">R</annotation></semantics></math>R with a side length
    equal to the length of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{s}</annotation></semantics></math>s.
    Fill the diagonal elements with random numbers between <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation
    encoding="application/x-tex">0</annotation></semantics></math>0 and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation
    encoding="application/x-tex">1</annotation></semantics></math>1. Then choose the
    word whose index corresponds with the highest value of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mover
    accent="true"><mi>s</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">R\vec{s}</annotation></semantics></math>Rs
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
