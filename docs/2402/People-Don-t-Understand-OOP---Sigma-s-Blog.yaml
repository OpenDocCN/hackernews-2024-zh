- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:31:42'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: People Donâ€™t Understand OOP â€“ Sigma's Blog
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: æ¥æºï¼š[https://blog.sigma-star.io/2024/01/people-dont-understand-oop/](https://blog.sigma-star.io/2024/01/people-dont-understand-oop/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: â€œOOP to me means only messaging, local retention and protection and hiding of
    state-process, and extreme late-binding of all things.â€
  id: totrans-split-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alan Kay (the guy who coined the term â€œObject Oriented Programmingâ€)
  id: totrans-split-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It seems like a lot of people dislike Object Oriented Programming. The first
    things that come to mind when hearing these three letters are cars, inheritance,
    getters, setters, and ObjectFactoryFactorySingleton.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: 'This always seemed kinda odd to me. Not only do I like OOP, I even feel that
    it often is the best/most obvious way to model a problem. Here is why I think
    that is:'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: OO Who?
  id: totrans-split-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I think before doing anything further we should probably define what we are
    talking about. Unfortunately OOP is not that well defined. So for the sake of
    coherence letâ€™s settle on a clear and unambiguous definition first.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: We will be talking about â€œobjectsâ€ a lot. So what are they? Most introduction
    texts to OOP use physical things like cars and animals to illustrate what objects
    are. And while thatâ€™s not wrong (it is literally where the object metaphor comes
    from; Alan Kay was thinking in terms of biological cells and networks.) itâ€™s certainly
    misleading, because objects are much more than that.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Peter Wegner writes: â€œObjects are collections of operations that share a state.â€'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark Stefik & Daniel Bobrow define objects as follows:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: â€œObjects are entities that combine the properties of procedures and data since
    they perform computations and save local state. Uniform use of objects contrasts
    with the use of separate procedures and data in conventional programming.â€
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s another definition by The Gang of Four: â€œObject-Oriented Programs are
    made up of objects. An object packages both data and procedures that can operate
    on data. Procedures are typically called methods or operations.â€'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, thatâ€™s a good start, but I still think an important characteristic of
    objects is missing. Maybe Tim Rentsch can help: Objects are units of state, that
    are generally opaque to the outside (This, I think, is the important part. We
    will see later why that is.). An object can however provide the possibility to
    interact with its state by the means of message-passing (= â€œmethodsâ€).'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: Wait a second. â€œ[â€¦] collections of operations that share stateâ€? â€œ[â€¦] entities
    that combine [â€¦] procedures and data [â€¦]â€? â€œ[â€¦] units of stateâ€?
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: The hell is that supposed to mean?
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: Well, it means that â€œobjectâ€ is an abstract term. An object can potentially
    be anything â€“ anything with state that is. It can be a physical item like car,
    an abstract concept, it can be any random piece of data with some sort of behavior
    attached to it. OOP just means we model our problem using these objects. Thatâ€™s
    it.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: A Class Of Its Own
  id: totrans-split-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might be thinking: â€œHold on, we defined OOP without even touching on classes.
    What gives?â€'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½ä¼šæƒ³ï¼šâ€œç­‰ç­‰ï¼Œæˆ‘ä»¬ç”šè‡³æ²¡æœ‰è§¦åŠç±»å°±å®šä¹‰äº†é¢å‘å¯¹è±¡ç¼–ç¨‹ã€‚è¿™æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿâ€
- en: 'The answer is simple: Classes are not strictly necessary for OOP. A shocker,
    I know.'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: ç­”æ¡ˆå¾ˆç®€å•ï¼šç±»å¯¹äºé¢å‘å¯¹è±¡ç¼–ç¨‹å¹¶éç»å¯¹å¿…éœ€ã€‚æ˜¯ä¸æ˜¯æœ‰ç‚¹éœ‡æƒŠï¼Ÿ
- en: Of course we need to be able to construct new objects, and class-based languages
    are admittedly way more prevalent. However, this is not the only way to achieve
    this goal.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘ä»¬éœ€è¦èƒ½å¤Ÿæ„å»ºæ–°å¯¹è±¡ï¼Œè€ŒåŸºäºç±»çš„è¯­è¨€æ˜¾ç„¶æ›´ä¸ºæ™®éã€‚ä½†æ˜¯ï¼Œè¿™ä¸æ˜¯å®ç°æ­¤ç›®æ ‡çš„å”¯ä¸€æ–¹æ³•ã€‚
- en: Languages like JavaScript (although ES6 introduced classes to the language)
    or Lua use a concept called prototype-based or prototypal OOP. Instead of providing
    a schema for constructing new objects we use an existing object as a prototype.
    This approach can even have real-world benefits, as it reduces the language complexity.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: åƒJavaScriptï¼ˆå°½ç®¡ES6å¼•å…¥äº†è¯­è¨€ä¸­çš„ç±»ï¼‰æˆ–Luaè¿™æ ·çš„è¯­è¨€ä½¿ç”¨ä¸€ç§ç§°ä¸ºåŸºäºåŸå‹æˆ–åŸå‹é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆprototypal OOPï¼‰çš„æ¦‚å¿µã€‚ä¸æ˜¯æä¾›ä¸€ä¸ªç”¨äºæ„é€ æ–°å¯¹è±¡çš„æ¨¡å¼ï¼Œè€Œæ˜¯ä½¿ç”¨ç°æœ‰å¯¹è±¡ä½œä¸ºåŸå‹ã€‚è¿™ç§æ–¹æ³•ç”šè‡³å¯ä»¥åœ¨ç°å®ä¸–ç•Œä¸­å¸¦æ¥å¥½å¤„ï¼Œå› ä¸ºå®ƒé™ä½äº†è¯­è¨€çš„å¤æ‚æ€§ã€‚
- en: '(Just as a side note: Classes donâ€™t need to be called classes. Languages like
    Go or Rust â€“ also C++ to some extend â€“ call them structs for example.)'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆåªæ˜¯é¡ºä¾¿æä¸€ä¸‹ï¼šç±»ä¸éœ€è¦è¢«ç§°ä¸ºç±»ã€‚åƒGoæˆ–Rust - ä»¥åŠåœ¨æŸç§ç¨‹åº¦ä¸Šçš„C++ - ä¾‹å¦‚ç§°å®ƒä»¬ä¸ºstructsã€‚ï¼‰
- en: Itâ€™s Hereditary
  id: totrans-split-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è¿™æ˜¯é—ä¼ çš„
- en: Another term that â€“ while not technically necessary â€“ is often associated with
    OOP is inheritance.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ä¸ªæœ¯è¯­ï¼Œè™½ç„¶åœ¨æŠ€æœ¯ä¸Šå¹¶ä¸å¿…éœ€ï¼Œä½†é€šå¸¸ä¸é¢å‘å¯¹è±¡ç¼–ç¨‹ç›¸å…³è”çš„æ˜¯ç»§æ‰¿ã€‚
- en: 'There are two reasons to use inheritance:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ç»§æ‰¿æœ‰ä¸¤ä¸ªåŸå› ï¼š
- en: The first is to reuse existing code. However, in modern programming this is
    usually discouraged in favor of object composition (an object inside another object).
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªåŸå› æ˜¯é‡ç”¨ç°æœ‰ä»£ç ã€‚ä½†æ˜¯ï¼Œåœ¨ç°ä»£ç¼–ç¨‹ä¸­ï¼Œé€šå¸¸é¼“åŠ±ä½¿ç”¨å¯¹è±¡ç»„åˆï¼ˆä¸€ä¸ªå¯¹è±¡å†…åµŒåˆ°å¦ä¸€ä¸ªå¯¹è±¡ï¼‰ã€‚
- en: The second reason (to me the more important one) is for abstraction and polymorphism.
    The technical term for this is â€œsubtypingâ€.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒä¸ªåŸå› ï¼ˆå¯¹æˆ‘æ¥è¯´æ›´é‡è¦çš„ä¸€ä¸ªï¼‰æ˜¯ç”¨äºæŠ½è±¡å’Œå¤šæ€æ€§ã€‚è¿™ç§æŠ€æœ¯æœ¯è¯­ç§°ä¸ºâ€œå­ç±»å‹åŒ–â€ã€‚
- en: â€˜Sup, Typing?
  id: totrans-split-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: â€˜å˜¿ï¼Œæ‰“å­—ä¸­ï¼Ÿ
- en: (Yes, I think this topic is important enough to warrant its own heading. ğŸ˜…)
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆæ˜¯çš„ï¼Œæˆ‘è®¤ä¸ºè¿™ä¸ªä¸»é¢˜è¶³å¤Ÿé‡è¦ï¼Œå€¼å¾—æœ‰è‡ªå·±çš„æ ‡é¢˜ã€‚ğŸ˜…ï¼‰
- en: Subtyping is not exclusive to OOP, however itâ€™s of special significance here
    since itâ€™s the primary way of modelling polymorphism. The idea is to combine multiple
    different classes that share common messages (i.e. have methods with similar semantics)
    into a super type that defines those messages. Now, the super type can be used
    instead of specifying a subtype.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: å­ç±»å‹åŒ–ä¸ä»…é™äºé¢å‘å¯¹è±¡ç¼–ç¨‹ï¼Œä½†åœ¨è¿™é‡Œå…·æœ‰ç‰¹æ®Šæ„ä¹‰ï¼Œå› ä¸ºå®ƒæ˜¯å»ºæ¨¡å¤šæ€æ€§çš„ä¸»è¦æ–¹å¼ã€‚å…¶æ€æƒ³æ˜¯å°†å…±äº«å…±åŒæ¶ˆæ¯ï¼ˆå³å…·æœ‰ç±»ä¼¼è¯­ä¹‰çš„æ–¹æ³•ï¼‰çš„å¤šä¸ªä¸åŒç±»ç»„åˆæˆä¸€ä¸ªå®šä¹‰è¿™äº›æ¶ˆæ¯çš„è¶…ç±»å‹ã€‚ç°åœ¨ï¼Œå¯ä»¥ä½¿ç”¨è¶…ç±»å‹è€Œä¸æ˜¯æŒ‡å®šå­ç±»å‹ã€‚
- en: My favorite example for how subtyping can be used in practice is the Java collections
    framework. It defines interfaces (we will later talk about what exactly interfaces
    are) for common use-cases like Lists, Queues, Sets, Maps, â€¦ as well as different
    implementations with different characteristics which support those different use-cases.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æœ€å–œæ¬¢çš„å­ç±»å‹åŒ–åœ¨å®è·µä¸­çš„ä¾‹å­æ˜¯Javaé›†åˆæ¡†æ¶ã€‚å®ƒå®šä¹‰äº†ç”¨äºåˆ—è¡¨ã€é˜Ÿåˆ—ã€é›†åˆã€æ˜ å°„ç­‰å¸¸è§ç”¨ä¾‹çš„æ¥å£ï¼ˆç¨åæˆ‘ä»¬å°†è¯¦ç»†è®¨è®ºæ¥å£æ˜¯ä»€ä¹ˆï¼‰ä»¥åŠå…·æœ‰ä¸åŒç‰¹æ€§çš„ä¸åŒå®ç°ï¼Œæ”¯æŒè¿™äº›ä¸åŒç”¨ä¾‹ã€‚
- en: wpg_div_collectionmap
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: wpg_div_collectionmap
- en: (The graph was generated from JavaDocs by scrapping all known subclasses of
    [Collection](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Collection.html)
    and [Map](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Map.html)
    and removing non-relevant nodes.)
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆå›¾è¡¨æ˜¯ä»JavaDocsç”Ÿæˆçš„ï¼Œé€šè¿‡æ£€ç´¢æ‰€æœ‰å·²çŸ¥çš„[Collection](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Collection.html)å’Œ[Map](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Map.html)çš„å­ç±»å¹¶åˆ é™¤éç›¸å…³èŠ‚ç‚¹è€Œç”Ÿæˆã€‚ï¼‰
- en: So letâ€™s say I want to process a list of data, Iâ€™d just use the List interface
    everywhere. At the point where I instantiate the List I choose ArrayList, since
    itâ€™s usually the more performant implementation. Later on it turns out that the
    program is doing a lot of inserts/deletes at the beginning of the list, which
    is pretty slow on arrays. To speed up the program I can switch to a LinkedList
    without changing any of the type signatures.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œå‡è®¾æˆ‘æƒ³å¤„ç†ä¸€ä¸ªæ•°æ®åˆ—è¡¨ï¼Œæˆ‘å¯ä»¥åœ¨æ‰€æœ‰åœ°æ–¹ä½¿ç”¨Listæ¥å£ã€‚åœ¨æˆ‘å®ä¾‹åŒ–Listçš„æ—¶å€™ï¼Œæˆ‘é€‰æ‹©ArrayListï¼Œå› ä¸ºå®ƒé€šå¸¸æ˜¯æ›´é«˜æ€§èƒ½çš„å®ç°ã€‚åæ¥å‘ç°ç¨‹åºåœ¨æ•°ç»„çš„å¼€å¤´åšäº†å¾ˆå¤šæ’å…¥/åˆ é™¤æ“ä½œï¼Œè¿™åœ¨æ•°ç»„ä¸Šéå¸¸æ…¢ã€‚ä¸ºäº†åŠ é€Ÿç¨‹åºï¼Œæˆ‘å¯ä»¥åˆ‡æ¢åˆ°LinkedListè€Œä¸æ”¹å˜ä»»ä½•ç±»å‹ç­¾åã€‚
- en: 'Side Note: When calling a method we need to know the actual class of the object,
    not just itâ€™s declared class, otherwise subtyping wonâ€™t work properly. This is
    called â€œlate/dynamic-bindingâ€. Itâ€™s technical execution is a bit tricky and is
    the main reason why in C++ objects and object-pointers behave differently (see
    vtables).'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: æ—æ³¨ï¼šåœ¨è°ƒç”¨æ–¹æ³•æ—¶ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å¯¹è±¡çš„å®é™…ç±»ï¼Œè€Œä¸ä»…ä»…æ˜¯å®ƒå£°æ˜çš„ç±»ï¼Œå¦åˆ™å­ç±»å‹åŒ–å°†æ— æ³•æ­£å¸¸å·¥ä½œã€‚è¿™ç§°ä¸ºâ€œè¿Ÿç»‘å®š/åŠ¨æ€ç»‘å®šâ€ã€‚å…¶æŠ€æœ¯æ‰§è¡Œæœ‰ç‚¹æ£˜æ‰‹ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆåœ¨C++ä¸­å¯¹è±¡å’Œå¯¹è±¡æŒ‡é’ˆè¡Œä¸ºä¸åŒçš„ä¸»è¦åŸå› ï¼ˆå‚è§vtablesï¼‰ã€‚
- en: Odd Behavior
  id: totrans-split-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¥‡æ€ªçš„è¡Œä¸º
- en: I think we canâ€™t (and shouldnâ€™t) talk about subtyping without mentioning behavioral
    subtyping and Barbara Liskov. The basic idea of behavioral subtyping is that a
    subtype should behave in a way similar to the parent type.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è®¤ä¸ºæˆ‘ä»¬ä¸èƒ½ï¼ˆä¹Ÿä¸åº”è¯¥ï¼‰è°ˆè®ºå­ç±»å‹åŒ–è€Œä¸æåˆ°è¡Œä¸ºå­ç±»å‹åŒ–å’ŒBarbara Liskovã€‚è¡Œä¸ºå­ç±»å‹åŒ–çš„åŸºæœ¬æ€æƒ³æ˜¯ï¼Œå­ç±»å‹åº”è¯¥ä»¥ä¸çˆ¶ç±»å‹ç±»ä¼¼çš„æ–¹å¼è¡Œä¸ºã€‚
- en: 'Barbara Liskov (who later won a Turing award for her work on programming languages
    and OOP in particular) formalized this concept in 1987 into â€œstrong behavioral
    subtypingâ€: A subtype should be able to be used in every situation its parent
    type can be used in.'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: Barbara Liskovï¼ˆåæ¥å› å…¶åœ¨ç¼–ç¨‹è¯­è¨€å’Œé¢å‘å¯¹è±¡ç¼–ç¨‹æ–¹é¢çš„å·¥ä½œè€Œè·å¾—å›¾çµå¥–ï¼‰åœ¨1987å¹´å°†è¿™ä¸€æ¦‚å¿µæ­£å¼å½¢æˆä¸ºâ€œå¼ºè¡Œä¸ºå­ç±»å‹åŒ–â€ï¼šå­ç±»å‹åº”è¯¥å¯ä»¥åœ¨å…¶çˆ¶ç±»å‹å¯ç”¨çš„ä»»ä½•æƒ…å†µä¸‹ä½¿ç”¨ã€‚
- en: 'â€œSubtype Requirement: LetÂ Ï†(x)Â be a property provable about objectsÂ xÂ of typeÂ T.
    ThenÂ Ï†(y)Â should be true for objectsÂ yÂ of typeÂ SÂ whereÂ SÂ is a subtype ofÂ T.â€'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: â€œå­ç±»å‹è¦æ±‚ï¼šè®©Â Ï†(x)Â ä¸ºå¯è¯æ˜çš„å…³äºç±»å‹Â TÂ çš„å¯¹è±¡Â xÂ çš„å±æ€§ã€‚é‚£ä¹ˆå¯¹äºç±»å‹Â SÂ çš„å¯¹è±¡Â yÂ ï¼Œå…¶ä¸­Â SÂ æ˜¯Â TÂ çš„å­ç±»å‹ï¼ŒÂ Ï†(y)Â åº”è¯¥ä¸ºçœŸã€‚â€
- en: This is called the Liskov substitution principle. I wonâ€™t to go into details
    here, but the basic idea is that any precondition (for types, data or state) for
    parameters can not be stronger than the super-type, while any postcondition for
    results can not be weaker than the super-type. The notion is related to the design-by-contract
    methodology that also started to pop up around the same time.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§°ä¸ºLiskovæ›¿æ¢åŸåˆ™ã€‚æˆ‘è¿™é‡Œä¸æƒ³è¯¦ç»†è®¨è®ºï¼Œä½†åŸºæœ¬æ€æƒ³æ˜¯ï¼Œä»»ä½•å‚æ•°çš„å‰ææ¡ä»¶ï¼ˆå¯¹äºç±»å‹ã€æ•°æ®æˆ–çŠ¶æ€ï¼‰éƒ½ä¸èƒ½æ¯”è¶…ç±»å‹æ›´å¼ºï¼Œè€Œç»“æœçš„ä»»ä½•åç½®æ¡ä»¶éƒ½ä¸èƒ½æ¯”è¶…ç±»å‹æ›´å¼±ã€‚è¿™ä¸ªæ¦‚å¿µä¸è®¾è®¡æŒ‰å¥‘çº¦æ–¹æ³•è®ºç›¸å…³è”ï¼Œè¯¥æ–¹æ³•è®ºä¹Ÿåœ¨å¤§çº¦åŒä¸€æ—¶é—´å¼€å§‹å‡ºç°ã€‚
- en: Way Too Abstract
  id: totrans-split-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è¿‡äºæŠ½è±¡
- en: 'In some cases we donâ€™t care about the code-sharing aspect of inheritance, but
    still want to profit off of subtyping â€“ we might never actually use the super
    type implementation of the methods and can therefore omit it entirely. This is
    in fact so common, it even has a name: Virtual or abstract methods.'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸å…³å¿ƒç»§æ‰¿çš„ä»£ç å…±äº«æ–¹é¢ï¼Œä½†ä»å¸Œæœ›ä»å­ç±»å‹åŒ–ä¸­è·ç›Š - æˆ‘ä»¬å¯èƒ½æ ¹æœ¬ä¸ä¼šå®é™…ä½¿ç”¨æ–¹æ³•çš„è¶…ç±»å‹å®ç°ï¼Œå› æ­¤å¯ä»¥å®Œå…¨çœç•¥å®ƒã€‚è¿™å®é™…ä¸Šæ˜¯å¦‚æ­¤å¸¸è§ï¼Œç”šè‡³æœ‰ä¸€ä¸ªåå­—ï¼šè™šæ‹Ÿæˆ–æŠ½è±¡æ–¹æ³•ã€‚
- en: We might even end up removing all state from our abstract super type, and only
    use it as a stencil for defining methods. This is called an interface.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç”šè‡³å¯èƒ½ä¼šä»æˆ‘ä»¬çš„æŠ½è±¡è¶…ç±»å‹ä¸­ç§»é™¤æ‰€æœ‰çŠ¶æ€ï¼Œå¹¶ä¸”ä»…å°†å…¶ç”¨ä½œå®šä¹‰æ–¹æ³•çš„æ¨¡æ¿ã€‚è¿™è¢«ç§°ä¸ºæ¥å£ã€‚
- en: 'Some languages even go a step further and completely decouple interfaces from
    classes. There are two different schools of thought:'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€äº›è¯­è¨€ç”šè‡³è¿›ä¸€æ­¥è§£è€¦æ¥å£å’Œç±»ã€‚æœ‰ä¸¤ç§ä¸åŒçš„æ€ç»´æ–¹å¼ï¼š
- en: Structural typing (as opposed to the usual nominal typing) is when interface
    implementations are not declared at all. You can simply use the object as an implementation
    as long as all necessary methods are defined. This is statically checked at compile
    time. Examples of languages that support structural typing are Go (both for interfaces
    themself and type constraints) and C++ (for concepts).
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æ„ç±»å‹åŒ–ï¼ˆä¸é€šå¸¸çš„åä¹‰ç±»å‹åŒ–ç›¸å¯¹ï¼‰æ˜¯æ¥å£å®ç°æ ¹æœ¬ä¸å£°æ˜æ—¶çš„æƒ…å†µã€‚åªè¦å®šä¹‰äº†æ‰€æœ‰å¿…è¦çš„æ–¹æ³•ï¼Œæ‚¨å°±å¯ä»¥ç®€å•åœ°å°†å¯¹è±¡ç”¨ä½œå®ç°ã€‚è¿™åœ¨ç¼–è¯‘æ—¶è¿›è¡Œé™æ€æ£€æŸ¥ã€‚æ”¯æŒç»“æ„ç±»å‹åŒ–çš„è¯­è¨€ç¤ºä¾‹åŒ…æ‹¬Goï¼ˆç”¨äºæ¥å£æœ¬èº«å’Œç±»å‹çº¦æŸï¼‰å’ŒC++ï¼ˆç”¨äºæ¦‚å¿µï¼‰ã€‚
- en: Duck typing is similar but the existence of methods is only checked at runtime.
    Languages that use this pattern include Python and JavaScript. One disadvantage
    thatâ€™s often cited is that it is more complicated to figure out which classes
    can be expected at a particular point in the program.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: é¸­å­ç±»å‹ç±»ä¼¼ï¼Œä½†ä»…åœ¨è¿è¡Œæ—¶æ£€æŸ¥æ–¹æ³•çš„å­˜åœ¨ã€‚ä½¿ç”¨æ­¤æ¨¡å¼çš„è¯­è¨€åŒ…æ‹¬Pythonå’ŒJavaScriptã€‚ç»å¸¸è¢«æåˆ°çš„ä¸€ä¸ªç¼ºç‚¹æ˜¯ï¼Œåœ¨ç¨‹åºçš„ç‰¹å®šç‚¹æ›´å¤æ‚åœ°ç¡®å®šå¯ä»¥é¢„æœŸçš„ç±»ã€‚
- en: The second pattern doesnâ€™t seem to have an established name yet. The idea is
    to declare that a class is implementing an interface after the class was already
    defined. An example of a language that does this is Rust with traits. Unfortunately,
    â€œtraitsâ€ is a horrible name for this concept, since â€œtraitsâ€ usually just refers
    to mix-ins. Iâ€™ve heard the term â€œextension traitsâ€ â€“ in reference to â€œextension
    methodsâ€ in C#/Kotlin â€“ but this doesnâ€™t seem to be very common either. Another
    language that support this feature is Haskell (they call it â€œtype classesâ€; but
    Haskell is arguably not object-oriented).
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒä¸ªæ¨¡å¼ä¼¼ä¹è¿˜æ²¡æœ‰ç¡®ç«‹çš„åç§°ã€‚è¿™ä¸ªæƒ³æ³•æ˜¯åœ¨ç±»å®šä¹‰ä¹‹åå£°æ˜è¯¥ç±»å®ç°ä¸€ä¸ªæ¥å£ã€‚ä¸€ä¸ªæ”¯æŒè¿™ç§ç‰¹æ€§çš„è¯­è¨€çš„ä¾‹å­æ˜¯Rustä¸traitsã€‚ä¸å¹¸çš„æ˜¯ï¼Œâ€œtraitsâ€å¯¹äºè¿™ä¸ªæ¦‚å¿µæ¥è¯´æ˜¯ä¸€ä¸ªå¯æ€•çš„åç§°ï¼Œå› ä¸ºâ€œtraitsâ€é€šå¸¸åªæ˜¯æŒ‡æ··å…¥ã€‚æˆ‘å¬è¯´è¿‡æœ¯è¯­â€œextension
    traitsâ€â€”â€”å‚è€ƒC#/Kotlinä¸­çš„â€œextension methodsâ€â€”â€”ä½†è¿™ä¼¼ä¹ä¹Ÿä¸æ˜¯å¾ˆå¸¸è§ã€‚å¦ä¸€ä¸ªæ”¯æŒæ­¤ç‰¹æ€§çš„è¯­è¨€æ˜¯Haskellï¼ˆä»–ä»¬ç§°å…¶ä¸ºâ€œtype
    classesâ€ï¼›ä½†Haskellå¯ä»¥è¯´ä¸æ˜¯é¢å‘å¯¹è±¡çš„ï¼‰ã€‚
- en: Hide & Seek
  id: totrans-split-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: èº²çŒ«çŒ«
- en: One term thatâ€™s often used with OOP is â€œencapsulationâ€. There are actually two
    applicable definitions of the term. The first one refers to bundling data with
    behavior (= the object metaphor). And the second one refers to restricting access
    to the state only to the objects itself. I would like to focus a bit on the latter
    since I think a lot of people donâ€™t understand it properly.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­ç»å¸¸ä½¿ç”¨çš„ä¸€ä¸ªæœ¯è¯­æ˜¯â€œå°è£…â€ã€‚å®é™…ä¸Šï¼Œè¿™ä¸ªæœ¯è¯­æœ‰ä¸¤ä¸ªé€‚ç”¨çš„å®šä¹‰ã€‚ç¬¬ä¸€ä¸ªæ˜¯æŒ‡å°†æ•°æ®ä¸è¡Œä¸ºæ†ç»‘åœ¨ä¸€èµ·ï¼ˆå³å¯¹è±¡æ¯”å–»ï¼‰ã€‚ç¬¬äºŒä¸ªæ˜¯æŒ‡ä»…å°†å¯¹çŠ¶æ€çš„è®¿é—®é™åˆ¶åœ¨å¯¹è±¡æœ¬èº«ã€‚æˆ‘æƒ³é›†ä¸­è®¨è®ºåè€…ï¼Œå› ä¸ºæˆ‘è®¤ä¸ºå¾ˆå¤šäººå¹¶æ²¡æœ‰å®Œå…¨ç†è§£å®ƒã€‚
- en: â€œEncapsulation is a technique for minimizing interdependencies among separately-written
    modules by defining strict external interfaces.â€
  id: totrans-split-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: â€œå°è£…æ˜¯ä¸€ç§é€šè¿‡å®šä¹‰ä¸¥æ ¼çš„å¤–éƒ¨æ¥å£æ¥æœ€å°åŒ–åˆ†å¼€ç¼–å†™çš„æ¨¡å—ä¹‹é—´ç›¸äº’ä¾èµ–çš„æŠ€æœ¯ã€‚â€
- en: Alan Snyder, 1986
  id: totrans-split-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Alan Snyderï¼Œ1986
- en: 'So why is it important to restrict access to state? Well, there are multiple
    reasons. We could argue that it would violate Liskovâ€™s history constraint. But
    I think itâ€™s much more practical to look at it from the perspective of a developer
    who wants to refactor the code base. Letâ€™s say we want to change the internal
    structure of an object (like in the List example earlier, maybe we want to switch
    from an ArrayList to a LinkedList). But if other components are reliant on the
    internal state (in the case of the ArrayList: this could be the internal primitive
    array) we can not easily change it. We would need to find all places outside of
    the class where the internal structure is referenced. The problem gets even worse
    when the class is exported and used by modules that we might not even control.'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ä¸ºä»€ä¹ˆé™åˆ¶å¯¹çŠ¶æ€çš„è®¿é—®å¾ˆé‡è¦å‘¢ï¼Ÿå¥½å§ï¼Œæœ‰å¤šä¸ªåŸå› ã€‚æˆ‘ä»¬å¯ä»¥è¯´è¿™è¿åäº†Liskovçš„å†å²çº¦æŸã€‚ä½†æˆ‘è®¤ä¸ºä»æƒ³é‡æ„ä»£ç åº“çš„å¼€å‘è€…çš„è§’åº¦æ¥çœ‹æ›´ä¸ºå®é™…ã€‚å‡è®¾æˆ‘ä»¬æƒ³æ”¹å˜å¯¹è±¡çš„å†…éƒ¨ç»“æ„ï¼ˆå°±åƒä¹‹å‰çš„Listç¤ºä¾‹ä¸­ä¸€æ ·ï¼Œä¹Ÿè®¸æˆ‘ä»¬æƒ³ä»ArrayListåˆ‡æ¢åˆ°LinkedListï¼‰ã€‚ä½†æ˜¯å¦‚æœå…¶ä»–ç»„ä»¶ä¾èµ–äºå†…éƒ¨çŠ¶æ€ï¼ˆåœ¨ArrayListçš„æƒ…å†µä¸‹ï¼šè¿™å¯èƒ½æ˜¯å†…éƒ¨åŸå§‹æ•°ç»„ï¼‰ï¼Œæˆ‘ä»¬æ— æ³•è½»æ¾æ›´æ”¹å®ƒã€‚æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ç±»å¤–å¼•ç”¨å†…éƒ¨ç»“æ„çš„æ‰€æœ‰åœ°æ–¹ã€‚å½“ç±»è¢«å¯¼å‡ºå¹¶ç”±æˆ‘ä»¬å¯èƒ½æ— æ³•æ§åˆ¶çš„æ¨¡å—ä½¿ç”¨æ—¶ï¼Œé—®é¢˜ä¼šå˜å¾—æ›´åŠ ä¸¥é‡ã€‚
- en: â€œ(Object) couplingâ€ and â€œ(class) cohesionâ€ are often used to talk about encapsulation.
    â€œObject couplingâ€ describes how much different objects depend on each other. High
    â€œobject couplingâ€ implies that the objects in question rely a lot on each other,
    which usually means they should be one single object instead. If objects rely
    on each others internal structure they are highly coupled. â€œClass cohesionâ€ describes
    the same characteristic but from a different perspective. Itâ€™s a measure of how
    coherent a classâ€™ responsibilities are. A class should ideally represent one idea
    and only do stuff related to that idea. Low â€œclass cohesionâ€ usually means high
    â€œobject couplingâ€ and vice versa.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: â€œï¼ˆå¯¹è±¡ï¼‰è€¦åˆâ€å’Œâ€œï¼ˆç±»ï¼‰å†…èšâ€ç»å¸¸ç”¨æ¥è°ˆè®ºå°è£…ã€‚â€œå¯¹è±¡è€¦åˆâ€æè¿°äº†ä¸åŒå¯¹è±¡å½¼æ­¤ä¾èµ–çš„ç¨‹åº¦ã€‚é«˜â€œå¯¹è±¡è€¦åˆâ€æ„å‘³ç€ç›¸å…³å¯¹è±¡ä¹‹é—´çš„ä¾èµ–å¾ˆå¤§ï¼Œé€šå¸¸æ„å‘³ç€å®ƒä»¬åº”è¯¥æ˜¯ä¸€ä¸ªå•ä¸€å¯¹è±¡ã€‚å¦‚æœå¯¹è±¡ä¾èµ–äºå½¼æ­¤çš„å†…éƒ¨ç»“æ„ï¼Œåˆ™å®ƒä»¬è€¦åˆæ€§å¾ˆé«˜ã€‚â€œç±»å†…èšâ€ä»ä¸åŒçš„è§’åº¦æè¿°äº†ç›¸åŒçš„ç‰¹æ€§ã€‚å®ƒè¡¡é‡äº†ä¸€ä¸ªç±»çš„è´£ä»»æœ‰å¤šä¸€è‡´ã€‚ä¸€ä¸ªç±»ç†æƒ³æƒ…å†µä¸‹åº”è¯¥ä»£è¡¨ä¸€ä¸ªæƒ³æ³•ï¼Œå¹¶ä¸”åªæ‰§è¡Œä¸è¯¥æƒ³æ³•ç›¸å…³çš„æ“ä½œã€‚ä½â€œç±»å†…èšâ€é€šå¸¸æ„å‘³ç€é«˜â€œå¯¹è±¡è€¦åˆâ€ï¼Œåä¹‹äº¦ç„¶ã€‚
- en: Iâ€™m sure if you have done any object-oriented programming youâ€™ve heard something
    like â€œDonâ€™t use public properties [â€¦]â€ (properties in the sense of member variables)
    at some point. And this is true, because public properties expose the internal
    state, and can potentially cause high object coupling. However, as with any dogma,
    itâ€™s usually a good idea to question it. In this case the complete â€œguidelineâ€
    is â€œDonâ€™t use public properties, use getters and setters instead.â€, which is completely
    wrong. In terms of encapsulation getters and setters are just as bad as public
    properties, as they do nothing to prevent object coupling. If you have a class
    without any methods (besides getters and setters) it doesnâ€™t really fit our object
    definition. A term that has been used for this is â€œrecordâ€.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ç›¸ä¿¡å¦‚æœä½ æœ‰è¿›è¡Œè¿‡ä»»ä½•é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼Œä½ ä¸€å®šå¬è¯´è¿‡ç±»ä¼¼â€œä¸è¦ä½¿ç”¨å…¬å…±å±æ€§[...]â€çš„å»ºè®®ã€‚è¿™æ˜¯çœŸçš„ï¼Œå› ä¸ºå…¬å…±å±æ€§æš´éœ²äº†å†…éƒ¨çŠ¶æ€ï¼Œå¯èƒ½ä¼šå¯¼è‡´é«˜å¯¹è±¡è€¦åˆã€‚ç„¶è€Œï¼Œå’Œä»»ä½•æ•™æ¡ä¸€æ ·ï¼Œé€šå¸¸è´¨ç–‘å®ƒæ˜¯ä¸€ä¸ªå¥½ä¸»æ„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®Œæ•´çš„â€œæŒ‡å¯¼åŸåˆ™â€æ˜¯â€œä¸è¦ä½¿ç”¨å…¬å…±å±æ€§ï¼Œè€Œæ˜¯ä½¿ç”¨getterå’Œsetterã€‚â€è¿™å®Œå…¨æ˜¯é”™è¯¯çš„ã€‚åœ¨å°è£…æ–¹é¢ï¼Œgetterå’Œsetterä¸å…¬å…±å±æ€§ä¸€æ ·ç³Ÿç³•ï¼Œå› ä¸ºå®ƒä»¬å¯¹é˜»æ­¢å¯¹è±¡è€¦åˆæ²¡æœ‰ä»»ä½•ä½œç”¨ã€‚å¦‚æœä¸€ä¸ªç±»é™¤äº†getterå’Œsetterä¹‹å¤–æ²¡æœ‰ä»»ä½•æ–¹æ³•ï¼Œå®ƒå®é™…ä¸Šå¹¶ä¸ç¬¦åˆæˆ‘ä»¬çš„å¯¹è±¡å®šä¹‰ã€‚ç”¨äºè¿™ç§æƒ…å†µçš„æœ¯è¯­æ˜¯â€œè®°å½•â€ã€‚
- en: '};'
  id: totrans-split-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '};'
- en: 'Okay, so what it OOP? OOP is when related state and behavior are bundled into
    units (= objects). Other properties object-oriented languages *may* have are:
    Classes, prototypes, encapsulation, subtyping, inheritance, â€¦'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œé‚£ä¹ˆé¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰æ˜¯ä»€ä¹ˆï¼ŸOOPæ˜¯å°†ç›¸å…³çŠ¶æ€å’Œè¡Œä¸ºæ†ç»‘æˆå•å…ƒï¼ˆ= å¯¹è±¡ï¼‰ã€‚é¢å‘å¯¹è±¡è¯­è¨€å¯èƒ½å…·æœ‰çš„å…¶ä»–ç‰¹æ€§åŒ…æ‹¬ï¼šç±»ã€åŸå‹ã€å°è£…ã€å­ç±»å‹ã€ç»§æ‰¿ç­‰ã€‚
- en: 'Letâ€™s take a look at some modern languages (these are the top 15 languages
    from the [StackOverflow Developer Survey 2023](https://survey.stackoverflow.co/2023/#section-most-popular-technologies-programming-scripting-and-markup-languages)
    â€“ excluding stuff like HTML, â€¦):'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥çœ‹çœ‹ä¸€äº›ç°ä»£è¯­è¨€ï¼ˆè¿™äº›æ˜¯æ¥è‡ª[StackOverflow 2023å¼€å‘è€…è°ƒæŸ¥](https://survey.stackoverflow.co/2023/#section-most-popular-technologies-programming-scripting-and-markup-languages)çš„å‰15ç§è¯­è¨€ï¼Œä¸åŒ…æ‹¬HTMLç­‰...ï¼‰ï¼š
- en: '| Language | Objs | Obj Creation | Encapsulation | Subtyping |'
  id: totrans-split-62
  prefs: []
  type: TYPE_TB
  zh: '| è¯­è¨€ | å¯¹è±¡ | å¯¹è±¡åˆ›å»º | å°è£… | å­ç±»å‹ |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| JavaScript | âœ”ï¸ | Classes/ Prototypes'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: '| JavaScript | âœ”ï¸ | ç±»/åŸå‹'
- en: '| âœ”ï¸ (since ES2022) | Inheritance/ Duck typing |'
  id: totrans-split-65
  prefs: []
  type: TYPE_TB
  zh: '| âœ”ï¸ï¼ˆè‡ªES2022èµ·ï¼‰ | ç»§æ‰¿/é¸­å­ç±»å‹ï¼ˆInheritance/ Duck typingï¼‰ |'
- en: '| Python | âœ”ï¸ | Classes | âŒ (not on a language level) | Inheritance/ Duck typing
    |'
  id: totrans-split-66
  prefs: []
  type: TYPE_TB
  zh: '| Python | âœ”ï¸ | ç±»ï¼ˆClassesï¼‰ | âŒï¼ˆè¯­è¨€å±‚é¢ä¸Šæ²¡æœ‰ï¼‰ | ç»§æ‰¿/é¸­å­ç±»å‹ï¼ˆInheritance/ Duck typingï¼‰
    |'
- en: '| TypeScript | âœ”ï¸ | Classes/ Prototypes | âœ”ï¸ | Inheritance/ Structural typing/'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: '| TypeScript | âœ”ï¸ | ç±»/åŸå‹ï¼ˆClasses/ Prototypesï¼‰ | âœ”ï¸ | ç»§æ‰¿/ç»“æ„ç±»å‹ï¼ˆInheritance/ Structural
    typingï¼‰ |'
- en: Duck typing |
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: é¸­å­ç±»å‹ |
- en: '| ShellScript | âŒ | âŒ | âŒ | âŒ |'
  id: totrans-split-69
  prefs: []
  type: TYPE_TB
  zh: '| ShellScript | âŒ | âŒ | âŒ | âŒ |'
- en: '| Java | âœ”ï¸ | Classes | âœ”ï¸ | Inheritance/ Nominal typing |'
  id: totrans-split-70
  prefs: []
  type: TYPE_TB
  zh: '| Java | âœ”ï¸ | ç±»ï¼ˆClassesï¼‰ | âœ”ï¸ | ç»§æ‰¿/å‘½åç±»å‹ï¼ˆInheritance/ Nominal typingï¼‰ |'
- en: '| C# | âœ”ï¸ | Classes | âœ”ï¸ | Inheritance/ Nominal typing |'
  id: totrans-split-71
  prefs: []
  type: TYPE_TB
  zh: '| C# | âœ”ï¸ | ç±»ï¼ˆClassesï¼‰ | âœ”ï¸ | ç»§æ‰¿/å‘½åç±»å‹ï¼ˆInheritance/ Nominal typingï¼‰ |'
- en: '| C++ | âœ”ï¸ | Classes + Structs | âœ”ï¸ | Inheritance/ Nominal typing +'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: '| C++ | âœ”ï¸ | ç±» + ç»“æ„ä½“ï¼ˆClasses + Structsï¼‰ | âœ”ï¸ | ç»§æ‰¿/å‘½åç±»å‹ï¼ˆInheritance/ Nominal
    typingï¼‰ +'
- en: Structural typing (concepts) |
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æ„ç±»å‹ï¼ˆæ¦‚å¿µï¼‰ |
- en: '| C | âŒ (no methods) | Structs | âœ”ï¸ (kinda using incomplete types) | âŒ (single
    â€œinheritanceâ€ by nesting structs; no real subtyping) |'
  id: totrans-split-74
  prefs: []
  type: TYPE_TB
  zh: '| C | âŒï¼ˆæ²¡æœ‰æ–¹æ³•ï¼‰ | ç»“æ„ä½“ï¼ˆStructsï¼‰ | âœ”ï¸ï¼ˆä½¿ç”¨ä¸å®Œæ•´ç±»å‹ï¼‰ | âŒï¼ˆé€šè¿‡åµŒå¥—ç»“æ„ä½“å®ç°çš„å•ä¸€â€œç»§æ‰¿â€ï¼Œæ²¡æœ‰çœŸæ­£çš„å­ç±»å‹ï¼‰ |'
- en: '| PHP | âœ”ï¸ | Classes | âœ”ï¸ | Inheritance/ Duck typing |'
  id: totrans-split-75
  prefs: []
  type: TYPE_TB
  zh: '| PHP | âœ”ï¸ | ç±»ï¼ˆClassesï¼‰ | âœ”ï¸ | ç»§æ‰¿/é¸­å­ç±»å‹ï¼ˆInheritance/ Duck typingï¼‰ |'
- en: '| PowerShell | âœ”ï¸ | Classes | âŒ | Inheritance/ Duck typing* |'
  id: totrans-split-76
  prefs: []
  type: TYPE_TB
  zh: '| PowerShell | âœ”ï¸ | ç±»ï¼ˆClassesï¼‰ | âŒ | ç»§æ‰¿/é¸­å­ç±»å‹*ï¼ˆInheritance/ Duck typing*ï¼‰ |'
- en: '| Go | âœ”ï¸ | Structs | âœ”ï¸ (on package level) | Structural typing |'
  id: totrans-split-77
  prefs: []
  type: TYPE_TB
  zh: '| Go | âœ”ï¸ | ç»“æ„ä½“ï¼ˆStructsï¼‰ | âœ”ï¸ï¼ˆåœ¨åŒ…çº§åˆ«ä¸Šï¼‰ | ç»“æ„ç±»å‹ |'
- en: '| Rust | âœ”ï¸ | Structs | âœ”ï¸ | Extension Traits/ Nominal typing |'
  id: totrans-split-78
  prefs: []
  type: TYPE_TB
  zh: '| Rust | âœ”ï¸ | ç»“æ„ä½“ï¼ˆStructsï¼‰ | âœ”ï¸ | æ‰©å±•ç‰¹æ€§/å‘½åç±»å‹ï¼ˆExtension Traits/ Nominal typingï¼‰
    |'
- en: '| Kotlin | âœ”ï¸ | Classes | âœ”ï¸ | Inheritance/ Nominal typing |'
  id: totrans-split-79
  prefs: []
  type: TYPE_TB
  zh: '| Kotlin | âœ”ï¸ | ç±»ï¼ˆClassesï¼‰ | âœ”ï¸ | ç»§æ‰¿/å‘½åç±»å‹ï¼ˆInheritance/ Nominal typingï¼‰ |'
- en: '| Ruby | âœ”ï¸ | Classes | âœ”ï¸ (enforced) | Inheritance/ Duck typing |'
  id: totrans-split-80
  prefs: []
  type: TYPE_TB
  zh: '| Ruby | âœ”ï¸ | ç±»ï¼ˆClassesï¼‰ | âœ”ï¸ï¼ˆå¼ºåˆ¶ï¼‰ | ç»§æ‰¿/é¸­å­ç±»å‹ï¼ˆInheritance/ Duck typingï¼‰ |'
- en: '| Lua | âœ”ï¸ | Tables (Prototypes) | âŒ | Inheritance/ Duck typing |'
  id: totrans-split-81
  prefs: []
  type: TYPE_TB
  zh: '| Lua | âœ”ï¸ | è¡¨ï¼ˆåŸå‹ï¼‰ | âŒ | ç»§æ‰¿/é¸­å­ç±»å‹ï¼ˆInheritance/ Duck typingï¼‰ |'
- en: '*) not sure'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*) ä¸ç¡®å®š'
- en: O-Oh, Noâ€¦
  id: totrans-split-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å™¢-å™¢ï¼Œä¸å¥½äº†â€¦â€¦
- en: Okay. Now that we have a good understanding of what exactly OOP is and what
    we can expect from languages that implement the OOP paradigm, letâ€™s take a look
    at some common points of criticism. (I shamelessly crowdsourced most of the following
    part by asking my friends what they hate about OOP. ğŸ˜‹)
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½äº†ã€‚ç°åœ¨æˆ‘ä»¬å¯¹é¢å‘å¯¹è±¡ç¼–ç¨‹æ˜¯ä»€ä¹ˆä»¥åŠæˆ‘ä»¬å¯ä»¥ä»å®ç°OOPèŒƒå¼çš„è¯­è¨€ä¸­æœŸå¾…ä»€ä¹ˆæœ‰äº†å¾ˆå¥½çš„ç†è§£ï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹ä¸€äº›å¸¸è§çš„æ‰¹è¯„ç‚¹ã€‚ï¼ˆæˆ‘åšé¢œæ— è€»åœ°é€šè¿‡è¯¢é—®æœ‹å‹ä»¬è®¨åŒOOPçš„åŸå› æ¥è·å¾—ä»¥ä¸‹å¤§éƒ¨åˆ†å†…å®¹ã€‚ğŸ˜‹ï¼‰
- en: But What ARE Objects?
  id: totrans-split-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ä»€ä¹ˆæ˜¯å¯¹è±¡ï¼Ÿ
- en: So, objects can be anything, right? So how do I know what should be an object?
    When should I combine things, what should be separate?
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œå¯¹è±¡å¯ä»¥æ˜¯ä»»ä½•ä¸œè¥¿ï¼Œå¯¹å§ï¼Ÿé‚£ä¹ˆæˆ‘å¦‚ä½•çŸ¥é“ä»€ä¹ˆåº”è¯¥æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Ÿä»€ä¹ˆæ—¶å€™åº”è¯¥å°†äº‹ç‰©ç»“åˆåœ¨ä¸€èµ·ï¼Œä»€ä¹ˆåº”è¯¥åˆ†å¼€ï¼Ÿ
- en: Well, in the end itâ€™s just practice and experience. With time youâ€™ll get a feeling
    about what should and what shouldnâ€™t be an object. However, to get started there
    are some tricks that might help you.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: å—¯ï¼Œåœ¨æœ€åï¼Œè¿™åªæ˜¯å®è·µå’Œç»éªŒé—®é¢˜ã€‚éšç€æ—¶é—´çš„æ¨ç§»ï¼Œä½ ä¼šå¯¹ä»€ä¹ˆåº”è¯¥æ˜¯å¯¹è±¡ï¼Œä»€ä¹ˆä¸åº”è¯¥æ˜¯å¯¹è±¡æœ‰æ‰€æ„Ÿè§‰ã€‚ç„¶è€Œï¼Œä¸ºäº†å¼€å§‹ï¼Œæœ‰ä¸€äº›æŠ€å·§å¯èƒ½ä¼šå¯¹ä½ æœ‰æ‰€å¸®åŠ©ã€‚
- en: 'Hereâ€™s what The Gang of Four has to say:'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ã€Šå››äººå¸®ã€‹çš„çœ‹æ³•ï¼š
- en: â€œObject-oriented design methodologies favor many different approaches. You can
    write a problem statement, single out the nouns and verbs, and create corresponding
    classes and operations. Or you can focus on the collaborations and responsibilities
    in your system. Or you can model the real world and translate the objects found
    during analysis into design. There will always be disagreement on which approach
    is best.â€
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: â€œé¢å‘å¯¹è±¡è®¾è®¡æ–¹æ³•åçˆ±å¤šç§ä¸åŒçš„æ–¹æ³•ã€‚ä½ å¯ä»¥ç¼–å†™é—®é¢˜é™ˆè¿°ï¼Œå•ç‹¬æ‰¾å‡ºåè¯å’ŒåŠ¨è¯ï¼Œç„¶ååˆ›å»ºç›¸åº”çš„ç±»å’Œæ“ä½œã€‚æˆ–è€…ä½ å¯ä»¥ä¸“æ³¨äºç³»ç»Ÿä¸­çš„åä½œå’Œè´£ä»»ã€‚æˆ–è€…ä½ å¯ä»¥å¯¹ç°å®ä¸–ç•Œè¿›è¡Œå»ºæ¨¡ï¼Œå¹¶å°†åˆ†æä¸­æ‰¾åˆ°çš„å¯¹è±¡è½¬åŒ–ä¸ºè®¾è®¡ã€‚å¯¹äºå“ªç§æ–¹æ³•æœ€å¥½ï¼Œæ€»ä¼šå­˜åœ¨åˆ†æ­§ã€‚â€
- en: Speedy Thing Goes In, Speedy Thing Comes Out
  id: totrans-split-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¿«é€Ÿçš„ä¸œè¥¿è¿›å»ï¼Œå¿«é€Ÿçš„ä¸œè¥¿å‡ºæ¥
- en: 'EDIT: It has been pointed out to me that a made a few mistakes when designing
    the benchmarks. Thanks to NoNaeAbC on Github for pointing out that Iâ€™m allocating
    and zeroing way too much memory in the OOP and SP tests, and u9vata on Youtube
    for critiquing my benchmark design. With regard to the latter, while I donâ€™t agree
    with everything they said, itâ€™s definitely true that I was making some unfounded
    assumptions about compiler optimisation.'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–è¾‘ï¼šæœ‰äººæŒ‡å‡ºæˆ‘åœ¨è®¾è®¡åŸºå‡†æµ‹è¯•æ—¶çŠ¯äº†å‡ ä¸ªé”™è¯¯ã€‚æ„Ÿè°¢Githubä¸Šçš„NoNaeAbCæŒ‡å‡ºæˆ‘åœ¨é¢å‘å¯¹è±¡ç¼–ç¨‹å’Œç»“æ„åŒ–ç¼–ç¨‹æµ‹è¯•ä¸­åˆ†é…å’Œæ¸…é›¶äº†å¤ªå¤šå†…å­˜ï¼Œä»¥åŠYoutubeä¸Šçš„u9vataæ‰¹è¯„äº†æˆ‘çš„åŸºå‡†è®¾è®¡ã€‚å…³äºåè€…ï¼Œè™½ç„¶æˆ‘ä¸åŒæ„ä»–ä»¬çš„æ‰€æœ‰è§‚ç‚¹ï¼Œä½†çš„ç¡®æ˜¯æˆ‘å¯¹ç¼–è¯‘å™¨ä¼˜åŒ–åšå‡ºäº†ä¸€äº›æ— æ ¹æ®çš„å‡è®¾ã€‚
- en: Iâ€™m not sure when Iâ€™ll have the time to redesign the benchmarks, so for the
    time being, please take the following with a big grain of salt.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¸ç¡®å®šä½•æ—¶ä¼šæœ‰æ—¶é—´é‡æ–°è®¾è®¡åŸºå‡†æµ‹è¯•ï¼Œå› æ­¤åœ¨è¿™æ®µæ—¶é—´å†…ï¼Œè¯·å¯¹ä»¥ä¸‹å†…å®¹ä¿æŒæ€€ç–‘æ€åº¦ã€‚
- en: 'While we are at it, I also came up with another explanation on why the FP tests
    are so slow: The band is stored as increasingly nested closures, which have to
    store their arguments on the heap, while the OOP and SP version can exclusively
    work on the stack.'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: é¡ºä¾¿è¯´ä¸€å¥ï¼Œæˆ‘ä¹Ÿæƒ³å‡ºäº†å¦ä¸€ä¸ªè§£é‡Šï¼Œè§£é‡Šä¸ºä»€ä¹ˆå‡½æ•°å¼ç¼–ç¨‹æµ‹è¯•å¦‚æ­¤ç¼“æ…¢ï¼šä¹é˜Ÿè¢«å­˜å‚¨ä¸ºè¶Šæ¥è¶ŠåµŒå¥—çš„é—­åŒ…ï¼Œè¿™äº›é—­åŒ…å¿…é¡»å°†å®ƒä»¬çš„å‚æ•°å­˜å‚¨åœ¨å †ä¸Šï¼Œè€Œé¢å‘å¯¹è±¡å’Œç»“æ„åŒ–ç¼–ç¨‹ç‰ˆæœ¬åˆ™å¯ä»¥å®Œå…¨åœ¨æ ˆä¸Šå·¥ä½œã€‚
- en: OOP is slow. Or so Iâ€™ve heard. The rationale is that vtable lookups are overhead
    compared to direct function calls. I donâ€™t actually know whether thatâ€™s true,
    so I decided to test it.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰å¾ˆæ…¢ã€‚æˆ–è€…è¿™æ˜¯æˆ‘å¬è¯´çš„ã€‚ç†ç”±æ˜¯è™šè¡¨æŸ¥æ‰¾æ¯”ç›´æ¥å‡½æ•°è°ƒç”¨å¤šä½™ã€‚æˆ‘å®é™…ä¸Šä¸çŸ¥é“è¿™æ˜¯ä¸æ˜¯çœŸçš„ï¼Œæ‰€ä»¥æˆ‘å†³å®šè¿›è¡Œæµ‹è¯•ã€‚
- en: 'The test setup is as follows: I wrote the same program (a Turing machine checking
    for binary palindromes) 3 times, once using object-oriented programming, once
    using structured programming (only using functions, loops, tuples, arrays â€“ stuff
    like that), and once using functional programming for good measure.'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: æµ‹è¯•è®¾ç½®å¦‚ä¸‹ï¼šæˆ‘å†™äº†ç›¸åŒçš„ç¨‹åºï¼ˆæ£€æŸ¥äºŒè¿›åˆ¶å›æ–‡çš„å›¾çµæœºï¼‰ä¸‰æ¬¡ï¼Œä¸€æ¬¡ä½¿ç”¨é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼Œä¸€æ¬¡ä½¿ç”¨ç»“æ„åŒ–ç¼–ç¨‹ï¼ˆä»…ä½¿ç”¨å‡½æ•°ã€å¾ªç¯ã€å…ƒç»„ã€æ•°ç»„ç­‰ç­‰ï¼‰ï¼Œè¿˜æœ‰ä¸€æ¬¡ä¸ºäº†å……åˆ†è€ƒè™‘ä½¿ç”¨å‡½æ•°å¼ç¼–ç¨‹ã€‚
- en: I implemented everything in C++ so itâ€™s an equal playing field (also, C++ has
    first class functions/lambda expressions for the functional version). There is
    100 000 test cases, the total time is measured. The compiler is clang 14.0.3,
    the target platform is Apple Silicon (M1). I ran each test with both -O0 and -O3.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ç”¨C++å®ç°äº†æ‰€æœ‰å†…å®¹ï¼Œè¿™æ ·æ˜¯å…¬å¹³ç«äº‰çš„åŸºç¡€ï¼ˆæ­¤å¤–ï¼ŒC++ä¸ºå‡½æ•°å¼ç‰ˆæœ¬æä¾›äº†ä¸€æµçš„å‡½æ•°/lambdaè¡¨è¾¾å¼ï¼‰ã€‚æœ‰100,000ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ€»æ—¶é—´å·²æµ‹é‡ã€‚ç¼–è¯‘å™¨æ˜¯clang
    14.0.3ï¼Œç›®æ ‡å¹³å°æ˜¯Apple Siliconï¼ˆM1ï¼‰ã€‚æˆ‘ç”¨-O0å’Œ-O3åˆ†åˆ«è¿è¡Œäº†æ¯ä¸ªæµ‹è¯•ã€‚
- en: For the OOP implementation I made sure to not rely on heap allocations, since
    the context switches would probably completely ruin the runtime. I did however
    use inheritance (the template pattern to be specific) to make the vtable lookups
    as realistic as possible.
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºé¢å‘å¯¹è±¡çš„å®ç°ï¼Œæˆ‘ç¡®ä¿ä¸ä¾èµ–å †åˆ†é…ï¼Œå› ä¸ºä¸Šä¸‹æ–‡åˆ‡æ¢å¯èƒ½ä¼šå®Œå…¨ç ´åè¿è¡Œæ—¶ã€‚ä½†æ˜¯ï¼Œæˆ‘ç¡®å®ä½¿ç”¨äº†ç»§æ‰¿ï¼ˆå…·ä½“æ¥è¯´æ˜¯æ¨¡æ¿æ¨¡å¼ï¼‰ï¼Œä»¥ä½¿è™šè¡¨æŸ¥æ‰¾å°½å¯èƒ½çœŸå®ã€‚
- en: The structured version also allocates everything on the stack. I build two different
    versions. The first one uses tuples in the transition table lookup, however I
    wasnâ€™t sure how tuples are implemented under the hood and I wanted to avoid using
    objects by accident if possible, so I wrote another version that only relies on
    functions. But it turned out the results were so close I couldnâ€™t tell the difference.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æ„åŒ–ç‰ˆæœ¬è¿˜åœ¨å †æ ˆä¸Šåˆ†é…æ‰€æœ‰å†…å®¹ã€‚æˆ‘æ„å»ºäº†ä¸¤ä¸ªä¸åŒçš„ç‰ˆæœ¬ã€‚ç¬¬ä¸€ä¸ªç‰ˆæœ¬åœ¨è½¬æ¢è¡¨æŸ¥æ‰¾ä¸­ä½¿ç”¨äº†å…ƒç»„ï¼Œä½†æˆ‘ä¸ç¡®å®šå…ƒç»„åœ¨å†…éƒ¨æ˜¯å¦‚ä½•å®ç°çš„ï¼Œå¦‚æœå¯èƒ½çš„è¯ï¼Œæˆ‘æƒ³é¿å…æ„å¤–ä½¿ç”¨å¯¹è±¡ï¼Œæ‰€ä»¥æˆ‘å†™äº†å¦ä¸€ä¸ªåªä¾èµ–å‡½æ•°çš„ç‰ˆæœ¬ã€‚ä½†ç»“æœæ˜¾ç¤ºä¸¤è€…éå¸¸æ¥è¿‘ï¼Œæˆ‘åˆ†è¾¨ä¸å‡ºæœ‰ä»€ä¹ˆåŒºåˆ«ã€‚
- en: <canvas id="myiChartbenchmarks--o0-1"></canvas>
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: <canvas id="myiChartbenchmarks--o0-1"></canvas>
- en: <canvas id="myiChartbenchmarks--o3-2"></canvas>
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: <canvas id="myiChartbenchmarks--o3-2"></canvas>
- en: As we can see, the structured version is marginally (~ 5 %) faster than the
    object-oriented one when not using any optimization (Although I should mention
    that I observed the values jumping quite a lot between runs). When using -O3 the
    performance is basically identical (~ 1 %), so my guess is that the C++ optimizer
    was able to get rid of whatever impacted the performance.
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬æ‰€çœ‹åˆ°çš„ï¼Œç»“æ„åŒ–ç‰ˆæœ¬åœ¨æ²¡æœ‰ä½¿ç”¨ä»»ä½•ä¼˜åŒ–æ—¶ï¼Œé€Ÿåº¦æ¯”é¢å‘å¯¹è±¡ç‰ˆæœ¬ç¨å¿«ï¼ˆå¤§çº¦5%ï¼‰ï¼ˆè™½ç„¶æˆ‘åº”è¯¥æåˆ°ï¼Œåœ¨è¿è¡Œä¹‹é—´è§‚å¯Ÿåˆ°çš„å€¼æœ‰å¾ˆå¤§çš„è·³åŠ¨ï¼‰ã€‚å½“ä½¿ç”¨ -O3
    æ—¶ï¼Œæ€§èƒ½åŸºæœ¬ä¸Šæ˜¯ç›¸åŒçš„ï¼ˆçº¦ä¸º1%ï¼‰ï¼Œæ‰€ä»¥æˆ‘çŒœæµ‹ C++ ä¼˜åŒ–å™¨èƒ½å¤Ÿæ¶ˆé™¤å½±å“æ€§èƒ½çš„ä»»ä½•ä¸œè¥¿ã€‚
- en: The functional implementation is not even remotely close. To a certain extend
    this is probably caused by the benchmark I chose. Turing machines are inherently
    stateful, which is pretty awkward to model in a functional way. Another aspect
    is that even though I used C++14 (which supports return type inference) I was
    forced to use the std::function template as a wrapper for lambda expressions (anonymous
    types are a pain in the backside) which (according to my tests) are quite a bit
    slower than native lambda expressions.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: å‡½æ•°å¼å®ç°æ ¹æœ¬ä¸æ¥è¿‘ã€‚åœ¨æŸç§ç¨‹åº¦ä¸Šï¼Œè¿™å¯èƒ½æ˜¯ç”±æˆ‘é€‰æ‹©çš„åŸºå‡†æµ‹è¯•å¼•èµ·çš„ã€‚å›¾çµæœºåœ¨æœ¬è´¨ä¸Šæ˜¯æœ‰çŠ¶æ€çš„ï¼Œè¿™åœ¨å‡½æ•°å¼æ¨¡å‹ä¸­å»ºæ¨¡èµ·æ¥ç›¸å½“å°´å°¬ã€‚å¦ä¸€ä¸ªæ–¹é¢æ˜¯ï¼Œå°½ç®¡æˆ‘ä½¿ç”¨äº†æ”¯æŒè¿”å›ç±»å‹æ¨æ–­çš„
    C++14ï¼ˆä½†æˆ‘è¢«è¿«ä½¿ç”¨äº† std::function æ¨¡æ¿ä½œä¸º lambda è¡¨è¾¾å¼çš„åŒ…è£…å™¨ï¼ˆåŒ¿åç±»å‹çœŸæ˜¯è®©äººå¤´ç–¼ï¼‰ï¼Œè€Œæ ¹æ®æˆ‘çš„æµ‹è¯•ï¼Œè¿™æ¯”æœ¬åœ° lambda
    è¡¨è¾¾å¼è¦æ…¢å¾—å¤šã€‚
- en: I should have probably done some rigorous statistical tests, or at least calculated
    the deviation. But honestly, I was too lazy. I may write an update with a proper
    analysis later on.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘åº”è¯¥å¯èƒ½è¿›è¡Œä¸€äº›ä¸¥æ ¼çš„ç»Ÿè®¡æµ‹è¯•ï¼Œæˆ–è€…è‡³å°‘è®¡ç®—ä¸€ä¸‹åå·®ã€‚ä½†è€å®è¯´ï¼Œæˆ‘å¤ªæ‡’äº†ã€‚ä¹Ÿè®¸ä»¥åæˆ‘ä¼šå†™ä¸€ä¸ªæ›´æ–°ï¼Œè¿›è¡Œé€‚å½“çš„åˆ†æã€‚
- en: In case you want to do some tests on your own, feel free to send me the results
    afterwards. ğŸ˜› The source code is on [Github](https://github.com/overflowerror/oop-benchmarks/tree/blog-version)
    (also I should probably apologise for the horrible code, C++ is not my native
    language and I hacked it together in like an hour or so ğŸ˜…).
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æƒ³è‡ªå·±è¿›è¡Œä¸€äº›æµ‹è¯•ï¼Œè¯·éšæ—¶æŠŠç»“æœå‘ç»™æˆ‘ã€‚ğŸ˜› æºä»£ç åœ¨ [Github](https://github.com/overflowerror/oop-benchmarks/tree/blog-version)
    ä¸Šï¼ˆåŒæ—¶æˆ‘å¯èƒ½åº”è¯¥ä¸ºé‚£äº›å¯æ€•çš„ä»£ç é“æ­‰ï¼ŒC++ ä¸æ˜¯æˆ‘çš„æ¯è¯­ï¼Œæˆ‘å¤§æ¦‚åªèŠ±äº†ä¸€ä¸ªå°æ—¶å·¦å³çæäº†ä¸€é€š ğŸ˜…ï¼‰ã€‚
- en: Anyway, without rigorous statistics my conclusion of the tests is that there
    is only a very small difference in performance. Adding more abstraction layers
    (or using different data structures) probably has a more significant impact.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºå¦‚ä½•ï¼Œç¼ºä¹ä¸¥æ ¼çš„ç»Ÿè®¡æ•°æ®ï¼Œæˆ‘çš„æµ‹è¯•ç»“è®ºæ˜¯æ€§èƒ½å·®å¼‚éå¸¸å°ã€‚å¢åŠ æ›´å¤šçš„æŠ½è±¡å±‚ï¼ˆæˆ–è€…ä½¿ç”¨ä¸åŒçš„æ•°æ®ç»“æ„ï¼‰å¯èƒ½ä¼šäº§ç”Ÿæ›´æ˜¾è‘—çš„å½±å“ã€‚
- en: However, other benchmarks on embedded systems have found a ~10 % performance
    penalty compared to a procedural implementation.
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå…¶ä»–åµŒå…¥å¼ç³»ç»Ÿä¸Šçš„åŸºå‡†æµ‹è¯•å‘ç°ä¸è¿‡ç¨‹åŒ–å®ç°ç›¸æ¯”ï¼Œæ€§èƒ½æœ‰çº¦10%çš„é™ä½ã€‚
- en: Another paper comparing the performance of different aspects of OOP as well
    as different design pattern has shown that virtual functions (which I used in
    my implementation) can impact the performance negatively (~ 5 %). The template
    pattern (which I also used) can also decrease the performance by about 3 â€“ 4 %
    (but this might also just be because it relies on virtual functions).
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ç¯‡æ¯”è¾ƒé¢å‘å¯¹è±¡ç¼–ç¨‹ä¸åŒæ–¹é¢æ€§èƒ½çš„è®ºæ–‡ä»¥åŠä¸åŒè®¾è®¡æ¨¡å¼çš„æ€§èƒ½è¡¨ç°æ˜¾ç¤ºï¼Œè™šå‡½æ•°ï¼ˆæˆ‘åœ¨æˆ‘çš„å®ç°ä¸­ä½¿ç”¨äº†ï¼‰å¯èƒ½ä¼šå¯¹æ€§èƒ½äº§ç”Ÿè´Ÿé¢å½±å“ï¼ˆå¤§çº¦5%ï¼‰ã€‚æ¨¡æ¿æ¨¡å¼ï¼ˆæˆ‘ä¹Ÿä½¿ç”¨äº†ï¼‰ä¹Ÿå¯èƒ½ä¼šä½¿æ€§èƒ½é™ä½çº¦3-4%ï¼ˆä½†è¿™å¯èƒ½åªæ˜¯å› ä¸ºå®ƒä¾èµ–äºè™šå‡½æ•°ï¼‰ã€‚
- en: Abstract Nonsense
  id: totrans-split-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æŠ½è±¡çš„èƒ¡è¯´å…«é“
- en: For some reason OOP leads us to overcomplicate everything. We needlessly build
    abstractions on top of abstractions, seemingly for the sole purpose of making
    pretty UML diagrams.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæŸç§åŸå› ï¼Œé¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰å¯¼è‡´æˆ‘ä»¬æŠŠä¸€åˆ‡éƒ½å¤æ‚åŒ–äº†ã€‚æˆ‘ä»¬ä¸å¿…è¦åœ°åœ¨æŠ½è±¡ä¹‹ä¸Šå†æ¬¡å»ºç«‹æŠ½è±¡ï¼Œçœ‹èµ·æ¥ä¼¼ä¹åªæ˜¯ä¸ºäº†åˆ¶ä½œæ¼‚äº®çš„UMLå›¾è¡¨ã€‚
- en: 'The thing is: Itâ€™s caused by how we use the tools, not the tools themselves.
    My suspicion is that most of these issues arise from developers wanting to be
    clever and build generic solutions to cover every possible future development.'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜æ˜¯ï¼šè¿™æ˜¯ç”±æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨å·¥å…·å¼•èµ·çš„ï¼Œè€Œä¸æ˜¯å·¥å…·æœ¬èº«çš„é—®é¢˜ã€‚æˆ‘æ€€ç–‘å¤§å¤šæ•°è¿™äº›é—®é¢˜æ˜¯å¼€å‘äººå‘˜æƒ³è¦èªæ˜åœ°æ„å»ºé€šç”¨è§£å†³æ–¹æ¡ˆæ¥è¦†ç›–æ¯ä¸€ç§å¯èƒ½çš„æœªæ¥å‘å±•æ‰€è‡´ã€‚
- en: 'I think a lot of this can be avoided by adjusting the workflow. Specifically:
    If the end goal is not determined from the beginning, donâ€™t plan for every eventuality
    from the start, only plan for what you know youâ€™ll need. The requirements might
    change later, so your amazing, highly generic solution that you worked on for
    4 weeks straight might not be used in the end â€“ a waste of time.'
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è®¤ä¸ºé€šè¿‡è°ƒæ•´å·¥ä½œæµç¨‹ï¼Œå¯ä»¥é¿å…å¾ˆå¤šè¿™æ ·çš„æƒ…å†µã€‚å…·ä½“æ¥è¯´ï¼šå¦‚æœå¼€å§‹æ—¶æ²¡æœ‰ç¡®å®šæœ€ç»ˆç›®æ ‡ï¼Œé‚£å°±ä¸è¦ä»ä¸€å¼€å§‹å°±ä¸ºæ¯ç§å¯èƒ½æ€§åˆ¶å®šè®¡åˆ’ï¼Œåªä¸ºä½ çŸ¥é“ä½ å°†éœ€è¦çš„éƒ¨åˆ†åˆ¶å®šè®¡åˆ’ã€‚éœ€æ±‚å¯èƒ½ä¼šåæ¥æ”¹å˜ï¼Œæ‰€ä»¥ä½ ä¸ºæ­¤è´¹äº†4ä¸ªæ˜ŸæœŸè¿ç»­å·¥ä½œçš„ç²¾å½©ä¸”é«˜åº¦é€šç”¨çš„è§£å†³æ–¹æ¡ˆæœ€ç»ˆå¯èƒ½ä¸ä¼šè¢«ä½¿ç”¨ï¼Œè¿™æ˜¯åœ¨æµªè´¹æ—¶é—´ã€‚
- en: The Threat of Get and Set
  id: totrans-split-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è·å–å’Œè®¾ç½®çš„å¨èƒ
- en: OOP is so verbose, there is so much boilerplate code. Getters and setters for
    example.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: é¢å‘å¯¹è±¡ç¼–ç¨‹å¤ªå•°å—¦äº†ï¼Œæœ‰å¤ªå¤šæ ·æ¿ä»£ç ã€‚ä¾‹å¦‚ï¼Œè·å–å™¨å’Œè®¾ç½®å™¨ã€‚
- en: '*sigh* This is a personal pet peeve of mine. We touched on this earlier but
    I would really like to hammer this part home: If you really need getters and setters
    for ever single member variable itâ€™s probably not a proper object to start with.
    Iâ€™d highly encourage reconsidering your object model, try to reduce coupling.
    If itâ€™s really a record class with no internal behavior, everything might as well
    be public â€“ there is hardly a point in using getters and setters. A similar thing
    (though admittedly itâ€™s a better) applies to properties in languages like C#,
    and of course code generators like the infamous Lombok.'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*å¹æ°”* è¿™æ˜¯æˆ‘ä¸ªäººçš„å°å°æ€¨å¿µã€‚æˆ‘ä»¬ä¹‹å‰æåˆ°è¿‡è¿™ä¸ªé—®é¢˜ï¼Œä½†æˆ‘çœŸçš„å¾ˆæƒ³å¼ºè°ƒä¸€ä¸‹ï¼šå¦‚æœä½ çœŸçš„éœ€è¦ä¸ºæ¯ä¸ªæˆå‘˜å˜é‡éƒ½æœ‰è·å–å™¨å’Œè®¾ç½®å™¨ï¼Œé‚£å®ƒå¯èƒ½ä¸æ˜¯ä¸€ä¸ªé€‚åˆç”¨å¯¹è±¡è¡¨ç¤ºçš„å¯¹è±¡ã€‚æˆ‘å¼ºçƒˆå»ºè®®é‡æ–°è€ƒè™‘ä½ çš„å¯¹è±¡æ¨¡å‹ï¼Œè¯•ç€å‡å°‘è€¦åˆã€‚å¦‚æœçœŸçš„æ˜¯ä¸€ä¸ªæ²¡æœ‰å†…éƒ¨è¡Œä¸ºçš„è®°å½•ç±»ï¼Œä¸€åˆ‡éƒ½å¯ä»¥æ˜¯å…¬å¼€çš„â€”â€”ä½¿ç”¨è·å–å™¨å’Œè®¾ç½®å™¨å‡ ä¹æ²¡æœ‰æ„ä¹‰ã€‚ç±»ä¼¼çš„æƒ…å†µï¼ˆå°½ç®¡åœ¨æŸç§ç¨‹åº¦ä¸Šæ›´å¥½ï¼‰ä¹Ÿé€‚ç”¨äºè¯¸å¦‚Cï¼ƒä¹‹ç±»çš„å±æ€§ï¼Œä»¥åŠåƒè‡­åæ˜­è‘—çš„Lombokä¹‹ç±»çš„ä»£ç ç”Ÿæˆå™¨ã€‚'
- en: The only real reason for the use of getters and setters over public members,
    is when there is some additional logic like validation of invariants for example.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è·å–å™¨å’Œè®¾ç½®å™¨è€Œä¸æ˜¯å…¬å…±æˆå‘˜çš„å”¯ä¸€çœŸæ­£åŸå› æ˜¯ï¼Œå½“å­˜åœ¨ä¸€äº›é¢å¤–çš„é€»è¾‘ï¼Œæ¯”å¦‚ä¸å˜é‡çš„éªŒè¯æ—¶ã€‚
- en: 'Kinda related: If you have a value object with no setters but lots of getters,
    make sure to not accidentally expose a modifiable reference to internal state.
    Otherwise youâ€™ve got setters â€“ just not intentionally.'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ç‚¹ç›¸å…³ï¼šå¦‚æœä½ æœ‰ä¸€ä¸ªå€¼å¯¹è±¡ï¼Œæ²¡æœ‰è®¾ç½®å™¨ä½†æœ‰å¾ˆå¤šè·å–å™¨ï¼Œè¯·ç¡®ä¿ä¸è¦æ„å¤–åœ°æš´éœ²å†…éƒ¨çŠ¶æ€çš„å¯ä¿®æ”¹å¼•ç”¨ã€‚å¦åˆ™ï¼Œä½ å°±æœ‰äº†è®¾ç½®å™¨â€”â€”åªæ˜¯ä¸æ˜¯æ•…æ„çš„ã€‚
- en: ObjectFactoryFactorySingleton
  id: totrans-split-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ObjectFactoryFactorySingleton
- en: I guess there are two topics that fit this heading. The first being the naming
    madness that has been established in enterprise software development. This is
    again not per se an issue with OOP although for some reason this seems to happen
    a lot more with OOP. I happen to be a Kevlin Henney fan, and he gave an [amazing
    talk on naming in programming](https://www.youtube.com/watch?v=CzJ94TMPcD8) at
    DevWeek 2015\. Among other things he talks about how naming can influence modelling.
    I highly recommend watching it.
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æƒ³è¿™ä¸ªæ ‡é¢˜é€‚åˆä¸¤ä¸ªè¯é¢˜ã€‚é¦–å…ˆæ˜¯å·²ç»åœ¨ä¼ä¸šè½¯ä»¶å¼€å‘ä¸­ç¡®ç«‹çš„å‘½åç–¯ç‹‚ã€‚è™½ç„¶è¿™ä¸é¢å‘å¯¹è±¡ç¼–ç¨‹æœ¬èº«å¹¶æ— ç›´æ¥å…³ç³»ï¼Œä½†ç”±äºæŸç§åŸå› ï¼Œè¿™ç§æƒ…å†µä¼¼ä¹åœ¨é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­æ›´ä¸ºæ™®éã€‚æˆ‘ç¢°å·§æ˜¯Kevlin
    Henneyçš„ç²‰ä¸ï¼Œä»–åœ¨2015å¹´çš„DevWeekä¸Šåšäº†ä¸€åœº[å…³äºç¼–ç¨‹ä¸­å‘½åçš„ç²¾å½©æ¼”è®²](https://www.youtube.com/watch?v=CzJ94TMPcD8)ã€‚é™¤å…¶ä»–å†…å®¹å¤–ï¼Œä»–è¿˜è°ˆåˆ°äº†å‘½åå¦‚ä½•å½±å“å»ºæ¨¡ã€‚æˆ‘å¼ºçƒˆæ¨èè§‚çœ‹è¿™ä¸ªè§†é¢‘ã€‚
- en: The second topic is the rabbit hole of design patterns, that are often blindly
    applied, seemingly without any thought on why exactly. Specifically, the factory
    pattern has some valid uses, but because people overuse the pattern so much itâ€™s
    now synonymous with unnecessary abstractions.
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒä¸ªè¯é¢˜æ˜¯è®¾è®¡æ¨¡å¼çš„å…”å­æ´ï¼Œé€šå¸¸æ˜¯ç›²ç›®åº”ç”¨çš„ï¼Œä¼¼ä¹æ²¡æœ‰æ€è€ƒä¸ºä»€ä¹ˆã€‚å…·ä½“æ¥è¯´ï¼Œå·¥å‚æ¨¡å¼ç¡®å®æœ‰ä¸€äº›æœ‰æ•ˆçš„ç”¨é€”ï¼Œä½†å› ä¸ºäººä»¬è¿‡åº¦ä½¿ç”¨è¿™ç§æ¨¡å¼ï¼Œç°åœ¨å®ƒå·²ç»æˆä¸ºä¸å¿…è¦æŠ½è±¡çš„ä»£åè¯ã€‚
- en: 'There are of course also established patterns where you should really have
    a damn good reason to actually use it â€“ at least in a strictly object-oriented
    context. Singletons for example. â€œSingletonâ€ is in essence just a fancy name for
    a global variable â€“ great. Fun little side note: In the Spring framework Beans
    by default get the Singleton scope, meaning if not stated otherwise every single
    bean is global.'
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ä¹Ÿæœ‰å·²ç»ç¡®ç«‹çš„æ¨¡å¼ï¼Œä½ ç¡®å®åº”è¯¥æœ‰ä¸€ä¸ªéå¸¸å¥½çš„ç†ç”±æ¥å®é™…ä½¿ç”¨å®ƒâ€”â€”è‡³å°‘åœ¨ä¸¥æ ¼çš„é¢å‘å¯¹è±¡ä¸Šä¸‹æ–‡ä¸­æ˜¯è¿™æ ·ã€‚ä¾‹å¦‚å•ä¾‹æ¨¡å¼ã€‚â€œå•ä¾‹â€æœ¬è´¨ä¸Šåªæ˜¯å…¨å±€å˜é‡çš„ä¸€ä¸ªèŠ±å“¨çš„åå­—â€”â€”å¾ˆå¥½ã€‚æœ‰è¶£çš„å°æ’æ›²ï¼šåœ¨Springæ¡†æ¶ä¸­ï¼ŒBeané»˜è®¤ä¸ºSingletonä½œç”¨åŸŸï¼Œè¿™æ„å‘³ç€å¦‚æœæ²¡æœ‰å¦æœ‰è¯´æ˜ï¼Œæ¯ä¸ªBeanéƒ½æ˜¯å…¨å±€çš„ã€‚
- en: A Dream of Spring
  id: totrans-split-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ˜¥å¤©çš„æ¢¦æƒ³
- en: Another thing Iâ€™ve been noticing with modern â€œenterpriseâ€ applications is that
    they are not actually object-oriented. Entities, DTOs, â€¦ are records, not objects.
    Beans, Services, Repositories, â€¦ donâ€™t hold state and could just as well be plain
    functions in modules.
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æ³¨æ„åˆ°ç°ä»£â€œä¼ä¸šâ€åº”ç”¨çš„å¦ä¸€ä»¶äº‹æ˜¯å®ƒä»¬å®é™…ä¸Šå¹¶ä¸æ˜¯é¢å‘å¯¹è±¡çš„ã€‚å®ä½“ã€DTOsï¼Œâ€¦ éƒ½æ˜¯è®°å½•ï¼Œè€Œä¸æ˜¯å¯¹è±¡ã€‚Beanã€æœåŠ¡ã€ä»“åº“ï¼Œâ€¦ ä¸ä¿æŒçŠ¶æ€ï¼Œå¯ä»¥åŒæ ·å†™æˆæ¨¡å—ä¸­çš„ç®€å•å‡½æ•°ã€‚
- en: We are using languages that force us to think in classes with architectures
    that donâ€™t require objects â€“ Spring Boot could just as well be written in C.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨çš„è¯­è¨€è¿«ä½¿æˆ‘ä»¬åœ¨ä¸éœ€è¦å¯¹è±¡çš„æ¶æ„ä¸­æ€è€ƒç±» - Spring Boot å¯ä»¥åŒæ ·ç”¨ C è¯­è¨€ç¼–å†™ã€‚
- en: Conclusion
  id: totrans-split-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: What a ride. I think this my longest blog post so far. Maybe even a bit too
    longâ€¦ Iâ€™ll make sure the next one is shorter. ğŸ˜…
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: å¤ªç²¾å½©äº†ã€‚æˆ‘è§‰å¾—è¿™æ˜¯æˆ‘è¿„ä»Šä¸ºæ­¢æœ€é•¿çš„åšå®¢æ–‡ç« ã€‚æˆ–è®¸æœ‰ç‚¹å¤ªé•¿äº†â€¦ æˆ‘ä¼šç¡®ä¿ä¸‹ä¸€ç¯‡æ–‡ç« æ›´çŸ­ä¸€äº›ã€‚ğŸ˜…
- en: I also found this really interesting [talk by Barbara Liskov about abstraction](https://www.youtube.com/watch?v=dtZ-o96bH9A),
    but I just wasnâ€™t sure where to put it, so here you go. (I particularly like the
    stab against Python for throwing encapsulation out the window. ğŸ˜†)
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è¿˜å‘ç°è¿™ä¸ªçœŸçš„å¾ˆæœ‰æ„æ€çš„ [å…³äºæŠ½è±¡çš„ Barbara Liskov çš„æ¼”è®²](https://www.youtube.com/watch?v=dtZ-o96bH9A)ï¼Œä½†æˆ‘ä¸ç¡®å®šåº”è¯¥æ”¾åœ¨å“ªï¼Œæ‰€ä»¥ç»™ä½ äº†ã€‚ï¼ˆæˆ‘ç‰¹åˆ«å–œæ¬¢å¥¹è®½åˆº
    Python ä¸¢æ‰å°è£…çš„é‚£éƒ¨åˆ† ğŸ˜†ï¼‰
- en: Anyway, I hope I could shed some light on the topic, maybe you learned something,
    or at the very least you found my ramblings somewhat entertaining.
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºå¦‚ä½•ï¼Œå¸Œæœ›æˆ‘èƒ½ä¸ºè¿™ä¸ªä¸»é¢˜æä¾›ä¸€äº›è§è§£ï¼Œä¹Ÿè®¸ä½ å­¦åˆ°äº†ä»€ä¹ˆï¼Œæˆ–è€…è‡³å°‘è§‰å¾—æˆ‘çš„èƒ¡è¨€ä¹±è¯­æœ‰ç‚¹å¨±ä¹æ€§ã€‚
- en: See you soon,
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
  zh: å¾…ä¼šè§ï¼Œ
- en: Sigma
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: è¥¿æ ¼ç›
- en: Footnotes
  id: totrans-split-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è„šæ³¨
