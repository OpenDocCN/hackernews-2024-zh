- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:31:42'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: People Don’t Understand OOP – Sigma's Blog
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.sigma-star.io/2024/01/people-dont-understand-oop/](https://blog.sigma-star.io/2024/01/people-dont-understand-oop/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “OOP to me means only messaging, local retention and protection and hiding of
    state-process, and extreme late-binding of all things.”
  id: totrans-split-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alan Kay (the guy who coined the term “Object Oriented Programming”)
  id: totrans-split-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It seems like a lot of people dislike Object Oriented Programming. The first
    things that come to mind when hearing these three letters are cars, inheritance,
    getters, setters, and ObjectFactoryFactorySingleton.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: 'This always seemed kinda odd to me. Not only do I like OOP, I even feel that
    it often is the best/most obvious way to model a problem. Here is why I think
    that is:'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: OO Who?
  id: totrans-split-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I think before doing anything further we should probably define what we are
    talking about. Unfortunately OOP is not that well defined. So for the sake of
    coherence let’s settle on a clear and unambiguous definition first.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: We will be talking about “objects” a lot. So what are they? Most introduction
    texts to OOP use physical things like cars and animals to illustrate what objects
    are. And while that’s not wrong (it is literally where the object metaphor comes
    from; Alan Kay was thinking in terms of biological cells and networks.) it’s certainly
    misleading, because objects are much more than that.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Peter Wegner writes: “Objects are collections of operations that share a state.”'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark Stefik & Daniel Bobrow define objects as follows:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: “Objects are entities that combine the properties of procedures and data since
    they perform computations and save local state. Uniform use of objects contrasts
    with the use of separate procedures and data in conventional programming.”
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another definition by The Gang of Four: “Object-Oriented Programs are
    made up of objects. An object packages both data and procedures that can operate
    on data. Procedures are typically called methods or operations.”'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, that’s a good start, but I still think an important characteristic of
    objects is missing. Maybe Tim Rentsch can help: Objects are units of state, that
    are generally opaque to the outside (This, I think, is the important part. We
    will see later why that is.). An object can however provide the possibility to
    interact with its state by the means of message-passing (= “methods”).'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: Wait a second. “[…] collections of operations that share state”? “[…] entities
    that combine […] procedures and data […]”? “[…] units of state”?
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: The hell is that supposed to mean?
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: Well, it means that “object” is an abstract term. An object can potentially
    be anything – anything with state that is. It can be a physical item like car,
    an abstract concept, it can be any random piece of data with some sort of behavior
    attached to it. OOP just means we model our problem using these objects. That’s
    it.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: A Class Of Its Own
  id: totrans-split-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might be thinking: “Hold on, we defined OOP without even touching on classes.
    What gives?”'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：“等等，我们甚至没有触及类就定义了面向对象编程。这是怎么回事？”
- en: 'The answer is simple: Classes are not strictly necessary for OOP. A shocker,
    I know.'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：类对于面向对象编程并非绝对必需。是不是有点震惊？
- en: Of course we need to be able to construct new objects, and class-based languages
    are admittedly way more prevalent. However, this is not the only way to achieve
    this goal.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要能够构建新对象，而基于类的语言显然更为普遍。但是，这不是实现此目标的唯一方法。
- en: Languages like JavaScript (although ES6 introduced classes to the language)
    or Lua use a concept called prototype-based or prototypal OOP. Instead of providing
    a schema for constructing new objects we use an existing object as a prototype.
    This approach can even have real-world benefits, as it reduces the language complexity.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 像JavaScript（尽管ES6引入了语言中的类）或Lua这样的语言使用一种称为基于原型或原型面向对象编程（prototypal OOP）的概念。不是提供一个用于构造新对象的模式，而是使用现有对象作为原型。这种方法甚至可以在现实世界中带来好处，因为它降低了语言的复杂性。
- en: '(Just as a side note: Classes don’t need to be called classes. Languages like
    Go or Rust – also C++ to some extend – call them structs for example.)'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: （只是顺便提一下：类不需要被称为类。像Go或Rust - 以及在某种程度上的C++ - 例如称它们为structs。）
- en: It’s Hereditary
  id: totrans-split-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这是遗传的
- en: Another term that – while not technically necessary – is often associated with
    OOP is inheritance.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个术语，虽然在技术上并不必需，但通常与面向对象编程相关联的是继承。
- en: 'There are two reasons to use inheritance:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承有两个原因：
- en: The first is to reuse existing code. However, in modern programming this is
    usually discouraged in favor of object composition (an object inside another object).
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个原因是重用现有代码。但是，在现代编程中，通常鼓励使用对象组合（一个对象内嵌到另一个对象）。
- en: The second reason (to me the more important one) is for abstraction and polymorphism.
    The technical term for this is “subtyping”.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因（对我来说更重要的一个）是用于抽象和多态性。这种技术术语称为“子类型化”。
- en: ‘Sup, Typing?
  id: totrans-split-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ‘嘿，打字中？
- en: (Yes, I think this topic is important enough to warrant its own heading. 😅)
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: （是的，我认为这个主题足够重要，值得有自己的标题。😅）
- en: Subtyping is not exclusive to OOP, however it’s of special significance here
    since it’s the primary way of modelling polymorphism. The idea is to combine multiple
    different classes that share common messages (i.e. have methods with similar semantics)
    into a super type that defines those messages. Now, the super type can be used
    instead of specifying a subtype.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型化不仅限于面向对象编程，但在这里具有特殊意义，因为它是建模多态性的主要方式。其思想是将共享共同消息（即具有类似语义的方法）的多个不同类组合成一个定义这些消息的超类型。现在，可以使用超类型而不是指定子类型。
- en: My favorite example for how subtyping can be used in practice is the Java collections
    framework. It defines interfaces (we will later talk about what exactly interfaces
    are) for common use-cases like Lists, Queues, Sets, Maps, … as well as different
    implementations with different characteristics which support those different use-cases.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的子类型化在实践中的例子是Java集合框架。它定义了用于列表、队列、集合、映射等常见用例的接口（稍后我们将详细讨论接口是什么）以及具有不同特性的不同实现，支持这些不同用例。
- en: wpg_div_collectionmap
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: wpg_div_collectionmap
- en: (The graph was generated from JavaDocs by scrapping all known subclasses of
    [Collection](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Collection.html)
    and [Map](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Map.html)
    and removing non-relevant nodes.)
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: （图表是从JavaDocs生成的，通过检索所有已知的[Collection](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Collection.html)和[Map](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Map.html)的子类并删除非相关节点而生成。）
- en: So let’s say I want to process a list of data, I’d just use the List interface
    everywhere. At the point where I instantiate the List I choose ArrayList, since
    it’s usually the more performant implementation. Later on it turns out that the
    program is doing a lot of inserts/deletes at the beginning of the list, which
    is pretty slow on arrays. To speed up the program I can switch to a LinkedList
    without changing any of the type signatures.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，假设我想处理一个数据列表，我可以在所有地方使用List接口。在我实例化List的时候，我选择ArrayList，因为它通常是更高性能的实现。后来发现程序在数组的开头做了很多插入/删除操作，这在数组上非常慢。为了加速程序，我可以切换到LinkedList而不改变任何类型签名。
- en: 'Side Note: When calling a method we need to know the actual class of the object,
    not just it’s declared class, otherwise subtyping won’t work properly. This is
    called “late/dynamic-binding”. It’s technical execution is a bit tricky and is
    the main reason why in C++ objects and object-pointers behave differently (see
    vtables).'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 旁注：在调用方法时，我们需要知道对象的实际类，而不仅仅是它声明的类，否则子类型化将无法正常工作。这称为“迟绑定/动态绑定”。其技术执行有点棘手，这也是为什么在C++中对象和对象指针行为不同的主要原因（参见vtables）。
- en: Odd Behavior
  id: totrans-split-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 奇怪的行为
- en: I think we can’t (and shouldn’t) talk about subtyping without mentioning behavioral
    subtyping and Barbara Liskov. The basic idea of behavioral subtyping is that a
    subtype should behave in a way similar to the parent type.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们不能（也不应该）谈论子类型化而不提到行为子类型化和Barbara Liskov。行为子类型化的基本思想是，子类型应该以与父类型类似的方式行为。
- en: 'Barbara Liskov (who later won a Turing award for her work on programming languages
    and OOP in particular) formalized this concept in 1987 into “strong behavioral
    subtyping”: A subtype should be able to be used in every situation its parent
    type can be used in.'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: Barbara Liskov（后来因其在编程语言和面向对象编程方面的工作而获得图灵奖）在1987年将这一概念正式形成为“强行为子类型化”：子类型应该可以在其父类型可用的任何情况下使用。
- en: '“Subtype Requirement: Let φ(x) be a property provable about objects x of type T.
    Then φ(y) should be true for objects y of type S where S is a subtype of T.”'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: “子类型要求：让 φ(x) 为可证明的关于类型 T 的对象 x 的属性。那么对于类型 S 的对象 y ，其中 S 是 T 的子类型， φ(y) 应该为真。”
- en: This is called the Liskov substitution principle. I won’t to go into details
    here, but the basic idea is that any precondition (for types, data or state) for
    parameters can not be stronger than the super-type, while any postcondition for
    results can not be weaker than the super-type. The notion is related to the design-by-contract
    methodology that also started to pop up around the same time.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为Liskov替换原则。我这里不想详细讨论，但基本思想是，任何参数的前提条件（对于类型、数据或状态）都不能比超类型更强，而结果的任何后置条件都不能比超类型更弱。这个概念与设计按契约方法论相关联，该方法论也在大约同一时间开始出现。
- en: Way Too Abstract
  id: totrans-split-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过于抽象
- en: 'In some cases we don’t care about the code-sharing aspect of inheritance, but
    still want to profit off of subtyping – we might never actually use the super
    type implementation of the methods and can therefore omit it entirely. This is
    in fact so common, it even has a name: Virtual or abstract methods.'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们不关心继承的代码共享方面，但仍希望从子类型化中获益 - 我们可能根本不会实际使用方法的超类型实现，因此可以完全省略它。这实际上是如此常见，甚至有一个名字：虚拟或抽象方法。
- en: We might even end up removing all state from our abstract super type, and only
    use it as a stencil for defining methods. This is called an interface.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可能会从我们的抽象超类型中移除所有状态，并且仅将其用作定义方法的模板。这被称为接口。
- en: 'Some languages even go a step further and completely decouple interfaces from
    classes. There are two different schools of thought:'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言甚至进一步解耦接口和类。有两种不同的思维方式：
- en: Structural typing (as opposed to the usual nominal typing) is when interface
    implementations are not declared at all. You can simply use the object as an implementation
    as long as all necessary methods are defined. This is statically checked at compile
    time. Examples of languages that support structural typing are Go (both for interfaces
    themself and type constraints) and C++ (for concepts).
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类型化（与通常的名义类型化相对）是接口实现根本不声明时的情况。只要定义了所有必要的方法，您就可以简单地将对象用作实现。这在编译时进行静态检查。支持结构类型化的语言示例包括Go（用于接口本身和类型约束）和C++（用于概念）。
- en: Duck typing is similar but the existence of methods is only checked at runtime.
    Languages that use this pattern include Python and JavaScript. One disadvantage
    that’s often cited is that it is more complicated to figure out which classes
    can be expected at a particular point in the program.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型类似，但仅在运行时检查方法的存在。使用此模式的语言包括Python和JavaScript。经常被提到的一个缺点是，在程序的特定点更复杂地确定可以预期的类。
- en: The second pattern doesn’t seem to have an established name yet. The idea is
    to declare that a class is implementing an interface after the class was already
    defined. An example of a language that does this is Rust with traits. Unfortunately,
    “traits” is a horrible name for this concept, since “traits” usually just refers
    to mix-ins. I’ve heard the term “extension traits” – in reference to “extension
    methods” in C#/Kotlin – but this doesn’t seem to be very common either. Another
    language that support this feature is Haskell (they call it “type classes”; but
    Haskell is arguably not object-oriented).
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模式似乎还没有确立的名称。这个想法是在类定义之后声明该类实现一个接口。一个支持这种特性的语言的例子是Rust与traits。不幸的是，“traits”对于这个概念来说是一个可怕的名称，因为“traits”通常只是指混入。我听说过术语“extension
    traits”——参考C#/Kotlin中的“extension methods”——但这似乎也不是很常见。另一个支持此特性的语言是Haskell（他们称其为“type
    classes”；但Haskell可以说不是面向对象的）。
- en: Hide & Seek
  id: totrans-split-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 躲猫猫
- en: One term that’s often used with OOP is “encapsulation”. There are actually two
    applicable definitions of the term. The first one refers to bundling data with
    behavior (= the object metaphor). And the second one refers to restricting access
    to the state only to the objects itself. I would like to focus a bit on the latter
    since I think a lot of people don’t understand it properly.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中经常使用的一个术语是“封装”。实际上，这个术语有两个适用的定义。第一个是指将数据与行为捆绑在一起（即对象比喻）。第二个是指仅将对状态的访问限制在对象本身。我想集中讨论后者，因为我认为很多人并没有完全理解它。
- en: “Encapsulation is a technique for minimizing interdependencies among separately-written
    modules by defining strict external interfaces.”
  id: totrans-split-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “封装是一种通过定义严格的外部接口来最小化分开编写的模块之间相互依赖的技术。”
- en: Alan Snyder, 1986
  id: totrans-split-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Alan Snyder，1986
- en: 'So why is it important to restrict access to state? Well, there are multiple
    reasons. We could argue that it would violate Liskov’s history constraint. But
    I think it’s much more practical to look at it from the perspective of a developer
    who wants to refactor the code base. Let’s say we want to change the internal
    structure of an object (like in the List example earlier, maybe we want to switch
    from an ArrayList to a LinkedList). But if other components are reliant on the
    internal state (in the case of the ArrayList: this could be the internal primitive
    array) we can not easily change it. We would need to find all places outside of
    the class where the internal structure is referenced. The problem gets even worse
    when the class is exported and used by modules that we might not even control.'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为什么限制对状态的访问很重要呢？好吧，有多个原因。我们可以说这违反了Liskov的历史约束。但我认为从想重构代码库的开发者的角度来看更为实际。假设我们想改变对象的内部结构（就像之前的List示例中一样，也许我们想从ArrayList切换到LinkedList）。但是如果其他组件依赖于内部状态（在ArrayList的情况下：这可能是内部原始数组），我们无法轻松更改它。我们需要找到类外引用内部结构的所有地方。当类被导出并由我们可能无法控制的模块使用时，问题会变得更加严重。
- en: “(Object) coupling” and “(class) cohesion” are often used to talk about encapsulation.
    “Object coupling” describes how much different objects depend on each other. High
    “object coupling” implies that the objects in question rely a lot on each other,
    which usually means they should be one single object instead. If objects rely
    on each others internal structure they are highly coupled. “Class cohesion” describes
    the same characteristic but from a different perspective. It’s a measure of how
    coherent a class’ responsibilities are. A class should ideally represent one idea
    and only do stuff related to that idea. Low “class cohesion” usually means high
    “object coupling” and vice versa.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: “（对象）耦合”和“（类）内聚”经常用来谈论封装。“对象耦合”描述了不同对象彼此依赖的程度。高“对象耦合”意味着相关对象之间的依赖很大，通常意味着它们应该是一个单一对象。如果对象依赖于彼此的内部结构，则它们耦合性很高。“类内聚”从不同的角度描述了相同的特性。它衡量了一个类的责任有多一致。一个类理想情况下应该代表一个想法，并且只执行与该想法相关的操作。低“类内聚”通常意味着高“对象耦合”，反之亦然。
- en: I’m sure if you have done any object-oriented programming you’ve heard something
    like “Don’t use public properties […]” (properties in the sense of member variables)
    at some point. And this is true, because public properties expose the internal
    state, and can potentially cause high object coupling. However, as with any dogma,
    it’s usually a good idea to question it. In this case the complete “guideline”
    is “Don’t use public properties, use getters and setters instead.”, which is completely
    wrong. In terms of encapsulation getters and setters are just as bad as public
    properties, as they do nothing to prevent object coupling. If you have a class
    without any methods (besides getters and setters) it doesn’t really fit our object
    definition. A term that has been used for this is “record”.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信如果你有进行过任何面向对象编程，你一定听说过类似“不要使用公共属性[...]”的建议。这是真的，因为公共属性暴露了内部状态，可能会导致高对象耦合。然而，和任何教条一样，通常质疑它是一个好主意。在这种情况下，完整的“指导原则”是“不要使用公共属性，而是使用getter和setter。”这完全是错误的。在封装方面，getter和setter与公共属性一样糟糕，因为它们对阻止对象耦合没有任何作用。如果一个类除了getter和setter之外没有任何方法，它实际上并不符合我们的对象定义。用于这种情况的术语是“记录”。
- en: '};'
  id: totrans-split-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '};'
- en: 'Okay, so what it OOP? OOP is when related state and behavior are bundled into
    units (= objects). Other properties object-oriented languages *may* have are:
    Classes, prototypes, encapsulation, subtyping, inheritance, …'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么面向对象编程（OOP）是什么？OOP是将相关状态和行为捆绑成单元（= 对象）。面向对象语言可能具有的其他特性包括：类、原型、封装、子类型、继承等。
- en: 'Let’s take a look at some modern languages (these are the top 15 languages
    from the [StackOverflow Developer Survey 2023](https://survey.stackoverflow.co/2023/#section-most-popular-technologies-programming-scripting-and-markup-languages)
    – excluding stuff like HTML, …):'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些现代语言（这些是来自[StackOverflow 2023开发者调查](https://survey.stackoverflow.co/2023/#section-most-popular-technologies-programming-scripting-and-markup-languages)的前15种语言，不包括HTML等...）：
- en: '| Language | Objs | Obj Creation | Encapsulation | Subtyping |'
  id: totrans-split-62
  prefs: []
  type: TYPE_TB
  zh: '| 语言 | 对象 | 对象创建 | 封装 | 子类型 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| JavaScript | ✔️ | Classes/ Prototypes'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: '| JavaScript | ✔️ | 类/原型'
- en: '| ✔️ (since ES2022) | Inheritance/ Duck typing |'
  id: totrans-split-65
  prefs: []
  type: TYPE_TB
  zh: '| ✔️（自ES2022起） | 继承/鸭子类型（Inheritance/ Duck typing） |'
- en: '| Python | ✔️ | Classes | ❌ (not on a language level) | Inheritance/ Duck typing
    |'
  id: totrans-split-66
  prefs: []
  type: TYPE_TB
  zh: '| Python | ✔️ | 类（Classes） | ❌（语言层面上没有） | 继承/鸭子类型（Inheritance/ Duck typing）
    |'
- en: '| TypeScript | ✔️ | Classes/ Prototypes | ✔️ | Inheritance/ Structural typing/'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: '| TypeScript | ✔️ | 类/原型（Classes/ Prototypes） | ✔️ | 继承/结构类型（Inheritance/ Structural
    typing） |'
- en: Duck typing |
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型 |
- en: '| ShellScript | ❌ | ❌ | ❌ | ❌ |'
  id: totrans-split-69
  prefs: []
  type: TYPE_TB
  zh: '| ShellScript | ❌ | ❌ | ❌ | ❌ |'
- en: '| Java | ✔️ | Classes | ✔️ | Inheritance/ Nominal typing |'
  id: totrans-split-70
  prefs: []
  type: TYPE_TB
  zh: '| Java | ✔️ | 类（Classes） | ✔️ | 继承/命名类型（Inheritance/ Nominal typing） |'
- en: '| C# | ✔️ | Classes | ✔️ | Inheritance/ Nominal typing |'
  id: totrans-split-71
  prefs: []
  type: TYPE_TB
  zh: '| C# | ✔️ | 类（Classes） | ✔️ | 继承/命名类型（Inheritance/ Nominal typing） |'
- en: '| C++ | ✔️ | Classes + Structs | ✔️ | Inheritance/ Nominal typing +'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: '| C++ | ✔️ | 类 + 结构体（Classes + Structs） | ✔️ | 继承/命名类型（Inheritance/ Nominal
    typing） +'
- en: Structural typing (concepts) |
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类型（概念） |
- en: '| C | ❌ (no methods) | Structs | ✔️ (kinda using incomplete types) | ❌ (single
    “inheritance” by nesting structs; no real subtyping) |'
  id: totrans-split-74
  prefs: []
  type: TYPE_TB
  zh: '| C | ❌（没有方法） | 结构体（Structs） | ✔️（使用不完整类型） | ❌（通过嵌套结构体实现的单一“继承”，没有真正的子类型） |'
- en: '| PHP | ✔️ | Classes | ✔️ | Inheritance/ Duck typing |'
  id: totrans-split-75
  prefs: []
  type: TYPE_TB
  zh: '| PHP | ✔️ | 类（Classes） | ✔️ | 继承/鸭子类型（Inheritance/ Duck typing） |'
- en: '| PowerShell | ✔️ | Classes | ❌ | Inheritance/ Duck typing* |'
  id: totrans-split-76
  prefs: []
  type: TYPE_TB
  zh: '| PowerShell | ✔️ | 类（Classes） | ❌ | 继承/鸭子类型*（Inheritance/ Duck typing*） |'
- en: '| Go | ✔️ | Structs | ✔️ (on package level) | Structural typing |'
  id: totrans-split-77
  prefs: []
  type: TYPE_TB
  zh: '| Go | ✔️ | 结构体（Structs） | ✔️（在包级别上） | 结构类型 |'
- en: '| Rust | ✔️ | Structs | ✔️ | Extension Traits/ Nominal typing |'
  id: totrans-split-78
  prefs: []
  type: TYPE_TB
  zh: '| Rust | ✔️ | 结构体（Structs） | ✔️ | 扩展特性/命名类型（Extension Traits/ Nominal typing）
    |'
- en: '| Kotlin | ✔️ | Classes | ✔️ | Inheritance/ Nominal typing |'
  id: totrans-split-79
  prefs: []
  type: TYPE_TB
  zh: '| Kotlin | ✔️ | 类（Classes） | ✔️ | 继承/命名类型（Inheritance/ Nominal typing） |'
- en: '| Ruby | ✔️ | Classes | ✔️ (enforced) | Inheritance/ Duck typing |'
  id: totrans-split-80
  prefs: []
  type: TYPE_TB
  zh: '| Ruby | ✔️ | 类（Classes） | ✔️（强制） | 继承/鸭子类型（Inheritance/ Duck typing） |'
- en: '| Lua | ✔️ | Tables (Prototypes) | ❌ | Inheritance/ Duck typing |'
  id: totrans-split-81
  prefs: []
  type: TYPE_TB
  zh: '| Lua | ✔️ | 表（原型） | ❌ | 继承/鸭子类型（Inheritance/ Duck typing） |'
- en: '*) not sure'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*) 不确定'
- en: O-Oh, No…
  id: totrans-split-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 噢-噢，不好了……
- en: Okay. Now that we have a good understanding of what exactly OOP is and what
    we can expect from languages that implement the OOP paradigm, let’s take a look
    at some common points of criticism. (I shamelessly crowdsourced most of the following
    part by asking my friends what they hate about OOP. 😋)
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好了。现在我们对面向对象编程是什么以及我们可以从实现OOP范式的语言中期待什么有了很好的理解，让我们来看看一些常见的批评点。（我厚颜无耻地通过询问朋友们讨厌OOP的原因来获得以下大部分内容。😋）
- en: But What ARE Objects?
  id: totrans-split-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 但是什么是对象？
- en: So, objects can be anything, right? So how do I know what should be an object?
    When should I combine things, what should be separate?
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，对象可以是任何东西，对吧？那么我如何知道什么应该是一个对象？什么时候应该将事物结合在一起，什么应该分开？
- en: Well, in the end it’s just practice and experience. With time you’ll get a feeling
    about what should and what shouldn’t be an object. However, to get started there
    are some tricks that might help you.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在最后，这只是实践和经验问题。随着时间的推移，你会对什么应该是对象，什么不应该是对象有所感觉。然而，为了开始，有一些技巧可能会对你有所帮助。
- en: 'Here’s what The Gang of Four has to say:'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是《四人帮》的看法：
- en: “Object-oriented design methodologies favor many different approaches. You can
    write a problem statement, single out the nouns and verbs, and create corresponding
    classes and operations. Or you can focus on the collaborations and responsibilities
    in your system. Or you can model the real world and translate the objects found
    during analysis into design. There will always be disagreement on which approach
    is best.”
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: “面向对象设计方法偏爱多种不同的方法。你可以编写问题陈述，单独找出名词和动词，然后创建相应的类和操作。或者你可以专注于系统中的协作和责任。或者你可以对现实世界进行建模，并将分析中找到的对象转化为设计。对于哪种方法最好，总会存在分歧。”
- en: Speedy Thing Goes In, Speedy Thing Comes Out
  id: totrans-split-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速的东西进去，快速的东西出来
- en: 'EDIT: It has been pointed out to me that a made a few mistakes when designing
    the benchmarks. Thanks to NoNaeAbC on Github for pointing out that I’m allocating
    and zeroing way too much memory in the OOP and SP tests, and u9vata on Youtube
    for critiquing my benchmark design. With regard to the latter, while I don’t agree
    with everything they said, it’s definitely true that I was making some unfounded
    assumptions about compiler optimisation.'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑：有人指出我在设计基准测试时犯了几个错误。感谢Github上的NoNaeAbC指出我在面向对象编程和结构化编程测试中分配和清零了太多内存，以及Youtube上的u9vata批评了我的基准设计。关于后者，虽然我不同意他们的所有观点，但的确是我对编译器优化做出了一些无根据的假设。
- en: I’m not sure when I’ll have the time to redesign the benchmarks, so for the
    time being, please take the following with a big grain of salt.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定何时会有时间重新设计基准测试，因此在这段时间内，请对以下内容保持怀疑态度。
- en: 'While we are at it, I also came up with another explanation on why the FP tests
    are so slow: The band is stored as increasingly nested closures, which have to
    store their arguments on the heap, while the OOP and SP version can exclusively
    work on the stack.'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我也想出了另一个解释，解释为什么函数式编程测试如此缓慢：乐队被存储为越来越嵌套的闭包，这些闭包必须将它们的参数存储在堆上，而面向对象和结构化编程版本则可以完全在栈上工作。
- en: OOP is slow. Or so I’ve heard. The rationale is that vtable lookups are overhead
    compared to direct function calls. I don’t actually know whether that’s true,
    so I decided to test it.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）很慢。或者这是我听说的。理由是虚表查找比直接函数调用多余。我实际上不知道这是不是真的，所以我决定进行测试。
- en: 'The test setup is as follows: I wrote the same program (a Turing machine checking
    for binary palindromes) 3 times, once using object-oriented programming, once
    using structured programming (only using functions, loops, tuples, arrays – stuff
    like that), and once using functional programming for good measure.'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设置如下：我写了相同的程序（检查二进制回文的图灵机）三次，一次使用面向对象编程，一次使用结构化编程（仅使用函数、循环、元组、数组等等），还有一次为了充分考虑使用函数式编程。
- en: I implemented everything in C++ so it’s an equal playing field (also, C++ has
    first class functions/lambda expressions for the functional version). There is
    100 000 test cases, the total time is measured. The compiler is clang 14.0.3,
    the target platform is Apple Silicon (M1). I ran each test with both -O0 and -O3.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我用C++实现了所有内容，这样是公平竞争的基础（此外，C++为函数式版本提供了一流的函数/lambda表达式）。有100,000个测试用例，总时间已测量。编译器是clang
    14.0.3，目标平台是Apple Silicon（M1）。我用-O0和-O3分别运行了每个测试。
- en: For the OOP implementation I made sure to not rely on heap allocations, since
    the context switches would probably completely ruin the runtime. I did however
    use inheritance (the template pattern to be specific) to make the vtable lookups
    as realistic as possible.
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向对象的实现，我确保不依赖堆分配，因为上下文切换可能会完全破坏运行时。但是，我确实使用了继承（具体来说是模板模式），以使虚表查找尽可能真实。
- en: The structured version also allocates everything on the stack. I build two different
    versions. The first one uses tuples in the transition table lookup, however I
    wasn’t sure how tuples are implemented under the hood and I wanted to avoid using
    objects by accident if possible, so I wrote another version that only relies on
    functions. But it turned out the results were so close I couldn’t tell the difference.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化版本还在堆栈上分配所有内容。我构建了两个不同的版本。第一个版本在转换表查找中使用了元组，但我不确定元组在内部是如何实现的，如果可能的话，我想避免意外使用对象，所以我写了另一个只依赖函数的版本。但结果显示两者非常接近，我分辨不出有什么区别。
- en: <canvas id="myiChartbenchmarks--o0-1"></canvas>
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: <canvas id="myiChartbenchmarks--o0-1"></canvas>
- en: <canvas id="myiChartbenchmarks--o3-2"></canvas>
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: <canvas id="myiChartbenchmarks--o3-2"></canvas>
- en: As we can see, the structured version is marginally (~ 5 %) faster than the
    object-oriented one when not using any optimization (Although I should mention
    that I observed the values jumping quite a lot between runs). When using -O3 the
    performance is basically identical (~ 1 %), so my guess is that the C++ optimizer
    was able to get rid of whatever impacted the performance.
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，结构化版本在没有使用任何优化时，速度比面向对象版本稍快（大约5%）（虽然我应该提到，在运行之间观察到的值有很大的跳动）。当使用 -O3
    时，性能基本上是相同的（约为1%），所以我猜测 C++ 优化器能够消除影响性能的任何东西。
- en: The functional implementation is not even remotely close. To a certain extend
    this is probably caused by the benchmark I chose. Turing machines are inherently
    stateful, which is pretty awkward to model in a functional way. Another aspect
    is that even though I used C++14 (which supports return type inference) I was
    forced to use the std::function template as a wrapper for lambda expressions (anonymous
    types are a pain in the backside) which (according to my tests) are quite a bit
    slower than native lambda expressions.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式实现根本不接近。在某种程度上，这可能是由我选择的基准测试引起的。图灵机在本质上是有状态的，这在函数式模型中建模起来相当尴尬。另一个方面是，尽管我使用了支持返回类型推断的
    C++14（但我被迫使用了 std::function 模板作为 lambda 表达式的包装器（匿名类型真是让人头疼），而根据我的测试，这比本地 lambda
    表达式要慢得多。
- en: I should have probably done some rigorous statistical tests, or at least calculated
    the deviation. But honestly, I was too lazy. I may write an update with a proper
    analysis later on.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该可能进行一些严格的统计测试，或者至少计算一下偏差。但老实说，我太懒了。也许以后我会写一个更新，进行适当的分析。
- en: In case you want to do some tests on your own, feel free to send me the results
    afterwards. 😛 The source code is on [Github](https://github.com/overflowerror/oop-benchmarks/tree/blog-version)
    (also I should probably apologise for the horrible code, C++ is not my native
    language and I hacked it together in like an hour or so 😅).
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想自己进行一些测试，请随时把结果发给我。😛 源代码在 [Github](https://github.com/overflowerror/oop-benchmarks/tree/blog-version)
    上（同时我可能应该为那些可怕的代码道歉，C++ 不是我的母语，我大概只花了一个小时左右瞎搞了一通 😅）。
- en: Anyway, without rigorous statistics my conclusion of the tests is that there
    is only a very small difference in performance. Adding more abstraction layers
    (or using different data structures) probably has a more significant impact.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，缺乏严格的统计数据，我的测试结论是性能差异非常小。增加更多的抽象层（或者使用不同的数据结构）可能会产生更显著的影响。
- en: However, other benchmarks on embedded systems have found a ~10 % performance
    penalty compared to a procedural implementation.
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他嵌入式系统上的基准测试发现与过程化实现相比，性能有约10%的降低。
- en: Another paper comparing the performance of different aspects of OOP as well
    as different design pattern has shown that virtual functions (which I used in
    my implementation) can impact the performance negatively (~ 5 %). The template
    pattern (which I also used) can also decrease the performance by about 3 – 4 %
    (but this might also just be because it relies on virtual functions).
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一篇比较面向对象编程不同方面性能的论文以及不同设计模式的性能表现显示，虚函数（我在我的实现中使用了）可能会对性能产生负面影响（大约5%）。模板模式（我也使用了）也可能会使性能降低约3-4%（但这可能只是因为它依赖于虚函数）。
- en: Abstract Nonsense
  id: totrans-split-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象的胡说八道
- en: For some reason OOP leads us to overcomplicate everything. We needlessly build
    abstractions on top of abstractions, seemingly for the sole purpose of making
    pretty UML diagrams.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种原因，面向对象编程（OOP）导致我们把一切都复杂化了。我们不必要地在抽象之上再次建立抽象，看起来似乎只是为了制作漂亮的UML图表。
- en: 'The thing is: It’s caused by how we use the tools, not the tools themselves.
    My suspicion is that most of these issues arise from developers wanting to be
    clever and build generic solutions to cover every possible future development.'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：这是由我们如何使用工具引起的，而不是工具本身的问题。我怀疑大多数这些问题是开发人员想要聪明地构建通用解决方案来覆盖每一种可能的未来发展所致。
- en: 'I think a lot of this can be avoided by adjusting the workflow. Specifically:
    If the end goal is not determined from the beginning, don’t plan for every eventuality
    from the start, only plan for what you know you’ll need. The requirements might
    change later, so your amazing, highly generic solution that you worked on for
    4 weeks straight might not be used in the end – a waste of time.'
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为通过调整工作流程，可以避免很多这样的情况。具体来说：如果开始时没有确定最终目标，那就不要从一开始就为每种可能性制定计划，只为你知道你将需要的部分制定计划。需求可能会后来改变，所以你为此费了4个星期连续工作的精彩且高度通用的解决方案最终可能不会被使用，这是在浪费时间。
- en: The Threat of Get and Set
  id: totrans-split-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取和设置的威胁
- en: OOP is so verbose, there is so much boilerplate code. Getters and setters for
    example.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程太啰嗦了，有太多样板代码。例如，获取器和设置器。
- en: '*sigh* This is a personal pet peeve of mine. We touched on this earlier but
    I would really like to hammer this part home: If you really need getters and setters
    for ever single member variable it’s probably not a proper object to start with.
    I’d highly encourage reconsidering your object model, try to reduce coupling.
    If it’s really a record class with no internal behavior, everything might as well
    be public – there is hardly a point in using getters and setters. A similar thing
    (though admittedly it’s a better) applies to properties in languages like C#,
    and of course code generators like the infamous Lombok.'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*叹气* 这是我个人的小小怨念。我们之前提到过这个问题，但我真的很想强调一下：如果你真的需要为每个成员变量都有获取器和设置器，那它可能不是一个适合用对象表示的对象。我强烈建议重新考虑你的对象模型，试着减少耦合。如果真的是一个没有内部行为的记录类，一切都可以是公开的——使用获取器和设置器几乎没有意义。类似的情况（尽管在某种程度上更好）也适用于诸如C＃之类的属性，以及像臭名昭著的Lombok之类的代码生成器。'
- en: The only real reason for the use of getters and setters over public members,
    is when there is some additional logic like validation of invariants for example.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用获取器和设置器而不是公共成员的唯一真正原因是，当存在一些额外的逻辑，比如不变量的验证时。
- en: 'Kinda related: If you have a value object with no setters but lots of getters,
    make sure to not accidentally expose a modifiable reference to internal state.
    Otherwise you’ve got setters – just not intentionally.'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有点相关：如果你有一个值对象，没有设置器但有很多获取器，请确保不要意外地暴露内部状态的可修改引用。否则，你就有了设置器——只是不是故意的。
- en: ObjectFactoryFactorySingleton
  id: totrans-split-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ObjectFactoryFactorySingleton
- en: I guess there are two topics that fit this heading. The first being the naming
    madness that has been established in enterprise software development. This is
    again not per se an issue with OOP although for some reason this seems to happen
    a lot more with OOP. I happen to be a Kevlin Henney fan, and he gave an [amazing
    talk on naming in programming](https://www.youtube.com/watch?v=CzJ94TMPcD8) at
    DevWeek 2015\. Among other things he talks about how naming can influence modelling.
    I highly recommend watching it.
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这个标题适合两个话题。首先是已经在企业软件开发中确立的命名疯狂。虽然这与面向对象编程本身并无直接关系，但由于某种原因，这种情况似乎在面向对象编程中更为普遍。我碰巧是Kevlin
    Henney的粉丝，他在2015年的DevWeek上做了一场[关于编程中命名的精彩演讲](https://www.youtube.com/watch?v=CzJ94TMPcD8)。除其他内容外，他还谈到了命名如何影响建模。我强烈推荐观看这个视频。
- en: The second topic is the rabbit hole of design patterns, that are often blindly
    applied, seemingly without any thought on why exactly. Specifically, the factory
    pattern has some valid uses, but because people overuse the pattern so much it’s
    now synonymous with unnecessary abstractions.
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个话题是设计模式的兔子洞，通常是盲目应用的，似乎没有思考为什么。具体来说，工厂模式确实有一些有效的用途，但因为人们过度使用这种模式，现在它已经成为不必要抽象的代名词。
- en: 'There are of course also established patterns where you should really have
    a damn good reason to actually use it – at least in a strictly object-oriented
    context. Singletons for example. “Singleton” is in essence just a fancy name for
    a global variable – great. Fun little side note: In the Spring framework Beans
    by default get the Singleton scope, meaning if not stated otherwise every single
    bean is global.'
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然也有已经确立的模式，你确实应该有一个非常好的理由来实际使用它——至少在严格的面向对象上下文中是这样。例如单例模式。“单例”本质上只是全局变量的一个花哨的名字——很好。有趣的小插曲：在Spring框架中，Bean默认为Singleton作用域，这意味着如果没有另有说明，每个Bean都是全局的。
- en: A Dream of Spring
  id: totrans-split-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 春天的梦想
- en: Another thing I’ve been noticing with modern “enterprise” applications is that
    they are not actually object-oriented. Entities, DTOs, … are records, not objects.
    Beans, Services, Repositories, … don’t hold state and could just as well be plain
    functions in modules.
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我注意到现代“企业”应用的另一件事是它们实际上并不是面向对象的。实体、DTOs，… 都是记录，而不是对象。Bean、服务、仓库，… 不保持状态，可以同样写成模块中的简单函数。
- en: We are using languages that force us to think in classes with architectures
    that don’t require objects – Spring Boot could just as well be written in C.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的语言迫使我们在不需要对象的架构中思考类 - Spring Boot 可以同样用 C 语言编写。
- en: Conclusion
  id: totrans-split-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: What a ride. I think this my longest blog post so far. Maybe even a bit too
    long… I’ll make sure the next one is shorter. 😅
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 太精彩了。我觉得这是我迄今为止最长的博客文章。或许有点太长了… 我会确保下一篇文章更短一些。😅
- en: I also found this really interesting [talk by Barbara Liskov about abstraction](https://www.youtube.com/watch?v=dtZ-o96bH9A),
    but I just wasn’t sure where to put it, so here you go. (I particularly like the
    stab against Python for throwing encapsulation out the window. 😆)
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我还发现这个真的很有意思的 [关于抽象的 Barbara Liskov 的演讲](https://www.youtube.com/watch?v=dtZ-o96bH9A)，但我不确定应该放在哪，所以给你了。（我特别喜欢她讽刺
    Python 丢掉封装的那部分 😆）
- en: Anyway, I hope I could shed some light on the topic, maybe you learned something,
    or at the very least you found my ramblings somewhat entertaining.
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，希望我能为这个主题提供一些见解，也许你学到了什么，或者至少觉得我的胡言乱语有点娱乐性。
- en: See you soon,
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
  zh: 待会见，
- en: Sigma
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: 西格玛
- en: Footnotes
  id: totrans-split-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚注
