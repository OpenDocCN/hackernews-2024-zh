<!--yml

category: 未分类

日期：2024-05-27 14:39:56

-->

# I 是意图 — Acko.net

> 来源：[https://acko.net/blog/i-is-for-intent/](https://acko.net/blog/i-is-for-intent/)

你还会得出结论：没有比后端和前端之间的硬分裂更险恶的事情了。你知道，由不同人编码，每一方只有一半意识到另一方的需求，但彼此正对面。对另一端需求的善意猜测通常是错误的。你最终将得到不能简洁高效地回答问题的数据类型和查询模型，并且必须小心照看以防止其变得陈旧。

在过去的 20 年里，在这片荒野上几乎没有什么变化。在后端方面，它看起来仍然大同小异。即使现代存储解决方案被部署，人们最终也会在其上加上类似 SQL 和 ORM 的层，因为那是熟悉的东西。后端和数据库之间的分裂有着同样的不良情况。

这些工作实际上并没有帮助使应用程序更可靠，相反：每个新功能都使持续开发变得更加困难。在这个领域的许多“解决方案”并不是真正的解决方案，它们只是应付手段。也许我们早就应该进行一次 NoSQL 复兴，这一次要专注于实用的模式设计和变异？SQL 是为了建模行政业务流程而设计的，而不是实时交互。我倒是认为前端应该*紧挨*着后端，而不是置于其前面，只有一个薄薄的代理作为中介。

我可以告诉你的确实：当意图成为一种第一类概念时，情况好多了。你不需要也不想把用户数据当作需要小心翼翼处理的东西，或者像处理放射性物质那样处理它。你可以无忧地操作和传输它。你可以在其上构建丰富、舒适的功能。一旦实施，你可能很长一段时间都不需要触碰你的网络代码。这完全是压倒性的相反，它是可爱的。你可以专注于构建用户所需的工具。

这可以为 OT 和 CRDT 等更高级的概念铺平道路，但会告诉你，它们都不能替代正确设置应用程序基础的重要性。

这样一来，你会达到 Dijkstra 和反-Dijkstra 的综合：你的程序应该在其数据流中[可证明正确](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD02xx/EWD288.html)，这意味着它可以安全地以完全任意的方式中断。

因为 UI 中的 I 一直意味着“意图”。

**更多信息：**
