["```\nfunc NewServer(\n\tlogger *Logger\n\tconfig *Config\n\tcommentStore *commentStore\n\tanotherStore *anotherStore\n) http.Handler {\n\tmux := http.NewServeMux()\n\taddRoutes(\n\t\tmux,\n\t\tLogger,\n\t\tConfig,\n\t\tcommentStore,\n\t\tanotherStore,\n\t)\n\tvar handler http.Handler = mux\n\thandler = someMiddleware(handler)\n\thandler = someMiddleware2(handler)\n\thandler = someMiddleware3(handler)\n\treturn handler\n}\n```", "```\nvar handler http.Handler = mux\nhandler = logging.NewLoggingMiddleware(logger, handler)\nhandler = logging.NewGoogleTraceIDMiddleware(logger, handler)\nhandler = checkAuthHeaders(handler)\nreturn handler\n```", "```\nsrv := NewServer(\n\tlogger,\n\tconfig,\n\ttenantsStore,\n\tslackLinkStore,\n\tmsteamsLinkStore,\n\tproxy,\n)\nhttpServer := &http.Server{\n\tAddr:    net.JoinHostPort(config.Host, config.Port),\n\tHandler: srv,\n}\ngo func() {\n\tlog.Printf(\"listening on %s\\n\", httpServer.Addr)\n\tif err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\tfmt.Fprintf(os.Stderr, \"error listening and serving: %s\\n\", err)\n\t}\n}()\nvar wg sync.WaitGroup\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\t<-ctx.Done()\n\t// make a new context for the Shutdown (thanks Alessandro Rosetti)\n\tshutdownCtx := context.Background()\n\tshutdownCtx, cancel := context.WithTimeout(ctx, 10 * time.Second)\n\tdefer cancel()\n\tif err := httpServer.Shutdown(shutdownCtx); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error shutting down http server: %s\\n\", err)\n\t}\n}()\nwg.Wait()\nreturn nil\n```", "```\nsrv := NewServer(\n\tlogger,\n\tconfig,\n\ttenantsStore,\n\tcommentsStore,\n\tconversationService,\n\tchatGPTService,\n)\n```", "```\nfunc addRoutes(\n\tmux                 *http.ServeMux,\n\tlogger              *logging.Logger,\n\tconfig              Config,\n\ttenantsStore        *TenantsStore,\n\tcommentsStore       *CommentsStore,\n\tconversationService *ConversationService,\n\tchatGPTService      *ChatGPTService,\n\tauthProxy           *authProxy\n) {\n\tmux.Handle(\"/api/v1/\", handleTenantsGet(logger, tenantsStore))\n\tmux.Handle(\"/oauth2/\", handleOAuth2Proxy(logger, authProxy))\n\tmux.HandleFunc(\"/healthz\", handleHealthzPlease(logger))\n\tmux.Handle(\"/\", http.NotFoundHandler())\n}\n```", "```\nfunc run(ctx context.Context, w io.Writer, args []string) error {\n\tctx, cancel := signal.NotifyContext(ctx, os.Interrupt)\n\tdefer cancel()\n\n\t// ...\n}\n\nfunc main() {\n\tctx := context.Background()\n\tif err := run(ctx, os.Stdout, os.Args); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n```", "```\nfunc run(\n\tctx    context.Context,\n\targs   []string,\n\tgetenv func(string) string,\n\tstdin  io.Reader,\n\tstdout, stderr io.Writer,\n) error\n```", "```\nargs := []string{\n\t\"myapp\",\n\t\"--out\", outFile,\n\t\"--fmt\", \"markdown\",\n}\ngo run(ctx, args, etc.)\n```", "```\ngetenv := func(key string) string {\n\tswitch key {\n\tcase \"MYAPP_FORMAT\":\n\t\treturn \"markdown\"\n\tcase \"MYAPP_TIMEOUT\":\n\t\treturn \"5s\"\n\tdefault:\n\t\treturn \"\"\n}\ngo run(ctx, args, getenv)\n```", "```\nfunc main() {\n\tctx := context.Background()\n\tif err := run(ctx, os.Getenv, os.Stderr); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n```", "```\n// handleSomething handles one of those web requests\n// that you hear so much about.\nfunc handleSomething(logger *Logger) http.Handler {\n\tthing := prepareThing()\n\treturn http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t// use thing to handle request\n\t\t\tlogger.Info(r.Context(), \"msg\", \"handleSomething\")\n\t\t}\n\t)\n}\n```", "```\nfunc encode[T any](w http.ResponseWriter, r *http.Request, status int, v T) error {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(status)\n\tif err := json.NewEncoder(w).Encode(v); err != nil {\n\t\treturn fmt.Errorf(\"encode json: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc decode[T any](r *http.Request) (T, error) {\n\tvar v T\n\tif err := json.NewDecoder(r.Body).Decode(&v); err != nil {\n\t\treturn v, fmt.Errorf(\"decode json: %w\", err)\n\t}\n\treturn v, nil\n}\n```", "```\nerr := encode(w, r, http.StatusOK, obj)\n```", "```\ndecoded, err := decode[CreateSomethingRequest](r)\n```", "```\n// Validator is an object that can be validated.\ntype Validator interface {\n\t// Valid checks the object and returns any\n\t// problems. If len(problems) == 0 then\n\t// the object is valid.\n\tValid(ctx context.Context) (problems map[string]string)\n}\n```", "```\nfunc decodeValid[T Validator](r *http.Request) (T, map[string]string, error) {\n\tvar v T\n\tif err := json.NewDecoder(r.Body).Decode(&v); err != nil {\n\t\treturn v, nil, fmt.Errorf(\"decode json: %w\", err)\n\t}\n\tif problems := v.Valid(r.Context()); len(problems) > 0 {\n\t\treturn v, problems, fmt.Errorf(\"invalid %T: %d problems\", v, len(problems))\n\t}\n\treturn v, nil, nil\n}\n```", "```\nfunc adminOnly(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !currentUser(r).IsAdmin {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\th(w, r)\n\t})\n}\n```", "```\npackage app\n\nfunc addRoutes(mux *http.ServeMux) {\n\tmux.HandleFunc(\"/api/\", handleAPI())\n\tmux.HandleFunc(\"/about\", handleAbout())\n\tmux.HandleFunc(\"/\", handleIndex())\n\tmux.HandleFunc(\"/admin\", adminOnly(handleAdminIndex()))\n}\n```", "```\nmux.Handle(\"/route1\", middleware(logger, db, slackClient, rroll []byte, handleSomething(handlerSpecificDeps))\nmux.Handle(\"/route2\", middleware(logger, db, slackClient, rroll []byte, handleSomething2(handlerSpecificDeps))\nmux.Handle(\"/route3\", middleware(logger, db, slackClient, rroll []byte, handleSomething3(handlerSpecificDeps))\nmux.Handle(\"/route4\", middleware(logger, db, slackClient, rroll []byte, handleSomething4(handlerSpecificDeps))\n```", "```\nfunc newMiddleware(\n\tlogger Logger,\n\tdb *DB,\n\tslackClient *slack.Client,\n\trroll []byte,\n) func(h http.Handler) http.Handler\n```", "```\nmiddleware := newMiddleware(logger, db, slackClient, rroll)\nmux.Handle(\"/route1\", middleware(handleSomething(handlerSpecificDeps))\nmux.Handle(\"/route2\", middleware(handleSomething2(handlerSpecificDeps))\nmux.Handle(\"/route3\", middleware(handleSomething3(handlerSpecificDeps))\nmux.Handle(\"/route4\", middleware(handleSomething4(handlerSpecificDeps))\n```", "```\n// middleware is a function that wraps http.Handlers\n// proving functionality before and after execution\n// of the h handler.\ntype middleware func(h http.Handler) http.Handler\n```", "```\nfunc handleSomething() http.HandlerFunc {\n\ttype request struct {\n\t\tName string\n\t}\n\ttype response struct {\n\t\tGreeting string `json:\"greeting\"`\n\t}\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t...\n\t}\n}\n```", "```\nfunc TestGreet(t *testing.T) {\n\tis := is.New(t)\n\tperson := struct {\n\t\tName string `json:\"name\"`\n\t}{\n\t\tName: \"Mat Ryer\",\n\t}\n\tvar buf bytes.Buffer\n\terr := json.NewEncoder(&buf).Encode(person)\n\tis.NoErr(err) // json.NewEncoder\n\treq, err := http.NewRequest(http.MethodPost, \"/greet\", &buf)\n\tis.NoErr(err)\n\t//... more test code here\n```", "```\nfunc handleTemplate(files string...) http.HandlerFunc {\n\tvar (\n\t\tinit    sync.Once\n\t\ttpl     *template.Template\n\t\ttplerr  error\n\t)\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tinit.Do(func(){\n\t\t\ttpl, tplerr = template.ParseFiles(files...)\n\t\t})\n\t\tif tplerr != nil {\n\t\t\thttp.Error(w, tplerr.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\t// use tpl\n\t}\n}\n```", "```\nfunc Test(t *testing.T) {\n\tctx := context.Background()\n\tctx, cancel := context.WithCancel(ctx)\n\tt.Cleanup(cancel)\n\tgo run(ctx)\n\t// test code goes here\n```", "```\n// waitForReady calls the specified endpoint until it gets a 200 \n// response or until the context is cancelled or the timeout is \n// reached.\nfunc waitForReady(\n\tctx context.Context, \n\ttimeout time.Duration, \n\tendpoint string,\n) error {\n\tclient := http.Client{}\n\tstartTime := time.Now()\n\tfor {\n\t\treq, err := http.NewRequestWithContext(\n\t\t\tctx, \n\t\t\thttp.MethodGet, \n\t\t\tendpoint, \n\t\t\tnil,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create request: %w\", err)\n\t\t}\n\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error making request: %s\\n\", err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tif resp.StatusCode == http.StatusOK {\n\t\t\tfmt.Println(\"Endpoint is ready!\")\n\t\t\tresp.Body.Close()\n\t\t\treturn nil\n\t\t}\n\t\tresp.Body.Close()\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tif time.Since(startTime) >= timeout {\n\t\t\t\treturn fmt.Errorf(\"timeout reached while waiting for endpoint\")\n\t\t\t}\n\t\t\t// wait a little while between checks\n\t\t\ttime.Sleep(250 * time.Millisecond)\n\t\t}\n\t}\n}\n```"]