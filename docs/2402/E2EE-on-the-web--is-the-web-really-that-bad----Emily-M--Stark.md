<!--yml

category: 未分类

date: 2024-05-27 14:59:16

-->

# 网络上的E2EE：网络真的那么糟糕吗？ | Emily M. Stark

> 来源：[https://emilymstark.com/2024/02/09/e2ee-on-the-web-is-the-web-really-that-bad.html](https://emilymstark.com/2024/02/09/e2ee-on-the-web-is-the-web-really-that-bad.html)

在我的[最新博客文章](https://emilymstark.com/2023/09/09/e2ee-on-the-web-isolating-plaintext.html)中，我讨论了为什么人们经常认为网络不是实施端到端加密（E2EE）的理想平台。[这种观点](https://emilymstark.com/2023/09/09/e2ee-on-the-web-isolating-plaintext.html#:~:text=On%20the%20web%2C%20there%20is%20no%20long%2Dterm%20trustable%20notion%20of%20what%20%E2%80%9Cthe%20application%E2%80%9D%20is%2C%20thus%20there%20is%20no%20sense%20in%20storing%20long%2Dterm%20secret%20keys%20that%20the%20application%20can%20use%20%E2%80%93%20because%20any%20one%20of%20a%20zillion%20TLS%20connections%2C%20or%20edge%20or%20origin%20servers%2C%20could%20be%20compromised%20to%20steal%20the%20long%2Dterm%20keys.)是，网络没有提供关于应用程序的长期可信概念。在早期的文章中，我探讨了将应用程序视为不可信的想法，并隔离敏感数据。在本文中，我将就网络应用程序在E2EE设置中是否真的比原生应用程序不可信多讨论一些，并提出如何弥合这一差距。这一差距并不像乍看起来的那样大，特别是对于桌面应用程序而言。然而，要关闭它，魔鬼在于（用户体验和部署相关的）细节。

## 网络真的更糟吗？

许多安全专家认为，网络不适合E2EE应用程序，因为代码注入的攻击面广阔，可以被开发人员或外部攻击者滥用。对于许多网络应用程序来说，Web浏览器接收并运行来自无数服务器的代码，通过无数TLS连接检索。只要有一个服务器或连接被攻破，就足以注入不可信代码到应用程序中，而且很可能不会被检测到。这与其他任何主流平台都不同，它们对应用程序代码的完整性和/或来源提供了更强的声明。

我认为这个论点基本上是事实正确的，但比第一眼看到的要少说服力。

### Web 与移动端的对比

在移动平台上，所谓更强的安全模型来自于应用商店的政策、审查流程和分发模型，以及操作系统在安全原则设计和沙盒使用上的考量。应用程序使用离线开发者密钥签名，并通常通过商店分发，经过人工审核以符合反滥用政策，并由操作系统供应商运营的集中分发点分发。这些属性各自可能并不提供强有力的保证，但它们共同形成了一个良好的深度防御模型。

如果我们将移动与Web进行比较，移动明显是更安全的平台，特别是在开发高安全性应用程序时。特别是如果威胁模型包括应用程序开发者（例如E2EE消息传递），因为在分发应用程序时除了应用程序开发者外还涉及另一方（操作系统供应商）。

### Web与桌面

在桌面平台上，情况要复杂得多：

+   许多桌面应用程序会从应用程序供应商的服务器自动静默更新，这看起来更像是Web的代码分发模型。

+   如今，桌面应用程序通常与Web应用程序相同构建，然后通过本地分发（例如通过[Electron](https://www.electronjs.org/)）打包。

+   桌面应用程序可能会根据动态数据（例如实验配置）运行不同的代码，并经常加载和重新加载，可能仅依赖TLS来保护这些配置免受注入。

+   与Web应用不同，桌面应用通常使用像C++这样存在内存不安全漏洞的语言编写。

+   桌面应用程序通常以相同的权限级别安装，并且与移动应用程序甚至Web应用程序相比，它们之间的隔离不够。

相较于网络，我会说桌面应用在应用安全方面的主要优势是使用离线开发者密钥进行代码签名的普遍性——因此，可以签署具体的应用程序，而不是形成网络应用的连续代码河流。这种差异是否重要？我不太确定：

+   代码签名的安全价值归结为代码签名PKI的安全性以及验证失败的用户体验，对于系统的这些方面我没有太多信心。此外，在E2EE威胁模型中，代码签名密钥的合法所有者是攻击者；因此，代码签名仅在E2EE威胁模型中部分相关。

+   拥有独立应用程序的想法很吸引人，但我很难说清楚原因。也许在审计和取证方面有一些优势，或者在像企业部署这样的严格控制环境中，知识渊博的管理员可以手动审核更新。它还为构建其他安全机制提供了基础，例如比较用户运行的代码版本与其他人运行的版本——但实际上，在今天的桌面操作系统中，这并没有广泛部署。

也就是说，随着时间的推移，桌面应用程序的安全性正在变得越来越好，新技术如 [Mac OS 签名](https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution)，代码签名 UX 的改进，更像是应用商店的分发模式，以及更强的隔离原语。如果桌面应用程序安全性历史上并没有与 web 应用程序安全性存在巨大差距，那么让 web 落后于桌面应用程序将是一种遗憾。但是，今天，我认为这种差距并不大，尤其是如果您考虑应用程序开发者是一个潜在的攻击者，这就是为什么我对那些声称 web 不适合端对端加密，却乐意分发其桌面版本的人持怀疑态度的原因。

## 将 web 接近于平等：一个 UX 问题

如果我们关心 web 平台与其他平台在安全模型上的差异，那么我们可以为 web 应用程序构建某种代码捆绑和签名机制，或许还可以在其上加一层透明度层，使代码能够公开审计，并且更难以针对特定用户发布恶意代码。为 web 构建捆绑/签名/透明度解决方案可能可以利用已有或至少已经被探索过的一些机制集合。相关的想法包括 [子资源完整性](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)，[隔离的 web 应用](https://github.com/WICG/isolated-web-apps/blob/main/README.md)，[签名交换](https://developer.chrome.com/blog/signed-exchanges) 和 [Web 打包](https://wicg.github.io/webpackage/draft-yasskin-dispatch-web-packaging.html)，Meta 的 [代码验证扩展](https://engineering.fb.com/2022/03/10/security/code-verify/)，以及 [源代码](https://github.com/twiss/source-code-transparency) 和 [供应链](https://datatracker.ietf.org/wg/scitt/about/) 透明度提案。

也就是说，解决方案的许多部分已经存在。很容易想象出一种机制，将 web 应用程序捆绑起来，用离线密钥签名，然后分发到浏览器中以独立运行，不允许任何动态代码加载。但是，仍然存在令人望而生畏的挑战，如用户体验问题和琐碎的部署细节：

+   **网站选择加入/退出**。任何形式的代码捆绑/签名/透明度机制都必须与当前存在的开放 web 平台共存。但是，浏览器如何知道 example.com 是一个正常的 web 应用程序，具有所有常规的动态代码加载机制，而不是一个特殊的捆绑/签名的 web 应用程序？如果 example.com 通常是一个特殊的捆绑/签名的 web 应用程序，但攻击者篡改它以开始提供常规的传统 web 应用程序，浏览器如何知道出现了问题？或者如果浏览器仅仅将信息传递给用户，用户又该如何知道出了什么问题？我认为目前还没有一个很好的答案。

    +   *分离的起源*：浏览器可以为签名/捆绑版本的起源和常规版本的起源使用分离的Web起源。这将隔离像长期身份密钥这样的机密数据。然而，将一个“物理”起源分离为不同的“逻辑”起源在历史上已被证明是一个复杂的努力，并且它引出了用户体验的问题，例如常规版本的起源是否能够钓鱼签名/捆绑版本以破坏安全保证。

    +   *证书透明信号*：有一个提案是将一个[信号](https://github.com/twiss/source-code-transparency/issues/7)插入证书透明日志中，但这种做法有些笨拙，滥用了Web PKI和证书透明的用途。此外，它提供了一个薄弱的安全模型。只有事后才能检测到降级，在证书透明的某种模糊的[安全保证](https://emilymstark.com/2022/08/23/certificate-transparency-is-really-not-a-replacement-for-key-pinning.html)内。

    +   *粘性头部*：可以想象使用类似[HSTS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)的头部，通过捆绑/签名的Web应用指示浏览器仅接受该域名的捆绑/签名代码。浏览器会记住这个指令一段可配置的时间。这可能还可以，但不是理想的解决方案。只有当用户访问网站以按预测的频率刷新浏览器缓存的指令时，HSTS的安全保证才能保持有效，并且它不能保护第一次访问免受降级的影响。任何一种“粘性”基于域名的机制，在域名所有者转让域名、让其过期或者改变网站配置想法时都会变得有问题。而且，HSTS已经激发了一些难以维护的[hacks](https://scotthelme.co.uk/hsts-preloading/)，用于需要更强安全性的网站。这些问题对于HSTS来说可能还能接受，因为在非常长期内，我们希望HSTS逐渐被HTTPS所取代。但对于代码捆绑/签名来说，没有任何长期的情况能使捆绑/签名应用成为默认或者唯一支持的机制，所以这些缺点可能不那么容忍。

+   **失败的用户体验**。无论是网站选择订阅还是取消订阅的解决方案，都必须设计一些用户体验功能，以便在浏览器预期获得有效的捆绑/签名网络应用程序但实际上没有时采取相应措施：例如，签名无效、浏览器预期获取捆绑/签名应用程序但获取的是传统资源，或者代码透明性验证出现故障（如果这种情况发生）。那么接下来会发生什么？用户能否绕过错误？如果可以，那么与其他安全警告一样，警告必须设计得恰到好处，以允许某些用户做出合理的、知情的判断，而不会将知识较少的用户置于风险之中，并且不会加剧端到端加密应用程序中更广泛的警告疲劳或习惯化效应。如果浏览器不允许用户绕过错误，那么整个系统必须精心设计，以使错误的误报几乎不存在。

+   **开发和部署经验**。最后，无论是应用程序捆绑/签名/透明性的机制如何，都必须能够被开发者使用。我发现，很容易把端到端加密视为一种小众功能，因此将应用程序捆绑/签名视为只有少数高度安全敏感的Web应用程序会使用的东西。很容易通过假设Web应用程序会很小且静态，或者适合于自定义的繁琐开发工作流程，或者由高度复杂的开发者构建来使问题更加可控。但实际上，一些世界上最大、最复杂的Web应用程序（例如facebook.com）需要端到端加密。目标市场包括具有大量传统代码、复杂定制开发工作流程、高性能敏感用户群等各种Web应用程序。此外，如果我们将Web上的端到端加密设计为一种小众功能，这将成为自我实现的预言。通过将其设计为大众市场功能，增加了端到端加密在任何平台上成为现代应用程序的基本要求的可能性。对Web的可用代码完整性和来源机制也将有益于除端到端加密应用程序外的许多其他类型的安全敏感应用程序。

在努力将端到端加密引入Web的过程中，我希望不要忘记或低估用户体验和开发者人机工效学中的这些挑战。

*感谢David Adrian、Richard Barnes、Nick Doty、Wendy Knox Everette、Ryan Hurst、April King、Jon Millican和Chris Palmer在这篇文章中提供的反馈意见。*
