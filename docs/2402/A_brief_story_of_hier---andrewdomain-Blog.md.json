["```\n> When the operating system grew too big to fit on the first RK05 disk pack (their \n> root filesystem) they let it leak into the second one, which is where all the \n> user home directories lived (which is why the mount was called /usr).  They \n> replicated all the OS directories under there (/bin, /sbin, /lib, /tmp...) \n> ```", "```\n> Of course they made rules about \"when the system first boots, it has to come up \n> enough to be able to mount the second disk on /usr, so don't put things like \n> the mount command /usr/bin or we'll have a chicken and egg problem bringing \n> the system up.\"\n> ...\n> The /bin vs /usr/bin split (and all the others) is an artifact of this, a \n> 1970's implementation detail \n> ```", "```\n> Quite a number of programs these days hook themselves \n> into the early boot process at various stages. \n> A popular way to do this is for example via udev rules. \n> The binaries called from these rules are sometimes located on /usr/bin, \n> or link against libraries in /usr/lib, or use data files from /usr/share. \n> If these rules fail udev will proceed with the next one, \n> however later on applications will then not properly detect\n> these udev devices or features of these devices. \n> ```", "```\n> I have a system that boots in three seconds, which is fairly long\n> already. Adding an initrd would extend that to five seconds and require\n> a twenty minute rebuild of the initrd on upgrade.\n> \n> Using an initrd would also add new failure modes where the initrd build\n> fails because of memory constraints (e.g. because an application process\n> is stuck in D state and did not terminate when we entered the \"system\n> update\" runlevel). \n> ```", "```\n> I, for example, am afraid of having to merge /usr in existing systems\n> during upgrades, causing repartitions to be necessary. I am afraid of\n> partition layout suddenly not fitting any more during an upgrade,\n> causing downtimes and customers considering to take the opportunity to\n> migrate to a really supported enterprise distribution.\n> \n> And, I really don't want to have to adapt, test and verify scripts and\n> backup schemes to changed partition layout. This will be necessary for\n> new systems, and it is really a horror vision to have to do this for\n> existing systems during upgrades. \n> ```", "```\n> a) the split between sbin and bin requires psychic powers from\n>    upstream developers:\n> \n>    The simple fact is that moving binaries between these dirs is really\n>    hard, and thus developers in theory would need to know at the time\n>    they first introduce a binary whether it *ever* might ever make sense to\n>    invoke it as unprivileged user (because in that case the binary\n>    belongs in /bin, not /sbin). History shows that more often than\n>    not developers have placed their stuff in the wrong directory, see\n>    /sbin/arp, /sbin/ifconfig, /usr/sbin/httpd and then there is no smart\n>    way to fix things anymore since changing paths means breaking all hardcoded\n>    scripts. And hardcoding paths in scripts is actually something we\n>    encourage due to perfomance reasons. The net effect is that many\n>    upstream developers unconditionally place their stuff in bin, and\n>    never consider sbin at all which undermines the purpose of sbin\n>    entirely (i.e. in systemd we do not stick a single binary in sbin,\n>    since we cannot be sure for any of its tools that it will never\n>    ever be useful for non-root users. and systemd is as low-level,\n>    system-specific it can get).\n> ...\n> f) splitting things up complicates stuff. If you want to keep things\n>    separate you really need a good reason for that. We should always\n>    focus on simplifiying things. And merging things into /usr does just\n>    that: it drastically simplifies the complexities we have collected\n>    over 30+ years of Unix heritage.\n> \n> g) given that some distros place certain binaries in other places than\n>    others, merging the dirs has the big benefit that the four paths are\n>    equivalent and scripts from other distros work on ours, regardless\n>    where the other distros place their stuff \n> ```", "```\n>  Environment variables exported by the user service manager are passed \n>        to any services started by that service manager. \n>        In particular, this may include services which run user shells. \n>        For example in the GNOME environment, the graphical terminal\n>        emulator runs as the gnome-terminal-server.service user unit,\n>        which in turn runs the user shell,  so that shell\n>        will inherit environment variables exported by the user manager.\n>        For other instances of the shell, not \n>        launched by the user service manager, the environment they\n>        inherit is defined by the program that starts them. \n>        ...\n>        Specifically, for ssh logins, the sshd(8) service builds\n>        an environment that is a combination of variables forwarded from\n>        the remote system and defined by sshd...\n>        A graphical display session will have an analogous mechanism \n>        to define the environment. \n>        Note that some managers query the systemd user instance\n>        for the exported environment and inject this configuration\n>        into programs they start, \n>        using systemctl show-environment or the underlying D-Bus call. \n> ```", "```\n# Path manipulation\nif [ \"$EUID\" = \"0\" ]; then\n    pathmunge /usr/sbin\n    pathmunge /usr/local/sbin\nelse\n    pathmunge /usr/local/sbin after\n    pathmunge /usr/sbin after\nfi \n```", "```\n You don't want the normal user to have /sbin in its PATH.  \n You maybe want only the root user to have /sbin in PATH.  \n\n Nowadays is also very easy and quick to gain root privileges with sudo,\n so at least normal users should be forced to write /sbin/something in full,\n so that they also remember to think about what they're typing..\n Because it would make sense for everything that is under /sbin, \n to be dangerous to the system if misused.\n\n So...  \n normal users having no /sbin in PATH, and\n discouraging interactive root sessions with (e.g.) `sudo -i`. \n```", "```\n> In the old times there was “root” and lusers, \n> the privilege separation was completely binary. \n> But some time in the 2.2 era, Linux implemented capabilities. \n> This means that you can be root, completely unprivileged, \n> or in one of the 1099511627774 intermediate states.\n> ...\n> The interesting corollary is that all programs that\n> are supposed to “run as root” must always treat \n> every individual operation as something \n> that can fail (because even if the process\n> formally has privileges, MAC or something else \n> may prevent the operation) and must report such failure \n> in sufficient detail. It is not OK to say “we failed” or\n> “not enough privileges, must be root”, because that is not\n> enough to figure out what exactly failed. \n> In fact, the process may be root and still fail. \n> ```"]