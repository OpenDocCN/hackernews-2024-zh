- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 13:21:41'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Abusing Conda's YAML comments that are actually Python expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://astrid.tech/2024/02/24/0/conda-recipe-selector-abuse/](https://astrid.tech/2024/02/24/0/conda-recipe-selector-abuse/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Abusing Conda's YAML comments that are actually Python expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: my favorite build system, jinja-preprocessed-eval-preprocessed YAML
  prefs: []
  type: TYPE_NORMAL
- en: 2024-02-24 01:25*
  prefs: []
  type: TYPE_NORMAL
- en: '[python](/t/python) [Anaconda](/t/anaconda) [cybersecurity](/t/cybersecurity)'
  prefs: []
  type: TYPE_NORMAL
- en: 'I was trying to submit a Conda package to [Conda Forge](https://conda-forge.org/),
    and I needed a way to mark it as Linux and MacOS only. As it turns out, you are
    supposed to define something like this in your `meta.yaml` build configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What this seems to mean is, “skip the build if we are in windows.” Why is it
    a comment? I don’t know, but that’s what it is.
  prefs: []
  type: TYPE_NORMAL
- en: This package also is a Python 3.9 and above thing – we don’t support 3.8 or
    under. So, how do I add that constraint?
  prefs: []
  type: TYPE_NORMAL
- en: Well, turns out this strange construct is called a “selector,” and there’s a
    section about what you can do with it in the [Conda docs](https://docs.conda.io/projects/conda-build/en/stable/resources/define-metadata.html#preprocessing-selectors)
  prefs: []
  type: TYPE_NORMAL
- en: You can add selectors to any line, which are used as part of a preprocessing
    stage. Before the `meta.yaml` file is read, each selector is evaluated and if
    it is `False`, the line that it is on is removed. A selector has the form `# [<selector>]`
    at the end of a line.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Oh, that makes sense. Cursed, because YAML *shouldn’t* look like this with multiple
    keys in one object, but it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: A selector is a valid Python statement that is executed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Wait… what?
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the selector is any valid Python expression, complicated logic is possible:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Wait, *WHAT*?
  prefs: []
  type: TYPE_NORMAL
- en: So… what it’s saying is… this is what I want?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I put that into my `meta.yaml` and… turns out it made it work!
  prefs: []
  type: TYPE_NORMAL
- en: But then, I got wondering, what *other* kinds of “complicated logic” is allowed
    in this selector?
  prefs: []
  type: TYPE_NORMAL
- en: Trying to accomplish arbitrary code execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I borrowed the following `meta.yaml` file from [conda-forge’s example](https://github.com/conda-forge/staged-recipes/blob/main/recipes/example/meta.yaml),
    but stripped it down a lot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, I inserted the following string to see if it would work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I ran `conda build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It spits out a lot of output. We don’t need to go over all of it. It seemed
    to have immediately quit.
  prefs: []
  type: TYPE_NORMAL
- en: But, checking `/tmp/foo`…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It fucking worked!!!
  prefs: []
  type: TYPE_NORMAL
- en: Where can the selector be placed?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I thought it might be smart to do something like this so that I don’t accidentally
    spit out a falsy value and make conda actually build the project, instead of only
    doing whatever shenanigans I was trying to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Why didn’t it work? Maybe it’s because the selector code is searching specifically
    for a comment with stuff in front of it. I don’t know. Either way, I can live
    with putting it on one of the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Making it run a shell command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s try to have it run a shell. This can’t be too hard, right?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Seems like it didn’t like that. Probably because it specifically accepts an
    expression, not a series of statements.
  prefs: []
  type: TYPE_NORMAL
- en: After a bit of digging around, turns out the answer was `exec()` (plus a `or
    True` to make it not build).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]conda build purge[PRE14]'
  prefs: []
  type: TYPE_NORMAL
- en: Making it talk to other computers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you can kinda just run whatever. Installing `netcat`, I used
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In a separate shell, I opened a server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Performing a build…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: … conda froze! But in the other tab, I got the message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I typed `asdfasdf` into the server tab, and got data back in the builder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Making it spawn a reverse shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is, of course, the logical final step. In fact, this selector doesn’t even
    need netcat.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Exploitability?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Honestly, I don’t think that there’s much that’s exploitable about this that
    isn’t already exploitable. As far as I know, `conda build` doesn’t do containerization
    or other security measures like that, so any amount of exploitation I can do here
    is probably already exploitable by the build script.
  prefs: []
  type: TYPE_NORMAL
- en: I mean, I guess I *could* see a potential case where `conda build` has a command
    that spits out the `meta.yaml` after it has done its jinja and selector postprocessing,
    but without executing any scripts, and the user would expect that no arbitrary
    code execution is happening. In practice, I don’t think that’s really common –
    most people probably just run `conda build`.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is great for recipe developers – this mechanism lets you make
    your build logic be non-deterministic, and have arbitrarily-complicated logic
    and I/O! You can do all sorts of things, like don’t build if the user’s name starts
    with an “a,” combine this with curl and an HTTP server to act as a killswitch
    for builds, make the metadata evaluation step “borrow” peoples’ SSH keys, and
    more!
  prefs: []
  type: TYPE_NORMAL
- en: What’s the code that actually calls eval?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The great thing about open source is that you can actually answer this question!
  prefs: []
  type: TYPE_NORMAL
- en: In the [conda-build repository](https://github.com/conda/conda-build), I searched
    for `eval`, and [this was the function](https://github.com/conda/conda-build/blob/cc7bb532eff61451853a8195f39688a2101a9548/conda_build/metadata.py#L255-L257)
    that seems to do it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This code was last touched… [2017, in PR #1753](https://github.com/conda/conda-build/pull/1753).
    And that wasn’t the thing that actually introduced the `eval()`, that commit just
    moved it to a different place. [Here’s what it used to look like before that commit](https://github.com/conda/conda-build/blob/761b3dc00e85ab3f8e7443417cd1d3888d2cce04/conda_build/metadata.py#L109-L112):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The comment came [in this 2016 commit](https://github.com/conda/conda-build/commit/d52852da9722e4b9b19664f7d0614b5ee5dfebdf#diff-a3f5613bda9366e31149c65731327047d4e29204c9e0508fd55416115b39a6bdR110-R111)
    from either [a group called Quantified Code](https://github.com/quantifiedcode)
    (whose website, [www.quantifiedcode.com](http://www.quantifiedcode.com/), appears
    to no longer work), or some automated tool they appear to have written. The `eval()`,
    on the other hand, came from [this 2,532-line commit in 2014 with the very informative
    title of “add new files”](https://github.com/conda/conda-build/commit/fe7f773010f4c8c200298c83a4164ca404626d52#diff-a3f5613bda9366e31149c65731327047d4e29204c9e0508fd55416115b39a6bdR52-R53).
  prefs: []
  type: TYPE_NORMAL
- en: I tried searching the issues to see if anyone has complained about how silly
    this `eval()` is, but I didn’t find anything. Perhaps people don’t mind at all.
    Perhaps there are even other people out there who are including shell scripts
    in their selectors!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Honestly, I don’t know how to conclude this. It’s a really silly thing that
    you can do, but it’s not even particularly exploitable. What I probably would
    have done if I wanted to implement something like this was cut the selector/jinja/YAML
    crap and just let the user write a Python script to generate this if you want
    your damn “flexibility.”
  prefs: []
  type: TYPE_NORMAL
- en: Okay, fine, maybe people really like their selector/jinja/YAML configs, and
    I really just had to deal with that fact. In that case, I would just was write
    a 100-200 line parser and interpreter for selector booleans. But my guess is that
    they probably rushed this and didn’t really fix it either.
  prefs: []
  type: TYPE_NORMAL
- en: Honestly, maybe I’m just being really negative. I’ll leave the final word to
    ChatGPT, who I have asked to help us be more optimistic about arbitrarily-executable
    YAML comments.
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary code execution within configuration file comments epitomizes the flexibility
    and agility central to modern DevOps practices, providing developers with unparalleled
    customization, dynamic configuration management, self-documentation, automation,
    and advanced configuration options. By harnessing executable code snippets within
    comments, teams can swiftly adapt to changing requirements, seamlessly integrating
    infrastructure as code (IaC) principles into agile deployment pipelines and continuous
    integration/continuous deployment (CI/CD) workflows. This capability fosters a
    culture of innovation, enabling rapid iteration, experimentation, and optimization,
    while ensuring infrastructure scalability and reliability.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'EDIT 2024-04-18: make title more informative'
  prefs: []
  type: TYPE_NORMAL
