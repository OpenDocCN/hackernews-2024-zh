["```\n// Index returns the index of the first occurrence of v in s,\n// or -1 if not present.\nfunc Index[S ~[]E, E comparable](s S, v E) int {\n    for i := range s {\n        if v == s[i] {\n            return i\n        }\n    }\n    return -1\n} \n```", "```\n s := []string{\"Bat\", \"Fox\", \"Owl\", \"Fox\"}\n    s2 := slices.Clone(s)\n    slices.Sort(s2)\n    fmt.Println(s2) // [Bat Fox Fox Owl]\n    s2 = slices.Compact(s2)\n    fmt.Println(s2)                  // [Bat Fox Owl]\n    fmt.Println(slices.Equal(s, s2)) // false \n```", "```\ns = append(s[:2], s[5:]...) \n```", "```\nfunc Delete[S ~[]E, E any](s S, i, j int) S {\n       return append(s[:i], s[j:]...)\n} \n```", "```\ns = slices.Delete(s, 2, 5) \n```", "```\n slices.Delete(s, 2, 5) // incorrect!\n    // s still has the same length, but modified contents \n```", "```\nslices.Delete(s, 2, 3)  // !! INCORRECT !! \n```", "```\nslices.Sort(s) // correct\nslices.Compact(s) // !! INCORRECT !! \n```", "```\nu := slices.Delete(s, 2, 3)  // !! INCORRECT, if you keep using s !! \n```", "```\ns := slices.Delete(s, 2, 3)  // !! INCORRECT, using := instead of = !! \n```"]