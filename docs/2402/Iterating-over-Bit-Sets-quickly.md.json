["```\nclass  BitSet  {  private words:  number[];  add(index:  number):  void;  remove(index:  number):  void;  has(index:  number):  boolean}\n```", "```\nclass  BitSet  {  forEach(callback:  (index:  number)  =>  void)  {  }}\n```", "```\nconst words =  this.words;for  (let wordIndex =  0; wordIndex < words.length; wordIndex++)  {  const word = words[wordIndex];}\n```", "```\nfor  (let i =  0; i <  WORD_LEN; i++)  {}\n```", "```\nconst bitIsSetToOne =  (word &  (1  << i))  !==  0;\n```", "```\nfor  (let i =  0; i <  WORD_LEN; i++)  {  const bitIsSetToOne =  (word &  (1  << i))  !==  0;  if  (bitIsSetToOne)  {  callback(index)\n\n             // Cannot find name 'index'.\n\n  }}\n```", "```\nconst index =  (wordIndex <<  WORD_LOG)  + i;\n```", "```\n1  <<  WORD_LOG3  <<  WORD_LOG\n```", "```\nclass  BitSet  {  forEach(callback:  (index:  number)  =>  void)  {  const words =  this.words;  for  (let wordIndex =  0; wordIndex < words.length; wordIndex++)  {  const word = words[wordIndex];  for  (let i =  0; i <  WORD_LEN; i++)  {  const bitIsSetToOne =  (word &  (1  << i))  !==  0;  if  (bitIsSetToOne)  {  const index =  (wordIndex <<  WORD_LOG)  + i;  callback(index);  }  }  }  }}\n```", "```\nfor  (let wordIndex =  0; wordIndex < words.length; wordIndex++)  {  const word = words[wordIndex];  if  (word ===  0)  continue;  }\n```", "```\n[  00000000,  01000000,  00000000,  00000000,  0000001  ][  11101101,  01110001,  10110101,  11010001,  0101101  ]\n```", "```\nconst densities =  [1,  0.75,  0.5,  0.25,  0.1,  0.05,  0.01,  0.001];\n```", "```\nconst bitsetsAndDensities = densities.map((density)  =>  ({ density, bitset:  makeBitSet(100_000_000, density),}));\n```", "```\nfunction  makeBitSet(size:  number, density:  number)  {  const bitset =  new  BitSet();  for  (let i =  0; i < size; i++)  {  if  (Math.random()  < density)  { bitset.add(i);  }  }  return bitset;}\n```", "```\nfor  (const  { bitset, density }  of bitsetsAndDensities)  {  profile(  ()  => bitset.forEach(()  =>  {}),  (time)  =>  console.log(`${percentage(density)} density: ${time}`),  );}\n```", "```\n100.0% density:     95.2 ms 75.0% density:    250.7 ms 50.0% density:    343.3 ms 25.0% density:    221.8 ms 10.0% density:    141.6 ms 1.0% density:     78.5 ms 0.1% density:     66.7 ms\n```", "```\n100.0% density:     95.4 ms 75.0% density:    245.5 ms 50.0% density:    336.3 ms 25.0% density:    213.9 ms 10.0% density:    132.4 ms 1.0% density:     34.6 ms 0.1% density:      5.6 ms\n```", "```\nexport  const  WORD_FIRST_HALF_MASK  =  0x0000ffff;export  const  WORD_LATTER_HALF_MASK  =  0xffff0000;console.log(WORD_FIRST_HALF_MASK);console.log(WORD_LATTER_HALF_MASK);\n```", "```\nconst iterFirstHalf =  (word &  WORD_FIRST_HALF_MASK)  !==  0;const iterLatterHalf =  (word &  WORD_LATTER_HALF_MASK)  !==  0;\n```", "```\nconst start = iterFirstHalf ?  0  :  WORD_LEN_HALF;const end = iterLatterHalf ?  WORD_LEN  :  WORD_LEN_HALF;for  (let i = start; i < end; i++)  {}\n```", "```\n00010011  1110110011101101 \n```", "```\n00110000  1100111111010000 \n```", "```\nwhile  (word !==  0)  {  const lsb = word &  -word; word ^= lsb;  }\n```", "```\nindexOfFirstSetBit(0b00000100)indexOfFirstSetBit(0b00000001)indexOfFirstSetBit(0b00100000)\n```", "```\nfunction  hammingWeight(n:  number):  number  { n -=  (n >>  1)  &  0x55555555; n =  (n &  0x33333333)  +  ((n >>>  2)  &  0x33333333);  return  (((n +  (n >>>  4))  &  0xf0f0f0f)  *  0x1010101)  >>  24;}\n```", "```\nclass  BitSet  {  forEach(callback:  (index:  number)  =>  void)  {  const words =  this.words;  for  (let wordIndex =  0; wordIndex < words.length; wordIndex++)  {  let word = words[wordIndex];  }  }}\n```", "```\nwhile  (word !==  0)  {  const lsb = word &  -word;}\n```", "```\nconst index =  (wordIndex <<  WORD_LOG)  +  hammingWeight(lsb -  1);callback(index);\n```", "```\nforEach(callback:  (index:  number)  =>  void)  {  const words =  this.words;  for  (let wordIndex =  0; wordIndex < words.length; wordIndex++)  {  let word = words[wordIndex];  while  (word !==  0)  {  const lsb = word &  -word;  const index =  (wordIndex <<  WORD_LOG)  +  hammingWeight(lsb -  1);  callback(index); word ^= lsb;  }  }}\n```"]