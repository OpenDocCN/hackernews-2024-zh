<!--yml

类别：未分类

日期：2024-05-29 13:29:01

-->

# 你刚刚继承了一个遗留的 C++ 代码库，现在该怎么办？

> 来源：[https://gaultier.github.io/blog/you_inherited_a_legacy_cpp_codebase_now_what.html](https://gaultier.github.io/blog/you_inherited_a_legacy_cpp_codebase_now_what.html)

发布日期为2024-02-29。

# 你刚刚继承了一个遗留的 C++ 代码库，现在该怎么办？

*这篇文章在[Hacker News](https://news.ycombinator.com/item?id=39549486)、[Lobster.rs](https://lobste.rs/s/lf8b9r/you_ve_just_inherited_legacy_c_codebase)和[Reddit](https://old.reddit.com/r/programming/comments/1b3143w/youve_just_inherited_a_legacy_c_codebase_now_what/)上讨论过。从评论中得到了很好的建议，请看结尾的附录！*

你正在自己做自己的事情，突然间有东西掉到你身上。也许你开始了一份新工作，或者换了团队，或者有经验的人离开了。

现在你要负责一个庞大、复杂、古怪的 C++ 代码库；你盯着它看时间太久，它会以各种有趣的方式崩溃。总之，它是遗留的。

但是一些 bug 仍然需要修复，偶尔需要添加新功能。简而言之，你不能忽视它，更好的办法是不要把它完全消灭。它是重要的。至少对于支付你工资的人来说是重要的。所以，它对你很重要。

现在你该怎么办？

不要害怕，因为我在许多地方多次经历过这种情况（背后那些讽刺的人会嘀咕：哪个 C++ 代码库不正如我所描述的那样），而且有一种方法可以走出困境，不会太痛苦，能让你实际修复 bug、添加功能，甚至梦想中的某一天重写它。

所以，请跟我一起回顾对我有效的方法，以及应该绝对避免的事情。

公平地说 C++，我并不讨厌它（本质上），它只是被人滥用的一种语言，不可避免地导致了可怕的混乱，可怜的 C++ 只是这里的受害者，C++ 委员会将在 C++45 中修复它，放心吧，通过将`std::cmake`加入标准库，你会看到它绝对是一个游戏改变者，啊- 咳咳，好吧，让我们回到话题。

所以，这里是要采取的步骤概述：

1.  把它在本地运行起来，只需做必要的代码和构建系统的最小更改，最好是没有。即使痒得厉害也不要进行大规模重构！

1.  拿出电锯，除去一切不是绝对必要的东西，以提供公司/开源项目正在宣传和销售的功能。

1.  让项目进入 21 世纪，通过添加 CI、代码检查、模糊测试、自动格式化等。

1.  最后，我们可以对代码进行小的增量更改，反复操作，直到你在每个夜晚都不再因为俄罗斯黑客在几秒钟内轻松攻破你的应用程序而惊醒。

1.  如果可能的话，考虑用一种内存安全的语言重写部分内容

最终目标是尽可能少地付出努力，以在安全性、开发人员体验、正确性和性能方面使项目达到可接受的状态。始终牢记这一点至关重要。这不是关于‘整洁的代码’，使用新潮的语言特性等等。

好的，让我们开始吧！

*顺便说一句，这里的一切都适用于纯 C 代码库或混合 C 和 C++ 代码库，所以如果你属于这一类，请继续阅读！*

**目录**

## 获得支持

你以为我会比较不同的消毒剂、编译标志或者构建系统？不，先和人们交流。疯狂吧？

软件工程需要成为一种可持续的实践，而不是你在几个月或几年后就会疲惫不堪的东西。我们不能在下班后、在一场死亡进程中，甚至是单打独斗中做到这一点！我们需要说服人们支持这一努力，让他们理解我们在做什么以及为什么要这么做。这包括每个人：你的老板、你的同事，甚至非技术人员。也许你去度假，回来时会发现人们在你不在办公室时继续推进这一努力。

所有这些只意味着：用简单的事实解释问题，提出解决方案并设定时间框架。简单吧？例如（引用 South Park 的话：*此节目中的所有角色和事件——即使是基于真实人物——都是虚构的*）：

+   嘿，老板，上一个新员工花了 3 周时间在他的机器上构建代码并进行了第一次贡献。如果我们能够以最小的努力让这个过程缩短到几分钟，那不是挺好的吗？

+   嘿，老板，我快速地搭建了一个简单的模糊测试设置（‘向应用中输入随机数据，像猴子一样看会发生什么’），在几秒钟内成功让应用崩溃了 253 次。我在想，如果在生产环境中有人试图这样做，会发生什么？

+   嘿，老板，最近几个紧急 bug 修复需要多人参与，花了 2 周时间才在生产环境中部署完成，因为这个应用只能通过一个带有已经不再支持的古老操作系统的构建服务器构建（对于感兴趣的人来说是 FreeBSD 9），而且它一直失败。哦，顺便说一句，每当这台服务器挂掉时，我们就没法部署了，完全没有办法。要不要考虑能够在任何廉价的云实例上构建我们的应用？

+   嘿，老板，我们的生产环境出现了一个难以理解的 bug，影响了用户，花了几周时间才找到并修复。原来是由于未定义行为（‘在代码中很难注意到的问题’）导致数据损坏。当我在我们的代码上运行这个行业标准的代码检查工具（‘一个可以找出代码问题的程序’）时，它立即检测到了问题。每次修改代码时我们应该运行这个工具！

+   嘿，老板，年度审计即将到来，上次审计因为审计员对所见情况不满意花了 7 个月才通过。我有一些想法可以让这次变得更顺利。

+   嘿老板，现在关于能够解密加密数据并窃取机密的安全漏洞正在新闻中，我认为我们可能会受到影响，但我不能确定，因为我们使用的密码库是手动‘复制-粘贴’并在其上进行了一些未经任何人审查的更改。我们应该清理一下，并设置一些东西，以便我们在受影响的漏洞发生时自动接收警报。

还有一些要避免的，完全是超级幻想，从未真正发生在我身上的例子：

+   我们没有使用最新的 C++ 标准，我们应该停止所有工作 2 周来进行升级，同时我也不知道是否会出现问题，因为我们没有任何测试

+   我将在一个单独的分支上对项目进行大量更改，并在几个月内进行工作。它肯定会在某个时候合并！（旁白：事实并非如此）

+   我们将从头开始重写项目，应该最多花几周时间

+   我们将改进代码库，但不知道何时会完成或甚至我们确切要做什么

好了，现在你已经得到了所有重要人士的支持，让我们过一下流程：

+   每次更改都是小而逐步的。应用程序在之前和之后都可以正常工作。测试通过，语法检查器也很满意，没有绕过任何内容来应用这些更改（例外情况确实会发生，但那只是例外）。

+   如果必须进行紧急的错误修复，可以像往常一样进行，没有任何阻碍

+   每次更改都是可量化的改进，并且可以解释并向非专家演示

+   如果整个工作必须暂停或完全停止（因为优先级转移、预算原因等），总体而言仍然比开始之前是一种净收益（而且这种收益以某种形式是*可量化*的）

根据我的经验，采用这种方法，你能让每个人都满意，并能进行真正需要做的改进。

好了，现在让我们开始吧！

## 写下你支持的平台列表

这非常重要，但不是许多项目所做的。在 README 中写下来吧（你肯定有 README 吧？）。它只是你的代码库官方支持的`<架构>-<操作系统>`对的列表，例如 `x86_64-linux` 或 `aarch64-darwin`。这对于使每一个平台上的构建工作都至关重要，而且稍后我们会看到，还可以删除你*不*支持的平台上的废物。

如果你想要搞高级的，甚至可以写下架构的版本，比如 ARMV6 vs ARMv7 等等。

这有助于回答一些重要问题，比如：

+   我们是否可以依赖于硬件支持浮点数、SIMD 或 SHA256？

+   我们是否在乎支持 32 位？

+   我们是否曾经在大端平台上运行过？（答案很可能是：没有，从未如此，将来也不会 - 如果您这样做了，请通过电子邮件告诉我详细信息，因为这听起来很有趣）。

+   `char` 能是 7 位吗？

还有一个重要的观点：这个列表绝对应该包括开发者的工作站。这让我想到了我的下一个观点：

## 使构建在您的机器上正常工作

您会惊讶地发现，有多少野生的C++代码库是成功产品的核心部分，赚取数百万美元，而它们基本上无法编译。嗯，如果所有条件都符合，它们可以。但这不是我的重点。我说的是在您支持的所有平台上可靠、一致地构建。没有麻烦，没有‘经过三周的拔头发终于搞定了’（这让我想起了一些回忆）。它只是工作（tm）。

一个小插曲在这里。我曾经非常喜欢空手道。我们每周进行3到4次训练，等等。我清楚地记得我的一位老师告诉过我（想象一个睿智的亚洲师傅 - 嗯实际上我的老师是个秃头白人… 想象一下史蒂夫·鲍尔默）：

> 您还没有掌握这一步骤。有时您会做到，有时您不会，因此您不要强求。吃饭时，用汤匙吃，你有五次中就有一次不会把勺子送到嘴巴里吗？

作为一名软件工程师，我一直秉持着这个理念。‘新功能可用’意味着它每次都有效。不是四次成功，一次失败。因此，构建也是如此。

经验告诉我，以快速和高效的方式生产软件的最佳方法是能够在您的机器上构建，理想情况下甚至在您的机器上运行。

现在，如果您的项目非常庞大，这可能会成为一个问题，您的系统甚至可能没有足够的内存来完成构建。后备方案是在某处租用一个大型服务器并在此运行您的构建。这不是最理想的，但总比什么都不强。

另一个障碍是代码需要一些特定平台的API支持，例如在Linux上的`io_uring`。在这里有所帮助的是实现一个适配器，或者在您的工作站上构建一个虚拟机。虽然不是最理想的，但总比没有强。

我过去做过所有这些，效果很好，但直接在您的机器上构建仍然是最佳选择。

## 在您的机器上使测试通过

首先，如果没有测试，我很抱歉。这将使得任何更改都变得非常困难。所以在对代码进行任何更改之前，先编写一些测试用例，并确保通过，然后再继续。最简单的方法是捕获程序在现实世界中运行的输入和输出，并基于此编写端到端测试，越多样化越好。这将确保在进行更改时没有回退，虽然行为是否一开始就是正确的，但总比什么都不做强。

所以，现在你有了一个测试套件。如果有些测试失败，暂时禁用它们。确保使其通过，即使整个测试套件运行需要几个小时。我们以后再来解决这个问题。

## 在README中写下如何构建和测试应用程序的步骤

理想情况下，构建和测试应该只需一个命令。起初，如果更复杂，可以将相应的命令放入`build.sh`和`test.sh`中，以封装这种混乱。

目标是使非C++专家能够构建代码并运行测试，而无需询问您任何事情。

有些人会建议文档化项目布局、架构等。因为下一步将剥离大部分内容，所以我建议现在不要浪费时间，最后再做。

## 找到加快构建和测试速度的低成本方法

强调“低成本”。不改变构建系统，不进行英雄主义的努力（我在本文中一直重复这一点，因为这非常重要）。

再次，在一个典型的 C++ 项目中，你会惊讶于构建系统在没有任何必要时所做的工作量。尝试下面的这些想法，看看是否有帮助：

+   默认情况下构建和运行依赖项的测试。在一个项目中，该项目将 `unittest++` 作为一个 CMake 子项目进行构建时，我发现默认行为是每次构建和运行测试框架的测试！这太疯狂了。通常有一个 CMake 变量或者类似的东西可以选择退出这个行为。

+   默认情况下构建和运行依赖项的示例程序。和上面一样，这次的罪魁祸首是 `mbedtls`。再次，设置一个 CMake 变量来选择退出解决了这个问题。

+   默认情况下，在将其作为另一个父项目的子项目包含时，构建和运行你的项目的测试。是的，我们刚才嘲笑过依赖项的默认行为？结果我们对其他项目也做了同样的事情！我不是 CMake 专家，但似乎没有标准的方法来排除构建测试。因此，我建议添加一个名为 `MYPROJECT_TEST` 的构建变量，默认情况下未设置，仅在设置时构建和运行测试。通常只有直接在项目上工作的开发人员会设置它。示例和生成文档等情况也是如此。

+   当你只需要其一小部分时，构建所有第三方依赖项：`mbedtls` 是一个很好的例子，因为它暴露了许多编译时标志来切换你可能不需要的许多部分。注意默认值，并且仅构建你需要的部分！

+   错误地列出了一个目标的错误依赖项，导致在不必要时重新构建整个世界：大多数构建系统都有一种方法可以从它们的角度输出依赖图，这真的可以帮助诊断这些问题。没有比等待数分钟或数小时重新构建更糟糕的感觉，而你深知它应该只重新构建了几个文件。

+   尝试一个更快的链接器：`mold` 是一个可以无成本地集成并真正帮助的链接器。但这真的取决于链接的库的数量，无论总体上是否成为瓶颈等等。

+   如果可以的话，尝试使用不同的编译器：我见过一些项目，clang 的速度是 gcc 的两倍，而另一些则没有区别。

一旦完成这些工作，这里有一些额外尝试的事情，尽管增益通常要小得多，有时甚至是负面的：

+   LTO：关闭/开启/精简

+   拆分调试信息

+   使用 Make 或 Ninja

+   正在使用的文件系统类型，以及调整其设置

一旦迭代周期感觉良好，代码就要被放大镜检查。如果构建需要很长时间，想要修改代码就不现实了。

## 删除所有不必要的代码。

爸爸，我看到死代码的截止日期了。

（明白引用了吗？好的，那么。）

我见过 30% 甚至更多的代码库完全是死代码。这是每次编译都要支付代价的代码行，你想进行重构等等。所以我们来把它们剔除吧。

以下是一些处理方法：

+   编译器有一堆 `-Wunused-xxx` 警告，例如 `-Wunused-function`。它们可以捕获一些东西，但不是所有东西。每个这类警告的实例都应该被处理。通常只需删除代码，重新构建和重新运行测试即可完成。在罕见情况下，这可能是一个调用了错误函数的 bug 的症状。所以我会对完全自动化这一步骤有些犹豫。但如果你对自己的测试套件有信心，可以尝试一下。

+   Linters 可以找到未使用的函数或类字段，例如 `cppcheck`。根据我的经验，特别是在继承中涉及虚函数时，这些工具可能会有相当多的误报，但好处是这些工具能够绝对找出编译器未注意到的未使用的东西。因此，如果没有添加到 CI（稍后再说），向你的工具箱添加 linter 是一个很好的借口。

+   我见过更奇特的技术，其中链接器被指示将每个函数放在自己的部分，并在链接时打印每次删除部分时发生的事情，因为检测到该部分在链接时未使用，但这会导致很多关于未使用标准库函数的噪音，所以我认为这并不实用。其他人检查生成的汇编代码并比较哪些函数存在于源代码中，但对虚函数无效。所以，也许可以试试，根据你的情况而定？

+   还记得支持的平台列表吗？是的，现在是时候利用它来删除所有不支持平台的代码了。试图支持古老 Solaris 版本的代码，而项目专门在 FreeBSD 上运行？抛出窗外吧。试图提供自己的随机数生成器，因为也许我们运行的平台没有一个（当然，后来证明从未出现这种情况）？扔进垃圾桶。在我们仅运行在现代 Linux 和 macOS 上时，检查是否支持 POSIX 2001 的代码？抹掉它。检查主机 CPU 是否为大端序并在是的情况下交换字节的代码？再见了（你最后一次为大端序 CPU 发布代码是什么时候？如果是，你是如何找到 IBM 的？）。多年前为一个从未实现的假设功能引入的代码？告别了。

这样做的额外好处不仅仅是将编译时间加速了 5 倍而没有任何不利因素，而且，如果你的老板有一点技术背景，他们会喜欢看到删除数千行代码的 PR。你的同事们也是如此。

## Linters

不要对代码检查器规则过于苛刻，添加一些基本规则，将它们整合到开发生命周期中，逐步调整规则并修复出现的问题，然后继续前进。不要试图启用所有规则，这只是一个收益递减的兔子洞。过去我使用过`clang-tidy`和`cppcheck`，它们可能会有所帮助，但也可能非常慢且嘈杂，所以请注意。然而，没有代码检查器不是一个选择。第一次运行代码检查器时，它将捕获到许多真实问题，让你想知道为什么即使开启了所有警告，编译器也检测不到任何问题。

## 代码格式化

等待没有活跃分支的合适时机（否则人们将面临可怕的合并冲突），随机选择一种代码风格，对整个代码库进行一次性格式化（没有例外），通常使用`clang-format`，提交配置，完成。不要浪费口水争论实际的代码格式化。它只存在于减小差异和避免争论，所以不要为此争论！

## [消毒剂](https://github.com/rxi/microui/pull/67)

与代码检查器一样，它可能是一条兔子洞，不幸的是，它绝对是必需的，以发现真正影响生产、难以检测的错误，并能够修复它们。`-fsanitize=address,undefined`是一个良好的基线。它们通常不会产生误报，因此如果检测到问题，立即修复它。运行测试以便在那里也发现问题。我甚至听说有人在生产环境中启用了一些消毒剂，所以如果你的性能预算允许的话，这可能是个好主意。

如果你（不得不）用于发布生产代码的编译器不支持消毒剂，至少在开发和运行测试时可以使用 clang 或类似的工具。这时，你在构建系统上的工作就派上了用场，使用不同的编译器应该相对容易。

有一点是肯定的：即使是世界上最好的代码库，拥有最佳的编码实践和开发者，一旦启用消毒剂，你绝对会发现多年来未被察觉的可怕的错误和内存泄漏。所以，请务必这样做。请注意，修复这些问题可能需要大量的工作和重构。每种消毒剂都有选项，所以如果你的项目很特别，检查它们可能会有用。

最后一件事：理想情况下，运行测试时，所有第三方依赖项也应该启用消毒剂来编译，以便发现其中的问题。

## 添加一个持续集成流水线

正如 Bryan Cantrill 曾经说过（从记忆中引用），“我确信大多数固件都是从开发者笔记本的主目录中出来的”。建立持续集成是快速、免费的，并自动化了我们迄今为止设置的所有好东西（代码检查器、代码格式化、测试等）。这样，我们可以在一个清洁的环境中，对每一次更改都生产出生产二进制文件。如果你作为开发者还没有这样做，我认为你还没有真正进入21世纪。

最后一笔：大多数持续集成系统允许在不同平台上运行步骤！因此你能明确验证支持的平台列表不仅仅是理论，而是实际存在的。

通常的构建流程看起来如 `make all test lint fmt` 等，基本不需要多大的技术挑战。然而应确保工具（如 Linters、安全检查器等）报告的问题能终止流程，否则无人关注和解决这些问题。

## 折腾代码的改进

这是已知领域，我不会在此多言。只是说很多代码往往可以大幅简化。

回忆起我曾迭代简化一个原本用于手动分配和（有时）回收内存的复杂类。这个类本意是处理通用事物的，结果发现类所做的只是分配一个指针，随后检查指针是否为 null，仅此而已。实际上这是布尔值。是真还是假，罢了。

我感觉到的难点在于时间规划，因为每一次简化都可能开启进一步简化的新途径。请凭直觉判断并保持保守态度。将安全、正确性及性能等具体目标放在首位，远离诸如“干净代码”的主观评价标准。

据我经验，升级项目使用的C++标准有时可以帮助简化代码。例如用 `for (auto x : items)` 循环替代手动迭代计数代码。但记住，这只是一条达到目标的途径，而非目标本身。假如你只需 `std::clamp` ，不妨自己写。

## 转为使用内存安全语言？

我目前在工作上正这样做，这值得单独写篇文章。内有诸多陷阱。仅在有足够理由的情况下才进行。

## 结论

好吧，这就是答案。一项可以实际执行、步步推进的计划，旨在应对复杂的遗留C++代码库引发的棘手问题。我在项目中刚完成了这个计划，现在处理起来更人性化了。原本不接触代码库的同事，现在也能贡献有意义的成果。所以真的感觉很棒。

有重要的话题我想提及，但最终未能包含，例如本地调试器运行代码的必要性、Fuzzing、漏洞扫描等。或许下篇文章可以讨论这些。

如若在某个项目上进行这种简化，并且觉得这篇文章有帮助，请发封邮件给我。知道这文章能帮助人真的很令人欣慰。

## 补充：依赖管理

*此部分观点极具主观性，仅为我的强烈偏见。*

有一个备受争议的主题，我迄今为止都尽量避免谈及，那就是依赖管理。总之，C++中缺乏系统辅助。大多数人都转向使用系统包管理器。这在 README 文件中很容易发现：

```
On Ubuntu 20.04: `sudo apt install [100 lines of packages]`

On macOS: `brew install [100 lines of packages named slightly differently]`

Any other: well you're out of luck buddy. I guess you'll have to pick a mainstream OS and reinstall ¯\_(ツ)_/¯
```

等等。我自己就实施过。我认为这是一个糟糕的想法。原因如下：

+   安装说明，正如我们上面所看到的，依赖于操作系统和发行版。更糟糕的是，它们还依赖于发行版的版本。我记得一个项目，从Ubuntu 20.04迁移到Ubuntu 22.04花了几个月，因为它们提供了不同版本的软件包（如果它们提供相同的软件包的话），所以升级发行版也意味着同时升级你项目的100个依赖项。显然这是一个非常糟糕的主意。你希望一次只升级一个依赖项，理想情况下。

+   总是有第三方依赖项没有软件包，你不得不从源代码构建它。

+   软件包从不以你想要的标志进行构建。Fedora和Ubuntu已经争论了多年是否启用帧指针（最近他们终于这么做了）。还记得关于消毒剂的部分吗？你怎么能得到启用了消毒剂的依赖项？不可能的。但是还有更多例子：LTO、-march、调试信息等。或者它们是用与你使用的不同的C++编译器版本构建的，并且它们在两者之间破坏了C++ ABI。

+   你希望在审计、开发、调试等情况下轻松地查看依赖项的源代码，*当前正在使用的版本*。

+   你希望能够轻松地修补一个依赖项的bug，并且不需要大幅改变构建系统就能重新构建

+   你永远无法在系统间获得完全相同的软件包版本，例如，开发者Alice使用macOS，Bob使用Ubuntu，生产系统使用FreeBSD。所以你会遇到无法复现的奇怪差异，这很烦人。

+   上述点的推论：你不知道你在系统上使用的确切版本（多个版本），而且很难以自动化方式生成一个物料清单（BOM），某些领域要求这样做（或者很快会要求？无论如何，这是一个好主意）。

+   有时软件包没有你需要的库的版本（静态或动态）

所以你可能会想，我知道了，我将使用那些新潮的C++包管理器，如Conan、vcpkg之类的！不过，不要那么急：

+   它们需要外部依赖项，因此你的CI变得更加复杂和慢（例如，弄清楚它们需要哪个确切版本的Python，这肯定会与你的项目所需的Python版本不同）

+   它们并没有所有版本的一个软件包。例如：[Conan和mbedtls](https://conan.io/center/recipes/mbedtls)，它从版本`2.16.12`跳到`2.23.0`。中间的版本发生了什么？它们有缺陷不能使用吗？谁知道！安全漏洞根本就没有列出来！当然，我以前有一个项目，我必须使用版本`2.17`……

+   它们可能不支持一些你关心的操作系统或架构（FreeBSD、ARM等）

我的意思是，如果你的情况适用，那太好了，这绝对比在我的想法中使用系统包要好。只是到目前为止，我从未遇到过能够使用它们的项目 - 总是有一些阻碍。

那么我推荐什么呢？好吧，就是那种传统的git子模块和从源代码编译的方法。确实有些麻烦，但也有：

+   它非常简单易用

+   它比手动维护更好，因为git具有历史记录和差异功能

+   你可以确切地知道，从提交到使用的依赖项版本都是哪个

+   升级单个依赖项的版本非常简单，只需运行`git checkout`

+   它适用于每个平台

+   你可以完全自定义编译标志、编译器等来构建所有依赖项。甚至可以为每个依赖项进行定制！

+   开发者即使没有C++经验也已经了解它

+   获取依赖项是安全的，远程源在git中。没有人会偷偷改变它。

+   它递归地工作（即：对依赖项的依赖项也是如此）

在每个子模块中编译每个依赖项可以像使用CMake的`add_subdirectory`那样简单，或者手动使用`git submodule foreach make`。

如果子模块真的不是一个选择，一个替代方法是仍然从源代码编译，但是手动进行，使用一个脚本，该脚本获取每个依赖项并构建它。现实中的例子：Neovim。

当然，如果你的依赖图在Graphviz中看起来像Rorschach测试，并且必须构建成千上万个依赖项，那么这并不容易实现，但仍然可能，使用像Buck2这样的构建系统，它进行混合本地-远程构建，并在不同用户的构建之间重用构建产物。

如果你看看编译语言（如Go、Rust等）的包管理器格局，我所知道的所有都是从源代码编译。这是相同的方法，减去git，加上自动化。

## 附录：读者的建议

我从读者那里收集了一些很棒的想法和反馈（有时是来自不同人的多条评论的综合，我是凭记忆在改编，如果不完全准确，还请谅解）：

+   *你应该更加重视测试（扩展测试套件、代码覆盖率等）- 但同时：在C++中的测试套件只有在使用sanitizer时才有价值，否则你会陷入一种虚假的安全感。* 百分之百同意。在没有测试支持的复杂外部代码中进行修改，在我看来根本不可能。而且，sanitizer会在测试中捕获到很多问题，你甚至应该考虑在CI中多次运行测试套件，启用不同的sanitizer。

+   *vcpkg是一个解决所有问题的好的C++依赖管理器。* 我从未有机会使用它，所以我会把它加入我的工具箱进行实验。如果它符合我列出的要求，并且支持跨平台编译，那么它绝对胜过git子模块。

+   *Nix 可以作为 C++ 的良好依赖管理器*。我必须承认，我被 Nix 的复杂性和缓慢击败了。也许几年后当它成熟了再说？

+   *如果你每年只修复一个 bug，就不要投入太多时间重构老代码库*。有些同意，但这真的是个判断问题。根据我的经验，从来不只是一个 bug，无论管理层怎么说。像移除死代码、进行消毒等所有好事都对偶尔的 bug 修复有益，同时也会发现更多 bug 并修复它们。就像一个回复者所说的：“如果你打算拥有一个代码库，那就真正拥有它。”

+   *删除代码非常风险，通常你永远不知道它是否被使用，以及是否有人依赖于这个确切的行为在实际中*。没错，这就是为什么我主张使用静态分析工具删除从未调用的代码，这样你就可以*确切*知道。但是，如果有疑问，还是不要删除为好。我在这里的急躁是虚拟方法，这些方法很难通过静态分析删除（因为整个目的是在运行时选择要调用的确切方法），这些方法通常不能轻易移除。此外，与销售人员、产品经理，甚至用户沟通。大多数时候，如果询问他们是否在使用特定功能或平台，你会迅速得到是或否的答复，然后就知道如何继续进行。我们工程师有时会忘记，与人们进行 15 分钟的交流可以简化那么多技术工作。

+   *将所有代码放在一个 LLM 中并开始向它提问*：作为一个反 LLM 的人，我必须承认从未想过这个主意。不过我认为如果可以在法律上安全的方式下完全本地化进行，并以谨慎的态度对待，这个想法可能值得一试。我真的很好奇看看它会得出什么答案！

+   *有工具可以分析代码并生成图表、类关系等，以便全面了解代码的概况*：我从未使用过这些工具，但这是个好主意，将来我一定会试试。

+   *步骤 0 应该是将代码添加到源代码控制系统中（如果还没有的话）*：当然。我很幸运从未遇到过这种情况，但是即便是最糟糕的源代码控制系统也比没有好。我说的是在曾经不得不使用 Visual Source Safe 后这么说的，这种系统修改文件意味着需要独占锁定它，然后还要手动释放。

+   *设置一个 CI 应该是第一步*：公平的观点，我完全理解这个角度。我在本地的速度更快，但公平。

+   *不要成为代码美女，只需做你需要的修复*：Amen.

+   *如果你可以放弃一个几乎不使用的平台以减少组合复杂性，并且这使你能够做出重大简化，那就去做吧*：完全正确。与你的销售人员和利益相关者交流，试图说服他们。在我的案例中，那些长期不再支持的古老FreeBSD版本，我想我们利用安全角度说服了每个人放弃它们。

+   *可重现构建*：这个话题被提了出来，并引起了激烈的辩论。老实说，我认为在典型的C++代码库中实现完全可重现的构建是不现实的。仅仅是编译器和标准库的版本就是一个问题，因为它们通常不被视为构建输入的一部分。但是实现可靠的构建绝对是现实的。在这个话题上提到了Docker。自2013年以来，我一直在愤怒地使用Docker，我认为它没有人们普遍认为的那么有价值。但再次强调 - 如果你能让代码在Docker中编译通过，总比什么都不做要好。

+   *Git可以被指示忽略一个提交，例如整个代码库格式化的提交，以便git blame仍然有效，历史记录仍然有意义*：这是我以前不知道的绝佳建议，所以谢谢！我一定会尝试的。

+   *使用VCS统计历史记录来识别代码库中变动最大的部分，以及通常一起更改的部分*：我从未尝试过这个方法，这是一个有趣的想法，但我也看到很多注意事项。也许值得一试？

+   *这篇文章不仅适用于C++，还适用于其他语言的遗留代码库*：谢谢！我在C++方面有最多的经验，所以那是我的观点，但我很高兴听到这一点。只需跳过与C++特定相关的部分，如代码检查器。

+   *《与遗留代码有效地工作》这本书提供了很好的建议*：我不认为我曾经从头到尾地读过它，所以谢谢你的推荐。我记得我只是粗略地浏览了一下，发现它非常依赖面向对象，有很多面向对象的设计模式，那时对我来说并不有帮助，但我的记忆有些模糊了。

+   *一般情况下，尽量少触及，专注于增加价值（实际价值，比如销售额）*：我基本同意（参见观点：不要成为美人鱼），但在典型的大型C++代码库中，一旦你从安全的角度审视它，你会发现大量的安全漏洞需要修复。这并不会带来财务收益 - 它是在降低风险。而我觉得这非常有价值。尽管如此，某些领域比其他领域更敏感。

> 如果你喜欢这篇文章并且愿意支持我，并且负担得起的话：[捐赠](https://paypal.me/philigaultier?country.x=DE&locale.x=en_US)
