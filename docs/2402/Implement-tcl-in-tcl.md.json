["```\n # Lct - A Tcl-like language implemented in Tcl\n # The implementation does NOT try to exploit the fact we\n # are implementing Tcl in Tcl exposing some Tcl built-in\n # to make the work simpler, thus this implementation is\n # quite portable. It should be quite easy to port it\n # to Python, PHP, Perl, Scheme and alike.\n #\n # Copyright (C) 2003 Salvatore Sanfilippo\n #\n # Biggest differences with Tcl:\n #\n # A lot of course, but this are important stuff you should\n # know before to try even some trivial example:\n #\n # - No 'expr' support, this also changes if/for/while semantic:\n #   What in Tcl is \"if {$a > $b} ...\" here is \"if {> $a $b} ...\" and so on.\n #   Math is done lispwise using +, -, *, / commands and so on.\n #   Note that conditionals doesn't perform substitution also, so\n #   There is no need of [] in most cases, but you need to use\n #   the \"pass\" identity function to test for a variable, like:\n #   if {pass $test} {...} elseif {...} else {...}\n # - No arrays for now\n # - No namespaces\n # - False is both zero and an empty string, no implicit expr in\n #   conditionals means to face the need to handle any kind of return\n #   string as false or true.\n # - True is just what's not false ;) any string that isn't \"0\" nor \"\".\n # - The 'pass' command is the \"identity\" command returning it's only argument.\n #   pass foobar ;# => foobar\n # - Unbalanced {} in comments are not a problem (but you need to quote\n #   anyway if your Lct program body is defined inside a Tcl script).\n #\n # TODO:\n #\n # - variable number of arguments to procedures\n # - exceptions, i.e. [catch]\n # - upvar\n # - break/for\n # - uproc foo args body, foo will be executed in the caller context\n # - set x(foo), $x(foo) as syntax glue for some \"dict set\" \"dict get\" command\n # - be able to save the continuation may be cool, but this interpreter\n #   calls itself from Tcl, so I will remove the recursion or figure how\n #   to reenter the recursion starting from state-information.\n # - handle line numbers in the parser to specify error's line number\n # - check for raised error condition in LctEval to exit with an error\n\n ################################################################################\n #                                 Lct Core\n ################################################################################\n\n # Interpreter state is implemented as global vars and arrays\n # no support for multiple interpreters (for now at least).\n array set ::LctCommands {}\n array set ::LctProcs {}\n set ::LctStack {}\n set ::LctError {}\n set ::LctStackLen 0\n\n proc LctAddStackFrame {} {\n     incr ::LctStackLen\n     namespace eval StackFrame$::LctStackLen {\n        variable EvalLevel 0\n        array set Locals {}\n        array set Globals {}\n     }\n }\n\n proc LctRemoveStackFrame {} {\n     namespace delete StackFrame$::LctStackLen\n     incr ::LctStackLen -1\n }\n\n proc LctSaveStackFrame varname {\n     upvar $varname saved\n     set sf $::LctStackLen\n     set saved {}\n     lappend saved [array get StackFrame$sf\\::Locals]\n     lappend saved [array get StackFrame$sf\\::Globals]\n     lappend saved [set StackFrame$sf\\::EvalLevel]\n }\n\n proc LctRestoreStackFrame varname {\n     upvar $varname saved\n     set sf $::LctStackLen\n     namespace eval StackFrame$sf {}\n     array set StackFrame$sf\\::Locals [lindex $saved 0]\n     array set StackFrame$sf\\::Globals [lindex $saved 1]\n     set StackFrame$sf\\::EvalLevel [lindex $saved 2]\n }\n\n # Create the top-level stack frame\n LctAddStackFrame\n\n # The parser is the core of the interpreter, being this\n # interpreted from the source code directly. No compilation.\n proc LctParser {text tokenvar indexvar {dosubst 0}} {\n     upvar $tokenvar token\n     upvar $indexvar i\n     set token {}\n     set inside {}\n     set dontstop $dosubst\n     while 1 {\n        # skip spaces\n        while {!$dontstop && [string match \"\\[ \\t\\]\" [string index $text $i]]} {\n            incr i\n        }\n        # skip comments\n        if {!$dontstop && [string equal [string index $text $i] #]} {\n            while {[string length [string index $text $i]] &&\n                  ![string match [string index $text $i] \\n]} \\\n            {\n                incr i\n            }\n        }\n        # check for special conditions\n        if {!$dontstop} {\n            switch -exact -- [string index $text $i] {\n                {} {return EOF}\n                {;} -\n                \"\\n\" {incr i; return EOL}\n            }\n        }\n        # main parser loop\n        while 1 {\n            switch -exact -- [string index $text $i] {\n                {} break\n                { } -\n                \"\\t\" -\n                \"\\n\" -\n                \";\" {\n                    if {!$dontstop} {\n                        break;\n                    }\n                }\n                \\\" {\n                    if {[string equal $inside {}]} {\n                        incr dontstop\n                        set inside \\\"\n                        incr i\n                        continue\n                    } elseif {[string equal $inside \\\"]} {\n                        incr dontstop -1\n                        set inside {}\n                        incr i\n                        continue\n                    }\n                }\n                \"\\{\" {\n                    if {[string equal $inside {}]} {\n                        incr dontstop\n                        set inside \"\\{\"\n                        incr i\n                        continue\n                    } elseif {[string equal $inside \"\\{\"]} {\n                        incr dontstop\n                    }\n                }\n                \"\\}\" {\n                    if {[string equal $inside \"\\{\"]} {\n                        incr dontstop -1\n                        if {$dontstop == 0} {\n                            set inside {}\n                            incr i\n                            continue\n                        }\n                    }\n                }\n                \\$ {\n                    if {![string equal $inside \"\\{\"]} {\n                        if {![string equal [string index $text [expr {$i+1}]] $]} {\n                            set res [LctSubstVar $text $indexvar]\n                            append token $res\n                            continue\n                        }\n                    }\n                }\n                \\[ {\n                    if {![string equal $inside \"\\{\"]} {\n                        set res [LctSubstCmd $text $indexvar]\n                        append token $res\n                        continue\n                    }\n                }\n            }\n            append token [string index $text $i]\n            incr i\n        }\n        return TOK\n     }\n }\n\n proc LctSubstCmd {text indexvar} {\n     upvar $indexvar i\n     set go 1\n     set cmd {}\n     incr i\n     while {$go} {\n        switch -exact -- [string index $text $i] {\n            {} break\n            \\[ {incr go}\n            \\] {incr go -1}\n        }\n        append cmd [string index $text $i]\n        incr i\n     }\n     set cmd [string range $cmd 0 end-1]\n     return [LctEval $cmd]\n }\n\n # Get the control when a '$' (not followed by $) is encountered,\n # extract the name of the variable, and return its content.\n proc LctSubstVar {text indexvar} {\n     upvar $indexvar i\n     set dontstop 0\n     set varname {}\n     incr i\n     while {1} {\n        switch -exact -- [string index $text $i] {\n            \\[ -\n            \\] -\n            \"\\t\" -\n            \"\\n\" -\n            \"\\\"\" -\n            \\; -\n            \\{ -\n            \\} -\n            \\$ -\n            ( -\n            ) -\n            { } -\n            {} {\n                if {!$dontstop} {\n                    break\n                }\n            }\n            ( {incr dontstop}\n            ) {incr dontstop -1}\n            default {\n                append varname [string index $text $i]\n            }\n        }\n        incr i\n     }\n     if {![LctLookupVar $varname content]} {\n        error \"No such variable '$varname'\"\n     } else {\n        return $content\n     }\n }\n\n proc LctLookupVar {varname contentvar} {\n     set sf $::LctStackLen\n     upvar $contentvar content\n     if {[info exists StackFrame$sf\\::Globals($varname)]} {\n        set sf 1\n     }\n     if {![info exists StackFrame$sf\\::Locals($varname)]} {\n        return 0\n     }\n     set content [set StackFrame$sf\\::Locals($varname)]\n     return 1\n }\n\n proc LctGetEvalLevel {} {\n     return [set StackFrame$::LctStackLen\\::EvalLevel]\n }\n\n proc LctSetEvalLevel newlevel {\n     set StackFrame$::LctStackLen\\::EvalLevel $newlevel\n }\n\n proc LctEval script {\n     set result {}\n     set eof 0\n     set i 0\n\n     set level [LctSetEvalLevel [expr {[LctGetEvalLevel]+1}]]\n     while {!$eof && ([LctGetEvalLevel] >= $level)} {\n        set argv {}\n        set argc 0\n        while 1 {\n            set state [LctParser $script token i]\n            if {[string equal $state EOF]} {\n                set eof 1\n            }\n            switch $state {\n                EOF -\n                EOL break\n                default {\n                    lappend argv $token\n                    incr argc\n                }\n            }\n        }\n        if {$argc} {\n            set cmd [lindex $argv 0]\n            if {![info exists ::LctCommands($cmd)]} {\n                error \"No such command '$cmd'\"\n            } else {\n                set result [$::LctCommands($cmd) $argv]\n                if {[string length $::LctError]} {error \"$::LctError\\n  in script:\\n$script\"}\n            }\n        }\n     }\n     if {$level == [LctGetEvalLevel]} {\n        LctSetEvalLevel [expr {[LctGetEvalLevel]-1}]\n     }\n     return $result\n }\n\n proc LctUplevel {level script result} {\n     upvar $result res\n     if {$::LctStackLen <= $level} {\n        LctSetError \"Bad Level\"\n        return\n     }\n     LctSaveStackFrame stackframe\n     incr ::LctStackLen -$level\n     set res [LctEval $script]\n     incr ::LctStackLen $level\n     LctRestoreStackFrame stackframe\n     return $res\n }\n\n # Do substitution of commands and vars\n proc LctSubst string {\n     set i 0\n     set s [LctParser $string token i 1]\n     return $token\n }\n\n proc LctRegisterCommand {name function} {\n     set ::LctCommands($name) $function\n }\n\n proc LctSetVar {varname value} {\n     set sf $::LctStackLen\n     if {[info exists StackFrame$sf\\::Globals($varname)]} {\n        set sf 1\n     }\n     return [set StackFrame$sf\\::Locals($varname) $value]\n }\n\n proc LctMarkGlobal varname {\n     set sf $::LctStackLen\n     set StackFrame$sf\\::Globals($varname) {}\n }\n\n proc LctSetError error {\n     set ::LctError $error\n }\n\n # In Lct both 0 and empty string is false.\n proc LctIsFalse value {\n     if {[string equal $value 0] || [string equal $value {}]} {\n        return 1\n     } else {\n        return 0\n     }\n }\n\n # Define it as the negation of LctIsFalse\n proc LctIsTrue value {\n     return [expr {![LctIsFalse $value]}]\n }\n\n ################################################################################\n #                                Core Commands\n ################################################################################\n\n proc LctSet argv {\n     if {[llength $argv] != 3} {\n        LctSetError \"Bad number of arguments, try: set varname value\"\n        return\n     }\n     return [LctSetVar [lindex $argv 1] [lindex $argv 2]]\n }\n\n proc LctPut argv {\n     set nonewline 0\n     if {[llength $argv] >= 2 && [string match [lindex $argv 1] -nonewline]} {\n        set nonewline 1\n        set argv [lrange $argv 1 end]\n     }\n     if {[llength $argv] != 2} {\n        LctSetError \"Bad number of arguments, try: put string\"\n        return\n     }\n     puts -nonewline stdout [lindex $argv 1]\n     if {!$nonewline} {\n        puts {}\n     }\n     return {}\n }\n\n # That's a generic binding for math stuff. It uses expr, and\n # 'sens' what operator to use from the name of the procedure itself.\n proc LctGenericMathOp argv {\n     if {[llength $argv] != 3} {\n        LctSetError \"Bad number of arguments, try: + number number\"\n        return\n     }\n     set e [lindex $argv 1][lindex $argv 0][lindex $argv 2]\n     set e [string map \"\\[ \\\\\\[ \\] \\\\\\]\" $e]\n     return [expr $e]\n }\n\n proc LctIncr argv {\n     if {[llength $argv] != 2 && [llength $argv] != 3} {\n        LctSetError \"Bad number of arguments, try: incr varname ?increment?\"\n        return\n     }\n     set varname [lindex $argv 1]\n     if {[llength $argv] == 3} {\n        set increment [lindex $argv 2]\n     } else {\n        set increment 1\n     }\n     if {![LctLookupVar $varname val]} {\n        LctSetError \"No such var '$varname'\"\n        return\n     }\n     if {[catch {expr {$val+$increment}} result]} {\n        LctSetError \"Expected integer, got something else ($result)\"\n        return\n     }\n     return [LctSetVar $varname $result]\n }\n\n proc LctProc argv {\n     if {[llength $argv] != 4} {\n        LctSetError \"Bad number of arguments, try: proc name args body\"\n        return\n     }\n     LctRegisterCommand [lindex $argv 1] LctCallProc\n     set ::LctProcs([lindex $argv 1]) [list [lindex $argv 2] [lindex $argv 3]]\n     return {}\n }\n\n # This built-in is used to call user-defined procedures\n # It checks for argv(0} in order to get the name of the\n # procedure to call, then create a new stack frame and call it.\n proc LctCallProc argv {\n     foreach {arglist body} $::LctProcs([lindex $argv 0]) break\n     if {[llength $argv]-1 != [llength $arglist]} {\n        LctSetError \"Wrong number of args calling procedure '[lindex $argv 0]'\"\n        return\n     }\n     set l [llength $arglist]\n     LctAddStackFrame\n     for {set i 0} {$i < $l} {incr i} {\n        LctSetVar [lindex $arglist $i] [lindex $argv [expr {$i+1}]]\n     }\n     set result [LctEval $body]\n     LctRemoveStackFrame\n     return $result\n }\n\n # Return is simple, we set the stack frame's EvalLevel to 0 in order\n # to be sure eval will return to the previous procedure.\n proc LctReturn argv {\n     if {[llength $argv] != 1 && [llength $argv] != 2} {\n        LctSetError \"Bad number of arguments, try: return ?value?\"\n        return\n     }\n     LctSetEvalLevel 0\n     if {[llength $argv] == 2} {\n        return [lindex $argv 1]\n     } else {\n        return {}\n     }\n }\n\n # Facility to pop arguments in varargs proc.\n proc LctPopArg varname {\n     upvar $varname argv\n     set arg [lindex $argv 0]\n     set argv [lreplace $argv 0 0]\n     return $arg\n }\n\n # The if command implemented as trivial FSA.\n proc LctIf argv {\n     set argv [lreplace $argv 0 0] ;# Drop the 'if' first argument.\n     set state EXPR\n     while {[llength $argv]} {\n        switch -exact $state {\n            EXPR {\n                set e [LctPopArg argv]\n                set res [LctIsTrue [LctEval $e]]\n                if {$res} {\n                    set state EVAL_NEXT\n                } else {\n                    set state SKIP_TRUE_BRANCH\n                }\n            }\n            EVAL_NEXT {\n                set script [LctPopArg argv]\n                return [LctEval $script]\n            }\n            SKIP_TRUE_BRANCH {\n                LctPopArg argv ;# Just skip it\n                set state ELSE_OR_ELSEIF_OR_FALSE_BRANCH\n            }\n            ELSE_OR_ELSEIF_OR_FALSE_BRANCH {\n                set x [LctPopArg argv]\n                if {[string equal $x else]} {\n                    set state EVAL_NEXT\n                } elseif {[string equal $x elseif]} {\n                    set state EXPR\n                } else {\n                    return [LctEval $x]\n                }\n            }\n        }\n     }\n     switch -exact $state {\n        EXPR {\n            LctSetError \"Missing expression in if\"\n            return\n        }\n        EVAL_NEXT {\n            LctSetError \"Missing script in if\"\n            return\n        }\n     }\n }\n\n proc LctWhile argv {\n     if {[llength $argv] != 3} {\n        LctSetError \"Bad number of arguments, try: while cond body\"\n        return\n     }\n     foreach {_ cond body} $argv break\n     while {[LctIsTrue [LctEval $cond]]} {\n        set result [LctEval $body]\n     }\n     return $result\n }\n\n proc LctPass argv {\n     if {[llength $argv] != 2} {\n        LctSetError \"Bad number of arguments, try: pass ?value?\"\n        return\n     }\n     return [lindex $argv 1]\n }\n\n proc LctEvalCmd argv {\n     set script {}\n     foreach x [lrange $argv 1 end] {append script $x}\n     return [LctEval $script]\n }\n\n proc LctUplevelCmd argv {\n     if {[llength $argv] < 2} {\n        LctSetError \"Bad number of arguments, try: uplevel ?level? arg ... ?arg?\"\n        return {}\n     }\n     foreach {- level script} $argv break\n     LctUplevel $level $script result\n     return $result\n }\n\n proc LctGlobalCmd argv {\n     set argv [lrange $argv 1 end]\n     foreach varname $argv {\n        LctMarkGlobal $varname\n     }\n     return {}\n }\n\n # Sort part of the core\n LctRegisterCommand proc LctCallProc\n LctRegisterCommand set LctSet\n LctRegisterCommand proc LctProc\n LctRegisterCommand return LctReturn\n LctRegisterCommand if LctIf\n LctRegisterCommand pass LctPass\n LctRegisterCommand while LctWhile\n LctRegisterCommand eval LctEvalCmd\n LctRegisterCommand uplevel LctUplevelCmd\n LctRegisterCommand global LctGlobalCmd\n\n # Random stuff that are really needed, but not part of the core itself.\n LctRegisterCommand puts LctPut\n LctRegisterCommand + LctGenericMathOp\n LctRegisterCommand - LctGenericMathOp\n LctRegisterCommand * LctGenericMathOp\n LctRegisterCommand / LctGenericMathOp\n LctRegisterCommand % LctGenericMathOp\n LctRegisterCommand > LctGenericMathOp\n LctRegisterCommand >= LctGenericMathOp\n LctRegisterCommand < LctGenericMathOp\n LctRegisterCommand =< LctGenericMathOp\n LctRegisterCommand == LctGenericMathOp\n LctRegisterCommand != LctGenericMathOp\n LctRegisterCommand incr LctIncr\n\n ################################################################################\n #                                   Example\n ################################################################################\n\n set text {\n     # Test for comment\n     # Test basic substitution\n     set name \"All The Tclers\"\n     puts \"Hello to $name [+ 1 2] [+ 10 20]\"\n     puts \"(6*3)+(8*2)=[+ [* 6 3] [* 8 2]]\"\n     # Test procedures\n     proc test a {\n        puts \"I'm printing $a\"\n     }\n     test \"Hello World\"\n     # Test return from procedure without value\n     proc testreturn {} {\n        puts \"Test Return\"\n        return\n        puts \"FooBar\"\n     }\n     testreturn\n     testreturn\n     # Test return with value\n     proc testreturn2 x {\n        return $x$x\n     }\n     puts \"Return With Value: [testreturn2 XyZ]\"\n     # Test conditionals\n     set a 1\n     if {pass $a} {puts \"($a) is true\"} else {puts \"($a) is false\"}\n     set a 0\n     if {pass $a} {puts \"($a) is true\"} else {puts \"($a) is false\"}\n     set a foobar\n     if {pass $a} {puts \"($a) is true\"} else {puts \"($a) is false\"}\n     set a {}\n     if {pass $a} {puts \"($a) is true\"} else {puts \"($a) is false\"}\n     # Test incr\n     set x 10\n     puts \"Now it is $x\"\n     incr x\n     puts \"Now it is $x\"\n     incr x -2\n     puts \"Now it is $x\"\n     # Test Loops\n     while {< $x 20} {\n        incr x 1\n        puts \"Hello World $x\"\n     }\n     set script {puts -nonewline we;}\n     eval $script {puts \" are inside eval\"}\n     # Test global\n     proc testglobal {} {\n        global x\n        puts \"x is global, value: $x\"\n        set x 30\n        puts \"x value changed, will print the new value outside the proc\"\n     }\n     testglobal\n     puts \"x new value is $x\"\n     # Test uplevel\n     proc testuplevel {} {\n        puts ---\n        uplevel 1 {puts \"testglobal was called from uplevel: [testglobal]\"}\n        uplevel 1 {puts \"In uplevel, x = $x\"}\n     }\n     testuplevel\n }\n\n LctEval $text\n```", "```\n   set {]} t\n   set a [list ${]} ]\n   set {\"} t\n   set a \"a ${\"} \"\n   set a \"ewe [list \"sewe\"] ewr\"\n```", "```\n   set a [list ${]} ]\n```", "```\n   set a x{$a}x\n```"]