- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 13:21:15'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Robust generic functions on slices - The Go Programming Language
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://go.dev/blog/generic-slice-functions](https://go.dev/blog/generic-slice-functions)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Robust generic functions on slices
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valentin Deleplace
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: 22 February 2024
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: The [slices](/pkg/slices) package provides functions that work for slices of
    any type. In this blog post we’ll discuss how you can use these functions more
    effectively by understanding how slices are represented in memory and how that
    affects the garbage collector, and we’ll cover how we recently adjusted these
    functions to make them less surprising.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: 'With [Type parameters](/blog/deconstructing-type-parameters) we can write functions
    like [slices.Index](/pkg/slices#Index) once for all types of slices of comparable
    elements:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-11
  prefs: []
  type: TYPE_PRE
- en: It is no longer necessary to implement `Index` again for each different type
    of element.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The [slices](/pkg/slices) package contains many such helpers to perform common
    operations on slices:'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-14
  prefs: []
  type: TYPE_PRE
- en: Several new functions (`Insert`, `Replace`, `Delete`, etc.) modify the slice.
    To understand how they work, and how to properly use them, we need to examine
    the underlying structure of slices.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: A slice is a view of a portion of an array. [Internally](/blog/slices-intro),
    a slice contains a pointer, a length, and a capacity. Two slices can have the
    same underlying array, and can view overlapping portions.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this slice `s` is a view on 4 elements of an array of size 6:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: If a function changes the length of a slice passed as a parameter, then it needs
    to return a new slice to the caller. The underlying array may remain the same
    if it doesn’t have to grow. This explains why [append](/blog/slices) and `slices.Compact`
    return a value, but `slices.Sort`, which merely reorders the elements, does not.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the task of deleting a portion of a slice. Prior to generics, the
    standard way to delete the portion `s[2:5]` from the slice `s` was to call the
    [append](/ref/spec#Appending_and_copying_slices) function to copy the end portion
    over the middle portion:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-20
  prefs: []
  type: TYPE_PRE
- en: 'The syntax was complex and error-prone, involving subslices and a variadic
    parameter. We added [slice.Delete](/pkg/slices#Delete) to make it easier to delete
    elements:'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
- en: 'The one-line function `Delete` more clearly expresses the programmer’s intent.
    Let’s consider a slice `s` of length 6 and capacity 8, containing pointers:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: 'This call deletes the elements at `s[2]`, `s[3]`, `s[4]` from the slice `s`:'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
- en: The gap at the indices 2, 3, 4 is filled by shifting the element `s[5]` to the
    left, and setting the new length to `3`.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: '`Delete` need not allocate a new array, as it shifts the elements in place.
    Like `append`, it returns a new slice. Many other functions in the `slices` package
    follow this pattern, including `Compact`, `CompactFunc`, `DeleteFunc`, `Grow`,
    `Insert`, and `Replace`.'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling these functions we must consider the original slice invalid, because
    the underlying array has been modified. It would be a mistake to call the function
    but ignore the return value:'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-29
  prefs: []
  type: TYPE_PRE
- en: A problem of unwanted liveness
  id: totrans-split-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before Go 1.22, `slices.Delete` didn’t modify the elements between the new and
    original lengths of the slice. While the returned slice wouldn’t include these
    elements, the “gap” created at the end of the original, now-invalidated slice
    continued to hold onto them. These elements could contain pointers to large objects
    (a 20MB image), and the garbage collector would not release the memory associated
    with these objects. This resulted in a memory leak that could lead to significant
    performance issues.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: In this above example, we’re successfully deleting the pointers `p2`, `p3`,
    `p4` from `s[2:5]`, by shifting one element to the left. But `p3` and `p4` are
    still present in the underlying array, beyond the new length of `s`. The garbage
    collector won’t reclaim them. Less obviously, `p5` is not one of the deleted elements,
    but its memory may still leak because of the `p5` pointer kept in the gray part
    of the array.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: This could be confusing for developers, if they were not aware that “invisible”
    elements were still using memory.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: 'So we had two options:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: Either keep the efficient implementation of `Delete`. Let users set obsolete
    pointers to `nil` themselves, if they want to make sure the values pointed to
    can be freed.
  id: totrans-split-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or change `Delete` to always set the obsolete elements to zero. This is extra
    work, making `Delete` slightly less efficient. Zeroing pointers (setting them
    to `nil`) enables the garbage collection of the objects, when they become otherwise
    unreachable.
  id: totrans-split-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was not obvious which option was best. The first one provided performance
    by default, and the second one provided memory frugality by default.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: The fix
  id: totrans-split-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key observation is that “setting the obsolete pointers to `nil`” is not as
    easy as it seems. In fact, this task is so error-prone that we should not put
    the burden on the user to write it. Out of pragmatism, we chose to modify the
    implementation of the five functions `Compact`, `CompactFunc`, `Delete`, `DeleteFunc`,
    `Replace` to “clear the tail”. As a nice side effect, the cognitive load is reduced
    and users now don’t need to worry about these memory leaks.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go 1.22, this is what the memory looks like after calling Delete:'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The code changed in the five functions uses the new built-in function [clear](/pkg/builtin#clear)
    (Go 1.21) to set the obsolete elements to the zero value of the element type of
    `s`:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: The zero value of `E` is `nil` when `E` is a type of pointer, slice, map, chan,
    or interface.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: Tests failing
  id: totrans-split-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This change has led to some tests that passed in Go 1.21 now failing in Go 1.22,
    when the slices functions are used incorrectly. This is good news. When you have
    a bug, tests should let you know.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ignore the return value of `Delete`:'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-46
  prefs: []
  type: TYPE_PRE
- en: then you may incorrectly assume that `s` does not contain any nil pointer. [Example
    in the Go Playground](/play/p/NDHuO8vINHv).
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ignore the return value of `Compact`:'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-49
  prefs: []
  type: TYPE_PRE
- en: then you may incorrectly assume that `s` is properly sorted and compacted. [Example](/play/p/eFQIekiwlnu).
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: 'If you assign the return value of `Delete` to another variable, and keep using
    the original slice:'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-52
  prefs: []
  type: TYPE_PRE
- en: then you may incorrectly assume that `s` does not contain any nil pointer. [Example](/play/p/rDxWmJpLOVO).
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: 'If you accidentally shadow the slice variable, and keep using the original
    slice:'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
- en: then you may incorrectly assume that `s` does not contain any nil pointer. [Example](/play/p/KSpVpkX8sOi).
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-split-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API of the `slices` package is a net improvement over the traditional pre-generics
    syntax to delete or insert elements.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: We encourage developers to use the new functions, while avoiding the “gotchas”
    listed above.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the recent changes in the implementation, a class of memory leaks
    is automatically avoided, without any change to the API, and with no extra work
    for the developers.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-split-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The signature of the functions in the `slices` package is heavily influenced
    by the specifics of the representation of slices in memory. We recommend reading
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: The [original proposal](/issue/63393) about zeroing obsolete elements contains
    many details and comments.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
