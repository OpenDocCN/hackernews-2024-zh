["```\nCREATE TABLE mytable (\n  mytable_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  data TEXT NOT NULL\n);\n\nCREATE TABLE mytable_history (\n  -- copy these fields, always keep them first\n  history_id UUID PRIMARY KEY,\n  systime TSTZRANGE NOT NULL CHECK (NOT ISEMPTY(systime)),\n\n  -- table fields, in the exact same order as in mytable\n  mytable_id UUID NOT NULL,\n  data TEXT NOT NULL\n);\n\nALTER TABLE mytable_history\n  ADD CONSTRAINT mytable_history_overlapping_excl\n  EXCLUDE USING GIST (mytable_id WITH =, systime WITH &&); \n```", "```\n--\n-- insert:\n--\n\nCREATE OR REPLACE FUNCTION copy_mytable_inserts_into_history()\n          RETURNS TRIGGER AS $$\n  INSERT INTO mytable_history\n    SELECT gen_random_uuid(), tstzrange(NOW(), NULL), NEW.*;\n  RETURN NEW;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER mytable_history_insert_trigger\nAFTER INSERT ON mytable\n    FOR EACH ROW\n    EXECUTE PROCEDURE copy_mytable_inserts_into_history();\n\n--\n-- update:\n--\n\nCREATE OR REPLACE FUNCTION copy_mytable_updates_into_history()\n          RETURNS TRIGGER AS $$\n  -- ignore changes inside the same tx\n  DELETE FROM mytable_history\n    WHERE mytable_id = NEW.mytable_id\n      AND lower(systime) = NOW()\n      AND upper_inf(systime);\n  -- close current row\n  -- (if any, may be deleted by previous line)\n  UPDATE mytable_history\n    SET systime = tstzrange(lower(systime), NOW())\n    WHERE mytable_id = NEW.mytable_id\n      AND systime @> NOW();\n  -- insert new row\n  INSERT INTO mytable_history\n    SELECT gen_random_uuid(), tstzrange(NOW(), NULL), NEW.*;\n  RETURN NEW;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER mytable_history_update_trigger\nAFTER UPDATE ON mytable\n    FOR EACH ROW\n    WHEN (OLD.* IS DISTINCT FROM NEW.*)\n    -- ^ to avoid updates on \"noop calls\", as best as possible\n    EXECUTE PROCEDURE copy_mytable_updates_into_history();\n\n--\n-- delete:\n--\n\nCREATE OR REPLACE FUNCTION copy_mytable_deletes_into_history()\n          RETURNS TRIGGER AS $$\n  -- close current row\n  -- note: updates and then deletes for same id\n  -- in same tx will fail\n  UPDATE mytable_history\n    SET systime = tstzrange(lower(systime), NOW())\n    WHERE mytable_id = OLD.mytable_id\n      AND systime @> NOW();\n  RETURN OLD;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER mytable_history_delete_trigger\nAFTER DELETE ON mytable\n    FOR EACH ROW\n    EXECUTE PROCEDURE copy_mytable_deletes_into_history(); \n```", "```\nINSERT INTO mytable_history\n  SELECT gen_random_uuid(), tstzrange(NOW(), NULL), NEW.*; \n```", "```\nINSERT INTO mytable_history\n  SELECT gen_random_uuid(), tstzrange(NOW(), NULL),\n         NEW.mytable_id, NEW.data; \n```", "```\nINSERT INTO mytable_history\n  (history_id, systime, mytable_id, data)\nSELECT gen_random_uuid(), tstzrange(NOW(), NULL),\n       NEW.mytable_id, NEW.data; \n```", "```\n-- ignore changes inside the same tx\nDELETE FROM mytable_history\n  WHERE mytable_id = NEW.mytable_id\n    AND lower(systime) = NOW()\n    AND upper_inf(systime);\n-- close current row\nUPDATE mytable_history\n  SET systime = tstzrange(lower(systime), NOW())\n  WHERE mytable_id = NEW.mytable_id\n    AND systime @> NOW();\n-- insert new row\nINSERT INTO mytable_history\n  SELECT gen_random_uuid(), tstzrange(NOW(), null), NEW.*; \n```", "```\n-- close current row\n-- note: updates and then deletes for same id\n-- in same tx will fail\nUPDATE mytable_history\n  SET systime = tstzrange(lower(systime), NOW())\n  WHERE mytable_id = OLD.mytable_id\n    AND systime @> NOW(); \n```", "```\nUPDATE mytable\n  SET deleted_by = ${deleted_by}\nWHERE mytable_id = ${mytable_id};\n\nDELETE FROM mytable\nWHERE mytable_id = ${mytable_id}; \n```", "```\nCREATE TABLE delete_log (\n  delete_log_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  table_name TEXT NOT NULL,\n  resource_id UUID NOT NULL,\n  deleted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  deleted_by UUID NOT NULL REFERENCES users(user_id)\n);\n\n-- then delete as follows\n\nINSERT INTO delete_log (table_name, resource_id, deleted_by)\nVALUES ('mytable', ${mytable_id}, ${deleted_by});\n\nDELETE FROM mytable\nWHERE mytable_id = ${mytable_id}; \n```", "```\nALTER TABLE mytable_history\n  ADD CONSTRAINT mytable_history_overlapping_excl\n  EXCLUDE USING GIST (mytable_id WITH =, systime WITH &&); \n```", "```\nBEGIN;\n\nDELETE FROM mytable\nWHERE company_id = ${company_id};\n\nINSERT INTO mytable (your, fields, here)\nSELECT h.your, h.field, h.here\nFROM mytable_history h\nWHERE h.company_id = ${company_id}\n  AND h.systime @> ${backup_time};\n\nCOMMIT; \n```", "```\nCREATE FUNCTION copy_updates_into_history() RETURNS TRIGGER AS $$\nDECLARE\n  history_table TEXT := quote_ident(tg_argv[0]);\n  id_field TEXT := quote_ident(tg_argv[1]);\nBEGIN\n  -- ignore changes inside the same tx\n  EXECUTE 'DELETE FROM ' || history_table ||\n    ' WHERE ' || id_field || ' = $1.' || id_field ||\n    ' AND lower(systime) = NOW()' ||\n    ' AND upper_inf(systime)' USING NEW;\n  -- close current row\n  -- (if any, may be deleted by previous line)\n  EXECUTE 'UPDATE ' || history_table ||\n    ' SET systime = tstzrange(lower(systime), NOW())'\n    ' WHERE ' || id_field || ' = $1.' || id_field ||\n    ' AND systime @> NOW()' USING NEW;\n  -- insert new row\n  EXECUTE 'INSERT INTO ' || history_table ||\n    ' SELECT gen_random_uuid(), tstzrange(NOW(), null), $1.*'\n    USING NEW;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql; \n```", "```\nCREATE TRIGGER mytable_history_update_trigger\nAFTER UPDATE ON mytable\n    FOR EACH ROW\n    WHEN (OLD.* IS DISTINCT FROM NEW.*)\n    -- ^ to avoid updates on \"noop calls\", as best as possible\n    EXECUTE PROCEDURE\n      copy_updates_into_history('mytable_history', 'mytable_id'); \n```"]