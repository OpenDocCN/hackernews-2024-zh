<!--yml

category: 未分类

date: 2024-05-27 14:33:32

-->

# 让 futures 成为 futures

> 来源：[https://without.boats/blog/let-futures-be-futures/](https://without.boats/blog/let-futures-be-futures/)

在2010年代初至中期，有一场语言复兴探索新的并发处理方式。在这场复兴的中心，开发出了一种用于实现并发操作的抽象化，称为“future”或“promise”抽象化，它代表了一个将来可能完成的工作单元，允许程序员使用它来操纵程序中的控制流。基于此，引入了称为“async/await”的语法糖，将 futures 转换为最常见的普通线性控制流。这种方法已经在许多主流语言中得到采用，这一系列发展在从业者中引起了争议。

在那段时间有两篇优秀的帖子，非常好地说明了争论的双方。我强烈推荐每篇帖子都全文阅读：

Eriksen 的帖子的论点是，futures 提供了一种与线程 fundamentally 不同的并发模型。线程提供了一个模型，其中所有操作都是“同步”进行的，因为程序的执行被建模为一堆函数调用，当它们需要等待并发执行的操作完成时会阻塞。相反地，通过将并发操作表示为异步完成的“futures”，futures 模型使得 Eriksen 引用的几个优势成为可能。以下是我认为特别有说服力的几点：

1.  执行异步操作的函数与“纯”函数的类型不同，因为它必须返回一个 future 而不仅仅是一个值。这种区别很有用，因为它可以让您知道函数是执行 IO 还是纯计算，对程序有深远的影响。

1.  因为它们创建了要执行的工作单元的直接表示，所以 futures 可以以多种方式进行组合，包括顺序和并发。阻塞函数调用只能按顺序组合，而不能启动新线程。

1.  因为 futures 可以并发组合，所以可以编写更直接表达发生逻辑的并发代码。可以编写抽象化的内容，代表并发模式，允许将业务逻辑从跨线程调度工作的机制中提取出来。Eriksen 提供了一些示例，比如一个 `flatMap` 操作符，在初始网络请求之后链接多个并发网络请求。

Nystrom 持相反的观点。他首先设想了一种所有函数都“着色”的语言，颜色为蓝色（BLUE）或红色（RED）。在他的想象语言中，两种颜色的函数之间的重要区别是红色（RED）函数只能从其他红色（RED）函数中调用。他假设这种区分为语言用户带来巨大的困惑，因为需要跟踪两种类型的不同函数很烦人。在他语言中，红色（RED）函数必须使用令人痛苦的繁复语法来调用。当然，他指的是一些在线性函数与异步函数之间的区别。Eriksen 引用为 futures 优势之一的“函数返回 futures 与零返回 futures”的差异，对 Nystrom 来说却是最薄弱的环节。

其中一些 Nystrom 的评论与异步 Rust 不相关。例如，他说如果您将颜色为一的函数误认为是另一种颜色的函数调用，则可能会发生可怕的事情：

> 调用函数时，需要使用与函数颜色对应的调用。如果出错&hellip;会发生糟糕的事情。将您童年的噩梦捞起，就像躲在床下的小丑，手中有蛇。它会跳出您的监视器，榨干您的玻璃体。

这在类型未指派语言（如 JavaScript）中可能是真实的，该语言具有[臭名昭著的荒谬](https://www.destroyallsoftware.com/talks/wat)语义，但在类型静态语言（如 Rust）中，您会获得编译器错误，您可以解决并继续前进。

他主要的观点之一是调用红色（RED）函数远比调用蓝色（BLUE）函数更加“痛苦”。正如 Nystrom 在后续的帖子中进一步阐述的那样，他指的是 2015 年 JavaScript 中常用的回调式 API，并说异步 - 等待语法解决了这个问题：

> [异步 - 等待] 让您以与同步调用相同的方式轻松执行异步调用，只需添加一个可爱的关键词。您可以将 await 调用嵌入到表达式中，将其用于异常处理代码中，将它们放在控制流中。

当然，他也会这么说，这是围绕“函数着色问题”争论的中心：

> *但&hellip;* 你仍然将世界分为两部分。这些异步函数更容易编写，但 *它们依然是异步函数*。
> 
> 您仍然有两种颜色。异步 - 等待解决了恼人的规则#4：它们使红色函数的调用与蓝色函数的调用几乎一样糟糕。但所有的其他规则仍然存在。

未来代表异步操作与同步操作有所不同。对于 Eriksen 来说，这提供了额外的优势，是 futures 的关键优点。对于 Nystrom 来说，这纯粹是调用返回 futures 的函数而不是阻塞的函数的额外障碍。

正如你可能期待的那样，如果你熟悉这个博客，我对Eriksen的立场非常坚定。所以对我来说并不容易发现，Nystrom的观点在像评论Hacker News的人群或在互联网上写愤怒、过于自信的 rant 文章的人中更受欢迎。几个月前，我写了一篇[文章](/blog/why-async-rust)，探讨了Rust如何在 futures 抽象和 async/await 语法的基础上发展的历史，以及后续的[文章](/blog/a-four-year-plan)描述了我希望在 async Rust 中添加的功能。

现在，我想退一步，重新审视 async Rust 的设计，考虑 futures 并发模型的实用性问题。在 async Rust 中，futures 的使用实际上给我们带来了什么？我希望我们可以想象一个世界，在这个世界中，使用 futures 的困难已经得到缓解或解决，而它们提供的额外功能不仅使 async Rust 的使用变得像非 async Rust 一样简单，而且实际上提供了一个*更好的*体验。

# 异步任务并不是伪线程。

通常将 futures 的好处解释给用户时，会涉及到性能改进：启动线程是昂贵的，而在它们之间切换也是昂贵的，因此能够在单个线程上多路复用许多并发操作，将允许您在机器上执行更多并发操作。与Eriksen一样，我认为这种关注“基于线程 IO”和“基于事件 IO”的性能二分法是一个红色假设。所有关于使用 futures 来结构化代码的好处，对于 Rust 也同样适用。

Eriksen在编写时考虑了使用 continuation-passing style 作为其未来抽象的基础的语言背景。正如我在关于 async Rust 历史的文章中所写的那样，这并不是 Rust 采取的方法。独特地，Rust 采用了一种基于反转续传基于方法的系统：而不是在完成时 future 调用一个继续函数，它们是通过外部轮询来完成的。为了理解这一点的相关性，我们需要退后一步来谈论“任务”。

当我提到任务时，并不仅仅是指“一个工作单元”。在 async Rust 中，“任务”是一个特定的艺术术语。异步工作的基本抽象是 future，这是一种实现[Future](https://doc.rust-lang.org/std/future/trait.Future.html) trait 的类型，通常通过 async 函数或 async 块实现。但是，为了执行任何异步代码，我们还需要使用“执行器”，它可以执行“任务”。通常情况下，这由“运行时”为我们提供，还提供了用于执行异步 IO 等其他类型的工具。最广泛使用的运行时是[tokio](https://tokio.rs)。

这些定义有点复杂。一个“任务”只是已在执行器上调度的任何 future。大多数执行器，如 tokio，可以同时运行多个任务。它们可能使用一个线程来完成，或者使用多个线程并在这些线程之间平衡任务（哪种方式更好一直是一些额外争议的主题）。能够同时运行多个任务的执行器通常会公开类似 `spawn` 的 API，用于“生成任务”。还存在其他执行器，一次只运行一个任务（如 [pollster](https://crates.io/crates/pollster)）：这些通常会公开类似 `block_on` 的 API。

所有任务都是 futures，但并非所有 futures 都是任务。当将 futures 传递给执行器以执行时，futures 就变成了任务。大多数情况下，一个任务将由许多较小的 futures 组合在一起：当在异步范围内等待一个 future 时，被等待的 future 的状态直接合并到异步范围评估的 future 中。通常情况下，你会做这样的操作比使用 spawn 要多得多，因此大多数 futures 并不是我所说的任务。但是在类型级别上，future 和任务之间没有区别：任何 future 都可以通过在执行器上运行来转变为任务。

在理解 futures 和 tasks 之间的区别时，重要的一点是：执行任务所需的所有状态将作为一个单独的对象分配，并且在内存中紧密排列在一起；任务中使用的每个单独的 future 不需要单独的分配。我们经常将这个状态机描述为任务的“完美大小的堆栈”；它恰好足够大，可以包含任务在 yield 时可能需要的所有状态。

（此设计的另一个影响是，不可能编写递归的异步函数而不显式地对递归调用进行封箱。这与不可能编写递归结构定义而不封箱递归嵌入类型的原因相同。）

这对于在异步 Rust 中表示并发操作有一些有趣的影响。我想引入一种区分任务模型中可以实现的两种并发类型的方法：*多任务并发*，其中并发操作被表示为单独的任务；以及*任务内并发*，其中一个单一任务同时执行多个操作。

## 多任务并发

如果希望两个操作同时进行，一种实现方法是为每个操作生成一个单独的任务。这就是“多任务并发”，通过使用多个并发任务实现的并发。

对许多用户来说，多任务并发是异步Rust中最易于接触的并发方式，因为它与基于线程的并发方式最为相似。就像在非异步Rust中可以为并发生成线程一样，在异步Rust中可以生成任务。这使得对于已经习惯于使用线程进行并发的用户来说非常熟悉。

一旦你有了多个异步任务，可能需要一些方法在它们之间传输信息。这种“任务间通信”通过使用某种同步原语（例如锁或通道）来实现。对于异步任务，每种阻塞同步原语都有对应的异步版本可用：异步`Mutex`、异步`RwLock`、异步`mpsc`通道等等。许多运行时甚至提供了标准库中没有的异步同步原语。尽管存在类似物，但两种原语的接口通常非常相似：就功能而言，异步`Mutex`与阻塞`Mutex`非常相似，只是其锁方法是异步的，而不是阻塞的。这是[async-std](https://async.rs)运行时的概念基础。

然而，值得注意的是，这些东西的实现完全不同。当你生成一个异步任务时运行的代码与生成线程时完全不同，例如异步锁的定义和实现非常不同于阻塞锁：通常它们会在底层使用基于原子操作的锁，并且还会有一个任务队列，等待该锁的任务。它们不会阻塞线程，而是将任务放入队列并让出执行；当锁被释放时，它们唤醒队列中的第一个任务，以允许其再次获取锁。

对于这些API的*用户*来说，多任务并发与多线程并发非常相似。然而，这并不是futures抽象能够实现的唯一并发形式。

## 内任务并发

虽然多任务并发与多线程并发有相同的API表面（除了散布的async & await关键字），但是futures抽象还可以实现一种在线程上下文中没有类似物的并发：“内任务并发”。这意味着同一任务可以同时执行多个异步操作。与为每个并发操作分配单独任务不同，你可以使用同一任务对象执行这些操作，提高内存局部性，节省分配开销，并增加优化机会。

具体来说，我指的是当您使用任务内并发原语（例如 `select!`）时，正在操作的两个 Futures 的状态将直接嵌入操作它们的父 Future 中。广为人知的任务内并发原语集合对应于我之前讨论过的异步原语表：它们是 `Future` 的 `select` 和 `join`，以及 `AsyncIterator` 的 `merge` 和 `zip`。

```
 │    SUM      │  PRODUCT ───────────────┼─────────────┼────────── │             │ FUTURE │    select!  │  join! │             │ ASYNCITERATOR │    merge!   │  zip! │             │ 
```

使用线程，您可以提供这样的 API，但只能通过生成新线程并使用通道或 join 句柄将其结果返回给父线程来实现。这引入了大量的开销，而这些原语的任务内实现在 Rust 中尽可能廉价。

实际上，消除这些组合器的开销正是 Rust 从传递续风格转向基于 readiness 的 Future 抽象的主要原因。当 Aaron Turon 在 [写到](http://aturon.github.io/tech/2016/09/07/futures-design/) 需要在传递续风格中进行堆分配的 Future 时，他举的例子是 `join`，这并非巧合。正是那些嵌入并发操作的 Future 需要共享续体的所有权（在任何并发操作完成时调用续体）。因此，正是这些用于任务内并发的组合器，是为了优化基于 readiness 的 Futures 而设计的。

正如 Rain 在过去所 [争辩的](https://sunshowers.io/posts/nextest-and-tokio/#what-are-heterogenous-selects)，"异构选择是异步 Rust 的要点。" 具体来说，您可以选择多种不同类型的 Futures，并等待它们中的任何一个首先完成，并且从单个任务中进行，而无需额外的分配，这是异步 Rust 相对于非异步 Rust 的独特属性之一，也是其最强大的特性之一。

异步 Rust 服务器的常见架构是为每个套接字生成一个任务。这些任务通常在套接字上内部复用入站和出站读写以及其他任务发送到套接字另一端服务的消息。为此，它们可能会在准确细节的生命周期中选择某些 Futures 或将事件流合并在一起。这可以具有非常高层次的外观，在许多方面它类似于异步并发的 actor 模型，但由于任务内并发，它将编译成每个套接字的单个状态机，这种运行时表示与类似于 C 语言中手写异步服务器非常相似。

这种架构（以及类似的其他架构）结合了多任务并发，适合最适当的情况和任务内并发，适合更好的情况。认识到这些场景之间的差异是掌握异步 Rust 的关键技能。任务内并发存在一些限制：如果你的算法可以遵守这些限制，那它可能非常合适。

第一个限制是，只能通过任务内并发实现静态并发度。也就是说，你不能在编译时加入（或选择等）任意数量的 future，数量必须在编译时确定。这是因为编译器需要能够在父 future 的状态中布局每个并发 future 的状态，并且每个 future 都需要具有静态确定的最大大小。这实际上与在堆栈上不能有动态大小的对象集合相同，但需要使用像堆分配的`Vec`这样的东西来拥有动态数量的对象。

第二个限制是，这些并发操作不会独立执行，也不会独立于等待它们的父任务执行。我的意思是两件事情。首先，任务内并发不会实现并行：最终只有一个任务，有一个单一的轮询方法，多个线程不能同时轮询该任务。 （所有广泛使用的异步运行时对计算密集型工作也不太适合；我认为这并不是异步模型的核心，但这是目前可用于使用异步的库的事实。）其次，如果用户取消对此任务的兴趣，所有子操作必然取消，因为它们都是同一个任务的一部分。因此，如果希望这些操作即使在工作被取消时也继续，它们必须成为单独的分开任务。

# 函数非着色问题

我想偏离一会儿，回到 Nystrom 的帖子，引入一个完全不同的线程到这个讨论中。我保证这些线程将来会重新连接，并且我甚至希望它们会连贯起来。

我建议我们继续以带有彩色功能的语言的思维实验，并想象语言的设计者已经阅读了 Nystrom 的批评，并试图缓解`RED`和`BLUE`函数的问题。在不知道何时停止的语言设计师的经典倾向下，他们添加了第三种颜色的函数，称为`GREEN`函数，他们希望这将终结所有人的抱怨。当然，这些也带来了他们自己的一套规则。

#### 1\. `GREEN`函数可以像`BLUE`函数一样被调用。

与`RED`函数不同，`GREEN`函数没有特殊的语法：您可以使用与`BLUE`函数完全相同的语法在任何地方调用它们。实际上，从它们的签名和使用方式来看，根本无法分辨出任何区别。文档中可能会有关于该函数是`GREEN`的说明，或者如果作者没有考虑到这些信息，也可能没有。

太好了！只要坚持使用`BLUE`和`GREEN`函数，您就不必再担心函数的颜色。

#### 2\. 每个原始`RED`函数都有对应的`GREEN`等效函数。

当然，要实现这一点，您需要能够在不调用`RED`函数的情况下编写程序。因此，语言作者在其标准库中为每个操作添加了一个`GREEN`函数，否则只能通过`RED`函数获得。

在某些与性能有关的方面，这些实现有所不同，这可能与您的用例有关系，但我们决定在这个思想实验中忽略代码的实际语义之类的东西，至少现在我们不会深入探讨这些。

#### 3\. 存在一个`GREEN`函数，用于包装任何`RED`函数并调用它。

尽管标准库中存在`GREEN`函数，用户仍然可能遇到使用`RED`函数编写的库。因此，语言设计者巧妙地想出了一个解决方法：有一种高阶`GREEN`函数，它以`RED`函数作为参数。它基本上只是调用`RED`函数，尽管有技术细节不容忽视。因为`GREEN`函数可以从任何地方调用，这解决了无法从`BLUE`函数内部调用`RED`函数的问题。

#### 4\. 在`RED`函数内部调用`GREEN`函数非常糟糕。

当然，总会有一些不利因素。绝对不应该从`RED`函数内部调用`GREEN`函数。这并不是“鼻子魔鬼”未定义行为糟糕，甚至不是“手臂上有蛇的小丑”JavaScript糟糕，但它肯定会减慢程序运行速度，最糟糕的情况下甚至可能导致死锁。用户绝对不应该这样做。喜欢使用`RED`函数的程序员必须不惜一切避免`GREEN`函数。

但是这种语言如何添加这些函数也存在问题：因为它们与`BLUE`函数完全相同，所以当您调用它们时无法分辨！您必须从文档中了解所有`GREEN`函数，并确保从`RED`函数内部永远不要调用它们。

## 阻塞函数没有颜色

现在我已经像圣诞树一样点亮了我的博客，让我们再谈谈Rust。你可能已经猜到`GREEN`函数是什么：绿色函数是任何阻塞当前线程的函数。没有特殊的语法或类型来区分一个阻塞等待某事同时发生的线程：这正是Nystrom认为阻塞函数如此出色之处。与许多支持异步函数的语言不同，Rust也支持阻塞函数：有一个API可以通过阻塞线程执行任何类型的IO或线程同步，还有一个`block_on`API，它接受任何`Future`并阻塞该线程直到准备就绪，因此你可以像阻塞调用异步库一样调用它们。

不支持阻塞操作的语言没有这个问题：相反，它们有Nystrom抱怨的问题，即您必须知道异步和非异步函数之间的区别。但由于在Rust中一切皆有可能，不想使用未来的用户几乎可以完全避开它们：他们唯一的问题是有时候开源库（免费提供给他们并且没有保修！）会使用async Rust，并且他们需要使用`block_on`来与其代码中的这些库一起使用。有些人仍然经常并且热切地抱怨这种情况。

这里最糟糕的是async Rust的用户，他们不仅必须处理async Rust，还必须处理绝不能在其async代码中调用阻塞函数的事实。然而，阻塞函数与普通函数完全无法区分！这正是Nystrom认为它们如此出色的原因。

很久以前（就在async/await推出后不久），我[提议](https://internals.rust-lang.org/t/warning-when-calling-a-blocking-function-in-an-async-context/11440)在阻塞函数上添加一个属性，试图引入一些针对在异步上下文中调用它们的警告，帮助用户捕捉此类错误。出于我不知道的原因，Rust项目并没有追求这个想法。我希望能看到更多的工作来帮助用户捕捉这种错误。

用于async IO中最阴险的阻塞API之一是阻塞`Mutex`。在某些特定但仍然非常普遍的情况下，在async函数中使用阻塞`Mutex`是可以的：

1.  在其所有用例中，它只会被锁定很短的时间。

1.  它从未持有在`await`点上。

然而，问题就在这里，如果在`await`点上持有`Mutex`，当同一线程上运行的其他任务尝试获取锁时，可能会导致线程死锁（标准库的`Mutex`不是可重入的）。这意味着有时候可以使用它完全没有问题，但有时候不仅仅是坏，而且绝对是灾难性的。这并不是一个好的结果！

# “我不想要快速线程，我想要未来”

前两节探讨了两个相当独立的思想：

+   在第一点，Rust 的 futures 模型使得一种特定的高度优化的“任务内并发”成为可能，而这是线程模型无法实现的。

+   在第二点，阻塞函数和普通函数几乎无法区分，这给异步 Rust 带来了问题。

这两个讨论的共同点在于异步函数和阻塞函数之间的差异是*Future trait 的额外支持*。这使得异步任务能够同时执行多个操作，而线程则不能。正是因为缺乏这种支持，阻塞函数在异步代码中调用时会导致问题，因为它们不能让步，只能阻塞。我的异步 Rust 设计原则是：我们实现这种支持有着非常充分的理由，应该充分利用它。正如 Henry de Valence 在 Twitter 上所说：“我不需要快速线程，我需要 futures。”（原文链接：[https://twitter.com/hdevalence/status/1665867608741011456](https://twitter.com/hdevalence/status/1665867608741011456)）

这个想法并不新鲜。在删除 Rust 中的 green threading 库的 RFC 中，Aaron Turon 认为试图使异步 IO 和阻塞 IO 的 API 相同限制了异步 Rust 的潜力。（原文链接：[https://rust-lang.github.io/rfcs/0230-remove-runtime.html](https://rust-lang.github.io/rfcs/0230-remove-runtime.html)）

> 采用今天的设计，绿色线程和本地线程模型必须始终提供相同的 I/O API。但有些功能只适合或者在某种线程模型下更为高效。
> 
> 例如，最轻量级的 M:N 任务模型本质上只是闭包的集合，并不提供任何特殊的 I/O 支持。这种轻量级任务的风格被用在 Servo 中，也出现在 java.util.concurrent 的执行器和 Haskell 的 par monad 中，以及许多其他地方。这些更轻量的模型不适合于当前的运行时系统。

Turon 接着开发了基于就绪状态的 futures API，这是 Rust 当今存在的基础。它的起源可以从这些言论中看出。我认为随着我们在 future 抽象上添加 async/await 语法（以及 Rust 贡献者的努力），这个想法已经被淡化并且有些失落。现在的思路是，异步 Rust 和阻塞 Rust 应尽可能相似。但这意味着异步 Rust 放弃了它的额外支持，除非用户空间调度可以提供潜在的性能改进。

理解异步/等待如何适应这个世界以及它并不是全部。Futures提供了一个选择，但不是一个要求，在一个任务内多路复用并发操作。这种选择在你需要时非常关键，但大多数时候你乐意让你的代码继续“一件该死的事情接着一件事情来”。等待操作符允许你做到这一点，而不需要高度嵌套的回调或组合器链。这降低了付出Futures选择性代价的成本，因为它们将世界分为异步和非异步函数，而不增加额外的使用困难。但正是那些你**确实**行使该选项的地方 - 你**不**等待未来的地方 - 才是最重要的地方！

Futures使您能够在单个线程上多路复用任意数量的完全大小的任务，并在单个任务内多路复用静态数量的并发操作。通过这样做，它们使用户能够在逻辑上结构化并发代码，而无需到处包含关于生成线程的并发相关样板。它们具有更好的性能特征，这在具有非常高并发度的场景中可能至关重要。在我看来，这一点单独就足以抵消入场费，但我们也可以想象其他优势。

返回到在等待点持有锁的问题。一些用户可能会使用的一种模式是，在执行任何可能耗时的异步操作（如IO）之前，确保他们放弃锁，这样其他并发操作可以取得锁而不是等待。（这需要小心：您需要确保您的代码能够抵御在执行IO时发生的保护状态潜在更改。）异步/等待已经比阻塞IO更容易，因为任务可能在`await`关键字标记的点执行长时间工作。对于阻塞IO，没有任何语法上表明阻塞，这样更容易忽略需要放弃锁的点。但是异步Rust可以做得比这更好。

大卫·巴斯基（David Barsky）提出了他所称的[“生命周期”](https://internals.rust-lang.org/t/pre-rfc-lifecycle-trait/12311) trait：类似于`Drop`的接口，但是在包含该对象的未来产生和恢复时执行。他特别对这个概念感兴趣，因为它能够在所有日志消息中包含执行任务的信息，并且需要知道何时发生更改。它还可以用于启用一个锁原语，该原语在未来产生控制权时自动放弃其租约，并在重新启动时重新获取租约。这将确保用户在等待时不会意外地未释放锁，甚至比手动版本更为高效：当您的任务实际上不会产生控制权（因为未来立即准备就绪）时，您无需放弃锁并重新获取。

## `maybe(async)`

如果我不提到Rust项目内部正在讨论的一个与我这里的思路完全相反的特性，我会觉得过意不去：`maybe(async)`的想法。这是一个（语法尚待确定）用于编写代码的特性，其抽象是否是异步的。换句话说，任何`maybe(async)`函数都可以实例化为两个变体：一个是异步的（并在其中等待所有未来），另一个则不是异步的（并且可能这些在异步版本中返回未来的函数将会阻塞）。

这个想法的最大问题在于它只适用于多任务并发。如我之前所述，使用多任务并发编写的代码与使用多线程并发编写的代码之间存在直接类比。但是，在任务内并发在基于线程的并发系统中没有等价物，因为它依赖于未来的特性。因此，任何试图使用`maybe(async)`的尝试将仅限于严格使用多任务并发的代码段。问题在于，对于任何足够重要的代码片段，都会存在利用任务内并发的关键部分，因此不适合使用`maybe(async)`进行抽象化。

最近，Mario Ortiz Manero在[这篇文章](https://nullderef.com/blog/rust-async-sync/)中讨论了尝试编写同时支持阻塞和异步IO的库的困难性。这篇博文对我来说似乎是我能想到的最为强有力的`maybe(async)`的案例，因此我想更深入地分析它。

他们的用例是一个包装器，将Rust方法调用转换为对Spotify API的HTTP请求。他们希望从相同的源代码支持其库的阻塞和异步版本，使用[reqwest](https://github.com/seanmonstar/reqwest)作为异步HTTP客户端，以及[ureq](https://github.com/algesten/ureq)作为阻塞HTTP客户端。他们讨论了目前这种做法的困难性，这显然是正确的。

首先，有趣的是注意到 reqwest 库实际上包含其自己的阻塞式 HTTP 客户端以及其异步客户端。为了实现这一点，它会在一个后台线程上生成所有对该客户端的请求，使它们在同一个线程上进行多路复用。奥尔蒂兹·马内罗因此拒绝了这种方法：

> 不幸的是，这种解决方案仍然有相当大的开销。您会引入像 `futures` 或 `tokio` 这样的大型依赖，并将它们包含在您的二进制文件中。所有这些，都是为了&mldr; 最终写出阻塞代码。因此，这不仅仅是运行时的成本，而且还是编译时的成本。这种感觉对我来说不太对劲。

在这里，奥尔蒂兹·马内罗似乎是指这些依赖的构建时开销，而不是运行时开销。但我们应该问一下为什么 reqwest 要引入这些依赖，即使它“感觉不对劲”？在阻塞式 reqwest 中，tokio 用于在同一线程上复用所有对同一客户端的请求。对我来说，这两种方法之间的这种架构差异比起一个依赖于 tokio 而另一个不依赖于它更为重要。我想看到针对不同工作负载的两种方法之间的基准测试，而不是仅仅因为其依赖树中的内容而排除其中一种。

reqwest 支持但 ureq 不支持的一个特性是 HTTP/2。HTTP/2 的设计允许用户在同一 TCP 连接上复用不同的请求。相比之下，ureq 只提供了（非管线化的）HTTP/1。根据其当前的架构，它无法支持这一点，因为每当用户在 TCP 连接上发出请求时，它会阻塞线程直到该请求完成。因此，使用 ureq，您可以向服务发送的并发网络请求数量受限于该服务允许您建立的开放 TCP 连接的数量，并且对于每个新连接，您将需要执行新的 TCP（和可能是 TLS）握手。

如果 ureq 想要支持 HTTP/2 及其复用功能，它会发现需要在单个 TCP 连接上实现该复用。它可能不会使用异步 Rust 来做到这一点，但如果它希望在此基础上使用阻塞 IO，并且仍然提供与现有 API 相似的接口，那么它仍然需要运行一个后台线程和通道，以便多个线程的并发请求可以在单个 TCP 连接上进行复用。换句话说，这种架构将变得与 reqwest 的架构一样。通过使用异步 Rust，reqwest 更容易地在多个连接上多路复用 HTTP/1 的请求和在同一连接上多路复用 HTTP/2 的请求之间进行抽象。这是一个巨大的优势，因为用户经常不知道他们想要通信的服务是否支持 HTTP/2。

即便如此，您可能会说 `maybe(async)` 对于本文作者来说仍然有一些效用，即使他们从 ureq 切换到 reqwest 的阻塞 API，因为它可以帮助他们省去实现库的异步版本和其阻塞 API 的样板文件。但由于 `maybe(async)` 能够抽象的内容有限，这仅对严格的无状态“映射”另一个底层库语义的库来说才是真实的。例如，这可能是一个将 HTTP RPC 调用转换为 Rust 对象和方法的库，或者可能是一个根据字节接口（如 TCP）定义的线路协议库。一旦库有了自己的不断发展的状态管理（正如它们下面的 HTTP 或 IO 库所做的那样），这两种实现就会有意义地分歧，不能再通过 `maybe(async)` 从同一源码实现。

由于对于那些需要维护两个版本的库来说，这只是样板文件，可能有更好的方法来支持这一点，而不是添加一个新的抽象层。一个方法是使用宏系统，可以用它来生成类似于 reqwest 的阻塞接口，从一个异步接口生成代码（生成将阻塞函数映射到后台线程的消息）。像 Spotify 客户端这样的库可以使用该宏来避免支持阻塞 API 的样板文件，但这会以在后台线程上使用异步运行时为代价来实现。但这同样适用于无状态和有状态的库，不像 `maybe(async)`。

另一种方法是所谓的“无IO”。例如，ureq 的作者还维护着一种以这种风格编写的 WebRTC 库，称为 [str0m](https://github.com/algesten/str0m)，它通过完全不处理库中的实际 IO 来避免阻塞和非阻塞 IO 的问题。类似地编写的库还有 Cloudflare 的 [quiche](https://github.com/cloudflare/quiche)，它实现了 QUIC 的状态机，但没有执行 IO。基于这个概念，我们可以想象一种完全将 IO 问题“解放”出这些库的方法，而是编写针对抽象接口的库，允许它们针对任何 UDP、TCP、HTTP 或它们所依赖的其他协议实现执行。如何通用化这一点还有待确定。

# 最后关于协程的离题讨论

这篇文章已经太长了，但我知道它可能会在 Rust 社区之外获得关注，我可以预测到某种消极反应：我引用的 future 的便利性不仅仅可以通过 futures 实现！任何类型的协程都可以提供这些便利性。Rust 使用 *无栈* 协程，它们有一些令人不快的限制，但是使用 *有栈* 协程的语言也可以以更少的麻烦提供相同的便利性。

我实际上同意。回到虚构语言的世界，人们可以想象一种所有函数都是协程的语言，这意味着所有函数都可以产生。没有函数染色！“纯”函数将是一个永远不会产生`Never`的函数（实际上根本不会产生），而“不纯”函数将是一个产生`Pending`（或来自你运行时的其他魔术类型，表示正在等待外部事件）的函数。不纯函数将是默认的，所有函数都是协程，因此调用操作符将自动向外传递`Pending`值。你仍然可以以某种方式标记纯函数，以确保你不做任何IO或同步操作。

该语言还需要一种实例化协程对象并恢复它的方法，而不是调用它直到完成。利用该操作符，你可以实现像select和join这样的并发组合器。语言还需要某种方式来作为全新的并发任务生成协程。所有这些都无需async/await：这就是堆栈饱和协程为你提供的。

你甚至可以将这种协程特性扩展到代表其他事物。例如，可迭代对象可以表示为产生有意义的值的协程。`for`循环将获取该协程对象并依次处理每个值。异步可迭代对象只会产生该值*或* `Pending`。你还可以以相同的方式建模异常，产生一个错误（可能会有一个单独的“路径”，用于识别抛出异常的函数无法重新启动的事实）。我还没有完全设计好这种语言，但所有这些听起来都是合理的。

（事实上，这并不一定要通过协程完成。你还可以以倒置方式建模这一点，以便为每个这些事物注册一个返回堆栈的点：用于挂起IO操作的一个点，用于抛出异常的一个点，用于从可迭代对象产生的项的一个点，等等。你可以称之为这些“效果”的堆栈点的“处理程序”，换句话说，一种“代数效果处理程序”。我想说的是，这两种语言概念，效果处理程序和协程，至少部分上是同构的。）

我还认为（但不确定）这样的语言可以在不向表面语法添加生命周期的情况下，实现与Rust相同的保证，即引用不会同时可变且别名化。只要协程能够暂停并使用引用恢复，引用就可以成为不能嵌入对象类型的修饰符，它们的生命周期可以完全推断。这将不允许与Rust一样优化的代码表示（在之前的[文章](/blog/the-registers-of-rust)术语中，将无法访问“低级寄存器”），但仍将提供相同的正确性保证。

为什么Rust不做类似的事情？[起初确实是这样的！](https://graydon2.dreamwidth.org/307291.html)但它让位给了其他要求。上周在lobste.rs上有一个真正好的[评论](https://lobste.rs/s/jkct2m/avoid_async_rust#c_0dqqlv)，比我更好地表达了这一点：

> 异步风格语言特性是你的执行模型与1：1的C ABI、C标准库和C运行时本地兼容以及M：N执行模型之间的一种妥协。C++的异步也遇到了相同的问题，只是在生命周期安全性上没有那么严格（这不是一件好事）。与C/系统运行时本地兼容的成本是“函数上色”问题。

Rust有一个与现有C运行时兼容的先前承诺。这意味着Rust代码由一堆子例程组成，可以取出堆栈中的项目地址，并且不仅可以存储在该堆栈中，还可以存储在程序内存的其他区域。Rust选择了这种方法，以获取对使用该模型编写的大量现有C和C++代码的零成本FFI支持，因为C运行时是所有主流平台的共享最小标准。但是，这种运行时模型与*栈内*协程不兼容，因此Rust需要引入一种*无栈*协程机制。每一种带有async/await的主要语言同样受限于一个类似的现有运行时，无论是C的还是某个虚拟机运行时。关于C运行时唯一的事情是，它是如此普遍，以至于许多程序员甚至没有意识到它的存在，也不是一个自然发生的现象。

还有一条关于这些问题的评论：

如果你是一位享有盛名的语言设计师，你可能会说服一家大型富有的技术公司资助你开发一种新的语言，这种语言不那么依赖于C运行时，特别是如果你作为一位对C和UNIX有深入了解的系统工程师享有卓越声誉，并且能够利用这一点（以及公司的声誉）迅速推广你的语言。在取得这样有影响力的位置后，你可能会引入一种新的范式，比如栈内协程或效果处理程序，从而解放程序员，摆脱线程和future之间的虚假选择。如果莱布尼茨说得对，我们生活在最好的世界中，那么这确实是你在一代人的机会中所能做的。

（如果你这样做了，我希望你至少不会上台说你采用这种方法的原因是因为你的用户“无法理解一个杰出的语言”！）

在不太理想的世界里，你可能会决定做一些不太有灵感的事情。你可能会从C运行时中休息一下，然后再次实现线程，基本上具有相同的语义，只是它们在用户空间中调度。你的用户将需要根据线程、锁和通道来实现并发，就像过去一直这样。你也可能决定你的语言应该具有其他经典特性，比如空指针、默认构造函数、数据竞争和GOTO，原因只有你自己知道。也许你会在多年之后才添加泛型，尽管用户频繁请求。在不太理想的世界里，你可能*去*做这些事情。

唉。在我感到悲观时，我认为我们的行业陷入了某种停滞，因此每个十年我们都将用新语言重新编写具有相同行为的新程序，这些语言在语义上基本相同，只是在性能特征上有轻微差异，更适合当前的硬件考虑。这是一个悲伤的命运，但也许很快将成为大型语言模型的命运，而不是程序员的命运。我热衷于推广Rust的原因在于它让我对编程感到乐观：Rust致力于相信主流编程语言可以有意义地为更好而进化。

尽管是一种进步，但Rust并不是摆脱了C运行时的语言。它是那种语言的低级别、更难处理的表亲：你可以通过一些汇编来获得相同的保证。“需自行组装”。在我们的硬性要求下，我们应该尽一切可能减少必要的汇编，在async/await的基础上，我们已经为此奠定了基础。我们应该志在不通过隐藏futures和线程之间的差异来简化系统，而是找到一套正确的API和语言特性，利用futures的便利性来实现比以往更多种类的工程任务。现在我们只有基础，但这已经比以往手工管理状态机和直接管理事件循环的世界有了巨大的进步。如果我们让futures成为futures并在此基础上建立，将会有更多可能性。
