- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 13:29:40'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling Internals
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: æ¥æºï¼š[https://tontinton.com/posts/scheduling-internals/](https://tontinton.com/posts/scheduling-internals/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A sneak peek to what's coming!
  id: totrans-split-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I remember when I first learned that you can write a server handling millions
    of clients running on just a single thread, my mind was simply blown away ğŸ¤¯
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: I used Node.js while knowing it is single threaded, I used `async` / `await`
    in Python, and I used threads, but never asked myself *"How is any of this possible?"*.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: This post is written to spread the genius of concurrency and hopefully getting
    you excited about it too.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: My goal is for you to want to send a link to this post to an engineer in your
    team asking out loud *"Wait, but how does async even work?"*.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Questions I''m going to answer:'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Why not create a thread per client?
  id: totrans-split-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to sleep when waiting on I/O?
  id: totrans-split-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does Node.js achieve concurrency?
  id: totrans-split-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's concurrency? What's parallelism?
  id: totrans-split-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are coroutines?
  id: totrans-split-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With an implementation we'll build piece by piece.
  id: totrans-split-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What are preemptive and non-preemptive schedulers?
  id: totrans-split-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does Go and Rust implement concurrency in the language (stackful vs stackless)?
  id: totrans-split-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What scheduling algorithms are used by linux, Go and Rust's tokio?
  id: totrans-split-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I assume proficiency in reading code and OS internals at an intermediate level,
    but don't stress over details you don't understand, try to get the bigger picture!
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: With all of that out of the way, let us begin.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: Just create a thread, bro
  id: totrans-split-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to write a simple echo server (whatever we receive, we send back)
    in C code, we''ll call it `echod`:'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Cool, now what should we do if want to handle multiple clients concurrently?
    While one client is being handled, another tries to `connect` to our server, without
    ever succeeding, as our server reaches the `accept` call only once it is done
    handling the current client.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: How can we fix that?
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing most people will think is *"Can''t you just create a thread
    for each client?"*, something that looks like this:'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first problem with threads is how the OS allocates a stack for a new thread.
    The stack is allocated virtual memory (10mb on linux by default), and physical
    pages are only commited once the pages are actually written to. This is really
    nice as it means that you don't really reserve 10mb of RAM for each thread right
    out of the gate, **but** it does mean the granularity of allocation is at least
    that of a page (run `getconf PAGESIZE`, my machine is 4kb). Using `pthread_attr_setstacksize`
    won't fix the problem, you still must provide a value that is a multiple of a
    page size. A page might be a lot more that what you actually use, depending on
    the application.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: I also think that relying on overcommitment of memory is pretty annoying. We
    are getting killed by the OOM killer instead of having an opportunity cleaning
    up resources when an allocation fails indicating we are out of memory.
  id: totrans-split-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The second problem we need to fix when creating a bunch of OS threads is to
    change all the relevant limits:'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just the files I showed you might not be enough for your system, for example
    `systemd` also sets maximums.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: The third problem is performance. Context switching between kernel and user
    mode is expensive in terms of CPU cycles. A single context switch isn't that expensive
    on its own, but doing a lot of them adds up.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: The fourth problem is that the stack allocation is static, we can't modify the
    stack size (grow) or free up commited physical pages in the stack once they are
    unused (shrink).
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: Because of all these problems, threads should not be your go-to solution for
    running a lot of tasks concurrently (especially for I/O bound tasks like in `echod`).
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: How else can we make `echod` serve millions of clients concurrently?
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: Async I/O
  id: totrans-split-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why block an entire thread from running, when calling `read` / `write` / `accept`?
    If you think about it, we waste a precious resource (CPU) from doing anything
    while the application waits for I/O.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: When calling `read` for example, the kernel waits for a network packet to be
    received from the network interface card or `NIC`. The CPU is free to run something
    else meanwhile.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: In linux, you can mark a socket as non-blocking by either using `ioctl(fd, FIONBIO)`
    or `fcntl & O_NONBLOCK` (posix). A `read` call on that same socket will return
    immediately. If there's a packet written by the `NIC` we haven't read yet, `read`
    will copy the buffer like usual, otherwise it will return an error, with `errno`
    equal to `EWOULDBLOCK`.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s patch `echod` to be single threaded again, but this time, supporting
    multiple concurrent clients using non-blocking sockets:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A bit lengthy, don't try to understand everything, just that we are dealing
    with a lot of different tasks "at once". For a compilable version, click [here](https://github.com/tontinton/echod-hog/blob/master/main.c).
  id: totrans-split-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The main problem with this solution is that we are now always busy doing something,
    the CPU runs at 100%, even when most loop iterations will result in `EWOULDBLOCK`.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is code complexity, we are now prohibited from running code
    that will block, to not block our entire server application.
  id: totrans-split-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What we really want is to sleep when we have nothing *useful* to do. I.e. When
    there is no client waiting to connect, no client has sent any packet and we can't
    yet send a packet to the client for whatever reason (maybe the client is busy
    doing something of its own).
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The reasons we want this are:'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: To be good neighbours to other applications running on the same machine, and
    not take CPU cycles they might want to utilize.
  id: totrans-split-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The more the CPU runs, the more energy it takes:'
  id: totrans-split-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worse battery life.
  id: totrans-split-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: More expensive.
  id: totrans-split-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Less environmental friendly ğŸŒ²ğŸŒ³ğŸŒ¿
  id: totrans-split-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Good news though, most operating systems provide an API to do just that. Maybe
    even too many APIs:'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: '**select(2)** - A posix API. The man page is excellent, so let''s copy the
    important bits:'
  id: totrans-split-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Main takeaway is that select is limited to `FD_SETSIZE` number of fds to monitor,
    which is usually 1024 (glibc). Another thing to note is that when a FD becomes
    ready, it scans all its registered FDs (`O(n)`), so when you have a lot of FDs,
    you can spend a lot of time just on this.
  id: totrans-split-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**poll(2)** - A posix API. Not limited to `FD_SETSIZE` but still `O(n)` like
    `select`.'
  id: totrans-split-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**epoll(7)** - A linux API. A non portable `poll` but at least it scales better
    as it''s `O(1)`.'
  id: totrans-split-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**aio(7)** - A linux API. Unlike previous APIs, it supports both sockets and
    files, but with some major disadvantages:'
  id: totrans-split-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports only files opened with `O_DIRECT`, which are complex to work with.
  id: totrans-split-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocks if file metadata isn't available until it becomes available.
  id: totrans-split-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocks when the storage device is out of request slots (each storage device
    has a fixed number of slots).
  id: totrans-split-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each IO submission copies 72 bytes and each completion copies 32 bytes. 104
    bytes copied for each IO operation using 2 syscalls.
  id: totrans-split-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**io_uring(7)** - A linux API (since 5.1). Like `aio`, it unifies disk and
    network operations under a single API, but without `aio`''s shortcomings. It is
    designed to be fast, creating 2 queues that live in shared memory (between user
    and kernel space), one for submission of I/O operations, the other is populated
    with the results of the I/O operations once they are ready. For more info head
    over to ["What is io_uring?"](https://unixism.net/loti/what_is_io_uring.html).'
  id: totrans-split-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScyllaDB` have successfully implemented their database using `aio` in [seastar](https://seastar.io/),
    you can read more on async disk I/O on [their blog](https://scylladb.com/2017/10/05/io-access-methods-scylla/).'
  id: totrans-split-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you're interested about platforms other than linux, windows has [I/O Completion
    Ports](https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports),
    with FreeBSD and MacOS both using [kqueue](https://man.freebsd.org/cgi/man.cgi?kqueue).
  id: totrans-split-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prior to `io_uring`, async I/O abstraction libraries used a thread pool to run
    disk I/O in a non-blocking manner.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: There are libraries like [libuv](https://libuv.org/) (what powers Node.js) that
    you can use to run highly concurrent servers while using just a single thread
    (they finally changed it to [use io_uring](https://github.com/libuv/libuv/pull/3952)).
    These kind of libraries are often called `Event Loops`, let's talk about them
    a bit.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: Event Loop
  id: totrans-split-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At its essence an event loop (also sometimes called [reactor pattern](https://en.wikipedia.org/wiki/Reactor_pattern))
    is basically this:'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Yeah, that''s it, just look at `libuv`''s `uv_run`:'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here''s `uv__run_pending` without omitting any details:'
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pretty awesome huh? This is what all Node.js applications are running on.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: What if you need to call a blocking 3rd party library function? For that, most
    event loop libraries have a thread pool you can run arbitrary code on, for example
    in `libuv`, you can use [uv_queue_work()](https://docs.libuv.org/en/v1.x/threadpool.html).
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Pop quiz: how would something like `setTimeout` be implemented in an event
    loop? If nothing comes to mind, try cloning `libuv` and reading the implementation
    of `uv__run_timers` in `src/timer.c`.'
  id: totrans-split-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è€ƒéªŒæ—¶é—´ï¼šåƒ`setTimeout`è¿™æ ·çš„ä¸œè¥¿åœ¨äº‹ä»¶å¾ªç¯ä¸­æ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿå¦‚æœè„‘æµ·ä¸­ä»€ä¹ˆä¹Ÿæ²¡æœ‰ï¼Œè¯·å°è¯•å…‹éš†`libuv`å¹¶é˜…è¯»`src/timer.c`ä¸­`uv__run_timers`çš„å®ç°ã€‚
- en: Event Driven Development
  id: totrans-split-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: äº‹ä»¶é©±åŠ¨å¼€å‘
- en: The programming model when using an event loop is inherently event driven, with
    each registered event having a callback to execute once it is ready.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨äº‹ä»¶å¾ªç¯æ—¶çš„ç¼–ç¨‹æ¨¡å‹æœ¬è´¨ä¸Šæ˜¯äº‹ä»¶é©±åŠ¨çš„ï¼Œæ¯ä¸ªæ³¨å†Œäº‹ä»¶éƒ½æœ‰ä¸€ä¸ªå‡†å¤‡å¥½æ—¶æ‰§è¡Œçš„å›è°ƒå‡½æ•°ã€‚
- en: 'Let''s see how `echod` would look like using an imaginary event loop library
    instead (start with `serve` from the bottom):'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹ä½¿ç”¨è™šæ„çš„äº‹ä»¶å¾ªç¯åº“æ—¶`echod`ä¼šæ˜¯ä»€ä¹ˆæ ·å­ï¼ˆä»åº•éƒ¨çš„`serve`å¼€å§‹ï¼‰ï¼š
- en: '[PRE8]'
  id: totrans-split-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you worked with javascript before, this should look familiar to you.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä¹‹å‰ä½¿ç”¨è¿‡ JavaScriptï¼Œè¿™çœ‹èµ·æ¥åº”è¯¥å¾ˆç†Ÿæ‚‰ã€‚
- en: 'The code will be very lightweight in terms of performance, and highly concurrent,
    but is often criticized for being:'
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ€§èƒ½ä¸Šæ¥è¯´ï¼Œä»£ç å°†éå¸¸è½»é‡åŒ–ï¼Œå¹¶ä¸”é«˜åº¦å¹¶å‘ï¼Œä½†é€šå¸¸å› ä»¥ä¸‹åŸå› è€Œå—åˆ°æ‰¹è¯„ï¼š
- en: '**Not intuitive** - Complex for most programmers who are used to reading and
    writing synchronous code, see ["Callback Hell"](http://callbackhell.com).'
  id: totrans-split-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ä¸ç›´è§‚** - å¯¹äºå¤§å¤šæ•°ä¹ æƒ¯äºé˜…è¯»å’Œç¼–å†™åŒæ­¥ä»£ç çš„ç¨‹åºå‘˜è€Œè¨€ï¼Œçœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œå‚è§["å›è°ƒåœ°ç‹±"](http://callbackhell.com)ã€‚'
- en: '**Hard to debug** - The call stack is very short and will not show you the
    flow of how you got to a specific breakpoint. The caller of each callback will
    always be `uv_run` in `libuv`, or `run_event_loop` in our example.'
  id: totrans-split-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**éš¾ä»¥è°ƒè¯•** - è°ƒç”¨å †æ ˆéå¸¸çŸ­ï¼Œä¸ä¼šæ˜¾ç¤ºä½ å¦‚ä½•åˆ°è¾¾ç‰¹å®šæ–­ç‚¹çš„æµç¨‹ã€‚æ¯ä¸ªå›è°ƒçš„è°ƒç”¨è€…å§‹ç»ˆæ˜¯`libuv`ä¸­çš„`uv_run`ï¼Œæˆ–è€…æˆ‘ä»¬ç¤ºä¾‹ä¸­çš„`run_event_loop`ã€‚'
- en: A lot of modern programming languages and runtimes try to solve these problems
    by letting you write code that looks synchronous while being fully asynchronous.
    In the next chapter, we're gonna learn how.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šç°ä»£ç¼–ç¨‹è¯­è¨€å’Œè¿è¡Œæ—¶è¯•å›¾é€šè¿‡è®©ä½ ç¼–å†™çœ‹èµ·æ¥æ˜¯åŒæ­¥çš„ä»£ç ï¼ŒåŒæ—¶å®é™…ä¸Šæ˜¯å®Œå…¨å¼‚æ­¥çš„æ¥è§£å†³è¿™äº›é—®é¢˜ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•å®ç°ã€‚
- en: Preemption
  id: totrans-split-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æŠ¢å 
- en: Have you ever wondered how is it that you can run more than 1 thread on a computer
    with just a single CPU core?
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æœ‰æ²¡æœ‰æƒ³è¿‡ï¼Œåªæœ‰ä¸€ä¸ªCPUæ ¸å¿ƒçš„è®¡ç®—æœºä¸Šå¦‚ä½•è¿è¡Œå¤šä¸ªçº¿ç¨‹ï¼Ÿ
- en: In this section, we'll go over the secret technique that enables this magic,
    called **preemption**.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»ä¸€ç§ç§°ä¸º**æŠ¢å **çš„ç§˜å¯†æŠ€æœ¯ï¼Œå®ƒä½¿è¿™ç§é­”æœ¯æˆä¸ºå¯èƒ½ã€‚
- en: 'Let''s say we have the following two tasks we would like to execute concurrently:'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬è¦åŒæ—¶æ‰§è¡Œä»¥ä¸‹ä¸¤ä¸ªä»»åŠ¡ï¼š
- en: '[PRE9]'
  id: totrans-split-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What should `run_all` do to make sure that both tasks run **concurrently**?
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`run_all`åº”è¯¥åšä»€ä¹ˆä»¥ç¡®ä¿è¿™ä¸¤ä¸ªä»»åŠ¡**å¹¶å‘**è¿è¡Œï¼Ÿ'
- en: If we had 2 CPU cores, we could have simply run 1 task on 1 core, which would
    mean we would run the two tasks **parallelly**, or in other words the two tasks
    run at the same time in the *real* world (at least the one we base physics on).
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æœ‰ä¸¤ä¸ªCPUæ ¸å¿ƒï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°åœ¨ä¸€ä¸ªæ ¸å¿ƒä¸Šè¿è¡Œä¸€ä¸ªä»»åŠ¡ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥**å¹¶è¡Œ**è¿è¡Œä¸¤ä¸ªä»»åŠ¡ï¼Œæˆ–è€…æ¢å¥è¯è¯´ï¼Œåœ¨*çœŸå®*ä¸–ç•Œä¸­ï¼ˆè‡³å°‘æ˜¯æˆ‘ä»¬åŸºäºç‰©ç†å­¦çš„ä¸–ç•Œï¼‰è¿™ä¸¤ä¸ªä»»åŠ¡åŒæ—¶è¿è¡Œã€‚
- en: A **concurrent** program deals with running multiple things at once, just not
    at the same time, thus they may seem **parallel** even if they're really not.
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¹¶å‘**ç¨‹åºå¤„ç†åŒæ—¶è¿è¡Œå¤šä¸ªäº‹ç‰©ï¼Œä½†å¹¶éåŒæ—¶è¿›è¡Œï¼Œå› æ­¤å®ƒä»¬å¯èƒ½çœ‹èµ·æ¥æ˜¯**å¹¶è¡Œ**çš„ï¼Œå³ä½¿å®é™…ä¸Šå¹¶éå¦‚æ­¤ã€‚'
- en: One way `run_all` can achieve **concurrency** is by running 1 task for some
    amount of time, pause, and then resume running the next task, forever in a loop
    until all tasks exit for example. To magically make it appear as if it's **parallel**,
    you simply need to configure the amount of time before pausing to be really small
    relative to the human experience (e.g. 100Î¼s?).
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`run_all`å®ç°**å¹¶å‘**çš„ä¸€ç§æ–¹å¼æ˜¯åœ¨æŸæ®µæ—¶é—´å†…è¿è¡Œä¸€ä¸ªä»»åŠ¡ï¼Œæš‚åœï¼Œç„¶åç»§ç»­è¿è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡ï¼Œå¹¶ä¸”æ°¸è¿œå¾ªç¯ï¼Œç›´åˆ°æ‰€æœ‰ä»»åŠ¡é€€å‡ºä¸ºæ­¢ã€‚ä¸ºäº†åƒ**å¹¶è¡Œ**ä¸€æ ·ç¥å¥‡åœ°å±•ç°å‡ºæ¥ï¼Œä½ åªéœ€é…ç½®æš‚åœä¹‹å‰çš„æ—¶é—´ç›¸å¯¹äºäººç±»ç»éªŒæ¥è¯´éå¸¸çŸ­ï¼ˆä¾‹å¦‚100Î¼sï¼Ÿï¼‰å³å¯ã€‚'
- en: '[PRE10]'
  id: totrans-split-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But how do you pause and resume execution of code?
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œå¦‚ä½•æš‚åœå’Œæ¢å¤ä»£ç çš„æ‰§è¡Œå‘¢ï¼Ÿ
- en: The answer lies in programs being deterministic state machines, as long as you
    give a program's executor (e.g. CPU for native code) the same inputs (e.g. registers,
    memory, etc...), it doesn't matter if it executes today or in a few years, the
    output will be the same.
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: ç­”æ¡ˆåœ¨äºç¨‹åºæ˜¯ç¡®å®šæ€§çŠ¶æ€æœºï¼Œåªè¦å‘ç¨‹åºçš„æ‰§è¡Œè€…ï¼ˆä¾‹å¦‚æœ¬æœºä»£ç çš„CPUï¼‰æä¾›ç›¸åŒçš„è¾“å…¥ï¼ˆä¾‹å¦‚å¯„å­˜å™¨ã€å†…å­˜ç­‰ï¼‰ï¼Œå®ƒæ— è®ºæ˜¯ä»Šå¤©æ‰§è¡Œè¿˜æ˜¯å‡ å¹´åæ‰§è¡Œï¼Œè¾“å‡ºéƒ½å°†ç›¸åŒã€‚
- en: Basically, pausing a task can be implemented as copying the current state of
    the program, and resuming a task can be implemented by loading that saved state.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºæœ¬ä¸Šï¼Œæš‚åœä»»åŠ¡å¯ä»¥é€šè¿‡å¤åˆ¶ç¨‹åºçš„å½“å‰çŠ¶æ€æ¥å®ç°ï¼Œæ¢å¤ä»»åŠ¡å¯ä»¥é€šè¿‡åŠ è½½ä¿å­˜çš„çŠ¶æ€æ¥å®ç°ã€‚
- en: It doesn't matter if the program runs on a real CPU or a virtual one like in
    `python`'s bytecode or on the `JVM` for example, they are all deterministic state
    machines. As long as you copy all the necessary state, the task will resume as
    if it was never even paused.
  id: totrans-split-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¨‹åºè¿è¡Œåœ¨çœŸå® CPU ä¸Šæˆ–åƒ `python` çš„å­—èŠ‚ç æˆ– `JVM` è¿™æ ·çš„è™šæ‹Ÿ CPU ä¸Šéƒ½æ²¡æœ‰å…³ç³»ï¼Œå®ƒä»¬éƒ½æ˜¯ç¡®å®šæ€§çŠ¶æ€æœºã€‚åªè¦å¤åˆ¶æ‰€æœ‰å¿…è¦çš„çŠ¶æ€ï¼Œä»»åŠ¡å°†ä¼šç»§ç»­è¿›è¡Œï¼Œå°±åƒä»æœªæš‚åœè¿‡ä¸€æ ·ã€‚
- en: To make it easy to understand how you might implement preemption (saving and
    loading of program state), let's look at `setjmp.h`, which implements saving and
    loading program state in a lot of different CPU architectures, and is part of
    `libc`.
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä¾¿äºç†è§£å¦‚ä½•å®ç°æŠ¢å ï¼ˆä¿å­˜å’ŒåŠ è½½ç¨‹åºçŠ¶æ€ï¼‰ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ `setjmp.h`ï¼Œå®ƒåœ¨è®¸å¤šä¸åŒçš„ CPU æ¶æ„ä¸­å®ç°äº†ä¿å­˜å’ŒåŠ è½½ç¨‹åºçŠ¶æ€ï¼Œå¹¶ä¸”æ˜¯ `libc`
    çš„ä¸€éƒ¨åˆ†ã€‚
- en: 'See the following example (copied directly from [wikipedia](https://en.wikipedia.org/wiki/Setjmp.h)):'
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: å‚è§ä»¥ä¸‹ç¤ºä¾‹ï¼ˆç›´æ¥ä» [wikipedia](https://en.wikipedia.org/wiki/Setjmp.h) å¤åˆ¶ï¼‰ï¼š
- en: '[PRE11]'
  id: totrans-split-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running it will output:'
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: è¿è¡Œå®ƒå°†è¾“å‡ºï¼š
- en: '[PRE12]'
  id: totrans-split-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`setjmp` saves the program state (in `buf`), and `longjmp` loads whatever is
    in `buf` to the CPU.'
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`setjmp` ä¿å­˜ç¨‹åºçŠ¶æ€ï¼ˆåœ¨ `buf` ä¸­ï¼‰ï¼Œè€Œ `longjmp` å°† `buf` ä¸­çš„ä»»ä½•å†…å®¹åŠ è½½åˆ° CPU ä¸­ã€‚'
- en: 'Let''s look behind the curtains, the following is the `x86_64` assembly code
    for `setjmp` and `longjmp` in [musl](https://musl.libc.org/) (a popular `libc`
    implementation):'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹å¹•åçš„æƒ…å†µï¼Œä»¥ä¸‹æ˜¯ `musl`ï¼ˆä¸€ä¸ªæµè¡Œçš„ `libc` å®ç°ï¼‰ä¸­ `x86_64` æ±‡ç¼–ä»£ç çš„ `setjmp` å’Œ `longjmp`ï¼š
- en: '[PRE13]'
  id: totrans-split-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Don't stress it if you don't understand assembly. The point is that saving and
    loading program state is pretty short and simple.
  id: totrans-split-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä¸ç†è§£æ±‡ç¼–è¯­è¨€ä¹Ÿä¸è¦ç´§ã€‚å…³é”®æ˜¯ä¿å­˜å’ŒåŠ è½½ç¨‹åºçŠ¶æ€éå¸¸ç®€çŸ­å’Œç®€å•ã€‚
- en: '`setjmp` saves all callee-saved registers into `jmp_buf`. Callee-saved registers
    are registers used to hold long-lived values that should be preserved across function
    calls. `longjmp` restores the callee-saved registers stored inside a `jmp_buf`
    directly to the CPU registers.'
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`setjmp` å°†æ‰€æœ‰è¢«è°ƒç”¨ä¿å­˜çš„å¯„å­˜å™¨ä¿å­˜åˆ° `jmp_buf` ä¸­ã€‚è¢«è°ƒç”¨ä¿å­˜çš„å¯„å­˜å™¨ç”¨äºä¿å­˜é•¿æœŸå­˜åœ¨çš„å€¼ï¼Œåœ¨å‡½æ•°è°ƒç”¨ä¹‹é—´åº”è¯¥ä¿ç•™ã€‚`longjmp`
    ç›´æ¥å°†ä¿å­˜åœ¨ `jmp_buf` ä¸­çš„è¢«è°ƒç”¨ä¿å­˜çš„å¯„å­˜å™¨æ¢å¤åˆ° CPU å¯„å­˜å™¨ä¸­ã€‚'
- en: To the curious, the reason caller-saved registers (like `rcx` for example) are
    not saved, is because to the compiler `setjmp` is just another function call,
    meaning it will not use caller-saved registers to hold state. It assumes just
    like with any function call, that these registers might be changed.
  id: totrans-split-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¯¹äºå¥½å¥‡çš„äººï¼Œä¸ä¿å­˜è°ƒç”¨è€…ä¿å­˜çš„å¯„å­˜å™¨ï¼ˆä¾‹å¦‚ `rcx`ï¼‰çš„åŸå› æ˜¯å› ä¸ºå¯¹ç¼–è¯‘å™¨è€Œè¨€ `setjmp` åªæ˜¯å¦ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œè¿™æ„å‘³ç€å®ƒä¸ä¼šä½¿ç”¨è°ƒç”¨è€…ä¿å­˜çš„å¯„å­˜å™¨æ¥ä¿å­˜çŠ¶æ€ã€‚å®ƒå‡å®šåƒä»»ä½•å‡½æ•°è°ƒç”¨ä¸€æ ·ï¼Œè¿™äº›å¯„å­˜å™¨å¯èƒ½ä¼šè¢«ä¿®æ”¹ã€‚
- en: Non-Preemptive Schedulers
  id: totrans-split-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: éæŠ¢å è°ƒåº¦ç¨‹åº
- en: Already, we have a solid foundation to start running multiple tasks concurrently.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»æœ‰äº†ä¸€ä¸ªåšå®çš„åŸºç¡€ï¼Œå¯ä»¥å¼€å§‹åŒæ—¶è¿è¡Œå¤šä¸ªä»»åŠ¡äº†ã€‚
- en: 'Instead of relying on time to pause execution of a running task, we can instead
    assume the programmer manually inserts calls to `longjmp`, see example (this time
    in C for `setjmp.h`):'
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ä¾èµ–æ—¶é—´æ¥æš‚åœæ­£åœ¨è¿è¡Œçš„ä»»åŠ¡ï¼Œæˆ‘ä»¬å¯ä»¥å‡è®¾ç¨‹åºå‘˜æ‰‹åŠ¨æ’å…¥è°ƒç”¨ `longjmp`ï¼Œå‚è§ç¤ºä¾‹ï¼ˆè¿™æ¬¡æ˜¯ C è¯­è¨€çš„ `setjmp.h`ï¼‰ï¼š
- en: '[PRE14]'
  id: totrans-split-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s run it:'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è¿è¡Œå®ƒï¼š
- en: '[PRE15]'
  id: totrans-split-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Cool, but... There's actually a hidden bug (can you find it?).
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ˆé…·ï¼Œä½†æ˜¯... å®é™…ä¸Šæœ‰ä¸€ä¸ªéšè—çš„ bugï¼ˆä½ èƒ½æ‰¾åˆ°å—ï¼Ÿï¼‰ã€‚
- en: 'Let''s change `task_0` to hold some state on the stack:'
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä¿®æ”¹ `task_0`ï¼Œåœ¨å †æ ˆä¸Šä¿å­˜ä¸€äº›çŠ¶æ€ï¼š
- en: '[PRE16]'
  id: totrans-split-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run it again:'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡è¿è¡Œå®ƒï¼š
- en: '[PRE17]'
  id: totrans-split-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Whoops... Because all our tasks share the same stack, each task (including
    our `main` function) may overwrite whatever is in the stack. See the following
    illustration:'
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: ç³Ÿç³•... å› ä¸ºæ‰€æœ‰ä»»åŠ¡å…±äº«åŒä¸€ä¸ªå †æ ˆï¼Œæ¯ä¸ªä»»åŠ¡ï¼ˆåŒ…æ‹¬æˆ‘ä»¬çš„ `main` å‡½æ•°ï¼‰å¯èƒ½ä¼šè¦†ç›–å †æ ˆä¸­çš„ä»»ä½•å†…å®¹ã€‚è¯·å‚è§ä¸‹é¢çš„ç¤ºä¾‹ï¼š
- en: '[PRE18]'
  id: totrans-split-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-split-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-split-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-split-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The fix is to create a stack for each task, and switch to it right before calling
    the task function:'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ³•æ˜¯ä¸ºæ¯ä¸ªä»»åŠ¡åˆ›å»ºä¸€ä¸ªå †æ ˆï¼Œå¹¶åœ¨è°ƒç”¨ä»»åŠ¡å‡½æ•°ä¹‹å‰åˆ‡æ¢åˆ°è¯¥å †æ ˆï¼š
- en: '[PRE22]'
  id: totrans-split-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The reason for saving the task function in the register `rax`, was to not lookup
    `tasks[i]` inside the stack, as we just changed the stack to some other memory
    location. The `asm` syntax is fully documented [here](https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/how-to-use-inline-assembly-language-in-c-code.html).
  id: totrans-split-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¿å­˜ä»»åŠ¡å‡½æ•°åœ¨å¯„å­˜å™¨ `rax` ä¸­çš„åŸå› æ˜¯ä¸ºäº†é¿å…åœ¨å †æ ˆå†…æŸ¥æ‰¾ `tasks[i]`ï¼Œå› ä¸ºæˆ‘ä»¬åˆšåˆšå°†å †æ ˆæ›´æ”¹ä¸ºå…¶ä»–å†…å­˜ä½ç½®ã€‚`asm` è¯­æ³•åœ¨ [è¿™é‡Œ](https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/how-to-use-inline-assembly-language-in-c-code.html)
    å…¨é¢è®°å½•ã€‚
- en: 'Run it one last time:'
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åå†è¿è¡Œä¸€æ¬¡ï¼š
- en: '[PRE23]'
  id: totrans-split-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have successfully implemented a user mode non-preemptive scheduler!
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æˆåŠŸå®ç°äº†ç”¨æˆ·æ¨¡å¼éæŠ¢å è°ƒåº¦ç¨‹åºï¼
- en: In real non-preemptive (also called cooperative) systems, the runtime should
    yield when it knows that the CPU has nothing useful to do anymore in the current
    task, for example waiting on I/O. They do that by registering for I/O and move
    the task to a different queue that holds blocked tasks (which the scheduler skips
    from running). Once there's I/O, they move the task from the blocked queue back
    to the regular queue for execution. This can be done for example by integrating
    with an event loop.
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨çœŸæ­£çš„éæŠ¢å å¼ï¼ˆä¹Ÿç§°ä¸ºåä½œå¼ï¼‰ç³»ç»Ÿä¸­ï¼Œè¿è¡Œæ—¶åº”åœ¨çŸ¥é“ CPU åœ¨å½“å‰ä»»åŠ¡ä¸­æ²¡æœ‰æ›´å¤šæœ‰ç”¨å·¥ä½œæ—¶è®©å‡ºï¼Œä¾‹å¦‚ç­‰å¾… I/Oã€‚ä»–ä»¬é€šè¿‡æ³¨å†Œ I/O å¹¶å°†ä»»åŠ¡ç§»åŠ¨åˆ°ä¸åŒçš„é˜Ÿåˆ—æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œè¯¥é˜Ÿåˆ—ä¿å­˜é˜»å¡ä»»åŠ¡ï¼ˆè°ƒåº¦å™¨è·³è¿‡è¿è¡Œï¼‰ã€‚ä¸€æ—¦æœ‰äº†
    I/Oï¼Œä»–ä»¬å°†ä»»åŠ¡ä»é˜»å¡é˜Ÿåˆ—ç§»å›å¸¸è§„é˜Ÿåˆ—ä»¥æ‰§è¡Œã€‚ä¾‹å¦‚ï¼Œå¯ä»¥é€šè¿‡ä¸äº‹ä»¶å¾ªç¯é›†æˆæ¥å®Œæˆæ­¤æ“ä½œã€‚
- en: 'Here are some examples of non-preemptive schedulers in popular mainstream runtimes:'
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›æµè¡Œä¸»æµè¿è¡Œæ—¶ä¸­çš„éæŠ¢å å¼è°ƒåº¦å™¨ç¤ºä¾‹ï¼š
- en: '**Rust''s [tokio](https://tokio.rs/)** - To yield, you either call `tokio::task::yield_now()`,
    or run until blocking (e.g. waiting on I/O or `tokio::time::sleep()`). In version
    0.3.1 they introduced an [automatic yield](https://tokio.rs/blog/2020-04-preemption).'
  id: totrans-split-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust çš„ [tokio](https://tokio.rs/)** - è¦è¿›è¡Œè®©æ­¥ï¼Œä½ å¯ä»¥è°ƒç”¨`tokio::task::yield_now()`ï¼Œæˆ–è€…è¿è¡Œç›´åˆ°é˜»å¡ï¼ˆä¾‹å¦‚ç­‰å¾…
    I/O æˆ– `tokio::time::sleep()`ï¼‰ã€‚åœ¨ç‰ˆæœ¬ 0.3.1 ä¸­ï¼Œä»–ä»¬å¼•å…¥äº†[è‡ªåŠ¨è®©æ­¥](https://tokio.rs/blog/2020-04-preemption)ã€‚'
- en: '**Go (prior to 1.14)** - At release (version 1.0), to yield, you would either
    call `runtime.Gosched()`, or run until blocking. In version 1.2 the scheduler
    is also invoked occasionally upon entry to a function.'
  id: totrans-split-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Goï¼ˆ1.14 ç‰ˆæœ¬ä¹‹å‰ï¼‰** - åœ¨å‘å¸ƒï¼ˆç‰ˆæœ¬ 1.0ï¼‰æ—¶ï¼Œè¦è¿›è¡Œè®©æ­¥ï¼Œä½ å¯ä»¥è°ƒç”¨`runtime.Gosched()`ï¼Œæˆ–è€…è¿è¡Œç›´åˆ°é˜»å¡ã€‚åœ¨ç‰ˆæœ¬
    1.2 ä¸­ï¼Œè°ƒåº¦å™¨ä¹Ÿå¶å°”ä¼šåœ¨å‡½æ•°å…¥å£å¤„è¢«è°ƒç”¨ã€‚'
- en: '**Erlang** - In [BEAM](https://blog.stenmans.org/theBeamBook/) (erlang''s awesome
    runtime), the scheduler is invoked at function calls. Since there are no other
    loop constructs than recursion and list comprehensions, there is no way to loop
    forever without doing a function call. You can cheat though by running native
    C code using a `NIF` (native implemented function).'
  id: totrans-split-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Erlang** - åœ¨[BEAM](https://blog.stenmans.org/theBeamBook/)ï¼ˆerlang çš„å¼ºå¤§è¿è¡Œæ—¶ï¼‰ä¸­ï¼Œè°ƒåº¦å™¨åœ¨å‡½æ•°è°ƒç”¨æ—¶è¢«è°ƒç”¨ã€‚ç”±äºé™¤äº†é€’å½’å’Œåˆ—è¡¨æ¨å¯¼æ²¡æœ‰å…¶ä»–å¾ªç¯ç»“æ„ï¼Œæ²¡æœ‰åŠæ³•æ— é™å¾ªç¯è€Œä¸è¿›è¡Œå‡½æ•°è°ƒç”¨ã€‚ä¸è¿‡ï¼Œä½ å¯ä»¥é€šè¿‡è¿è¡Œæœ¬åœ°çš„
    C ä»£ç æ¥ä½œå¼Šï¼Œä½¿ç”¨`NIF`ï¼ˆæœ¬åœ°å®ç°å‡½æ•°ï¼‰ã€‚'
- en: 'Non-preemptive schedulers are risky, as we assume developers remember to put
    `yield` calls when doing long computations:'
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
  zh: éæŠ¢å å¼è°ƒåº¦å™¨æ˜¯æœ‰é£é™©çš„ï¼Œå› ä¸ºæˆ‘ä»¬å‡è®¾å¼€å‘äººå‘˜åœ¨è¿›è¡Œé•¿æ—¶é—´è®¡ç®—æ—¶è®°å¾—æ”¾ç½®`yield`è°ƒç”¨ï¼š
- en: '[PRE24]'
  id: totrans-split-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Preemptive Schedulers
  id: totrans-split-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æŠ¢å å¼è°ƒåº¦å™¨
- en: A preemptive scheduler context switches (yields) once in a while, even without
    a developer inserting yield calls.
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: æŠ¢å å¼è°ƒåº¦å™¨å¶å°”è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼ˆè®©å‡ºï¼‰ï¼Œå³ä½¿æ²¡æœ‰å¼€å‘äººå‘˜æ’å…¥è®©å‡ºè°ƒç”¨ã€‚
- en: Most modern operating systems utilize timer interrupts. The CPU receives an
    interrupt once every X amount of time is passed. The interrupt stops execution
    of whatever is currently running, and the interrupt handler calls the scheduler
    which decides whether to context switch.
  id: totrans-split-146
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§å¤šæ•°ç°ä»£æ“ä½œç³»ç»Ÿä½¿ç”¨å®šæ—¶å™¨ä¸­æ–­ã€‚CPU æ¯éš”ä¸€æ®µæ—¶é—´æ”¶åˆ°ä¸€ä¸ªä¸­æ–­ã€‚ä¸­æ–­åœæ­¢å½“å‰æ­£åœ¨è¿è¡Œçš„ä»»ä½•å†…å®¹ï¼Œå¹¶ä¸”ä¸­æ–­å¤„ç†ç¨‹åºè°ƒç”¨è°ƒåº¦å™¨ï¼Œå†³å®šæ˜¯å¦è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚
- en: That's cool and all, but user mode applications can't register to interrupts,
    so what can we do if we want to implement a preemptive scheduler in user mode?
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¾ˆé…·ï¼Œä½†ç”¨æˆ·æ¨¡å¼åº”ç”¨ç¨‹åºä¸èƒ½æ³¨å†Œä¸­æ–­ï¼Œé‚£ä¹ˆå¦‚æœæˆ‘ä»¬æƒ³åœ¨ç”¨æˆ·æ¨¡å¼ä¸­å®ç°æŠ¢å å¼è°ƒåº¦å™¨ï¼Œæˆ‘ä»¬è¯¥æ€ä¹ˆåšå‘¢ï¼Ÿ
- en: One simple solution would be to utilize the kernel's preemptive scheduler. Create
    a thread that periodically sends a signal to threads running our scheduler.
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯åˆ©ç”¨å†…æ ¸çš„æŠ¢å å¼è°ƒåº¦å™¨ã€‚åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œå®šæœŸå‘è¿è¡Œæˆ‘ä»¬çš„è°ƒåº¦å™¨çš„çº¿ç¨‹å‘é€ä¿¡å·ã€‚
- en: This is exactly how Go made their scheduler preemptive in version 1.14\. By
    periodically sending signals from their monitoring thread ([runtime.sysmon](https://sobyte.net/post/2021-12/golang-sysmon/))
    to the scheduler threads running goroutines.
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ­£æ˜¯ Go åœ¨ç‰ˆæœ¬ 1.14 ä¸­ä½¿ä»–ä»¬çš„è°ƒåº¦å™¨å˜ä¸ºæŠ¢å å¼çš„æ–¹å¼ã€‚é€šè¿‡å‘¨æœŸæ€§åœ°ä»ä»–ä»¬çš„ç›‘æ§çº¿ç¨‹ï¼ˆ[runtime.sysmon](https://sobyte.net/post/2021-12/golang-sysmon/)ï¼‰å‘è¿è¡Œ
    goroutines çš„è°ƒåº¦å™¨çº¿ç¨‹å‘é€ä¿¡å·ã€‚
- en: 'For more info on their solution, I recommend you watch ["Pardon the Interruption:
    Loop Preemption in Go 1.14"](https://youtube.com/watch?v=1I1WmeSjRSw).'
  id: totrans-split-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'æƒ³äº†è§£æ›´å¤šå…³äºä»–ä»¬è§£å†³æ–¹æ¡ˆçš„ä¿¡æ¯ï¼Œæˆ‘å»ºè®®ä½ è§‚çœ‹["Pardon the Interruption: Loop Preemption in Go 1.14"](https://youtube.com/watch?v=1I1WmeSjRSw)ã€‚'
- en: Stackful vs Stackless
  id: totrans-split-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å †æ ˆå¼ vs æ— å †æ ˆå¼
- en: Up until now, I have been calling them tasks to not confuse you, but they have
    many different names like fibers, greenlets, user mode threads, green threads,
    virtual threads, coroutines and goroutines.
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: ç›´åˆ°ç°åœ¨ï¼Œæˆ‘ä¸€ç›´ç§°å®ƒä»¬ä¸ºä»»åŠ¡ï¼Œä»¥å…è®©ä½ å›°æƒ‘ï¼Œä½†å®ƒä»¬æœ‰è®¸å¤šä¸åŒçš„åç§°ï¼Œå¦‚çº¤ç¨‹ï¼ˆfibersï¼‰ã€greenletsã€ç”¨æˆ·æ¨¡å¼çº¿ç¨‹ã€ç»¿è‰²çº¿ç¨‹ã€è™šæ‹Ÿçº¿ç¨‹ã€åç¨‹å’Œ
    goroutinesã€‚
- en: When people say threads, they usually mean OS threads (managed by the kernel
    scheduler).
  id: totrans-split-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å½“äººä»¬è¯´çº¿ç¨‹æ—¶ï¼Œé€šå¸¸æŒ‡çš„æ˜¯æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼ˆç”±å†…æ ¸è°ƒåº¦ç¨‹åºç®¡ç†ï¼‰ã€‚
- en: 'A coroutine is simply a program that can be paused and resumed. There are mainly
    two ways to implement them: either you allocate a stack for each coroutine (stackful),
    or you make each function marked as `async` return an object that can hold all
    the state needed to pause and resume that function (stackless).'
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Stackful and stackless impact the API greatly, each with its own advantages
    and disadvantages. Here''s an overview:'
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Stackful** - Coroutines have the exact same API and semantics as OS threads,
    which makes sense, as they both allocate a stack at runtime. Our example scheduler
    using `setjmp` is stackful. Go is another example of a stackful implementation.
    Just like Go needs to periodically context switch, it also needs to periodically
    check whether there is enough free stack space to continue running, if not, it
    reallocates the stack to have more memory, copies what it had before and fixes
    all pointers that pointed to the old stack to now point to the new stack. Just
    like the stack can grow dynamically, it can also shrink if needed. The real beauty
    is that you can choose to run any function either synchronously or asynchronously
    in the background, without affecting the code around it:'
  id: totrans-split-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-split-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Stackless** - If you have ever used a language with `async` & `await`, you
    used a stackless implementation. Examples include Rust and Python''s `asyncio`.
    Rust''s `async` transforms a block of code into a state machine that is not run
    until you `await` it. The biggest advantage of this approach is how [lightweight
    it is at runtime](https://pkolaczk.github.io/memory-consumption-of-async/), memory
    is allocated exactly as needed, which served well for Rust''s embedded use case
    as well. The main problem with this approach is "function coloring". An `async`
    function can only be called inside another `async` function:'
  id: totrans-split-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-split-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Rust started with stackful prior to release, but ultimately ended up switching
    to stackless: ["Why async rust?"](https://without.boats/blog/why-async-rust/).'
  id: totrans-split-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Scheduler Algorithms
  id: totrans-split-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A scheduler is also responsible for deciding which task it should run next once
    one finishes.
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
- en: One of the simplest methods is one we have already seen before in the event
    loop section, and that is to run tasks in the order that they are added to the
    task queue.
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux''s `SCHED_FIFO` scheduler does exactly this:'
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
- en: Each circle is a task. The white progress circle around tasks is the time left
    to run until the task is blocked.
  id: totrans-split-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Purple box** - The queue holding tasks ready to run.'
  id: totrans-split-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Green box** - The CPU.'
  id: totrans-split-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Gray box** - Tasks blocked on something (e.g. I/O).'
  id: totrans-split-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Taking `SCHED_FIFO` and adding a task runtime limit is what `SCHED_RR` does,
    allowing the CPU to be shared in a more uniform manner:'
  id: totrans-split-169
  prefs: []
  type: TYPE_NORMAL
- en: What if you have a task that *must* run once every 5ms, even if for a really
    short amount of time? For example in audio programming, you have a buffer to fill
    with a signal in time (e.g. `sin(x)`) that the audio device reads from at some
    interval. Missing out on filling this buffer, will result in a random signal which
    sounds like crackling noise, potentially ruining a recording of an entire orchestra.
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æœ‰ä¸€ä¸ªå¿…é¡»æ¯5æ¯«ç§’è¿è¡Œä¸€æ¬¡çš„ä»»åŠ¡ï¼Œå³ä½¿æ—¶é—´å¾ˆçŸ­ä¹Ÿå¿…é¡»è¿è¡Œæ€ä¹ˆåŠï¼Ÿä¾‹å¦‚ï¼Œåœ¨éŸ³é¢‘ç¼–ç¨‹ä¸­ï¼Œä½ éœ€è¦å¡«å……ä¸€ä¸ªä¿¡å·ï¼ˆå¦‚`sin(x)`ï¼‰åˆ°ç¼“å†²åŒºä¸­ï¼ŒéŸ³é¢‘è®¾å¤‡ä»¥æŸä¸ªé—´éš”ä»ä¸­è¯»å–ã€‚å¦‚æœé”™è¿‡äº†å¡«å……æ­¤ç¼“å†²åŒºï¼Œå°†å¯¼è‡´å¬èµ·æ¥åƒçˆ†è£‚å™ªéŸ³çš„éšæœºä¿¡å·ï¼Œå¯èƒ½ä¼šç ´åæ•´ä¸ªä¹å›¢çš„å½•éŸ³ã€‚
- en: These kind of programs are usually called soft real time programs. Hard real
    time means missing a deadline will result in the whole system failing, for example
    autopilot and spacecrafts.
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ç±»å‹çš„ç¨‹åºé€šå¸¸ç§°ä¸ºè½¯å®æ—¶ç¨‹åºã€‚ç¡¬å®æ—¶æ„å‘³ç€é”™è¿‡æˆªæ­¢æ—¥æœŸå°†å¯¼è‡´æ•´ä¸ªç³»ç»Ÿå¤±è´¥ï¼Œä¾‹å¦‚è‡ªåŠ¨é©¾é©¶å’Œèˆªå¤©å™¨ã€‚
- en: 'Linux has a nice answer for soft real time systems called `SCHED_DEADLINE`,
    where each thread sets the amount of time until their deadline, and the scheduler
    always runs the task that is closest to reaching the deadline:'
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
  zh: Linux å¯¹è½¯å®æ—¶ç³»ç»Ÿæœ‰ä¸€ä¸ªå¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆï¼Œç§°ä¸º`SCHED_DEADLINE`ï¼Œå…¶ä¸­æ¯ä¸ªçº¿ç¨‹è®¾ç½®åˆ°å…¶æˆªæ­¢æ—¶é—´çš„æ—¶é—´é‡ï¼Œè°ƒåº¦å™¨å§‹ç»ˆè¿è¡Œæ¥è¿‘è¾¾åˆ°æˆªæ­¢æ—¶é—´çš„ä»»åŠ¡ï¼š
- en: The **green** progress circle is how much time is left until the deadline.
  id: totrans-split-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ç»¿è‰²**è¿›åº¦åœ†åœˆæ˜¾ç¤ºè·ç¦»æˆªæ­¢æ—¶é—´è¿˜å‰©å¤šå°‘æ—¶é—´ã€‚'
- en: Follow the **pink** circle, it has a short deadline, making it run a lot more
    than others.
  id: totrans-split-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å…³æ³¨**ç²‰è‰²**åœ†åœˆï¼Œå®ƒæœ‰ä¸€ä¸ªçŸ­æœŸé™ï¼Œä½¿å…¶æ¯”å…¶ä»–åœ†åœˆè¿è¡Œæ›´é¢‘ç¹ã€‚
- en: '`SCHED_FIFO` and `SCHED_RR` can also be used in soft real time systems because
    of their deterministic nature, depending on the problem you need to solve.'
  id: totrans-split-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`SCHED_FIFO`å’Œ`SCHED_RR`ä¹Ÿå¯ç”¨äºè½¯å®æ—¶ç³»ç»Ÿï¼Œå› ä¸ºå®ƒä»¬å…·æœ‰ç¡®å®šæ€§è´¨ï¼Œå–å†³äºæ‚¨éœ€è¦è§£å†³çš„é—®é¢˜ã€‚'
- en: To guarantee all tasks are able to run according to their configured deadline,
    `SCHED_DEADLINE` calculates and rejects threads with a configuration that will
    steal too much run time. You can learn more about it on lwn's ["Deadline scheduling"](https://lwn.net/Articles/743740/).
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä¿è¯æ‰€æœ‰ä»»åŠ¡èƒ½å¤ŸæŒ‰å…¶é…ç½®çš„æˆªæ­¢æ—¶é—´è¿è¡Œï¼Œ`SCHED_DEADLINE`è®¡ç®—å¹¶æ‹’ç»å…·æœ‰ä¼šå¤ºå–è¿‡å¤šè¿è¡Œæ—¶é—´çš„é…ç½®çš„çº¿ç¨‹ã€‚æ‚¨å¯ä»¥åœ¨lwnçš„["æˆªæ­¢æ—¥æœŸè°ƒåº¦"](https://lwn.net/Articles/743740/)ä¸Šäº†è§£æ›´å¤šä¿¡æ¯ã€‚
- en: For general purpose workloads, like a laptop running arbitrary processes, you
    usually want fairness. Fairness can be achieved by continuously tracking which
    processes have gotten less CPU time than others, and always run the task with
    the lowest tracked runtime. Linux's default scheduler `SCHED_OTHER`, also known
    as `CFS` (Completely Fair Scheduler), does exactly this. You can also configure
    priorities to processes by setting a `nice` value, where processes with a lower
    `nice` value will be scheduled more.
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºåƒç¬”è®°æœ¬ç”µè„‘è¿è¡Œä»»æ„è¿›ç¨‹è¿™æ ·çš„é€šç”¨å·¥ä½œè´Ÿè½½ï¼Œé€šå¸¸å¸Œæœ›å…¬å¹³æ€§ã€‚å…¬å¹³æ€§å¯ä»¥é€šè¿‡æŒç»­è·Ÿè¸ªå“ªäº›è¿›ç¨‹çš„ CPU æ—¶é—´æ¯”å…¶ä»–è¿›ç¨‹å°‘ï¼Œå¹¶å§‹ç»ˆè¿è¡Œå…·æœ‰æœ€ä½å·²è·Ÿè¸ªè¿è¡Œæ—¶é—´çš„ä»»åŠ¡æ¥å®ç°ã€‚Linux
    çš„é»˜è®¤è°ƒåº¦å™¨`SCHED_OTHER`ï¼Œä¹Ÿç§°ä¸º`CFS`ï¼ˆå®Œå…¨å…¬å¹³è°ƒåº¦å™¨ï¼‰ï¼Œæ­£æ˜¯è¿™æ ·åšçš„ã€‚æ‚¨è¿˜å¯ä»¥é€šè¿‡è®¾ç½®`nice`å€¼ä¸ºè¿›ç¨‹é…ç½®ä¼˜å…ˆçº§ï¼Œå…¶ä¸­`nice`å€¼è¾ƒä½çš„è¿›ç¨‹å°†è¢«æ›´é¢‘ç¹åœ°è°ƒåº¦ã€‚
- en: '`CFS` has served well for the last 26 years, but in v6.6, the new default scheduling
    algorithm is [EEVDF](https://lwn.net/Articles/925371/).'
  id: totrans-split-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`CFS`å·²ç»æœåŠ¡äº†26å¹´ï¼Œä½†åœ¨v6.6ä¸­ï¼Œæ–°çš„é»˜è®¤è°ƒåº¦ç®—æ³•æ˜¯[EEVDF](https://lwn.net/Articles/925371/)ã€‚'
- en: Multi-Core
  id: totrans-split-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¤šæ ¸
- en: So far, I have pretty much ignored the fact that modern machines have more than
    1 CPU core.
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘åŸºæœ¬ä¸Šå¿½ç•¥äº†ç°ä»£è®¡ç®—æœºæ‹¥æœ‰å¤šä¸ª CPU æ ¸å¿ƒçš„äº‹å®ã€‚
- en: 'The simplest way to achieve multi-core scheduling, is to do exactly as before.
    Having a global queue of tasks that are ready to run, and run them once a core
    is ready:'
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: å®ç°å¤šæ ¸è°ƒåº¦çš„æœ€ç®€å•æ–¹æ³•æ˜¯ç»§ç»­åƒä»¥å‰ä¸€æ ·ã€‚æ‹¥æœ‰ä¸€ä¸ªå…¨å±€ä»»åŠ¡é˜Ÿåˆ—ï¼Œå…¶ä¸­åŒ…å«å‡†å¤‡è¿è¡Œçš„ä»»åŠ¡ï¼Œå¹¶åœ¨æ ¸å¿ƒå‡†å¤‡å°±ç»ªåè¿è¡Œå®ƒä»¬ï¼š
- en: You just need to ensure that the task queue is thread-safe for `MPMC` operations
    (multi-producer multi-consumer), by using atomics or locks.
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨åªéœ€ç¡®ä¿ä»»åŠ¡é˜Ÿåˆ—åœ¨`MPMC`æ“ä½œï¼ˆå¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…ï¼‰æ—¶æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¯ä»¥é€šè¿‡åŸå­æ“ä½œæˆ–é”æ¥å®ç°ã€‚
- en: '`MPMC` queues are a lot slower than the more restrictive `SPMC` (single-producer
    multi-consumer) queues, which is why Go decided to have a fixed size `SPMC` queue
    for each scheduler (Go runs a scheduler per core configured by `GOMAXPROCS`),
    with a global `MPSC` queue to push to when the `SPMC` queue is full.'
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`MPMC`é˜Ÿåˆ—æ¯”æ›´ä¸¥æ ¼çš„`SPMC`ï¼ˆå•ç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…ï¼‰é˜Ÿåˆ—æ…¢å¾—å¤šï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆ Go é€‰æ‹©ä¸ºæ¯ä¸ªè°ƒåº¦å™¨é…ç½®ä¸€ä¸ªå›ºå®šå¤§å°çš„`SPMC`é˜Ÿåˆ—ï¼ˆGo ä½¿ç”¨`GOMAXPROCS`é…ç½®æ¯ä¸ªæ ¸å¿ƒè¿è¡Œä¸€ä¸ªè°ƒåº¦å™¨ï¼‰ï¼Œå¹¶åœ¨`SPMC`é˜Ÿåˆ—æ»¡æ—¶æ¨é€åˆ°å…¨å±€`MPSC`é˜Ÿåˆ—ã€‚'
- en: To ensure all cores are fully utilized, when a core is free to run but has nothing
    in its local queue and there are no tasks in the global queue, it **steals** tasks
    from other local queues (which is why they are multi-consumer).
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ç¡®ä¿æ‰€æœ‰æ ¸å¿ƒå……åˆ†åˆ©ç”¨ï¼Œå½“ä¸€ä¸ªæ ¸å¿ƒå¤„äºç©ºé—²çŠ¶æ€ä½†æœ¬åœ°é˜Ÿåˆ—ä¸­æ²¡æœ‰ä»»åŠ¡å¹¶ä¸”å…¨å±€é˜Ÿåˆ—ä¸­ä¹Ÿæ²¡æœ‰ä»»åŠ¡æ—¶ï¼Œå®ƒä¼š**çªƒå–**å…¶ä»–æœ¬åœ°é˜Ÿåˆ—çš„ä»»åŠ¡ï¼ˆè¿™å°±æ˜¯å®ƒä»¬ä¸ºä»€ä¹ˆæ˜¯å¤šæ¶ˆè´¹è€…çš„åŸå› ï¼‰ã€‚
- en: 'Go''s solution is so good, tokio borrowed a lot from it. I highly recommend
    reading it on their blog: ["Making the Tokio scheduler 10x faster"](https://tokio.rs/blog/2019-10-scheduler).'
  id: totrans-split-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Goçš„è§£å†³æ–¹æ¡ˆéå¸¸å‡ºè‰²ï¼Œtokioä»ä¸­å€Ÿé‰´äº†å¾ˆå¤šã€‚æˆ‘å¼ºçƒˆæ¨èåœ¨ä»–ä»¬çš„åšå®¢ä¸Šé˜…è¯»ç›¸å…³å†…å®¹ï¼š["ä½¿Tokioè°ƒåº¦å™¨å¿«10å€"](https://tokio.rs/blog/2019-10-scheduler)ã€‚
- en: Conclusion
  id: totrans-split-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: Congratulations ğŸ¥³! You are a real hero reaching the end, hopefully you have
    learned a thing or two.
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
  zh: ç¥è´º ğŸ¥³ï¼ä½ æ˜¯ä¸€ä¸ªçœŸæ­£çš„è‹±é›„ï¼Œåˆ°è¾¾äº†ç»ˆç‚¹ï¼Œå¸Œæœ›ä½ æœ‰æ‰€æ”¶è·ã€‚
- en: The topic has a lot more to cover, the links left throughout this post are a
    great place to start exploring the endless rabbit hole of concurrency and parallelism.
  id: totrans-split-188
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¸»é¢˜è¿˜æœ‰å¾ˆå¤šå†…å®¹éœ€è¦æ¶µç›–ï¼Œæœ¬æ–‡ä¸­ç•™ä¸‹çš„é“¾æ¥æ˜¯æ¢ç´¢å¹¶å‘å’Œå¹¶è¡Œæ€§æ— å°½å…”å­æ´çš„ç»ä½³èµ·ç‚¹ã€‚
- en: If you want to play around with the animations yourself, here's a link to the
    [code](https://github.com/tontinton/sched_animation).
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æƒ³è‡ªå·±ç©å¼„è¿™äº›åŠ¨ç”»ï¼Œè¯·ç‚¹å‡»è¿™é‡ŒæŸ¥çœ‹[ä»£ç ](https://github.com/tontinton/sched_animation)ã€‚
- en: Click here to scroll back to the animation at the top.
  id: totrans-split-190
  prefs: []
  type: TYPE_NORMAL
  zh: ç‚¹å‡»è¿™é‡Œè¿”å›é¡¶éƒ¨çš„åŠ¨ç”»ã€‚
