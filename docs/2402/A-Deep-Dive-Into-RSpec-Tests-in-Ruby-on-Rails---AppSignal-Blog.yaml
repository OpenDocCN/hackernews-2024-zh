- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:46:43'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: A Deep Dive Into RSpec Tests in Ruby on Rails | AppSignal Blog
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.appsignal.com/2024/02/07/a-deep-dive-into-rspec-tests-in-ruby-on-rails.html](https://blog.appsignal.com/2024/02/07/a-deep-dive-into-rspec-tests-in-ruby-on-rails.html)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In our last post, we looked at the basics of RSpec and explored how well it
    works with Behavior Driven Development in Ruby.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will look at specific types of RSpec tests for different parts of a
    Ruby on Rails application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive straight in!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Unit, Controller, and Integration Tests in Ruby on Rails
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Ruby on Rails application is composed of several layers. As the framework
    is built around Models, Views, and Controllers, we might think of those three
    as the only layers of an application. Yet, often, that's barely enough to describe
    a Ruby on Rails application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Mailers, Jobs, and Helpers are secondary layers we don't want to miss. When
    it comes to testing, it's important to remember that these components are largely
    impacted by how our code has been designed. Using [SOLID principles](https://en.wikipedia.org/wiki/SOLID)
    — particularly Single Responsibility — helps keep our code straightforward and
    more testable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we usually aim to keep things simple in views, controllers, models, jobs,
    and mailers: we want to assemble and use the bricks of code we have designed and
    tested separately already. Once we enter the realm of views and controllers, testing
    becomes much more complex, and slower too.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Categories of Ruby Tests
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, we split tests into these categories:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests** (models and other plain old Ruby objects — POROs): Ensure class
    methods are working as expected.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller tests:** Test the expected outcome of controller actions (rendering
    the right template, redirections, and flash messages).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View tests:** (Used rarely) to test specific elements or content in views.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helper tests:** For when you use a complex helper method.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature or system tests:** Simulate user interactions in the browser — this
    is where Capybara will help.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request tests:** Test an application''s response to various HTTP verbs without
    browser overhead. This is faster than feature tests.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mailer and jobs tests:** Specific tests are needed for this secondary layer
    to ensure emails are sent properly with the right content and jobs trigger the
    appropriate work.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing tests:** Complex routing is a code smell. Testing routes will help
    you avoid trouble when you have too many routes or routes that are too complex.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Kinds of Tests Should We Write?
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Do we need to write all of these tests? It depends on your culture and team,
    but these might be good starting points:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests:** Write focused and (as much as possible) database-dependent
    tests for your models'' public methods and other POROs you craft into your application;
    they should run fast.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller tests:** Write tests that help ensure controller actions are routable
    and respond as expected for each context they could be in. These should not aim
    to test the whole response or complex scenarios made of multiple requests.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request tests:** Test request scenarios from a machine client (think API
    controllers), typically: "for a given HTTP request context (HTTP verb, path, and
    parameters), what HTTP response should we get?"'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System tests:** Test scenarios of human user requests. Typically, this is
    where we want to test complex scenarios with multiple clicks.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mailer and job tests:** These should only test that a mailer and job are
    doing the specific "mailer" and "job" work properly. In particular, for jobs,
    most of the "work" should be done through classes and methods tested separately.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Controller tests are often replaced by a good layer of request and system tests,
    as they ultimately serve the same purpose. Too many tests will cause fatigue in
    your team or slow down your whole test suite for little benefit. It''s up to you.
    The point is to test your controller layer: figure out which way is best in your
    case.'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 控制器测试经常被良好的请求和系统测试层所取代，因为它们最终都有相同的目的。过多的测试会导致团队疲劳，或者对整个测试套件的速度造成小小的好处。这取决于你。重点是测试你的控制器层：找出在你的情况下哪种方式最好。
- en: Let's see how unit, controller, and integration (both request and system) tests
    look.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看单元测试，控制器测试和集成（请求和系统）测试的样子。
- en: Using RSpec and Ruby on Rails for Testing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RSpec和Ruby on Rails进行测试
- en: As pointed out in [our previous post](https://blog.appsignal.com/2024/01/24/behaviour-driven-development-in-ruby-with-rspec.html),
    we can use the `rspec-rails` gem to integrate RSpec into a Ruby on Rails application's
    code base.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[之前的文章](https://blog.appsignal.com/2024/01/24/behaviour-driven-development-in-ruby-with-rspec.html)中指出的，我们可以使用`rspec-rails`
    gem将RSpec集成到Ruby on Rails应用程序的代码库中。
- en: Unit Tests
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are at the base of the [testing pyramid](https://www.headspin.io/blog/the-testing-pyramid-simplified-for-one-and-all),
    so there will be numerous unit tests in a codebase. They need to be fast.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是[测试金字塔](https://www.headspin.io/blog/the-testing-pyramid-simplified-for-one-and-all)的基础，因此在代码库中会有大量的单元测试。它们需要快速执行。
- en: 'Remember: tests (with RSpec) are focused on testing code behavior, not implementation.
    That should help to write fast tests. In the case of Ruby on Rails projects, models
    are a big source of unit tests. As models are related to database access (either
    read or write access), those tests can have a performance impact. So be careful
    about reading and writing to the database for those tests. In some cases, you
    won''t be able to avoid calling `create`, `save`, `update`, or `find`, but you
    can in most. You should be able to rely on `new` instead of `create`, for example.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：测试（使用RSpec）专注于测试代码行为，而不是实现。这应该有助于编写快速测试。在Ruby on Rails项目中，模型是单元测试的主要来源。由于模型与数据库访问相关（无论是读取还是写入访问），这些测试可能会对性能产生影响。因此，在这些测试中谨慎读取和写入数据库。在某些情况下，你可能无法避免调用`create`，`save`，`update`或`find`，但你可以在大多数情况下依赖于`new`而不是`create`。
- en: 'Here is what an RSpec unit test for a Ruby on Rails model looks like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于Ruby on Rails模型的RSpec单元测试的示例：
- en: While those two examples are written a bit differently, they basically do the
    same thing. One has no description and reads pretty nicely still; the other one
    has a description but carries a bit of a duplication, don't you think?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个示例写法有些不同，但它们基本上是做同样的事情。一个没有描述，但读起来仍然很不错；另一个有描述，但有点重复，你觉得呢？
- en: Note that we use `User.new` to instantiate a user. This call doesn't require
    a read or write to the database. Since our `valid_email?` method only works with
    the instance's attributes, it won't slow the test down either.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用`User.new`来实例化一个用户。这个调用不需要读取或写入数据库。由于我们的`valid_email?`方法仅与实例的属性一起工作，它也不会使测试变慢。
- en: 'Those two are good unit tests: simple, focused, and fast.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是很好的单元测试：简单，专注，快速。
- en: 'Unit tests are not just for Ruby on Rails models. They are also good for any
    classes you build around models and the rest of an application''s architecture.
    We have specified the test `type` in the first line (`RSpec.describe User, type:
    :model`), but we can totally avoid that if we write tests for a plain Ruby class.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '单元测试不仅适用于Ruby on Rails模型。它们也适用于您围绕模型和应用程序架构的任何类。我们在第一行指定了测试的`type`（`RSpec.describe
    User, type: :model`），但如果我们为一个普通的Ruby类编写测试，完全可以避免这样做。'
- en: Controller and Request Specs
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器和请求规范
- en: Up until recently, controller tests were the main way to test controllers. Nowadays,
    we tend to rely on request specs instead. Similarly to controller tests, they
    are designed to test an application from a *machine client*. They allow us to
    test one, or multiple, controller action/s. They are tests, so we need to define
    a context, then our expectation. As they are functional tests, we have to define
    a context composed of a given HTTP verb (get, post, put, ...), a path (`/`, `/users`,
    ...), parameters, and (potentially) a body. The expectation is then focused on
    the response (HTTP status code, response/s header/s, and body).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，控制器测试是测试控制器的主要方式。如今，我们倾向于使用请求规范。与控制器测试类似，它们旨在从*机器客户端*的角度测试应用程序。它们允许我们测试一个或多个控制器操作。它们是测试，所以我们需要定义一个上下文，然后是我们的期望。由于它们是功能测试，所以我们必须定义一个由给定的HTTP动词（get、post、put等）、路径（`/`、`/users`等）、参数和（可能的）主体组成的上下文。然后，期望集中在响应上（HTTP状态码、响应头和主体）。
- en: With request specs, it's not a matter of UI or Javascript.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用请求规范，这不是UI或Javascript的问题。
- en: A simple request spec will look like this.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的请求规范看起来像这样。
- en: 'It''s simple, but you can see the context in the part doing the request: `get
    "/users/new"`. In turn, the expectation itself is centered on the response. We
    see a new matcher here, allowing us to test if a specific template is rendered.
    Another one (`redirect_to`) allows us to test that we are properly redirected.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但你可以在处理请求的部分看到上下文：`get "/users/new"`。反过来，期望本身集中在响应上。我们在这里看到了一个新的匹配器，允许我们测试特定模板是否被渲染。另一个（`redirect_to`）允许我们测试是否被正确重定向。
- en: Request specs can also be used to test more complex scenarios.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请求规范也可以用于测试更复杂的场景。
- en: However, request specs are better adapted to test behavior from a machine client's
    perspective. So, request specs are best used to test an API backend's controller
    parts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请求规范更适合从机器客户端的角度测试行为。因此，请求规范最适合用于测试API后端的控制器部分。
- en: While we haven't included any in this example, we can also express different
    contexts to test behaviors. The RSpec vocabulary and grammar still applies fully
    in that kind of spec. We merely use a bit more to handle the parts specific to
    making an HTTP request and its response.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这个示例中没有包含任何内容，但我们也可以表达不同的上下文以测试行为。RSpec词汇和语法仍然完全适用于那种类型的规范。我们只是稍微多用了一点来处理特定于发出HTTP请求及其响应的部分。
- en: System Specs
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统规范
- en: System specs are more complete integration tests than request ones. They are
    used to test an application in a real or headless browser, and require a driver
    for the browser (the default is Selenium; this can be changed).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: System specs are similar to request specs in concept, but with improved grammar
    to focus on a user's actions in the browser rather than the requests being made.
    Here is an example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that here, the context (verb, path, parameters) is defined underneath
    but still there: we *visit* a page, fill out a form (which sets parameters), and
    then click a button (trigger a POST request). Finally, the expectation is defined
    as the content of the page rendered. Indirectly, it''s still about testing the
    response''s content, although the browser interprets that.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Because system specs use and drive the complete stack, they are a lot slower
    than other specs. As such, they should be limited in number and potentially run
    at particular times within the CI pipeline.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Complimentary Test Types in Ruby
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, Ruby on Rails applications are composed of a few more components
    with specific roles: mailers, jobs, serializers, and decorators. Those require
    tests as well — ones closer to unit than integration tests. It can be useful to
    test out specifics regarding mailers and jobs.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Mailer Specs
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thanks to [ActiveMailer](https://github.com/expectedbehavior/active_mailer),
    Ruby on Rails has a simple way to abstract interactions with a third party that
    sends emails. Thus, instead of testing email sends, you can focus on testing what
    matters: behavior. In the case of emails, what matters is the subject, from and
    to addresses, and the body of the response.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Job Specs
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly, job specs allow you to test specific behavior around jobs: if they
    have been enqueued, performed, etc. This includes testing arguments using [Delayed
    Job](https://github.com/collectiveidea/delayed_job).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: We can be tempted to test ActiveJob's behavior. We do know that calling `perform`
    and `perform_later` bill queues a job; what we want to know is if, and when, that
    happens.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: So, you should test if a job is queued in contexts requiring it. Then, test
    that a job properly calls upon code that has its own unit tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: This expresses and tests a job's enqueued behavior with certain parameters when
    a specific method is called.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: A Note on Concerns in Ruby on Rails
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ruby on Rails has a way to factorize code used in multiple models or controllers
    through a [disguised Ruby module called a concern](https://blog.appsignal.com/2020/09/16/rails-concers-to-concern-or-not-to-concern.html).
    Concerns are a great way to avoid duplication of code. Make sure you test the
    content of concerns. Proper unit tests should also cover models. In the case of
    controllers, those are tested through request and system tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Some Thoughts on Testing with RSpec for Ruby
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's worth reiterating that your first layer of testing should be unit tests.
    Tests for models and other POROs should represent the vast majority of your tests
    in a code base.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Tests should run fast and avoid database and external services access as much
    as possible. To test the controller layer, request and system specs are best,
    respectively, for machine or human-driven activity on controller actions. They
    are slower than unit tests due to their inherent complexity, so there should be
    less of them than unit tests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Finally, components like mailers and jobs should be used wisely and in their
    specific context, not to test the behavior of the lower library (like ActiveMailer
    and ActiveJob).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in part one of this series, we can factorize a lot of code and avoid
    duplication by making use of RSpec''s basics: `before` and `after` hooks, `let`,
    and a proper structure built with `describe` and `context`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we took a deep dive into testing with RSpec for Ruby, focusing
    on unit, controller, and integration tests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: We have explored how it's usually easy to keep unit tests small, while minimizing
    request and system tests is more difficult. So, after you have written (and made
    green) system and request specs, don't hesitate to spend some time slimming them
    down. This will keep them readable and easier to maintain.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何通常可以轻松保持单元测试的规模较小，而尽量减少请求和系统测试则更为困难。因此，在编写（并通过）系统和请求规范之后，不要犹豫花一些时间将它们精简。这样可以保持它们的可读性，并更容易维护。
- en: Happy testing!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 测试愉快！
- en: '**P.S. If you''d like to read Ruby Magic posts as soon as they get off the
    press, [subscribe to our Ruby Magic newsletter and never miss a single post](https://blog.appsignal.com/ruby-magic)!**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**附：如果您想在文章发布后第一时间阅读 Ruby Magic 文章，[订阅我们的 Ruby Magic 通讯，永远不会错过任何一篇文章](https://blog.appsignal.com/ruby-magic)!**'
