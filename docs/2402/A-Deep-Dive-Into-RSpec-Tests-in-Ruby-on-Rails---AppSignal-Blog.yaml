- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:46:43'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: A Deep Dive Into RSpec Tests in Ruby on Rails | AppSignal Blog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.appsignal.com/2024/02/07/a-deep-dive-into-rspec-tests-in-ruby-on-rails.html](https://blog.appsignal.com/2024/02/07/a-deep-dive-into-rspec-tests-in-ruby-on-rails.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In our last post, we looked at the basics of RSpec and explored how well it
    works with Behavior Driven Development in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will look at specific types of RSpec tests for different parts of a
    Ruby on Rails application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive straight in!
  prefs: []
  type: TYPE_NORMAL
- en: Unit, Controller, and Integration Tests in Ruby on Rails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Ruby on Rails application is composed of several layers. As the framework
    is built around Models, Views, and Controllers, we might think of those three
    as the only layers of an application. Yet, often, that's barely enough to describe
    a Ruby on Rails application.
  prefs: []
  type: TYPE_NORMAL
- en: Mailers, Jobs, and Helpers are secondary layers we don't want to miss. When
    it comes to testing, it's important to remember that these components are largely
    impacted by how our code has been designed. Using [SOLID principles](https://en.wikipedia.org/wiki/SOLID)
    — particularly Single Responsibility — helps keep our code straightforward and
    more testable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we usually aim to keep things simple in views, controllers, models, jobs,
    and mailers: we want to assemble and use the bricks of code we have designed and
    tested separately already. Once we enter the realm of views and controllers, testing
    becomes much more complex, and slower too.'
  prefs: []
  type: TYPE_NORMAL
- en: Categories of Ruby Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, we split tests into these categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests** (models and other plain old Ruby objects — POROs): Ensure class
    methods are working as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller tests:** Test the expected outcome of controller actions (rendering
    the right template, redirections, and flash messages).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View tests:** (Used rarely) to test specific elements or content in views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helper tests:** For when you use a complex helper method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature or system tests:** Simulate user interactions in the browser — this
    is where Capybara will help.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request tests:** Test an application''s response to various HTTP verbs without
    browser overhead. This is faster than feature tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mailer and jobs tests:** Specific tests are needed for this secondary layer
    to ensure emails are sent properly with the right content and jobs trigger the
    appropriate work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing tests:** Complex routing is a code smell. Testing routes will help
    you avoid trouble when you have too many routes or routes that are too complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Kinds of Tests Should We Write?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Do we need to write all of these tests? It depends on your culture and team,
    but these might be good starting points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests:** Write focused and (as much as possible) database-dependent
    tests for your models'' public methods and other POROs you craft into your application;
    they should run fast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller tests:** Write tests that help ensure controller actions are routable
    and respond as expected for each context they could be in. These should not aim
    to test the whole response or complex scenarios made of multiple requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request tests:** Test request scenarios from a machine client (think API
    controllers), typically: "for a given HTTP request context (HTTP verb, path, and
    parameters), what HTTP response should we get?"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System tests:** Test scenarios of human user requests. Typically, this is
    where we want to test complex scenarios with multiple clicks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mailer and job tests:** These should only test that a mailer and job are
    doing the specific "mailer" and "job" work properly. In particular, for jobs,
    most of the "work" should be done through classes and methods tested separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Controller tests are often replaced by a good layer of request and system tests,
    as they ultimately serve the same purpose. Too many tests will cause fatigue in
    your team or slow down your whole test suite for little benefit. It''s up to you.
    The point is to test your controller layer: figure out which way is best in your
    case.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's see how unit, controller, and integration (both request and system) tests
    look.
  prefs: []
  type: TYPE_NORMAL
- en: Using RSpec and Ruby on Rails for Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As pointed out in [our previous post](https://blog.appsignal.com/2024/01/24/behaviour-driven-development-in-ruby-with-rspec.html),
    we can use the `rspec-rails` gem to integrate RSpec into a Ruby on Rails application's
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests are at the base of the [testing pyramid](https://www.headspin.io/blog/the-testing-pyramid-simplified-for-one-and-all),
    so there will be numerous unit tests in a codebase. They need to be fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: tests (with RSpec) are focused on testing code behavior, not implementation.
    That should help to write fast tests. In the case of Ruby on Rails projects, models
    are a big source of unit tests. As models are related to database access (either
    read or write access), those tests can have a performance impact. So be careful
    about reading and writing to the database for those tests. In some cases, you
    won''t be able to avoid calling `create`, `save`, `update`, or `find`, but you
    can in most. You should be able to rely on `new` instead of `create`, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what an RSpec unit test for a Ruby on Rails model looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: While those two examples are written a bit differently, they basically do the
    same thing. One has no description and reads pretty nicely still; the other one
    has a description but carries a bit of a duplication, don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use `User.new` to instantiate a user. This call doesn't require
    a read or write to the database. Since our `valid_email?` method only works with
    the instance's attributes, it won't slow the test down either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those two are good unit tests: simple, focused, and fast.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests are not just for Ruby on Rails models. They are also good for any
    classes you build around models and the rest of an application''s architecture.
    We have specified the test `type` in the first line (`RSpec.describe User, type:
    :model`), but we can totally avoid that if we write tests for a plain Ruby class.'
  prefs: []
  type: TYPE_NORMAL
- en: Controller and Request Specs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until recently, controller tests were the main way to test controllers. Nowadays,
    we tend to rely on request specs instead. Similarly to controller tests, they
    are designed to test an application from a *machine client*. They allow us to
    test one, or multiple, controller action/s. They are tests, so we need to define
    a context, then our expectation. As they are functional tests, we have to define
    a context composed of a given HTTP verb (get, post, put, ...), a path (`/`, `/users`,
    ...), parameters, and (potentially) a body. The expectation is then focused on
    the response (HTTP status code, response/s header/s, and body).
  prefs: []
  type: TYPE_NORMAL
- en: With request specs, it's not a matter of UI or Javascript.
  prefs: []
  type: TYPE_NORMAL
- en: A simple request spec will look like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s simple, but you can see the context in the part doing the request: `get
    "/users/new"`. In turn, the expectation itself is centered on the response. We
    see a new matcher here, allowing us to test if a specific template is rendered.
    Another one (`redirect_to`) allows us to test that we are properly redirected.'
  prefs: []
  type: TYPE_NORMAL
- en: Request specs can also be used to test more complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: However, request specs are better adapted to test behavior from a machine client's
    perspective. So, request specs are best used to test an API backend's controller
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: While we haven't included any in this example, we can also express different
    contexts to test behaviors. The RSpec vocabulary and grammar still applies fully
    in that kind of spec. We merely use a bit more to handle the parts specific to
    making an HTTP request and its response.
  prefs: []
  type: TYPE_NORMAL
- en: System Specs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System specs are more complete integration tests than request ones. They are
    used to test an application in a real or headless browser, and require a driver
    for the browser (the default is Selenium; this can be changed).
  prefs: []
  type: TYPE_NORMAL
- en: System specs are similar to request specs in concept, but with improved grammar
    to focus on a user's actions in the browser rather than the requests being made.
    Here is an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that here, the context (verb, path, parameters) is defined underneath
    but still there: we *visit* a page, fill out a form (which sets parameters), and
    then click a button (trigger a POST request). Finally, the expectation is defined
    as the content of the page rendered. Indirectly, it''s still about testing the
    response''s content, although the browser interprets that.'
  prefs: []
  type: TYPE_NORMAL
- en: Because system specs use and drive the complete stack, they are a lot slower
    than other specs. As such, they should be limited in number and potentially run
    at particular times within the CI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Complimentary Test Types in Ruby
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, Ruby on Rails applications are composed of a few more components
    with specific roles: mailers, jobs, serializers, and decorators. Those require
    tests as well — ones closer to unit than integration tests. It can be useful to
    test out specifics regarding mailers and jobs.'
  prefs: []
  type: TYPE_NORMAL
- en: Mailer Specs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thanks to [ActiveMailer](https://github.com/expectedbehavior/active_mailer),
    Ruby on Rails has a simple way to abstract interactions with a third party that
    sends emails. Thus, instead of testing email sends, you can focus on testing what
    matters: behavior. In the case of emails, what matters is the subject, from and
    to addresses, and the body of the response.'
  prefs: []
  type: TYPE_NORMAL
- en: Job Specs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly, job specs allow you to test specific behavior around jobs: if they
    have been enqueued, performed, etc. This includes testing arguments using [Delayed
    Job](https://github.com/collectiveidea/delayed_job).'
  prefs: []
  type: TYPE_NORMAL
- en: We can be tempted to test ActiveJob's behavior. We do know that calling `perform`
    and `perform_later` bill queues a job; what we want to know is if, and when, that
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: So, you should test if a job is queued in contexts requiring it. Then, test
    that a job properly calls upon code that has its own unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: This expresses and tests a job's enqueued behavior with certain parameters when
    a specific method is called.
  prefs: []
  type: TYPE_NORMAL
- en: A Note on Concerns in Ruby on Rails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ruby on Rails has a way to factorize code used in multiple models or controllers
    through a [disguised Ruby module called a concern](https://blog.appsignal.com/2020/09/16/rails-concers-to-concern-or-not-to-concern.html).
    Concerns are a great way to avoid duplication of code. Make sure you test the
    content of concerns. Proper unit tests should also cover models. In the case of
    controllers, those are tested through request and system tests.
  prefs: []
  type: TYPE_NORMAL
- en: Some Thoughts on Testing with RSpec for Ruby
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's worth reiterating that your first layer of testing should be unit tests.
    Tests for models and other POROs should represent the vast majority of your tests
    in a code base.
  prefs: []
  type: TYPE_NORMAL
- en: Tests should run fast and avoid database and external services access as much
    as possible. To test the controller layer, request and system specs are best,
    respectively, for machine or human-driven activity on controller actions. They
    are slower than unit tests due to their inherent complexity, so there should be
    less of them than unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, components like mailers and jobs should be used wisely and in their
    specific context, not to test the behavior of the lower library (like ActiveMailer
    and ActiveJob).
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in part one of this series, we can factorize a lot of code and avoid
    duplication by making use of RSpec''s basics: `before` and `after` hooks, `let`,
    and a proper structure built with `describe` and `context`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we took a deep dive into testing with RSpec for Ruby, focusing
    on unit, controller, and integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored how it's usually easy to keep unit tests small, while minimizing
    request and system tests is more difficult. So, after you have written (and made
    green) system and request specs, don't hesitate to spend some time slimming them
    down. This will keep them readable and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Happy testing!
  prefs: []
  type: TYPE_NORMAL
- en: '**P.S. If you''d like to read Ruby Magic posts as soon as they get off the
    press, [subscribe to our Ruby Magic newsletter and never miss a single post](https://blog.appsignal.com/ruby-magic)!**'
  prefs: []
  type: TYPE_NORMAL
