- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:59:43'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Snake Game Clone with Rust/Bevy | Brad Barrows' Blog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://bbarrows.com/posts/bevy-snake](https://bbarrows.com/posts/bevy-snake)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rust Practice with Bevy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bevy has an amazing dependency injection system that makes its "ECS" (Entity
    Component System) architecture very easy and ituitive to use. Really the DI system
    is one of the most amazing Rust feats that I have seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: Someone has taken the time to document how to create your own [Bevy based DI
    system here which is a great read](https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html)
  prefs: []
  type: TYPE_NORMAL
- en: There is also an unofficial Bevy book that is really helpful [here](https://bevy-cheatbook.github.io/programming/intro-data.html)
  prefs: []
  type: TYPE_NORMAL
- en: Bevy and ECS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECS is documented [here](https://bevyengine.org/learn/quick-start/getting-started/ecs/)
    It describes some of the basic concepts of how the Bevy game engine works. Combined
    with a powerful dependency injection (DI) system, Bevy is powerful, easy to work
    with, and fun to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'For my snake game I only needed the concept of three entities really: the snake,
    the food, and the snake''s body.'
  prefs: []
  type: TYPE_NORMAL
- en: This is done by the C part of ECS. I create a Component for each. This allows
    me to, later on, using the DI/query system executed on each game loop, to find
    all the entities of a certain type and do something with them.
  prefs: []
  type: TYPE_NORMAL
- en: On setup, I create the snake and the food using a spawn command. It takes a
    tuple where I can provide multiple Components that make up whatever entity I am
    creating.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the described objects above have a visual aspect for example, so each
    have a 2D mesh (which includes a transform/translation aka location).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where I create the SnakeHead for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The most amazing part of Bevy though that I have found so far is its "query"/DI
    system. With types and traits, I can query for all the entities of a certain type
    and do something with them each step of the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the function signature I have for checking for collisions for ex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function signature can be however long.
  prefs: []
  type: TYPE_NORMAL
- en: The DI system will provide me with whatever objects I need. Commands, meshes,
    materials, etc.. As well as decipher a simple to work with type system to provide
    me with all the entities that match a specific query.
  prefs: []
  type: TYPE_NORMAL
- en: For example, with the snake body. I want to be able to move each one and also
    remove them if the snake crashes. To move them I just need their Transform (part
    of what was provided from the MaterialMesh2dBundle during setup) and the Entity
    itself so I can send a command to despawn them or remove body parts from the game.
  prefs: []
  type: TYPE_NORMAL
- en: The DI system that powers all this is amazing to me. I had no idea this could
    be accomplished in Rust until someone from the Bevy Discord chat kindly pointed
    me to this documentation which breaks down [how it all works](https://promethia-27.github.io/dependency_injection_like_bevy_from_scratch/chapter1/system.html).
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Learning the Complicated Macros from the DI System Mentioned Above
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you take the example from the end of page 3 in the DI like Bevy from Scratch
    book, you can use cargo expand to see what the macro is doing.
  prefs: []
  type: TYPE_NORMAL
- en: I created a new project and added the macro to the main.rs file. Then I ran
    cargo expand and it showed me the expanded macro created unsugared Rust code which
    made understanding the macros and the documentation much easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install cargo expand run: `cargo install cargo-expand`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code I ran `cargo expand > expanded.rs` on is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: My Snake Clone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can be found [here](https://github.com/bebrws/bevy-snake)
  prefs: []
  type: TYPE_NORMAL
- en: And Compiled to WASM and Played Here! (Only on WASM supported browsers - so
    no mobile)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <canvas id="bevy-portal" tabindex="0" data-raw-handle="1" alt="app" cursor="auto"></canvas>
  prefs: []
  type: TYPE_NORMAL
