- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:04:14'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: TCP Puzzlers | Triton DataCenter
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.tritondatacenter.com/blog/tcp-puzzlers](https://www.tritondatacenter.com/blog/tcp-puzzlers)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It's been said that we don't really understand a system until we understand
    how it fails. Despite having written a (toy) TCP implementation in college and
    then working for several years in industry, I'm continuing to learn more deeply
    how TCP works — and how it fails. What's been most surprising is how basic some
    of these failures are. They're not at all obscure. I'm presenting them here as
    puzzlers, in the fashion of [Car Talk](http://www.cartalk.com/content/puzzlers)
    and the [old Java puzzlers](https://www.youtube.com/watch?v=wbp-3BJWsU8). Like
    the best of those puzzlers, these are questions that are very simple to articulate,
    but the solutions are often surprising. And rather than focusing on arcane details,
    they hopefully elucidate some deep principles about how TCP works.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  id: totrans-split-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These puzzlers assume some basic knowledge about working with TCP on Unix-like
    systems, but you don''t have to have mastered any of this before diving in. As
    a refresher:'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: TCP states, the three-way handshake used to establish a connection, and the
    way connections are terminated are described pretty concisely on the [TCP Wikipedia
    page](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Protocol_operation).
  id: totrans-split-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs typically interact with sockets using `read`, `write`, `connect`, `bind`,
    `listen`, and `accept`. There's also `send` and `recv`, but for our purposes,
    these work the same way as `read` and `write`.
  id: totrans-split-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I''ll be talking about programs that use `poll`. Although most systems use
    something more efficient like `kqueue`, event ports, or `epoll`, these are all
    equivalent for our purposes. As for applications that use blocking operations
    instead of any of these mechanisms: once you understand how TCP failure modes
    affect poll, it''s pretty easy to understand how it affects blocking operations
    as well.'
  id: totrans-split-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try all of these examples yourself. I used two virtual machines running
    under VMware Fusion. The results match my experiences in our production systems.
    I'm testing using the `nc(1)` tool on SmartOS, and I don't believe any of the
    behavior shown here is OS-specific. I'm using the illumos-specific [truss(1)](http://illumos.org/man/truss)
    tool to trace system calls and to get some coarse timing information. You may
    be able to get similar information using [dtruss(1m)](https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/dtruss.1m.html)
    on OS X or [strace(1)](http://linux.die.net/man/1/strace) on GNU/Linux.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: '`nc(1)` is a pretty simple tool. We''ll use it in two modes:'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: As a server. In this mode, `nc` will set up a listening socket, call `accept`,
    and block until a connection is received.
  id: totrans-split-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a client. In this mode, `nc` will create a socket and establish a connection
    to a remote server.
  id: totrans-split-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both modes, once connected, each side uses `poll` to wait for either stdin
    or the connected socket to have data ready to be read. Incoming data is printed
    to the terminal. Data you type into the terminal is sent over the socket. Upon
    CTRL-C, the socket is closed and the process exits.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, my client is called `kang` and my server is called `kodos`.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Warmup: Normal TCP teardown'
  id: totrans-split-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This one demonstrates a very basic case just to get the ball rolling. Suppose
    we set up a server on `kodos`:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: (Remember, in these examples, I'm using `truss` to print out the system calls
    that `nc` makes. The `-d` flag prints a relative timestamp and the `-t` flag selects
    which system calls we want to see.)
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Now on `kang`, I establish a connection:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: Client
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Over on kodos, we see:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, the TCP connections are in state ESTABLISHED and both processes
    are in `poll`. We can see this using the `netstat` tool on each system:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Client
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The question is, **when we shut down one of these processes, what happens in
    the other process?** Does it find out? How? Try to predict the specific syscall
    behavior and explain why each system call does what it does.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it. I''ll CTRL-C the server on kodos:'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s what we see on `kang`:'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: Client
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What happened here? Let''s be specific:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: We sent SIGINT to the server, causing the process to exit. Upon exit, file descriptors
    are closed.
  id: totrans-split-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the last file descriptor for an `ESTABLISHED` socket is closed, the TCP
    stack on kodos sends a FIN over the connection and enters the `FIN_WAIT_1` state.
  id: totrans-split-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TCP stack on kang receives the FIN packet, transitions its own connection
    to `CLOSE_WAIT`, and sends an ACK back. Since the `nc` client is blocked on this
    socket being ready to read, the kernel wakes this thread with the event `POLLIN`.
  id: totrans-split-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `nc` client sees `POLLIN` for the socket and calls `read`, which returns
    0 immediately. This indicates end-of-stream. `nc` presumes that we're done with
    this socket and closes it.
  id: totrans-split-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Meanwhile, the TCP stack on kodos receives the ACK and enters `FIN_WAIT_2`.
  id: totrans-split-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the `nc` client on kang closed its socket, the TCP stack on kang sent
    a FIN to `kodos`. The connection on kang enters `LAST_ACK`.
  id: totrans-split-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TCP stack on kodos receives the FIN, the connection enters `TIME_WAIT`,
    and the stack on kodos acknowledges the FIN.
  id: totrans-split-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TCP stack on kang receives the ACK for the FIN and removes the connection
    entirely.
  id: totrans-split-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two minutes later, the TCP connection on kodos is closed and the stack removes
    the connection entirely.
  id: totrans-split-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (It's possible for steps to be slightly reordered and for kang to transition
    through `CLOSING` instead of `FIN_WAIT_2`.)
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the final state according to netstat:'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's no output for this connection at all on kang.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: The intermediate states transition very quickly, but you could see them using
    the [DTrace TCP provider](http://dtracebook.com/index.php/Network_Lower_Level_Protocols:tcpstate.d).
    You can see the packet flow using [snoop(1m)](http://illumos.org/man/snoop) or
    [tcpdump(1)](http://www.tcpdump.org/tcpdump_man.html).
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusions:** We''ve seen the normal path of system calls for connection
    establishment and teardown. Note that kang immediately found out when kodos''s
    connection was closed — it was woken up out of `poll` and `read` returned 0 to
    indicate end-of-stream. At that point, kang *elected* to close its socket, which
    cleaned up the connection state on kodos. We''ll revisit this later to see how
    the results can differ if kang doesn''t close its socket here.'
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Puzzler 1: Power cycling'
  id: totrans-split-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What happens to an established, idle TCP connection if one system is power
    cycled?**'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: Since most processes go through normal exit as part of a graceful reboot (e.g.,
    if you use the "reboot" command), you get basically the same result if you type
    "reboot" on kodos instead of killing the server with CTRL-C. But what would happen
    if we'd power-cycled kodos in the previous example? Surely kang will eventually
    find out, right?
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it. Set up the connection:'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Client
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now I'll use VMware's "reboot" function to power-cycle the system. It's important
    that this be an actual power cycle (or OS panic) — anything that causes a graceful
    shut down will look more like the first case above.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: '20 minutes later, kang is still sitting in the same place:'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: Client
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We tend to believe that TCP''s job is to maintain a consistent abstraction
    (namely, the TCP connection) across multiple systems, so it''s surprising to discover
    cases where the abstraction is broken like this. And lest you think this is some
    nc(1) issue, it''s not. "netstat" on kodos shows no connection to kang, but kang
    shows a perfectly healthy connection to kodos:'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: Client
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can leave this forever without touching it and kang will *never* figure out
    that kodos rebooted.
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: '**Now, suppose at this point, kang tries to send data to kodos. What happens?**'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it:'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: Client
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When I type the message and hit enter, kodos gets woken up, reads the message
    from stdin, and sends it over the socket. *The `write` call completes successfully!*
    `nc` goes back to poll to wait for another event, eventually finds out that the
    socket can be read without blocking, and then calls `read`. This time, `read`
    fails with `ECONNRESET`. What does this mean? [POSIX''s definition of read(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/read.html)
    says that this means:'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-split-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The [illumos read(2) man page](http://illumos.org/man/read.2) provides a little
    more context:'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-split-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This error doesn't mean that something specific to the `read` call went wrong,
    but rather that the socket itself is disconnected. Most other socket operations
    would fail the same way at that point.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: So what happened here? At the point when the `nc` on kang tried to send data,
    the TCP stack still didn't know the connection was dead. kang sent a data packet
    over to kodos, which responded with an RST because it didn't know anything about
    the connection. kang saw the RST and tore down its connection. It cannot close
    the socket file descriptor — that's not how file descriptors work — but subsequent
    operations fail with ECONNRESET until nc does close the fd.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusions:**'
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: A hard power-cycle is very different than a graceful shutdown. When testing
    distributed systems, this case needs to be specifically tested. You can't just
    kill a process and expect it to test the same thing.
  id: totrans-split-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**There are situations when one side believes a TCP connection is established,
    but the other side does not, and where this situation will never be automatically
    resolved.** It''s possible to manage this problem using TCP or application-level
    keep-alive.'
  id: totrans-split-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only reason that kang eventually found out that the remote side had disappeared
    was that it took action: it sent data and received a response indicating the connection
    was gone.'
  id: totrans-split-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That raises the question: what if kodos had not responded to the data message
    for some reason?'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Puzzler 2: Power off'
  id: totrans-split-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**What happens if one endpoint of a TCP connection is powered off for a while?**
    Does the other endpoint ever discover this? If so, how? And when?'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, I''ll set up the connection with `nc`:'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-split-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Client
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-split-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, I''ll cut power to kodos abruptly and attempt to send data from kang:'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
- en: Client
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-split-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `write` completes normally, and I don''t see anything for quite a while.
    Just over 5 minutes later, I see this:'
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
- en: Client
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-split-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This looks similar to the case where the system was power-cycled instead of
    powered off, except for two things: it took 5 minutes for the system to notice,
    and the error reported was ETIMEDOUT. Note that again, it''s not that the `read`
    timed out per se. We would have seen the same error from other socket operations,
    and subsequent socket operations would likely fail immediately with the same ETIMEDOUT
    error. That''s because it''s the *socket* that has entered a state where the underlying
    connection has timed out. The specific reason for this is that the remote side
    failed to acknowledge a data packet for too long — 5 minutes, as configured on
    this system.'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusions:**'
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
- en: When the remote system is powered off instead of power cycled, again, the first
    system only finds out if it's trying to send data. If it doesn't send packets,
    it will never find out about the terminated connections.
  id: totrans-split-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the system has been attempting to send data for long enough without receiving
    acknowledgments from the remote side, the TCP connection will be terminated and
    a socket operation on them will fail with ETIMEDOUT.
  id: totrans-split-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Puzzler 3: Broken connection with no failure'
  id: totrans-split-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time, instead of giving you a specific case and asking what happens, I''ll
    flip it around: here''s an observation, and see if you can figure out how it could
    happen. We''ve discussed several cases where kang can believe it has a connection
    to kodos, but kodos doesn''t know about it. **Is it possible for kang to have
    a connection to kodos without kodos knowing about it — indefinitely (i.e., where
    this will not resolve itself) and even if there''s been no power off, no power
    cycle, and no other failure of the operating system on kodos and no failure of
    networking equipment?**'
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a hint: consider the case above where a connection is stuck in `ESTABLISHED`.
    In that case, it''s fair to say that the application has the responsibility to
    deal with the problem, since by definition it still has the socket open and could
    find out by sending data, at which point the connection will eventually be terminated.
    But what if the application didn''t have the socket open any more?'
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
- en: In the Warmup, we looked at the case where kodos's `nc` closed its socket, and
    we said that kang's `nc` read 0 (indicating end-of-stream) and then closed its
    socket. What if it didn't close the socket, but kept it open? Obviously, it couldn't
    read from it. But there's nothing about TCP that says you can't send more data
    to the other side that has sent you a FIN. **FIN only means end-of-data-stream
    in the direction that the FIN was sent.**
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate this, we can't use `nc` on kang because it automatically
    closes its socket when it reads 0\. So I've written a demo version of `nc` called
    [dnc](https://github.com/davepacheco/experiment-dnc), which simply skips this
    behavior. It also prints out explicitly which system calls it's making. This will
    give us a chance to observe the TCP states.
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll set up the connections as usual:'
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-split-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Client
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-split-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let''s verify the connections are in the `ESTABLISHED` state we expect
    on both sides:'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-split-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Client
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-split-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s CTRL-C the `nc` process on kodos:'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-split-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We immediately see this on kang:'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
- en: Client
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-split-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s look at the TCP connection states:'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-split-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Client
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-split-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This makes sense: kodos sent a FIN to kang. `FIN_WAIT_2` indicates that kodos
    received an ACK from kang for the FIN that it sent, and `CLOSE_WAIT` indicates
    that kang received the FIN *but has not sent a FIN back*. **This is a perfectly
    valid state for a TCP connection for an indefinite period of time.** Imagine kodos
    had sent a request to kang and was not planning to send any more requests; kang
    could happily send data in response for hours, and this would work. Only in our
    case, kodos *has* actually closed the socket.'
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s wait a minute and check the TCP connection states again. A minute later,
    the connection is completely missing from kodos, but it''s still present on kang:'
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
- en: Client
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-split-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'What happened here? We hit a lesser-known special case in the TCP stack: when
    an application has closed a socket, the TCP stack has sent a FIN, and the remote
    TCP stack has acknowledged the FIN, the local TCP stack waits a fixed period of
    time *and then closes the connection*. The reason? In case the remote side has
    rebooted. This case is actually an analog to the case above where one side had
    an `ESTABLISHED` connection and the other doesn''t know about it. The difference
    is that in this specific case, the application has closed the socket, so there''s
    no other component that could deal with the problem. As a result, the TCP stack
    waits a fixed period of time and then tears down the connection (without sending
    anything to the other side).'
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？我们遇到了 TCP 栈中一个不太为人知的特殊情况：当应用程序关闭了一个套接字后，TCP 栈发送了一个 FIN，远程 TCP 栈确认了 FIN，本地
    TCP 栈等待了一个固定的时间，然后 *关闭连接*。为什么要这样做呢？以防远程端重新启动。这种情况实际上类似于上面一个情况，其中一方有一个 `ESTABLISHED`
    连接，而另一方却不知道。不同之处在于，在这种特定情况下，应用程序已经关闭了套接字，因此没有其他组件可以处理这个问题。结果是，TCP 栈等待了一段固定的时间，然后关闭连接（而不向另一端发送任何内容）。
- en: 'Follow-up question: **what happens if kang sends data to kodos at this point?**
    Remember, kang still thinks the connection is open, but it''s been torn down on
    kodos.'
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 跟进问题：**如果 kang 在这一点向 kodos 发送数据会发生什么？**请记住，kang 仍然认为连接是打开的，但在 kodos 上已经被拆除。
- en: Client
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端
- en: '[PRE28]'
  id: totrans-split-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the same as we saw in case Puzzler 1: the `write()` actually succeeds,
    since the TCP stack doesn''t know that the connection is closed yet. But it does
    get a RST, which wakes up the thread in `poll()`, and the subsequent `read()`
    returns ECONNRESET.'
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在谜题1中看到的情况相同：`write()` 实际上成功了，因为 TCP 栈还不知道连接已经关闭。但它确实收到了一个 RST，这会唤醒 `poll()`
    中的线程，随后的 `read()` 返回 ECONNRESET。
- en: '**Conclusions:**'
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论：**'
- en: It's possible for two sides to disagree about the state of the connection *even
    when there's been no OS, network, or hardware failure at all*.
  id: totrans-split-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 甚至在没有任何操作系统、网络或硬件故障的情况下，两个方面对于连接的状态可能会产生分歧。
- en: In a case like the one above, it's not possible for kang to distinguish between
    the case where kodos is attentively waiting to receive data or kodos has closed
    the socket and isn't listening (at least, not without sending a packet). For this
    reason, maybe it's not a great idea to design a system that uses sockets in these
    half-open states for an extended period of time under normal operation.
  id: totrans-split-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在像上面那种情况下，kang 不可能区分 kodos 是在专心等待接收数据，还是 kodos 已经关闭了套接字而不再监听（至少，没有发送数据包的情况下）。因此，也许设计一个在正常操作期间使用这些半开放状态的套接字的系统并不是一个好主意。
- en: Conclusions
  id: totrans-split-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: 'TCP is typically presented as a protocol for maintaining a consistent abstraction
    — the "TCP connection" — across two systems. We know that in the face of certain
    types of network and software problems, connections will fail, but it''s not always
    obvious that there are cases where the *abstraction* fails, in that the two systems
    disagree about the state of the connection. Specifically:'
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 通常被描述为在两个系统之间维护一致的抽象——"TCP 连接"——的协议。我们知道，在面对某些类型的网络和软件问题时，连接会失败，但并不总是明显地看到抽象失败的情况，即两个系统在连接状态上有分歧。具体而言：
- en: It's possible for one system to think it has a working, established TCP connection
    to a remote system, while the remote system knows nothing about that connection.
  id: totrans-split-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能一个系统认为它与远程系统有一个正常工作的已建立的 TCP 连接，而远程系统对这个连接一无所知。
- en: This is possible even when there has been no failure of the network, hardware,
    or operating system.
  id: totrans-split-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在没有网络、硬件或操作系统故障的情况下，这种情况也是可能的。
- en: These behaviors do not reflect deficiencies in TCP. Quite the contrary, in all
    of these cases, the TCP implementation appears to behave as reasonably as it could
    given the situation. If we were tempted to implement our own communication mechanism
    instead of using TCP, the presence of these cases might well remind us how complex
    the underlying problems are. These are intrinsic problems with distributed systems,
    and a TCP connection is fundamentally a distributed system.
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行为并不反映 TCP 的缺陷。恰恰相反，在所有这些情况中，TCP 的实现似乎都表现得尽可能合理。如果我们试图实现自己的通信机制而不使用 TCP，这些情况的存在可能会提醒我们底层问题的复杂性。这些都是分布式系统的固有问题，而
    TCP 连接本质上就是一个分布式系统。
- en: That said, the single most important lesson in all of this is that **the notion
    of a TCP connection that spans multiple systems is a convenient fiction.** When
    it goes wrong, it's critical to think about it as two separate state machines
    that operate simultaneously to try to maintain a consistent view of the connection.
    It's the responsibility of the application to handle the cases where these differ
    (often using a keep-alive mechanism).
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，所有这些中最重要的一课是**跨多个系统的TCP连接这一概念是一个方便的虚构**。当出现问题时，关键是将其视为两个独立的状态机，它们同时操作以尝试维护连接的一致视图。应用程序有责任处理这些不同之处（通常使用保持活动机制）。
- en: Furthermore, there's a disconnect between the application's file descriptor
    and the underlying TCP connection. TCP connections exist (in various states related
    to closing) even after an application has closed the file descriptor, and a file
    descriptor can be open when the underlying TCP connection has been closed as a
    result of a failure.
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应用程序的文件描述符与底层的TCP连接之间存在断开。即使应用程序关闭了文件描述符，TCP连接（与关闭相关的各种状态）仍然存在，并且由于故障，当底层TCP连接关闭时文件描述符可以打开。
- en: 'Other lessons to keep in mind:'
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: 其他需要牢记的教训包括：
- en: Ungraceful reboot of a system (as happens when the OS crashes) is not the same
    as a userland process exiting or closing its socket. It's important to test this
    case specifically. Reboot, when the remote system comes back online before the
    connection times out, is also different than power-off.
  id: totrans-split-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的非优雅重新启动（当操作系统崩溃时会发生）与用户进程退出或关闭其套接字不同。特别是要测试这种情况。在远程系统在连接超时之前重新上线时重启，与关机也是不同的。
- en: There's no proactive notification from the kernel when a TCP socket is torn
    down. You only find this out when you call `read()`, `write()`, or some other
    socket operation on the socket file descriptor. If your program doesn't do this
    for some reason, you'll never find out about the connection failure.
  id: totrans-split-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当TCP套接字关闭时，内核没有主动通知。你只有在对套接字文件描述符调用 `read()`、`write()` 或其他套接字操作时才能发现这一点。如果由于某种原因你的程序没有这样做，你将永远不会发现连接失败。
- en: 'Some related notes that I''ve found aren''t so commonly known:'
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一些相关的笔记，我发现并不那么常见：
- en: '`ECONNRESET` is a socket error you can see from `read()`, `write()`, and other
    operations that indicates that the remote peer has sent a RST.'
  id: totrans-split-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ECONNRESET` 是一个套接字错误，你可以在 `read()`、`write()` 和其他操作中看到，表明远程对等方已发送RST。'
- en: '`ETIMEDOUT` is a socket error you can see from `read()`, `write()`, and other
    operations that indicates that some timeout associated with the connection has
    elapsed. The cases I''ve seen most are when the remote side did not acknowledge
    some packet for too long. These are usually either data packets, a FIN packet,
    or a KeepAlive probe.'
  id: totrans-split-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ETIMEDOUT` 是一个套接字错误，你可以在 `read()`、`write()` 和其他操作中看到，表明连接相关的某个超时已经过去。我见过的情况大多数是远程端太长时间没有确认某个数据包。这些通常是数据包、FIN包或者KeepAlive探测。'
- en: Importantly, neither of these errors means that there was anything wrong with
    the read or write operation that you tried to do — just that the socket itself
    is closed.
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，这些错误都不意味着你尝试做的读取或写入操作有任何问题 — 只是套接字本身已关闭。
- en: If you made it this far, and this sort of problem sounds interesting to you,
    [we're hiring](https://www.joyent.com/about/careers)!
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读到这里，并且这类问题听起来对你有趣，[我们正在招聘](https://www.joyent.com/about/careers)!
- en: '*Post written by Dave Pacheco*'
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dave Pacheco 撰写*'
