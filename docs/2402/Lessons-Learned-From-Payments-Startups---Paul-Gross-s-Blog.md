<!--yml

category: 未分类

date: 2024-05-27 14:40:39

-->

# 支付初创公司的经验教训 - 保罗·格罗斯的博客

> 来源：[https://www.pgrs.net/2024/01/26/lessons-learned-from-payemnts-startups/](https://www.pgrs.net/2024/01/26/lessons-learned-from-payemnts-startups/)

在我迄今为止的职业生涯中，我参与了许多支付公司，包括几家初创公司。在最后一家初创公司，我参与了从头开始构建支付平台（从第一行代码开始）。本文是我的思考和经验教训的集合。希望这些内容对其他人也有所帮助。

各个部分相对独立，因此这里是一些快速链接：

每个新工具、语言、数据库等都会增加大量复杂性。您需要设置和管理它（即使是托管的服务仍然需要工作），与其集成，了解其内部（通常是在某种方式失败之后），并且您会发现一些您甚至不知道需要考虑的事情。

因此，在我寻找新东西之前，我会尽量使用我们已经拥有的，即使这不是最优的选择。例如，我的项目经常使用 [PostgreSQL](https://www.postgresql.org/) 作为数据库。PostgreSQL 功能非常全面，因此我尽量在尽可能多的地方使用它。这包括作业队列、搜索，甚至简单的缓存（例如存储临时值并随时间清除的表）。这些可能并不是最理想的平台，但管理一个数据库比整套数据系统要容易得多。即使在某些时候，应用程序会超出 PostgreSQL 在某些方面的能力，但推迟做出这些决定和工作也是非常有价值的。

引入新语言和框架也是如此。在可能的情况下，我喜欢使用我们已经有的东西，只有在把现有的东西推到极限之后才会引入新的东西。

另一个优势是随着时间的推移，许多软件变得过时，但并未被移除。某些产品或功能不再维护，但由于仍在使用中，因此并未完全关闭或删除。留下过时的代码和服务已经很糟糕，但更糟糕的是，现在可能会有额外的数据库或其他平台系统仍然需要维护，但却没有提供任何当前价值。即使是过时的系统，仍然需要安全升级、迁移到新服务器等操作。

## 优化变更

这在初创公司尤为真实，但实际上，变更是任何软件项目的一部分。需求变化，我们对问题的理解变化，技术变化，甚至公司的重心都可能变化。因此，确保软件能够随之变化非常重要。有时这是主观的（哪种架构最容易变更），而有时则是具体的。

例如，我曾参与开发过一个系统，其中既有客户安装的本地系统，也有云托管的系统。本地系统因为要求客户自行升级（通常按照他们自己的时间表），所以极其难以更改。相比之下，云托管系统完全受我们控制。因此，优化变化意味着尽可能多地将事物放入云托管系统，并保持本地部分精简。这样，我们需要更少地更改难以更改的部分，并且可以按照我们自己的时间表推出尽可能多的更改。

优化变化还可以帮助架构讨论和决策。在选择不同方案时，选择后期易于变更的方案可能会有所帮助。当撤销这种变更的成本不那么高时，尝试新事物会更容易。如果新的框架或工具不起作用，你可以切换回来或者转向其他新事物。

在我看来，为了优化变化，保持事物尽可能简单是最好的方法之一。有时候，人们会过度设计当前系统，试图预测它们未来的演变，并在现在就试图未雨绸缪。一个例子就是在今天只有一种类型时就将事物设计得过于通用。我认为这是一个错误。我们对事物变化的猜测通常是错误的，而改变简单系统要比复杂系统容易得多。今天维护一个简单的系统也比带着过度设计的包袱容易得多。

## 专注于迭代

能够将工作分解成小的、可交付的部分非常重要。我见过太多项目数月未展示任何价值。有时候最终确实会交付，但也可能会被取消或者大幅修改。逐步发布要好得多，即使它还没有完全成型。特性标志和其他部分发布特性的方式在这里非常好用。它能让你从一部分客户或者内部人士那里得到生产反馈。它还能让长期项目中的进展可见。

我发现，如果人们能够随着时间看到可见的进展，而不是模糊的未来交付日期，那么对软件估算和交付时间表的许多挫败感会消失。

我希望有一个更好的解决方案来使特性的稳定性更加明显。例如，我希望快速发布以获得反馈，但随后仍然能够更改该特性或API。然而，一旦客户开始使用某些功能，他们通常会默认认为它不会改变。

希望能找到一种方法来标记特性或API为alpha、beta、stable等，并设定清晰的特性期望和时间框架。例如，鼓励客户试用alpha API，但知道它将会变化，他们需要定期更新集成。就我个人而言，我还没有看到这方面的超级好的做法。

## 测试

测试代码非常有价值，有许多不同的方法，各有不同的权衡。这个话题可以说很多，但我只想提到我一直在思考的一个方面：在测试速度和质量之间保持平衡。

一般来说，拥有大量的测试能让你有信心进行更改。如果一个大而全面的测试套件通过了，你可以相当确信你没有破坏任何东西。它甚至可以让你有信心升级核心组件，如应用框架或语言版本。

然而，测试越多，运行速度就会越慢。从最初几秒钟的套件开始，如果不小心的话很容易变成几分钟甚至更长时间。解决这个问题的一种方法是尝试将测试与其他系统隔离开来，通常使用模拟。例如，在没有数据库的情况下测试业务逻辑的核心，或者在没有实际打开连接并进行API调用的情况下测试API，或者模拟第三方系统的响应。

但这里的权衡是，当你为了加快测试速度而孤立测试时，你可能也会使它们不太现实，也不太能够捕捉问题。基于模拟的测试速度快，但也许模拟在某些边缘情况下不会像真实组件那样工作。

或者你想要改变组件之间的交互方式，现在你必须更新数百个设置了测试模拟的情况。

对于这个问题，我没有一个很好的答案。我尽量在可能的情况下将代码与外部依赖隔离开来（例如，通过将业务逻辑编写为简单函数，以其数据作为输入）。至于在边缘或测试交互时的其余部分，我只是尽量考虑我们在测试速度与准确性之间做的权衡。我也倾向于使用伪造物而不是模拟物，其中你有一个在许多测试中使用的基本稳定的替身，而不是为每个测试设置模拟期望。

## 模块化单体

其他地方已经对模块化单体架构说了很多，所以我只想补充说我真的喜欢这种方法。软件系统的最终接缝很难预测，而且小团队要同时处理许多独立服务（包括托管、部署、监控、升级等）也很难。

在最近我们使用单体架构的案例中，我认为效果非常好。将来从单体中拆分服务总是需要付出一定的努力，但我们可以尝试在单体内部进行代码分离，以帮助使其更容易（并且明确我们对什么是独立领域的思考）。我们将这些决策推迟到以后，这样我们现在可以更快地专注于构建（这对初创公司尤为重要）。

## 把一切都放在数据库里

我非常喜欢将几乎所有东西存储在数据库中。我发现，如果能够查询所有相关数据，这样做会使理解和调试变得更加容易。通常，我会更喜欢数据库而不是日志记录，因为你不能轻易地将日志与存储的数据进行关联（例如[存储外部请求](/2023/12/14/storing-external-requests/)）。

例如，在支付系统中，支付通常会通过许多不同的状态。在数据库中有条目代表发生了什么变化以及何时发生变化非常有帮助，即使只有最终状态是重要的。然后，在尝试调试为什么支付处于奇怪状态时，我们可以在一个地方查看所有相关数据的所有表中的数据（例如在事件或审计表中）。

添加一个唯一的请求标识符会使其更加有用。然后，您可以将失败的API请求与其所有数据库记录关联起来。

然而，随着数据量的真正增长，存在实际考虑因素。我使用过的一种策略是将部分数据存储时间缩短。例如，类似日志的数据可能只有几周有用，因此在那之后可以删除它。或者将其导出到文件并单独存档。

另一个问题是个人身份信息（PII）。通常存在这类数据的法律和道德要求，因此需要具体情况具体分析。有时，仍然可以存储它，但仅有短暂时间。其他时候，应该清除或从数据库中排除。

## 使数据库查询变得简单

一旦将所有内容存入数据库，我发现让人们轻松查询是非常有帮助的。最近，我使用了[Metabase](https://github.com/metabase/metabase)，并且真的很喜欢它如何允许轻松地基于Web进行查询和图形化我们的数据。我们将其设置为与只读连接到读副本，因此几乎没有影响生产或意外更改数据的担忧。我们发现开发人员和非技术人员都广泛使用它。

例如，我们创建了仪表板，您可以输入`orderId`，并查看存储关联数据的所有表中的所有数据。这对于调试和支持人员非常有价值。

同样，有考虑谁可以看到数据以及看到多少的问题。但总的来说，让人们能够自己回答他们的数据问题非常强大，并且减轻了开发者的负担。构建共享仪表板和图表，以便每个人都可以观看相同的指标，非常有力量。

## 作业排水模式

一旦系统发展超出单一数据库，数据一致性问题就会开始出现。即使引入后台作业系统或搜索工具也会显示问题。例如，主数据库已写入，但复制到搜索工具的过程失败了。或者后台作业在主数据库提交之前排队了。

有各种方法可以解决这个问题，特别是我喜欢工作排水模式，详细介绍在[Postgres中的事务式工作排水](https://brandur.org/job-drain)。我在几个不同的项目上成功使用过这种模式。

## 检查生成的文件

将一切放入数据库的做法与将一切放入git类似。对我来说，这包括尽可能包括生成的文件。我知道很多生态系统更喜欢仅在构建时生成到临时目录，但我真的喜欢将它们放入git中。在进行更改时，比如升级生成库或代码时，我发现能够对比这些文件非常有用。否则，很难确定是否有任何重要的更改，或者更改是否超出预期。

当使用[Gradle](https://gradle.org)时，我还喜欢提交生成的[锁定文件](https://docs.gradle.org/current/userguide/dependency_locking.html)，这些文件指定了每个传递依赖的确切版本。然后，当[Dependabot](https://docs.github.com/en/code-security/dependabot)/[Renovate](https://github.com/renovatebot/renovate)/等执行自动升级时，很容易看到哪些传递依赖项也发生了变化。

## 决策日志

总体来说，我认为很多内部文档都是浪费的努力。人们花费无数小时起草产品计划或文档，然后再也不看它们。

不过，我认为有些文档通常是有价值的。特别是我喜欢决策日志。其思想是每当团队需要做出决策时，就要在一些简短的文档中记录下来。我认为它有两个目的：

1.  将选项及其各自的优缺点写出来有助于澄清思路，帮助做出更好的决策。它展示了你考虑过什么，并允许其他人注意到空白或误解。还经常有助于澄清决策时你*不*打算解决的问题，即什么是超出范围的。

1.  几个月甚至几年后，回顾决策日志可能对理解系统为何以某种方式设计很有帮助。例如，新雇员不理解为什么选择数据库X而不是数据库Y，可以查看日志条目。或者当有人提出已经考虑过的新建议时，可以回头看看为什么之前没有选择它，以及当前情况是否有变化（例如公司或工具的能力）。决策日志有助于消除只有少数老员工知道任何事情原因的“机构知识”。

不过，我认为这些决策日志（以及其他文档）应该保持相对简洁。大家不应该花费几天时间起草它们。

## 持续部署

我非常喜欢持续部署。这在不同的项目中可能有所不同，但理想情况下，每次对主分支的提交都会部署到测试和生产环境。我看到了许多好处：

1.  这意味着提交到生产之间的时间很短，因此完成的工作可以迅速地交到用户手中。你也不必担心代码何时发布，以及依赖于它的其他代码何时也可以发布。你可以合并一个更改，让它部署，然后再合并另一个更改。

1.  这要求部署必须完全自动化，这样既可以重复执行，也可以通常被发现。任何人都可以看到每次部署运行的步骤，它们始终相同（没有隐藏的步骤）。此外，如果需要手动部署，某人可以查看脚本并运行相同的命令。

1.  它消除了通常耗时的开发者繁琐工作。现在，部署就像自动发生的，你不必花时间协调或执行它们。

对于尚未准备向所有人展示的测试功能（beta features），我认为功能标志（feature flags）非常有效。在这个领域有很多库和产品，但可以从内置于GitLab中的功能简单开始：[https://docs.gitlab.com/ee/operations/feature_flags.html](https://docs.gitlab.com/ee/operations/feature_flags.html)
