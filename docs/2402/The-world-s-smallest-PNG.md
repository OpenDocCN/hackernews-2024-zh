<!--yml

类别：未分类

日期：2024-05-27 14:34:10

-->

# 世界上最小的 PNG

> 来源：[https://evanhahn.com/worlds-smallest-png/](https://evanhahn.com/worlds-smallest-png/)

<main class="content-page">

# 世界上最小的 PNG

由 [Evan Hahn](/) 编写

，更新

2024 年 1 月 21 日

（原始发布

2024 年 1 月 4 日

）

最小的 PNG 文件是 67 字节。它是一个单独的黑色像素。这是它在放大 200× 后的样子：

![一个单独的黑色像素。](img/d5beb8f4f56c3c6b2f3420d6d28cd29f.png)

哇，多么漂亮。

此文件共有四个部分：

1.  PNG 签名，每个 PNG 都一样：8 字节

1.  图像的元数据，包括其尺寸：25 字节

1.  图像的图元数据：22 字节

1.  “图像结束”标记：12 字节

此后的内容将更详细地描述这个文件，并试图解释 PNG 的工作原理。

结尾有一个大的转折，如果你感兴趣的话。但我希望你只是对学习 PNG 感兴趣。

## 第一部分：PNG 签名

每个单独的 PNG，包括这个，都以相同的 8 字节开始。以十六进制编码，这些字节是：

```
89 50 4E 47 0D 0A 1A 0A 
```

这被称为 [**PNG 签名**](https://www.w3.org/TR/2022/WD-png-3-20221025/#5PNG-file-signature)。尝试对任何 PNG 进行十六进制转储，你会看到它以这些字节开头。

PNG 解码器使用签名来确保它们正在读取 PNG 图像。通常，如果文件不以此签名开头，它们会拒绝该文件。数据可能以各种方式损坏（曾经遇到文件扩展名错误吗？），这有助于解决这个问题。

有趣的事实：如果你将这些字节解码为 ASCII，你会在里面看到字母“PNG”：

```
.PNG.... 
```

这样就完成了第一部分！这是我们的“检查清单”：

1.  ~~PNG 签名~~

1.  图像元数据块

1.  图元数据块

1.  “图像结束”块

其余部分呢？

PNG 的下一部分是图像元数据，它是几个**块**之一。什么是块？

### 快速介绍块

除了开始的 PNG 签名外，PNG 由块组成。

块有两个逻辑部分：一个**类型**和一些**数据字节**。类型可以是“图像头”或“文本元数据”之类的内容。数据取决于类型 —— 文本元数据块与图像头块的编码方式不同。

这些逻辑部分用 [四个字段](https://www.w3.org/TR/2022/WD-png-3-20221025/#5Chunk-layout) 编码。这些字段在每个块中始终以相同顺序出现。它们是：

1.  **长度**：块数据字段中的字节数（下面的第 3 个字段）。编码为 4 字节整数。

1.  **块类型**：这是块的类型。有许多不同的块类型。编码为 4 字节 ASCII 字符串，例如“IHDR”代表“图像头”或“tEXt”代表“文本元数据”。

1.  **数据**：块的数据。查看“长度”字段以了解将有多少字节。根据块类型的不同而变化。可能为空，但通常不会。

1.  **校验和**：对其余块数据进行校验，确保数据没有损坏。4 字节。

如您所见，每个块至少需要12字节长（4字节长度，4字节类型和4字节校验和）。

注意“长度”字段是“数据”字段的大小，*而不是*整个数据块。如果想知道整个数据块的大小，只需加上12——4字节长度，4字节类型和4字节校验和。

您有一些余地，但数据块有特定的顺序。例如，图像元数据块必须出现在像素数据块之前。一旦达到“图像完成”块，PNG就完成了。

我们的小型PNG将只有三个这些数据块。

每个PNG的第一个数据块，包括我们的，类型为**IHDR**，简称为[“图像头”](https://www.w3.org/TR/2022/WD-png-3-20221025/#11IHDR)。

每个数据块以数据的**长度**开头。

IHDR数据块总是有13字节的相关数据，我们稍后会看到。13在十六进制中为`0D`，编码如下：

```
00 00 00 0D 
```

接下来是**数据块类型**。这是另外四个字节。"IHDR"被编码为：

```
49 48 44 52 
```

这只是ASCII编码。数据块类型由ASCII字母组成。[每个字母的大写都很重要。](https://www.w3.org/TR/2022/WD-png-3-20221025/#5Chunk-naming-conventions)例如，第一个字母大写意味着它是一个必需的数据块。

接下来是数据块的**数据**。IHDR的数据恰好是13个字节，排列如下：

+   前八字节编码图像的宽度和高度。因为这是1×1图像，编码为`00 00 00 01 00 00 00 01`。

+   接下来的两个字节是[位深度](https://www.w3.org/TR/2022/WD-png-3-20221025/#3bitDepth)和[颜色类型](https://www.w3.org/TR/2022/WD-png-3-20221025/#6Colour-values)。

    这些值可能是这个PNG中最令人困惑的部分。

    有五种可能的颜色类型。我们的图像是黑白的，所以使用“灰度”颜色类型（编码为`00`）。如果我们的图像有颜色，可能会使用“真彩色”类型（使用`02`编码）。还有三种其他颜色类型，今天我们用不到，但您可以[在PNG规范中了解更多信息](https://www.w3.org/TR/2022/WD-png-3-20221025/#4Concepts.PNGImage)。

    一旦选择了颜色类型，就需要选择位深度。位深度取决于颜色类型，但通常表示图像中每个颜色通道的位数。例如，像`#FE9802`这样的十六进制颜色有8位深度——红色8位，绿色8位，蓝色8位。我们的全黑图像不需要所有这些……我们只需要*一*位！像素要么完全黑（`0`），要么完全白（`1`）——在我们的情况下，完全黑。

    如果我们选择了更“表现力”的颜色类型和位深度，我们可以在视觉上制作相同的1×1图像，但文件可能会更大，因为每个像素可能需要更多的位数，但实际上我们并不需要。例如，如果我们使用“真彩色”类型和每通道16位，每个像素将需要48位，而不是只需一个编码“完全黑色”的像素。

    用 1 位深度和颜色类型 0 编码这两个值，使用 `00 01`。

+   接下来的字节是 [压缩方法](https://www.w3.org/TR/2022/WD-png-3-20221025/#10CompressionCM0)。目前所有的 PNG 都将其设置为 `00`。这里只是以防万一他们想要添加另一种压缩方法。据我所知，目前还没有人这么做。

+   对于 [过滤方法](https://www.w3.org/TR/2022/WD-png-3-20221025/#3filter) 也是同样的情况，始终为 `00`。

+   块数据的最后一部分是 [交错方法](https://www.w3.org/TR/2022/WD-png-3-20221025/#8InterlaceMethods)。PNG 支持渐进解码，允许在下载过程中部分渲染图像。我们不打算使用此功能，因此将其设置为 `00`。

最后，每个块都以四字节的 **校验和** 结束。它使用 [常见的校验和函数](https://www.w3.org/TR/2022/WD-png-3-20221025/#5CRC-algorithm) CRC32，并以块的其余部分作为输入。计算该校验和得到以下字节：

```
37 6E F9 24 
```

总体来说，这就是整个 IHDR 块：

| 字节 | 什么？ |
| --- | --- |
| `00 00 00 0D` | 数据长度为 13 字节 |
| `49 48 44 52` | “IHDR” 的 ASCII 码 |
| `00 00 00 01` | 宽度 |
| `00 00 00 01` | 高度 |
| `01` | 位深度 |
| `00` | 颜色类型 |
| `00` | 压缩方法 |
| `00` | 过滤器方法 |
| `00` | 交错方法 |
| `37 6E F9 24` | 校验和 |

这就是我们的第一个块！让我们再次检查我们的清单：

1.  ~~PNG 签名~~

1.  ~~图像元数据块~~

1.  像素数据块

1.  “图像结束”块

还有两个块要处理 —— 接下来是像素数据。

## 第三部分：像素数据块

我们的下一个块是 **IDAT**，简称为 [“图像数据”](https://www.w3.org/TR/2022/WD-png-3-20221025/#11IDAT)。这里是实际像素编码的地方&mldr;或者在我们的情况下，仅有一个像素。

记住，每个块有四个部分：数据的 *长度*，*块类型*，*数据* 和 *校验和*。

该块将包含 10 个字节的数据。我们很快会讨论这些数据的*内容*，但我保证它是 10 个字节。让我们编码这个长度：

```
00 00 00 0A 
```

接下来，让我们为块类型编码“IDAT”：

```
49 44 41 54 
```

再次强调，这只是 ASCII 码，我展示的是十六进制编码的值。

现在是有趣的部分：图像数据。

### 第一步：未压缩像素

图像数据以一系列称为 [“扫描线”](https://www.w3.org/TR/2022/WD-png-3-20221025/#3scanline) 的形式编码，然后进行压缩。

一个扫描线代表一条水平像素线。例如，一个 123×456 的图像有 456 条扫描线。在我们的例子中，由于我们的图像只有一个像素高，所以只有一条扫描线。

扫描线以一种称为 [过滤器类型](https://www.w3.org/TR/2022/WD-png-3-20221025/#9Filter-types) 开始，这可以根据您的图像改善压缩。我们的图像如此之小，以至于这个过程无关紧要，因此我们使用过滤器类型 0，或“无”。

在过滤器类型之后，每个像素根据其位深度编码为一个或多个位。在我们的情况下，每个像素只需一位 —— 记得我们的位深度是 1；全黑或全白。

如果你的像素数据与字节边界不对齐——换句话说，它不是 8 位的倍数——你需要在扫描线的末尾填充零。在我们的情况下是这样，所以我们添加了七个填充位来填充一个字节。

把这些放在一起（以一个零字节开始扫描线，一个单零位和七个零填充位），我们的单个扫描线是：

```
00 00 
```

现在是“压缩”数据的时候了。

### 第二步： “压缩”

接下来，我们压缩扫描线数据&mldr;嗯，不完全是。

更准确地说，我们通过压缩算法运行它。大多数情况下，压缩算法会生成较小的输出，这就是它的全部目的！但有时，“压缩”微小的输入实际上会产生*更大*的输出，因为有些小的开销。不幸的是，对我们来说，这里就是这种情况。但 PNG 文件格式要求我们这么做。

PNG 图像数据使用 [zlib 格式](https://www.rfc-editor.org/rfc/rfc1950) 进行编码，采用 [DEFLATE 压缩算法](https://zlib.net/feldspar.html)。DEFLATE 也被应用于 [gzip](https://en.wikipedia.org/wiki/Gzip) 和 [ZIP](https://en.wikipedia.org/wiki/ZIP_(file_format))，这两种非常流行的压缩格式。

我在这里不会深入讲解 DEFLATE（部分因为我不是专家^()，但这是我们块数据包含的内容：

1.  zlib 头部：2 bytes

1.  一个压缩的 DEFLATE 块编码了两个字面上的零^(: 4 bytes)

1.  zlib 校验和（这是与 PNG 块校验和分开的！）：4 bytes

想了解更多 DEFLATE 的工作原理，请参阅 [“DEFLATE 算法解释”](https://zlib.net/feldspar.html)。我还推荐 [infgen](https://github.com/madler/infgen/)，这是一个检查 DEFLATE 流的有用工具。

总的来说，这里有十个数据字节：

```
78 01 63 60 00 00 00 02 00 01 
```

再次不幸的是，我们不得不通过一个算法运行我们的两字节扫描线，使其*增加五倍*，但 PNG 强制我们这么做！

有了这个，我们可以计算 PNG 的校验字段并完成块。

| Bytes | What? |
| --- | --- |
| `00 00 00 0A` | 数据长度为 10 字节 |
| `49 44 41 54` | ASCII 中的 “IDAT” |
| `78 01` | zlib 头部 |
| `63 60 00 00` | “压缩” DEFLATE 块 |
| `00 02 00 01` | zlib 校验和 |
| `73 75 01 18` | 块校验和 |

再来最后一个块！在所有事项都完成前，我们再检查一遍清单：

1.  ~~PNG 签名~~

1.  ~~图像元数据块~~

1.  ~~像素数据块~~

1.  “图像结束”块

让我们结束这个。

## 第四部分：结束

诗意地说，PNG 结束时和开始时一样：都有少量的常量字节。

**IEND** 是最终块，简称为 [“图像尾部”](https://www.w3.org/TR/2022/WD-png-3-20221025/#11IEND)。

零长度用四个零来编码：

```
00 00 00 00 
```

然后编码了 “IEND”：

```
49 45 4E 44 
```

IEND 块中没有数据，所以我们直接转到校验和。因为块中的其他内容都是固定的，所以这个校验和总是相同的：

```
AE 42 60 82 
```

整个尾部块如下：

| Bytes | What? |
| --- | --- |
| `00 00 00 00` | 数据长度为 0 |
| `49 45 4E 44` | ASCII 中的 “IEND” |
| `AE 42 60 82` | 校验和 |

PNG 完成了！

## 欣赏我们的工作

再次展示，放大至200×：

![一个单一的黑色像素。](img/d5beb8f4f56c3c6b2f3420d6d28cd29f.png)

美丽。 它以经典的PNG签名开头，接着是一些元数据，“压缩”像素数据，最后以空块签名结束。

这就是世界上最小的PNG图像了！

&mldr;还是吗？

## 转折点：有很多冠军

在本文中，我说这是世界上最小的PNG。 但事实并非完全如此：它与第一名并列。 有几个“世界上最小的PNG”！

*只要我们将所有像素数据编码在一个字节中，我们就可以并列世界上最小的PNG。*

例如，您可以编码这个8×1的黑色图像，它也是67字节：

![一个8像素宽和1像素高的黑色矩形。](img/b95743e9e2abd57ea0ef739103e429ff.png)

这有效，因为我们使用了所有八个位来编码像素数据。

在我们的1×1图像中，回想一下七个位被有效地“浪费”在填充上。基本上发生了以下情况：

| 位 | 什么？ |
| --- | --- |
| `0` | 一个黑色像素 |
| `0000000` | 填充 |

8×1图像可以像这样编码八个黑色像素：

| 位 | 什么？ |
| --- | --- |
| `00000000` | 八个黑色像素 |

不是增加更多像素，而是增加更高的色彩分辨率。 许多灰色可以编码成单个字节，让我们并列第一。例如，这个1×1的灰色像素也是67字节：

![一个单一的灰色像素。](img/ce106dba64972531222763ae1a52ed9a.png)

再次，“用完”我们有的整个字节，不像我们的1×1图像。

欲了解更多信息，我的前同事乔丹·罗斯发表了[“最大的最小PNG”](https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/) 作为对此文章的回应。它展示了最大的67字节PNG图像：一个1×2064的黑线。

## 总结

PNG以“签名”开头。 文件的其余部分由块组成。 每个块都有长度、类型、数据和校验和。 像图像头（IHDR）块一样，一些块总是需要的。

最小的PNG使用最少的块和最小可能的数据。

我们的PNG由四个部分组成：

1.  固定的PNG签名（8字节）

1.  包含元数据的IHDR块（25字节）

1.  IDAT块，图像像素数据（22字节）

1.  IEND块，图像尾部（12字节）

如果您有兴趣以互动方式了解更多有关PNG的信息，我制作了[PNG块浏览器](https://evanhahn.gitlab.io/png-explorer/)，它可以让您分析PNG图像。尝试上传您自己的图像，看看它们由什么组成！（对于移动设备的支持不是很好，抱歉。）

我还制作了[单色图像](https://singlecolorimage.com/)，它生成任意尺寸的单色PNG图像。例如，您可以生成一个12×34的紫色矩形。这些图像应该很小，但我还没有实现最复杂的压缩，因此您可能需要通过PNG压缩器来实现最小尺寸。

最后，我还写了关于[*最大可能的PNG*](/largest-possible-png/)。理论上没有文件大小限制，但有像素数量的最大限制，许多解码器还设有各种限制。

我希望这篇长篇文章让你对PNG文件格式有了深入的理解。如果你读到这里有什么想说的，[请告诉我](/contact/)！

</main>
