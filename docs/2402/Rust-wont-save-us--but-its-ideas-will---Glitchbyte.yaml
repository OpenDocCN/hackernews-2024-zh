- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:44:11'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Rust wont save us, but its ideas will • Glitchbyte
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://glitchbyte.io/posts/rust-wont-save-us/](https://glitchbyte.io/posts/rust-wont-save-us/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**UPDATE 2/10/2024**: After receiving some constructive feedback, the example
    errors were fixed.'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: What are we saving?
  id: totrans-split-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recently, I came across this article titled ”[Rust Won’t Save Us: An Analysis
    of 2023’s Known Exploited Vulnerabilities](https://www.horizon3.ai/analysis-of-2023s-known-exploited-vulnerabilities/)“.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: Being the clickbait it is, I clicked.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Quick background on me: I’ve worked in cybersecurity for almost 10 years. I
    know cybersecurity way more than I know development.'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: My day job is securing infrastructure and code.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: An article like this piques my interest.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: I’ve been writing programs in Rust for a few years now.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: I started writing Rust because of its claim to memory safety, and it became
    my favorite language to use. I’ve even managed to ship Rust to prod in one of
    the coolest projects I’ve had the honor of being apart of.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: So what is this article talking about?
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: 'TL;DR: Rust was made to solve memory-related vulnerabilities and issues, but
    that only makes up 19.5% of the most exploited vulnerabilities in 2023\. Routing
    and Path abuse exploits tied for second place with memory vulns, followed by Default
    Secrets (4.9%), Request Smuggling(4.9%), and Weak Encryption (2.4%). The most
    abused exploit? Insecure Exposed Functions (IEF), at 48.8%.'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The article goes onto making the most generic recommendations any cybersec
    professional would know:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: Vendors 1\. Develop the depth of knowledge of your engineers in the frameworks
    they use 2\. Harden, standardize, and audit the use of those frameworks across
    products 3\. Enable and expose verbose logging for your products
  id: totrans-split-18
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Developers 1\. Assume all code you write is reachable from an unauthenticated
    context 2\. Practice defense-in-depth programming and don’t make it easy for an
    attacker to shell out
  id: totrans-split-19
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Defenders 1\. Reduce any attack surface exposed to the internet if its not needed
    there 2\. Proactively enable logging, and remote logging if possible, for all
    products that touch the internet
  id: totrans-split-20
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Researchers 1\. Look for bugs in the places frameworks come together
  id: totrans-split-21
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Therefore, Rust won’t save us.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: There is some truth to that, and the advice given by the article is also correct.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: But it doesn’t dig into why Rust was made in the first place.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t ask the question “Can we reduce/eliminate IEF abuse similar to how
    we reduced memory vulnerabilities?”
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: Looking at IEF
  id: totrans-split-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are Insecure Exposed Functions, exactly?
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets take a look at the [MITRE](https://cwe.mitre.org/data/definitions/749.html)
    definition:'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: The product provides an Applications Programming Interface (API) or similar
    interface for interaction with external actors, but the interface includes a dangerous
    method or function that is not properly restricted.
  id: totrans-split-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This weakness can lead to a wide variety of resultant weaknesses, depending
    on the behavior of the exposed method. It can apply to any number of technologies
    and approaches, such as ActiveX controls, Java functions, IOCTLs, and so on.
  id: totrans-split-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The exposure can occur in a few different ways
  id: totrans-split-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The function/method was never intended to be exposed to outside actors.
  id: totrans-split-32
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The function/method was only intended to be accessible to a limited set of actors,
    such as Internet-based access from a single web site.
  id: totrans-split-33
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: IEF is access to functions the outside world should never have had access to
    in the first place.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: Private by default
  id: totrans-split-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lets look at an example from the MITRE page:'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a Java method `removeDatabase` that will delete a database
    with the name specified in the parameter.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: The problem is this method should never have been public. By declaring it public,
    the rest of the application has access to this method, even though it should be
    restricted.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-40
  prefs: []
  type: TYPE_PRE
- en: 'Java has a few keywords for deciding the level of access the rest of the codebase
    should have:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  id: totrans-split-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`'
  id: totrans-split-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`'
  id: totrans-split-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*no modifier*, where you don’t specify an access level; package-private default'
  id: totrans-split-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now lets take that same example and see what it would look like in Rust.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-47
  prefs: []
  type: TYPE_PRE
- en: Rust only has `pub` as a keyword for determining whether an item has a public
    or private scope.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: By default, all of Rust code is inherently private.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: In Java, if no modifier is added, Java assumes is has package-private access,
    which is package-level rather than item-level.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: In other words, visibility control in Rust is explicit and controlled through
    the `pub` modifier; Java’s visibility control is implicit if no modifier is specified,
    allowing access control based on their location within the codebase. If a modifier
    is specified, then it is explicit.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the Rust function to be public, we would have to declare it public:'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-53
  prefs: []
  type: TYPE_PRE
- en: This example is a simple scoping error, or laziness.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to miss, but Rust is less likely to let you make this mistake.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: “Okay, so it’s private by default, big deal. Theres other ways of improperly
    accessing functions and abusing them.”
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: IEF in the Wild
  id: totrans-split-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re going to look at [CVE-2023-22515: Atlassian Confluence](https://attackerkb.com/topics/Q5f0ItSzw5/cve-2023-22515/rapid7-analysis)
    vulnerability and how we can potentially solve it.'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: What was the problem?
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: The application insecurely exposed an endpoint, `/server-info.action?bootstrapStatusProvider.applicationConfig.setupComplete=false`,
    that allows modification to the server’s configuration state. Setting this state
    to false allows an attacker to re-enter application setup and add an administrative
    user.
  id: totrans-split-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We must note that the class `com.atlassian.confluence.core.actions.ServerInfoAction`
    extends the class `com.atlassian.confluence.core.ConfluenceActionSupport`. This
    will be important during exploitation.
  id: totrans-split-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rust doesn’t have inheritance, which makes it less likely to accidentally inherit
    unintended behavior from a parent class.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: Instead, Rust offers other mechanisms for code reuse and polymorphism.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The decision to omit inheritance from Rust by its designers:'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: simplifies the language, reducing the potential for inheritance-related issues
    such as the “diamond problem” or “fragile base class” problem.
  id: totrans-split-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: encourages composition over inheritance.
  id: totrans-split-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: provides trait-based polymorphism as an alternative, allowing you to define
    a behavior that types can implement.
  id: totrans-split-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance can be useful in certain contexts, but Rust’s design philosophy
    prioritizes simplicity, safety, and expressiveness, leaning in favor of composition,
    traits, and other language features.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: We know we can leverage the XWorks2 feature of supplying HTTP parameters to
    call setter methods on objects. We need to identify an unauthenticated endpoint
    whose Action object also exposes a suitable get method that will allow us to access
    the application configuration.
  id: totrans-split-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remembering the class `com.atlassian.confluence.core.actions.ServerInfoAction`,
    seen during diffing, we explore the base class it inherits from, `com.atlassian.confluence.core.ConfluenceActionSupport`.
  id: totrans-split-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-71
  prefs: []
  type: TYPE_PRE
- en: We can see this class has a getter method `getBootstrapStatusProvider` which
    returns the `BootstrapStatusProviderImpl` instance we are looking for.
  id: totrans-split-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`BootstrapStatusProviderImpl`, in turn, has a getter method `getApplicationConfig`
    to return the application’s configuration.'
  id: totrans-split-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
- en: Finally, we can see the class `com.atlassian.config.ApplicationConfig` implements
    the setter method `setSetupComplete`.
  id: totrans-split-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-76
  prefs: []
  type: TYPE_PRE
- en: Rust’s approach to mutability would have helped here.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: If you want setters to be mutable, then you’d need to make that explicit.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Routing Abuse
  id: totrans-split-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Routing abuse tied for second with memory corruption issues.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The [example Horizon3 provided](https://www.horizon3.ai/moveit-transfer-cve-2023-34362-deep-dive-and-indicators-of-compromise/)
    involves a security advisory by Progress for their MOVEit Transfer application:'
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: Progress released a [security advisory](https://community.progress.com/s/article/MOVEit-Transfer-Critical-Vulnerability-31May2023)
    for their MOVEit Transfer application which detailed a SQL injection leading to
    remote code execution and urged customers to update to the latest version. The
    vulnerability, CVE-2023-34362, at the time of release was believed to have been
    exploited in-the-wild as a 0-day dating back at least 30 days.
  id: totrans-split-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The function that extracts the `X-siLock-Transaction` header to compare its
    value to `folder_add_by_path` has a bug. **It will incorrectly extract headers**
    that end in `X-siLock-Transaction`, so an attacker can trick the function to passing
    the request onto the machine2.aspx by providing a header such as `xX-siLock-Transaction=folder_add_by_path`
    and additionally providing the correctly formatted header with our own arbitrary
    transaction to be executed by the machine2.aspx endpoint.
  id: totrans-split-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using Rust’s [http::header::HeaderName](https://docs.rs/http/1.0.0/http/header/struct.HeaderName.html)
    would have caught this error since the headers passed would not have been treated
    as a string, but to known typed headers.
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: This http lib is used in almost every Rust web framework for header parsing.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
- en: The right way to do header parsing, in Rust, requires creating a `HeaderName`
    and using that to get the header, rather than treating header names as strings.
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
- en: This is one advantage of Rust’s type system.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
- en: It’s designed to be expressive, allowing developers to express complex ideas
    and patterns into a concise and readable manner.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: Rusts Memory Safety
  id: totrans-split-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It worth noting Rust eliminates most memory corruption issues, which would take
    care of ~20% of vulnerabilities exploited in 2023.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty huge when you think about the reports [Microsoft](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/)
    and [Google Chrome](https://www.zdnet.com/article/chrome-70-of-all-security-bugs-are-memory-safety-issues/)
    have dropped, stating 70% of their vulnerabilities were memory-safety related.
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: Rust doesn’t even have `NULL`, which [Tony Hoare called his “One Billion Dollar
    Mistake”](https://www.youtube.com/watch?v=ybrQvs4x0Ps).
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
- en: We wont be having NULL-pointer exceptions issues in Rust anytime soon (sorry
    Java).
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
- en: The hero we need
  id: totrans-split-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The average developer is more concerned with shipping the product now and worry
    about fixing bugs later than how security can be designed from the start.
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
- en: Security is an afterthought in many processes, something that gets bolted on.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
- en: For security to work, it has to be there from the start.
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
- en: You can’t add the egg onto your cake once you’ve baked it; you need to add it
    to the mixture.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
- en: Security is a process of layering many defensive techniques on top of each other
    in an effort to thwart attackers.
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
- en: Its a constant cat and mouse game.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
- en: The hero we need isn’t Rust.
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
- en: Rust wont address all vulnerabilities and magically fix them.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
- en: However, Rust has inherent qualities from its design philosophy that make it
    safer to use than the average language.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
- en: That is our hero.
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
- en: Rust may not save us, but the ideas it embodies will.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
- en: Private by default
  id: totrans-split-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable by default
  id: totrans-split-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type-safety checked at compile time
  id: totrans-split-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Borrow checker and ownership model reducing memory corruption
  id: totrans-split-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safe abstractions and idiomatic patterns that prevent common security vulnerabilities
  id: totrans-split-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust’s design philosophy is a step in the right direction.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
- en: Rust doesn’t rely on the developer to put in place all the details. It lifts
    responsibility from the developer so they can worry more on developing and less
    on safety/correctness.
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
- en: Imagine using a language that prevents all these kind of vulnerabilities.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
- en: Why do we talk about around programming languages as if there isn’t a way to
    improve their inherent security by design as well?
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
- en: Besides all the recommendations Horizon made, programming languages should also
    be among them.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
- en: We should expect all our languages to be safer.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
