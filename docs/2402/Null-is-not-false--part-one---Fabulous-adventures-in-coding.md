<!--yml

分类：未分类

日期：2024-05-27 14:54:11

-->

# Null 不是 false，第一部分 | 编程中的神奇冒险

> 来源：[https://ericlippert.com/2012/03/26/null-is-not-false-part-one/](https://ericlippert.com/2012/03/26/null-is-not-false-part-one/)

通常在 C# 中表示“缺失”或“无效”值的方式是使用该类型的“null”值。每种引用类型都有一个“null”值；即指向实际不存在的引用。而每种“正常”的值类型都有一个对应的“可空”值类型，它有一个 null 值。

这些概念的实现方式完全不同。引用通常在后台作为 32 位或 64 位数字实现。正如我们之前讨论过的 [先前](http://blogs.msdn.com/b/ericlippert/archive/2009/02/17/references-are-not-addresses.aspx)，那个数字应该逻辑上被视为只有垃圾收集器知道的“不透明”句柄，但实际上，该数字是进程虚拟内存空间中指向所引用对象的偏移量，位于托管堆内。数字零被保留为 null 的表示，因为操作系统将虚拟内存的前几页保留为无效，总是如此。不会出现因为偶然事件而使零地址成为堆中的有效地址的机会。

相比之下，可空值类型只是值类型的一个实例，再加上一个布尔值，指示该值是要被视为值，还是作为 null。这只是一种语法糖，用于传递一个标志。这是因为值类型不需要有任何没有其他含义的“特殊”值；一个字节有 256 个可能的值，每一个都是有效的，因此可空字节必须有一些额外的存储。

有些语言允许对值类型或引用类型的 null 值进行隐式地布尔处理。在 C 中，你可以这样说：

```
int* x = whatever(); 
if (x) 
  ...

```

并且这会被视为你说了 `if (x != null)`。对于可空值类型也是类似的；在某些语言中，null 值类型被隐式地视为“false”。

C# 的设计者们考虑了这些特性并予以了拒绝。首先，因为将引用或可空值类型作为布尔值处理是一种令人困惑的习惯用法，也是潜在的错误来源。其次，从语义上看，自动将 null —— 应该意味着“此值缺失”或“此值未知” —— 转换为“此值逻辑上为 false”似乎是自以为是的。

特别是，我们希望将可空布尔值视为具有三种状态：true、false 和 null，而不是具有三种状态：true、false 和不同类型的 false。将 null 可空布尔值视为 false 会导致许多奇怪的情况。假设我们这样做了，假设 x 是一个等于 null 的可空布尔型：

```
if (x)
   Foo(); 
if (!x)
   Bar();

```

`Foo`和`Bar`都不会被执行，因为“非空”当然也是空。 （对于“这个未知值的相反是什么？”的答案是“一个未知值”。） `x`和`!x`同时被视为假，这不是很奇怪吗？同样，如果`(x | !x)`也被视为假，这看起来也很奇怪。

这些奇怪现象的问题的解决方案是首先避免问题，而不是使空值表现得像假一样。

**下一期的FAIC：** [我们将看一看真值确定的另一个方面：那些“真”和“假”用户定义操作符到底是怎么回事？](https://ericlippert.com/2012/04/12/null-is-not-false-part-two/ "Null is not false, part two")
