["```\nuse XL.CONSOLE.TEXT_IO ***(1)**\nuse XL.TEXT.FORMAT\n\nprint \"Starting printing Fibonacci sequences\" ***(2)**\n\nfib 0 is 1 ***(3)**\nfib 1 is 1\nfib N is (fib(N-1) + fib(N-2)) ***(4)**\n\nfor I in 1..5 loop ***(5)**\n    F is fib I ***(6)**\n    print format(\"Fib(%1) is %2\", I, F) ***(7)*********\n```", "```\ntmp1 is N-1\ntmp2 is fib(tmp1)\ndelete tmp1\ntmp3 is N-2\ntmp4 is fib(tmp3)\ndelete tmp3\ntmp5 is tmp2+tmp4\ndelete tmp2\ndelete tmp4\ntmp5\n```", "```\ntmpBody is\n    F is fib I\n    print format(\"Fib(%1) is %2\", I, F)\n{ I is 1 } ( tmpBody )\n{ I is 2 } ( tmpBody )\n{ I is 3 } ( tmpBody )\n{ I is 4 } ( tmpBody )\n{ I is 5 } ( tmpBody )\n```", "```\ntmpBody is\n    F is fib I\n    print format(\"Fib(%1) is %2\", I, F)\n    delete F\n```", "```\nAdd Z:complex is\n   T:complex\n   Z+T\n```", "```\nAdd Z:complex is\n   T:complex\n   (create T)\n   Z+T\n```", "```\ncreate Z:out complex is\n    print \"Creator called\"\n```", "```\ncreate Z:out complex is\n   (create Z.Re)        // Implicit creation of complex fields\n   (create Z.Im)\n   print \"Creator called\"\n```", "```\nZ:complex\n(create Z)      // because of the declaration above\n(delete Z)      // because Z is passed as out argument to 'create'\ncreate Z\n```", "```\ntype complex is matching complex(Re:real, Im:real)\n```", "```\ni   is complex(0.0, 1.0)\n\nsyntax { POSTFIX 190 i }\nRe:real + Im:real i                 is complex(Re, Im)      // Case 1\nRe:real + Im:real * [[i]]           is complex(Re, Im)      // Case 2\nRe:real + [[i]] * Im:real           is complex(Re, Im)      // Case 3\nRe:real as complex                  is complex(Re, 0.0)     // Case 4\nX:complex + Y:complex as complex    is ...\n\n2 + 3i              // Calls case 1 (with explicit concersions to real)\n2 + 3 * i           // Calls case 2 (with explicit conversions to real)\n2 + i * 3           // Calls case 3\n2 + 3i + 5.2        // Calls case 4 to convert 5.2 to complex(5.2, 0.0)\n2 + 3i + 5          // Error: Two implicit conversions (exercise: fix it)\n```", "```\ntype large is matching (N when N > 42)\nA:large := 44   // OK\nB:large := 99.1 // OK\nC:large         // Error\nto create V:out large is\n    print \"Creator called\"\n```", "```\ntype large is matching (N when N > 42)\nC:large         // OK\nto create V:out large is\n    print \"Creator called\"\n    V := 44     // Creator for a large value\n```", "```\nmodule MY_FILE with\n    type file\n    to open(Name:text) as file\n    to close F:io file\n\nmodule MY_FILE is\n    type file matches file(fd:integer)\n    to open(Name:text) as file is\n        fd:integer := libc.open(Name, libc.O_RDONLY)\n        file(fd)\n    to close F:inout file is\n        if fd >= 0 then\n            libc.close(F.fd)\n            F.fd := -2\n    to delete F:inout file is close F    // Destruction, see below\n```", "```\nto delete Z:inout complex is\n    print \"Deleting complex \", Z\n```", "```\nto delete Z:inout complex is\n    print \"Deleting complex \", Z\n    (delete Z.Im)\n    (delete Z.Re)\n```", "```\nto delete Anything is nil\n```", "```\nto delete F:inout file when F.fd < 0  is ... // Invalid flie\nto delete F:inout file                is ... // Valid file\n```", "```\ntype positive is matching (N when N > 0)\nintegers is string of integer\nN:integers > 0 as boolean is\n    for I in N loop\n        if not (I > 0) then\n            return false\n    return true\n\ndelete N:inout positive is\n    print \"Deleting positive: \", N\n\ndelete N:integer is\n    print \"Deleting integer: \", N\n\ndelete N:integers is\n    print \"Deleting integers with size: \", size N\n\nexample is\n   print \"Beginning example\"\n   A:integers := string(1,8,4)\n   B:integers := string(-1,0,5)\n   print \"End of example\"\n```", "```\ntype integers is matching(base:string of integer)\n\ndelete P:inout positive is\n    print \"Deleting positive: \", P\n    (delete P.N)        // Delete the N bound in 'positive'\n\ndelete N:integer is\n    print \"Deleting integer: \", N\n    (delete N.base)     // For 'integer', this is a no-op\n\ndelete S:integers is\n    print \"Deleting integers with size: \", size S\n    (delete S.base)     // Delete the underlying 'string of integer'\n```", "```\nBeginning example\nEnd of example\nDeleting integers with size 3 ***(1)**\nDeleting positive: 5 ***(2)**\nDeleting integer: 5 ***(3)**\nDeleting integer: 0 ***(4)**\nDeleting integer: -1\nDeleting positive: string(1,8,4) ***(5)**\nDeleting integers with size 3 ***(6)**\nDeleting positive: 4\nDeleting integer: 4\nDeleting positive: 8\nDeleting integer: 8\nDeleting positive: 1\nDeleting integer: 1******\n```", "```\nshow_destructors is\n    delete Something is\n        print \"Deleted\", Something\n        super.delete Something\n    X is 42\n    Y is 57.2\n    X + Y\n```", "```\nDeleted 42.0\nDeleted 57.2\nDeleted 42\n```", "```\nfor I in 1..LARGE_NUMBER loop\n    delete Value\n```", "```\ntype error is one_of\n    error Message:text\n    error Message:text, Payload\n```", "```\nlog X:real as error when X <= 0 is\n    error \"Logarithm of negative value %1\", X\n```", "```\nmayfail T:type as type is T or error\n```", "```\nlog X:real as mayfail real     is ... // May return real or error\n```", "```\nlog X:real as real  when X > 0.0    is ... // Always return a real\nlog X:real as error                 is ... // Always return an error\n```", "```\nif X > 0.0 then\n    print format(\"Log(%1) is %2\", X, log X)\n```", "```\n    T:text[I:offset] as character or range_error is\n        if I >= length T then\n            range_error \"Text index %2 is out of bounds for text %2\", I, T\n        else\n            P : memory_address[character] := memory_address(T.first)\n            P += I\n            *P\n    ```", "```\n    if X > 0 then\n        print \"X is positive\"\n    else if X < 0 then\n        print \"X is negative\"\n    else\n        logic_error \"Some programmer forgot to consider this case\"\n    ```", "```\n    S : string of integer           // The string requires storage\n    loop\n        V : own integer := 3        // This allocates an integer, freed each loop\n        S &= V                      // Accumulate integers in an unbounded way\n    ```", "```\n    // Emit a specific compile-time error if assigning text to an integer\n    X:integer := Y:text is\n        compile_error \"Cannot assign text %1 to integer %2\", Y, X\n\n    // Emit a specific warning when writing a real into an integer\n    X:integer := Y:real is\n        compile_warning \"Assigning real to integer may lose data\"\n        T is integer Y\n        if real T = Y then\n            X := T\n        else\n            range_error \"Assigned real value %1 is out of range for integer\", Y\n    ```", "```\nStartupMessage : text := \"Hello World\"  // Variable\nAnswer as integer is 42                 // Named constant\n```", "```\nX : integer := 42       // Initialize with value 42\nX := X or 1             // Binary or, X is now 43\nX -= 1                  // Subtract 1 from X, now 42\n```", "```\nGreeting : text := \"Hello\"              // Variable text\nPerson as text is \"John\"                // Constant text\nGreeting := Greeting & \" \" & Person     // (1) Greeting now \"Hello John\"\nGreeting &= \"!\"                         // (2) Greeting now \"Hello John!\"\nGreeting[0..4] := \"Good m0rning\"        // (3) Greeting now \"Good m0rning John!\"\nGreeting[6] := 'o'                      // (4) Greeting now \"Good morning John!\"\n```", "```\nfor J in 1..5 loop\n    for I in 1..5 loop\n        K is 2*I + 1\n        L is 2*J + 1\n        print \"I=\", I, \" K=\", K, \" L=\", L\n```", "```\nDerived:derived as base is ...\n```", "```\ntype complex is matching complex[real:number] // WRONG\n```", "```\ntype complex is matching complex[real:type like number]\n```", "```\ntype complex inherits arithmetic\ntype complex inherits compact\n```"]