["```\n ┌ WAITS FOR SPACE IN ───┐    ┌ WAITS TO BE PROCESSED BY ─┐ ╔═══════════════╗           ╔════▼═════════╗           ╔══════════▼════╗ ║               ║▐▌         ║              ║▐▌         ║               ║▐▌ ║   STREAM OF   ║▐▌         ║   BUFFERED   ║▐▌         ║   FOR AWAIT   ║▐▌ ║    FUTURES    ║▐▌         ║    STREAM    ║▐▌         ║      LOOP     ║▐▌ ║               ║▐▌         ║              ║▐▌         ║               ║▐▌ ╚════════▲══════╝▐▌         ╚═════════▲════╝▐▌         ╚═══════════════╝▐▌ ▀▀▀▀▀▀▀▀│▀▀▀▀▀▀▀▀▘          ▀▀▀▀│▀▀▀▀│▀▀▀▀▀▀▘          ▀▀▀▀▀▀▀▀▀▀│▀▀▀▀▀▀▘ └─ BUFFERS FUTURES FROM ┘    └─── PROCESSES RESULTS FROM ┘ \n```", "```\n ╔═══════════════════════════════════╗ ║          SCOPED TASK SET          ║▐▌ ║                                   ║▐▌ ║           ╔════════╗              ║▐▌ ║           ║  TASK  ║▐▌            ║▐▌ ║           ╚════════╝▐▌            ║▐▌ ║            ▀▀▀│▀▀▀▀▀▀▘            ║▐▌ ║       ┌─── JOINING ───┐           ║▐▌ ║       │               │           ║▐▌ ║   ╔═══▼════╗       ╔══▼═════╗     ║▐▌ ║   ║  TASK  ║▐▌     ║  TASK  ║▐▌   ║▐▌ ║   ╚════════╝▐▌     ╚════════╝▐▌   ║▐▌ ║    ▀▀▀▀│▀▀▀▀▀▘      ▀▀▀▀▀▀▀▀▀▀▘   ║▐▌ ║     AWAITING                      ║▐▌ ║        │                          ║▐▌ ║    ╔═══▼════╗                     ║▐▌ ║    ║  TASK  ║▐▌                   ║▐▌ ║    ╚════════╝▐▌                   ║▐▌ ║     ▀▀▀▀▀▀▀▀▀▀▘                   ║▐▌ ║                                   ║▐▌ ╚═══════════════════════════════════╝▐▌ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▘ \n```", "```\n// yield two values with an async generator: let  iter  =  async  gen  {  let  mut  guard  =  mutex.lock().await; yield  x; yield  y; drop(guard); };   // consume two values with a for await loop: for  await  elem  in  iter  {  let  mut  guard  =  mutex.lock().await; println!(\"{}\",  elem); drop(guard); } \n```", "```\n ┌ WAITING TO BE POLLED ───┐ ╔════════════════╗        ╔══════════▼═════╗ ║                ║▐▌      ║                ║▐▌ ║ ASYNC ITERATOR ║▐▌      ║ FOR AWAIT LOOP ║▐▌ ║  (holds lock)  ║▐▌      ║  (holds task)  ║▐▌ ║                ║▐▌      ║                ║▐▌ ╚══════▲═════════╝▐▌      ╚════════════════╝▐▌ ▀▀▀▀▀▀│▀▀▀▀▀▀▀▀▀▀▀▘       ▀▀▀▀▀│▀▀▀▀▀▀▀▀▀▀▀▀▘ └── WAITING TO TAKE LOCK ┘ \n```", "```\nlet  (tx,  rx)  =  channel(0);   // send two values through a channel: scope.spawn(async  {  let  mut  guard  =  mutex.lock().await; tx.send(x).await; tx.send(y).await; drop(guard); });   // process all values sent through the channel: scope.spawn(async  {  for  await  elem  in  rx  { let  mut  guard  =  mutex.lock().await; println!(\"{}\",  elem); drop(guard); } }); \n```", "```\n ┌ WAITING TO SEND DATA ───┐ ╔════════════════╗        ╔══════════▼══════╗ ║                ║▐▌      ║                 ║▐▌ ║ FIRST SUB-TASK ║▐▌      ║ SECOND SUB-TASK ║▐▌ ║  (holds lock)  ║▐▌      ║  (holds rx)     ║▐▌ ║                ║▐▌      ║                 ║▐▌ ╚══════▲═════════╝▐▌      ╚═════════════════╝▐▌ ▀▀▀▀▀▀│▀▀▀▀▀▀▀▀▀▀▀▘       ▀▀▀▀▀│▀▀▀▀▀▀▀▀▀▀▀▀▀▘ └── WAITING TO TAKE LOCK ┘ \n```"]