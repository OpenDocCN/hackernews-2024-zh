["```\nDate: Tue, 30 Jan 2024 18:39:37 +0000\nFrom: Qualys Security Advisory <qsa@...lys.com>\nTo: \"oss-security@...ts.openwall.com\" <oss-security@...ts.openwall.com>\nSubject: Out-of-bounds read & write in the glibc's qsort()\n\nQualys Security Advisory\n\nFor the algorithm lovers: Nontransitive comparison functions lead to\nout-of-bounds read & write in glibc's qsort()\n\n========================================================================\nContents\n========================================================================\n\nSummary\nBackground\nExperiments\nAnalysis\nPatch\nDiscussion\nAcknowledgments\nTimeline\n\n    CUT MY LIST IN TWO PIECES\n    THAT'S HOW YOU START QUICK SORT\n        -- https://twitter.com/QuinnyPig/status/1710447650112438710\n\n========================================================================\nSummary\n========================================================================\n\nWe discovered a memory corruption in the glibc's qsort() function, due\nto a missing bounds check. To be vulnerable, a program must call qsort()\nwith a nontransitive comparison function (a function cmp(int a, int b)\nthat returns (a - b), for example) and with a large number of attacker-\ncontrolled elements (to cause a malloc() failure inside qsort()). We\nhave not tried to find such a vulnerable program in the real world.\n\nAll glibc versions from at least September 1992 (glibc 1.04) to the\ncurrent release (glibc 2.38) are affected, but the glibc's developers\nhave independently discovered and patched this memory corruption in the\nmaster branch (commit b9390ba, \"stdlib: Fix array bounds protection in\ninsertion sort phase of qsort\") during a recent refactoring of qsort().\n\nAbout our advisory, the glibc security team issues the following\nstatement:\n\n------------------------------------------------------------------------\nThis memory corruption in the GNU C Library through the qsort function is\ninvoked by an application passing a non-transitive comparison function, which\nis undefined according to POSIX and ISO C standards.  As a result, we are of\nthe opinion that the resulting CVE, if any, should be assigned to any such\ncalling applications and subsequently fixed by passing a valid comparison\nfunction to qsort and not to glibc.  We however acknowledge that this is a\nquality of implementation issue and we fixed this in a recent refactor of\nqsort.  We would like to thank Qualys for sharing their findings and helping\nus validate our recent changes to qsort.\n------------------------------------------------------------------------\n\n========================================================================\nBackground\n========================================================================\n\nWhile browsing through Postfix's HISTORY file, we stumbled across a\npuzzling entry from February 2002:\n\n------------------------------------------------------------------------\n        Bugfix: make all recipient comparisons transitive, because\n        Solaris qsort() causes SIGSEGV errors otherwise. Victor\n        Duchovni, Morgan Stanley. File: *qmgr/qmgr_message.c.\n------------------------------------------------------------------------\n\nSegmentation faults in qsort()? Transitive comparison functions?\n\nAs explained in the manual page for qsort(), \"The comparison function\nmust return an integer less than, equal to, or greater than zero if the\nfirst argument is considered to be respectively less than, equal to, or\ngreater than the second.\" Of course, such a comparison function cmp()\nmust be transitive:\n\n- if a < b (i.e., if cmp(pointer_to(a), pointer_to(b)) < 0);\n\n- and if b < c (i.e., if cmp(pointer_to(b), pointer_to(c)) < 0);\n\n- then necessarily a < c (i.e., cmp(pointer_to(a), pointer_to(c)) < 0).\n\nFor example, the following comparison function (which compares integers)\nis transitive (and perfectly correct):\n\n------------------------------------------------------------------------\nint\ncmp(const void * const pa, const void * const pb)\n{\n    const int a = *(const int *)pa;\n    const int b = *(const int *)pb;\n    if (a > b) return +1;\n    if (a < b) return -1;\n    return 0;\n}\n------------------------------------------------------------------------\n\nA shorter and more efficient version of this comparison function could\nsimply \"return (a > b) - (a < b);\" and still be transitive and perfectly\ncorrect:\n\n- if a > b, it returns 1 - 0 = +1;\n\n- if a < b, it returns 0 - 1 = -1;\n\n- if a = b, it returns 0 - 0 = 0.\n\nThe question, then, is: how can a comparison function be nontransitive?\nA comparison function cmp() is nontransitive if there exist a, b, and c\nsuch that:\n\n- a < b (because cmp(pointer_to(a), pointer_to(b)) < 0);\n\n- b < c (because cmp(pointer_to(b), pointer_to(c)) < 0);\n\n- but a >= c (because cmp(pointer_to(a), pointer_to(c)) >= 0 by\n  mistake).\n\nAlthough the following comparison function seems correct at first, it is\nin fact nontransitive, because the subtraction in \"return (a - b);\" is\nprone to integer overflows:\n\n------------------------------------------------------------------------\nint\ncmp(const void * const pa, const void * const pb)\n{\n    const int a = *(const int *)pa;\n    const int b = *(const int *)pb;\n    return (a - b);\n}\n------------------------------------------------------------------------\n\nFor example, if a = INT_MIN, b = 0, and c = INT_MAX, then:\n\n- a < b (because cmp(pointer_to(a), pointer_to(b)) returns INT_MIN - 0,\n  which is correctly negative);\n\n- b < c (because cmp(pointer_to(b), pointer_to(c)) returns 0 - INT_MAX,\n  which is also correctly negative);\n\n- but a > c by mistake (because cmp(pointer_to(a), pointer_to(c))\n  returns INT_MIN - INT_MAX = +1, which is incorrectly positive because\n  this subtraction overflows).\n\nUnfortunately, such nontransitive comparison functions are extremely\ncommon, as discussed in this excellent blog post from Ted Unangst:\n\n  https://flak.tedunangst.com/post/subtraction-is-not-comparison\n\nand as hinted at in OpenBSD's manual page for qsort(): \"It is almost\nalways an error to use subtraction to compute the return value of the\ncomparison function.\"\n\nFortunately, when passed to a robust qsort() implementation, these\nnontransitive comparison functions should (at the worst) result in an\nincorrectly sorted array; certainly not in a memory corruption. However,\nthe aforementioned entry from Postfix's HISTORY file suggests that not\nall qsort() implementations are robust.\n\n========================================================================\nExperiments\n========================================================================\n\nWe therefore decided to assess the robustness of the glibc's qsort()\nimplementation, by calling it with a nontransitive comparison function:\n\n------------------------------------------------------------------------\n  1 #include <limits.h>\n  2 #include <stdlib.h>\n  3 #include <sys/time.h>\n  4 \n  5 static int\n  6 cmp(const void * const pa, const void * const pb)\n  7 {\n  8     const int a = *(const int *)pa;\n  9     const int b = *(const int *)pb;\n 10     return (a - b);\n 11 }\n 12 \n 13 int\n 14 main(const int argc, const char * const argv[])\n 15 {\n 16     if (argc != 2) return __LINE__;\n 17     const size_t nmemb = strtoul(argv[1], NULL, 0);\n 18     if (nmemb <= 0 || nmemb >= (1<<28)) return __LINE__;\n 19 \n 20     int * const pcanary1 = calloc(1 + nmemb + 1, sizeof(int));\n 21     if (!pcanary1) return __LINE__;\n 22     int * const array = pcanary1 + 1;\n 23     int * const pcanary2 = array + nmemb;\n 24 \n 25     struct timeval tv;\n 26     if (gettimeofday(&tv, NULL)) return __LINE__;\n 27     srandom((tv.tv_sec << 16) ^ tv.tv_usec);\n 28 \n 29     const int canary1 = *pcanary1 = (random() << 16) ^ random();\n 30     const int canary2 = *pcanary2 = (random() << 16) ^ random();\n 31     array[random() % nmemb] = INT_MIN;\n 32 \n 33     qsort(array, nmemb, sizeof(int), cmp);\n 34     if (*pcanary1 != canary1) abort();\n 35     if (*pcanary2 != canary2) abort();\n 36     return 0;\n 37 }\n------------------------------------------------------------------------\n\n- at lines 5-11, cmp() is the nontransitive comparison function\n  introduced in the previous \"Background\" section;\n\n- at lines 16-18, the number of elements to be sorted (simple integers)\n  is read from the command line;\n\n- at lines 20-23, the array of elements to be sorted is calloc()ated,\n  along with a canary element below this array, and a canary element\n  above this array;\n\n- at lines 29-30, these two canary elements are randomized, and copied\n  to the stack for later comparison;\n\n- at line 31, one random element of the array is initialized to INT_MIN\n  (all other elements are initialized to 0 by calloc());\n\n- at line 33, the elements of this array are sorted by qsort();\n\n- at lines 34-35, the two canary elements (below and above the sorted\n  array) are checked against their stack copies, and if they differ (an\n  out-of-bounds write in qsort()), abort() is called.\n\nWe chose the array elements a = INT_MIN and b = 0 because they directly\nexhibit the problematic behavior of this cmp() function:\n\n- a < b, because cmp(pointer_to(a), pointer_to(b)) returns INT_MIN - 0,\n  which is correctly negative;\n\n- but b < a by mistake, because cmp(pointer_to(b), pointer_to(a))\n  returns 0 - INT_MIN = INT_MIN (the \"Leblancian Paradox\"), which is\n  incorrectly negative (because this subtraction overflows).\n\nWe then executed our test program in a loop, on Fedora 39 (which uses\nthe latest glibc version, 2.38):\n\n------------------------------------------------------------------------\n$ while true; do n=$((RANDOM*64+RANDOM+1)); ./qsort $n; done\n------------------------------------------------------------------------\n\nUnsurprisingly, nothing happened: our program did not crash or abort().\nWhile this loop was still running (and not crashing), we started to read\nthe glibc's qsort() implementation; to our great surprise, we discovered\nthat the glibc's qsort() is not, in fact, a quick sort by default, but a\nmerge sort (in stdlib/msort.c).\n\nMost likely, merge sort was chosen over quick sort to avoid quick sort's\nworst-case performance, which is O(n^2); on the other hand, merge sort's\nworst-case performance is O(n*log(n)). But merge sort suffers from one\nmajor drawback: it does not sort in-place -- it malloc()ates a copy of\nthe array of elements to be sorted. As a result, if this array is very\nlarge (lines 212-217), or if this malloc() fails (lines 219-229), then\nthe glibc's qsort() falls back to a quick sort (in stdlib/qsort.c),\nbecause quick sort does sort in-place:\n\n------------------------------------------------------------------------\n163 void\n164 __qsort_r (void *b, size_t n, size_t s, __compar_d_fn_t cmp, void *arg)\n165 {\n166   size_t size = n * s;\n...\n170   /* For large object sizes use indirect sorting.  */\n171   if (s > 32)\n172     size = 2 * n * sizeof (void *) + s;\n173 \n174   if (size < 1024)\n175     /* The temporary array is small, so put it on the stack.  */\n176     p.t = __alloca (size);\n177   else\n178     {\n...\n212       /* If the memory requirements are too high don't allocate memory.  */\n213       if (size / pagesize > (size_t) phys_pages)\n214         {\n215           _quicksort (b, n, s, cmp, arg);\n216           return;\n217         }\n218 \n219       /* It's somewhat large, so malloc it.  */\n220       int save = errno;\n221       tmp = malloc (size);\n222       __set_errno (save);\n223       if (tmp == NULL)\n224         {\n225           /* Couldn't get space, so use the slower algorithm\n226              that doesn't need a temporary array.  */\n227           _quicksort (b, n, s, cmp, arg);\n228           return;\n229         }\n230       p.t = tmp;\n231     }\n...\n299 }\n------------------------------------------------------------------------\n\nWe therefore decided to assess the robustness of the glibc's quick sort\n(instead of its merge sort, which was clearly not crashing), by forcing\nqsort() to call _quicksort(). Locally, forcing the malloc() at line 221\nto fail is very easy: we simply execute our program with a low RLIMIT_AS\n(\"The maximum size of the process's virtual memory\", man setrlimit); and\nthis works even when executing a SUID-root program. So we executed our\nprogram in the following loop instead:\n\n------------------------------------------------------------------------\n$ while true; do n=$((RANDOM*64+RANDOM+1)); prlimit --as=$((n*4/2*3)) ./qsort $n; done\nAborted (core dumped)\nAborted (core dumped)\nAborted (core dumped)\n...\n------------------------------------------------------------------------\n\nIncredibly, we almost immediately observed crashes of our test program:\ncalls to abort(), because one of our canary elements (below or above the\nsorted array) was overwritten (i.e., an out-of-bounds write in qsort()).\nTo understand these crashes, we examined one of them in gdb:\n\n------------------------------------------------------------------------\n$ gdb prlimit\n(gdb) run --as=8104854 ./qsort 1350809\nStarting program: /usr/bin/prlimit --as=8104854 ./qsort 1350809\n...\nProgram received signal SIGABRT, Aborted.\n__pthread_kill_implementation (threadid=<optimized out>, signo=signo@...ry=6, no_tid=no_tid@...ry=0) at pthread_kill.c:44\n44            return INTERNAL_SYSCALL_ERROR_P (ret) ? INTERNAL_SYSCALL_ERRNO (ret) : 0;\n\n(gdb) backtrace\n#0  __pthread_kill_implementation (threadid=<optimized out>, signo=signo@...ry=6, no_tid=no_tid@...ry=0) at pthread_kill.c:44\n#1  0x00007ffff7e698a3 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78\n#2  0x00007ffff7e178ee in __GI_raise (sig=sig@...ry=6) at ../sysdeps/posix/raise.c:26\n#3  0x00007ffff7dff8ff in __GI_abort () at abort.c:79\n#4  0x0000555555555334 in main (argc=2, argv=0x7fffffffe338) at qsort.c:34\n\n(gdb) select-frame 4\n(gdb) p/x canary1\n$1 = 0xc6109e4c\n(gdb) p/x *pcanary1\n$2 = 0x0\n\n(gdb) x/xw pcanary1 - 2\n0x7ffff78af008: 0x00528002\n0x7ffff78af00c: 0x80000000\n0x7ffff78af010: 0x00000000\n0x7ffff78af014: 0xc6109e4c\n0x7ffff78af018: 0x00000000\n------------------------------------------------------------------------\n\n- at address 0x7ffff78af010 (pcanary1), the original value of the canary\n  (0xc6109e4c) was overwritten with 0x0 -- an out-of-bounds write;\n\n- at address 0x7ffff78af00c (below pcanary1), the most significant word\n  of an mchunk_size (heap metadata) was overwritten with 0x80000000\n  (INT_MIN) -- another out-of-bounds write;\n\n- at address 0x7ffff78af014 (above pcanary1), the first element of the\n  array was overwritten with 0xc6109e4c (the original value of the\n  canary), which was therefore read out-of-bounds beforehand (from\n  pcanary1).\n\n========================================================================\nAnalysis\n========================================================================\n\nTo identify the root cause of these out-of-bounds memory accesses, we\nmust analyze the implementation of the glibc's quick sort:\n\n------------------------------------------------------------------------\n 87 void\n 88 _quicksort (void *const pbase, size_t total_elems, size_t size,\n 89             __compar_d_fn_t cmp, void *arg)\n 90 {\n 91   char *base_ptr = (char *) pbase;\n...\n108       while (STACK_NOT_EMPTY)\n109         {\n...\n193         }\n...\n206     char *tmp_ptr = base_ptr;\n...\n214     for (run_ptr = tmp_ptr + size; run_ptr <= thresh; run_ptr += size)\n215       if ((*cmp) ((void *) run_ptr, (void *) tmp_ptr, arg) < 0)\n216         tmp_ptr = run_ptr;\n217 \n218     if (tmp_ptr != base_ptr)\n219       SWAP (tmp_ptr, base_ptr, size);\n...\n223     run_ptr = base_ptr + size;\n224     while ((run_ptr += size) <= end_ptr)\n225       {\n226         tmp_ptr = run_ptr - size;\n227         while ((*cmp) ((void *) run_ptr, (void *) tmp_ptr, arg) < 0)\n228           tmp_ptr -= size;\n...\n246       }\n...\n248 }\n------------------------------------------------------------------------\n\n- at lines 108-193, when quick sort's partitions become smaller than\n  MAX_THRESH (4 elements), _quicksort() switches to a final insertion\n  sort (at lines 206-246), which is faster than quick sort for small or\n  mostly sorted arrays;\n\n- at lines 206-219, this insertion sort makes sure that the very first\n  element of the array (base_ptr) is the smallest element of the array;\n\n- at lines 226-228, this first element acts as a natural barrier that\n  prevents tmp_ptr from being decremented below the array (because if\n  tmp_ptr reaches base_ptr, then necessarily cmp(run_ptr, tmp_ptr) >= 0\n  because tmp_ptr is base_ptr, the smallest element of the array);\n\n- unfortunately this does not hold true if cmp() is nontransitive, in\n  which case cmp(run_ptr, tmp_ptr) can be < 0 even if tmp_ptr is\n  base_ptr, so tmp_ptr can be decremented below the array, where\n  out-of-bounds elements are read and overwritten.\n\n========================================================================\nPatch\n========================================================================\n\nTo patch these out-of-bounds memory accesses in _quicksort(), a simple\ncheck \"tmp_ptr > base_ptr &&\" can be added in front of the cmp() call at\nline 227 (of course this does not magically result in a correctly sorted\narray if cmp() is nontransitive, but at least it does not result in a\nmemory corruption anymore).\n\nIn fact, while drafting this advisory, we discovered that such a check\n(\"tmp_ptr != base_ptr &&\") has already been added to the glibc's master\nbranch (which will become glibc 2.39 in February 2024), by the following\ncommit (\"stdlib: Fix array bounds protection in insertion sort phase of\nqsort\"):\n\n  https://sourceware.org/git?p=glibc.git;a=commit;h=b9390ba93676c4b1e87e218af5e7e4bb596312ac\n\nIndeed, the glibc developers have recently refactored qsort() and\nreplaced the merge sort (and its fallback to quick sort) with an\nintrospective sort (a combination of quick sort, heap sort, and\ninsertion sort):\n\n  https://en.wikipedia.org/wiki/Introsort\n  https://sourceware.org/pipermail/libc-alpha/2023-October/151907.html\n\nDuring this refactoring, the glibc developers have proactively\ndiscovered (and patched) the out-of-bounds memory accesses in the\ninsertion sort (probably because these out-of-bounds memory accesses\nbecame directly exposed to the misbehavior of nontransitive comparison\nfunctions, instead of being safely hidden behind a malloc() failure in\nthe merge sort).\n\nLast-minute note: in January 2024, the glibc developers have reverted\nthis refactoring of qsort(), back to the original merge sort, plus a\nfallback to heap sort instead of quick sort; for more information:\n\n  https://sourceware.org/pipermail/libc-alpha/2024-January/154051.html\n\n========================================================================\nDiscussion\n========================================================================\n\nWe have not tried to find a vulnerable program (i.e., a program that\nuses a nontransitive comparison function to qsort() attacker-controlled\nelements); however, vulnerable programs are certain to exist in the real\nworld:\n\n- calls to qsort() are extremely common;\n\n- nontransitive comparison functions are also common;\n\n- all glibc versions from at least September 1992 (glibc 1.04, the first\n  version that we could find online) to the current release (glibc 2.38)\n  are affected by this memory corruption.\n\nLocally, forcing a malloc() failure in qsort() (which is necessary to\nreach the memory corruption) is easy: either execute the target program\n(e.g., a SUID-root program) with a low RLIMIT_AS, or allocate a large\namount of memory with another program on the same machine.\n\nRemotely, forcing this malloc() failure is harder: either allocate a\nlarge amount of memory (e.g., a memory leak) in the network service that\nis being targeted, or in another network service on the same machine.\n\n========================================================================\nAcknowledgments\n========================================================================\n\nWe thank the glibc security team and the linux-distros@...nwall.\n\n========================================================================\nTimeline\n========================================================================\n\n2023-12-12: We sent a draft of our advisory to the glibc security team.\nThey immediately acknowledged receipt of our email.\n\n2023-12-19: The glibc security team decided to not treat this memory\ncorruption in qsort() as a vulnerability in the glibc itself, as\nexplained in the \"Summary\" of our advisory.\n\n2024-01-16: We backported commit b9390ba to all current and past stable\nversions of the glibc, and sent this patch and a draft of our advisory\nto the linux-distros@...nwall (to piggyback on the glibc embargo for\nCVE-2023-6246). They immediately acknowledged receipt of our email.\n\n2024-01-30: Coordinated Release Date (18:00 UTC).\n\n```"]