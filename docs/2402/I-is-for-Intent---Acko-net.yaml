- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:39:56'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: I is for Intent — Acko.net
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://acko.net/blog/i-is-for-intent/](https://acko.net/blog/i-is-for-intent/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You will also conclude there is nothing more nefarious than a hard split between
    back-end and front-end. You know, coded by different people, where each side is
    only half-aware of the other's needs, but one sits squarely in front of the other.
    Well-intentioned guesses about what the other end needs will often be wrong. You
    will end up with data types and query models that cannot answer questions concisely
    and efficiently, and which must be babysat to not go stale.
  prefs: []
  type: TYPE_NORMAL
- en: In the last 20 years, little has changed here in the wild. On the back-end,
    it still looks mostly the same. Even when modern storage solutions are deployed,
    people end up putting SQL- and ORM-like layers on top, because that's what's familiar.
    The split between back-end and database has the exact same malaise.
  prefs: []
  type: TYPE_NORMAL
- en: 'None of this work actually helps make the app more reliable, it''s the opposite:
    every new feature makes on-going development harder. Many "solutions" in this
    space are not solutions, they are copes. Maybe we''re overdue for a NoSQL-revival,
    this time with a focus on practical schema design and mutation? SQL was designed
    to model administrative business processes, not live interaction. I happen to
    believe a front-end should sit *next* to the back-end, not in front of it, with
    only a thin proxy as a broker.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What I can tell you for sure is: it''s so much better when intent is a first-class
    concept. You don''t need nor want to treat user data as something to pussy-foot
    around, or handle like it''s radioactive. You can manipulate and transport it
    without a care. You can build rich, comfy functionality on top. Once implemented,
    you may find yourself not touching your network code for a very long time. It''s
    the opposite of overwhelming, it''s lovely. You can focus on building the tools
    your users need.'
  prefs: []
  type: TYPE_NORMAL
- en: This can pave the way for more advanced concepts like OT and CRDT, but will
    show you that neither of them is a substitute for getting your application fundamentals right.
  prefs: []
  type: TYPE_NORMAL
- en: 'In doing so, you reach a synthesis of Dijkstra and anti-Dijkstra: your program
    should be [provably correct in its data flow](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD02xx/EWD288.html),
    which means it can safely break in completely arbitrary ways.'
  prefs: []
  type: TYPE_NORMAL
- en: Because the I in UI meant "intent" all along.
  prefs: []
  type: TYPE_NORMAL
- en: '**More:**'
  prefs: []
  type: TYPE_NORMAL
