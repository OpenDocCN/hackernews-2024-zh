- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:00:10'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: htmz - a low power tool for html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://leanrada.com/htmz/](https://leanrada.com/htmz/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: =>htmz>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*a low power tool for html*'
  prefs: []
  type: TYPE_NORMAL
- en: '**htmz** is a minimalist HTML microframework for creating interactive and modular
    web user interfaces with the familiar simplicity of **plain HTML**. [[GitHub]](https://github.com/Kalabasa/htmz)'
  prefs: []
  type: TYPE_NORMAL
- en: plainüç¶
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use straight up HTML. No supersets. No hz- ng- hx- v- w- x-; no special attributes.
    No DSLs. No <custom-elements>. *Just vanilla HTML.*
  prefs: []
  type: TYPE_NORMAL
- en: lightweightü™∂
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**166 bytes in total.** Zero dependencies. Zero JS bundles to load. Not even
    a backend is required. *Just an inline HTML snippet*.'
  prefs: []
  type: TYPE_NORMAL
- en: nofilter‚ö°
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No preventDefaults. No hidden layers. Real DOM, real interactions. No VDOM,
    no click listeners. No AJAX, no fetch. *No reinventing browsers*.
  prefs: []
  type: TYPE_NORMAL
- en: '**In a nutshell, htmz** lets you swap page fragments on request using vanilla
    HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine clicking a link, but instead of reloading the whole page, it *only updates
    the relevant portion of the page*.
  prefs: []
  type: TYPE_NORMAL
- en: htmz is an *experiment* inspired by [htmx](https://htmx.org/), [Comet](https://en.wikipedia.org/wiki/Comet_(programming)),
    ‚ÄòHTML As The Engine Of Application State‚Äô[[1]](https://en.wikipedia.org/wiki/HATEOAS)[[2]](https://htmx.org/essays/hateoas/),
    and other similar web application architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Demos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check out these demos to get an idea of what htmz can do!
  prefs: []
  type: TYPE_NORMAL
- en: üêô Select an example above!
  prefs: []
  type: TYPE_NORMAL
- en: 'See also: [Extensions üç±](extensions/)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simply copy the following snippet into your page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For **npm enjoyers**, use the following npm commands to automate the *simple
    process of copying the snippet*. For maximum npm enjoyment, this npm package contains
    25 bonus dependencies!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For **hackers**, you may start with the development version (deminified): [htmz.dev.html](https://github.com/Kalabasa/htmz/blob/master/htmz.dev.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To invoke htmz, you need a hyperlink (or form) having these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: href (or action) pointing to the **resource URL** `href="/flower.html‚ãØ`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continuing within the href: **destination ID selector** `‚ãØ#my-element"`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And a **target** attribute with this value `target=**htmz**`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While this looks like an abuse of the URL fragment (it is), there is no other
    use for the URL fragment in this context, so it was repurposed as the destination
    ID selector. And it already looks like a CSS ID selector.
  prefs: []
  type: TYPE_NORMAL
- en: '**‚ö† Important note:** The loaded content **replaces** the selected destination.
    It may not be intuitive at first, but htmz does *not* insert the content into
    the destination. The rationale is that replacement is a more powerful operation.
    With replacement, you can *replace*, *delete* (replace with nothing), and *insert-into*
    (replace with the same container as original).'
  prefs: []
  type: TYPE_NORMAL
- en: What does it do exactly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: htmz does one thing and one thing only.
  prefs: []
  type: TYPE_NORMAL
- en: '**Load HTML onto *any element* in the page on request.**'
  prefs: []
  type: TYPE_NORMAL
- en: Think tabbed UIs, dual-pane list-detail layouts, dialogs, in-place editors,
    and the like.
  prefs: []
  type: TYPE_NORMAL
- en: '*This idea is not new.* Dividing web pages into independently reloading parts
    has been a thing since mid-1990s. They were called [**frames**](https://www.w3.org/TR/html401/present/frames.html),
    namely, <iframe>s, <frame>s, and <frameset>s.'
  prefs: []
  type: TYPE_NORMAL
- en: '**htmz is a generalisation of HTML frames.** ‚Äî Load HTML resources within ~~any
    frame~~  in the page.'
  prefs: []
  type: TYPE_NORMAL
- en: Read more on [how it works](#how) in a section below.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More example applications, componentization approaches, and code in different
    languages can be found in the `/examples` directory. To start the example server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then load `http://localhost:3000/`.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Naturally, only `<a>` and `<form>` elements can target and invoke htmz (as of
    current HTML5). This is fine; it‚Äôs semantic, after all. However, HTML offers a
    couple more features that work well with htmz.
  prefs: []
  type: TYPE_NORMAL
- en: Per-button action & target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to override the form‚Äôs action on a per-button basis, use the `<button>`‚Äôs
    [`formaction`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#formaction)
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Base target value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tired of adding `target=htmz` to every link and form?
  prefs: []
  type: TYPE_NORMAL
- en: Using the [base](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base)
    element, set htmz as the default target for all relative links. Add this at the
    top of your page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Clean target values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don‚Äôt like the look of `target=htmz` at all? Prefer using the real target as
    the value?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do a hack that enables you to write the target ID selector in the target
    attribute itself! Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The key is to add an iframe with a *matching name*, and modify the htmz snippet
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can even [automate the generation of matching target iframes](https://github.com/Kalabasa/htmz/blob/master/examples/cf_clean_target_tabs/worker.js).
  prefs: []
  type: TYPE_NORMAL
- en: Support opening links in a new tab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if the user opens an htmz link in a new tab? Well, they would be loading
    your page fragment, carefully designed to be injected into an exsting page, on
    its own!
  prefs: []
  type: TYPE_NORMAL
- en: Using the [**Sec-Fetch-Dest**](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Dest)
    header, you can [fall back to a full page](https://github.com/Kalabasa/htmz/blob/master/examples/php_new_tab_detection/content.php)
    in these cases. This header lets the server know the request‚Äôs destination and
    render either a fragment or a full page appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting / interactivity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need something more interactive than the request-response model, you
    may try the htmz companion scripting language: **javazcript**. Sorry, I meant
    JavaScript, a scripting language designed to make HTML interactive.'
  prefs: []
  type: TYPE_NORMAL
- en: htmz does not preclude you writing JS or using UI libraries to enhance interaction.
    You could, say, enhance a single form control with [vanillaJS](http://vanilla-js.com/),
    but the form *values* could still be submitted as a regular HTTP form with htmz.
  prefs: []
  type: TYPE_NORMAL
- en: That said, htmz is extensible!
  prefs: []
  type: TYPE_NORMAL
- en: Extensibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Need advanced selectors? Need error handling? Multiple targets? Fear not; the
    hero is here to save the day. The hero is you.
  prefs: []
  type: TYPE_NORMAL
- en: Here‚Äôs [the development version of the snippet](https://github.com/Kalabasa/htmz/blob/master/htmz.dev.html).
    Feel free to hack and extend according to your needs. You‚Äôre a programmer, right?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Pre-written extensions are now available in the [Extensions üç± page](extensions/).**'
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: htmz is an iframe named "htmz". You invoke htmz by loading a URL into the iframe
    via target=htmz. By using an iframe, we lean on the browser‚Äôs native capability
    to fetch the URL and parse the HTML. After loading the HTML resource, we take
    the resulting DOM via an onload handler.
  prefs: []
  type: TYPE_NORMAL
- en: htmz is essentially a **proxy target**.
  prefs: []
  type: TYPE_NORMAL
- en: Like how a proxy server forwards requests to some specified server, proxy target
    htmz forwards responses into some specified target.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When you load a URL into the htmz iframe, the onload handler kicks in. It extracts
    your destination ID selector from the URL hash fragment and transplants the iframe‚Äôs
    contents (now containing the loaded HTML resource) into your specified destination.
  prefs: []
  type: TYPE_NORMAL
- en: htmz only runs when you invoke it. It does not continually parse your DOM and
    scan it for special attributes or syntax, nor does it attach listeners in your
    DOM. It‚Äôs a proxy not a VPN.
  prefs: []
  type: TYPE_NORMAL
- en: So it‚Äôs just another JavaScript framework?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Oh my! Not the f-word!!!
  prefs: []
  type: TYPE_NORMAL
- en: On a more serious note, I would say that rather than a JS one, it‚Äôs more of
    an HTML micro-f*******k. It does use JS, but only the minimum necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Is htmz a library or a framework?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: htmz is a snippet. ‚úÇÔ∏è
  prefs: []
  type: TYPE_NORMAL
- en: What does htmz mean?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTMZ stands for ***H**tml with **T**argeted **M**anipulation **Z**ones.*
  prefs: []
  type: TYPE_NORMAL
- en: Is this a joke?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This started as a *‚ÄúDo I really need htmx? Can‚Äôt I do the load-link-into-target
    thing with current web? Sounds a lot like frames.‚Äù* and ended up with this.
  prefs: []
  type: TYPE_NORMAL
- en: So, it isn‚Äôt quite a joke, but a response to htmx. I wanted to try htmx. The
    premise sounded great (*Why should you only be able to replace the entire screen?*),
    then I saw that it was 16kB of JavaScript. Huh. Then there‚Äôs special syntax everywhere.
    Huh. I don‚Äôt want to learn a whole new set of instructions and Turing-complete
    DSLs specific to those instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of joke status, htmz seems fine as a library. It feels kinda powerful
    for its tiny size. (But really it‚Äôs the browser that‚Äôs doing the heavy lifting!)
    Nonetheless, there are limitations.
  prefs: []
  type: TYPE_NORMAL
- en: What are the limitations?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main direct limitation is having only one destination per response. However,
    this can be fixed by writing an extension. ;)
  prefs: []
  type: TYPE_NORMAL
- en: A more general but classic limitation is the request-response model. The Web
    1.0 model, and the baggage that comes with it. Like a roundtrip delay on every
    interaction, a browser history entry on every click, etc.
  prefs: []
  type: TYPE_NORMAL
- en: The Web 1.0 model might also mean putting more UI logic in the web server. This
    can be a good thing or a bad thing, as it could lead to either consolidation or
    fragmentation of UI logic, which respectively decreases or increases complexity.
    It really depends on your goal and style.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, this is not a templating library! No HTML imports or client-side includes.
  prefs: []
  type: TYPE_NORMAL
