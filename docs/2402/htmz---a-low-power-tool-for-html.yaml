- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-27 15:00:10'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 15:00:10
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: htmz - a low power tool for html
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: htmz - 一个低功率工具用于处理 HTML
- en: 来源：[https://leanrada.com/htmz/](https://leanrada.com/htmz/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://leanrada.com/htmz/](https://leanrada.com/htmz/)
- en: =>htmz>
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: =>htmz>
- en: '*a low power tool for html*'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个低功率工具用于处理 HTML*'
- en: '**htmz** is a minimalist HTML microframework for creating interactive and modular
    web user interfaces with the familiar simplicity of **plain HTML**. [[GitHub]](https://github.com/Kalabasa/htmz)'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**htmz** 是一个极简的 HTML 微框架，用于创建交互式和模块化的 Web 用户界面，具有**纯 HTML** 的简单易用性。[[GitHub]](https://github.com/Kalabasa/htmz)'
- en: plain🍦
  id: totrans-split-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯🍦
- en: Use straight up HTML. No supersets. No hz- ng- hx- v- w- x-; no special attributes.
    No DSLs. No <custom-elements>. *Just vanilla HTML.*
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯 HTML。没有超集。没有 hz- ng- hx- v- w- x-；没有特殊属性。没有 DSL。没有 <custom-elements>。*只是纯
    HTML*。
- en: lightweight🪶
  id: totrans-split-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轻量级🪶
- en: '**166 bytes in total.** Zero dependencies. Zero JS bundles to load. Not even
    a backend is required. *Just an inline HTML snippet*.'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**总共 166 字节。** 零依赖。零 JS 捆绑包加载。甚至不需要后端。*只需内联 HTML 片段*。'
- en: nofilter⚡
  id: totrans-split-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无过滤器⚡
- en: No preventDefaults. No hidden layers. Real DOM, real interactions. No VDOM,
    no click listeners. No AJAX, no fetch. *No reinventing browsers*.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 preventDefaults。没有隐藏层。真实的 DOM，真实的交互。没有 VDOM，没有点击侦听器。没有 AJAX，没有 fetch。*不重新发明浏览器*。
- en: '**In a nutshell, htmz** lets you swap page fragments on request using vanilla
    HTML.'
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**简而言之，htmz** 允许你根据请求交换页面片段，使用纯 HTML。'
- en: Imagine clicking a link, but instead of reloading the whole page, it *only updates
    the relevant portion of the page*.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象点击一个链接，但不是重新加载整个页面，而是*仅更新页面的相关部分*。
- en: htmz is an *experiment* inspired by [htmx](https://htmx.org/), [Comet](https://en.wikipedia.org/wiki/Comet_(programming)),
    ‘HTML As The Engine Of Application State’[[1]](https://en.wikipedia.org/wiki/HATEOAS)[[2]](https://htmx.org/essays/hateoas/),
    and other similar web application architectures.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: htmz 是一个*实验*，灵感来自于 [htmx](https://htmx.org/)、[Comet](https://en.wikipedia.org/wiki/Comet_(programming))、‘HTML
    As The Engine Of Application State’[[1]](https://en.wikipedia.org/wiki/HATEOAS)[[2]](https://htmx.org/essays/hateoas/)
    等类似的 Web 应用架构。
- en: Demos
  id: totrans-split-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示
- en: Check out these demos to get an idea of what htmz can do!
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这些演示，了解 htmz 的功能！
- en: 🐙 Select an example above!
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 🐙 从上面选择一个示例！
- en: 'See also: [Extensions 🍱](extensions/)'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅：[扩展 🍱](extensions/)
- en: Installing
  id: totrans-split-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'Simply copy the following snippet into your page:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将以下片段直接复制到您的页面中：
- en: '[PRE0]'
  id: totrans-split-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For **npm enjoyers**, use the following npm commands to automate the *simple
    process of copying the snippet*. For maximum npm enjoyment, this npm package contains
    25 bonus dependencies!
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **npm 爱好者**，请使用以下 npm 命令来自动化*复制片段的简单过程*。对于最大的 npm 乐趣，此 npm 包包含 25 个额外依赖项！
- en: '[PRE1]'
  id: totrans-split-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For **hackers**, you may start with the development version (deminified): [htmz.dev.html](https://github.com/Kalabasa/htmz/blob/master/htmz.dev.html)'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **黑客**，你可以从开发版本（未混淆的）开始：[htmz.dev.html](https://github.com/Kalabasa/htmz/blob/master/htmz.dev.html)
- en: Basic usage
  id: totrans-split-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本使用
- en: 'To invoke htmz, you need a hyperlink (or form) having these attributes:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 htmz，您需要一个具有以下属性的超链接（或表单）：
- en: href (or action) pointing to the **resource URL** `href="/flower.html⋯`
  id: totrans-split-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: href（或动作）指向的 **资源 URL** `href="/flower.html⋯`
- en: 'Continuing within the href: **destination ID selector** `⋯#my-element"`'
  id: totrans-split-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 href 中继续：**目标 ID 选择器** `⋯#my-element"`
- en: And a **target** attribute with this value `target=**htmz**`
  id: totrans-split-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并带有这个值的 **目标** 属性 `target=**htmz**`
- en: '[PRE2]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While this looks like an abuse of the URL fragment (it is), there is no other
    use for the URL fragment in this context, so it was repurposed as the destination
    ID selector. And it already looks like a CSS ID selector.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来像是滥用 URL 片段（确实是），但在这种情况下 URL 片段没有其他用途，因此它被重新用作目标 ID 选择器。而且它已经看起来像是一个 CSS
    ID 选择器。
- en: '**⚠ Important note:** The loaded content **replaces** the selected destination.
    It may not be intuitive at first, but htmz does *not* insert the content into
    the destination. The rationale is that replacement is a more powerful operation.
    With replacement, you can *replace*, *delete* (replace with nothing), and *insert-into*
    (replace with the same container as original).'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**⚠ 重要提示：** 加载的内容**替换**了所选目标。一开始可能不直观，但 htmz 不会将内容插入目标中。理由是替换是一种更强大的操作。通过替换，你可以*替换*、*删除*（替换为空）、*插入到*（替换为与原始容器相同的容器）。'
- en: What does it do exactly?
  id: totrans-split-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它确切地做什么？
- en: htmz does one thing and one thing only.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: htmz 只做一件事。
- en: '**Load HTML onto *any element* in the page on request.**'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**在页面上的 *任意元素* 上请求加载 HTML。**'
- en: Think tabbed UIs, dual-pane list-detail layouts, dialogs, in-place editors,
    and the like.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 思考选项卡式用户界面（tabbed UIs）、双窗格列表-详细布局、对话框、原地编辑器等。
- en: '*This idea is not new.* Dividing web pages into independently reloading parts
    has been a thing since mid-1990s. They were called [**frames**](https://www.w3.org/TR/html401/present/frames.html),
    namely, <iframe>s, <frame>s, and <frameset>s.'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**此想法并非新颖。** 分割网页并各自加载自 1990 年代中叶以来就是一项技术。它们被称为[**帧**](https://www.w3.org/TR/html401/present/frames.html)，即如果rame
    s、<frame>s 和 <frameset>s。'
- en: '**htmz is a generalisation of HTML frames.** — Load HTML resources within ~~any
    frame~~  in the page.'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**htmz 是 HTML 帧的泛化。** - 在页面内的任意 frame 中加载 HTML 资源。'
- en: Read more on [how it works](#how) in a section below.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[如何运作]`这一部分中查看如何运行的详细信息。
- en: Examples
  id: totrans-split-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'More example applications, componentization approaches, and code in different
    languages can be found in the `/examples` directory. To start the example server:'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例应用、组件化方法和不同语言的代码可在 `/examples` 目录中找到。启动示例服务器的步骤如下：
- en: '[PRE3]'
  id: totrans-split-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then load `http://localhost:3000/`.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后加载 `http://localhost:3000/`。
- en: Advanced usage
  id: totrans-split-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进阶使用
- en: Naturally, only `<a>` and `<form>` elements can target and invoke htmz (as of
    current HTML5). This is fine; it’s semantic, after all. However, HTML offers a
    couple more features that work well with htmz.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 理所当然地，只有 `<a>` 和 `<form>`元素可以目标化和调用 htmz（到目前为止，HTML5 提供的）。这很合理；毕竟，这是语义相关的。不过，HTML
    还提供了一两个与 htmz 搭配使用的特性。
- en: Per-button action & target
  id: totrans-split-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按按钮的行动与目标
- en: If you want to override the form’s action on a per-button basis, use the `<button>`’s
    [`formaction`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#formaction)
    attribute.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在每个按钮的基础上更迭表单的行动，可以利用 `<button>` 的 `formaction` 属性。
- en: '[PRE4]'
  id: totrans-split-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Base target value
  id: totrans-split-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认目标值
- en: Tired of adding `target=htmz` to every link and form?
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 厌倦了在每条链接和形式上添加 `target=htmz`？
- en: Using the [base](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base)
    element, set htmz as the default target for all relative links. Add this at the
    top of your page.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [base](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base) 元素，**设置
    htmz 作为所有相对链接的默认目标**。请在页面顶部添加这一配置。
- en: '[PRE5]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Clean target values
  id: totrans-split-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清洁目标值
- en: Don’t like the look of `target=htmz` at all? Prefer using the real target as
    the value?
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不喜欢 `target=htmz` 这种形式？想要使用实际目标作为值呢？
- en: 'We can do a hack that enables you to write the target ID selector in the target
    attribute itself! Like this:'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现一项巧妙策略，使你可以在目标属性本身编写目标 ID 选择器！使用这种方式：
- en: '[PRE6]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The key is to add an iframe with a *matching name*, and modify the htmz snippet
    accordingly.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于添加具有*匹配名字*的 iframe，并相应地修改 htmz 配置。
- en: '[PRE7]'
  id: totrans-split-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can even [automate the generation of matching target iframes](https://github.com/Kalabasa/htmz/blob/master/examples/cf_clean_target_tabs/worker.js).
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过[自动化生成匹配源 iframe](https://github.com/Kalabasa/htmz/blob/master/examples/cf_clean_target_tabs/worker.js)。
- en: Support opening links in a new tab
  id: totrans-split-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持在新标签页中打开链接
- en: What if the user opens an htmz link in a new tab? Well, they would be loading
    your page fragment, carefully designed to be injected into an exsting page, on
    its own!
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 用户如何在新标签页中打开 htmz 链接呢？实际上，他们就是加载自定义设计、格式切除你的页面片段，将其独立加载在单独的页面上！
- en: Using the [**Sec-Fetch-Dest**](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Dest)
    header, you can [fall back to a full page](https://github.com/Kalabasa/htmz/blob/master/examples/php_new_tab_detection/content.php)
    in these cases. This header lets the server know the request’s destination and
    render either a fragment or a full page appropriately.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用[**Sec-Fetch-Dest**](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Dest)
    配置，遇到以下情况时，你可以[回退到完整页面](https://github.com/Kalabasa/htmz/blob/master/examples/php_new_tab_detection/content.php)。这条配置让服务器了解到请求的目标，并适当地呈现片段或完整页面。
- en: Scripting / interactivity
  id: totrans-split-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本化/互动性
- en: 'If you need something more interactive than the request-response model, you
    may try the htmz companion scripting language: **javazcript**. Sorry, I meant
    JavaScript, a scripting language designed to make HTML interactive.'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 若需超越请求-响应模型的互动性，可以尝试 htmz 的伴生脚本语言 **JavaScript**。抱歉，我指的 **JavaScript** 正好是一种内联脚本语言，旨在增强
    HTML 的互动性。
- en: htmz does not preclude you writing JS or using UI libraries to enhance interaction.
    You could, say, enhance a single form control with [vanillaJS](http://vanilla-js.com/),
    but the form *values* could still be submitted as a regular HTTP form with htmz.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: htmz 并不妨碍你使用 JS 或 UI 库来增强交互。例如，你可以只用[vanillaJS](http://vanilla-js.com/)就增强单个表单控件，但仍然可以通过
    htmz 正常提交包括单表按钮在内的所有常规 HTTP 表单。
- en: That said, htmz is extensible!
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，htmz 是高度可扩展的！
- en: Extensibility
  id: totrans-split-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Need advanced selectors? Need error handling? Multiple targets? Fear not; the
    hero is here to save the day. The hero is you.
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 具备高级选择器？有错误处理？需要多重目标吗？别担心，英雄已准备好拯救你。
- en: Here’s [the development version of the snippet](https://github.com/Kalabasa/htmz/blob/master/htmz.dev.html).
    Feel free to hack and extend according to your needs. You’re a programmer, right?
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[片段的开发版本](https://github.com/Kalabasa/htmz/blob/master/htmz.dev.html)。根据你的需要随意进行修改和扩展。你是程序员，对吧？
- en: '[PRE8]'
  id: totrans-split-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Pre-written extensions are now available in the [Extensions 🍱 page](extensions/).**'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在可以在[扩展 🍱 页面](extensions/)找到预写的扩展。**'
- en: FAQ
  id: totrans-split-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见问题
- en: How does it work?
  id: totrans-split-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: htmz is an iframe named "htmz". You invoke htmz by loading a URL into the iframe
    via target=htmz. By using an iframe, we lean on the browser’s native capability
    to fetch the URL and parse the HTML. After loading the HTML resource, we take
    the resulting DOM via an onload handler.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: htmz是一个名为"htmz"的iframe。你通过target=htmz将一个URL加载到iframe中来调用htmz。通过使用iframe，我们依赖浏览器的原生能力来获取URL并解析HTML。加载HTML资源后，我们通过onload处理程序获取结果的DOM。
- en: htmz is essentially a **proxy target**.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: htmz本质上是一个**代理目标**。
- en: Like how a proxy server forwards requests to some specified server, proxy target
    htmz forwards responses into some specified target.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像代理服务器将请求转发到某个指定服务器一样，htmz代理将响应转发到某个指定的目标。
- en: '[PRE9]'
  id: totrans-split-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you load a URL into the htmz iframe, the onload handler kicks in. It extracts
    your destination ID selector from the URL hash fragment and transplants the iframe’s
    contents (now containing the loaded HTML resource) into your specified destination.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个URL加载到htmz iframe中时，onload处理程序会启动。它从URL哈希片段中提取你的目标ID选择器，然后将iframe的内容（现在包含加载的HTML资源）移植到你指定的目标中。
- en: htmz only runs when you invoke it. It does not continually parse your DOM and
    scan it for special attributes or syntax, nor does it attach listeners in your
    DOM. It’s a proxy not a VPN.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: htmz只有在调用时才会运行。它不会持续解析你的DOM并扫描特殊属性或语法，也不会在你的DOM中附加监听器。它是一个代理而不是VPN。
- en: So it’s just another JavaScript framework?
  id: totrans-split-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所以这只是另一个JavaScript框架？
- en: Oh my! Not the f-word!!!
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 哦天啊！不是那个脏话！！！
- en: On a more serious note, I would say that rather than a JS one, it’s more of
    an HTML micro-f*******k. It does use JS, but only the minimum necessary.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 更严肃地说，我会说它不像是一个纯JS的，更像是一个HTML微型f*******k。它确实使用了JS，但只是必要的最小限度。
- en: Is htmz a library or a framework?
  id: totrans-split-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: htmz是一个库还是一个框架？
- en: htmz is a snippet. ✂️
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: htmz只是一个片段。✂️
- en: What does htmz mean?
  id: totrans-split-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: htmz是什么意思？
- en: HTMZ stands for ***H**tml with **T**argeted **M**anipulation **Z**ones.*
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: HTMZ代表***H**tml with **T**argeted **M**anipulation **Z**ones*（带有定向操纵区的HTML）。
- en: Is this a joke?
  id: totrans-split-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这是一个笑话吗？
- en: This started as a *“Do I really need htmx? Can’t I do the load-link-into-target
    thing with current web? Sounds a lot like frames.”* and ended up with this.
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最初只是一个*“我真的需要htmx吗？我不能用当前的Web做加载-链接到目标的事情吗？听起来很像框架。”*，结果却变成了这样。
- en: So, it isn’t quite a joke, but a response to htmx. I wanted to try htmx. The
    premise sounded great (*Why should you only be able to replace the entire screen?*),
    then I saw that it was 16kB of JavaScript. Huh. Then there’s special syntax everywhere.
    Huh. I don’t want to learn a whole new set of instructions and Turing-complete
    DSLs specific to those instructions.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这并不完全是一个笑话，而是对htmx的回应。我想尝试htmx。起初听起来很棒（*为什么你只能替换整个屏幕？*），然后我看到它是16kB的JavaScript。嗯。然后到处都是特殊的语法。嗯。我不想学习一整套新的指令和特定于这些指令的图灵完备DSL。
- en: Regardless of joke status, htmz seems fine as a library. It feels kinda powerful
    for its tiny size. (But really it’s the browser that’s doing the heavy lifting!)
    Nonetheless, there are limitations.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不管是不是笑话，htmz作为一个库似乎表现不错。尽管其体积小，但感觉功能强大。（但实际上是浏览器在进行大部分工作！）尽管如此，也存在一些限制。
- en: What are the limitations?
  id: totrans-split-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有哪些限制？
- en: The main direct limitation is having only one destination per response. However,
    this can be fixed by writing an extension. ;)
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的直接限制是每个响应只有一个目标。不过，这可以通过编写扩展来解决。;)
- en: A more general but classic limitation is the request-response model. The Web
    1.0 model, and the baggage that comes with it. Like a roundtrip delay on every
    interaction, a browser history entry on every click, etc.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更普遍但经典的限制是请求-响应模型。Web 1.0模型及其带来的负担。比如每次交互都会有一个往返延迟，每次点击都会有一个浏览器历史记录条目等。
- en: The Web 1.0 model might also mean putting more UI logic in the web server. This
    can be a good thing or a bad thing, as it could lead to either consolidation or
    fragmentation of UI logic, which respectively decreases or increases complexity.
    It really depends on your goal and style.
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: Web 1.0模型可能意味着将更多的UI逻辑放在Web服务器中。这可能是好事，也可能是坏事，因为它可能导致UI逻辑的统一化或分散化，分别降低或增加复杂性。这实际上取决于你的目标和风格。
- en: Lastly, this is not a templating library! No HTML imports or client-side includes.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这不是一个模板化库！没有HTML导入或客户端包含。
