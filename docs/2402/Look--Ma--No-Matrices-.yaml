- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 13:26:56'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Look, Ma, No Matrices!
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://enkimute.github.io/LookMaNoMatrices/](https://enkimute.github.io/LookMaNoMatrices/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look, Ma, No Matrices!
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Steven De Keninck**'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: Putting PGA ($\mathbb R_{3,0,1}$) to the test! Since the 2019 SIGGRAPH course
    [1], Geometric Algebra, and Euclidean PGA (plane-based or projective geometric
    algebra) in particular, has been gaining traction within the computer graphics
    and machine learning communities [2, 3, 4]. Despite its broad applicability, including
    for higher dimensional geometry and physics, its adoption in traditional 3D graphics
    has been limited, often merely re-branding a dual quaternion as a PGA motor. The
    ’Look, Ma, No Matrices!’ project aims to broaden PGA’s application by introducing
    a modern, glTF-compliant, forward-rendering 3D engine that fully integrates the
    PGA algebra.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: In this write up, we will go over this project, highlighting the solutions and
    techniques that are required when moving to a PGA implementation. It was at times
    tempting to start from the existing techniques and attempt an 'algebra-level'
    translation. This however often leads to unsatisfactory solutions and in order
    for PGA to truly reach its potential a more fundamental revisit is often needed.
    Algebra without geometry, indeed, is blind.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: Introduction.
  id: totrans-split-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matrices are everywhere in computer graphics. In fact, there was a time when
    4x4 matrices were both baked into the GPU and a mandatory part of all graphics
    API's. This project would then simply not have been possible. Today however, pushed
    in no small part by the advancements in AI, GPU's are highly programmable scalar
    processors, no longer tied into the long gone fixed function pipeline. Yet, 4x4
    matrices are still omnipresent. And why should they not be? They can represent
    all linear transformations, and the typical forward graphics pipeline indeed involves
    both rigid and projective transformations. Seems like a good fit.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Quaternions are also everywhere in computer graphics. Turns out, matrices have
    less than ideal interpolation properties, and modern formats like Khronos' glTF
    use quaternions for all their rotation needs. Fantastic for animations, and generally
    considered worth the cost of the unavoidable conversions to and from matrices.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: Out in the real world, however, the vast majority of matrices in your typical
    3D engine setup are going to be orthogonal matrices, encoding just rotations and
    translations. And this is where the motor manifold of PGA comes in. At a lower
    computational and memory cost, PGA motors encode the full set of Euclidean motions,
    additionally offering conversion free inclusion of quaternions and dual quaternions.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: This of course raises the question - can we replace all matrices in a typical
    forward renderer by their PGA equivalents ? Is a true matrix free setup possible
    or even desirable ? Only one way to find out ...
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: But before we start, a short disclaimer. This project aims to replace matrices
    without compromise. That, of course, is not how one should approach any engineering
    problem. As a reference for this project we are using the Khronos glTF viewer.
    This is a sensible choice, as no doubt others will use this as reference, but
    it does not attempt to be an optimal implementation. It uses 4x4 matrices in full,
    and the built-in glsl operators for them for most operations, when experienced
    graphics programmers know there are still wins there. The point here is not to
    make the most optimal implementation, especially in light of some of the findings
    here, the most optimal implementation is most likely a hybrid solution, subject
    to a future writeup!
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但在开始之前，有一个简短的免责声明。本项目旨在无需妥协地替换矩阵。当然，这并不是解决任何工程问题的正确方法。作为本项目的参考，我们使用了Khronos
    glTF查看器。这是一个明智的选择，因为毫无疑问其他人也会将其作为参考，但它并不试图成为最佳实现。它完全使用4x4矩阵和它们的内置glsl运算符来进行大多数操作，而经验丰富的图形程序员知道在那里仍然存在优势。这里的重点不是做出最优实现，特别是考虑到这里的一些发现，最优实现很可能是一个混合解决方案，未来会进行详细的介绍！
- en: 'FPGA : Fast PGA!'
  id: totrans-split-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FPGA：快速PGA！
- en: A full introduction to PGA is outside of the scope of this article, and we will
    assume the reader is familiar with at least the material in [1, 5, 6]. Instead,
    we will focus on the choices made for this particular implementation, and specifically
    work out in detail the basic operators that are needed, both for CPU and GPU.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本文不涵盖PGA的完整介绍，我们假设读者至少熟悉[1, 5, 6]中的内容。我们将专注于为这个特定实现所做的选择，并详细说明所需的基本运算符，无论是在CPU还是GPU上。
- en: Basics and Basis
  id: totrans-split-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础和基础
- en: 'The PGA algebra is generated by four basis vectors $\mathbf e_0$ to $\mathbf
    e_3$. The $\mathbf e_1, \mathbf e_2, \mathbf e_3$ vectors map to the $x=0, y=0,
    z=0$ planes respectively while the special degenerate $\mathbf e_0$ vector represents
    the plane at infinity. These four generators are then combined to form six bivectors,
    four trivectors and a single quadvector that together with the scalar represent
    all of the PGA elements. Our specific choice for basis and memory layout was selected
    to minimize convertions when handling typical graphics data. All of the elements
    of PGA are intricately connected, an overview of our choices and how they map
    to transformations and geometric elements is in the following table (where the
    second row denotes the square of each element) :'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: PGA代数由四个基向量 $\mathbf e_0$ 到 $\mathbf e_3$ 生成。向量 $\mathbf e_1, \mathbf e_2, \mathbf
    e_3$ 分别映射到 $x=0, y=0, z=0$ 平面，而特殊的退化向量 $\mathbf e_0$ 表示无穷远平面。然后这四个生成器结合形成六个双向量，四个三向量和一个单个四向量，再加上标量代表所有PGA元素。我们选择的特定基础和内存布局旨在处理典型图形数据时最小化转换。PGA的所有元素都是密切相关的，我们的选择概述以及它们如何映射到变换和几何元素在下表中详细说明（第二行表示每个元素的平方）：
- en: '| e1 | e2 | e3 | e0 | 1 | e23 | e31 | e12 | e01 | e02 | e03 | e0123 | e032
    | e013 | e021 | e123 |'
  id: totrans-split-20
  prefs: []
  type: TYPE_TB
  zh: '| e1 | e2 | e3 | e0 | 1 | e23 | e31 | e12 | e01 | e02 | e03 | e0123 | e032
    | e013 | e021 | e123 |'
- en: '| +1 | +1 | +1 | 0 | +1 | -1 | -1 | -1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | -1 |'
  id: totrans-split-21
  prefs: []
  type: TYPE_TB
  zh: '| +1 | +1 | +1 | 0 | +1 | -1 | -1 | -1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | -1 |'
- en: '| plane-reflection | Motor / Dual Quaternion / Lie Group | point-reflection
    |'
  id: totrans-split-22
  prefs: []
  type: TYPE_TB
  zh: '| 平面反射 | 电机 / 对偶四元数 / 李群 | 点反射 |'
- en: '| Quaternion |  |'
  id: totrans-split-23
  prefs: []
  type: TYPE_TB
  zh: '| 四元数 |  |'
- en: '| plane $a\mathbf e_1 + b\mathbf e_2 + c\mathbf e_3 + d\mathbf e_0 = 0$ |  |
    Line through orig. | ∞ line |  | point $(x\mathbf e_1 + y\mathbf e_2 + z\mathbf
    e_3 + w\mathbf e_0)^*$ |'
  id: totrans-split-24
  prefs: []
  type: TYPE_TB
  zh: '| 平面 $a\mathbf e_1 + b\mathbf e_2 + c\mathbf e_3 + d\mathbf e_0 = 0$ |  | 通过原点的直线
    | ∞ 线 |  | 点 $(x\mathbf e_1 + y\mathbf e_2 + z\mathbf e_3 + w\mathbf e_0)^*$ |'
- en: '| Line / Lie Algebra |'
  id: totrans-split-25
  prefs: []
  type: TYPE_TB
  zh: '| 线 / 李代数 |'
- en: '| vector | S | bivector | PSS | trivector |'
  id: totrans-split-26
  prefs: []
  type: TYPE_TB
  zh: '| 向量 | S | 双向量 | PSS | 三向量 |'
- en: These choices translate to the following simple shader structures, where we
    opted to stay within the builtin types to retain addition, subtraction and scalar
    multiplication. (glsl does not support operator overloading for custom types).
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择体现在以下简单的着色器结构中，我们选择保持在内置类型内以保留加法、减法和标量乘法。（glsl 不支持自定义类型的运算符重载）。
- en: '[PRE0]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Get your Geometric Products!
  id: totrans-split-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获得你的几何积！
- en: With our data structures defined, we can focus our attention on implementing
    the (subset) of PGA products we will need. Special attention is given to the composition
    and sandwich operators - the numerical efficiency of matrix-vector multiplication
    is well known, and as we will discover, some creativity is needed to get PGA up
    to par.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了数据结构后，可以集中精力实现我们将需要的（部分）PGA乘积。特别关注组合和夹心运算符 - 矩阵-向量乘法的数值效率是众所周知的，正如我们将发现的，需要一些创造力来使PGA达到标准。
- en: Composition of transformations.
  id: totrans-split-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变换组合。
- en: 'The 8-float motors of PGA, isomorphic to the dual quaternions, naturally come
    with an efficient composition operator in the form of the geometric product. Recall
    that the product of two 4x4 matrices requires 64 multiplications and 48 additions.
    For two general PGA motors, their composition clocks in at just 48 multiplications
    and 40 additions. Working out the product at coefficient level produces the following
    implementation on the CPU:'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: PGA的8浮点电机，同构于双四元数，自然带有形式化乘积中的高效组合运算符。回想一下，两个4x4矩阵的乘积需要64次乘法和48次加法。对于两个一般PGA电机，它们的组合仅需48次乘法和40次加法。在CPU上实现其系数级产品如下：
- en: '[PRE1]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This block of code, with some reshuffling and pattern matching can be written
    in glsl using dot and cross products as:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码块经过重新排列和模式匹配后，可以使用点积和叉积在glsl中编写如下：
- en: '[PRE2]'
  id: totrans-split-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While already reasonably efficient, the above code block handles general motors
    and there are many scenarios where we deal with e.g. pure translations or rotations
    around the origin. In those scenarios many of the motor coefficients will be zero,
    and reworking the above code block to incorporate that is an easy task. For example,
    for the composition of two rotations around the origin we find we need only 16
    multiplications and 12 additions:'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经相当高效，上述代码块处理一般电机，而有许多情况我们处理例如纯平移或绕原点旋转。在这些情况下，许多电机系数将为零，将上述代码块重新工作以包含这一点是一项简单的任务。例如，对于两个绕原点旋转的组合，我们发现只需要16次乘法和12次加法：
- en: '[PRE3]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our implementation provides these optimised versions for any combination of
    translation (_t), rotation around the origin (_r) and general motor (_m).
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现为任意组合的平移（_t）、绕原点旋转（_r）和一般运动（_m）提供了这些优化版本。
- en: '| Operation | Multiplications | Additions |'
  id: totrans-split-39
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 乘法 | 加法 |'
- en: '| gp_mm | 48 | 40 |'
  id: totrans-split-40
  prefs: []
  type: TYPE_TB
  zh: '| gp_mm | 48 | 40 |'
- en: '| gp_rr | 16 | 12 |'
  id: totrans-split-41
  prefs: []
  type: TYPE_TB
  zh: '| gp_rr | 16 | 12 |'
- en: '| gp_tt | 0 | 3 |'
  id: totrans-split-42
  prefs: []
  type: TYPE_TB
  zh: '| gp_tt | 0 | 3 |'
- en: '| gp_rt / gp_tr | 12 | 8 |'
  id: totrans-split-43
  prefs: []
  type: TYPE_TB
  zh: '| gp_rt / gp_tr | 12 | 8 |'
- en: '| gp_rm / gp_mr | 32 | 24 |'
  id: totrans-split-44
  prefs: []
  type: TYPE_TB
  zh: '| gp_rm / gp_mr | 32 | 24 |'
- en: '| gp_tm / gp_mt | 12 | 12 |'
  id: totrans-split-45
  prefs: []
  type: TYPE_TB
  zh: '| gp_tm / gp_mt | 12 | 12 |'
- en: Transforming points
  id: totrans-split-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变换点
- en: 'For the transformation of a point $p$ with a motor $M$, done in PGA with the
    sandwich product, the situation is more involved. $$ p'' = M p \widetilde M $$
    Working out these two geometric products naively results in a whopping 33 multiplications
    and 29 additions, or more than twice the 16 multiplications and 12 additions required
    for the matrix-vector equivalent. The reason for this is that this naive expansion
    does not take into account the fact that PGA motors satisfy $M\widetilde M = 1$.
    It is however not to difficult to incorporate this into our sandwich product.
    To do so, we suggest starting instead from the expression $$ p'' = M p \widetilde
    M + p \cdot (1 - M\widetilde M)$$ Where the second term evaluates to zero for
    a normalized motor M. Evaluating this new expression at coefficient level allows
    us to reduce the operations needed to 21 multiplications and 18 additions (which
    for the isomorphic dual quaternions is the best known solution) :'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用夹心乘积在PGA中对点$p$进行变换，情况更为复杂。$$ p' = M p \widetilde M $$ 对这两个几何乘积进行朴素计算结果是33次乘法和29次加法，比矩阵-向量等价物所需的16次乘法和12次加法多出一倍以上。原因是这种朴素展开没有考虑到PGA电机满足$M\widetilde
    M = 1$的事实。然而，将这一点纳入我们的夹心乘积中并不困难。为此，我们建议从以下表达式开始：$$ p' = M p \widetilde M + p \cdot
    (1 - M\widetilde M)$$ 第二项对于归一化电机M为零。在系数级评估这个新表达式允许我们将所需的操作减少到21次乘法和18次加法（这对于同构双四元数是已知的最佳解决方案）：
- en: '[PRE4]'
  id: totrans-split-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Transforming directions
  id: totrans-split-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变换方向
- en: For directions, aka points at infinity, with an implied $\mathbf e_{123}$ coefficient
    of $0$, we can do a bit better still. Applying the same normalisation trick we
    find a solution that requires only 18 multiplications and 12 additions.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方向，即无穷远点，隐含的$\mathbf e_{123}$系数为$0$，我们可以更进一步。应用相同的归一化技巧，我们找到了一个只需要18次乘法和12次加法的解决方案。
- en: '[PRE5]'
  id: totrans-split-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Anticipating our needs when dealing with tangent spaces, we also work out the
    sandwich product on the basis directions. (as opposed to the general direction
    above). In that scenario, the computational cost can be reduced even further.
    In fact, if we produce an output normalized to $0.5$ instead of $1$ we can reduce
    the computational cost for the transformation of e.g. the x axis to an amazing
    6 multiplications and 4 additions - about the cost of a default cross product:'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理切空间时，我们也需要预先计算在基方向上的夹积。（与上述的一般方向相反）。在这种情况下，计算成本可以进一步降低。实际上，如果我们将输出归一化到 $0.5$
    而不是 $1$，我们可以将例如 x 轴的转换计算成本减少到令人惊讶的 6 次乘法和 4 次加法 - 大约是默认叉乘的成本的一半：
- en: '[PRE6]'
  id: totrans-split-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is an important observation, and as you will see will allow us to challenge
    the common belief that matrices are unconditionally the fastest choice ...
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的观察，正如您将看到的，这将使我们有能力挑战普遍认为矩阵无条件是最快选择的共同信念……
- en: Normalisation
  id: totrans-split-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标准化
- en: 'The squared (pseudo)norm of a PGA motor $M$ is given by $$ \lvert M \rvert^2
    = M \widetilde M = a + b\mathbf e_{0123}$$ For a normalized motor, $\lvert M \rvert
    = 1$, but in general the result of this expression is $a + b\mathbf e_{0123}$,
    a Study Number (a multivector whose non-scalar part squares to a scalar). As a
    consequence, the normalized motor $\overline M$, $$ \overline M = \cfrac {M} {\lvert
    M \rvert} $$ is a bit more involved to calculate. In 3D PGA it involves inverting
    a Study Number that here is isomorphic to a dual number. We''ve worked out the
    details for a number of algebras in [7], from which we only need the inverse square
    root formula in 3D PGA : $$\cfrac {1} {\lvert M \rvert} = \cfrac {1} {\sqrt{M
    \widetilde M}} = \cfrac{1}{\sqrt{a + b\mathbf e_{0123}}} = \cfrac{1}{\sqrt{a}}
    - \cfrac{b}{2{\sqrt{a}}^3}\mathbf e_{0123} $$ This leads to the following efficient
    implementation for 3DPGA:'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: PGA（保持旋转运动群）电机 $M$ 的平方（伪）范数由以下给出：$$ \lvert M \rvert^2 = M \widetilde M = a +
    b\mathbf e_{0123}$$ 对于标准化电机，$\lvert M \rvert = 1$，但一般来说，这个表达式的结果是 $a + b\mathbf
    e_{0123}$，一个 Study Number（一个非标量部分平方为标量的多向量）。因此，标准化电机 $\overline M$，$$ \overline
    M = \cfrac {M} {\lvert M \rvert} $$ 计算起来稍微复杂一些。在 3D PGA 中，这涉及求逆一个 Study Number，这里同构于对偶数。我们已经为多个代数[7]解析出细节，在这些中，我们仅需
    3D PGA 中的逆平方根公式：$$\cfrac {1} {\lvert M \rvert} = \cfrac {1} {\sqrt{M \widetilde
    M}} = \cfrac{1}{\sqrt{a + b\mathbf e_{0123}}} = \cfrac{1}{\sqrt{a}} - \cfrac{b}{2{\sqrt{a}}^3}\mathbf
    e_{0123} $$ 这导致以下 3DPGA 的高效实现：
- en: '[PRE7]'
  id: totrans-split-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that this procedure should be compared not to vector normalisation, but
    instead to Gram-Schmidt orthogonalisation, as the resulting motor is guaranteed
    to be an orthonormal transformation. As before, when we are dealing with a pure
    translation or rotation, far more efficient versions of the normalisation procedure
    are available.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个过程应该与向量归一化进行比较，而不是与 Gram-Schmidt 正交化比较，因为结果电机保证是一个正交归一化的变换。与之前一样，在处理纯平移或旋转时，我们可以使用更高效的归一化过程版本。
- en: Square Roots
  id: totrans-split-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 平方根
- en: 'The square root plays an important role in PGA, as it is the key to constructing
    transformations between elements. Given any pair of points/lines/planes $a,b$,
    there exist a rigid transformation that moves $a$ onto $b$. Such a rigid transformation
    always has a motor form, and this motor is always given by the same simple expression
    : $$ M = \sqrt{ \cfrac {b} {a} } $$ Combine this with the fact that for any normalized
    non-null blade $a$ its inverse is $\pm a$, and we can rewrite this as $$ \pm M^2
    = ba $$ Or, in other words, the geometric product $ba$ of any two points, two
    lines or two planes produces a motor that represents double the transformation
    from $a$ to $b$. The square root comes in to halve this result and indeed find
    the motor that moves $a$ exactly onto $b$. Here too, geometric algebra provides
    a single elegant method that universally applies : $$ \sqrt M = \overline{1 +
    M} $$ Here the overline denotes the Study-normalisation procedure from our previous
    block. Hence the computational cost of a square root is exactly that of the normalisation
    procedure with one extra addition.'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在PGA中，平方根发挥着重要作用，因为它是构建元素之间转换的关键。对于任意一对点/线/平面$a, b$，存在将$a$移动到$b$的刚性变换。这样的刚性变换总是具有电动机形式，并且该电动机总是由相同的简单表达式给出：$$
    M = \sqrt{ \cfrac {b} {a} } $$ 结合事实，对于任何归一化的非零刀片$a$，其逆是$\pm a$，我们可以将其重写为 $$ \pm
    M^2 = ba $$ 或者说，任何两个点、两条线或两个平面的几何积$ba$产生一个代表从$a$到$b$的两倍变换的电动机。平方根进入其中，将这个结果减半，并确实找到将$a$移动到$b$的电动机。同样地，几何代数提供了一个通用适用的简洁方法：$$
    \sqrt M = \overline{1 + M} $$ 这里的上划线表示我们先前模块中的Study标准化过程。因此，平方根的计算成本正好等于带有额外加法的标准化过程的成本。
- en: '[PRE8]'
  id: totrans-split-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exponential map
  id: totrans-split-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指数映射
- en: To complete our PGA toolbox, we adapt, also from [7], efficient implementations
    of the logarithmic and exponential maps. Recall that the logarithm of a PGA motor
    is a (sum of) scaled lines, and similarly, any scaled line can be exponentiated
    to construct a rotation around it. While the exponential map for general 4x4 matrices
    is numerically very expensive, for our PGA motor manifold efficient closed form
    solutions are possible.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完善我们的PGA工具箱，我们还从[7]中借鉴了对数和指数映射的高效实现。请记住，PGA电动机的对数是（一组）缩放线的和，类似地，任何缩放线都可以被指数化以构建围绕其旋转的操作。虽然通用4x4矩阵的指数映射在数值上非常昂贵，但对于我们PGA电动机流形，可以使用高效的封闭形式解决方案。
- en: '[PRE9]'
  id: totrans-split-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-split-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Inverses
  id: totrans-split-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逆元素
- en: If there's one place where Geometric Algebra sets itself clearly apart from
    our standard vector and matrix algebra aproach, it is the existense of inverses
    for (multi) vectors. Not only do these inverses exist, but for the normalized
    objects we are working with in our context, they are very efficient to calculate.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个地方，几何代数明显与我们标准的向量和矩阵代数方法不同，那就是（多）向量的逆元素的存在性。这些逆元素不仅存在于我们上下文中正在处理的归一化对象中，而且计算起来非常高效。
- en: '| Element $x$ | Inverse $x^{-1}$ |'
  id: totrans-split-68
  prefs: []
  type: TYPE_TB
  zh: '| 元素 $x$ | 逆元素 $x^{-1}$ |'
- en: '| Plane | $x^{-1} = x$ |'
  id: totrans-split-69
  prefs: []
  type: TYPE_TB
  zh: '| 平面 | $x^{-1} = x$ |'
- en: '| Line | $x^{-1} = -x$ |'
  id: totrans-split-70
  prefs: []
  type: TYPE_TB
  zh: '| 线 | $x^{-1} = -x$ |'
- en: '| Point | $x^{-1} = -x$ |'
  id: totrans-split-71
  prefs: []
  type: TYPE_TB
  zh: '| 点 | $x^{-1} = -x$ |'
- en: '| Motor | $x^{-1} = \widetilde x$ |'
  id: totrans-split-72
  prefs: []
  type: TYPE_TB
  zh: '| 电动机 | $x^{-1} = \widetilde x$ |'
- en: Where $\widetilde x$, the reversion operation, changes the sign of the bivector
    and trivector coefficients only. There is one more inverse that is occasionally
    needed, which is the inverse of a general bivector $B$. Recall that a bivector
    $B$ only represents a single line iff $B \wedge B = 0$, the so called Plucker
    condition. If a bivector $B$ does not satisfy that requirement, it is no blade,
    i.e. not the result of meeting two planes or joining two points. For such an element
    the inverse is slightly more complicated.
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其中$\widetilde x$，即还原操作，仅改变双向量和三向量系数的符号。偶尔还需要一个更一般的逆元素，即一个一般双向量$B$的逆元素。请回忆一下，一个双向量$B$仅在$B
    \wedge B = 0$，即所谓的Plucker条件下代表单一线。如果一个双向量$B$不满足该要求，则它不是刀片，即不是两个平面的交集或两个点的联合的结果。对于这样的元素，其逆元素稍微复杂一些。
- en: To find this inverse, we start by multiplying with the reverse bivector from
    the right. $$ \cfrac {1} {B} = \cfrac {\widetilde B}{B \widetilde B}$$ As before,
    the squared norm of $\lvert B \rvert^2 = B \widetilde B = a + b \mathbf e_{0123}$,
    is a Study number, isomorphic to the dual numbers. This allows us to use the definition
    of a dual number inverse. $$ \cfrac {1} {(a + b \mathbf e_{0123})} = \cfrac {1}
    {a} - \cfrac {b} {a^2} \mathbf e_{0123}$$ Multiplying this last expression with
    $\widetilde B$ produces the inverse we are looking for.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到这个逆，我们从右侧乘以反向双矢量开始。$$ \cfrac {1} {B} = \cfrac {\widetilde B}{B \widetilde
    B} $$ 与之前一样，$\lvert B \rvert^2 = B \widetilde B = a + b \mathbf e_{0123}$的平方范数是一个斯图尔数，与双数同构。这使我们能够使用双数逆的定义。$$
    \cfrac {1} {(a + b \mathbf e_{0123})} = \cfrac {1} {a} - \cfrac {b} {a^2} \mathbf
    e_{0123} $$ 将最后一个表达式与$\widetilde B$相乘产生了我们寻找的逆。
- en: Motor Factorisation
  id: totrans-split-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电机因子分解
- en: Just as the process of factorizing matrices can be very insightful, so is the
    factorization of PGA motors. Two particular factorisations will be useful to us,
    and we will add them as the last tools to our box. The first of those is called
    the *Euclidean Factorisation*, and it decomposes a motor into a rotation around
    the origin followed by a translation. $$ M = T_e R_e $$ This factorisation is
    particularly easy to calculate, as the Euclidean rotor $R_e$ is simply the Euclidean
    part of our motor - the first four floats - isomorphic to a regular quaternion.
    If it is needed, the translation $T_e$ can be computed as $T_e = M \widetilde
    R_e$
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像分解矩阵的过程可以非常有见地一样，PGA电机的分解也是如此。我们将添加两种特定的因子分解作为我们工具箱的最后工具。其中第一种称为*欧几里得因子分解*，它将电机分解为围绕原点的旋转后跟平移。$$
    M = T_e R_e $$ 这种分解特别容易计算，因为欧几里得转子$ R_e $只是我们电机的欧几里得部分 - 前四个浮点数 - 同构于常规四元数。如果需要，平移$
    T_e $可以计算为$ T_e = M \widetilde R_e $
- en: The second factorisation of interest is the so called *Invariant factorisation*.
    It decomposes a motor $M$ into a commuting translation and rotation, which is
    always possible and generally known in 3D as the Mozzi-Chasles theorem. You may
    have heard of it as every rigid body transformation can be decomposed into a rotation
    around a line preceded or followed by a translation along the same line. $$ M
    = TR = RT$$ In 3D PGA, the invariant factorisation is also easy to calculate,
    with the commuting translation given by $$ T = 1 + \cfrac {\langle M \rangle_4}
    {\langle M \rangle_2}$$ Where the angle brackets denote the grade extraction,
    and the general bivector inverse from above comes in handy. The matching rotation
    can now be constructed as $R = M\widetilde T = \widetilde TM$.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的第二个因子分解被称为*不变分解*。它将一个电机$ M $分解为一个可交换的平移和旋转，这总是可能的，并且在3D中通常称为Mozzi-Chasles定理。您可能已经听说过，每个刚体变换可以分解为围绕一条线的旋转，前后跟随着沿着同一条线的平移。$$
    M = TR = RT $$ 在3D PGA中，不变分解也很容易计算，其中可交换的平移由$$ T = 1 + \cfrac {\langle M \rangle_4}
    {\langle M \rangle_2} $$给出，其中尖括号表示等级提取，而上面的一般双矢量逆转出现很方便。现在可以构建匹配的旋转$ R = M\widetilde
    T = \widetilde TM $。
- en: We will in particular use the Euclidean factorisation when composing the transformation
    of the tangent frame with that of the object to world motor, as such a frame is
    invariant to translations and the composition of rotations around the origin is
    more efficient.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在将切线框架的变换与物体到世界电机的变换组合时，我们将特别使用欧几里得分解，因为这样的框架对平移是不变的，绕原点的旋转组合更为高效。
- en: Escaping the matrix
  id: totrans-split-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逃离矩阵
- en: The prevalence of matrices in computer graphics means that interacting with
    existing content inevitably will confront you with matrices. The Khronos glTF
    project from which we have started uses matrices throughout, for transformations,
    binding poses for skinning etc. Our commitment to a matrix-free environment implies
    we will have to convert these matrices to their PGA equivalents at load time.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，矩阵的普遍存在意味着与现有内容交互将不可避免地涉及到矩阵。我们开始使用的Khronos glTF项目在整个过程中都使用矩阵，用于变换、绑定姿势（如皮肤绑定）等。我们致力于无矩阵环境的承诺意味着我们需要在加载时将这些矩阵转换为它们的PGA等效形式。
- en: Converting matrices to motors.
  id: totrans-split-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将矩阵转换为电机。
- en: To convert a 4x4 orthogonal matrix to a motor, we happily employ the isomorphism
    to quaternions and upgrade an industry standard solution to handle the entire
    PGA manifold.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个4x4正交矩阵转换为电机，我们愉快地利用四元数的同构性，并升级行业标准解决方案，以处理整个PGA流形。
- en: '[PRE11]'
  id: totrans-split-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-split-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These conversions are run on all of the matrices in our imports, at load time.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些转换在我们的导入中的所有矩阵上在加载时运行。
- en: Handling uniform scaling.
  id: totrans-split-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理均匀缩放。
- en: PGA motors, in contrast with 4x4 matrices, do not incorporate scaling, as it
    clearly is not a rigid body transformation. Scaling, and specifically uniform
    scaling is however commonly used in scene graphs to scale resources coming from
    potentially different sources and authored in different absolute sizes. While
    less than $0.5$% of the almost 400 random glTF files tested had any animation
    on the scale, quite a large number of them has some fixed uniform scale applied.
    The advantage of uniform scaling is that it is invariant to both rotations and
    translations, and as a result it requires only one floating point number per node,
    where each element's total scale is simply the product of its own scale and that
    of its parent. Our implementations tracks scaling in this manner, applying the
    total scale to the vertices either at load time or as first step in the vertex
    shader, and applying the parent scale to the translations, again at load time
    and when updating animations. The impact of incorporating uniform scaling like
    this is absolutely minimal, enabling us to cover almost all existing content without
    abandoning the PGA motor efficiency.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与4x4矩阵相比，PGA马达不包含缩放，因为它显然不是刚体变换。然而，缩放，特别是均匀缩放，在场景图中通常用于缩放来自潜在不同来源和绝对大小不同的资源。虽然在接近400个随机glTF文件的测试中，不到$0.5$%的文件有任何缩放动画，但其中相当多的文件都应用了固定的均匀缩放。均匀缩放的优势在于它对旋转和平移都是不变的，因此每个节点只需要一个浮点数，其中每个元素的总缩放仅仅是其自身缩放与其父节点缩放的乘积。我们的实现以这种方式跟踪缩放，在加载时或顶点着色器的第一步中应用总缩放，并在更新动画时将父节点的缩放应用于平移。像这样整合均匀缩放的影响是绝对微小的，使我们能够覆盖几乎所有现有内容，而不放弃PGA马达的效率。
- en: Handling non-uniform scaling.
  id: totrans-split-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理非均匀缩放。
- en: For non uniform scaling the situation is trickier - in the scenario where non-uniform
    scaling is used, ultimately a fall-back to 4x4 matrices is unavoidable. A non-uniform
    scale is not invariant to rotations, and tracking these scales as we did in the
    uniform case is tedious. However, again from our sample of glTF files, we could
    only find non-uniform scale applied on leaf nodes. (and given the problems caused
    by non-uniform scaling, this is not unexpected). For such a scenario, animation
    keys are not impacted and we simply apply the non-uniform scale separately before
    the rest of the transformations.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非均匀缩放，情况就比较棘手了——在使用非均匀缩放的场景中，最终无法避免回到4x4矩阵。非均匀缩放不对旋转不变，像我们在均匀情况下追踪这些缩放是令人厌烦的。然而，再次从我们的glTF文件样本中，我们只能发现非均匀缩放应用于叶节点上（考虑到非均匀缩放引起的问题，这并不意外）。对于这种情况，动画关键帧不受影响，我们只需在其余变换之前单独应用非均匀缩放。
- en: Forward Rendering.
  id: totrans-split-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前向渲染。
- en: Armed with our fully stocked PGA toolbox, we can now tackle the actual rendering
    task. Guided by the reference implementation provided by Khronos, let us revisit
    those places where matrices are the defacto solution.
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有我们完备的PGA工具箱，现在我们可以着手处理实际的渲染任务。在Khronos提供的参考实现指导下，让我们重新审视那些矩阵是唯一解决方案的地方。
- en: The general idea of a forward renderer, is to transform all mesh geometry, and
    determining for each triangle which pixels it covers. This is to be contrasted
    with a ray tracing approach where one starts from a ray throuh a pixel and determines
    which triangles it hits. In a typical forward rendering setup the transformation
    of the mesh from its specification in object space to its position on the screen
    is usually handled by a set of matrices called the model, view and projection
    matrices.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前向渲染器的一般思想是转换所有网格几何体，并确定每个三角形覆盖的像素。这与射线追踪方法相对立，后者从像素开始，确定其击中的三角形。在典型的前向渲染设置中，将网格从对象空间规范化到屏幕位置通常由一组称为模型、视图和投影矩阵的矩阵处理。
- en: Model - View - Projection.
  id: totrans-split-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型 - 视图 - 投影。
- en: Our conversion at load time of all matrices and transformations into PGA motors,
    is already a substantial optimization on the amount of computation needed to update
    the scene graph hierarchy. For complex setups many composition operators are required,
    and the gain of switching to motors is obvious.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在加载时将所有矩阵和变换转换为PGA马达的转换已经是对更新场景图层次结构所需计算量的实质性优化。对于复杂的设置，需要许多组合运算符，切换到马达的好处是显而易见的。
- en: However, while the CPU is concerned with producing updated transformations,
    the GPU has the task of applying these transformations to the vertices, normals
    and tangents that make up our mesh, and as we've seen, the computational complexity
    involved appears to make our motors a disadvantage.
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然CPU关心生成更新的转换，GPU则负责将这些转换应用于组成网格的顶点、法线和切线，正如我们所见，所涉及的计算复杂性似乎使我们的马达处于劣势。
- en: As we will soon discover, the situation is more subtle, and at this point we
    push through, replacing the model and view matrices with motors, and using the
    above defined sandwich products to transform the incoming vertex attributes.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们很快会发现的那样，情况更加微妙，在这一点上我们继续推进，用马达替换模型和视图矩阵，并使用上述定义的夹层积来转换传入的顶点属性。
- en: '[PRE13]'
  id: totrans-split-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For the projection matrix, the situation is different. The typical 4x4 projection
    matrix has only 5 non-zero entries, and even without PGA it is much more performant
    to simply write out the resulting expression. The same simply holds here and we
    use a standard projection function for this.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于投影矩阵，情况则不同。典型的4x4投影矩阵只有5个非零项，即使没有PGA，直接写出结果表达式也更加高效。同样，我们在这里使用一个标准投影函数。
- en: '[PRE14]'
  id: totrans-split-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With our basic transformations all setup, let us turn our attention to one of
    todays most common shading techniques, tangent space normal mapping.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好我们的基本转换后，让我们将注意力转向当今最常见的一种着色技术，即切线空间法线映射。
- en: Tangent Space Normalmapping.
  id: totrans-split-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切线空间法线映射。
- en: Vertex Shader
  id: totrans-split-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: For a tangent space normal-mapped mesh, the vertex shader needs to transform
    the position, the normal, and the tangent vector. So it seems unavoidable that
    our choice for PGA means we are incurring the higher transformation cost threefold.
    However, the normal, tangent and bitangent vector together form an orthonormal
    frame. In PGA, any orthonormal frame is related to the canonical basis frame through
    a $k$-reflection. When $k$ is even, these are just the rotation-only motors we
    encountered before (isomorphic to the quaternions), and when $k$ is odd, this
    k-reflection instead represents a similar rotation followed by one extra reflection.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于切线空间法线映射网格，顶点着色器需要转换位置、法线和切线向量。因此，似乎我们选择PGA意味着我们要承担三倍的更高转换成本。然而，法线、切线和副切线向量一起形成一个标准正交框架。在PGA中，任何标准正交框架都通过$k$-反射与基本标准框架相关联。当$k$为偶数时，这些只是我们之前遇到的仅旋转的马达（同构于四元数），而当$k$为奇数时，这种$k$-反射代表的是一个类似旋转的转换，随后是一个额外的反射。
- en: This implies that we can remove both the normal and the tangent vectors from
    our vertex description, replacing them instead by a tangentRotor, which represents
    the rotation from the basis frame to the desired tangent frame. Such a tangentRotor
    $R$ in fact double-covers all possible tangent frames in the sense that both $R$
    and $-R$ produce the same transformation. We can use this double covering to disambiguate
    even and odd k-reflections, simply by making sure the sign of the scalar coefficient
    of $R$ matches the classical handedness flag. Note that in doing so, we piggy-back
    on the IEE754 floating point specification, that is we depend on the signed representation
    of zero. In the vertexshader we can then unambigously extract the original sign
    using
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以从顶点描述中移除法线和切线向量，取而代之的是一个切线转子，它表示从基本框架到所需切线框架的旋转。事实上，这样一个切线转子$R$实际上对所有可能的切线框架进行了双重覆盖，即$R$和$-R$产生相同的变换。我们可以利用这种双重覆盖来消除偶数和奇数$k$-反射的歧义，只需确保$R$的标量系数的符号与经典的左右手标志匹配。请注意，在这样做时，我们依赖于IEEE754浮点数规范，即我们依赖于零的有符号表示。在顶点着色器中，我们可以明确地提取原始符号，使用：
- en: '[PRE15]'
  id: totrans-split-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Combining all this, we conclude that we can reduce our vertex descriptor for
    the most common tangent space normalmapping setup from 12 floats (3 position,
    3 normal, 4 tangent, 2 uv) down to 9 (3 position, 4 tangentRotor, 2 uv). That
    is a substantial save, which is implemented at loadtime, converting loaded normal
    and tangent vectors with:'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 综合所有这些，我们得出结论，我们可以将最常见的切线空间法线映射设置的顶点描述符从12个浮点数（3个位置、3个法线、4个切线、2个UV）减少到9个（3个位置、4个切线转子、2个UV）。这是一个相当大的节省，它在加载时实现，将加载的法线和切线向量转换为：
- en: '[PRE16]'
  id: totrans-split-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But there is more good news. Recall that using 4x4 matrices, the transformation
    of position, normal and tangent includes 3 matrix vector products, totalling 48
    multiplications and 36 additions. In the PGA version, we can however transform
    the entire tangent frame in one go, for a cost of just 16 multiplications and
    12 additions. After which we can in fact extract the worldspace normal and tangent
    directly with just 9 multiplications and 8 additions using :'
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但好消息还有更多。请记住，使用4x4矩阵时，位置、法线和切线的转换包括3个矩阵向量乘积，总共48次乘法和36次加法。在PGA版本中，我们可以一次性转换整个切线框架，仅需16次乘法和12次加法的成本。然后，我们实际上可以使用以下方式仅需9次乘法和8次加法直接提取世界空间的法线和切线：
- en: '[PRE17]'
  id: totrans-split-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Add to that the 21 multiplications and 18 additions needed to transform the
    vertex position, and another multiplication to extract the handedness, and we
    come to the remarkable conclusion that in order to transform a vertex with full
    tangent frame to world space, our PGA approach needs only (16 + 9 + 21 + 1 = 47)
    multiplications and (12 + 8 + 18 = 38) additions. That is nearly identical to
    the 48 multiplications and 36 additions that would be required if we use 4x4 matrices
    and normal and tangent vectors instead.
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 再加上用于转换顶点位置所需的21次乘法和18次加法，再加上用于提取手性的一次乘法，我们得出了一个了不起的结论，即为了将带有完整切线框架的顶点转换到世界空间，我们的PGA方法仅需（16
    + 9 + 21 + 1 = 47）次乘法和（12 + 8 + 18 = 38）次加法。这几乎与如果我们使用4x4矩阵和法线、切线向量而需48次乘法和36次加法相同。
- en: '**PGA motors can be just as fast as 4x4 matrices to transform your mesh vertices
    !!!**'
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**PGA马达可以像4x4矩阵一样快速地转换您的网格顶点!!!**'
- en: '| method | floats/vertex | floats/transform | multiplications | additions |'
  id: totrans-split-112
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 每顶点浮点数 | 每次变换浮点数 | 乘法次数 | 加法次数 |'
- en: '| Matrix + normal + tangent | 12 | 32 | 48 | 36 |'
  id: totrans-split-113
  prefs: []
  type: TYPE_TB
  zh: '| 矩阵 + 法线 + 切线 | 12 | 32 | 48 | 36 |'
- en: '| Motor + tangentRotor | 9 **-25%** | 8 **-75%** | 47 | 38 |'
  id: totrans-split-114
  prefs: []
  type: TYPE_TB
  zh: '| 马达 + 切线旋子 | 9 **-25%** | 8 **-75%** | 47 | 38 |'
- en: The resulting code block in the vertexshader now becomes
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在顶点着色器中的生成代码块变成了
- en: '[PRE18]'
  id: totrans-split-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, no changes to the fragment shader are required, making this a
    drop-in replacement that can be used in any existing engine.
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，片段着色器不需要进行任何更改，因此这是一个可以用于任何现有引擎的即插即用替换。
- en: Fragment Shader
  id: totrans-split-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 片段着色器
- en: If we want to be able to load existing content, this is the point where we have
    to resort back to the TBN matrix. The reason for this is clear. When baking the
    high detail mesh onto the low detail mesh, the baking tool has interpolated vertex
    normal and tangent vectors over the face of each triangle. From these (no longer
    normalized or orthogonal) vectors, at each fragment, an orthogonal TBN matrix
    is constructed, and used to transform the high detail world space normal to the
    tangent space normal that is stored in the texture.
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望能够加载现有内容，这就是我们不得不退回到TBN矩阵的时刻。其原因显而易见。在将高细节网格烘焙到低细节网格时，烘焙工具已经在每个三角形面上插值了顶点法线和切线向量。从这些（不再归一化或正交的）向量中，在每个片段处构建一个正交的TBN矩阵，并用于将高细节的世界空间法线转换为存储在纹理中的切线空间法线。
- en: This process of interpolating basis vectors introduces an error that is typical
    for matrices, and unfortunately this error is thus literally baked into the textures.
    This is why we opted to indeed extract the normal and tangent vectors explicitely
    from the tangentRotor.
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 插值基向量的过程引入了一种典型的矩阵误差，不幸的是，这种误差确实被烘焙到了纹理中。这就是为什么我们决定确实从切线旋子中明确提取法线和切线向量的原因。
- en: However, for scenarios where one controls the baking tool, we can do better
    still. In these cases we could just pass the tangentRotor unmodified to the fragmentShader,
    where it can be normalized and used to transform the sampled normal, without ever
    constructing a tbn matrix. In this scenario, we would save even more, removing
    the need to extract normal and tangent in the vertex shader, requiring one less
    varying parameter, and removing the need for expensive orthogonalisation in the
    fragment shader.
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在控制烘焙工具的情况下，我们还可以做得更好。在这些情况下，我们可以将切线旋子未经修改地传递到片段着色器，那里可以对其进行归一化并用于转换采样法线，而无需构建TBN矩阵。在这种情况下，我们可以节省更多，消除在顶点着色器中提取法线和切线的需求，减少一个更多的变量参数，并消除片段着色器中昂贵的正交化的需求。
- en: Motor Skinning.
  id: totrans-split-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 马达蒙皮。
- en: 'With PGA motors isomorphic to the dual quaternions, skinning is an obvious
    candidate for our PGA approach. After converting inverse bind matrices to their
    motor equivalent, the skinning code for our motors follows the well known pattern
    from dual quaternion skinning :'
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PGA电机同构于双四元数，我们的PGA方法显然是骨骼动画的一个候选。在将反向绑定矩阵转换为其电机等效物之后，我们的电机的皮肤代码遵循双四元数蒙皮的已知模式：
- en: '[PRE19]'
  id: totrans-split-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note how just as for dual quaternions, we make sure that any transformation
    that is blended in follows the shortest arc, and renormalize the resulting transformation.
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，就像对双四元数而言，我们确保混合的任何变换都遵循最短弧，并重新归一化结果变换。
- en: Animation Blending
  id: totrans-split-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画混合
- en: For animation blending, the same technique is used, directly blending and renormalizing
    PGA motors on the CPU.
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动画混合，直接在CPU上混合和重新归一化PGA电机使用了相同的技术。
- en: <select id="anim1"><option>Idle</option> <option>Idle2</option> <option selected="selected">Failure</option>
    <option>Success</option> <option>Talk</option> <option>Walk</option></select>
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
  zh: <select id="anim1"><option>空闲</option> <option>空闲2</option> <option selected="selected">失败</option>
    <option>成功</option> <option>交谈</option> <option>行走</option></select>
- en: <select id="anim2"><option>Idle</option> <option>Idle2</option> <option>Failure</option>
    <option selected="selected">Success</option> <option>Talk</option> <option>Walk</option></select>
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: <select id="anim2"><option>空闲</option> <option>空闲2</option> <option>失败</option>
    <option selected="selected">成功</option> <option>交谈</option> <option>行走</option></select>
- en: Conclusion
  id: totrans-split-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: This project started off with the goal to demonstrate it is indeed possible
    to implement a forward renderer using PGA exclusively. What we found is that,
    not only is this possible, the common understanding that this would come at the
    cost of more expensive transformations turns out to be much more subtle. The resulting
    improvements are both unexpected and quite spectacular, especially on the memory
    footprint where an extra 33% vertices in the same storage is quite a significant
    improvement. This technique can readily be deployed into other existing 3D engines,
    at virtually no cost on the vertex shader and without modifications to the rest
    of the pipeline.
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目最初的目标是演示仅使用PGA实现前向渲染器的可能性。我们发现，不仅这是可能的，而且常见的理解认为这会增加更昂贵的转换费用，结果却更加微妙。所得的改进既出乎意料又非常引人注目，尤其是在内存占用方面，同一存储中额外33%的顶点显著提高。这项技术可以轻松部署到其他现有的3D引擎中，几乎不费一文在顶点着色器上，而且无需修改管道的其余部分。
- en: References
  id: totrans-split-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: Geometric Algebra and Computer Graphics. Charles Gunn & Steven De Keninck. [https://dl.acm.org/doi/10.1145/3305366.3328099](https://dl.acm.org/doi/10.1145/3305366.3328099)
  id: totrans-split-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何代数与计算机图形学，Charles Gunn & Steven De Keninck。[https://dl.acm.org/doi/10.1145/3305366.3328099](https://dl.acm.org/doi/10.1145/3305366.3328099)
- en: n-Dimensional Rigid Body Mechanics. Marc Ten Bosch. SIGGRAPH2020\. [https://marctenbosch.com/ndphysics/NDrigidbody.pdf](https://marctenbosch.com/ndphysics/NDrigidbody.pdf)
  id: totrans-split-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: n维刚体力学，Marc Ten Bosch。SIGGRAPH2020。[https://marctenbosch.com/ndphysics/NDrigidbody.pdf](https://marctenbosch.com/ndphysics/NDrigidbody.pdf)
- en: Geometric Clifford Algebra Networks. David Ruhe & co. [https://doi.org/10.48550/arXiv.2302.06594](https://doi.org/10.48550/arXiv.2302.06594)
  id: totrans-split-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何Clifford代数网络，David Ruhe & 合著者。[https://doi.org/10.48550/arXiv.2302.06594](https://doi.org/10.48550/arXiv.2302.06594)
- en: Geometric Algebra Transformers. Johann Brehmer & co. [https://arxiv.org/pdf/2305.18415.pdf](https://arxiv.org/pdf/2305.18415.pdf)
  id: totrans-split-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何代数变换器，Johann Brehmer & 合著者。[https://arxiv.org/pdf/2305.18415.pdf](https://arxiv.org/pdf/2305.18415.pdf)
- en: Plane-based Geometric Algebra for Computer Science. Leo Dorst & Steven De Keninck.
    [https://bivector.net/PGA4CS.html](https://bivector.net/PGA4CS.html)
  id: totrans-split-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[计算机科学中的基于平面的几何代数](https://bivector.net/PGA4CS.html)，Leo Dorst & Steven De
    Keninck。'
- en: May the Forque be with you. Leo Dorst & Steven De Keninck. [https://bivector.net/PGADYN.html](https://bivector.net/PGADYN.html)
  id: totrans-split-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 愿Fork和您同在，Leo Dorst & Steven De Keninck。[https://bivector.net/PGADYN.html](https://bivector.net/PGADYN.html)
- en: Normalization, square roots, and the exponential and logarithmic maps in geometric
    algebras of less than 6D. Steven De Keninck & Martin Roelfs. [http://dx.doi.org/10.1002/mma.8639](http://dx.doi.org/10.1002/mma.8639)
  id: totrans-split-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小于6D几何代数中的归一化、平方根以及指数和对数映射，Steven De Keninck & Martin Roelfs。[http://dx.doi.org/10.1002/mma.8639](http://dx.doi.org/10.1002/mma.8639)
