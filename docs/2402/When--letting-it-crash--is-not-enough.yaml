- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»åˆ«ï¼šæœªåˆ†ç±»
- en: 'date: 2024-05-27 14:42:40'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024-05-27 14:42:40
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: When "letting it crash" is not enough
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å½“â€œè®©å®ƒå´©æºƒâ€ä¸å†è¶³å¤Ÿ
- en: æ¥æºï¼š[https://flawless.dev/essays/when-letting-it-crash-is-not-enough/](https://flawless.dev/essays/when-letting-it-crash-is-not-enough/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://flawless.dev/essays/when-letting-it-crash-is-not-enough/](https://flawless.dev/essays/when-letting-it-crash-is-not-enough/)
- en: When "letting it crash" is not enough
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å½“â€œè®©å®ƒå´©æºƒâ€ä¸å†è¶³å¤Ÿ
- en: When it comes to computer systems, The [Erlang/OTP](https://www.erlang.org)
    programming platform has an interesting approach to failure handling. It's also
    widely known under the name "let it crash". The core idea behind it has to do
    with the fact that modern applications have a huge number of states that they
    can find themselves in. The more complex your application is, the more variables
    you need to keep track of everything. Eventually it becomes impossible for developers
    to predict all combinations of state that these variables will form. Once your
    app gets into an undesirable state, the best thing you can do is to reset it and
    start from a fresh, well known and correct state.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è°ˆè®ºè®¡ç®—æœºç³»ç»Ÿæ—¶ï¼Œ[Erlang/OTP](https://www.erlang.org)ç¼–ç¨‹å¹³å°å¯¹äºå¤„ç†æ•…éšœæœ‰ç€ç‹¬ç‰¹çš„æ–¹æ³•ã€‚å®ƒä¹Ÿä»¥â€œè®©å®ƒå´©æºƒâ€é—»åã€‚è¿™èƒŒåçš„æ ¸å¿ƒæ€æƒ³ä¸ç°ä»£åº”ç”¨ç¨‹åºçš„å¤šçŠ¶æ€æœ‰å…³ã€‚ä½ çš„åº”ç”¨ç¨‹åºè¶Šå¤æ‚ï¼Œä½ éœ€è¦è·Ÿè¸ªçš„å˜é‡å°±è¶Šå¤šã€‚æœ€ç»ˆï¼Œå¼€å‘è€…æ— æ³•é¢„æµ‹è¿™äº›å˜é‡ç»„åˆå‡ºç°çš„æ‰€æœ‰çŠ¶æ€ã€‚ä¸€æ—¦ä½ çš„åº”ç”¨ç¨‹åºé™·å…¥ä¸è‰¯çŠ¶æ€ï¼Œæœ€å¥½çš„åšæ³•æ˜¯é‡ç½®å®ƒï¼Œå¹¶ä»ä¸€ä¸ªå·²çŸ¥ä¸”æ­£ç¡®çš„çŠ¶æ€é‡æ–°å¼€å§‹ã€‚
- en: This works amazingly well together with Erlang's property that each process
    has a separate memory space. Allowing us to selectively reset only parts of our
    application, while keeping the system as a whole running. Then we can divide the
    application into a tree-like structure and keep restarting parts of it until we
    reach the root and are forced to restart the whole thing. This concept is also
    known as [supervision trees](https://www.erlang.org/doc/design_principles/des_princ).
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸Erlangçš„ç‰¹æ€§éå¸¸å¥‘åˆï¼Œå³æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰å•ç‹¬çš„å†…å­˜ç©ºé—´ã€‚è¿™ä½¿å¾—æˆ‘ä»¬å¯ä»¥æœ‰é€‰æ‹©åœ°é‡ç½®åº”ç”¨ç¨‹åºçš„éƒ¨åˆ†ï¼ŒåŒæ—¶ä¿æŒæ•´ä¸ªç³»ç»Ÿè¿è¡Œã€‚ç„¶åæˆ‘ä»¬å¯ä»¥å°†åº”ç”¨ç¨‹åºåˆ†æˆç±»ä¼¼æ ‘çŠ¶ç»“æ„ï¼Œå¹¶ä¸æ–­é‡å¯å…¶éƒ¨åˆ†ï¼Œç›´åˆ°è¾¾åˆ°æ ¹éƒ¨å¹¶è¢«è¿«é‡å¯æ•´ä¸ªç³»ç»Ÿã€‚è¿™ä¸ªæ¦‚å¿µä¹Ÿè¢«ç§°ä¸º[ç›‘ç£æ ‘](https://www.erlang.org/doc/design_principles/des_princ)ã€‚
- en: If you take a closer look at Erlang's approach, this is exactly what a human
    would do. If your phone gets stuck playing a video, you will try restarting the
    app, and if this doesn't fix it, you might end up restarting your phone. Or even
    the router of your home internet connection. You intuitively know that propagating
    the failure through your home will eventually bring all devices into a state that
    resembles the one when you first set everything up and everything was working.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä»”ç»†ç ”ç©¶Erlangçš„æ–¹æ³•ï¼Œè¿™æ­£æ˜¯äººç±»ä¼šåšçš„äº‹æƒ…ã€‚å¦‚æœä½ çš„æ‰‹æœºåœ¨æ’­æ”¾è§†é¢‘æ—¶å¡ä½ï¼Œä½ ä¼šå°è¯•é‡å¯åº”ç”¨ç¨‹åºï¼›å¦‚æœè¿™è¡Œä¸é€šï¼Œä½ å¯èƒ½ä¼šé‡å¯æ‰‹æœºï¼Œç”šè‡³æ˜¯å®¶é‡Œçš„è·¯ç”±å™¨ã€‚ä½ æœ¬èƒ½åœ°çŸ¥é“ï¼Œé€šè¿‡ä½ çš„å®¶åº­ä¼ æ’­æ•…éšœæœ€ç»ˆä¼šå°†æ‰€æœ‰è®¾å¤‡å¸¦å…¥ä¸€ä¸ªç±»ä¼¼äºä½ åˆå§‹è®¾ç½®æ—¶ä¸€åˆ‡æ­£å¸¸çš„çŠ¶æ€ã€‚
- en: Even sometimes Erlang's claims around resilience and fault tolerance are a bit
    **[overblown](https://stackoverflow.com/a/26447543)**, I still think that it's
    a very powerful way to deal with failure. If my web app breaks, the first thing
    I do is to restart the server. In the majority of cases this immediately fixes
    the issue, while I dive deeper into the logs trying to figure out what went wrong.
    Having this automatic restarting capability at every level of abstraction in your
    app, will definitely help you sleep better.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: å³ä½¿æœ‰æ—¶Erlangå…³äºå¼¹æ€§å’Œå®¹é”™æ€§çš„è¯´æ³•æœ‰äº›**[è¨€è¿‡å…¶å®](https://stackoverflow.com/a/26447543)**ï¼Œæˆ‘ä»ç„¶è®¤ä¸ºè¿™æ˜¯å¤„ç†æ•…éšœçš„ä¸€ç§éå¸¸æœ‰æ•ˆçš„æ–¹å¼ã€‚å¦‚æœæˆ‘çš„Webåº”ç”¨ç¨‹åºå´©æºƒï¼Œæˆ‘é¦–å…ˆä¼šé‡å¯æœåŠ¡å™¨ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿™ä¼šç«‹å³è§£å†³é—®é¢˜ï¼Œè€Œæˆ‘ä¼šæ·±å…¥æ—¥å¿—æ–‡ä»¶ä»¥æ‰¾å‡ºé—®é¢˜çš„æ ¹æºã€‚åœ¨åº”ç”¨ç¨‹åºçš„æ¯ä¸ªæŠ½è±¡å±‚é¢éƒ½å…·æœ‰è¿™ç§è‡ªåŠ¨é‡å¯èƒ½åŠ›ï¼Œæ— ç–‘ä¼šè®©ä½ ç¡å¾—æ›´å®‰å¿ƒã€‚
- en: However, resetting the state is almost never enough. In the phone example, once
    the phone starts up again, you still need to get back into the state where you
    stopped. This usually means finding the video again and jumping back to the right
    point on the timeline. We are partially reconstructing the state where we stopped,
    but ignoring all the other state where things might have gone wrong, like our
    home internet connection being broken.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä»…ä»…é‡ç½®çŠ¶æ€å‡ ä¹ä»æ¥éƒ½ä¸å¤Ÿã€‚ä»¥æ‰‹æœºä¸ºä¾‹ï¼Œä¸€æ—¦æ‰‹æœºé‡æ–°å¯åŠ¨ï¼Œä½ ä»ç„¶éœ€è¦å›åˆ°åœæ­¢æ—¶çš„çŠ¶æ€ã€‚è¿™é€šå¸¸æ„å‘³ç€é‡æ–°æ‰¾åˆ°è§†é¢‘å¹¶è·³å›æ­£ç¡®çš„æ—¶é—´ç‚¹ã€‚æˆ‘ä»¬éƒ¨åˆ†åœ°é‡å»ºäº†åœæ­¢æ—¶çš„çŠ¶æ€ï¼Œä½†å¿½ç•¥äº†å…¶ä»–å¯èƒ½å‡ºé”™çš„æ‰€æœ‰çŠ¶æ€ï¼Œæ¯”å¦‚æˆ‘ä»¬å®¶é‡Œçš„äº’è”ç½‘è¿æ¥æ–­å¼€äº†ã€‚
- en: For humans, it's easy to approximately remember where we stopped watching a
    video, but for an application it's impossible to reconstruct the state without
    the developer explicitly keeping track of it. How to snapshot your state, where
    to store it and how often to do it, are very difficult questions. Even with very
    frequent snapshots, with my luck, it would probably fail in between snapshots
    and result in data loss. The only way of having total confidence in such a system
    is if **every** state change is captured.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºäººç±»æ¥è¯´ï¼Œå¤§è‡´è®°ä½æˆ‘ä»¬åœæ­¢è§‚çœ‹è§†é¢‘çš„ä½ç½®å¾ˆå®¹æ˜“ï¼Œä½†å¯¹äºåº”ç”¨ç¨‹åºæ¥è¯´ï¼Œå¦‚æœæ²¡æœ‰å¼€å‘è€…æ˜¾å¼è·Ÿè¸ªï¼Œé‡æ–°æ„å»ºçŠ¶æ€æ˜¯ä¸å¯èƒ½çš„ã€‚å¦‚ä½•å¿«ç…§æ‚¨çš„çŠ¶æ€ï¼Œå­˜å‚¨åœ¨å“ªé‡Œä»¥åŠå¤šé¢‘ç¹æ‰§è¡Œè¿™äº›æ“ä½œï¼Œéƒ½æ˜¯éå¸¸å›°éš¾çš„é—®é¢˜ã€‚å³ä½¿è¿›è¡Œéå¸¸é¢‘ç¹çš„å¿«ç…§ï¼Œä¹Ÿå¯èƒ½åœ¨ä¸¤æ¬¡å¿«ç…§ä¹‹é—´å‘ç”Ÿæ•…éšœï¼Œå¯¼è‡´æ•°æ®ä¸¢å¤±ã€‚åœ¨è¿™æ ·çš„ç³»ç»Ÿä¸­å®Œå…¨è‡ªä¿¡çš„å”¯ä¸€æ–¹å¼æ˜¯æ•è·æ¯ä¸ªçŠ¶æ€å˜åŒ–ã€‚
- en: Durable Execution
  id: totrans-split-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æŒä¹…æ‰§è¡Œ
- en: This brings me to a recent discovery I made, another approach to dealing with
    failure that completely blew my mind ğŸ¤¯. It's commonly known under the name durable
    execution, and it's an elegant solution to the "keeping track of state changes"
    problem, and perfectly complements Erlang's approach.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è®©æˆ‘æƒ³åˆ°äº†æˆ‘æœ€è¿‘çš„ä¸€ä¸ªå‘ç°ï¼Œä¸€ç§å®Œå…¨é¢ è¦†äº†æˆ‘è®¤çŸ¥çš„å¤„ç†å¤±è´¥çš„æ–¹æ³• ğŸ¤¯ã€‚å®ƒé€šå¸¸è¢«ç§°ä¸ºæŒä¹…æ‰§è¡Œï¼Œæ˜¯å¤„ç†â€œè·Ÿè¸ªçŠ¶æ€å˜åŒ–â€é—®é¢˜çš„ä¸€ä¸ªä¼˜é›…è§£å†³æ–¹æ¡ˆï¼Œå¹¶ä¸”ä¸ Erlang
    çš„æ–¹æ³•å®Œç¾ç»“åˆã€‚
- en: The simplest way of thinking of it is as a database for compute progression.
    It stores the minimal amount of data to be able to reconstruct your application's
    sate at any time. It makes your local variables indestructible, and for many scenarios
    you will not even require a traditional database anymore.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ç®€å•çš„æ€è€ƒæ–¹å¼æ˜¯å°†å…¶è§†ä¸ºè®¡ç®—è¿›ç¨‹çš„æ•°æ®åº“ã€‚å®ƒå­˜å‚¨æœ€å°é‡çš„æ•°æ®ï¼Œä»¥ä¾¿éšæ—¶é‡æ„åº”ç”¨ç¨‹åºçš„çŠ¶æ€ã€‚å®ƒä½¿æ‚¨çš„å±€éƒ¨å˜é‡ä¸å¯æ¯ç­ï¼Œå¹¶ä¸”å¯¹äºè®¸å¤šåœºæ™¯ï¼Œæ‚¨ç”šè‡³ä¸å†éœ€è¦ä¼ ç»Ÿçš„æ•°æ®åº“ã€‚
- en: Imagine if you could just start an arbitrary computation and the system guarantees
    that it will run until completion and all the operations will be performed **exactly
    once**. Even if your app needs to be restarted in the middle. Or even if you need
    to stop the computation, move it to a different machine and continue. Your running
    code suddenly becomes this tangible thing, that you can look at, move and play
    with.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœæ‚¨å¯ä»¥å¼€å§‹ä»»æ„è®¡ç®—ï¼Œå¹¶ä¸”ç³»ç»Ÿä¿è¯å®ƒå°†è¿è¡Œç›´åˆ°å®Œæˆï¼Œå¹¶ä¸”æ‰€æœ‰æ“ä½œå°†è¢«**ç²¾ç¡®æ‰§è¡Œä¸€æ¬¡**ã€‚å³ä½¿æ‚¨çš„åº”ç”¨ç¨‹åºéœ€è¦åœ¨ä¸­é€”é‡æ–°å¯åŠ¨ã€‚æˆ–è€…å³ä½¿æ‚¨éœ€è¦åœæ­¢è®¡ç®—ï¼Œå°†å…¶ç§»åŠ¨åˆ°å¦ä¸€å°æœºå™¨å¹¶ç»§ç»­ã€‚æ‚¨æ­£åœ¨è¿è¡Œçš„ä»£ç çªç„¶å˜æˆäº†ä¸€ç§å¯è§¦åŠçš„ä¸œè¥¿ï¼Œæ‚¨å¯ä»¥æŸ¥çœ‹ã€ç§»åŠ¨å’Œæ“ä½œã€‚
- en: Durable execution is more of a general purpose technology that can be used for
    different use cases, like transactions across distributed services, or very long-running
    jobs (months), but the underlying guarantees also make it the ultimate tool to
    create snapshots for picking up where you stopped in case you need to partially
    restart your system.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: æŒä¹…æ‰§è¡Œæ˜¯ä¸€ç§æ›´é€šç”¨çš„æŠ€æœ¯ï¼Œå¯ä»¥ç”¨äºä¸åŒçš„ç”¨ä¾‹ï¼Œæ¯”å¦‚è·¨åˆ†å¸ƒå¼æœåŠ¡çš„äº‹åŠ¡ï¼Œæˆ–è€…éå¸¸é•¿æ—¶é—´è¿è¡Œçš„ä½œä¸šï¼ˆå‡ ä¸ªæœˆï¼‰ã€‚ä½†æ˜¯åº•å±‚çš„ä¿è¯ä¹Ÿä½¿å®ƒæˆä¸ºåˆ›å»ºå¿«ç…§çš„ç»ˆæå·¥å…·ï¼Œä»¥ä¾¿åœ¨éœ€è¦éƒ¨åˆ†é‡å¯ç³»ç»Ÿæ—¶å¯ä»¥ç»§ç»­ä¹‹å‰çš„è¿›åº¦ã€‚
- en: I have been working on my own engine for durable execution called **[flawless](https://flawless.dev)**.
    It implicitly keeps a log of side effects, so that you always can reconstruct
    the latest state and pick up where you left off. It's still in private alpha,
    but I hope to soon open it up and share with everyone.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¸€ç›´åœ¨å¼€å‘åä¸º **[flawless](https://flawless.dev)** çš„æŒä¹…æ‰§è¡Œå¼•æ“ã€‚å®ƒéšå¼åœ°è®°å½•å‰¯ä½œç”¨çš„æ—¥å¿—ï¼Œå› æ­¤æ‚¨å§‹ç»ˆå¯ä»¥é‡æ„æœ€æ–°çŠ¶æ€å¹¶ç»§ç»­ä¸Šæ¬¡ä¸­æ–­çš„å·¥ä½œã€‚å®ƒç›®å‰ä»å¤„äºç§äººé˜¶æ®µï¼Œä½†æˆ‘å¸Œæœ›å¾ˆå¿«èƒ½å‘å¤§å®¶å¼€æ”¾å¹¶åˆ†äº«ã€‚
- en: ~ [Bernard](https://twitter.com/bkolobara)
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: ~ [ä¼¯çº³å¾·](https://twitter.com/bkolobara)
