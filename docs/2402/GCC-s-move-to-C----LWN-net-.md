<!--yml

category: 未分类

date: 2024-05-27 15:02:20

-->

# GCC 的转型至 C++ [LWN.net]

> 来源：[https://lwn.net/Articles/542457/](https://lwn.net/Articles/542457/)

| **请考虑订阅 LWN**订阅是 LWN.net 的生命线。如果您喜欢这篇内容，并希望看到更多类似内容，请考虑订阅。您的订阅将有助于确保 LWN 继续繁荣。请访问 [此页面](/subscribe/) 进行订阅。 |
| --- |

2013 年 3 月 13 日

本文由琳达·雅各布森贡献

GNU 编译器集合（GCC）从诞生之初就是用 C 语言编写并由 C 编译器编译的。从 2008 年开始，人们努力改变 GCC，使其可以由 C++ 编译器编译，并利用 C++ 结构的子集。这一努力始于 [Ian Lance Taylor 的演讲 [PDF]](http://airs.com/ian/cxx-slides.pdf)，2008 年 GCC 峰会上。和任何重大变化一样，这个变化有其反对者和问题，也有支持者和成功案例。

#### 原因

Taylor 的幻灯片列出了将 GCC 写成 C++ 的原因：

+   C++ 是众所周知和流行的。

+   它几乎是 C90 的超集，而 GCC 当时就是用它写成的。

+   C++ 中的 C 子集与 C 一样高效。

+   C++ 在“几个重要情况下支持更清晰的代码”。它从不要求“更丑陋”的代码。

+   C++ 使得跨接口边界更难以打破，从而导致更清晰的接口。

C++ 的流行及其与 C 的超集关系不言而喻。Taylor 表示，C++ 中的 C 子集与 C 一样高效，这意味着如果开发人员关注效率，限制自己使用 C 结构将生成同样高效的代码。拥有更清晰的接口是 C++ 或任何面向对象语言的主要优势之一。说 C++ 从不需要“更丑陋”的代码是一个价值判断。然而，说它在一些重要情况下支持“更清晰的代码”有着深厚的历史，最好由 gengtype 加以证明。

[根据 GCC Wiki](http://gcc.gnu.org/wiki/gengtype)：

由于 C 没有任何反射手段[...] gengtype 被引入以支持一些 GCC 特定的类型和变量注释，进而支持编译器内的垃圾收集和预编译头。因此，gengtype 是一个由基本 C 词法分析器和解析器组成的大杂糅。

事情的发生是开发人员在 C 语言中模拟了诸如垃圾收集、向量类和树类等功能。这正是 Taylor 所指的“丑陋”代码。

在他的幻灯片中，Taylor 也试图解决许多最初的反对意见：C++ 太慢，太复杂，可能存在引导问题，自由软件基金会（FSF）不会喜欢等等。他通过指出 C++ 中的 C 子集与 C 一样高效来解决速度问题。至于 FSF，Taylor 写道：“FSF 不是在写这段代码。”

语言的复杂性在于观察者的眼中。许多GCC开发者主要或专门是C程序员，因此必然会有一个时间段他们的生产力会降低，和/或者他们可能会以一种消除了所有声称的好处的方式使用C++。为了解决这个问题，Taylor希望制定限制开发到C++子集的编码标准。

引导问题可以通过确保GCC版本*N-1*始终可以构建GCC版本*N*并静态链接到`libstdc++`来解决。GCC版本*N-1*在构建GCC *N*和`libstdc++` *N*时必须链接到`libstdc++` *N-1*；反过来，GCC *N*需要`libstdc++` *N*。静态链接确保每个编译器版本都能与适当版本的库一起运行。

多年来，直到2008年之前，根据Taylor（通过电子邮件）的说法，大家普遍同意将GCC代码限制在C和C++的共同子集中。然而，用C++编译器取代C编译器遭到了很大的反对。在2008年的GCC峰会上，Taylor进行了一项关于反对程度的投票，大约有40%的人持反对意见。C++的支持者密切关注并解决了C++反对者提出的具体异议（速度、内存使用、开发者经验等），因此，此后每年反对者的规模都显著减少。这些讨论大多发生在GCC峰会和未记录的IRC聊天中。因此，仅有的记录保存在[GCC邮件列表档案](http://gcc.gnu.org/ml/gcc)中。

#### 第一步

第一步，一个正确的初步行动，仅仅是尝试用C++编译器编译现有的C代码库。在Taylor仍在会议期间，他[创建了一个gcc-in-cxx分支](http://gcc.gnu.org/ml/gcc/2008-06/msg00385.html)，用于尝试用C++编译器构建GCC。开发者们迅速宣布他们的意图参与该项目。最初的构建尝试遇到了许多错误和警告，随后进行了清理。

2009年6月，几乎正好一年之后，Taylor报告称第一阶段已经完成。他使用`enable-build-with-cxx`开关配置了GCC，以便用C++构建核心编译器。在单个目标系统上完成了引导。此时左右，独立的cxx分支已经合并到主GCC主干中，人们继续使用`enable-build-with-cxx`开关继续工作。（然而，至少有一次独立分支因实验而复活。）

2010 年 5 月，[GCC 发布经理在 IRC 上进行了问答](http://gcc.gnu.org/wiki/Release%20Manager%20Q%26A?action=AttachFile&do=view&target=rmqa-20100527.txt)。会议的结论是请求 GCC 指导委员会的许可，以在 GCC 本身中使用 C++ 语言特性，而不仅仅是用 C++ 编译器进行编译。许可获得批准，并且自自由软件基金会也表示同意。Mark Mitchell 在 2010 年 5 月 31 日的 GCC 邮件列表中[宣布了这一决定](http://gcc.gnu.org/ml/gcc/2010-05/msg00705.html)。

在那个帖子中，[Jakub Jelinek](http://gcc.gnu.org/ml/gcc/2010-05/msg00746.html) 和 [Vladimir Makarov](http://gcc.gnu.org/ml/gcc/2010-05/msg00744.html) 对这一变化表达了不太热情的态度。然而，正如 Makarov 所说，他并不希望为一个早已做出的决定而引发争论。话虽如此，他最近通过电子邮件分享，他主要的担忧是 GCC 社区会匆忙将 GCC 代码库转换为 C++，“而不是致力于为 GCC 用户改进性能、增加新功能等更重要的事情。” 幸运的是，这种情况并未发生。

Richard Guenther 对[创建一个树类层次结构](http://gcc.gnu.org/ml/gcc/2010-05/msg00745.html)表示关注：

这是一项艰巨的工作（树在所有三个前端、中端和后端都有扩展）。我担心我们只会完成一半的过渡 - 这比没有过渡更糟糕。

支持者的努力缓解了担忧，而反对者的“请小心”信息也显示了其他担忧的迹象。除了 Taylor 在 2008 年的演示中提出的问题外，Jelinek 还提到了内存使用情况。其他人时常在其他评论中担心，初学者的 C++ 程序员可能会不当使用语言，导致代码难以维护。

论坛上关于编码标准有很多讨论。有几人主张现有的标准，但也有人指出他们需要定义一个“安全”的 C++ 子集来使用。起初关于哪些 C++ 特性对于初学者来说是安全的意见不一。Taylor 提出了一套编码标准。这些被 Lawrence Crowl 和其他人修改后，然后被[采纳](http://gcc.gnu.org/codingconventions.html)。每个要求都有详尽的理由和讨论。然而，在可维护性上的指导原则并不是编码标准，而是一直存在于 GCC 中的原则：组件的维护者对于该组件的任何更改都有最终决定权。

#### 当前状态

目前，支持这些变化的人认为他们的努力产生了他们预期的好处。没有人公开表达对这项工作的不满。Makarov松了一口气，因为他担心的转换工作会耗费资源的担忧并未成真。此外，他指出提高模块化的好处是使GCC更容易学习，因此更有可能吸引新的开发人员。

关于速度，Makarov指出，在多CPU平台上引导程序的速度与C语言相比是一样快的。然而，在单处理器平台上，C语言的引导速度要快30%。他没有推测为什么会这样。他还发现了积极的影响，比如转换为C++的哈希表，可以将编译时间加快1-2%。这项工作是一个持续进行的过程，Lawrence Crowl在2012年10月最后[报告](http://gcc.gnu.org/ml/gcc-patches/2012-10/msg00217.html)过这方面的工作。为了响应Makarov的关切，这项工作进行得很慢，取决于人们的时间和兴趣。

在最初希望进行的转换中（gengtype、tree和vector），vector支持已经使用C++构造（即一个类）提供，而gengtype已经重写以支持C++兼容性。树结构则是另一回事。尽管它们被广泛讨论过，并且多次自愿进行，但代码并未作出任何改变。这加强了Guenther（现已将姓氏改为Biener）在2010年的主张的可信度，即正确地进行转换会很困难。最近联系到的Biener表示，他认为现在评估转换的影响还为时过早，因为与GCC的规模相比，对C++构造的改变还很少。但他也指出（正如其他人所言），由于这些改变，长期贡献者必须重新学习他们过去熟悉的内容。

在2008年、2009年和2010年（即在开始和每个里程碑之后），Taylor提供了下一步的正式计划。从这里起，没有正式的计划。未来的补丁中，人们将根据需要使用C++构造，但不仅仅为了这样做而这样做。有些人将改变局限于在修补代码时进行。其他人则审视现有的C代码，以便在代码更清晰或更高效时将其转换为C++。因此，在可预见的未来，这将是一项沿着曲折路径持续进行的努力。

随着C++项目的进展，一些担忧已经消除，而一些开发人员仍然处于观望状态。对于他们来说，现在评估事物还为时过早，改变方向也为时已晚。然而，大多数人似乎对这些变化感到满意。只有时间能告诉我们，新的利益或问题将会出现。

* * *

（

[登录](https://lwn.net/Login/?target=/Articles/542457/)

（发表评论）
