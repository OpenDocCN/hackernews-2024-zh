["```\nfn by_value(cat: Cat) { .. } fn by_reference(cat: &Cat) { .. } fn by_mutable_reference(cat: &mut Cat) { .. } \n```", "```\nlet db: Option<Database> = ..; let db = db.filter(|db| db.name? == \"chashu\"); \n```", "```\npub trait Into<T>: Sized {     \n  fn into(self) -> T; } \n```", "```\nimpl Into<Loaf> for Cat {     \n  fn into(self) -> Loaf {\n  self.nap()\n } } \n```", "```\npub trait AsyncInto<T>: Sized {     \n async fn into(self) -> T; } \n```", "```\nimpl AsyncInto<Loaf> for Cat {     \n async fn into(self) -> Loaf {\n  self.nap().await\n } } \n```", "```\n#[maybe(async)] impl Into<Loaf> for Cat {     \n #[maybe(async)]\n  fn into(self) -> Loaf {\n  self.nap()\n } } \n```", "```\nimpl Into<Loaf> for Cat {     \n  fn into(self) -> Loaf {\n  self.nap()\n } } \n```", "```\nimpl async Into<Loaf> for Cat {     \n async fn into(self) -> Loaf {\n  self.nap().await\n } } \n```", "```\nimpl async Into<Loaf> for Cat {\n async fn into(self) -> Loaf {\n  self.nap().await\n } } \n```", "```\nimpl Into<Loaf, true> for Cat {\n  type ReturnTy = impl Future<Output = Loaf>;\n fn into(self) -> Self::ReturnTy { async move {\n  self.nap().await\n } } } \n```", "```\npub fn copy<R, W>(\n  reader: &mut R,  writer: &mut W ) -> io::Result<()> where\n R: Read, W: Write; \n```", "```\npub fn async_copy<R, W>(\n  reader: &mut R,  writer: &mut W ) -> io::Result<()> where\n R: AsyncRead, W: AsyncWrite; \n```", "```\npub fn async_copy<R, W>(\n  reader: &mut R,  writer: &mut W ) -> io::Result<()> where\n R: async Read, W: async Write; \n```", "```\n#[maybe(async)] pub fn copy<R, W>(\n  reader: &mut R,  writer: &mut W ) -> io::Result<()> where\n R: #[maybe(async)] Read, W: #[maybe(async)] Write; \n```", "```\ncopy(reader, writer)?; // infer sync copy(reader, writer).await?; // infer async copy::<async>(reader, writer).await?; // force async \n```", "```\nstruct File { .. } impl File {\n  fn open<P>(p: P) -> Result<Self>\n  where\n P: AsRef<Path>; } \n```", "```\nstruct AsyncFile { .. } impl AsyncFile {\n async fn open<P>(p: P) -> Result<Self>\n  where\n P: AsRef<AsyncPath>; } \n```", "```\n#[maybe(async)] struct File { .. }   #[maybe(async)] impl File {\n #[maybe(async)]\n  fn open<P>(p: P) -> Result<Self>\n  where\n P: AsRef<#[maybe(async)] Path>; } \n```", "```\n#[maybe(async)] fn copy<R, W>(reader: R, writer: W) -> io::Result<()> {\n  let mut buf = vec![4028];\n  loop {\n  match reader.read(&mut buf).await? {  0 => return Ok(()),\n n => writer.write_all(&buf[0..n]).await?,\n } } } \n```", "```\nimpl File {\n #[maybe(async)]\n  fn open<P>(p: P) -> Result<Self> {\n  if IS_ASYNC { .. } else { .. }\n } } \n```", "```\npub async fn meow(self) {} pub const unsafe fn meow() {} \n```", "```\nasync { async_fn().await }; // async effect unsafe { unsafe_fn() }; // unsafe effect const { const_fn() }; // const effect try { try_fn()? }; // try effect (unstable) || { yield my_type }; // generator effect (unstable) \n```", "```\nlet x = try async { .. }; \n```", "```\n1\\. -> impl Future<Output = Result<T, E>> 2\\. -> Result<impl Future<Output = T>, E> \n```", "```\nconst fn meow() {} // maybe-const const {} // always-const \n```", "```\neffect const = diverge + panic; effect core   = const + statics + non_determinism; effect alloc  = core + heap; effect std    = alloc + host_apis; \n```"]