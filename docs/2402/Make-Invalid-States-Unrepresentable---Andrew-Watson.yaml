- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:28:28'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Make Invalid States Unrepresentable - Andrew Watson
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.awwsmm.com/blog/make-invalid-states-unrepresentable](https://www.awwsmm.com/blog/make-invalid-states-unrepresentable)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[[edit history]](https://github.com/awwsmm/awwsmm.com/commits/master/blog/make-invalid-states-unrepresentable.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have a `Person` class in your program, and that a `Person` has an
    `age`. What type should the `age` be?
  prefs: []
  type: TYPE_NORMAL
- en: '`age` as a `String`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '"Of course it shouldn''t be a `String`" you might think. But why? The reason
    is that we can then end up with code like'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ever wanted to *do* anything with an `age: String`, we would need to
    validate it everywhere'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is cumbersome for the programmer *writing* the code, and makes it difficult
    for any programmer *reading* the code, as well.
  prefs: []
  type: TYPE_NORMAL
- en: We could move this validation to a separate method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '...but this is still not ideal. The code is a bit cleaner, but we still need
    to parse a `String` into an `Int` every time we want to do anything numeric (comparison,
    arithmetic, etc.) with the `age`. This is often called ["stringly-typed" data](https://en.wiktionary.org/wiki/stringly-typed).'
  prefs: []
  type: TYPE_NORMAL
- en: This can also move the program into an illegal state by throwing an `Exception`.
    If we're going to fail anyway, we should [fail fast](https://www.martinfowler.com/ieeeSoftware/failFast.pdf).
    We can do better.
  prefs: []
  type: TYPE_NORMAL
- en: '`age` as an `Int`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your first instinct might have been to make `age` an `Int`, rather than a `String`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If so, you have good instincts. An `age: Int` is much nicer to work with'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This
  prefs: []
  type: TYPE_NORMAL
- en: is easier to write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: is easier to read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fails fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You *cannot construct* an instance of the `Person` class with a `String` `age`
    now. That is an invalid state. We have [made it unrepresentable](https://www.cs.rice.edu/~javaplt/411/23-spring/NewReadings/functional_programming_on_Wall_Street.pdf),
    using the type system. The compiler will not allow this program to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Problem solved, right?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is clearly an invalid state as well. A person cannot have a negative age.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is also invalid -- it looks like someone accidentally entered their [ZIP
    code](https://en.wikipedia.org/wiki/Beverly_Hills,_California) instead of their
    age.
  prefs: []
  type: TYPE_NORMAL
- en: So how can we constrain this type even further? How can we make even more invalid
    states unrepresentable?
  prefs: []
  type: TYPE_NORMAL
- en: '`age` as an `Int` with constraints'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: at runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can enforce *runtime constraints* in any statically-typed language
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In Scala, `assert` will throw a `java.lang.AssertionError` if the assertion
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can be sure that the `age` for any `Person` will always be within the
    range `[0, 150)`. Both
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: will now fail. But they will fail at runtime, halting the execution of our program.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to what we saw in "`age` as a `String`", above. This is still
    not ideal. Is there a better way?
  prefs: []
  type: TYPE_NORMAL
- en: at compile time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many languages allow *compile-time* constraints, as well. Usually this is accomplished
    through macros, which inspect the source code during a compilation phase. These
    are often referred to as [refined types](https://en.wikipedia.org/wiki/Refinement_type).
  prefs: []
  type: TYPE_NORMAL
- en: Scala has [quite good](https://blog.rockthejvm.com/refined-types/) support for
    [refined types](https://github.com/Iltotore/iron) across multiple libraries. A
    solution using the [`refined` library](https://github.com/fthomas/refined) might
    look something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A limitation of this approach is that the field(s) to be constrained at compile-time
    must be [*literal*, hard-coded](https://en.wikipedia.org/wiki/Literal_(computer_programming))
    values. Compile-time constraints cannot be enforced on, for example, values provided
    by a user. By that point, the program has already been compiled. In this case,
    we can always fall back to runtime constraints, which is often what these libraries
    do.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we'll continue with runtime constraints only, since often that's the
    best we can do.
  prefs: []
  type: TYPE_NORMAL
- en: '`age` as an `Age` with constraints'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From simplest to most complex implementation, we moved left to right in the
    diagram below
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This increase in complexity directly correlates with the *accuracy* with which
    we're modelling this data
  prefs: []
  type: TYPE_NORMAL
- en: '"The problems tackled have inherent complexity, and it takes some effort to
    model them appropriately." [[source]](https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The move left-to-right above should be driven by the requirements of your system.
    You should not implement compile-time refinements, for example, unless you have
    lots of hard-coded values to validate at compile time: otherwise [you aren''t
    gonna need it](https://martinfowler.com/bliki/Yagni.html). Every line of code
    has a cost to implement and maintain. Avoiding premature specification is just
    as important as avoiding [premature generalization](https://www.codewithjason.com/premature-generalization),
    though it''s ***always easier* to move from more specific types to less specific
    types**, so prefer specificity over generalization.'
  prefs: []
  type: TYPE_NORMAL
- en: Every bit of data has a *context*, as well. There is no such thing as a "pure"
    `Int` value floating around in the universe. An age can be modelled as an `Int`,
    but it's different from a weight, which could also be modelled as an Int. The
    labels we attach to these raw values are the *context*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is one more problem for us to solve here. Suppose I'm 81kg and 33 years
    old
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That compiles, but... it shouldn't. I swapped my weight and age!
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to avoid this confusion is to define some more types. In this case,
    [*newtypes*](https://doc.rust-lang.org/rust-by-example/generics/new_types.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The name *newtype* for this pattern [comes from Haskell](https://wiki.haskell.org/Newtype).
    This is a simple way to ensure that we don't accidentally swap values with the
    same underlying type. The following, for example, will not compile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We could also use [*tagged types*](https://medium.com/iterators/to-tag-a-type-88dc344bb66c).
    In Scala, the simplest possible example of this looks something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This makes use of the fact that function application `f()` is syntactic sugar
    in Scala for an `apply()` method. So `f()` is equivalent to `f.apply()`.
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows us to model the idea that an `Age` / a `Weight` is an `Int`,
    but an `Int` is not an `Age` / a `Weight`. This means we can treat an `Age` /
    a `Weight` *as* an `Int` and add, subtract, or do whatever other `Int`-like things
    we want to do.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing these two approaches in one example, you can see the difference between
    newtypes and tagged types. You must extract the "raw value" from a newtype. You
    do not need to do this with a tagged type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In some languages, the "unwrapping" of newtypes can be done automatically. This
    can make newtypes as ergonomic as tagged types. For example, in Scala, this could
    be done with an *implicit conversion*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Further refinements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The important point of the above discussion is that, as much as possible, we
    want to *make invalid states unrepresentable*.
  prefs: []
  type: TYPE_NORMAL
- en: '"Jeff" is an invalid age. Age isn''t a string, it is a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -1 is an invalid age. Age cannot be negative, it should be 0 or positive, and
    probably less than about 150.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My age is not 88\. An age should be easily distinguishable from other integral
    values, like weight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything discussed above implemented these refinements on the concept of "age",
    one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We can make further refinements if there is a need for those refinements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we want to send a "Happy Birthday!" email to a `Person`
    on their birthday. Rather than an `Age`, we now need a date of birth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The amount of information provided by `dateOfBirth` is strictly greater than
    the amount of information provided by `Age`. We can calculate someone's age from
    their date of birth, but we cannot do the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: The above implementation leaves much to be desired, though -- there are lots
    of invalid states. A better way to implement this would be for `Month` to be an
    enum, and for `Day` validity to depend on the `Month` (February never has 30 days,
    for example)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Always prefer low-cardinality types to [high-cardinality types](https://www.seas.upenn.edu/~sweirich/types/archive/1999-2003/msg01233.html),
    when possible. It limits the number of possible invalid states. In most languages,
    `enum`s are the way to go here (in Scala 2, an `enum` can be modelled using a
    `sealed trait`, as shown above). But there are still invalid states hiding above.
    Can you find them?
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, stringly-typed data validated using regular expressions can be
    replaced entirely by `enum`s. Could you model [Canadian postal codes](https://www150.statcan.gc.ca/n1/pub/92-153-g/2011002/tech-eng.htm)
    such that it's impossible to construct an invalid one?
  prefs: []
  type: TYPE_NORMAL
- en: Use the above knowledge to go forth and *make invalid states unrepresentable*.
  prefs: []
  type: TYPE_NORMAL
