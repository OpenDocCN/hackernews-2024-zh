["```\n `pub fn select_all_matches(\n     &mut self,\n     action: &SelectAllMatches,\n     cx: &mut ViewContext<Self>\n ) -> Result<()> {\n        self.push_to_selection_history();\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        loop {\n            self.select_next_match_internal(&display_map, action.replace_newest, cx)?;\n\n            if self.select_next_state.as_ref().map(|selection_state| selection_state.done).unwrap_or(true)\n            {\n                break;\n            }\n        }\n\n        Ok(())\n    }`\n```", "```\n`loop {\n  user = loadNextUser()\n  if user == null {\n    break\n  }\n  profilePicture = loadUserProfilePicture(user)\n  blogPosts = loadLastFiveBlogPosts(user)\n\n  render_template(\"user_profile\", user)\n}`\n```", "```\n`users = loadAllUsers()\npictures = loadUserProfilePicturesForUsers(users)\nblogPosts = loadLastFiveBlogPostsForUsers(users)\nfor user in users {\n  render_template(\"user_profile\", user)\n}`\n```", "```\n`pub fn select_all_matches(\n    &mut self,\n    _action: &SelectAllMatches,\n    cx: &mut ViewContext<Self>,\n) -> Result<()> {\n    self.push_to_selection_history();\n    let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n    self.select_next_match_internal(&display_map, false, None, cx)?;\n    let Some(select_next_state) = self.select_next_state.as_mut() else {\n        return Ok(());\n    };\n    if select_next_state.done {\n        return Ok(());\n    }\n\n    let mut new_selections = self.selections.all::<usize>(cx);\n\n    let buffer = &display_map.buffer_snapshot;\n    let query_matches = select_next_state\n        .query\n        .stream_find_iter(buffer.bytes_in_range(0..buffer.len()));\n\n    for query_match in query_matches {\n        let query_match = query_match.unwrap(); // can only fail due to I/O\n        let offset_range = query_match.start()..query_match.end();\n        let display_range = offset_range.start.to_display_point(&display_map)\n            ..offset_range.end.to_display_point(&display_map);\n\n        if !select_next_state.wordwise\n            || (!movement::is_inside_word(&display_map, display_range.start)\n                && !movement::is_inside_word(&display_map, display_range.end))\n            {\n                self.selections.change_with(cx, |selections| {\n                    new_selections.push(Selection {\n                        id: selections.new_selection_id(),\n                        start: offset_range.start,\n                        end: offset_range.end,\n                        reversed: false,\n                        goal: SelectionGoal::None,\n                    });\n                });\n            }\n    }\n\n    new_selections.sort_by_key(|selection| selection.start);\n    let mut ix = 0;\n    while ix + 1 < new_selections.len() {\n        let current_selection = &new_selections[ix];\n        let next_selection = &new_selections[ix + 1];\n        if current_selection.range().overlaps(&next_selection.range()) {\n            if current_selection.id < next_selection.id {\n                new_selections.remove(ix + 1);\n            } else {\n                new_selections.remove(ix);\n            }\n        } else {\n            ix += 1;\n        }\n    }\n\n    select_next_state.done = true;\n    self.unfold_ranges(\n        new_selections.iter().map(|selection| selection.range()),\n        false, false, cx,\n    );\n    self.change_selections(Some(Autoscroll::fit()), cx, |selections| {\n        selections.select(new_selections)\n    });\n\n    Ok(())\n}`\n```"]