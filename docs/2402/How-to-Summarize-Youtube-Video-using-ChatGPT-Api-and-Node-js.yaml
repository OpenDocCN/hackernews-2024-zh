- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:51:44'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: How to Summarize Youtube Video using ChatGPT Api and Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://implementing.substack.com/p/how-to-summarize-youtube-video-using](https://implementing.substack.com/p/how-to-summarize-youtube-video-using)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hey, I'm [Marco](https://www.linkedin.com/in/marco-moauro-b49489162/) and welcome
    to my newsletter!
  prefs: []
  type: TYPE_NORMAL
- en: As a software engineer, I created this newsletter to share my first-hand knowledge
    of the development world. Each topic we will explore will provide valuable insights,
    with the goal of inspiring and helping all of you on your journey.
  prefs: []
  type: TYPE_NORMAL
- en: In this episode I want to bring you the first tutorial, on how to make a system
    in Node.js that starting from a youtube video link generates a summary using OpenAI's
    [completions api](https://platform.openai.com/docs/guides/text-generation/chat-completions-api),
    the same api on which the ChatGPT system is based.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download all the code shown directly from my Github repository: [https://github.com/marcomoauro/youtube-summarizer](https://github.com/marcomoauro/youtube-summarizer)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Subscribe to Implementing ‚ú®](https://implementing.substack.com/subscribe)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'The system architecture primarily comprises:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting text from YouTube videos
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating text summaries
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This process involves extracting text from the video and utilizing it for summary
    generation. Various options were considered, including:'
  prefs: []
  type: TYPE_NORMAL
- en: The chosen solution involves scraping, which is the most challenging among the
    options. This decision is motivated by the fact that implementing everything independently
    incurs no costs associated with third-party APIs for text extraction. Additionally,
    as a genuine enthusiast, I prefer this approach, given that most of my personal
    projects are founded on this technique.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in finding out what are the best practices for web scraping
    sign up for the newsletter, I will be publishing a post about it soon.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After getting the captions, we put them into OpenAI. The first challenge I faced
    was the limit on the maximum size of the text that the completions API can handle.
    This limit depends on the model used; for the 3.5 turbo model, it's specifically
    set at 4.000 tokens.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this limitation, I adopted a recursive approach. The text is divided
    into smaller parts, which are merged into groups and summarized independently;
    this process is repeated until a single output text is generated, corresponding
    to the final summary generated from the intermediate summaries.
  prefs: []
  type: TYPE_NORMAL
- en: '[Subscribe to Implementing ‚ú®](https://implementing.substack.com/subscribe)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: For this tutorial you need to have Yarn and Node.js installed, specifically
    I used the LTS version 20.9.0\. If you don't have Node.js on your machine you
    can install it from the [official website](https://nodejs.org/en).
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from my workspaces folder I have created the project folder and the
    npm package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'add the clause ‚Äútype: module‚Äù to use ES6 syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The libraries we need are **Axios**, a library for making HTTP calls, we will
    need to implement the call to the completion, **he** and **striptags** to manipulate
    the HTML, **p-queue** for handle a queue for the promises in order to call OpenAI
    with max X calls in the same moment and **yargs** to build interactive command
    line tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install it typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the file **getSubtitleFromVideo.js**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The initial function we'll create is designed to use web scraping to fetch the
    HTML content of a YouTube video page. Let's name this function **getHTML**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we get the html we can retrieve the subtitles via this **getSubtitle**
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: => Inside the video's HTML, there's a YouTube link directing to their timedtext
    API, where an XML file containing automatic captioning can be found (an example
    is provided [here](https://www.youtube.com/api/timedtext?v=ULDCt13hetw&ei=c5GOZcmyFea26dsP0-ydqAQ&caps=asr&opi=112496729&xoaf=5&hl=it&ip=0.0.0.0&ipbits=0&expire=1703867363&sparams=ip,ipbits,expire,v,ei,caps,opi,xoaf&signature=75063412BCC19F57C0FACAD8F931B04B33607678.3E55E91F52C40D16D66F8420C614830C702CAAB2&key=yt8&kind=asr&lang=en)).
    This XML data is what we extract to generate the summary.
  prefs: []
  type: TYPE_NORMAL
- en: '**getSubtitleFromVideo.js** file will export the **getSubtitleFromVideo** function.
    This function can be called externally, taking the video link as input and returning
    the corresponding subtitles.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the contents of the file **getSubtitleFromVideo.js:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Subscribe to Implementing ‚ú®](https://implementing.substack.com/subscribe)'
  prefs: []
  type: TYPE_NORMAL
- en: After getting the subtitles, the goal is to arrange them in chunks of text and
    then summarize. As mentioned earlier, different models have various maximum context
    limits; for the 3.5 turbo model, it's 4,000 tokens, I made the assumption that
    1 token equals 1 character.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s go ahead and create the **splitInChunks.js** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file we are going to export a function with the same name splitInChunks
    that takes care of grouping the individual subtitles of the video frames into
    chunks of up to 4000 words, here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At this point we have the chunks and we can proceed with the summary step.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file **summarizeChunks.js:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'we first define the method for calling the OpenAI api:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We submit a prompt to the completions API, comprising a "system" message instructing
    it on what to do, and a "user" message containing the text to be summarized. It's
    important to create an API key on the OpenAI developer portal, just follow this
    [link](https://openai.com/blog/openai-api). Once created, simply insert the key
    into the constant `OPEN_AI_API_KEY`.
  prefs: []
  type: TYPE_NORMAL
- en: I've named this function with the underscore (_) prefix because we'll define
    a new function called computeSummaryByAI, which serves as the entry point to OpenAI.
    This function utilizes the p-queue library to manage a maximum number of Promises
    running concurrently, preventing rate-limiting issues and slower response times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With `concurrency: 5` it means that there can be at most 5 calls running to
    OpenAI, all because we will launch calls in "parallel" via the **Promise.all**
    construct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now come to the core part of the summary mechanism, the function that will
    export the file will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function is responsible for generating an initial summary for each chunk
    to make sense of the content, considering that the chunks contain automatic subtitles
    generated by YouTube. After calculating the summary, if we have only one chunk,
    the process is complete, and the result is ready. Otherwise, we need to proceed
    with the recursive algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now define the recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are fewer than 5 pieces, proceed to the summary by combining the pieces
    into a single text. It is worth noting that we specified a maximum of 200 words
    in the prompt. With 5 pieces, we should have a maximum of 1000 words. However,
    in experimenting, I have noticed that these limits specified in the OpenAI prompt
    are often not met. As a result, I opted for lower thresholds to ensure proper
    operation without running into errors due to too large context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have more than 5 chunks, we group them into groups of 5, for each we merge
    them into a single text and summarize them. Calls for summaries are executed in
    parallel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the function relaunches itself by passing the result of the recursive
    step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All the code shown can be found here: [https://github.com/marcomoauro/youtube-summarizer](https://github.com/marcomoauro/youtube-summarizer)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'I created a CLI through which you can summarize the videos you want by passing
    the YouTube video link and the language code in which you want the summary, here
    is an example of how to launch it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*requires that you are in the root of the project and have properly installed
    the dependencies with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: I have integrated this functionality into my [quickview.email](https://quickview.email/try-summary)
    website. Simply provide the email with which you want to receive the summary,
    the link to the youtube video and the language in which you want to read it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Subscribe to Implementing ‚ú®](https://implementing.substack.com/subscribe)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This same mechanism is the driving force behind my crypto newsletter, are you
    interested in the world of cryptocurrencies but don't have time to stay up-to-date?
    Sign up now to receive daily video summaries!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'And that‚Äôs it for today! If you are finding this newsletter valuable, consider
    doing any of these:'
  prefs: []
  type: TYPE_NORMAL
- en: üçª **Read with your friends** ‚Äî Implementing lives thanks to word of mouth. Share
    the article with someone who would like it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Share](https://implementing.substack.com/p/how-to-summarize-youtube-video-using?utm_source=substack&utm_medium=email&utm_content=share&action=share)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: üì£ **Provide your feedback** - We welcome your thoughts! Please share your opinions
    or suggestions for improving the newsletter, your input helps us adapt the content
    to your tastes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Leave a comment](https://implementing.substack.com/p/why-i-moved-from-rails-to-nodejs/comments)'
  prefs: []
  type: TYPE_NORMAL
- en: I wish you a great day! ‚òÄÔ∏è
  prefs: []
  type: TYPE_NORMAL
- en: Marco
  prefs: []
  type: TYPE_NORMAL
