<!--yml

category: 未分类

date: 2024-05-27 15:00:41

-->

# 浮点数是奇怪的

> 来源：[https://a.exozy.me/posts/floats-weird/](https://a.exozy.me/posts/floats-weird/)

浮点数很奇怪。无论如何，这里有一个基本的微积分练习：

\[\lim_{x \to 0} \frac{e^x-1}{x} = 1\]

然而，在这里我不会证明这个极限，因为这篇文章是关于浮点数奇怪性，而不是微积分文章。相反，让我们尝试使用Python对这个极限进行数值近似，因为最坏的情况是什么？让我们将该分数写成一个Python函数，并插入越来越小的$x$。

```
def f(x):  return (math.exp(x)-1)/x 
```

`f(1e-9)`返回1.000000082740371，而`f(1e-12)`返回1.000088900582341，这已经很奇怪了。随着较小的$x$，近似值难道不应该变得更好吗？然而，真正的麻烦出现在`f(1e-15)`。它返回一个惊人的1.1102230246251565，这有超过10%的误差！

但是，有了这个奇怪的技巧&mldr;

```
def g(x):  y = math.exp(x) return (y-1)/math.log(y) 
```

`g(1e-9)`返回1.0000000005，`g(1e-12)`返回1.0000000000005，而`g(1e-15)`返回1.0000000000000004，这正是我们想要的！ 🤯

等一下！这个新函数正在做冗余计算！为什么我们要取$\log(e^x)$，而不是简单地除以$x$？这是如何如此有效地减少错误的？

## 假设

要解释这种现象，我们需要做一个巨大的简化假设。对于像$x+y$这样的某些操作，使用浮点运算时，最终答案不会完全等于$x+y$的精确值。让我们用$fl(x+y)$表示这个浮点计算的值。然后，我们假设$fl(x+y) = (x+y)(1+\delta)$，其中$\delta$很小。$\delta$的上界取决于我们使用的浮点数类型。Python使用IEEE 754双精度浮点数，其$\delta$的大小最多为$2^{-53}$。

你可能会想为什么我们没有选择一个不同的假设，即$|fl(x+y) - (x+y)| < \epsilon$，其中$\epsilon$很小。这是因为随着浮点数变得越来越大，它们之间的间隔也变得更大，因此对于大的$x, y$，$fl(x+y)$可能与$x+y$有很大的绝对差异，但其相对差异$\frac{fl(x+y)}{x+y}$仍然很小。因此，我们最初的假设确实是正确的。

我们还假设这种$1+\delta$假设对减法、乘法、指数运算和对数运算等其他操作同样成立。现在我们有了解决问题的必要工具！

## 分析f

首先，让我们找出$fl\left(\frac{e^x-1}{x}\right)$。使用我们的$1+\delta$假设，我们有

\[fl\left(\frac{e^x-1}{x}\right) = \frac{(e^x(1+\delta_1)-1)(1+\delta_2)}{x}(1+\delta_3).\]

你可能还记得从微积分中$e^x = 1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\dots$，这是一个泰勒级数。因为我们只插入了非常小的$x$值，$x^2$、$x^3$和其他更高次幂都是非常非常小的数，所以我们可以简单地忽略它们。我们只说$e^x \approx 1+x$。这在数学和物理中是一个常见的技巧。现在我们得到

\[fl\left(\frac{e^x-1}{x}\right) = \frac{((1+x)(1+\delta_1)-1)(1+\delta_2)}{x}(1+\delta_3) = \frac{(x+\delta_1+x\delta_1)(1+\delta_2)}{x}(1+\delta_3).\]

再次，由于 $x$ 很小，$x\delta_1$ 将非常微小，所以我们也可以忽略它。因此，整个过程简化为

\[fl\left(\frac{e^x-1}{x}\right) = (1+\frac{\delta_1}{x})(1+\delta_2)(1+\delta_3).\]

如果我们将 $x = 10^{-15}, \delta_1 = 2^{-53}$ 代入，我们得到 $1+\frac{\delta_1}{x} = 1.1110$，这与一开始得到的实际误差非常相似！很棒，现在我们可以看到错误的源头了：$x$ 在分母中，所以随着 $x$ 变小，误差增大。

## 分析 g

接下来，让我们找出 $fl\left(\frac{e^x-1}{\log(e^x)}\right)$。再次使用我们最喜欢的假设，我们得到

\[fl\left(\frac{e^x-1}{\log(e^x)}\right) = \frac{(e^x(1+\delta_1)-1)(1+\delta_2)}{\log(e^x(1+\delta_1))(1+\delta_4)}(1+\delta_3).\]

这看起来相当可怕，但我们可以使用 $e^x \approx 1+x$ 和 $x\delta_1 \approx 0$ 的近似将其简化为

\[fl\left(\frac{e^x-1}{\log(e^x)}\right) = \frac{(x+\delta_1)(1+\delta_2)}{\log(1+x+\delta_1)(1+\delta_4)}(1+\delta_3).\]

现在我们需要最后一个 Taylor 级数，用于 $\log(x)$。由于这篇文章不是关于微积分的（尽管它有点），我只是给你我们需要的 Taylor 级数：$\log(x) = (x-1) - \frac{(x-1)^2}{2} + \frac{(x-1)^3}{3} - \frac{(x-1)^4}{4} + \dots$（这个级数并不对所有 $x$ 收敛，但无所谓）。重要的是，$(x-1)^2$ 和更高阶的幂会非常小，因为我们将 $x$ 插入 $\log(x)$ 的 $1+x+\delta_1$。因此，我们可以忽略它们，并得出结论 $\log(x) \approx x-1$。

当我们将这个近似值代入时，一些神奇的事情发生了。分子中的 $x+\delta_1$ 和分母中的 $x$ 抵消了！我们只剩下

\[fl\left(\frac{e^x-1}{\log(e^x)}\right) = \frac{1+\delta_2}{1+\delta_4}(1+\delta_3).\]

太棒了！现在我们可以清楚地看到，对于小的 $x$，得到的误差是微小的。你可能会想知道为什么这个答案中没有 $x$。当我们插入 $x = 10^{-6}$ 时，它并不接近于 1。这是因为当 $x = 10^{-6}$ 时，我们对 $e^x \approx 1+x$ 和 $\log(x) \approx x-1$ 的近似并不完全有效，因为平方项确实会有所贡献。基本上，我们的答案只对 $x$ 非常小且接近 $10^{-15}$ 时才成立。

直觉上，`g` 比 `f` 更准确，因为分子和分母中的 $e^x$ 的误差最终抵消了，但这实际上是一个相当误导人的解释。要看到为什么会发生这种情况，唯一的方法是仔细分析。

总之，浮点数很奇怪。
