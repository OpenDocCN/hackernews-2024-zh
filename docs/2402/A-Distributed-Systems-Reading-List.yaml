- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-27 14:42:08'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 14:42:08
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: A Distributed Systems Reading List
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个分布式系统阅读列表
- en: 来源：[https://ferd.ca/a-distributed-systems-reading-list.html](https://ferd.ca/a-distributed-systems-reading-list.html)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://ferd.ca/a-distributed-systems-reading-list.html](https://ferd.ca/a-distributed-systems-reading-list.html)
- en: 2024/02/07
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 2024/02/07
- en: A Distributed Systems Reading List
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个分布式系统阅读列表
- en: This document contains various resources and quick definition of a lot of background
    information behind distributed systems. It is not complete, even though it is
    kinda sorta detailed. I had written it some time in 2019 when coworkers at the
    time had asked for a list of references, and I put together what I thought was
    a decent overview of the basics of distributed systems literature and concepts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本文包含各种资源和分布式系统背后的大量背景信息的快速定义。尽管它有点详细，但并不完整。我在2019年某个时候写了这篇文章，当时同事们要求我提供参考文献列表，我整理了我认为是分布式系统文献和概念基础的不错概述。
- en: Since I was asked for resources again recently, I decided to pop this text into
    my blog. I have verified the links again and replaced those that broke with archive
    links or other ones, but have not sought alternative sources when the old links
    worked, nor taken the time to add any extra content for new material that may
    have been published since then.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最近又有人向我要资源，所以我决定将这篇文章放到我的博客上。我再次验证了链接，并用存档链接或其他链接替换了那些失效的链接，但在旧链接有效时没有寻找替代来源，也没有花时间添加任何可能已经发布的新材料的额外内容。
- en: It is meant to be used as a quick reference to understand various distsys discussions,
    and to discover the overall space and possibilities that are around this environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它旨在作为快速参考，了解各种分布式系统讨论，并发现环境中存在的总体空间和可能性。
- en: Foundational theory
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础理论
- en: This is information providing the basics of all the distsys theory. Most of
    the papers or resources you read will make references to some of these concepts,
    so explaining them makes sense.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提供所有分布式系统理论基础知识的信息。你阅读的大多数论文或资源都会涉及到其中一些概念，因此解释它们是有意义的。
- en: Models
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模型
- en: In a Nutshell
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 概述
- en: 'There are three model types used by computer scientists doing distributed system
    theory:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家在进行分布式系统理论时使用了三种模型类型：
- en: synchronous models
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步模型
- en: semi-synchronous models
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 半同步模型
- en: asynchronous models
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步模型
- en: A **synchronous model** means that each message sent within the system has a
    known *upper bound* on communications (max delay between a message being sent
    and received) and the processing speed between nodes or agents. This means that
    you can *know* for sure that after a period of time, a message was missed. This
    model is applicable in rare cases, such as hardware signals, and is mostly beginner
    mode for distributed system proofs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步模型**意味着系统中每个发送的消息都有一个已知的通信上限（消息发送和接收之间的最大延迟）以及节点或代理之间的处理速度。这意味着你可以*确切地*知道在一段时间之后，某个消息被错过了。这种模型在硬件信号等少数情况下适用，并且在大多数情况下是分布式系统证明的初学者模式。'
- en: An **asynchronous model** means that you have no upper bound. It is legit for
    agents and nodes to process and delay things indefinitely. You can never assume
    that a "lost" message you haven't seen for the last 15 years won't just happen
    to be delivered tomorrow. The other node can also be stuck in a GC loop that lasts
    500 centuries, that's good.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步模型**意味着你没有上限。节点和代理可以无限期地处理和延迟事务。你永远不能假设你在过去15年没有看到的“丢失”消息不会在明天被传送。另一个节点也可能陷入持续500世纪的垃圾回收循环中，这很好。'
- en: Proving something works on asynchronous model means it works with all other
    types. This is expert mode for proofs and is even trickier than real world implementations
    to make work in most cases.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步模型上证明某事可行意味着它对所有其他类型也适用。这是专家模式的证明，甚至比大多数情况下的实际实现更棘手。
- en: The **Semi-synchronous models** are the cheat mode for real world. There *are*
    upper-bounds to the communication mechanisms and nodes everywhere, but they are
    often configurable and unspecified. This is what lets a protocol designer go "you
    know what, we're gonna stick a *ping* message in there, and if you miss too many
    of them we consider you're dead."
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**半同步模型**是现实世界的作弊模式。通信机制和各个节点都有上限，但它们通常是可配置的和未指定的。这就是让协议设计者能够说“你知道吗，我们会在里面加上一个*ping*消息，如果你错过了太多次，我们就认为你挂了。”的原因。'
- en: You can't assume all messages are delivered reliably, but you give yourself
    a chance to say "now that's enough, I won't wait here forever."
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能假设所有消息都能可靠地传递，但你可以给自己一个机会说“现在够了，我不会永远等待下去。”
- en: Protocols like Raft, Paxos, and ZAB (quorum protocols behind etcd, Chubby, and
    ZooKeeper respectively) all fit this category.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Raft、Paxos和ZAB（etcd、Chubby和ZooKeeper背后的法定代表人协议）等协议都属于这一类别。
- en: Theoretical Failure Modes
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理论故障模式
- en: 'The way failures happen and are detected is important to a bunch of algorithms.
    The following are the most commonly used ones:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 故障发生和被检测的方式对一些算法很重要。以下是最常用的一些：
- en: Fail-stop failures
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止失败
- en: Crash failures
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 崩溃故障
- en: Omission failures
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 省略故障
- en: Performance failures
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能故障
- en: Byzantine failures
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拜占庭故障
- en: First, **Fail-stop failures** mean that if a node encounters a problem, everyone
    can know about it and detect it, and can restore state from stable storage. This
    is easy mode for theory and protocols, but super hard to achieve in practice (and
    in some cases impossible)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**停止失败**意味着如果一个节点遇到问题，每个人都能知道并检测到，并且可以从稳定的存储中恢复状态。这对于理论和协议来说是简单模式，但在实践中（有时甚至是不可能的情况下）却非常难以实现。
- en: '**Crash failures** mean that if a node or agent has a problem, it crashes and
    then never comes back. You are either correct or late forever. This is actually
    easier to design around than fail-stop in theory (but a huge pain to operate because
    redundancy is the name of the game, forever).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**崩溃故障**意味着如果一个节点或代理出了问题，它就会崩溃，然后永远不会恢复。你要么正确，要么永远迟到。在理论上，这实际上比停止故障更容易设计（但在操作上非常痛苦，因为冗余是游戏的名字，永远）。'
- en: '**Omission failures** imply that you give correct results that respect the
    protocol or never answer.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**省略故障**意味着您提供符合协议的正确结果或从不回答。'
- en: '**Performance failures** assumes that while you respect the protocol in terms
    of the content of messages you send, you will also possibly send results late.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能故障**假设虽然您在发送消息的内容方面尊重协议，但也可能会延迟发送结果。'
- en: '**Byzantine failures** means that anything can go wrong (including people willingly
    trying to break you protocol with bad software pretending to be good software).
    There''s a special class of **authentication-detectable byzantine failures** which
    at least put the constraint that you can''t forge other messages from other nodes,
    but that is an optional thing. Byzantine modes [are the worst](http://scholar.harvard.edu/files/mickens/files/thesaddestmoment.pdf).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**拜占庭故障**意味着任何事情都可能出错（包括人们愿意尝试用坏软件假装成好软件来破坏您的协议）。有一种特殊类别的**通过认证检测的拜占庭故障**，至少会强制您不能伪造其他节点的其他消息，但这是可选的。拜占庭模式[是最糟糕的](http://scholar.harvard.edu/files/mickens/files/thesaddestmoment.pdf)。'
- en: By default, most distributed system theory assumes that there are no bad actors
    or agents that are corrupted and willingly trying to break stuff, and byzantine
    failures are left up to blockchains and some forms of package management.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，大多数分布式系统理论假设没有坏的行为者或被腐败并愿意破坏东西的代理人，而拜占庭故障则留给区块链和某些形式的软件包管理。
- en: Most modern papers and stuff will try and stick with either crash or fail-stop
    failures since they tend to be practical.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代论文和其他资料都会尝试坚持使用崩溃或失败停止故障，因为它们往往是实用的。
- en: See [this typical distsys intro slide deck](https://ti.tuwien.ac.at/cps/teaching/courses/dependable_systems-ss08/dcs_slides/dcs-2007-p5.pdf)
    for more details.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节请参阅[此典型分布式系统简介幻灯片](https://ti.tuwien.ac.at/cps/teaching/courses/dependable_systems-ss08/dcs_slides/dcs-2007-p5.pdf)。
- en: Consensus
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共识
- en: 'This is one of the core problems in distributed systems: how can all the nodes
    or agents in a system agree on one value? The reason it''s so important is that
    if you can agree on *just one value*, you can then do a lot of things.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是分布式系统中的一个核心问题：系统中的所有节点或代理如何同意一个值？之所以如此重要，是因为如果您只能就*一个值*达成一致，那么您就可以做很多事情。
- en: The most common example of picking a single very useful value is *the name of
    an elected leader* that enforces decisions, just so you can stop having to build
    more consensuses because holy crap consensuses are painful.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 选取单个非常有用的值的最常见示例是*选举领导者的名称*，以强制执行决策，这样您就可以停止构建更多的共识，因为天啊，共识是痛苦的。
- en: Variations exist on what exactly is a consensus, including does everyone agree
    fully? (strong) or just a majority? (t-resilient) and asking the same question
    in various synchronicity or failure models.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于共识的确切定义存在变化，包括每个人都完全同意吗？（强）还是只是大多数人？（t-弹性）以及在各种同步或故障模型中询问相同的问题。
- en: Note that while classic protocols like Paxos use a leader to ensure consistency
    and speed up execution while remaining consistent, a bunch of systems will forgo
    these requirements.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管像Paxos这样的经典协议使用领导者来确保一致性并加快执行速度，同时保持一致性，但一些系统将放弃这些要求。
- en: FLP Result
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FLP结果
- en: In A Nutshell
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简而言之
- en: Stands for *Fischer-Lynch-Patterson*, the authors of a 1985 paper that states
    that proper consensus where *all* participants agree on a value is unsolvable
    in a purely asynchronous model (even though it is in a synchronous model) as long
    as any kind of failure is possible, even if they're just delays.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代表*Fischer-Lynch-Patterson*，这是一篇于1985年的论文的作者，该论文指出在纯异步模型中无法解决所有参与者都同意一个值的适当共识（即使在同步模型中是可能的），只要任何类型的故障都可能发生，即使只是延迟。
- en: It's one of the most influential papers in the arena because it triggered a
    lot of other work for other academics to define what exactly is going on in distributed
    systems.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该领域最具影响力的论文之一，因为它引发了许多其他学者进行其他工作，以定义分布式系统中到底发生了什么。
- en: Detailed reading
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 详细阅读
- en: Fault Detection
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障检测
- en: Following FLP results, which showed that failure detection was kind of super-critical
    to making things work, a lot of computer science folks started working on what
    exactly it means to detect failures.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在FLP结果之后，该结果显示故障检测对使事物正常运作至关重要，许多计算机科学家开始研究到底什么是故障检测。
- en: This stuff is hard and often much less impressive than we'd hope for it to be.
    There are *strong* and *weak* fault detectors. The former implies all faulty processes
    are eventually identified by all non-faulty ones, and the latter that only some
    non-faulty processes find out about faulty ones.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些东西很难，而且通常远比我们希望的要不那么令人印象深刻。有*强*和*弱*故障检测器。前者意味着所有有故障的进程最终都会被所有没有故障的进程识别出来，而后者则只意味着一些没有故障的进程会发现有故障的进程。
- en: 'Then there are degrees of accuracy:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后存在准确度的度量：
- en: Nobody who has not crashed is suspected of being crashed
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有发生过崩溃的人不会被怀疑崩溃。
- en: It's possible that a non-faulty process is never suspected at all
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有可能一个非故障进程根本不会被怀疑。
- en: You can be confused because there's chaos but at some point non-faulty processes
    stop being suspected of being bad
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能会感到困惑，因为有混乱，但在某个时候，非故障进程停止被怀疑有问题。
- en: At some point there's at least one non-faulty process that is not suspected
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少有一个非故障进程在某个时候不会被怀疑
- en: You can possibly realize that a strong and fully accurate detector (said to
    be *perfect*) kind of implies that you get a consensus, and since consensus is
    not really doable in a fully asynchronous system model with failures, then there
    are hard limits to things you can detect reliably.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会意识到一个强大且完全准确的检测器（称为*完美*）有点暗示着您会得到共识，而由于在完全异步的系统模型中，即使存在故障，也实际上无法做到共识，因此存在硬性限制，限制了您可以可靠检测的事物。
- en: 'This is often why *semi-synchronous* system models make sense: if you treat
    delays greater than *T* to be a failure, then you can start doing adequate failure
    detection.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是为什么*半同步*系统模型是有意义的：如果您将大于*T*的延迟视为故障，则可以开始进行足够的故障检测。
- en: '[See this slide deck for a decent intro](https://www.inf.ed.ac.uk/teaching/courses/ds/slides1415/failure.pdf)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[查看这张幻灯片了解一个不错的介绍](https://www.inf.ed.ac.uk/teaching/courses/ds/slides1415/failure.pdf)'
- en: CAP Theorem
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CAP 定理
- en: The CAP theorem was for a long while just a conjecture, but has been proven
    in the early 2000s, leading to a lot of eventually consistent databases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CAP 定理曾经只是一个推测，但在21世纪初已经被证明，导致了许多最终一致性数据库。
- en: In A Nutshell
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简而言之
- en: 'There are three properties to a distributed system:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统有三个属性：
- en: '**C**onsistency: any time you write to a system and read back from it, you
    get the value you wrote or a fresher one back.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：每次写入系统并从中读取时，都会得到你写入的值或更新的值。'
- en: '**A**vailability: every request results in a response (including both reads
    and writes)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：每个请求都会有响应（包括读和写）'
- en: '**P**artition tolerance: the network can lose messages'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P** 分区容忍性：网络可以丢失消息'
- en: In theory, you can get a system that is both available and consistent, but only
    under synchronous models on a perfect network. Those don't really exist so in
    practice **P** is always there.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以得到一个既可用又一致的系统，但只在完美网络的同步模型下。这种实际上并不存在，因此在实践中 **P** 总是存在。
- en: What the CAP theorem states is essentially that *given* **P**, you have to choose
    either **A** (keep accepting writes and potentially corrupt data) *or* **C** (stop
    accepting writes to save the data, and go down).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CAP 定理陈述的实质是，*给定* **P**，你必须在**A**（继续接受写入并可能使数据损坏）*或* **C**（停止接受写入以保存数据，并降低可用性）之间进行选择。
- en: Refinements
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 修正
- en: CAP is a bit strict in what you get in practice. Not all partitions in a network
    are equivalent, and not all consistency levels are the same.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: CAP 对实际获得的东西有些严格。网络中并非所有的分区都是等效的，并非所有的一致性级别都是相同的。
- en: Two of the most common approaches to add some flexibility to the CAP theorem
    are the *Yield/Harvest* models and *PACELC*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 添加某些灵活性到 CAP 定理最常见的两种方法是 *Yield/Harvest* 模型和 *PACELC*。
- en: '*Yield/Harvest* essentially says that you can think of the system differently:
    *yield* is your ability to fulfill requests (as in uptime), and *harvest* is the
    fraction of all the potential data you can actually return. Search engines are
    a common example here, where they will increase their *yield* and answer more
    often by reducing their *harvest* when they ignore some search results to respond
    faster if at all.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*Yield/Harvest* 本质上是说你可以以不同的方式思考系统：*yield* 是你履行请求的能力（就像是正常运行时间），而*harvest*
    是你实际上能够返回的所有潜在数据的一部分。搜索引擎在这里是一个常见的例子，当它们忽略一些搜索结果以更快地响应时，它们将通过减少*harvest*来增加*yield*并更频繁地回答。'
- en: '*PACELC* adds the idea that eventually-consistent databases are overly strict.
    In case of network **P**artitioning you have to choose between **A**vailability
    or **C**onsistency, but **E**lse --when the system is running normally--one has
    to choose between **L**atency and **C**onsistency. The idea is that you can decide
    to degrade your consistency for availability (but only when you really need to),
    or you could decide to always forego consistency because you gotta go fast.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*PACELC* 添加了这样一个观点，即最终一致性数据库过于严格。在网络**P**分区的情况下，你必须在**A**可用性和**C**一致性之间进行选择，但是--当系统正常运行时--你必须在**L**延迟和**C**一致性之间进行选择。这个想法是你可以选择降低一致性以换取可用性（但只有在真正需要时），或者你可以选择永远放弃一致性，因为你必须尽快完成。'
- en: It is important to note that you *cannot* beat the CAP theorem (as long as you
    respect the models under which it was proven), and anyone claiming to do so is
    often a snake oil salesman.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，你*不能*打败 CAP 定理（只要你遵循它被证明的模型），任何声称可以做到的人通常都是江湖骗子。
- en: Resources
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 资源
- en: There's been countless rehashes of the CAP theorem and various discussions over
    the years; the results are mathematically proven even if many keep trying to make
    the argument that they're so reliable it doesn't matter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来已经有无数次对 CAP 定理进行了重新讨论，尽管许多人试图辩称它们是如此可靠以至于无关紧要，但结果在数学上是被证明的。
- en: Message Passing Definitions
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消息传递定义
- en: 'Messages can be sent zero or more times, in various orderings. Some terms are
    introduced to define what they are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以零次或多次发送，顺序各异。有些术语用于定义它们是什么：
- en: '*unicast* means that the message is sent to one entity only'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*unicast* 表示消息只发送给一个实体'
- en: '*anycast* means that the message is sent to any valid entity'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*anycast* 表示消息发送给任何有效实体'
- en: '*broadcast* means that a message is sent to all valid entities'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*broadcast* 表示消息发送给所有有效实体'
- en: '*atomic broadcast* or *total order broadcast* means that all the non-faulty
    actors in a system receive the same messages in the same order, whichever that
    order is'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*atomic broadcast* 或 *total order broadcast* 意味着系统中的所有非故障参与者都以相同的顺序接收相同的消息，无论该顺序是什么'
- en: '*gossip* stands for the family of protocols where messages are forwarded between
    peers with the hope that eventually everyone gets all the messages'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*gossip* 代表了一系列协议，其中消息在对等体之间转发，希望最终每个人都能得到所有消息'
- en: '*at least once delivery* means that each message will be sent once or more;
    listeners are to expect to see all messages, but possibly more than once'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*at least once delivery* 意味着每个消息将被发送一次或多次；听众可以期望看到所有消息，但可能会看到多次'
- en: '*at most once delivery* means that each sender will only send the message one
    time. It''s possible that listeners never see it.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*at most once delivery* 意味着每个发送者只会发送一次消息。听众可能永远不会看到它。'
- en: '*exactly once delivery* means that each message is guaranteed to be sent and
    seen only once. This is a nice theoretical objective but quite impossible in real
    systems. It ends up being simulated through other means (combining *atomic broadcast*
    with specific flags and ordering guarantees, for example)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*exactly once delivery* 意味着每个消息都保证只发送和看到一次。这是一个很好的理论目标，但在实际系统中几乎是不可能的。最终会通过其他手段进行模拟（例如将*原子广播*与特定的标志和排序保证结合起来）'
- en: 'Regarding ordering:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关于排序：
- en: '*total order* means that all messages have just one strict ordering and way
    to compare them, much like 3 is always greater than 2.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*total order* 意味着所有消息都有一个严格的排序和比较方式，就像3永远大于2一样。'
- en: '*partial order* means that some messages can compare with some messages, but
    not necessarily all of them. For example, I could decide that all the updates
    to the key `k1` can be in a total order regarding each other, but independent
    from updates to the key `k2`. There is therefore a *partial* order between all
    updates across all keys, since `k1` updates bear no information relative to the
    `k2` updates.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*偏序*意味着一些消息可以与一些消息进行比较，但不一定是所有消息。例如，我可以决定所有对键`k1`的更新可以在彼此之间有一个关于每个其他的总序，但独立于对键`k2`的更新。因此，在所有键的所有更新之间存在一个*部分*顺序，因为`k1`的更新与`k2`的更新之间没有相对的信息。'
- en: '*causal order* means that all messages that depend on other messages are received
    after these (you can''t learn of a user''s avatar before you learn about that
    user). It is a specific type of partial order.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*因果顺序*意味着所有依赖其他消息的消息都是在这些消息之后收到的（你不可能在了解用户之前就了解到用户的头像）。这是一种特定类型的偏序。'
- en: There isn't a "best" ordering, each provides different possibilities and comes
    with different costs, optimizations, and related failure modes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 没有“最佳”顺序，每种顺序都提供不同的可能性，并带有不同的成本、优化和相关故障模式。
- en: Idempotence
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 幂等性
- en: Idempotence is important enough to warrant its own entry. Idempotence means
    that when messages are seen more than once, resent or replayed, they don't impact
    the system differently than if they were sent just once.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性非常重要，值得有专门的条目。幂等性意味着当消息被多次看到、重发或重播时，它们不会对系统产生与只发送一次相同的不同影响。
- en: Common strategies is for each message to be able to refer to previously seen
    messages so that you define an ordering that will prevent replaying older messages,
    setting unique IDs (such as transaction IDs) coupled with a store that will prevent
    replaying transactions, and so on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 常见策略是每个消息都能够引用先前看到的消息，以便定义一个防止重放旧消息的顺序，设置唯一ID（如事务ID）并与可以防止重放事务的存储耦合，等等。
- en: See [Idempotence is not a medical condition](https://queue.acm.org/detail.cfm?id=2187821)
    for a great read on it, with various related strategies.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有关它的精彩阅读，请参阅[幂等性不是一种医学状况](https://queue.acm.org/detail.cfm?id=2187821)，以及各种相关策略。
- en: State Machine Replication
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态机复制
- en: This is a theoretical model by which, given the same sequences of states and
    the same operations applied to them (disregarding all kinds of non-determinism),
    all state machines will end up with the same result.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个理论模型，通过它，给定相同的状态序列和施加于它们的相同操作（忽略所有类型的不确定性），所有状态机最终都会得到相同的结果。
- en: This model ends up being critical to most reliable systems out there, which
    tend to all try to replay all events to all subsystems in the same order, ensuring
    predictable data sets in all places.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型最终对大多数可靠系统至关重要，这些系统往往尝试以相同的顺序向所有子系统重播所有事件，确保所有地方都有可预测的数据集。
- en: This is generally done by picking a leader; all writes are done through the
    leader, and all the followers get a consistent replicated state of the system,
    allowing them to eventually become leaders or to fan-out their state to other
    actors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常是通过选择一个领导者来完成的；所有写入都通过领导者完成，而所有的跟随者获得系统的一致复制状态，使它们最终可以成为领导者或将其状态扩展到其他参与者。
- en: State-Based Replication
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于状态的复制
- en: State-based replication can be conceptually simpler to state-machine replication,
    with the idea that if you only replicate the state, you get the state at the end!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基于状态的复制在概念上可能比状态机复制更简单，因为如果你只复制状态，你最终得到的就是状态！
- en: The problem is that it is extremely hard to make this fast and efficient. If
    your state is terabytes large, you don't want to re-send it on every operation.
    Common approaches will include splitting, hashing, and bucketing of data to detect
    changes and only send the changed bits (think of `rsync`), [merkle trees](https://en.wikipedia.org/wiki/Merkle_tree)
    to detect changes, or the idea of a `patch` to source code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于要使其快速高效非常困难。如果你的状态有几千兆字节大，你不想在每次操作时重新发送它。常见的方法包括拆分、哈希和数据分桶以检测更改并仅发送更改的位（类似于`rsync`），[默克尔树](https://en.wikipedia.org/wiki/Merkle_tree)以检测更改，或者对源代码进行`patch`的想法。
- en: Practical Matters
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际问题
- en: Here are a bunch of resources worth digging into for various system design elements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些值得深入研究的各种系统设计要素的资源。
- en: End-to-End Argument in System Design
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 系统设计中的端到端论点
- en: 'Foundational practical aspect of system design for distributed systems:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统的系统设计基础实践方面：
- en: a message that is sent is not a message that is necessarily received by the
    other party
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送的消息未必是对方一定会收到的消息
- en: a message that is received by the other party is not necessarily a message that
    is actually read by the other party
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对方收到的消息未必是对方实际阅读的消息
- en: a message that is read by the other party is not necessarily a message that
    has been acted on by the other party
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对方阅读的消息未必是对方已经执行的消息
- en: The conclusion is that if you want anything to be reliable, you *need* an end-to-end
    acknowledgement, usually written by the application layer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，如果你希望任何东西都是可靠的，*需要*一种端到端的确认，通常由应用层编写。
- en: These ideas are behind the design of TCP as a protocol, but the authors also
    note that it wouldn't be sufficient to leave it at the protocol, the application
    layer must be involved.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些思想是TCP作为协议设计的基础，但作者也指出，仅将其保留在协议中是不够的，必须涉及应用层。
- en: Fallacies of Distributed Computing
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分布式计算的谬论
- en: 'The fallacies are:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 谬论包括：
- en: The network is reliable
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是可靠的
- en: Latency is zero
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟为零
- en: Bandwidth is infinite
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宽是无限的
- en: The network is secure
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是安全的
- en: Topology doesn't change
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑结构不会改变
- en: There is one administrator
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个管理员
- en: Transport cost is zero
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输成本为零
- en: The network is homogeneous
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是同质的
- en: Partial explanations on the [Wiki page](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)
    or full ones in [the paper](https://www.researchgate.net/publication/322500050_Fallacies_of_Distributed_Computing_Explained).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[维基页面](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)上有部分解释，或者在[论文](https://www.researchgate.net/publication/322500050_Fallacies_of_Distributed_Computing_Explained)中有完整的解释。
- en: Common Practical Failure Modes
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见的实际故障模式
- en: In practice, when you switch from Computer Science to Engineering, the types
    of faults you will find are a bit more varied, but can map to any of the theoretical
    models.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当你从计算机科学转向工程时，你会发现故障类型更加多样，但可以映射到任何理论模型。
- en: This section is an informal list of common sources of issues in a system. See
    also [the CAP theorem checklist](https://ferd.ca/beating-the-cap-theorem-checklist.html)
    for other common cases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是系统中常见问题的非正式列表。还可以参考[CAP理论检查清单](https://ferd.ca/beating-the-cap-theorem-checklist.html)以了解其他常见情况。
- en: Netsplit
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网络分裂
- en: Some nodes can talk to each other, but some nodes are unreachable to others.
    A common example is that a US-based network can communicate fine internally, and
    so could a EU-based network, but both would be unable to speak to each-other
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一些节点可以相互通信，但有些节点对其他节点不可达。一个常见的例子是，基于美国的网络可以在内部正常通信，欧盟的网络也可以，但两者都无法彼此通信。
- en: Asymmetric Netsplit
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 非对称网络分裂
- en: Communication between groups of nodes is not symmetric. For example, imagine
    that the US network can send messages to the EU network, but the EU network cannot
    respond back.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 节点组之间的通信不对称。例如，想象一下，美国网络可以向欧盟网络发送消息，但欧盟网络无法回复。
- en: This is a rarer mode when using TCP (although it has happened before), and a
    potentially common one when using UDP.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用TCP时这种情况比较罕见（尽管以前发生过），而使用UDP时这种情况可能比较常见。
- en: Split Brain
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分裂大脑
- en: The way a lot of systems deal with failures is to keep a majority going. A split
    brain is what happens when both sides of a netsplit think they are the leader,
    and starts making conflicting decisions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 很多系统处理故障的方式是保持大多数运行。当网络分裂的两侧都认为自己是领导者并开始做出冲突决策时，就会发生分裂大脑。
- en: Timeouts
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 超时
- en: Timeouts are particularly tricky because they are non-deterministic. They can
    only be *observed* from one end, and you never know if a timeout that is ultimately
    interpreted as a failure was actually a failure, or just a delay due to networking,
    hardware, or GC pauses.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 超时特别棘手，因为它们是非确定性的。它们只能从一端*观察*，你永远不知道超时是否最终被解释为失败，或者只是由于网络、硬件或GC暂停而延迟了。
- en: 'There are times where retransmissions are not safe if the message has already
    been seen (i.e. it is not idempotent), and timeouts essentially make it impossible
    to know if retransmission is safe to try: was the message acted on, dropped, or
    is it still in transit or in a buffer somewhere?'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果消息已经被看到（即它不是幂等的），重新发送是不安全的，而超时基本上使得不可能知道重新发送是否安全尝试：消息是否被处理、丢弃或仍在传输或缓冲区中？
- en: Missing Messages due to Ordering
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 由于顺序问题导致的消息丢失
- en: 'Generally, using TCP and crashes will tend to mean that few messages get missed
    across systems, but frequent cases can include:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用TCP和崩溃会导致系统之间丢失的消息很少，但频繁出现的情况可能包括：
- en: The node has gone down (or the software crashed) for a few seconds during which
    it missed a message that won't be repeated
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点已经停止运行（或软件崩溃）几秒钟，期间错过了一个不会重复的消息
- en: The updates are received transitively across various nodes. For example, a message
    published by service `A` on a bus (whether Kafka or RMQ) can end up read, transformed
    or acted on and re-published by service `B`, and there is a possibility that service
    `C` will read `B`'s update before `A`'s, causing issues in causality
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新在各个节点之间通过传递接收。例如，由服务`A`在总线上发布的消息（无论是Kafka还是RMQ）可能会被服务`B`读取、转换或执行，并且有可能在服务`C`读取`A`的更新之前读取`B`的更新，从而在因果关系上造成问题
- en: Clock Drift
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 时钟漂移
- en: Not all clocks on all systems are synchronized properly (even using [NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol))
    and will go at different speeds.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有系统上的所有时钟都同步正确（即使使用[NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol)），并且会以不同的速度运行。
- en: Using a timestamp to sort through events is almost guaranteed to be a source
    of bugs, even moreso if the timestamps come from multiple computers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时间戳对事件进行排序几乎肯定会是错误的来源，尤其是如果时间戳来自多台计算机。
- en: The Client is Part of the System
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 客户端是系统的一部分
- en: A very common pitfall is to forget that the client that participates in a distributed
    system is part of it. Consistency on the server-side will not necessarily be worth
    much if the client can't make sense of the events or data it receives.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的陷阱是忘记参与分布式系统的客户端是其一部分。如果客户端无法理解收到的事件或数据，那么服务器端的一致性并不一定有多大价值。
- en: This is particularly insidious for database clients that do a non-idempotent
    transactions, time out, and have no way to know if they can try it again.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于执行非幂等事务、超时并且无法知道是否可以重试的数据库客户端，这种情况特别隐蔽。
- en: Restoring from multiple backups
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从多个备份中恢复
- en: A single backup is kind of easy to handle. Multiple backups run into a problem
    called [consistent cuts](https://www.cs.cornell.edu/courses/cs5414/2010fa/publications/BM93.pdf)
    ([high level view](https://blog.mattchung.me/2021/02/13/distributed-system-snapshots-consistent-vs-inconsistent-cuts/))
    and distributed snapshots, which means that not all the backups are taken at the
    same time, and this introduces inconsistencies that can be construed as corrupting
    data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 单个备份相对容易处理。多个备份会遇到一个叫做[一致性截取](https://www.cs.cornell.edu/courses/cs5414/2010fa/publications/BM93.pdf)（[高级视图](https://blog.mattchung.me/2021/02/13/distributed-system-snapshots-consistent-vs-inconsistent-cuts/)）的问题，这意味着并非所有备份都在同一时间被拍摄，这会引入可以被解释为损坏数据的不一致性。
- en: The good news is there's no great solution and everyone suffers the same.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是没有很好的解决方案，每个人都遭受同样的痛苦。
- en: Consistency Models
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一致性模型
- en: There are dozens different levels of consistency, all of which are documented
    on [Wikipedia](https://en.wikipedia.org/wiki/Consistency_model), by [Peter Bailis'
    paper on the topic](http://www.vldb.org/pvldb/vol7/p181-bailis.pdf), or overviewed
    by [Kyle Kingsbury post on them](https://aphyr.com/posts/313-strong-consistency-models)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有数十种不同级别的一致性，所有这些都在[Wikipedia](https://en.wikipedia.org/wiki/Consistency_model)、[彼得·贝利斯关于该主题的论文](http://www.vldb.org/pvldb/vol7/p181-bailis.pdf)或[凯尔·金斯伯里的文章中进行了记录](https://aphyr.com/posts/313-strong-consistency-models)。
- en: '*Linearizability* means each operation appears atomic and could not have been
    impacted by another one, as if they all ran just one at a time. The order is known
    and deterministic, and a read that started after a given write had started will
    be able to see that data.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可线性化* 意味着每个操作都表现为原子操作，并且不可能受到另一个操作的影响，就像它们一次只执行一个一样。顺序是已知且确定的，而且在给定写入开始后开始的读取将能够查看该数据。'
- en: '*Serializability* means that while all operations appear to be atomic, it makes
    no guarantee about *which* order they would have happened in. It means that some
    operations *might* start after another one and complete before it, and as long
    as the isolation is well-maintained, that isn''t a problem.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可序列化* 意味着虽然所有操作都表现为原子操作，但不保证它们会以*哪种*顺序发生。这意味着一些操作 *可能* 在另一个操作之后开始并在其之前完成，只要隔离得到良好维护，这并不是问题。'
- en: '*Sequential consistency* means that even if operations might have taken place
    out-of-order, they will appear as if they all happened in order'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*顺序一致性* 意味着即使操作可能以无序方式发生，它们也将呈现为所有操作都按顺序发生的情况'
- en: '*Causal Consistency* means that only operations that have a logical dependency
    on each other need to be ordered amongst each other'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*因果一致性* 意味着仅需要对彼此具有逻辑依赖关系的操作进行排序'
- en: '*Read-committed* consistency means that any operation that has been committed
    is available for further reads in the system'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读取已提交* 一致性意味着已提交的任何操作都可在系统中进一步读取'
- en: '*Repeatable reads* means that within a transaction, reading the same value
    multiple times always yields the same result'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可重复读* 意味着在事务中，多次读取相同的值始终产生相同的结果'
- en: '*Read-your-writes* consistency means that any write you have completed must
    be readable *by the same client* subsequently'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读取你的写入* 一致性意味着你已完成的任何写入后续必须可被*同一客户端*读取'
- en: '*Eventual Consistency* is a kind of special family of consistency measures
    that say that the system can be inconsistent as long as it eventually becomes
    consistent again. *Causal consistency* is an example of eventual consistency.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最终一致性* 是一种特殊的一致性度量家族，它表明系统在最终变得一致之前可以不一致。*因果一致性* 就是最终一致性的一个例子。'
- en: '*Strong Eventual Consistency* is like *eventual consistency* but demands that
    no conflicts can happen between concurrent updates. This is usually the land of
    *CRDTs*.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强一致性* 类似于*最终一致性*，但要求并发更新之间不会发生冲突。这通常是*CRDTs*的领域。'
- en: Note that while these definitions have clear semantics that academics tend to
    respect, they are not adopted uniformly or respected in various projects' or vendors'
    documentation in the industry.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然这些定义在学术界有清晰的语义，学者们倾向于尊重这些语义，但在工业界的各种项目或供应商文档中并不统一采用或受到尊重。
- en: Database Transaction Scopes
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据库事务范围
- en: By default, most people assume database transactions are linearizable, and they
    tend not to be because that's way too slow as a default.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，大多数人认为数据库事务是可线性化的，但它们通常不是，因为作为默认选项的速度太慢了。
- en: Each database might have different semantics, so the following links may cover
    the most major ones.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库可能有不同的语义，因此以下链接可能涵盖最主要的内容。
- en: Be aware that while the PostgreSQL documentation is likely the clearest and
    most easy to understand one to introduce the topic, various vendors can assign
    different meanings to the same standard transaction scopes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然 PostgreSQL 文档可能是介绍该主题最清晰且最易于理解的文档，但各种供应商可能会为相同的标准事务范围赋予不同的含义。
- en: Logical Clocks
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逻辑时钟
- en: Those are data structures that allow to create either total or partial orderings
    between messages or state transitions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是允许在消息或状态转换之间创建全局或部分排序的数据结构。
- en: 'Most common ones are:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是：
- en: CRDTs
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CRDTs
- en: CRDTs essentially are data structures that restrict operations that can be done
    such that they can never conflict, no matter which order they are done in or how
    concurrently this takes place.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: CRDTs本质上是限制可以执行的操作的数据结构，以便无论以何种顺序或并发方式执行，它们都永远不会发生冲突。
- en: Think of it as the specification on how someone would write a distributed redis
    that was never wrong, but only left maths behind.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为对某人如何编写一个永远不会出错，但只是留下了数学的分布式 redis 的规范。
- en: This is still an active area of research and countless papers and variations
    are always coming out.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一个活跃的研究领域，而且还会不断涌现出无数的论文和变体。
- en: Other interesting material
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他有趣的材料
- en: The bible for putting all of these views together is [Designing Data-Intensive
    Applications](https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/)
    by Martin Kleppmann. Be advised however that everyone I know who absolutely loves
    this book are people who had a good foundation in distributed systems from reading
    a bunch of papers, and greatly appreciated having it all put in one place. Most
    people I've seen read it in book clubs with the aim get better at distributed
    systems still found it challenging and confusing at times, and benefitted from
    having someone around to whom they could ask questions in order to bridge some
    gaps. It is still the clearest source I can imagine for everything in one place.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些观点汇总起来的圣经是[Martin Kleppmann的《设计数据密集型应用》](https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/)。但请注意，我认识的所有热爱这本书的人都是那些通过阅读大量论文对分布式系统有了良好基础的人，并且非常感谢将所有内容放在一个地方的好处。我见过的大多数人都是在读书俱乐部中读这本书，目的是更好地理解分布式系统，但有时仍然觉得有挑战和困惑，并受益于有人在身边向他们提问以弥合一些差距。对于所有内容放在一个地方来说，这仍然是我能想象到的最清晰的来源。
