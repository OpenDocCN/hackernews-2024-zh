<!--yml

类别：未分类

日期：2024-05-27 14:34:45

-->

# __VA_OPT__ 小细节

> 来源：[https://www.corsix.org/content/va-opt-minutiae](https://www.corsix.org/content/va-opt-minutiae)

假设我们在写C代码，并且想要定义一个带有换行符的`printf`宏。我们可以从以下内容开始：

```
#define printfln(fstr, ...) \
  printf(fstr "\n", __VA_ARGS__) 
```

目前为止都很好；我们可以写`printfln("1+1 is %d", 1+1)`，它会打印`1 + 1 is 2`，然后换行。然而，像`printfln("Hello")`这样的简单情况会导致语法错误，因为这个宏展开为`printf("Hello" "\n",)`，由于尾随逗号而无效。

**非标准解决方案**

一种传统的解决方案是依赖于非标准语言扩展，通过在`,`和`__VA_ARGS__`之间插入`##`具有*特殊效果*：

```
#define printfln(fstr, ...) \
  printf(fstr "\n", ## __VA_ARGS__) 
```

使用此功能，`printfln("1+1 is %d", 1+1)`和`printfln("Hello")`都能正常工作。然而，将两者结合成`printfln("Wrote %d chars", printfln("Hello"))`之类的内容会导致一个神秘的错误。要找出原因，我们需要仔细研究这种非标准语言扩展具有的*特殊效果*。[GNU C预处理器文档中关于可变参数宏的说明](https://gcc.gnu.org/onlinedocs/gcc-13.2.0/cpp/Variadic-Macros.html)说：

> 当逗号和可变参数之间放置`##`标记粘合操作符时，具有特殊含义。如果您写入[...]并且省略了可变参数[...]，那么`##`前的逗号将被删除。如果传递空参数，则不会发生这种情况，如果`##`之前的标记不是逗号，则也不会发生这种情况。

与此同时，[GCC文档中关于可变参数宏的说明](https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Variadic-Macros.html)说：

> 如果省略或空置变量参数，则`##`运算符会导致预处理器在其前的逗号被移除。如果在宏调用中提供了一些变量参数，GNU CPP不会抱怨粘贴操作，而是将变量参数放置在逗号后面。与任何其他粘贴的宏参数一样，这些参数不会被宏扩展。

第二篇文档的最后一句告诉我们正在发生的事情：宏参数通常在替换之前被扩展，但在作为`#`或`##`操作数使用的宏参数中，*这并不*发生。在任一情况下，在执行替换之后，结果令牌会被重新扫描以进行更多扩展，尽管在此重新扫描期间原始宏已被停用。在扩展之前和在重新扫描期间进行扩展的唯一主要可观察差异在于前者中原始宏是活跃的，而在后者中是停用的。因此，`printfln("Wrote %d chars", printfln("Hello"))`展开为`printf("Wrote %d chars" "\n", printfln("Hello"))`，内部的`printfln`不会被扩展，编译器随后尝试解析为不存在的*函数*`printfln`。

这两篇文档中关于变量参数为空时的行为是相互矛盾的（如`printfln("Hello",)`）。实际上，第1篇文档是正确的；如果变量参数为空，则保留逗号。

第1篇文档中关于`##`之前的令牌不是逗号时也不会发生的短语是有趣的，因为事实证明这是一个稍微动态的特性：逗号删除可以发生在像`, ## x ## __VA_ARGS__`这样的情况下，前提是`x`扩展为空。当`x`扩展为空时，Clang也会删除`, x ## __VA_ARGS__`中的逗号。如果紧跟着更多的粘贴，情况似乎也会变得有趣。例如：

| `#define F(x, ...)`如 | `F()` | `F(1)` | `F(,)` | `F(1,)` | `F(1,2)` |
| --- | --- | --- | --- | --- | --- |
| `,##__VA_ARGS__` | 空 | 空 | `,` | `,` | `,2` |
| `,##__VA_ARGS__ x` | 空 | `1` | `,` | `,1` | `,2 1` |
| `,##__VA_ARGS__##x` | `,` | 错误 | `,` | 错误 | 错误† 或 `,21`‡ |
| `,##x##__VA_ARGS__` | 空 | 错误 | `,` | 错误 | 错误 |
| `,x##__VA_ARGS__` | `,`† 或 空 ‡ | `,1` | `,` | `,1` | `,12` |

† 根据gcc 13.2。

‡ 根据clang 17.0.1。

在gcc和clang不同的情况下，谁能说哪个是正确的？毕竟，并没有一个标准来记录非标准语言扩展的期望行为。

**进入`__VA_OPT__`**

与标准化这一混乱不同，[C](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3033.htm)和[C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0306r4.html)语言采用了一种不同的解决方案，即`__VA_OPT__`。使用`__VA_OPT__`，我们的激励示例看起来像这样：

```
#define printfln(fstr, ...) \
  printf(fstr "\n" __VA_OPT__(,) __VA_ARGS__) 
```

在这种情况下，如果变量参数不存在或为空或在宏扩展后变为空，则`__VA_OPT__(,)`扩展为空，否则扩展为`,`。这里没有进行令牌粘贴，因此`printfln("Wrote %d chars", printfln("Hello"))`现在可以正常工作。另一个行为上的区别是看起来奇怪的`printfln("Hello",)`现在扩展为有效的`printf("Hello" "\n")`，就像在`#define EMPTY /*nothing*/`的上下文中一样。

标准并未就此止步；`__VA_OPT__`中可以包含不仅仅是`,`。允许任何`(`-`)`平衡的令牌序列，并且甚至可以访问宏调用的参数，因此例如以下是有效的：

```
#define M(x, ...) (0 __VA_OPT__(-(x)) ) 
```

然后`M(1)`扩展为`(0)`，而`M(1,2)`扩展为`(0 - (1))`。

**空格呢？**

编译器在`__VA_OPT(`之后或匹配`)`之前的空格行为上存在分歧。考虑：

```
#define TILDAS(...) ~__VA_OPT__( ~ )~
#define S2(x) #x
#define S1(x) S2(x)
const char* s = S1(TILDAS());
const char* sa = S1(TILDAS(a)); 
```

观察到的结果是：

|  | gcc 13.2 | clang 17.0.1 |
| --- | --- | --- |
| s | `"~~"` | `"~ ~"` |
| sa | `"~~~"` | `"~ ~ ~"` |

一种解释是gcc是正确的，基于标准中的这段话：（[N3096](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3096.pdf) 6.10.4.1¶7）

> 对于一个 va-opt-replacement 的预处理标记序列[...]，它由包含的 pp-tokens 的扩展结果作为当前函数样式宏的替换列表，**在移除占位符标记之前**，重新扫描和进一步替换。

结合前面关于替换列表的段落：([N3096](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3096.pdf) 6.10.4¶7)

> [...] 任何位于预处理标记的替换列表之前或之后的空白字符都不被视为任何形式宏的替换列表的一部分。

**`__VA_OPT__()` 展开为什么？**

简短回答应该是 *什么也不是*，基于对其扩展规则的解读：

1.  如果可变参数不存在、为空或在宏展开后变为空，则 `__VA_OPT__()` 的扩展是一个单一的占位符标记。

1.  否则，如果作为 `##` 的操作数使用，`__VA_OPT__()` 的扩展是一个单一的占位符标记（因为空展开在这种情况下变成了占位符标记）。

1.  否则，`__VA_OPT__()` 的展开是空的（尽管单个占位符标记同样有效，因为它将在适当时消失）。

因此，`#__VA_OPT__()` 成为一种编写 `""` 的混淆方式。同时，`__VA_OPT__()` 作为 `##` 的操作数可用于强制 *另一个* 操作数在 `##` 上下文中。例如，`, ## __VA_ARGS__` 的不良行为可以通过以下方式复制：

```
#define printfln(fstr, ...) \
  printf(fstr "\n" __VA_OPT__(,) __VA_OPT__() ## __VA_ARGS__) 
```

如果 `__VA_OPT__()` 展开为空，无论可变参数是否在宏展开后为空，似乎都可以将其优化掉。不过有一个特殊情况：确定可变参数在宏展开后是否为空需要对其进行宏展开，并且非标准的 `__COUNTER__` 宏的宏展开会产生可见的副作用。考虑：

```
#define EMPTY_VA_OPT(...) __VA_OPT__()
int x = __COUNTER__;
EMPTY_VA_OPT(__COUNTER__)
int y = __COUNTER__;
return y - x; 
```

对于上述，gcc 13.2 返回 2，而 clang 17.0.1 返回 1，表明 clang 优化掉了 `__VA_OPT__()`。

**标记粘贴和 `__VA_OPT__`**

标准特别指出，`__VA_OPT__` 的扩展可以包含占位符标记：([N3096](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3096.pdf) 6.10.4.1¶7，重点在我)

> 对于一个 va-opt-replacement 的预处理标记序列[...]，它由包含的 pp-tokens 的扩展结果作为当前函数样式宏的替换列表，**在移除占位符标记之前**，重新扫描和进一步替换。

这些占位符标记最初是标准所想象的虚构物，以提供对 `##` 语义的简洁描述：

+   `##` 的操作数始终至少生成一个标记。如果操作数产生零个标记，它会产生一个单一的占位符标记。

+   如果 `##` 的一个操作数是占位符标记，则 `##` 的结果是另一个操作数。

+   占位符标记在 `##` 处理之后以及重新扫描之前会被移除。

在 `__VA_OPT__` 之前，可以忽略这个虚构，并且通过周围对 `##` 评估的谨慎规则来[实现预处理算法](https://www.spinellis.gr/blog/20060626/)，而不是生成和稍后移除位置标记令牌。使用 `__VA_OPT__` 维护这个虚构变得更加困难。考虑：

```
#define G(x, y, z, ...) 1 ## __VA_OPT__(x y ## y z) ## 5 
```

然后 `G(,,)` 扩展为单个标记 `15`，而 `G(2,3,4,-)` 扩展为三个标记 `12` `33` `45`。如果 `y` 是空的，那么内部的 `y ## y` 应产生一个位置标记，然后事情就变得有趣起来：

| 扩展为 | 结果 | 注意事项 |
| --- | --- | --- |
| `G(2,,4,-)` | `12` `45` | `__VA_OPT__` 扩展为 `2``4`。 |
| `G( ,,4,-)` | `1` `45` | 位置标记阻止了合并到 `145`。 |
| `G(2,, ,-)` | `12` `5` | 位置标记阻止了合并到 `125`。 |
| `G( ,, ,-)` | `1` `5`† 或 `15`‡ | 正确的结果是合并后的 `15`。 |

† 根据 gcc 13.2 的说法。

‡ 根据 clang 17.0.1 的说法。

另一个有趣的观察是，在 `__VA_OPT__` 内部的宏参数被宏展开，即使 `__VA_OPT__` 本身是 `##` 的操作数。考虑：

```
#define H1(...) x ##            __VA_ARGS__
#define H2(...) x ## __VA_OPT__(__VA_ARGS__) 
```

然后 `H1(__LINE__)` 扩展为 `x__LINE__`，而 `H2(__LINE__)` 扩展为类似于 `x3` 的内容。

**进一步阅读**

+   [P1042R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1042r1.html) 几年前微调了 `__VA_OPT__` 的语义。

+   `__VA_OPT__` 可以用于[递归宏](https://www.scs.stanford.edu/~dm/blog/va-opt.html)（滥用）。
