["```\n// Assume server_fd is already initialized to start accepting clients. void serve(int server_fd) {\n  while (true) {\n  int client_fd = accept(server_fd, NULL, NULL);    char buffer[2048];    while (true) {\n  ssize_t len = read(client_fd, buffer, sizeof(buffer));\n  if (len == -1)\n  break;    write(client_fd, buffer, len);\n  }    close(client_fd);\n  } } \n```", "```\nvoid serve_client(int client_fd) {\n  char buffer[2048];    while (true) {\n  ssize_t len = read(client_fd, buffer, sizeof(buffer));\n  if (len == -1)\n  break;    write(client_fd, buffer, len);\n  }    close(client_fd); }   void serve(int server_fd) {\n  while (true) {\n  int client_fd = accept(server_fd, NULL, NULL);\n  run_thread(serve_client, client_fd);\n  } } \n```", "```\n$ cat /proc/sys/kernel/threads-max 63704   # Threads in linux are light weight processes (LWP). $ cat /proc/sys/kernel/pid_max 131072   # Maximum number of VMAs a process can own. $ cat /proc/sys/vm/max_map_count 65530   # Each of these can be set by simply writing to the file: $ echo 2000000 > /proc/sys/kernel/threads-max $ echo 2000000 > /proc/sys/kernel/pid_max $ echo 2000000 > /proc/sys/vm/max_map_count \n```", "```\nstruct client {\n  int fd;  char buffer[2048]; // Not allocated dynamically for brevity.\n  ssize_t offset; // -1 when in reading state, otherwise the offset in buffer to write.\n  ssize_t length; // The length left to write (only useful when in writing state). };   void set_nonblock(int fd) {\n  // Ignore errors for brevity.\n  fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK); }   void serve(int server_fd) {\n  set_nonblock(server_fd);    struct client clients[64]; // Maximum 64 concurrent clients.\n  int num_clients = 0;    while (true) {\n  if (num_clients < ARRAY_SIZE(clients)) {\n  int client_fd = accept(server_fd, NULL, NULL);\n  if (client_fd != -1) {\n  set_nonblock(client_fd);\n clients[num_clients].fd = client_fd; clients[num_clients].offset = -1;\n num_clients++;\n  }\n  }    for (int i = 0; i < num_clients; i++) {\n  struct client* client = &clients[i];\n  bool is_reading = client->offset == -1;    ssize_t result;  if (is_reading) {\n result = read(client->fd, client->buffer, sizeof(client->buffer));\n  } else {\n result = write(client->fd, client->buffer + client->offset, client->length);\n  }    if (result != -1) {\n  if (is_reading) {\n client->offset = 0; // Move to writing state.\n client->length = result;  } else {\n client->length -= result;    if (client->length == 0) {\n client->offset = -1; // Move to reading state.\n  } else {\n client->offset += result;  }\n  }\n  } else if (errno != EWOULDBLOCK) {\n  close(client->fd);\n num_clients--;\n  memcpy(client, &clients[num_clients], sizeof(*client));\n i--; // Don't skip the moved client.\n  }\n  }\n  } } \n```", "```\n$ man 2 select   ...   select() allows a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become \"ready\" for some class of I/O operation (e.g., input possible). A file descriptor is considered ready if it is possible to perform a corresponding I/O operation (e.g., read(2), or a sufficiently small write(2)) without blocking.   select() can monitor only file descriptors numbers that are less than FD_SETSIZE; poll(2) and epoll(7) do not have this limitation. See BUGS.   ... \n```", "```\nwhile should_continue_running():\n ready_fds = poll_fds() # Implemented using any of the async APIs we talked about.\n events = fds_to_events(ready_fds)\n  while event := events.pop():\n event.callback() \n```", "```\nint uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int r;   // ...    while (r != 0 && loop->stop_flag == 0) {   // ...    uv__run_pending(loop);\n  uv__run_idle(loop);\n  uv__run_prepare(loop);   // ...    uv__io_poll(loop, timeout);   // ...   r = uv__loop_alive(loop);\n  }   // ...    return r; } \n```", "```\nstatic void uv__run_pending(uv_loop_t* loop) {\n  struct uv__queue* q;  struct uv__queue pq; uv__io_t* w;    uv__queue_move(&loop->pending_queue, &pq);    while (!uv__queue_empty(&pq)) {\n q = uv__queue_head(&pq);\n  uv__queue_remove(q);\n  uv__queue_init(q);\n w = uv__queue_data(q, uv__io_t, pending_queue);\n w->cb(loop, w, POLLOUT);\n  } } \n```", "```\nstruct context {\n  char buffer[2048];\n  size_t offset;  size_t length; };   void on_write(loop_t* loop, struct context* ctx, int client_fd, ssize_t written) {\n  if (written == -1) {\n  // Error, stop.\n  free(ctx);\n  return;\n  }   ctx->offset += written;    if (ctx->offset < ctx->length) {\n  char* buf = ctx->buffer + ctx->offset;\n  size_t len = ctx->length - ctx->offset;\n  register_write(loop, ctx, client_fd, buf, len, on_write);\n  } else {\n  register_read(loop, ctx, client_fd, on_read);\n  } }   void on_read(loop_t* loop, struct context* ctx, int client_fd, ssize_t read) {\n  if (read == -1) {\n  // Error, stop.\n  free(ctx);\n  return;\n  }   ctx->offset = 0;\n ctx->length = read;    register_write(loop, ctx, client_fd, ctx->buffer, read, on_write); }   void on_accept(loop_t* loop, void* unused, int server_fd, int client_fd) {\n  struct context* ctx = malloc(sizeof(*ctx));\n  register_read(loop, ctx, client_fd, ctx->buffer, sizeof(ctx->buffer), on_read);\n  register_accept(loop, NULL, server_fd, on_accept); }   void serve(loop_t* loop, int server_fd) {\n  register_accept(loop, NULL, server_fd, on_accept);\n  run_event_loop(loop); } \n```", "```\ndef task_0():\n  while True:\n  print('0')   def task_1():\n  while True:\n  print('1')   run_all([task_0, task_1]) \n```", "```\nfrom itertools import cycle # cycle([1, 2, 3]) -> (1, 2, 3, 1, 2, 3, ...)   def run_all(tasks):\n  for task in cycle(tasks):\n  run_task_for_a_little(task) \n```", "```\n#include &LTstdio.h> #include &LTsetjmp.h>   static jmp_buf buf;   void second() {\n  printf(\"second\\n\"); // prints\n  longjmp(buf,1); // jumps back to where setjmp was called - making setjmp now return 1 }   void first() {\n  second();\n  printf(\"first\\n\"); // does not print }   int main() {\n  if (!setjmp(buf))\n  first(); // when executed, setjmp returned 0\n  else // when longjmp jumps back, setjmp returns 1\n  printf(\"main\\n\"); // prints    return 0; } \n```", "```\n$ gcc example.c -o example && ./example second main \n```", "```\nsetjmp:\n  mov %rbx,(%rdi) ; rdi is jmp_buf, move registers onto it  mov %rbp,8(%rdi)\n  mov %r12,16(%rdi)\n  mov %r13,24(%rdi)\n  mov %r14,32(%rdi)\n  mov %r15,40(%rdi)\n  lea 8(%rsp),%rdx ; this is our rsp WITHOUT current ret addr  mov %rdx,48(%rdi)\n  mov (%rsp),%rdx ; save return addr ptr for new rip  mov %rdx,56(%rdi)\n  xor %eax,%eax ; always return 0  ret   longjmp:\n  xor %eax,%eax\n  cmp $1,%esi ; CF = val ? 0 : 1  adc %esi,%eax ; eax = val + !val  mov (%rdi),%rbx ; rdi is the jmp_buf, restore regs from it  mov 8(%rdi),%rbp\n  mov 16(%rdi),%r12\n  mov 24(%rdi),%r13\n  mov 32(%rdi),%r14\n  mov 40(%rdi),%r15\n  mov 48(%rdi),%rsp\n  jmp *56(%rdi) ; goto saved address without altering rsp \n```", "```\n#include &LTstdbool.h> #include &LTstdio.h> #include &LTsetjmp.h>   jmp_buf* current_buffer; jmp_buf main_buffer;   #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0])) #define YIELD() { if (!setjmp(*current_buffer)) longjmp(main_buffer, 1); }   void task_0() {\n  while (true) {\n  printf(\"0\\n\");\n  YIELD();\n  } }   void task_1() {\n  while (true) {\n  printf(\"1\\n\");\n  YIELD();\n  } }   int main() {\n  void(*tasks[])(void) = {task_0, task_1};\n jmp_buf buffers[ARRAY_SIZE(tasks)];\n  bool started = false;    while (true) {\n  for (int i = 0; i < ARRAY_SIZE(tasks); i++) {\n  if (setjmp(main_buffer)) {\n  continue;\n  }   current_buffer = &buffers[i];\n  if (!started) {\n tasks[i]();  } else {\n  longjmp(buffers[i], 1);\n  }\n  }   started = true;\n  }    return 0; } \n```", "```\n$ gcc example.c -o example && ./example 0 1 0 1 ... ^C \n```", "```\nvoid task_0() {\n  int i = 0;\n  while (true) {\n  printf(\"0: %d\\n\", i++);\n  YIELD();\n  } } \n```", "```\n$ gcc example.c -o example && ./example 0: 0 1 0: 32765 1 0: 32765 1 ... ^C \n```", "```\n---------------- | main's stack | ----------------\n ^ First, a call to setjmp in main saves the stack address here. \n```", "```\n--------------------------------- | main's stack | task_0's stack | ---------------------------------\n ^ Then, a call to setjmp in task_0 saves the stack address here. \n```", "```\n--------------------------------- | main's stack | task_0's stack | ---------------------------------\n ^ Once we longjmp back to main, we reset the stack register (rsp in x86_64) back here. \n```", "```\nThen any pushing to the stack, will overwrite any data saved in task_0's stack. So once we longjmp back to task_0, this is how our stack will look like:   --------------------------------- | main's stack | \"random\" stuff | ---------------------------------\n ^ No wonder we get a random looking value when we print something inside the stack. \n```", "```\n@@ -25,6 +26,7 @@ void task_1() {\n int main() { void(*tasks[])(void) = {task_0, task_1}; jmp_buf buffers[ARRAY_SIZE(tasks)]; +    char stacks[ARRAY_SIZE(tasks)][1024];  // Stack size of 1kb.\n bool started = false;   while (true) { @@ -35,7 +37,12 @@ int main() {   current_buffer = &buffers[i]; if (!started) { -                tasks[i](); +                // Stack goes down on push, up on pop. +                char* stack = stacks[i] + sizeof(stacks[i]); +                asm(\"movq %0, %%rax;\" +                    \"movq %1, %%rsp;\" +                    \"call *%%rax\" +                    :: \"rm\" (tasks[i]), \"rm\" (stack) : \"rax\");\n } else { longjmp(buffers[i], 1); } \n```", "```\n$ gcc example.c -o example && ./example 0: 0 1 0: 1 1 0: 2 1 ... ^C \n```", "```\n// In Go (prior to 1.14), this code would not yield until done. sum := 0 for i := 0; i < 1e8; i++ {\n  sum++ } \n```", "```\ngo fmt.Println(\"world\") fmt.Println(\"hello\") \n```", "```\nasync fn say() {\n println!(\"hello world\"); }   fn main() {\n  // Can't call say(), as main() is not async.    let mut rt = tokio::runtime::Runtime::new().unwrap();\n rt.block_on(async {\n  let future = say(); // Calling does not execute.\n future.await; // Starts executing.\n  }) } \n```"]