["```\nstruct Error {\n  data: Rc<ExpensiveToCloneDirectly>, }   pub type Response = Result<Output, Error>;   fn parse(input: Input) -> Response {\n todo!() } \n```", "```\nenum Command {\n Input(Input), Exit, }   pub enum RequestStatus {\n Completed(Response), Running, }   pub struct Parser {\n  command_sender: Sender<Command>,\n  response_receiver: Receiver<(Input, Response)>,\n  cached_result: HashMap<Input, RequestStatus>, }   impl Parser {\n  pub fn new() -> Self {\n  let (command_sender, command_receiver) = channel::<Command>();\n  let (response_sender, response_receiver) = channel::<(Input, Response)>();   std::thread::spawn(move || loop {\n  match command_receiver.recv() {\n Ok(Command::Input(input)) => {  let response = parse(input);\n  let _ = response_sender.send((input, response));\n } Ok(Command::Exit) => break,\n Err(_) => break,\n } });    Self {\n command_sender, response_receiver, cached_result: HashMap::default(), } }    pub fn request_parsing(&mut self, input: Input) -> RequestStatus {\n  // pump previously received responses\n  while let Ok((input, response)) = self.response.receiver.try_recv() {\n  self.cached_result\n .insert(input, RequestStatus::Completed(response));\n }    let response = match self.cached_result.entry(input) {\n Entry::Vacant(entry) => {  self.command_sender\n .send(Command::Input(entry.key()))\n .unwrap();\n entry.insert(RequestStatus::Running)\n } Entry::Occupied(entry) => entry.into_mut(),\n }; response.clone()\n } } \n```", "```\nerror[E0277]: `Rc<String>` cannot be sent between threads safely\n --> src/main.rs:58:32\n | 58 |               std::thread::spawn(move || loop {\n |  _____________------------------_^ | |             | | |             required by a bound introduced by this call 59 | | match command_receiver.recv() { 60 | |                     Ok(Command::Input(input)) => { 61 | | let response = maybe_make(input); ...   | 68 | |                 } 69 | |             });\n | |_____________^ `Rc<String>` cannot be sent between threads safely\n | = help: within `(&'static str, Result<worker::Output, worker::Error>)`, the trait `Send` is not implemented for `Rc<String>` note: required because it appears within the type `Error` --> src/main.rs:17:16\n | 17 | pub struct Error {\n |                ^^^^^ note: required because it appears within the type `Result<Output, Error>`\n --> /home/dureuill/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:502:10 | 502 | pub enum Result<T, E> {\n |          ^^^^^^ = note: required because it appears within the type `(&str, Result<Output, Error>)`\n = note: required for `Sender<(&'static str, Result<worker::Output, worker::Error>)>` to implement `Send` note: required because it's used within this closure --> src/main.rs:58:32 | 58  |             std::thread::spawn(move || loop {\n |                                ^^^^^^^ note: required by a bound in `spawn`\n --> /home/dureuill/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/mod.rs:683:8 | 680 | pub fn spawn<F, T>(f: F) -> JoinHandle<T>\n |        ----- required by a bound in this function ... 683 |     F: Send + 'static,\n |        ^^^^ required by this bound in `spawn` \n```", "```\ndiff --git a/src/main.rs b/src/main.rs index 04ec0d0..fd4b447 100644 --- a/src/main.rs +++ b/src/main.rs @@ -3,9 +3,9 @@ use std::{io::Write, time::Duration};\n mod parse { use std::{ collections::{hash_map::Entry, HashMap}, -        rc::Rc,\n sync::{ mpsc::{channel, Receiver, Sender}, +            Arc,\n }, time::Duration, }; @@ -15,13 +15,13 @@ mod parse {   #[derive(Clone, Debug)] pub struct Error { -        data: Rc<ExpensiveToCloneDirectly>, +        data: Arc<ExpensiveToCloneDirectly>,\n }   impl Error { fn new(data: ExpensiveToCloneDirectly) -> Self { Self { -                data: Rc::new(data), +                data: Arc::new(data),\n } } } \n```"]