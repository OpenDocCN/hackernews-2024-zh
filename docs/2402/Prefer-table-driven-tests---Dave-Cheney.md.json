["```\n// Split slices s into all substrings separated by sep and\n// returns a slice of the substrings between those separators.\nfunc Split(s, sep string) []string {\n    var result []string\n    i := strings.Index(s, sep)\n    for i > -1 {\n        result = append(result, s[:i])\n        s = s[i+len(sep):]\n        i = strings.Index(s, sep)\n    }\n    return append(result, s)\n}\n```", "```\npackage split\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestSplit(t *testing.T) {\n    got := Split(\"a/b/c\", \"/\")\n    want := []string{\"a\", \"b\", \"c\"}\n    if !reflect.DeepEqual(want, got) {\n         t.Fatalf(\"expected: %v, got: %v\", want, got)\n    }\n}\n```", "```\n% go test -coverprofile=c.out\nPASS\ncoverage: 100.0% of statements\nok      split   0.010s\n```", "```\n% go tool cover -func=c.out\nsplit/split.go:8:       Split          100.0%\ntotal:                  (statements)   100.0%\n```", "```\ncover () {\n    local t=$(mktemp -t cover)\n    go test $COVERFLAGS -coverprofile=$t $@ \\\n        && go tool cover -func=$t \\\n        && unlink $t\n}\n```", "```\nfunc TestSplitWrongSep(t *testing.T) {\n    got := Split(\"a/b/c\", \",\")\n    want := []string{\"a/b/c\"}\n    if !reflect.DeepEqual(want, got) {\n        t.Fatalf(\"expected: %v, got: %v\", want, got)\n    }\n}\n```", "```\nfunc TestSplitNoSep(t *testing.T) {\n    got := Split(\"abc\", \"/\")\n    want := []string{\"abc\"}\n    if !reflect.DeepEqual(want, got) {\n        t.Fatalf(\"expected: %v, got: %v\", want, got)\n    }\n}\n```", "```\nfunc TestSplit(t *testing.T) {\n    type test struct {\n        input string\n        sep   string\n        want  []string\n    }\n\n    tests := []test{\n        {input: \"a/b/c\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n        {input: \"a/b/c\", sep: \",\", want: []string{\"a/b/c\"}},\n        {input: \"abc\", sep: \"/\", want: []string{\"abc\"}},\n    }\n\n    for _, tc := range tests {\n        got := Split(tc.input, tc.sep)\n        if !reflect.DeepEqual(tc.want, got) {\n            t.Fatalf(\"expected: %v, got: %v\", tc.want, got)\n        }\n    }\n}\n```", "```\nfunc TestSplit(t *testing.T) {\n    tests := []struct {\n        input string\n        sep   string\n        want  []string\n    }{\n        {input: \"a/b/c\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n        {input: \"a/b/c\", sep: \",\", want: []string{\"a/b/c\"}},\n        {input: \"abc\", sep: \"/\", want: []string{\"abc\"}},\n    } \n\n    for _, tc := range tests {\n        got := Split(tc.input, tc.sep)\n        if !reflect.DeepEqual(tc.want, got) {\n            t.Fatalf(\"expected: %v, got: %v\", tc.want, got)\n        }\n    }\n}\n```", "```\n{input: \"a/b/c\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n{input: \"a/b/c\", sep: \",\", want: []string{\"a/b/c\"}},\n{input: \"abc\", sep: \"/\", want: []string{\"abc\"}},\n{input: \"a/b/c/\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}}, // trailing sep\n```", "```\n% go test\n--- FAIL: TestSplit (0.00s)\n    split_test.go:24: expected: [a b c], got: [a b c ]\n\n```", "```\nfunc TestSplit(t *testing.T) {\n    tests := []struct {\n        input string\n        sep   string\n        want  []string\n    }{\n        {input: \"a/b/c\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n        {input: \"a/b/c\", sep: \",\", want: []string{\"a/b/c\"}},\n        {input: \"abc\", sep: \"/\", want: []string{\"abc\"}},\n        {input: \"a/b/c/\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n    }\n\n    for i, tc := range tests {\n        got := Split(tc.input, tc.sep)\n        if !reflect.DeepEqual(tc.want, got) {\n            t.Fatalf(\"test %d: expected: %v, got: %v\", i+1, tc.want, got)\n        }\n    }\n}\n```", "```\n% go test\n--- FAIL: TestSplit (0.00s)\n    split_test.go:24: test 4: expected: [a b c], got: [a b c ]\n\n```", "```\nfunc TestSplit(t *testing.T) {\n    tests := []struct {\n name  string\n        input string\n        sep   string\n        want  []string\n    }{\n        {name: \"simple\", input: \"a/b/c\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n        {name: \"wrong sep\", input: \"a/b/c\", sep: \",\", want: []string{\"a/b/c\"}},\n        {name: \"no sep\", input: \"abc\", sep: \"/\", want: []string{\"abc\"}},\n        {name: \"trailing sep\", input: \"a/b/c/\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n    }\n\n    for _, tc := range tests {\n        got := Split(tc.input, tc.sep)\n        if !reflect.DeepEqual(tc.want, got) {\n            t.Fatalf(\"%s: expected: %v, got: %v\", tc.name, tc.want, got)\n        }\n    }\n}\n```", "```\n% go test\n--- FAIL: TestSplit (0.00s)\n    split_test.go:25: trailing sep: expected: [a b c], got: [a b c ]\n\n```", "```\nfunc TestSplit(t *testing.T) {\n    tests := map[string]struct {\n        input string\n        sep   string\n        want  []string\n    }{ \n        \"simple\":       {input: \"a/b/c\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}}, \n        \"wrong sep\":    {input: \"a/b/c\", sep: \",\", want: []string{\"a/b/c\"}},\n        \"no sep\":       {input: \"abc\", sep: \"/\", want: []string{\"abc\"}},\n        \"trailing sep\": {input: \"a/b/c/\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n    }\n\n    for name, tc := range tests {\n        got := Split(tc.input, tc.sep)\n        if !reflect.DeepEqual(tc.want, got) {\n            t.Fatalf(\"%s: expected: %v, got: %v\", name, tc.want, got)\n        }\n    }\n}\n```", "```\nfunc TestSplit(t *testing.T) {\n    tests := map[string]struct {\n        input string\n        sep   string\n        want  []string\n    }{\n        \"simple\":       {input: \"a/b/c\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n        \"wrong sep\":    {input: \"a/b/c\", sep: \",\", want: []string{\"a/b/c\"}},\n        \"no sep\":       {input: \"abc\", sep: \"/\", want: []string{\"abc\"}},\n        \"trailing sep\": {input: \"a/b/c/\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n    }\n\n    for name, tc := range tests {\n        t.Run(name, func(t *testing.T) {\n            got := Split(tc.input, tc.sep)\n            if !reflect.DeepEqual(tc.want, got) {\n                t.Fatalf(\"expected: %v, got: %v\", tc.want, got)\n            }\n        })\n    }\n}\n```", "```\n% go test\n--- FAIL: TestSplit (0.00s)\n    --- FAIL: TestSplit/trailing_sep (0.00s)\n        split_test.go:25: expected: [a b c], got: [a b c ]\n\n```", "```\n% go test -run=.*/trailing -v\n=== RUN   TestSplit\n=== RUN   TestSplit/trailing_sep\n--- FAIL: TestSplit (0.00s)\n    --- FAIL: TestSplit/trailing_sep (0.00s)\n        split_test.go:25: expected: [a b c], got: [a b c ]\n\n```", "```\n--- FAIL: TestSplit (0.00s)\n    --- FAIL: TestSplit/trailing_sep (0.00s)\n        split_test.go:25: expected: [a b c], got: [a b c ]\n```", "```\ngot := Split(tc.input, tc.sep)\nif !reflect.DeepEqual(tc.want, got) {\n    t.Fatalf(\"expected: %#v, got: %#v\", tc.want, got)\n}\n```", "```\n% go test\n--- FAIL: TestSplit (0.00s)\n    --- FAIL: TestSplit/trailing_sep (0.00s)\n        split_test.go:25: expected: []string{\"a\", \"b\", \"c\"}, got: []string{\"a\", \"b\", \"c\", \"\"}\n\n```", "```\nfunc main() {\n    type T struct {\n        I int\n    }\n    x := []*T{{1}, {2}, {3}}\n    y := []*T{{1}, {2}, {4}}\n    fmt.Printf(\"%v %v\\n\", x, y)\n    fmt.Printf(\"%#v %#v\\n\", x, y)\n}\n```", "```\nfunc main() {\n    type T struct {\n        I int\n    }\n    x := []*T{{1}, {2}, {3}}\n    y := []*T{{1}, {2}, {4}}\n    fmt.Println(cmp.Equal(x, y)) // false\n}\n```", "```\nfunc main() {\n    type T struct {\n        I int\n    }\n    x := []*T{{1}, {2}, {3}}\n    y := []*T{{1}, {2}, {4}}\n    diff := cmp.Diff(x, y)\n    fmt.Printf(diff)\n}\n```", "```\n% go run\n{[]*main.T}[2].I:\n         -: 3\n         +: 4\n```", "```\nfunc TestSplit(t *testing.T) {\n    tests := map[string]struct {\n        input string\n        sep   string\n        want  []string\n    }{\n        \"simple\":       {input: \"a/b/c\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n        \"wrong sep\":    {input: \"a/b/c\", sep: \",\", want: []string{\"a/b/c\"}},\n        \"no sep\":       {input: \"abc\", sep: \"/\", want: []string{\"abc\"}},\n        \"trailing sep\": {input: \"a/b/c/\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n    }\n\n    for name, tc := range tests {\n        t.Run(name, func(t *testing.T) {\n            got := Split(tc.input, tc.sep)\n            diff := cmp.Diff(tc.want, got)\n            if diff != \"\" {\n                t.Fatalf(diff)\n            }\n        })\n    }\n}\n```", "```\n% go test\n--- FAIL: TestSplit (0.00s)\n    --- FAIL: TestSplit/trailing_sep (0.00s)\n        split_test.go:27: {[]string}[?->3]:\n                -: <non-existent>\n                +: \"\"\nFAIL\nexit status 1\nFAIL    split   0.006s\n```"]