["```\n#!/usr/bin/env python3 \ndef log(repo_name, *args):\n    print(f\"{repo_name}:\", *args)\n\ndef randsleep():\n    import random\n    import time\n    time.sleep(random.randint(1, 5))\n\ndef func(repo_name):\n    log(repo_name, \"Starting\")\n    randsleep()  # Can be substituted for actual work\n    log(repo_name, \"Installing\")\n    randsleep()\n    log(repo_name, \"Building\")\n    randsleep()\n    log(repo_name, \"Instrumenting\")\n    randsleep()\n    log(repo_name, \"Running tests\")\n    randsleep()\n    log(repo_name, f\"Result in {repo_name}.json\")\n\nrepos = [\"repoA\", \"repoB\", \"repoC\", \"repoD\"]\nfor repo in repos:\n    func(repo) \n```", "```\nimport multiprocessing\n\n# ... \nwith multiprocessing.Pool() as pool:\n    pool.map(func, repos, chunksize=1) \n```", "```\ndef fill_output():\n    to_fill = num_lines - len(last_output_per_process)\n    for _ in range(to_fill):\n        print()\n\ndef clean_up():\n    for _ in range(num_lines):\n        print(\"\\x1b[1A\\x1b[2K\", end=\"\")  # move up cursor and delete whole line \ndef log(repo_name, *args):\n    with terminal_lock:\n        last_output_per_process[repo_name] = \" \".join(str(arg) for arg in args)\n        clean_up()\n        sorted_lines = last_output_per_process.items()\n        for repo_name, last_line in sorted_lines:\n            print(f\"{repo_name}: {last_line}\")\n        fill_output()\n\ndef func(repo_name):\n    # ...\n    with terminal_lock:\n        del last_output_per_process[repo_name]\n\n# ... \nrepos = [\"repoA\", \"repoB\", \"repoC\", \"repoD\"]\nnum_procs = multiprocessing.cpu_count()\nnum_lines = min(len(repos), num_procs)\nwith multiprocessing.Manager() as manager:\n    last_output_per_process = manager.dict()\n    terminal_lock = manager.Lock()\n    fill_output()\n    with multiprocessing.Pool() as pool:\n        pool.map(func, repos, chunksize=1)\n    clean_up() \n```"]