["```\n#include <stdio.h>\n\nint main() {\n    printf(\"Penguin!\\n\");\n} \n```", "```\nELF>@@H@8\n@@@@@@��88@@@@�� ((`(`�\nPP`P`��P�td@,,Q�tdR�td((`(`��/lib64/ld-linux-x86-64.so.2GNUGNUϨ�n��8�w�j7*oL�h��\n__gmon_start__libc.so.6puts__libc_start_mainGLIBC_2.2.5ui\n1```", "```\n\nThere’s text here, though! This was not a total failure. In particular it says “Penguin!” and “ELF”. ELF is the name of the binary format. So that’s something! Then there are a bunch of unprintable symbols, which isn’t a huge surprise because this is a binary.\n\n## Step 2: use `readelf` to see the symbol table\n\nThroughout we’re going to use a tool called `readelf` to explore our binary. Let’s start by running `readelf --symbols` on it. (another popular tool to do this is `nm`)\n\n```", "```\n\n([full output here](https://gist.github.com/jvns/0f82a7655d32bb6b331e))\n\nHere we see three *symbols*: `main` is the address of my `main()` function. `puts` looks like a reference to the `printf` function I called in it (which I guess the compiler changed to `puts` as an optimization?). `_start` is pretty important.\n\nWhen the program starts running, you might think it starts at `main`. It doesn’t! It *actually* goes to `_start`. This does a bunch of Very Important Things that I don’t understand very well, including calling `main`. So I won’t explain them.\n\nSo, what’s a symbol?\n\n### Symbols\n\nWhen you write a program, you might write a function called `hello`. When you compile the program, the binary for that function is labelled with a **symbol** called `hello`. If I call a function (like `printf`) from a library, we need a way to look up the code for that function! The process of looking up functions from libraries is called **linking**. It can happen either just after we compile the program (“static linking”) or when we run the program (“dynamic linking”).\n\nSo symbols are what allow linking to work! Let’s find the symbol for printf! It’ll be in `libc`, where all the C standard library functions are.\n\nIf I run `nm` on my copy of libc, it tells me “no symbols”. But the internet tells me I can use `objdump -tT` instead! This works! `objdump -tT /lib/x86_64-linux-gnu/libc-2.15.so` gives me [this output](https://gist.github.com/jvns/13bae55c3d463cdad809).\n\nIf you look at it, you’ll see `sprintf`, `strlen`, `fork`, `exec`, and everything you might expect libc to have. From here we can start to imagine how dynamic linking works – we see that `hello` calls `puts`, and then we can look up the location of `puts` in libc’s symbol table.\n\n## Step 3: use `objdump` to see the binary, and learn about sections!\n\nOpening our binary in a text editor was a bad way to open it. `objdump` is a better way. Here’s an excerpt:\n\n```", "```\n\nYou can see that it shows us all the bytes in the file as hex on the left, and a translation into ASCII on the right.\n\nThe are a whole bunch of **sections** here (see [this gist](https://gist.github.com/jvns/64aa2c85e083e0031609) for the whole thing). This shows you all the bytes in your binary! Some sections we care about:\n\n*   `.text` is the program’s actual code (the assembly). `_start` and `main` are both part of the `.text` section.\n*   `.rodata` is where some read-only data is stored (in this case, our string “Penguin!”)\n*   `.interp` is the filename of the dynamic linker!\n\nThe major difference between *sections* and *segments* is that sections are used at link time (by `ld`) and segments are used at execution time. `objdump` shows us the contents of the sections, which is nice, but doesn’t give us as much metadata about the sections as I’d like. Let’s try `readelf` instead:\n\n```", "```\n\n([full output](https://gist.github.com/jvns/37ce4ad26758b403f6b3))\n\nNeat! We can see `.text` is executable and read-only, `.rodata` (“read only data”) is read-only, and `.data` is read-write.\n\n## Step 4: Look at some assembly!\n\nWe mentioned briefly that `.text` contains assembly code. We can actually look at what it is really easily. If we were magicians, we would already be able to read and understand this:\n\n```", "```\n\nIt starts with `31ed4989`. Those are bytes that our CPU interprets as code! And runs! However we are not magicians (I don’t know what `31 ed` means!) and so we will use a disassembler instead.\n\n```", "```\n\n[full output here](https://gist.github.com/jvns/75298b0a5b6cde5de175)\n\nSo we see that `31 ed` is xoring two things. Neat! That’s all the assembly we’ll do for now.\n\n## Step 5: Segments!\n\nFinally, a program is organized into **segments** or **program headers**. Let’s look at the segments for our program using `readelf --segments hello`.\n\n```"]