<!--yml

类别：未分类

日期：2024-05-27 14:56:47

-->

# 故障、错误和失败 - 作者：Sir Whinesalot

> 来源：[https://btmc.substack.com/p/you-cant-handle-errors](https://btmc.substack.com/p/you-cant-handle-errors)

最近成为父亲（导致我写作速度变得极慢的原因之一）后，我不得不处理一种非常特殊的错误输出：*哭泣*。

从计算的角度来看，这大致相当于以下内容：

大声且不具体。好吧，至少对于一个婴儿来说，哭泣的原因是有限的，所以解决问题就是解决每个可能的原因，直到有所作为。但是祝你好运，调试上面的错误消息。

这让我想到，一个人怎么会得到类似上面那样无用的错误消息呢？编程语言应该提供哪些设施，以便让开发人员方便地正确处理错误？

最初，这篇文章本来是要对错误处理方法进行调查，类似于我在内存管理方法上的帖子，但最终我决定放弃，因为我认为从“超越传统思维”的角度看待这个问题很重要。也许有人能想出更好的“处理错误”的方法。

让我们从头开始。我们所说的*错误*是什么意思？不幸的是，“错误”这个术语在文献中并不一致，但我们可以使用来自容错研究中的3个相关、常用术语来区分“错误”一词的不同含义**：**

+   一个**故障**（俗称*bug*），是软件中的静态缺陷，意味着有一行（或多行）代码是错误的，很可能会导致…

+   一个**错误**，这是一个*未观察到*的，不正确的内部状态，很可能会导致…

+   一个**失败**，这是*观察到*的，与软件预期行为不符的不正确行为。

例如，考虑以下一段C#代码：

```
var a = new int[]{1,2,3,4,5};
for (int i = 0; i <= 5; i++) {
  Console.WriteLine(a[i]);
}
```

循环停止条件中有一个*故障*（应该是`i < 5`），这将导致`i = 5`的*错误*状态，当用于索引向量时将触发*失败*（抛出IndexOutOfRange异常）。

**错误不是异常（失败），也不是不正确的循环条件（故障）。**

了解这种区别对于本文的其余部分是至关重要的。在处理错误之前，我需要谈论错误*预防*，因为这两者经常混淆，这将有助于澄清我的意思。

测试、静态类型系统、模型检查、消毒剂、模糊测试，甚至某些语言特性如`foreach`循环（可以轻松避免上面的问题）都是间接*预防*错误的方法，通过检测或预防*故障*。

我完全支持上述所有内容，它们都很棒。如果你没有使用它们但可以使用，那么你应该使用。你的用户会感谢你。你的同事会感谢你。你未来的自己会感谢你。

错误几乎总是由于故障导致的。除了宇宙射线、硬件问题或应用程序与操作系统之间的非常不寻常的竞态条件之外，如果出现错误，则是*程序员搞砸了*，引入了一个错误。

Rust和Haskell等某些语言以“如果代码编译通过，则代码运行正常”而闻名。它们之所以享有此声誉，是因为通过强大的静态类型系统和尽可能精确地建模函数域和值域的文化，它们擅长防止常见的错误。

考虑以下函数声明（使用Rust语法）：

```
fn head(v: Vec<i64>) -> i64
```

头函数以带符号64位整数向量作为输入，并返回该向量中的第一个整数。

此函数的域是所有带符号64位整数向量的集合，其值域是带符号64位整数的集合。但这个函数声明是“虚假的”，根据观点不同，要么关于其域，要么关于其值域。

存在一个隐藏的前提条件，即`v`不为空。如果`v`为空，则该函数会发生恐慌。

“真实的”头函数会有不同的域或者值域：

```
fn head(v: NonEmptyVec<i64>) -> i64
fn head(v: Vec<i64>) -> Option<i64>
```

在第一种情况下，我们限制了域，在第二种情况下我们放宽了值域。无论哪种方式，都使得函数更不容易出现错误——通过提醒程序员考虑他们必须考虑的特殊情况——但代价是使其更难使用。

在第一种情况下，调用者必须通过调用某些显式转换函数来证明他们拥有一个非空向量，而在后一种情况下，即使他们确切知道向量不为空，调用者也必须始终处理“None”情况。

如果同时需要多个属性（例如，期望一个非空的偶数长度向量），则“真实的域”方法在没有更强大的类型系统特性支持（如[依赖类型](https://en.wikipedia.org/wiki/Dependent_type)或[精化类型](https://en.wikipedia.org/wiki/Refinement_type)）的情况下迅速崩溃，而这些特性又会给语言增加大量复杂性，而我认为这并不值得。

值域总是可以通过单个额外的“无效输入”案例放宽，并且可以添加各种语言设施以便捷处理此额外案例，这在大多数情况下是更好的解决方案。例如，在C#中，可空类型具有大量功能，使其尽可能方便使用：

+   流类型化，其传播空检查的结果（即`int?`变量在检查结果有效的时间内变为`int`）

+   空合并（`??` 和 `??=`）运算符使得用非空类型的替代值替换空值变得更加方便。

+   空条件（`?.` 和 `?[]`）运算符允许从非空类型到可空类型的“扁平映射”操作。

思想是保持真实代码域的优势（提醒程序员处理特殊情况），同时减少不便之处。

即使尽可能地采取了所有的故障预防措施，错误仍然会发生。故障预防是确保已知的前置和后置条件被正确处理，它无法处理意外的逻辑错误或缺失的需求。

不幸的是，一旦错误发生，它无法直接处理。记住，错误是*未观察到*的不正确状态。一旦你*观察到*一个错误，它已经变成了一个*故障*。

比如考虑对一个变量进行一系列加法和减法操作，在中间计算中会出现溢出，但最终结果没有。中间溢出的值是*错误*，但没有*故障*产生。

如果你确实在每次操作后检查溢出，你将检测到错误，触发一个*故障*并引发恐慌或类似情况。而如果，相反地，你检查所有输入以确保它们永远不会溢出，你将预防一个*故障*。混淆故障和故障，我相信，已经导致了一些真的很糟糕的语言特性，比解决的故障和故障还要多（例如，**异常**，稍后再详细说明）。

因此，错误不能被处理，只有故障可以，而故障是程序的观察到的不正确行为。如果程序的行为不正确，你能做什么呢？

首先，程序如何知道它的行为不正确？如果程序可以知道它的行为不正确，为什么不在第一次预防出现故障呢？***是的***。但因为各种原因，这样做的成本可能太高。

一个例子就是需要在每次算术运算后检查是否溢出。我不是说编译器插入检查并触发一个故障，我是说程序员在每次算术运算后明确检查溢出并处理每一种“特殊情况”。非常令人恼火。

或者，可以通过使用[任意精度算术](https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic)来防止与溢出相关的故障，这将带来计算成本，并可能导致不同类型的故障（内存不足）。

编译器（或者程序员）插入的检查是一种计算方式，用来观察由于不太可能的（但本应预期的）错误导致的故障，这些错误本质上是因为防止其发生的成本过高。最常见的例子是数组边界检查。

注意这些检查并不是故障处理，它们是检测故障的必要步骤，实际的处理是在其后进行。

观察到故障的最常见反应是抛出异常。异常会解开堆栈，直到它们遇到程序员指定的处理程序（即`try/catch`块）或默认处理程序使程序崩溃，并通常打印出[堆栈跟踪](https://en.wikipedia.org/wiki/Stack_trace)来帮助调试问题。

第二种最常见的方法是通过向程序发送信号来中止程序，这种信号通常被默认信号处理程序捕获，该处理程序将终止程序并输出一个“有用”的消息，比如[分段错误](https://en.wikipedia.org/wiki/Segmentation_fault)（正如上述定义的一种失败，你是否讨厌不一致的命名约定？）

Rust的panic可以设置为使用类似异常的机制，终止当前线程，或者中止程序（如上所述发送信号）。

所有的可能性都默认使程序崩溃。在我讨论原因之前，我需要指出以下内容*并非*故障处理：

```
try {
  File f = new File("filename.txt");
  ...
}
catch (FileNotFoundException e) {
  ...
}
```

在我看来，这只是一个看起来奇怪的条件，针对文件构造函数的一个特定“输出值”。文件构造函数的“真实”值域包括作为异常“返回”的其他情况。

你会写类似上面的代码来处理数组越界的情况吗？就在你尝试索引数组之后？除以零呢？不会吧？

忘记处理丢失的文件是一个错误，并且捕捉“输出”*不是没有那个错误*。使用异常而不是正确建模函数的值域，增加了故障发生的可能性及其相应的失败，因为没有提醒程序员处理常见的故障情况。

我真的不喜欢异常，因为它们混淆了这些无关的问题。

如果你允许在故障处理功能中编码不同的“错误类型”，那你可能已经搞砸了。让我解释一下。

让我说得明白点：

处理失败意味着将程序恢复到已知的正确状态。

记住管道：故障 → 错误 → 失败。故障是程序源代码中的错误，导致程序进入不正确的未观察状态，然后可能导致失败，这是观察到的不正确行为。

故障处理程序的任务是*消除错误*。请注意，它并非处理错误，而是处理失败，造成失败的错误是未知的。但目标无论如何都是消除错误。

考虑一个数组越界异常。如果发生了这种情况，那是因为程序中存在一个错误，导致某个变量设置为错误值，进而导致尝试越界访问数组的不正确行为。故障处理程序应该做什么？

首先，一个真正的故障处理程序不会在实际的索引越界情况附近，因为如果是这样，你只是处理索引操作的可能“返回值”之一（防止故障），而不是真正处理故障。

在具有[代数效果处理程序](https://en.wikipedia.org/wiki/Effect_system)的语言中，索引越界情况的处理程序可以通过使用虚构的值恢复程序来“修复”故障。这是个糟糕的主意，本质上是用新错误替换故障。使用异常你甚至不能做到这一点。

不，一个真正的故障处理程序是程序员希望永远不会真正运行的一段代码！它是最后的防线。故障处理程序只知道某个变量（不知道哪个）在某个时刻（不知道在哪里）被设置为错误值，然后用于错误地索引数组（知道在哪里，但无法做任何处理）。

鉴于上述情况，对于故障处理程序而言，IndexOutOfBounds就好像是PoopExplosion9000一样。这些信息对程序员有用，堆栈跟踪也有用，但它本可以作为断言错误消息中的文本字符串。异常的实际类型对于故障处理的目的是完全无用的（对于“贫民区”的情况不适用，但你不应该在第一时间使用异常）。

虽然你只能处理故障（因为只有故障是可观察到的），但仅仅通过消除故障本身并不能有多大帮助，仍然存在导致它的不可观察的无效状态，而且你不能直接处理该无效状态，因为你不知道它是什么或者它来自哪里。

这就是为什么任何一种恐慌机制（异常、信号等）的默认处理程序都是全面崩溃，尽可能多地为程序员提供调试所需的信息。它无法做其他事情。

你唯一能做的就是把它关掉然后再打开。

每一个比默认值更好的故障处理程序最终都只是减少了重新启动的范围或者提高了信息转储的有用性。

恐慌机制的选择（异常、信号、终止线程）基本上决定了可以重新启动的范围。如果重新启动不是目标，那么除了彻底终止程序之外就不需要任何机制了。

异常允许你在函数的任意点重新启动。这听起来没那么有用，因为错误状态可能发生在处理程序的重新启动点之外。你只能安全地重新启动纯函数或那些像[事务](https://en.wikipedia.org/wiki/Transaction_processing)一样工作的函数。

重启线程（特别是工作线程）是最佳方法之一，如果线程不共享可变状态。Erlang（及其衍生的 Elixir）完全围绕这一思想构建，使用[监督树](https://erlang.org/documentation/doc-4.9.1/doc/design_principles/sup_princ.html)。由于 Erlang 设计时考虑了故障处理，因此非常适合高可靠性系统。

最后一种情况，向程序发送信号，听起来似乎没有多少“重启”的余地，但这在很大程度上取决于软件的工作方式。如果程序每秒将用户工作备份到磁盘，那么你可以通过重启整个程序并指示其加载用户备份的工作来返回到“已知的正确状态”。你也可以在多进程架构中使用这种方法。

另一个适合重启的软件架构是[Elm 架构](https://guide.elm-lang.org/architecture/)，因为每个“更新”步骤都可以被取消。可惜的是，Elm 本身缺乏良好的故障处理机制来利用这一点。试图以任何代价避免故障会导致[这种胡言乱语](https://github.com/elm/core/issues/1072)。

在所有情况下，希望触发故障是不常见的事件，否则程序将陷入无意义的重启循环。

不幸的是，由于逻辑错误，错误可能不会导致计算上可观察的失败。例如，想想那些故障的物理模拟。只能等待用户的投诉出现。

故障是源代码中导致错误（未观察到的无效状态），直到触发失败（观察到的无效行为）的错误。

许多故障是容易预防的错误，而其他一些则太昂贵或令人讨厌以至于无法预防。能够避免或检测到这些错误的语言和工具都是好的。

你不能直接处理错误，只能处理它们对应的失败。

处理失败总是意味着重启（部分）程序以消除错误，否则这实际上并不是处理失败，而是在函数的额外已知“返回值”上工作。

你应该以允许适当故障处理的方式设计软件。一些语言（如 Erlang）对此有很好的支持。而像 Elm 这样的语言则认为这是不必要的（我不同意）。

异常被用作函数的额外“返回值”建模的一种方式，同时也是一种故障处理机制，这使得它们既不擅长前者也不擅长后者。异常糟透了。

* * *

**旁注：** 我在文本中没有提到它，因为文本已经太大而且混乱不堪，但有另一种很好的方法来预防故障，而不是通过扩展定义域来“必须处理无效结果”以提醒程序员可能存在的故障。

您还可以通过额外的“无害”结果扩展函数域。对于库来说是一个可怕的想法，因为它不可能知道对于调用者来说这样一个无害的结果会是什么样子，但对于应用程序来说是一个完全有效的方法。

例如，假设您的程序在开始时加载了一堆纹理。而不是纹理加载函数返回一个 `Option<Texture>`，然后您需要在各个地方处理它，它可以仅返回 `Texture`，但对于加载失败的纹理使用特殊的“缺失纹理”。

函数应该记录某处缺少的纹理，并且允许程序继续正常运行，仍然让用户完成一些工作（如果他们不需要这些纹理的话）。程序可以检查是否在某个时刻记录了错误，并在一个单独的代码路径中向用户显示这些错误，与此同时，用户可以在其他时间修复缺失的纹理。查看关于此主题的[瑞安·弗卢里的这篇文章](https://www.rfleury.com/p/the-easiest-way-to-handle-errors)。
