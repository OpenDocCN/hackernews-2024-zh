- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ç±»ï¼šæœªåˆ†ç±»
- en: 'date: 2024-05-27 14:48:37'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024-05-27 14:48:37
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'Compiling History: A brief tour of C compilers'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¼–è¯‘å†å²ï¼šCç¼–è¯‘å™¨ç®€è¦ä»‹ç»
- en: æ¥æºï¼š[https://www.deusinmachina.net/p/compiling-history-a-brief-tour-of](https://www.deusinmachina.net/p/compiling-history-a-brief-tour-of)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://www.deusinmachina.net/p/compiling-history-a-brief-tour-of](https://www.deusinmachina.net/p/compiling-history-a-brief-tour-of)
- en: 'As the story of Câ€™s birth goes hand in hand with the creation of Unix, the
    first C compiler can be traced back to the early 1970â€™s. I''ve detailed the history
    of C in my previous article [Tracing the Lines: From the Telephone to Unix](https://www.deusinmachina.net/p/history-of-unix),
    which includes a brief summary of this history.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: éšç€Cè¯ç”Ÿçš„æ•…äº‹ä¸Unixçš„åˆ›å»ºå¯†åˆ‡ç›¸å…³ï¼Œç¬¬ä¸€ä¸ªCç¼–è¯‘å™¨å¯ä»¥è¿½æº¯åˆ°20ä¸–çºª70å¹´ä»£åˆã€‚æˆ‘åœ¨æˆ‘çš„ä¸Šä¸€ç¯‡æ–‡ç« [è¿½è¸ªçº¿è·¯ï¼šä»ç”µè¯åˆ°Unix](https://www.deusinmachina.net/p/history-of-unix)ä¸­è¯¦ç»†ä»‹ç»äº†Cçš„å†å²ï¼Œå…¶ä¸­åŒ…æ‹¬å¯¹è¿™æ®µå†å²çš„ç®€è¦æ€»ç»“ã€‚
- en: Around 1971, Ken decided that Unix needed to be ported to a higher level language.
    Dennis Ritchie took on the task, evolving Kenâ€™s B language into something more
    feature rich. It was first called New B (NB), but each time Ken tried to rewrite
    the kernel in New B he would run into a roadblock. He would then ask Dennis to
    add more features. Eventually after structures were invented, there were enough
    features that Ken could rewrite version 4 of the whole Unix kernel in it. After
    a new compiler was written for this new language, it was renamed to C, and the
    rest is history. This was a significant breakthrough, as, until then, kernels
    were written in Assembly. For perspective, as late as 1983, Microsoft was still
    programming [MS-DOS v2.0](https://github.com/microsoft/MS-DOS/tree/master/v2.0/source)
    in Assembly. Unix was truly ahead of its time.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¤§çº¦åœ¨1971å¹´ï¼ŒKenå†³å®šå°†Unixç§»æ¤åˆ°æ›´é«˜çº§çš„è¯­è¨€ã€‚Dennis Ritchieæ‰¿æ‹…äº†è¿™é¡¹ä»»åŠ¡ï¼Œå°†Kençš„Bè¯­è¨€æ¼”å˜æˆæ›´å…·ç‰¹è‰²çš„ä¸œè¥¿ã€‚å®ƒæœ€åˆè¢«ç§°ä¸ºNew
    Bï¼ˆNBï¼‰ï¼Œä½†æ¯æ¬¡Kenè¯•å›¾ç”¨New Bé‡å†™å†…æ ¸æ—¶ï¼Œä»–éƒ½ä¼šé‡åˆ°éšœç¢ã€‚ç„¶åä»–ä¼šè¦æ±‚Dennisæ·»åŠ æ›´å¤šåŠŸèƒ½ã€‚æœ€ç»ˆï¼Œç»“æ„è¢«å‘æ˜åï¼Œæœ‰è¶³å¤Ÿçš„åŠŸèƒ½ï¼ŒKenå¯ä»¥ç”¨å®ƒé‡å†™æ•´ä¸ªUnixå†…æ ¸çš„ç‰ˆæœ¬4ã€‚åœ¨ä¸ºè¿™ç§æ–°è¯­è¨€ç¼–å†™äº†æ–°ç¼–è¯‘å™¨åï¼Œå®ƒè¢«é‡æ–°å‘½åä¸ºCï¼Œå…¶ä½™çš„å°±æ˜¯å†å²ã€‚è¿™æ˜¯ä¸€ä¸ªé‡å¤§çªç ´ï¼Œå› ä¸ºç›´åˆ°é‚£æ—¶ï¼Œå†…æ ¸éƒ½æ˜¯ç”¨æ±‡ç¼–è¯­è¨€ç¼–å†™çš„ã€‚ä¸ºäº†ç†è§£ï¼Œ1983å¹´ï¼Œå¾®è½¯ä»åœ¨ç”¨æ±‡ç¼–è¯­è¨€ç¼–å†™[MS-DOS
    v2.0](https://github.com/microsoft/MS-DOS/tree/master/v2.0/source)ã€‚UnixçœŸæ­£é¢†å…ˆäºå…¶æ—¶ä»£ã€‚
- en: Since Unix was created on a PDP-10/11, it makes sense that the first compiler
    for C was created for the PDP-11\. This is usually just referred to as the PDP
    C Compiler. The earliest known version of this compilerâ€™s source code can still
    [be viewed here](https://github.com/mortdeus/legacy-cc), and is an interesting
    time capsule of computing history.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºUnixæ˜¯åœ¨PDP-10/11ä¸Šåˆ›å»ºçš„ï¼Œå› æ­¤ç¬¬ä¸€ä¸ªCç¼–è¯‘å™¨ä¸ºPDP-11åˆ›å»ºã€‚è¿™é€šå¸¸è¢«ç§°ä¸ºPDP Cç¼–è¯‘å™¨ã€‚è¿™ä¸ªç¼–è¯‘å™¨æºä»£ç çš„æœ€æ—©ç‰ˆæœ¬ä»ç„¶å¯ä»¥[åœ¨è¿™é‡ŒæŸ¥çœ‹](https://github.com/mortdeus/legacy-cc)ï¼Œå®ƒæ˜¯è®¡ç®—å†å²çš„ä¸€ä¸ªæœ‰è¶£çš„æ—¶å…‰èƒ¶å›Šã€‚
- en: 'This was succeeded by the Portable C Compiler, developed by Stephen C. Johnson
    of Bell Labs, and one of the first compilers that was capable of generating machine
    independent C code. In Section 2.1 of Bjarne Stroustrupâ€™s article titled [Sibling
    Rivalry: C and C++](https://stroustrup.com/sibling_rivalry.pdf), he details key
    aspects of this compiler and why it was so important'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Portable C Compilerçš„åç»§è€…æ˜¯è´å°”å®éªŒå®¤çš„Stephen C. Johnsonå¼€å‘çš„ï¼Œå®ƒæ˜¯æœ€æ—©èƒ½å¤Ÿç”Ÿæˆä¸æœºå™¨æ— å…³çš„Cä»£ç çš„ç¼–è¯‘å™¨ä¹‹ä¸€ã€‚åœ¨Bjarne
    Stroustrupçš„æ–‡ç« [å…„å¼Ÿç«äº‰ï¼šCå’ŒC++](https://stroustrup.com/sibling_rivalry.pdf)çš„ç¬¬2.1èŠ‚ä¸­ï¼Œä»–è¯¦ç»†ä»‹ç»äº†è¿™ä¸ªç¼–è¯‘å™¨çš„å…³é”®æ–¹é¢ä»¥åŠå®ƒä¸ºä»€ä¹ˆå¦‚æ­¤é‡è¦ã€‚
- en: 'Pre-ANSI C is often referred to as K&R C. However, that is slightly incorrect.
    The C described in [Kernighan,1978] lacks three features of the language used
    by almost all C programmers before the emergenceof C89: void, enumerations, and
    structure assignment. These three features were added in PCC, the Portable C Compiler,
    developed by Steve Johnson and distributed as the C compiler by Bell Labs (with
    the â€˜â€˜blessingâ€™â€™ of Dennis Ritchie).'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Pre-ANSI Cé€šå¸¸è¢«ç§°ä¸ºKï¼†R Cã€‚ç„¶è€Œï¼Œè¿™æœ‰ç‚¹ä¸å‡†ç¡®ã€‚ [Kernighan,1978]ä¸­æè¿°çš„Cè¯­è¨€ç¼ºå°‘å‡ ä¸ªå‡ ä¹æ‰€æœ‰Cç¨‹åºå‘˜åœ¨C89å‡ºç°ä¹‹å‰ä½¿ç”¨çš„è¯­è¨€çš„ç‰¹æ€§ï¼švoidã€æšä¸¾å’Œç»“æ„èµ‹å€¼ã€‚è¿™ä¸‰ä¸ªç‰¹æ€§æ˜¯ç”±Steve
    Johnsonå¼€å‘çš„ä¾¿æºå¼Cç¼–è¯‘å™¨PCCï¼ˆPortable C Compilerï¼‰æ·»åŠ çš„ï¼Œå¹¶ç”±è´å°”å®éªŒå®¤åˆ†å‘ä¸ºCç¼–è¯‘å™¨ï¼ˆå¾—åˆ°äº†Dennis Ritchieçš„â€œç¥ç¦â€ï¼‰ã€‚
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Adding void (used as a possible return type for functions only) allows a programmer
    to directly express that a function doesnâ€™t return a value, and allows the compiler
    to check that. Similarly, adding enumerations allows a programmer to directly
    express that a group of values in some way belong together. It also supports the
    notion of manifest constants in a way that does not rely on macros.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ·»åŠ voidï¼ˆä»…ç”¨ä½œå‡½æ•°çš„å¯èƒ½è¿”å›ç±»å‹ï¼‰å…è®¸ç¨‹åºå‘˜ç›´æ¥è¡¨ç¤ºå‡½æ•°ä¸è¿”å›å€¼ï¼Œå¹¶å…è®¸ç¼–è¯‘å™¨æ£€æŸ¥ã€‚ç±»ä¼¼åœ°ï¼Œæ·»åŠ æšä¸¾å…è®¸ç¨‹åºå‘˜ç›´æ¥è¡¨ç¤ºä¸€ç»„å€¼åœ¨æŸç§ç¨‹åº¦ä¸Šå½’å±äºä¸€èµ·ã€‚å®ƒè¿˜æ”¯æŒä¸€ç§ä¸ä¾èµ–äºå®çš„å¸¸é‡è¡¨ç¤ºæ³•ã€‚
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Adding structure assignment (and also structure copy initialization, argument
    passing, and function return) makes struct values first-class citizens of C.
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ·»åŠ ç»“æ„èµ‹å€¼ï¼ˆä»¥åŠç»“æ„å¤åˆ¶åˆå§‹åŒ–ã€å‚æ•°ä¼ é€’å’Œå‡½æ•°è¿”å›ï¼‰ä½¿ç»“æ„å€¼æˆä¸ºCçš„ä¸€ç­‰å…¬æ°‘ã€‚
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thus, two of the three last additions to Classic C add to the expressive power
    of the type system without actually allowing a programmer to express any new computations.
    The third makes user-defined types, as then existing, equal to built-in types.
    In addition, one of the additions provides an alternative to the use of macros.
    These are all themes that recur in the design of C++.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œç»å…¸Cçš„æœ€åä¸‰ä¸ªè¡¥å……ä¸­çš„ä¸¤ä¸ªå¢åŠ äº†ç±»å‹ç³»ç»Ÿçš„è¡¨ç°åŠ›ï¼Œè€Œå®é™…ä¸Šå¹¶æ²¡æœ‰å…è®¸ç¨‹åºå‘˜è¡¨è¾¾ä»»ä½•æ–°çš„è®¡ç®—ã€‚ç¬¬ä¸‰ä¸ªä½¿ç”¨æˆ·å®šä¹‰çš„ç±»å‹ï¼Œå¦‚å½“æ—¶å­˜åœ¨çš„ï¼Œç­‰åŒäºå†…ç½®ç±»å‹ã€‚æ­¤å¤–ï¼Œå…¶ä¸­ä¸€ä¸ªè¡¥å……æä¾›äº†ä¸€ç§æ›¿ä»£å®çš„æ–¹æ³•ã€‚è¿™äº›éƒ½æ˜¯C++è®¾è®¡ä¸­åå¤å‡ºç°çš„ä¸»é¢˜ã€‚
- en: The Portable C Compiler was distributed with version 7 of Unix, the last version
    of Unix released before it was commercialized. Due to its early mover advantage,
    and the fact that it could be adapted to produce assembly for different architectures,
    meant that it enjoyed much success in the nascent years of C.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾¿æºå¼Cç¼–è¯‘å™¨éšUnixçš„ç¬¬7ç‰ˆä¸€èµ·å‘å¸ƒï¼Œè¿™æ˜¯Unixåœ¨å•†ä¸šåŒ–ä¹‹å‰å‘å¸ƒçš„æœ€åä¸€ä¸ªç‰ˆæœ¬ã€‚ç”±äºå®ƒçš„å…ˆè¡Œè€…ä¼˜åŠ¿ï¼Œä»¥åŠå®ƒå¯ä»¥é€‚åº”ä¸ºä¸åŒä½“ç³»ç»“æ„ç”Ÿæˆæ±‡ç¼–ä»£ç ï¼Œæ„å‘³ç€å®ƒåœ¨Cçš„åˆæœŸå¹´ä»½å–å¾—äº†å¾ˆå¤§çš„æˆåŠŸã€‚
- en: But it was not the only compiler to pop up during that time. The 1970s also
    saw the Small-C compiler created by Ron Cain. It was a minimalist subset of C
    that could run on 8-bit microcomputers. Itâ€™s hard to believe now a days that computers
    at one point struggled to compile C code, let alone a subset of it, but that was
    indeed the case. The PDP-11 that C was developed on was a 16-bit broom closet
    sized computer, which was still considerably more powerful than the 8-bit home
    computers of the day. This is often why programs from that era were written in
    Assembly, Basic, and Pascal instead of C.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å®ƒå¹¶ä¸æ˜¯é‚£ä¸ªæ—¶ä»£å”¯ä¸€å‡ºç°çš„ç¼–è¯‘å™¨ã€‚20 ä¸–çºª 70 å¹´ä»£è¿˜è§è¯äº† Ron Cain åˆ›é€ çš„ Small-C ç¼–è¯‘å™¨ã€‚å®ƒæ˜¯ C çš„ä¸€ä¸ªæç®€å­é›†ï¼Œå¯ä»¥åœ¨
    8 ä½å¾®å‹è®¡ç®—æœºä¸Šè¿è¡Œã€‚éš¾ä»¥ç½®ä¿¡çš„æ˜¯ï¼Œå¦‚ä»Šè®¡ç®—æœºæ›¾ç»åœ¨ç¼–è¯‘ C ä»£ç æ–¹é¢ä¹Ÿé‡åˆ°å›°éš¾ï¼Œæ›´ä¸ç”¨è¯´å…¶å­é›†äº†ï¼Œä½†äº‹å®ç¡®å®å¦‚æ­¤ã€‚C å¼€å‘çš„ PDP-11 æ˜¯ä¸€å° 16
    ä½çš„å°å‹è®¡ç®—æœºï¼Œå°½ç®¡æ¯”å½“æ—¶çš„ 8 ä½å®¶ç”¨è®¡ç®—æœºå¼ºå¤§å¾—å¤šï¼Œä½†ä»ç„¶è¿œä¸åŠä»Šå¤©çš„è®¡ç®—æœºã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆé‚£ä¸ªæ—¶ä»£çš„ç¨‹åºç»å¸¸æ˜¯ç”¨æ±‡ç¼–ã€Basic å’Œ Pascal ç¼–å†™ï¼Œè€Œä¸æ˜¯ç”¨
    C ç¼–å†™çš„åŸå› ã€‚
- en: Another commercial compiler to come out during this time was the Lattice C compiler,
    one of the first C compilers written for the IBM Personal Computer. It was created
    by [Lifeboat Associates](https://en.wikipedia.org/wiki/Lifeboat_Associates) and
    retailed for $500 ($1,628 in todayâ€™s money), and it ran on PC-DOS and MS-DOS.
    Microsoft used this as the basis for their Microsoft C Compiler (MSC). During
    this time many compilers were produced including, the Mark Williams Compiler,
    the Green Hills compiler, the Aztec C compiler and many others.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ­¤æœŸé—´æ¨å‡ºçš„å¦ä¸€æ¬¾å•†ä¸šç¼–è¯‘å™¨æ˜¯ Lattice C ç¼–è¯‘å™¨ï¼Œå®ƒæ˜¯ä¸º IBM ä¸ªäººè®¡ç®—æœºç¼–å†™çš„ç¬¬ä¸€æ‰¹ C ç¼–è¯‘å™¨ä¹‹ä¸€ã€‚å®ƒæ˜¯ç”±[Lifeboat Associates](https://en.wikipedia.org/wiki/Lifeboat_Associates)åˆ›å»ºçš„ï¼Œå”®ä»·ä¸º
    500 ç¾å…ƒï¼ˆæŒ‰ä»Šå¤©çš„ä»·å€¼ä¸º 1,628 ç¾å…ƒï¼‰ï¼Œå¯åœ¨ PC-DOS å’Œ MS-DOS ä¸Šè¿è¡Œã€‚å¾®è½¯å°†å…¶ç”¨ä½œå…¶ Microsoft C ç¼–è¯‘å™¨ï¼ˆMSCï¼‰çš„åŸºç¡€ã€‚åœ¨æ­¤æœŸé—´ï¼Œç”Ÿäº§äº†è®¸å¤šç¼–è¯‘å™¨ï¼ŒåŒ…æ‹¬
    Mark Williams ç¼–è¯‘å™¨ã€Green Hills ç¼–è¯‘å™¨ã€Aztec C ç¼–è¯‘å™¨ç­‰ã€‚
- en: These developments however, navigated a landscape devoid of an official C standard,
    leading to varied interpretations and implementations. They were based on "The
    C Programming Language" book by Brian Kernighan and Dennis M. Ritchie published
    on February 22, 1978\. The eventual release of the standard, known as C89 or C90,
    brought much needed uniformity and clarity to the language. The preface in the
    2nd edition of the book, published in April of 1988, highlights the importance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™äº›å‘å±•æ˜¯åœ¨æ²¡æœ‰å®˜æ–¹ C æ ‡å‡†çš„æƒ…å†µä¸‹è¿›è¡Œçš„ï¼Œå¯¼è‡´äº†å„ç§ä¸åŒçš„è§£é‡Šå’Œå®ç°ã€‚å®ƒä»¬åŸºäº Brian Kernighan å’Œ Dennis M. Ritchie
    åœ¨ 1978 å¹´ 2 æœˆ 22 æ—¥å‡ºç‰ˆçš„ã€ŠC ç¨‹åºè®¾è®¡è¯­è¨€ã€‹ä¸€ä¹¦ã€‚æœ€ç»ˆçš„æ ‡å‡†ç‰ˆæœ¬ï¼Œå³ C89 æˆ– C90ï¼Œä¸ºè¯¥è¯­è¨€å¸¦æ¥äº†æ€¥éœ€çš„ä¸€è‡´æ€§å’Œæ¸…æ™°åº¦ã€‚è¯¥ä¹¦ç¬¬äºŒç‰ˆçš„å‰è¨€ï¼Œäº
    1988 å¹´ 4 æœˆå‡ºç‰ˆï¼Œå¼ºè°ƒäº†å…¶é‡è¦æ€§ã€‚
- en: The standard formalizes constructions that were hinted but not described in
    the first edition, particularly structure assignment and enumerations. It provides
    a new form of function declaration that permits cross-checking of definition with
    use. It specifies a standard library, with an extensive set of functions for performing
    input and output, memory management, string manipulation, and similar tasks. It
    makes precise the behavior of features that were not spelled out in the original
    definition, and at the same time states explicitly which aspects of the language
    remain machine-dependent.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ­¤æ ‡å‡†è§„èŒƒäº†ç¬¬ä¸€ç‰ˆä¸­æš—ç¤ºä½†æœªæè¿°çš„æ„é€ ï¼Œç‰¹åˆ«æ˜¯ç»“æ„èµ‹å€¼å’Œæšä¸¾ã€‚å®ƒæä¾›äº†ä¸€ç§æ–°å½¢å¼çš„å‡½æ•°å£°æ˜ï¼Œå…è®¸å¯¹å®šä¹‰ä¸ä½¿ç”¨è¿›è¡Œäº¤å‰æ£€æŸ¥ã€‚å®ƒæŒ‡å®šäº†ä¸€ä¸ªæ ‡å‡†åº“ï¼Œå…¶ä¸­åŒ…å«äº†å¤§é‡ç”¨äºæ‰§è¡Œè¾“å…¥å’Œè¾“å‡ºã€å†…å­˜ç®¡ç†ã€å­—ç¬¦ä¸²æ“ä½œç­‰ä»»åŠ¡çš„å‡½æ•°ã€‚å®ƒæ˜ç¡®äº†åŸå§‹å®šä¹‰ä¸­æœªè¯¦ç»†è¯´æ˜çš„åŠŸèƒ½è¡Œä¸ºï¼Œå¹¶åŒæ—¶æ˜ç¡®è¯´æ˜äº†è¯­è¨€çš„å“ªäº›æ–¹é¢ä»ç„¶æ˜¯æœºå™¨ç›¸å…³çš„ã€‚
- en: With the publishing of the standard, C became a much more consistent language
    to program across environments.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: éšç€æ ‡å‡†çš„å‘å¸ƒï¼ŒC æˆä¸ºäº†è·¨å¹³å°ç¼–ç¨‹çš„ä¸€ç§æ›´ä¸ºä¸€è‡´çš„è¯­è¨€ã€‚
- en: Fast forward to the present, the GNU Compiler Collection (GCC) stands as a testament
    to the evolution of compilers, supporting not just multiple platforms, but also
    multiple languages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å¿«è¿›åˆ°ç°åœ¨ï¼ŒGNU ç¼–è¯‘å™¨é›†ï¼ˆGCCï¼‰æ˜¯ç¼–è¯‘å™¨å‘å±•æ¼”å˜çš„ä¸€ä¸ªè§è¯ï¼Œä¸ä»…æ”¯æŒå¤šä¸ªå¹³å°ï¼Œè¿˜æ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€ã€‚
- en: One of my favorite things about computer lore is that many of the most instrumental
    people are still alive today, and we still have records of when they made history.
    This is no different for GCC, and we actual have the text [Richard Stallman sent](https://gcc.gnu.org/wiki/History),
    introducing the GCC beta back in 87\.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å¯¹è®¡ç®—æœºä¼ è¯´çš„å…¶ä¸­ä¸€ä»¶å–œæ¬¢çš„äº‹æƒ…æ˜¯ï¼Œè®¸å¤šæœ€å…·å½±å“åŠ›çš„äººè‡³ä»Šä»ç„¶å¥åœ¨ï¼Œæˆ‘ä»¬ä»ç„¶è®°å½•ç€ä»–ä»¬åˆ›é€ å†å²çš„æ—¶åˆ»ã€‚å¯¹äº GCC æ¥è¯´ä¹Ÿä¸ä¾‹å¤–ï¼Œæˆ‘ä»¬å®é™…ä¸Šè¿˜æœ‰è®°å½•[ç†æŸ¥å¾·Â·æ–¯æ‰˜æ›¼å‘é€çš„æ–‡æœ¬](https://gcc.gnu.org/wiki/History)ï¼Œä»‹ç»äº†
    87 å¹´çš„ GCC beta ç‰ˆã€‚
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This feels like computer archeology to me.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è®©æˆ‘æ„Ÿè§‰åƒæ˜¯è¿›è¡Œè®¡ç®—æœºè€ƒå¤ã€‚
- en: 'Today, GCC is more than just a C compiler. Itâ€™s a Compiler Collection, and
    it supports these programming languages: C, C++, Objective-C, Objective-C++, Fortran,
    Ada, D, and Go. It has support for the most platforms, and the most CPU architectures
    out of all compilers today, and is still being actively developed.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ä»Šå¤©ï¼ŒGCC ä¸ä»…ä»…æ˜¯ä¸€ä¸ª C ç¼–è¯‘å™¨ã€‚å®ƒæ˜¯ä¸€ä¸ªç¼–è¯‘å™¨é›†åˆï¼Œæ”¯æŒè¿™äº›ç¼–ç¨‹è¯­è¨€ï¼šCã€C++ã€Objective-Cã€Objective-C++ã€Fortranã€Adaã€D
    å’Œ Goã€‚å®ƒæ”¯æŒæœ€å¤šçš„å¹³å°å’Œæœ€å¤šçš„ CPU æ¶æ„ï¼Œæ˜¯å½“ä»Šæ‰€æœ‰ç¼–è¯‘å™¨ä¸­ä»åœ¨ç§¯æå¼€å‘çš„ã€‚
- en: But GCC isnâ€™t the only cross platform industrial grade compiler on the block.
    LLVM provides a great experience as well, and benefits from decades of hindsight
    in compiler construction. It was created by Vikram Adve and his PhD student Chris
    Lattner at the [University of Illinois at Urbanaâ€“Champaign](https://en.wikipedia.org/wiki/University_of_Illinois_at_Urbana%E2%80%93Champaign)
    in 2000\. It started as a research project in December while Chris was on winter
    break. Over the course of the next year, Chris and Vikram continued to work on
    the compiler before publishing their first paper on it titled, [Automatic Pool
    Allocation for Disjoint Data Structures](https://llvm.org/pubs/2002-06-AutomaticPoolAllocation.pdf).
    Though they didnâ€™t know it at the time, they were making history. A lot had happened
    in the field of compilers by the early 2000s, and this allowed LLVM to enjoy many
    benefits.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ä½† GCC å¹¶ä¸æ˜¯å”¯ä¸€çš„è·¨å¹³å°å·¥ä¸šçº§ç¼–è¯‘å™¨ã€‚LLVM ä¹Ÿæä¾›äº†å¾ˆå¥½çš„ä½“éªŒï¼Œå¹¶å—ç›Šäºç¼–è¯‘å™¨æ„å»ºå‡ åå¹´çš„ç»éªŒã€‚å®ƒæ˜¯ç”± Vikram Adve å’Œä»–çš„åšå£«ç”Ÿ
    Chris Lattner åœ¨ 2000 å¹´åœ¨[ä¼Šåˆ©è¯ºä¼Šå¤§å­¦å„å·´çº³-é¦™æ§Ÿåˆ†æ ¡](https://en.wikipedia.org/wiki/University_of_Illinois_at_Urbana%E2%80%93Champaign)åˆ›å»ºçš„ã€‚å®ƒæ˜¯åœ¨
    Chris æ”¾å¯’å‡çš„ 12 æœˆå¼€å§‹çš„ç ”ç©¶é¡¹ç›®ã€‚åœ¨æ¥ä¸‹æ¥çš„ä¸€å¹´é‡Œï¼ŒChris å’Œ Vikram ç»§ç»­è‡´åŠ›äºè¯¥ç¼–è¯‘å™¨çš„å¼€å‘ï¼Œç„¶åå‘è¡¨äº†ä»–ä»¬çš„ç¬¬ä¸€ç¯‡å…³äºå®ƒçš„è®ºæ–‡ï¼Œæ ‡é¢˜ä¸º
    [Automatic Pool Allocation for Disjoint Data Structures](https://llvm.org/pubs/2002-06-AutomaticPoolAllocation.pdf)ã€‚å°½ç®¡å½“æ—¶ä»–ä»¬ä¸çŸ¥é“ï¼Œä½†ä»–ä»¬æ­£åœ¨åˆ›é€ å†å²ã€‚åˆ°äº†
    2000 å¹´ä»£åˆæœŸï¼Œç¼–è¯‘å™¨é¢†åŸŸå‘ç”Ÿäº†å¾ˆå¤šå˜åŒ–ï¼Œè¿™ä½¿å¾— LLVM èƒ½å¤Ÿäº«å—åˆ°è®¸å¤šå¥½å¤„ã€‚
- en: '**LLVM IR**'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**LLVM IR**'
- en: Front-end developers only need to understand LLVM IR, its workings, and invariants,
    making it easy to create new front ends for LLVM. Unlike other compilers like
    GCC, LLVM IR is self-contained, eliminating the need to manipulate complex data
    structures and global variables from other parts of the compiler
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‰ç«¯å¼€å‘äººå‘˜åªéœ€ç†è§£ LLVM IRï¼Œå…¶å·¥ä½œåŸç†å’Œä¸å˜æ€§ï¼Œå°±å¯ä»¥è½»æ¾åˆ›å»ºæ–°çš„ LLVM å‰ç«¯ã€‚ä¸å…¶ä»–ç¼–è¯‘å™¨ï¼ˆå¦‚ GCCï¼‰ä¸åŒï¼ŒLLVM IR æ˜¯è‡ªåŒ…å«çš„ï¼Œæ— éœ€ä»ç¼–è¯‘å™¨çš„å…¶ä»–éƒ¨åˆ†æ“ä½œå¤æ‚çš„æ•°æ®ç»“æ„å’Œå…¨å±€å˜é‡
- en: '**Modular Library-Based Design**'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**æ¨¡å—åŒ–åŸºäºåº“çš„è®¾è®¡**'
- en: The LLVM infrastructure consists of loosely coupled libraries instead of a monolith,
    including the optimizer, allowing developers to choose and order optimization
    passes for their specific needs. Only the necessary optimization passes are linked
    into the final application, optimizing compile times and avoiding unnecessary
    bloat
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM åŸºç¡€æ¶æ„ç”±æ¾æ•£è€¦åˆçš„åº“ç»„æˆï¼Œè€Œä¸æ˜¯å•å—ï¼ŒåŒ…æ‹¬ä¼˜åŒ–å™¨ï¼Œå…è®¸å¼€å‘äººå‘˜ä¸ºå…¶ç‰¹å®šéœ€æ±‚é€‰æ‹©å’Œæ’åºä¼˜åŒ–ä¼ é€’ã€‚åªæœ‰å¿…è¦çš„ä¼˜åŒ–ä¼ é€’æ‰ä¼šé“¾æ¥åˆ°æœ€ç»ˆåº”ç”¨ç¨‹åºä¸­ï¼Œä¼˜åŒ–ç¼–è¯‘æ—¶é—´å¹¶é¿å…ä¸å¿…è¦çš„è†¨èƒ€
- en: '**Retargetable Code Generator**'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**å¯é‡æ–°å®šä½çš„ä»£ç ç”Ÿæˆå™¨**'
- en: The LLVM code generator transforms LLVM IR into target specific machine code.
    It employs a modular approach with individual passes for instruction selection,
    register allocation, scheduling, code layout optimization, and assembly emission.
    This flexibility enables target-specific optimizations, such as register pressure
    reduction for x86 and latency optimization for PowerPC, without requiring a complete
    code generator rewrite
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM ä»£ç ç”Ÿæˆå™¨å°† LLVM IR è½¬æ¢ä¸ºç‰¹å®šç›®æ ‡çš„æœºå™¨ä»£ç ã€‚å®ƒé‡‡ç”¨æ¨¡å—åŒ–æ–¹æ³•ï¼Œä¸ºæŒ‡ä»¤é€‰æ‹©ã€å¯„å­˜å™¨åˆ†é…ã€è°ƒåº¦ã€ä»£ç å¸ƒå±€ä¼˜åŒ–å’Œæ±‡ç¼–å‘å°„æä¾›å•ç‹¬çš„ä¼ é€’ã€‚è¿™ç§çµæ´»æ€§ä½¿å¾—å¯ä»¥é’ˆå¯¹ç‰¹å®šç›®æ ‡è¿›è¡Œä¼˜åŒ–ï¼Œä¾‹å¦‚ä¸º
    x86 å‡å°‘å¯„å­˜å™¨å‹åŠ›å’Œä¸º PowerPC ä¼˜åŒ–å»¶è¿Ÿï¼Œè€Œæ— éœ€å®Œå…¨é‡å†™ä»£ç ç”Ÿæˆå™¨
- en: And lastly itâ€™s 13 years younger than GCC, and benefits from not having to support
    as many architectures. This means that this, along with LLVMâ€™s modular natures,
    allows LLVMâ€™s code base to be about 3.5 times smaller than GCC (5million vs 1.6
    million lines of code). While these numbers might seem staggering, it pales in
    comparison to the mighty Ford F150 which has 150 million lines of code much of
    which is compiled with LLVM and GCC Iâ€™m sure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œå®ƒæ¯” GCC å¹´è½» 13 å¹´ï¼Œå¹¶ä¸”å—ç›Šäºä¸å¿…æ”¯æŒå¤ªå¤šæ¶æ„ã€‚è¿™æ„å‘³ç€è¿™ä¸ªï¼Œä»¥åŠ LLVM çš„æ¨¡å—åŒ–ç‰¹æ€§ï¼Œä½¿å¾— LLVM çš„ä»£ç åº“çº¦ä¸º GCC çš„ 3.5
    å€å°ï¼ˆ500 ä¸‡ vs 160 ä¸‡è¡Œä»£ç ï¼‰ã€‚å°½ç®¡è¿™äº›æ•°å­—çœ‹èµ·æ¥ä»¤äººéœ‡æƒŠï¼Œä½†ä¸æ‹¥æœ‰ 1.5 äº¿è¡Œä»£ç çš„å¼ºå¤§çš„ Ford F150 ç›¸æ¯”ï¼Œå®ƒæ˜¾å¾—å¾®ä¸è¶³é“ï¼Œå…¶ä¸­å¾ˆå¤šä»£ç éƒ½æ˜¯ä½¿ç”¨
    LLVM å’Œ GCC ç¼–è¯‘çš„ï¼Œæˆ‘ç›¸ä¿¡ã€‚
- en: But while LLVM might be newer, it still faces stiff competition from GCC. Both
    GCC and LLVM support many modern C and C++ standards, and they both have a large
    suite of tools for working with their output. In the great article by Jeremy Bennett
    titled [How Much Does a Compiler Cost?](https://www.embecosm.com/2018/02/26/how-much-does-a-compiler-cost/)
    We see the many tools that these compilers bring, as well as the hundreds of thousands
    of lines of code it takes to create the supporting software suite.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å°½ç®¡ LLVM å¯èƒ½è¾ƒæ–°ï¼Œä½†ä»ç„¶é¢ä¸´æ¥è‡ª GCC çš„æ¿€çƒˆç«äº‰ã€‚GCC å’Œ LLVM éƒ½æ”¯æŒè®¸å¤šç°ä»£ C å’Œ C++ æ ‡å‡†ï¼Œå¹¶ä¸”å®ƒä»¬éƒ½æœ‰å¤§é‡çš„å·¥å…·å¥—ä»¶ç”¨äºå¤„ç†å®ƒä»¬çš„è¾“å‡ºã€‚åœ¨
    Jeremy Bennett æ’°å†™çš„ä¸€ç¯‡åä¸º [ä¸€ä¸ªç¼–è¯‘å™¨æˆæœ¬å¤šå°‘é’±ï¼Ÿ](https://www.embecosm.com/2018/02/26/how-much-does-a-compiler-cost/)
    çš„ç²¾å½©æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è¿™äº›ç¼–è¯‘å™¨å¸¦æ¥çš„è®¸å¤šå·¥å…·ï¼Œä»¥åŠåˆ›å»ºæ”¯æŒè½¯ä»¶å¥—ä»¶æ‰€éœ€çš„æ•°åä¸‡è¡Œä»£ç ã€‚
- en: '**Debugger:** Either GDB (800k lines) or LLDB (600k lines)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**è°ƒè¯•å™¨ï¼š** å¯é€‰ GDBï¼ˆ800k è¡Œï¼‰æˆ– LLDBï¼ˆ600k è¡Œï¼‰'
- en: '**Linker:** GNU ld (160k lines), gold (140k lines) or lld (60k lines)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**é“¾æ¥å™¨ï¼š** GNU ldï¼ˆ160k è¡Œï¼‰ï¼Œgoldï¼ˆ140k è¡Œï¼‰æˆ– lldï¼ˆ60k è¡Œï¼‰'
- en: '**Assembler/disassembler:** GNU gas (850k lines) or the built in LLVM assembler'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ±‡ç¼–å™¨/åæ±‡ç¼–å™¨ï¼š** GNU gasï¼ˆ850k è¡Œï¼‰æˆ–å†…ç½® LLVM æ±‡ç¼–å™¨'
- en: '**Binary utilities:** GNU (90k lines) and/or LLVM (included in main LLVM source)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**äºŒè¿›åˆ¶å®ç”¨ç¨‹åºï¼š** GNUï¼ˆ90k è¡Œï¼‰å’Œ/æˆ– LLVMï¼ˆåŒ…å«åœ¨ä¸» LLVM æºä»£ç ä¸­ï¼‰'
- en: '**Emulation library:** libgcc (included in GCC source) or CompilerRT (340k
    lines)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ¨¡æ‹Ÿåº“ï¼š** libgccï¼ˆåŒ…å«åœ¨ GCC æºä»£ç ä¸­ï¼‰æˆ– CompilerRTï¼ˆ340k è¡Œï¼‰'
- en: '**Standard C library:** newlib (850k lines), glibc (1.2M lines), musl (82k
    lines) or uClibC-ng (251k lines)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ ‡å‡† C åº“ï¼š** newlibï¼ˆ850k è¡Œï¼‰ï¼Œglibcï¼ˆ1.2M è¡Œï¼‰ï¼Œmuslï¼ˆ82k è¡Œï¼‰æˆ– uClibC-ngï¼ˆ251k è¡Œï¼‰'
- en: In Matt Godboltâ€™s CppCon talk titled *What Has My Compiler Done for Me Lately?
    Unbolting the Compiler's Lid*, we see how many of the clever optimization tricks
    we used to need to do in code, can be done at the compiler level. This allows
    us to have simpler and easier to maintain code, without making tradeoffs on performance
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Matt Godbolt çš„ CppCon æ¼”è®²ä¸­ï¼Œæ ‡é¢˜ä¸º *æˆ‘çš„ç¼–è¯‘å™¨æœ€è¿‘ä¸ºæˆ‘åšäº†ä»€ä¹ˆï¼Ÿè§£å¼€ç¼–è¯‘å™¨çš„ç›–å­*ï¼Œæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬æ›¾ç»éœ€è¦åœ¨ä»£ç ä¸­æ‰§è¡Œçš„è®¸å¤šå·§å¦™ä¼˜åŒ–æŠ€å·§å¯ä»¥åœ¨ç¼–è¯‘å™¨çº§åˆ«å®Œæˆã€‚è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿæ‹¥æœ‰æ›´ç®€å•ã€æ›´æ˜“äºç»´æŠ¤çš„ä»£ç ï¼Œè€Œä¸ä¼šåœ¨æ€§èƒ½ä¸Šåšå‡ºå¦¥å
- en: Iâ€™m grateful for all the work compilers maintainers have put in optimizing our
    programs. Weâ€™ve come a long way to get here, and have built upon decades of hard
    won programming experience to come up with the robust solutions we have today.
    As our programming languages continue to evolve, our compilers will be right their
    with us, tirelessly optimizing our code and catching bugs, so we can get the best
    performance we can
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å¾ˆæ„Ÿæ¿€ç¼–è¯‘å™¨ç»´æŠ¤è€…ä¸ºä¼˜åŒ–æˆ‘ä»¬çš„ç¨‹åºæ‰€ä»˜å‡ºçš„æ‰€æœ‰å·¥ä½œã€‚æˆ‘ä»¬å·²ç»èµ°è¿‡äº†å¾ˆé•¿çš„è·¯ç¨‹ï¼Œå¹¶ä¸”åœ¨å‡ åå¹´çš„è‰°è‹¦ç¼–ç¨‹ç»éªŒåŸºç¡€ä¸Šå»ºç«‹äº†æˆ‘ä»¬ä»Šå¤©æ‹¥æœ‰çš„å¼ºå¤§è§£å†³æ–¹æ¡ˆã€‚éšç€æˆ‘ä»¬çš„ç¼–ç¨‹è¯­è¨€ä¸æ–­å‘å±•ï¼Œæˆ‘ä»¬çš„ç¼–è¯‘å™¨ä¹Ÿå°†ä¸æˆ‘ä»¬ä¸€èµ·ï¼Œä¸çŸ¥ç–²å€¦åœ°ä¼˜åŒ–æˆ‘ä»¬çš„ä»£ç å¹¶æ•æ‰é”™è¯¯ï¼Œä»¥ä¾¿æˆ‘ä»¬èƒ½å¤Ÿè·å¾—æœ€ä½³æ€§èƒ½ã€‚
- en: Hi ğŸ‘‹ my name is Diego Crespo and I like to talk about technology, niche programming
    languages, and AI. I have a [Twitter](https://twitter.com/deusinmach) and a [Mastodon](https://mastodon.social/deck/@DiegoCrespo),
    if youâ€™d like to follow me on other social media platforms. If you liked the article,
    consider liking and subscribing. And if you havenâ€™t why not check out another
    article of mine listed below! Thank you for reading and giving me a little of
    your valuable time. A.M.D.G
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: å—¨ ğŸ‘‹ æˆ‘çš„åå­—æ˜¯è¿­æˆˆÂ·å…‹é›·æ–¯æ³¢ï¼Œæˆ‘å–œæ¬¢è°ˆè®ºæŠ€æœ¯ã€å°ä¼—ç¼–ç¨‹è¯­è¨€å’Œäººå·¥æ™ºèƒ½ã€‚æˆ‘æœ‰ä¸€ä¸ª[Twitter](https://twitter.com/deusinmach)å’Œä¸€ä¸ª[Mastodon](https://mastodon.social/deck/@DiegoCrespo)ï¼Œå¦‚æœä½ æƒ³åœ¨å…¶ä»–ç¤¾äº¤åª’ä½“å¹³å°ä¸Šå…³æ³¨æˆ‘ã€‚å¦‚æœä½ å–œæ¬¢è¿™ç¯‡æ–‡ç« ï¼Œè¯·è€ƒè™‘ç‚¹èµå’Œè®¢é˜…ã€‚å¦‚æœä½ è¿˜æ²¡æœ‰ï¼Œä¸ºä»€ä¹ˆä¸çœ‹çœ‹æˆ‘ä¸‹é¢åˆ—å‡ºçš„å¦ä¸€ç¯‡æ–‡ç« å‘¢ï¼è°¢è°¢ä½ èŠ±æ—¶é—´é˜…è¯»å¹¶ç»™äºˆæˆ‘å®è´µçš„æ—¶é—´ã€‚A.M.D.G
- en: '[Share](https://www.deusinmachina.net/p/compiling-history-a-brief-tour-of?utm_source=substack&utm_medium=email&utm_content=share&action=share)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[åˆ†äº«](https://www.deusinmachina.net/p/compiling-history-a-brief-tour-of?utm_source=substack&utm_medium=email&utm_content=share&action=share)'
- en: '[Share Deus In Machina](https://www.deusinmachina.net/?utm_source=substack&utm_medium=email&utm_content=share&action=share)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[åˆ†äº« Deus In Machina](https://www.deusinmachina.net/?utm_source=substack&utm_medium=email&utm_content=share&action=share)'
