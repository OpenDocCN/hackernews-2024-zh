["```\nimport requests\n\n# Basic HTTP GET\nurl: str = \"https://requests.readthedocs.io/en/latest/\"\nr = requests.get(url)\nprint(r.text)\n\n# Does the right thing with TLS\nurl: str = \"https://expired.badssl.com/\"\ntry:\n   r = requests.get(url)\nexcept requests.exceptions.SSLError:\n   print(\"Unable to verify expired certificate\")\n\n# POSTing JSON data easily without having to encode it yourself or specify\n# headers\nurl: str = \"https://httpbin.org/post\"\nr = requests.post(url, json={\"some\": \"data\"}) \n```", "```\nimport requests\n\ns: requests.Session = requests.Session()\nurl: str = \"https://httpbin.org/post\"\nr = s.post(url, data={\"urlencode\", \"me\"}) \n```", "```\nimport requests\n\ns: requests.Session = requests.Session()\nurl: str = \"https://httpbin.org/post\"\n# Let's just send a file\nr = s.post(url, files={\"fileA\": open(filename, \"rb\")})\n# NOTE: Do not use files this way, this is purely for simplicity of example\n# code\n\n# Let's send a file and some other form elements\nr = s.post(\n   url,\n   data={\"wait\": \"is this urlencoded too?\"},\n   files={\"fileA\": open(filename, \"rb\")},\n)\n\n# Let's send two form fields, a basic file, and then a file with a custom\n# name, custom part content-type, and additional custom headers for the\n# part\nr = s.post(\n   url,\n   data={\"wait\": \"is this urlencoded too?\", \"form-encoded\": \"no\"},\n   files={\n      \"fileA\": open(filename, \"rb\"),\n      \"fileB\": (\n         \"custom-filename.xml\",\n         open(other_filename, \"rb\"),\n         \"application/xml\",\n         {\"X-Custom-Part-Header\": \"value\"},\n   },\n) \n```", "```\nContent-Length: ...\nContent-Type: multipart/form-data; boundary=---------------------------9051914041544843365972754266\n\n-----------------------------9051914041544843365972754266\nContent-Disposition: form-data; name=\"wait\"\n\nis this urlencoded too?\n-----------------------------9051914041544843365972754266\nContent-Disposition: form-data; name=\"form-encoded\"\n\nno\n-----------------------------9051914041544843365972754266\nContent-Disposition: form-data; name=\"fileA\"; filename=\"a.txt\"\nContent-Type: text/plain\n\nContent of a.txt.\n\n-----------------------------9051914041544843365972754266\nContent-Disposition: form-data; name=\"fileB\"; filename=\"custom-filename.xml\"\nContent-Type: application/xml\nX-Custom-Part-Header: value\n\n<root><elems><elem>Item</elem></elems></root>\n\n-----------------------------9051914041544843365972754266-- \n```", "```\nimport requests\n\ns: requests.Session = requests.Session()\nurl: str = \"https://httpbin.org/post\"\n# This is broken, if you see this searching for how to handle things, don't\n# copy this but read below\nr = s.post(url, json={\"a\": \"b\"}, files={\"fileA\": open(filename, \"rb\")}) \n```", "```\nimport requests\n\ns: requests.Session = requests.Session()\nurl: str = \"https://httpbin.org/post\"\n# This is broken, if you see this searching for how to handle things, don't\n# copy this but read below\nr = s.post(url, json={\"a\": \"b\"}, headers={\"Content-Type\": \"application/xml\"})\nr = s.post(url, files={\"a\": open(filename, \"rb\")}, headers={\"Content-Type\": \"multipart/form-data\"})\nr = s.post(url, data={\"form\": \"encoded\"}, headers={\"Content-Type\": \"multipart/form-data\"})\nr = s.post(url, data={\"form\": \"encoded\"}, headers={\"Content-Length\": \"1000000\"})\n# This may not do what some people expect. Many people tend to expect this\n# to  **replace** c=d to the query string, but instead it appends c=e so\n# the query string becomes a=b&c=d&c=e. In reality, there's no intuitive\n# behaviour here for everyone\nr = s.post(\"https://httpbin.org/get?a=b&c=d\", params={\"c\": \"e\"}) \n```", "```\nSet-Cookie: sessionId=38afes7a8; Domain=example.com; Path=/user/home; HttpOnly; Secure; SameSite=strict \n```", "```\nSet-Cookie: sessionId=29bedt6b9; Domain=google.com; Path=/; HttpOnly; Secure; SameSite=strict \n```", "```\nimport requests\n\nurl: str = \"...\"\ns: requests.Session = requests.Session()\n# Timeout if connecting to the remote takes more than 2 seconds, or if it\n# takes more than 2 seconds for the remote to write bytes in response\nr = s.get(url, timeout=2)\n# Timeout after 2s during connect, after 10s if no data written\nr = s.get(url, timeout=(2, 10)) \n```", "```\n; <<>> DiG 9.18.20 <<>> salesforce.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 22322\n;; flags: qr rd ra; QUERY: 1, ANSWER: 8, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 65494\n;; QUESTION SECTION:\n;salesforce.com.                        IN      A\n\n;; ANSWER SECTION:\nsalesforce.com.         120     IN      A       184.31.10.133\nsalesforce.com.         120     IN      A       184.31.3.130\nsalesforce.com.         120     IN      A       104.109.10.129\nsalesforce.com.         120     IN      A       184.25.179.132\nsalesforce.com.         120     IN      A       23.1.35.132\nsalesforce.com.         120     IN      A       23.1.99.130\nsalesforce.com.         120     IN      A       104.109.11.129\nsalesforce.com.         120     IN      A       23.1.106.133\n\n;; Query time: 63 msec\n;; MSG SIZE  rcvd: 171 \n```", "```\nrequests.exceptions.SSLError: HTTPSConnectionPool(host='expired.badssl.com', port=443): Max retries exceeded with url: / (Caused by SSLError (SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: certificate has expired (_ssl.c:1000)'))) \n```", "```\n>>> sslerr\nSSLError(MaxRetryError(\"HTTPSConnectionPool(host='expired.badssl.com', port=443): Max retries exceeded with url: / (Caused by SSLError(SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: certificate has expired (_ssl.c:1000)')))\"))\n>>> sslerr.args\n(MaxRetryError(\"HTTPSConnectionPool(host='expired.badssl.com', port=443): Max retries exceeded with url: / (Caused by SSLError(SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: certificate has expired (_ssl.c:1000)')))\"),)\n>>> sslerr.args[0]\nMaxRetryError(\"HTTPSConnectionPool(host='expired.badssl.com', port=443): Max retries exceeded with url: / (Caused by SSLError(SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: certificate has expired (_ssl.c:1000)')))\")\n>>> sslerr.args[0].args\n\"HTTPSConnectionPool(host='expired.badssl.com', port=443): Max retries exceeded with url: / (Caused by SSLError(SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: certificate has expired (_ssl.c:1000)')))\" \n```", "```\nimport  \"net/http\"\n\ntype  CustomTransport  struct  {\n  T  http.RoundTripper\n}\n\nfunc  (t  CustomTransport)  RoundTrip(req  *http.Request)  (*http.Response,  error)  {\n  newReq  :=  modifyRequest(req)\n  return  t.T.RoundTrip(req)\n}\n\nfunc  modifyRequest(req  *http.Request)  *http.Request  {\n  reqCopy  :=  new(http.Request)\n  *reqCopy  =  *req\n  // Do something with copy\n  return  reqCopy\n}\n\nfunc  main()  {\n  client  :=  &http.Client{\n  Transport:  CustomTransport{http.DefaultClient.Transport},\n  }\n} \n```", "```\nimport ssl\n\nimport requests\nfrom requests.proxies import Proxies Proxy\n\nproxy_ssl_context = ssl.SSLContext()\nproxy_ssl_context.load_verify_location(cafile=\"/etc/pki/corp.net/cacerts.pem\")\nproxy_ssl_context.verify_mode = ssl.CERT_REQUIRED\n\nurl: str = \"...\"\nproxies = Proxies.from_dict({\n   \"http\": \"http://plain.proxy\",\n   \"https\": Proxy(\n      uri=\"https://encrypted.proxy\",\n      ssl_context=proxy_ssl_context,\n   ),\n})\nr: requests.Response = requests.get(url, proxies=proxies) \n```"]