["```\nvoid\nprint_strings(std::convertible_to<std::string_view> auto&& ...s)\n{\n for (auto v : std::initializer_list<std::string_view>{ s... })\n std::cout << v << \" \";\n std::cout << std::endl;\n}\n\nint\nmain()\n{\n print_strings(\"one\", std::string{\"two\"});\n}\n```", "```\nvoid dummy(auto&&...) {}\n\ntemplate<std::same_as<char> ...C>\nvoid\nexpand(C...c)\n{\n std::tuple<C...> tpl(c...);\n\n const char msg[] = { C(std::toupper(c))..., '\\0' };\n dummy(msg, c...);\n}\n```", "```\n     template<typename ...Base>\n     struct MyStruct :  Base... {\n     MyStruct();\n     };\n    ```", "```\n     template<typename ...Base>\n     MyStruct<Base...>::MyStruct() : Base()... {}\n    ```", "```\n     void\n     f(auto...arg)\n     {\n     auto with_copy = [arg...]{\n     /* do something with arg... */\n     };\n     with_copy();\n\n     auto with_reference = [&arg...]{\n     /* do something with arg... */\n     };\n     with_reference();\n     }\n    ```", "```\n     template<typename ...T> struct Outer {\n     template<T...V> struct Inner {\n     };\n     };\n    ```", "```\n     template<std::size_t ...N>\n     void process_strings(const char (&...s)[N]) { /* ... */ }\n     // conceptually like:\n     // process_strings(const char s1[N1], const char s2[N2], etc.)\n\n     template<typename ...T>\n     auto function_results(T (&...f)()) { return std::tuple(f()...); }\n     // conceptually like:\n     // function_results(T1(&f1)(), T2(&f2)(), etc.)\n    ```", "```\n     template<typename ...Base>\n     struct MyStruct :  Base... {\n     MyStruct();\n     using Base::f...;\n     // Conceptually equivalent to:\n     //   using Base_1::f;\n     //   using Base_2::f;\n     //   ...\n     };\n    ```", "```\n     template<typename ...T>\n     struct alignas(T...) storage {\n     char contents[std::max({ sizeof(T)... })];\n     };\n    ```", "```\n constexpr int\n sum(std::convertible_to<int> auto ...il)\n {\n int r = 0;\n for (int i : { int(il)... })\n r += i;\n return r;\n }\n\n template<int ...N>\n struct Nested {\n static constexpr int nested_sum(auto ...v) {\n return sum(sum(N..., v)...);\n }\n };\n\n static_assert(Nested<1>::nested_sum(100, 200) == 302);\n // Equivalent to:  sum(sum(1, 100),sum(1, 200)) == 302\n```", "```\n constexpr int\n sum(std::convertible_to<int> auto ...i)\n {\n return (0 + ... + i);\n }\n```", "```\n template<typename ...T> struct S1{};\n template<int ...I> struct S2{};\n template<template<typename> typename ...Tmpls> struct S3{};\n```", "```\n // Illegal for pack not to be last\n template<typename ...T1, typename ...T2> struct S{}; // error\n S<int, int, bool> a;  // If this were legal, what would T1 and T2 be?\n\n // Okay to put ...Tmpls first because T inferred from function argument\n template<template<typename...> typename ...Tmpls, typename T>\n auto\n ptr_tuple(const T &v)\n {\n // Exception-safe since C++17 (see P0145R3)\n return std::tuple(Tmpls<T>(new T(v))...);\n }\n auto ones = ptr_tuple<std::shared_ptr, std::unique_ptr>(1);\n\n using std::tuple;\n\n template<typename T1, typename T2, typename T3>\n struct is_tuple_cat : std::false_type {};\n\n // Okay for ...T1 not to be last in specialization\n template<typename ...T1, typename ...T2>\n struct is_tuple_cat<tuple<T1...>, tuple<T2...>, tuple<T1..., T2...>>\n : std::true_type {};\n\n static_assert(is_tuple_cat<tuple<int>, tuple<char*>, tuple<int, char*>>{});\n static_assert(!is_tuple_cat<tuple<int>, tuple<char*>, tuple<int, bool>>{});\n```", "```\n template<> constexpr int\n sum(int ...i)  // illegal\n {\n return (0 + ... + i);\n }\n```", "```\n int printf(const char *, ...);  // better way, required by C\n int printf(const char *...);    // 1983 C++ way, before C had prototypes\n```", "```\n int f1(std::same_as<int> auto ...i);\n int f2(std::convertible_to<int> auto ...i);\n```", "```\n struct Obj { void use() { /* ... */ } /* ... */ };\n\n void good() {}\n void good(Obj o1) { o1.use(); }\n void good(Obj o1, Obj o2) { o1.use(); o2.use(); }\n // ...\n\n void\n bad(std::convertible_to<Obj> auto&& ...o)\n {\n // Unary fold over comma\n (Obj{std::forward<decltype(o)>(o)}.use(), ...);\n }\n```", "```\n template<std::convertible_to<std::string> ...T>\n auto\n make_prefixer(T&& ...args)\n {\n using namespace std::string_literals;\n return [...p=std::string(std::forward<T>(args))](std::string  msg) {\n // binary right fold over +\n return ((p + \": \"s + msg + \"\\n\"s) + ... + \"\"s);\n };\n }\n\n int\n main()\n {\n auto p = make_prefixer(\"BEGIN\", \"END\");\n std::cout << p(\"message\");\n // prints:\n // BEGIN: message\n // END: message\n }\n```", "```\n#include <algorithm>\n#include <array>\n#include <concepts>\n#include <initializer_list>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <variant>\n```", "```\ninline void\nprintall()\n{\n}\n\nvoid\nprintall(const auto &first, const auto &...rest)\n{\n std::cout << first;\n printall(rest...);\n}\n```", "```\nvoid\nprintall2(const auto &...args)\n{\n // binary left fold\n (std::cout << ... << args);\n}\n```", "```\ntemplate<char ...Cs>\nstruct string_holder {\n static constexpr std::size_t  len = sizeof...(Cs);\n static constexpr char value[] = { Cs..., '\\0' };\n constexpr operator const char *() const { return value; }\n constexpr operator std::string() const { return { value, len }; }\n};\n\ntemplate<size_t N, char...Cs>\nconsteval auto\nindex_string()\n{\n if constexpr (N < 10)\n return string_holder<N+'0', Cs...>{};\n else\n return index_string<N/10, (N%10)+'0', Cs...>();\n}\n\n// \"10\"\nconstinit const char *ten = index_string<10>();\n```", "```\ntemplate<char ...Out>\nconsteval auto\nadd_commas(string_holder<>, string_holder<Out...> out)\n{\n return out;\n}\n\ntemplate<char In0, char ...InRest, char ...Out>\nconsteval auto\nadd_commas(string_holder<In0, InRest...>, string_holder<Out...> = {})\n{\n if constexpr (sizeof...(InRest) % 3 == 0 && sizeof...(InRest) > 0)\n return add_commas(string_holder<InRest...>{},\n string_holder<Out..., In0, ','>{});\n else\n return add_commas(string_holder<InRest...>{},\n string_holder<Out..., In0>{});\n}\n\n// \"1,000,000\"\nconstinit const char *million = add_commas(index_string<1'000'000>());\n```", "```\ntemplate<typename T, typename ...E>\nvoid\nmulti_insert(T &t, E&&...e)\n{\n // unary right fold over comma\n (void(t.insert(std::forward<E>(e))), ...);\n}\n\nint\nmain()\n{\n std::set<int> s;\n multi_insert(s, 1, 4, 7, 10);\n for (auto i : s)\n std::cout << i << \" \";\n std::cout << std::endl;\n // prints:\n // 1 4 7 10\n}\n```", "```\nvoid(t.insert(std::forward<E>(e))), ...;  // error: bad fold\nt.insert(std::forward<E>(e))...;  // error: bad expansion context\n```", "```\ntemplate<typename T, typename F>\nstd::size_t\ntuple_find(const T &t, F &&f)\n{\n return std::apply([&f](const auto &...e) {\n std::size_t  r = 0;\n ((std::forward<F>(f)(e) || (++r, false)) || ...);\n return r;\n }, t);\n}\n\nint\nmain()\n{\n std::tuple  t(-2, -1, 0U, 1UL, 2ULL);\n std::cout << tuple_find(t, [](auto i) {\n return std::cmp_greater(i, -1);\n }) << std::endl;\n // prints:\n // 2\n}\n```", "```\nauto\ntuple_mult(auto scalar, auto tpl)\n{\n return apply([&scalar]<typename ...T>(T...t) {\n return std::tuple(T(scalar * t)...);\n }, tpl);\n}\n\nint\nmain()\n{\n auto t = std::tuple(1, 2U, 4.0);\n t = tuple_mult(2, t);\n std::cout << get<0>(t) << \" \"\n << get<1>(t) << \" \"\n << get<2>(t) << std::endl;\n // prints:\n // 2 4 8\n}\n```", "```\ntemplate<typename T>\nauto\ntuple_add(const T &a, const T&b)\n{\n return [&a, &b]<std::size_t ...I>(std::index_sequence<I...>) {\n return std::tuple(get<I>(a) + get<I>(b)...);\n }(std::make_index_sequence<std::tuple_size_v<T>>{});\n}\n\nint\nmain()\n{\n auto t = std::tuple(1, 2U, 4.0);\n t = tuple_add(t, tuple_mult(10, t));\n std::cout << get<0>(t) << \" \"\n << get<1>(t) << \" \"\n << get<2>(t) << std::endl;\n // prints:\n // 11 22 44\n}\n```", "```\nconstexpr int\nhexdigit(char c)\n{\n if (c >= '0' && c <= '9')\n return c - '0';\n c |= 0x20;            // convert upper- to lower-case\n if (c >= 'a' && c <= 'f')\n return c - ('a' - 10);\n return -1;            // invalid\n}\n\ntemplate<char ...C>\nrequires (sizeof...(C)%2 == 0)\nconstexpr std::string\noperator\"\"_hex()\n{\n constexpr std::array  digits{ C... };\n std::string  result{};\n for (std::size_t  i = 2; i < digits.size(); i += 2)\n result += char(hexdigit(digits[i])<<4 | hexdigit(digits[i+1]));\n return result;\n}\n\nint\nmain()\n{\n std::cout << 0x48656c6c6f21_hex << std::endl;\n // prints:\n // Hello!\n}\n```", "```\ntemplate<char ...C>\nrequires (sizeof...(C)%2 == 0 &&\n [](char zero, char x, auto ...rest) {\n return zero == '0' && x == 'x' && ((hexdigit(rest) != -1) && ...);\n }(C...))\nconstexpr std::string\noperator\"\"_hex()\n{\n constexpr std::array  digits{ C... };\n std::string  result{};\n for (std::size_t  i = 2; i < digits.size(); i += 2)\n result += char(hexdigit(digits[i])<<4 | hexdigit(digits[i+1]));\n return result;\n}\n```", "```\ntemplate<char ...C>\nrequires (sizeof...(C)%2 == 0 &&\n [](char zero, char x, auto ...rest) {\n return zero == '0' && x == 'x' && ((hexdigit(rest) != -1) && ...);\n }(C...))\nconsteval auto\noperator\"\"_hex()\n{\n return []<std::size_t ...I>(std::index_sequence<I...>) {\n constexpr std::array  digits{ C... };\n return string_holder<hexdigit(digits[2*I+2])<<4 |\n hexdigit(digits[2*I+3])...>{};\n }(std::make_index_sequence<sizeof...(C)/2-1>{});\n}\n```", "```\n// Clunky idiom with helper types\nnamespace detail {\n\ntemplate<typename T> struct tuple_ptr_helper;\n\ntemplate<typename ...T>\nstruct tuple_ptr_helper<std::tuple<T...>> {\n using type = std::tuple<T*...>;\n};\n\n} // namespace detail\n\ntemplate<typename T> using tuple_ptrs =\n typename detail::tuple_ptr_helper<T>::type;\n\nstatic_assert(std::is_same_v<tuple_ptrs<std::tuple<int, char>>,\n std::tuple<int*, char*>>);\n```", "```\ntemplate<typename T> using tuple_ptrs =\n decltype(std::apply([](auto ...t) { return std::tuple(&t...); },\n std::declval<T>()));\n```", "```\ntemplate<typename ...L>\nstruct multilambda : L... {\n using L::operator()...;\n constexpr multilambda(L...lambda) : L(std::move(lambda))... {}\n};\n\nint\nmain()\n{\n using namespace std::string_literals;\n std::tuple  t (1, true, \"hello\"s, 3.0);\n constexpr multilambda action {\n [](int i) { std::cout << i << std::endl; },\n [](double d) { std::cout << d << std::endl; },\n [](bool b) { std::cout << (b ? \"yes\\n\" : \"no\\n\"); },\n [](std::string  s) { std::cout << s.size() << \" bytes\\n\"; },\n };\n apply([action](auto ...v) {\n (action(v), ...);  // unary right fold\n }, t);\n // prints:\n // 1\n // yes\n // 5 bytes\n // 3\n}\n```", "```\ntemplate<typename T, template<typename...> typename Tmpl>\nconcept is_template = decltype(multilambda{\n []<typename ...U>(const Tmpl<U...> &) { return std::true_type{}; },\n [](const auto &) { return std::false_type{}; },\n }(std::declval<T>()))::value;\n\nstatic_assert(is_template<std::tuple<int, long>, std::tuple>);\nstatic_assert(is_template<const std::tuple<int, long> &, std::tuple>);\nstatic_assert(!is_template<std::tuple<int, long>, std::variant>);\n```", "```\ntemplate<typename ...Lambdas>\nstruct multilambda : Lambdas... {\n using Lambdas::operator()...;\n};\ntemplate<typename ...Lambdas>\nmultilambda(Lambdas...) -> multilambda<Lambdas...>;\n```", "```\ntemplate<typename ...T> struct HList;\n\ntemplate<>\nstruct HList<> {\n static constexpr std::size_t  len = 0;\n};\n\ntemplate<typename T0, typename ...TRest>\nstruct HList<T0, TRest...> : HList<TRest...> {\n using head_type = T0;\n using tail_type = HList<TRest...>;\n\n static constexpr std::size_t  len = 1 + sizeof...(TRest);\n [[no_unique_address]] head_type value_{};\n\n constexpr HList() = default;\n template<typename U0, typename ...URest>\n constexpr HList(U0 &&u0, URest &&...urest)\n : tail_type(std::forward<URest>(urest)...),\n value_(std::forward<U0>(u0)) {}\n\n head_type &head() & { return value_; }\n const head_type &head() const& { return value_; }\n head_type &&head() && { return value_; }\n\n tail_type &tail() & { return *this; }\n const tail_type &tail() const& { return *this; }\n tail_type &&tail() && { return *this; }\n};\n// User-defined class template argument deduction guide:\ntemplate<typename ...T> HList(T...) -> HList<T...>;\n\ntemplate<std::size_t  N> struct dummy{};\nstatic_assert(sizeof(HList<dummy<0>, dummy<1>, dummy<2>>) == 1);\nstatic_assert(sizeof(HList<dummy<0>, dummy<0>, dummy<0>>) == 3);\n```", "```\nstruct Base {}; // empty\n\nstruct Derived : Base {\n /* ... unspecified ... */\n};\n```", "```\ntemplate<std::size_t  N, is_template<HList> HL>\nrequires (N <= std::remove_cvref_t<HL>::len)\ninline decltype(auto)\ndrop(HL &&hl)\n{\n if constexpr (N)\n return drop<N-1>(std::forward<HL>(hl).tail());\n else\n return std::forward<HL>(hl);\n}\n\ntemplate<std::size_t  N, is_template<HList> HL>\nrequires (N < std::remove_cvref_t<HL>::len)\ninline decltype(auto)\nget(HL &&hl)\n{\n return drop<N>(std::forward<HL>(hl)).head();\n}\n\ntemplate<typename F, is_template<HList> HL>\ndecltype(auto)\napply(F &&f, HL &&hl)\n{\n [&f,&hl]<std::size_t ...I>(std::index_sequence<I...>) -> decltype(auto) {\n return std::forward<F>(f)(get<I>(std::forward<HL>(hl))...);\n }(std::make_index_sequence<std::remove_cvref_t<HL>::len>{});\n}\n```", "```\nstruct Obj { void use() { /* ... */ } /* ... */ };\n\ntemplate<typename Want, typename Have>\ninline std::conditional_t<std::is_same_v<Want, Have>, Want &&, Want>\nlocal_copy(Have &in)\n{\n return static_cast<Have&&>(in);\n}\n\ntemplate<std::convertible_to<Obj> ...T>\nvoid\ngood1(T&&...t)\n{\n // Unary fold over comma operator\n (local_copy<Obj, T>(t).use(), ...);\n}\n\n// Another way to do it\ntemplate<std::convertible_to<Obj> ...T>\nvoid\ngood2(T&&...t)\n{\n auto use = []<typename U>(U &&arg) {\n decltype(auto) o = local_copy<Obj, U>(arg);\n o.use();\n };\n (use(std::forward<T>(t)), ...);\n}\n```", "```\n     // Doesn't copy or move an Obj, but requires the invoking\n     // context to create a default-initialized Obj\n     Obj make_object() { return {}; }\n\n     // Only one Obj is ever created per invocation\n     void use_object() { Obj o = make_object(); o.use(); }\n    ```", "```\ninline void\nalmost_good3(std::initializer_list<Obj> args)\n{\n for (const Obj &o : args)\n o.use(); // doesn't work with non-const method, though\n}\n```", "```\n// Painful to write, only works if variant has exactly 3 types\nvoid\nset_index(auto &v, std::size_t  n)\n{\n switch (n) {\n case 0:\n v.template emplace<0>();\n break;\n case 1:\n v.template emplace<1>();\n break;\n case 2:\n v.template emplace<2>();\n break;\n }\n}\n```", "```\n// Parse a pack of char as a decimal number\nconstexpr std::size_t\nchars2size(std::same_as<char> auto ...c)\n{\n std::size_t  r = 0;\n for (std::size_t  i : { c... })\n r = r*10 + i - '0';\n return r;\n}\n\n// Define 0_const, 1_const, etc. as compile-time integral constants\n// (Note: doesn't work with clang++ yet)\ntemplate<char ...C> requires ((C >= '0' && C <= '9') && ...)\nconsteval std::integral_constant<std::size_t, chars2size(C...)>\noperator \"\"_const()\n{\n return {};\n}\n\n// Illegal nonsense--a function can only return one type\nauto\nget_constant(std::size_t  n)\n{\n switch (n) {\n case 0:\n return 0_const;\n case 1:\n return 1_const;\n // ...\n }\n}\n```", "```\ntemplate<typename R = void, typename F>\ninline constexpr R\nwith_constant(std::size_t  n, F &&f)\n{\n switch (n) {\n case 0:\n return std::forward<F>(f)(0_const);\n case 1:\n return std::forward<F>(f)(1_const);\n // ...\n }\n}\n\nvoid\nset_index(auto &v, std::size_t  n)\n{\n with_constant(n, [&v](auto i) { v.template emplace<i>(); });\n}\n```", "```\nnamespace detail {\n\ntemplate<std::size_t  I, typename R, typename F>\ninline constexpr R with_integral_constant(F f)\n{\n return static_cast<F>(f)(std::integral_constant<std::size_t, I>{});\n}\n\n} // namespace detail\n\ntemplate<std::size_t  N, typename R = void, typename F>\ninline constexpr R\nwith_n(int n, F &&f)\n{\n constexpr auto invoke_array =\n []<std::size_t...I>(std::index_sequence<I...>) {\n return std::array{ detail::with_integral_constant<I, R, F&&>... };\n }(std::make_index_sequence<N>{});\n\n return invoke_array.at(n)(std::forward<F>(f));\n}\n\ntemplate<typename T> requires requires {\n { std::variant_size_v<T>+0 } -> std::same_as<std::size_t>;\n}\nvoid\nset_index(T &t, std::size_t  n)\n{\n with_n<std::variant_size_v<T>>(n, [&t](auto i) {\n t.template emplace<i>();\n });\n}\n```", "```\ntemplate<is_template<std::variant> T> \nvoid\nset_index(T &t, std::size_t  n)\n{\n /* ... */\n}\n```"]