- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分类：未分类
- en: 'date: 2024-05-27 14:38:38'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 14:38:38
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Command Line Interface Guidelines
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行界面指南
- en: 来源：[https://clig.dev/](https://clig.dev/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://clig.dev/](https://clig.dev/)
- en: <main>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <main>
- en: Command Line Interface Guidelines
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行界面指南
- en: An [open-source](https://github.com/cli-guidelines/cli-guidelines) guide to
    help you write better command-line programs, taking traditional UNIX principles
    and updating them for the modern day.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 [开源](https://github.com/cli-guidelines/cli-guidelines) 指南，帮助您编写更好的命令行程序，采用传统的
    UNIX 原则，并将其更新到现代。
- en: Authors
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作者
- en: '**Aanand Prasad**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Aanand Prasad**'
- en: Engineer at Squarespace, co-creator of Docker Compose.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Squarespace 的工程师，Docker Compose 的共同创始人。
- en: '[@aanandprasad](https://twitter.com/aanandprasad)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[@aanandprasad](https://twitter.com/aanandprasad)'
- en: '**Ben Firshman**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ben Firshman**'
- en: Co-creator [Replicate](https://replicate.ai/), co-creator of Docker Compose.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 共同创始人[Replicate](https://replicate.ai/)，Docker Compose 的共同创始人。
- en: '[@bfirsh](https://twitter.com/bfirsh)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[@bfirsh](https://twitter.com/bfirsh)'
- en: '**Carl Tashian**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Carl Tashian**'
- en: Offroad Engineer at [Smallstep](https://smallstep.com/), first engineer at Zipcar,
    co-founder Trove.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[Smallstep](https://smallstep.com/) 的越野工程师，Zipcar 的首席工程师，Trove 的联合创始人。'
- en: '[tashian.com](https://tashian.com/) [@tashian](https://twitter.com/tashian)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[tashian.com](https://tashian.com/) [@tashian](https://twitter.com/tashian)'
- en: '**Eva Parish**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Eva Parish**'
- en: Technical Writer at Squarespace, O’Reilly contributor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Squarespace 的技术作家，O’Reilly 贡献者。
- en: '[evaparish.com](https://evaparish.com/) [@evpari](https://twitter.com/evpari)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[evaparish.com](https://evaparish.com/) [@evpari](https://twitter.com/evpari)'
- en: Design by [Mark Hurrell](https://mhurrell.co.uk/). Thanks to Andreas Jansson
    for early contributions, and Andrew Reitz, Ashley Williams, Brendan Falk, Chester
    Ramey, Dj Walker-Morgan, Jacob Maine, James Coglan, Michael Dwan, and Steve Klabnik
    for reviewing drafts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 设计由 [Mark Hurrell](https://mhurrell.co.uk/) 完成。感谢 Andreas Jansson 提供的早期贡献，以及
    Andrew Reitz、Ashley Williams、Brendan Falk、Chester Ramey、Dj Walker-Morgan、Jacob
    Maine、James Coglan、Michael Dwan 和 Steve Klabnik 对草稿的审查。
- en: '[Join us on Discord](https://discord.gg/EbAW5rUCkE) if you want to discuss
    the guide or CLI design.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[加入我们的 Discord](https://discord.gg/EbAW5rUCkE) 如果您想讨论指南或 CLI 设计。'
- en: Foreword
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序言
- en: In the 1980s, if you wanted a personal computer to do something for you, you
    needed to know what to type when confronted with `C:\>` or `~<main. Help came
    in the form of thick, spiral-bound manuals. Error messages were opaque. There
    was no Stack Overflow to save you. But if you were lucky enough to have internet
    access, you could get help from Usenet—an early internet community filled with
    other people who were just as frustrated as you were. They could either help you
    solve your problem, or at least provide some moral support and camaraderie.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1980 年代，如果你想让个人计算机为你做事情，你需要知道当面对 `C:\>` 或 `~<main` 时该输入什么，帮助来自于厚厚的、装订的手册。错误消息是模糊的。没有
    Stack Overflow 来拯救你。但是如果你很幸运能够上网，你可以从 Usenet 获得帮助——一个早期的互联网社区，充满了其他和你一样沮丧的人。他们可以帮助你解决问题，或者至少提供一些道义支持和友谊。
- en: Forty years later, computers have become so much more accessible to everyone,
    often at the expense of low-level end user control. On many devices, there is
    no command-line access at all, in part because it goes against the corporate interests
    of walled gardens and app stores.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 四十年后，计算机变得更加易于所有人访问，往往是以牺牲低级别的最终用户控制为代价。在许多设备上，根本没有命令行访问，部分原因是因为这与封闭的园地和应用商店的企业利益相抵触。
- en: Most people today don’t know what the command line is, much less why they would
    want to bother with it. As computing pioneer Alan Kay said in [a 2017 interview](https://www.fastcompany.com/40435064/what-alan-kay-thinks-about-the-iphone-and-technology-now),
    “Because people don’t understand what computing is about, they think they have
    it in the iPhone, and that illusion is as bad as the illusion that ‘Guitar Hero’
    is the same as a real guitar.”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 今天大多数人都不知道命令行是什么，更不用说为什么他们要费心去学习它了。正如计算机先驱 Alan Kay 在 [2017 年的一次采访](https://www.fastcompany.com/40435064/what-alan-kay-thinks-about-the-iphone-and-technology-now)
    中所说：“因为人们不理解计算机是怎么一回事，他们认为 iPhone 中有计算机，这种错觉和认为‘Guitar Hero’就是真正吉他一样糟糕。”
- en: Kay’s “real guitar” isn’t the CLI—not exactly. He was talking about ways of
    programming computers that offer the power of the CLI and that transcend writing
    software in text files. There is a belief among Kay’s disciples that we need to
    break out of a text-based local maximum that we’ve been living in for decades.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Kay 的“真正的吉他”不是 CLI——不完全是。他谈论的是提供 CLI 功能并超越在文本文件中编写软件的编程计算机方式。Kay 的追随者相信，我们需要打破几十年来一直生活在其中的基于文本的局部最大值。
- en: It’s exciting to imagine a future where we program computers very differently.
    Even today, spreadsheets are by far the most popular programming language, and
    the no-code movement is taking off quickly as it attempts to replace some of the
    intense demand for talented programmers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 激动人心的是，想象一种我们以非常不同的方式编程计算机的未来。即使在今天，电子表格仍然是最受欢迎的编程语言，而无代码运动正在迅速发展，试图取代对有才华的程序员的强烈需求的一部分。
- en: Yet with its creaky, decades-old constraints and inexplicable quirks, the command
    line is still the most *versatile* corner of the computer. It lets you pull back
    the curtain, see what’s really going on, and creatively interact with the machine
    at a level of sophistication and depth that GUIs cannot afford. It’s available
    on almost any laptop, for anyone who wants to learn it. It can be used interactively,
    or it can be automated. And, it doesn’t change as fast as other parts of the system.
    There is creative value in its stability.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管它有着老旧的约束和莫名其妙的怪癖，命令行仍然是计算机中最 *多才多艺* 的角落。它让你拉开了帷幕，看到了真正发生的事情，并以 GUI 无法提供的复杂程度和深度创造性地与机器交互。几乎任何笔记本电脑都可以使用它，任何想要学习它的人都可以使用它。它可以交互使用，也可以自动化。而且，它的变化速度不如系统的其他部分快。它的稳定性具有创造性的价值。
- en: So, while we still have it, we should try to maximize its utility and accessibility.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们仍然拥有它时，我们应该尽量最大化其效用和可访问性。
- en: 'A lot has changed about how we program computers since those early days. The
    command line of the past was *machine-first*: little more than a REPL on top of
    a scripting platform. But as general-purpose interpreted languages have flourished,
    the role of the shell script has shrunk. Today’s command line is *human-first*:
    a text-based UI that affords access to all kinds of tools, systems and platforms.
    In the past, the editor was inside the terminal—today, the terminal is just as
    often a feature of the editor. And there’s been a proliferation of `git`-like
    multi-tool commands. Commands within commands, and high-level commands that perform
    entire workflows rather than atomic functions.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自从那些早期以来，我们编写计算机程序的方式已经发生了很多变化。过去的命令行是*面向机器*的：只是一个脚本平台上的 REPL。但随着通用解释性语言的兴起，shell
    脚本的作用已经变小。现在的命令行是*面向人*的：一个基于文本的界面，可以访问各种工具，系统和平台。过去，编辑器在终端里——今天，终端同样经常是编辑器的一个功能。还有像
    `git` 一样的多工具命令。命令里面的命令，高级别的命令执行整个工作流，而不是原子功能。
- en: Inspired by traditional UNIX philosophy, driven by an interest in encouraging
    a more delightful and accessible CLI environment, and guided by our experiences
    as programmers, we decided it was time to revisit the best practices and design
    principles for building command-line programs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 受传统 UNIX 哲学的启发，受到鼓励更令人愉快和易用的 CLI 环境的兴趣的驱动，以及我们作为程序员的经验的指引，我们决定是时候重新审视构建命令行程序的最佳实践和设计原则了。
- en: Long live the command line!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行长存
- en: Introduction
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This document covers both high-level design philosophy, and concrete guidelines.
    It’s heavier on the guidelines because our philosophy as practitioners is not
    to philosophize too much. We believe in learning by example, so we’ve provided
    plenty of those.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这份文档既涵盖高级设计理念，又包含具体的指导方针。我们更看重指导方针，因为作为实践者，我们的哲学不是过多地哲学化。我们相信通过示例学习，所以我们提供了大量示例。
- en: This guide doesn’t cover full-screen terminal programs like emacs and vim. Full-screen
    programs are niche projects—very few of us will ever be in the position to design
    one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指南不涵盖像 emacs 和 vim 这样的全屏终端程序。全屏程序是小众项目——我们很少有人会处在设计这样的位置。
- en: This guide is also agnostic about programming languages and tooling in general.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指南也不偏向于特定的编程语言和通用工具。
- en: Who is this guide for?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指南适合谁？
- en: If you are creating a CLI program and you are looking for principles and concrete
    best practices for its UI design, this guide is for you.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在创建一个 CLI 程序，并且在寻找原则和具体最佳实践来设计其用户界面，这个指南适合你。
- en: If you are a professional “CLI UI designer,” that’s amazing—we’d love to learn
    from you.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是一名专业的“CLI UI 设计师”，那太棒了——我们很乐意向你学习。
- en: If you’d like to avoid obvious missteps of the variety that go against 40 years
    of CLI design conventions, this guide is for you.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想避免明显的错误，而这些错误违反了 40 年的 CLI 设计约定，这个指南适合你。
- en: If you want to delight people with your program’s good design and helpful help,
    this guide is definitely for you.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想用你的程序的良好设计和有帮助的帮助来取悦人们，这个指南绝对适合你。
- en: If you are creating a GUI program, this guide is not for you—though you may
    learn some GUI anti-patterns if you decide to read it anyway.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在创建一个 GUI 程序，这个指南不适合你——尽管如果你决定阅读，可能会学到一些 GUI 的反模式。
- en: If you are designing an immersive, full-screen CLI port of Minecraft, this guide
    isn’t for you. (But we can’t wait to see it!)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在设计一个沉浸式的全屏 CLI 版本的 Minecraft，这个指南不适合你。 （但我们迫不及待想看到它！）
- en: Philosophy
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哲学
- en: These are what we consider to be the fundamental principles of good CLI design.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们认为的良好 CLI 设计的基本原则。
- en: Human-first design
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人先设计
- en: Traditionally, UNIX commands were written under the assumption they were going
    to be used primarily by other programs. They had more in common with functions
    in a programming language than with graphical applications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，UNIX 命令是在它们主要为其他程序使用的假设下编写的。它们与编程语言中的函数更相似，而不是图形应用程序。
- en: 'Today, even though many CLI programs are used primarily (or even exclusively)
    by humans, a lot of their interaction design still carries the baggage of the
    past. It’s time to shed some of this baggage: if a command is going to be used
    primarily by humans, it should be designed for humans first.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，尽管许多 CLI 程序主要（甚至完全）由人使用，但它们的交互设计很大程度上仍带有过去的包袱。是时候摆脱一些包袱了：如果一个命令主要是为人使用，它应该首先为人设计。
- en: Simple parts that work together
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的部分组合在一起
- en: A core tenet of [the original UNIX philosophy](https://en.wikipedia.org/wiki/Unix_philosophy)
    is the idea that small, simple programs with clean interfaces can be combined
    to build larger systems. Rather than stuff more and more features into those programs,
    you make programs that are modular enough to be recombined as needed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[原始 UNIX 哲学](https://en.wikipedia.org/wiki/Unix_philosophy)的核心原则之一是：小而简单的程序，具有清晰的接口，可以组合构建更大的系统。而不是把这些程序的特性堆积起来，你做的是足够模块化，可以根据需要重新组合程序。'
- en: In the old days, pipes and shell scripts played a crucial role in the process
    of composing programs together. Their role might have diminished with the rise
    of general-purpose interpreted languages, but they certainly haven’t gone away.
    What’s more, large-scale automation—in the form of CI/CD, orchestration and configuration
    management—has flourished. Making programs composable is just as important as
    ever.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，管道和 shell 脚本在合成程序的过程中发挥了至关重要的作用。它们的作用可能随着通用解释型语言的兴起而减少，但它们确实还没有消失。而且，大规模的自动化——以
    CI/CD，编排和配置管理的形式—已经蓬勃发展。使程序可组合构建的重要性与以往一样重要。
- en: Fortunately, the long-established conventions of the UNIX environment, designed
    for this exact purpose, still help us today. Standard in/out/err, signals, exit
    codes and other mechanisms ensure that different programs click together nicely.
    Plain, line-based text is easy to pipe between commands. JSON, a much more recent
    invention, affords us more structure when we need it, and lets us more easily
    integrate command-line tools with the web.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，UNIX环境中长期建立的传统，旨在为此目的而设计，至今仍然对我们有所帮助。标准输入/输出/错误、信号、退出代码和其他机制确保不同的程序能够很好地配合。基于纯文本、逐行的管道易于在命令之间传输。JSON，一种更为近期的发明，为我们提供了更多结构，当我们需要时，让我们更容易地将命令行工具与网络集成。
- en: Whatever software you’re building, you can be absolutely certain that people
    will use it in ways you didn’t anticipate. Your software *will* become a part
    in a larger system—your only choice is over whether it will be a well-behaved
    part.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在构建什么样的软件，你可以肯定人们会用它的方式超出你的预期。你的软件*将*成为更大系统中的一个组成部分，你唯一的选择是它是一个表现良好的部分。
- en: Most importantly, designing for composability does not need to be at odds with
    designing for humans first. Much of the advice in this document is about how to
    achieve both.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，为可组合性而设计并不一定与首要考虑人类的设计相矛盾。本文的许多建议都是关于如何实现这两者。
- en: Consistency across programs
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序间的一致性
- en: The terminal’s conventions are hardwired into our fingers. We had to pay an
    upfront cost by learning about command line syntax, flags, environment variables
    and so on, but it pays off in long-term efficiency… as long as programs are consistent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 终端的约定已经深深印在我们的手指中。我们不得不付出学习命令行语法、标志、环境变量等的前期成本，但长期效率确实会得到回报……只要程序保持一致性。
- en: Where possible, a CLI should follow patterns that already exist. That’s what
    makes CLIs intuitive and guessable; that’s what makes users efficient.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，CLI应该遵循已经存在的模式。这就是让CLI直观和可猜测的原因；这就是让用户高效的原因。
- en: That being said, sometimes consistency conflicts with ease of use. For example,
    many long-established UNIX commands don’t output much information by default,
    which can cause confusion or worry for people less familiar with the command line.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，有时一致性会与易用性相冲突。例如，许多长期存在的UNIX命令默认情况下并不输出太多信息，这可能会对对命令行不太熟悉的人造成困惑或担忧。
- en: When following convention would compromise a program’s usability, it might be
    time to break with it—but such a decision should be made with care.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循传统可能会损害程序的可用性时，也许是打破它的时候了——但这样的决定应该慎重考虑。
- en: Saying (just) enough
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 说（刚刚）足够
- en: The terminal is a world of pure information. You could make an argument that
    information is the interface—and that, just like with any interface, there’s often
    too much or too little of it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 终端是一个纯粹信息的世界。您可以提出一个论点，即信息是界面——就像任何界面一样，往往信息过多或过少。
- en: 'A command is saying too little when it hangs for several minutes and the user
    starts to wonder if it’s broken. A command is saying too much when it dumps pages
    and pages of debugging output, drowning what’s truly important in an ocean of
    loose detritus. The end result is the same: a lack of clarity, leaving the user
    confused and irritated.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个命令花费几分钟时间挂起而用户开始怀疑它是否出错时，说明命令说的太少了。当一个命令输出页页的调试信息，淹没了真正重要的内容时，说明命令说的太多了。结果是一样的：缺乏清晰度，让用户感到困惑和恼火。
- en: It can be very difficult to get this balance right, but it’s absolutely crucial
    if software is to empower and serve its users.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让这种平衡正确可能会很困难，但如果软件要赋予和服务于用户，则这是绝对关键的。
- en: Ease of discovery
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现的便利性
- en: When it comes to making functionality discoverable, GUIs have the upper hand.
    Everything you can do is laid out in front of you on the screen, so you can find
    what you need without having to learn anything, and perhaps even discover things
    you didn’t know were possible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要让功能易于发现时，GUI具有优势。屏幕上展示的一切都是您可以做的事情，因此您可以找到所需的内容而无需学习任何东西，甚至可能会发现您以前不知道的内容。
- en: It is assumed that command-line interfaces are the opposite of this—that you
    have to remember how to do everything. The original [Macintosh Human Interface
    Guidelines](https://archive.org/details/applehumaninterf00appl), published in
    1987, recommend “See-and-point (instead of remember-and-type),” as if you could
    only choose one or the other.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可以假定命令行界面与此相反——你必须记住如何进行每一步操作。1987年出版的[Macintosh人机界面指南](https://archive.org/details/applehumaninterf00appl)建议“看和点击（而不是记住和输入）”，好像你只能选择其中一种。
- en: These things needn’t be mutually exclusive. The efficiency of using the command-line
    comes from remembering commands, but there’s no reason the commands can’t help
    you learn and remember.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事情不必互相排斥。使用命令行的有效性来自于记住命令，但并没有理由这些命令不能帮助你学习和记住。
- en: Discoverable CLIs have comprehensive help texts, provide lots of examples, suggest
    what command to run next, suggest what to do when there is an error. There are
    lots of ideas that can be stolen from GUIs to make CLIs easier to learn and use,
    even for power users.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 易于发现的命令行界面具有全面的帮助文本，提供大量示例，建议下一步要运行的命令，建议在出现错误时该怎么做。有很多从图形用户界面中可以借鉴的想法，使命令行界面更易于学习和使用，即使是对于高级用户。
- en: '*Citation: The Design of Everyday Things (Don Norman), Macintosh Human Interface
    Guidelines*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用：《设计心理学》（唐·诺曼），Macintosh人机界面指南*'
- en: Conversation as the norm
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以对话为常态
- en: 'GUI design, particularly in its early days, made heavy use of *metaphor*: desktops,
    files, folders, recycle bins. It made a lot of sense, because computers were still
    trying to bootstrap themselves into legitimacy. The ease of implementation of
    metaphors was one of the huge advantages GUIs wielded over CLIs. Ironically, though,
    the CLI has embodied an accidental metaphor all along: it’s a conversation.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在早期，GUI设计大量使用*隐喻*：桌面、文件、文件夹、回收站。这是很有道理的，因为计算机还在努力提升自身的合法性。隐喻实现的便利性是GUI相对于CLI的一大优势。然而具有讽刺意味的是，CLI一直以来都体现着一种偶然的隐喻：它是一场对话。
- en: 'Beyond the most utterly simple commands, running a program usually involves
    more than one invocation. Usually, this is because it’s hard to get it right the
    first time: the user types a command, gets an error, changes the command, gets
    a different error, and so on, until it works. This mode of learning through repeated
    failure is like a conversation the user is having with the program.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最简单的命令之外，运行程序通常涉及不止一个调用。通常情况下，这是因为第一次很难做对：用户输入命令，得到一个错误，改变命令，得到另一个错误，依此类推，直到成功。这种通过反复失败学习的模式就像用户与程序进行的对话。
- en: 'Trial-and-error isn’t the only type of conversational interaction, though.
    There are others:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 试错并不是唯一类型的对话交互，还有其他类型：
- en: Running one command to set up a tool and then learning what commands to run
    to actually start using it.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一个命令来设置工具，然后学习要运行哪些命令才能实际开始使用它。
- en: Running several commands to set up an operation, and then a final command to
    run it (e.g. multiple `git add`s, followed by a `git commit`).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多个命令来设置一个操作，然后运行最终的命令来运行它（例如多次`git add`，然后跟着一个`git commit`）。
- en: Exploring a system—for example, doing a lot of `cd` and `ls` to get a sense
    of a directory structure, or `git log` and `git show` to explore the history of
    a file.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索系统——例如，执行大量的`cd`和`ls`去了解目录结构，或者执行`git log`和`git show`去探索文件的历史。
- en: Doing a dry-run of a complex operation before running it for real.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在真正运行之前对复杂操作进行测试运行。
- en: Acknowledging the conversational nature of command-line interaction means you
    can bring relevant techniques to bear on its design. You can suggest possible
    corrections when user input is invalid, you can make the intermediate state clear
    when the user is going through a multi-step process, you can confirm for them
    that everything looks good before they do something scary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 承认命令行交互的对话性质意味着你可以在其设计中应用相关的技术。当用户输入无效时，您可以建议可能的更正；当用户执行多步骤过程时，您可以清楚地展示中间状态；在用户做出某些可怕的事情之前，您可以为他们确认一切都看起来很好。
- en: The user is conversing with your software, whether you intended it or not. At
    worst, it’s a hostile conversation which makes them feel stupid and resentful.
    At best, it’s a pleasant exchange that speeds them on their way with newfound
    knowledge and a feeling of achievement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 用户正在与你的软件对话，不管你是否打算这样。最糟糕的情况是这是一种敌对的对话，会让他们感到愚蠢和愤怒。最好的情况是这是一种愉快的交流，能为他们提供新知识并取得成就感。
- en: '*Further reading: [The Anti-Mac User Interface (Don Gentner and Jakob Nielsen)](https://www.nngroup.com/articles/anti-mac-interface/)*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*更多阅读：[反马克用户界面（唐·根特纳和雅各布·尼尔森）](https://www.nngroup.com/articles/anti-mac-interface/)*'
- en: Robustness
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 健壮性
- en: 'Robustness is both an objective and a subjective property. Software should
    *be* robust, of course: unexpected input should be handled gracefully, operations
    should be idempotent where possible, and so on. But it should also *feel* robust.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 健壮性既是客观的属性，也是主观的属性。软件当然应该*是*健壮的：应该优雅地处理意外的输入，在可能的情况下应该是幂等的等等。但它也应该*感觉*健壮。
- en: You want your software to feel like it isn’t going to fall apart. You want it
    to feel immediate and responsive, as if it were a big mechanical machine, not
    a flimsy plastic “soft switch.”
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的软件感觉它不会崩溃。你希望它感觉迅速响应，就好像它是一个大型机械设备，而不是一个脆弱的塑料“软开关”。
- en: 'Subjective robustness requires attention to detail and thinking hard about
    what can go wrong. It’s lots of little things: keeping the user informed about
    what’s happening, explaining what common errors mean, not printing scary-looking
    stack traces.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 主观上的健壮性需要关注细节，认真思考可能出现的问题。这是许多小事情的综合：让用户了解正在发生什么，解释常见错误的含义，不打印看起来吓人的堆栈跟踪。
- en: As a general rule, robustness can also come from keeping it simple. Lots of
    special cases and complex code tend to make a program fragile.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个通用原则，简化也可能带来健壮性。大量的特殊情况和复杂的代码往往会使程序变得脆弱。
- en: Empathy
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同情心
- en: Command-line tools are a programmer’s creative toolkit, so they should be enjoyable
    to use. This doesn’t mean turning them into a video game, or using lots of emoji
    (though there’s nothing inherently wrong with emoji 😉). It means giving the user
    the feeling that you are on their side, that you want them to succeed, that you
    have thought carefully about their problems and how to solve them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具是程序员的创意工具包，所以它们应该是令人愉快的。这不意味着把它们变成视频游戏，或者使用大量的表情符号（尽管表情符号本身并没有什么不对😉）。这意味着让用户感觉到你站在他们这边，你希望他们成功，你认真思考过他们的问题以及如何解决它们。
- en: There’s no list of actions you can take that will ensure they feel this way,
    although we hope that following our advice will take you some of the way there.
    Delighting the user means *exceeding their expectations* at every turn, and that
    starts with empathy.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 没有可以确保用户有这种感觉的一揽子行为清单，尽管我们希望遵循我们的建议会在某种程度上帮助到你。让用户感到愉快意味着*在每一个转折点都超越他们的期望*，而这始于同情心。
- en: Chaos
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混乱
- en: The world of the terminal is a mess. Inconsistencies are everywhere, slowing
    us down and making us second-guess ourselves.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 终端世界是一团乱麻。不一致性无处不在，让我们停下来并且让我们对自己的选择产生怀疑。
- en: Yet it’s undeniable that this chaos has been a source of power. The terminal,
    like the UNIX-descended computing environment in general, places very few constraints
    on what you can build. In that space, all manner of invention has bloomed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而不可否认的是，这种混乱是一种力量的源泉。与类UNIX的计算环境一样，终端对你可以构建什么几乎没有多少限制。在这个空间里，各种各样的发明就此开花。
- en: It’s ironic that this document implores you to follow existing patterns, right
    alongside advice that contradicts decades of command-line tradition. We’re just
    as guilty of breaking the rules as anyone.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有讽刺的是，这篇文件不仅督促你遵循现有的模式，还与违反几十年的命令行传统的建议并列。我们正像任何人一样，破坏规则。
- en: The time might come when you, too, have to break the rules. Do so with intention
    and clarity of purpose.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有一天你也不得不打破规则。请有目的地以及明确地这样做。
- en: “Abandon a standard when it is demonstrably harmful to productivity or user
    satisfaction.” — Jef Raskin, [The Humane Interface](https://en.wikipedia.org/wiki/The_Humane_Interface)
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “在标准明显有损生产力或用户满意度时放弃该标准。” — 杰夫·拉斯金，《人性化界面》
- en: Guidelines
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指南
- en: This is a collection of specific things you can do to make your command-line
    program better.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一系列可以使您的命令行程序更好的具体事项。
- en: The first section contains the essential things you need to follow. Get these
    wrong, and your program will be either hard to use or a bad CLI citizen.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含您需要遵循的基本要点。如果违反这些规则，您的程序将要么难用，要么是一个糟糕的CLI工具。
- en: The rest are nice-to-haves. If you have the time and energy to add these things,
    your program will be a lot better than the average program.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 其余则是一些不错的功能。如果您有时间和精力添加这些功能，您的程序将比平均程序好了许多。
- en: 'The idea is that, if you don’t want to think too hard about the design of your
    program, you don’t have to: just follow these rules and your program will probably
    be good. On the other hand, if you’ve thought about it and determined that a rule
    is wrong for your program, that’s fine. (There’s no central authority that will
    reject your program for not following arbitrary rules.)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主意是，如果您不想过多考虑程序的设计，您不必这样做：只需遵循这些规则，您的程序可能会很不错。另一方面，如果您思考了并确定某个规则不适合您的程序，那没问题。（没有中央管理机构会因为不遵循任意规则而拒绝您的程序。）
- en: Also—these rules aren’t written in stone. If you disagree with a general rule
    for good reason, we hope you’ll [propose a change](https://github.com/cli-guidelines/cli-guidelines).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些规则并不是一成不变的。如果您有正当理由不同意一般规则，我们希望您会[提出更改](https://github.com/cli-guidelines/cli-guidelines)。
- en: The Basics
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础知识
- en: There are a few basic rules you need to follow. Get these wrong, and your program
    will be either very hard to use, or flat-out broken.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些基本规则需要遵循。如果违反这些规则，您的程序将要么非常难用，要么毫无作用。
- en: '**Use a command-line argument parsing library where you can.** Either your
    language’s built-in one, or a good third-party one. They will normally handle
    arguments, flag parsing, help text, and even spelling suggestions in a sensible
    way.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**在可能的情况下使用命令行参数解析库。** 使用您所用语言内置的解析库，或者优秀的第三方解析库。它们通常会以明智的方式处理参数解析、标志解析、帮助文本，甚至拼写建议。'
- en: 'Here are some that we like:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们喜欢的：
- en: '**Return zero exit code on success, non-zero on failure.** Exit codes are how
    scripts determine whether a program succeeded or failed, so you should report
    this correctly. Map the non-zero exit codes to the most important failure modes.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**在成功时返回零退出代码，在失败时返回非零退出代码。** 退出代码是脚本确定程序是否成功或失败的方式，因此您应该正确报告此信息。将非零退出代码映射到最重要的失败模式。'
- en: '**Send output to `stdout`.** The primary output for your command should go
    to `stdout`. Anything that is machine readable should also go to `stdout`—this
    is where piping sends things by default.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**将输出发送到`stdout`。** 您的命令的主要输出应发送到`stdout`。任何机器可读内容也应该发送到`stdout`，这是管道默认发送内容的位置。'
- en: '**Send messaging to `stderr`.** Log messages, errors, and so on should all
    be sent to `stderr`. This means that when commands are piped together, these messages
    are displayed to the user and not fed into the next command.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**将消息发送到`stderr`。** 日志消息、错误等应全部发送到`stderr`。这意味着当命令串联在一起时，这些消息将显示给用户而不会被输入到下一个命令中。'
- en: Help
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帮助
- en: '**Display help text when passed no options, the `-h` flag, or the `--help`
    flag.**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**当不添加任何选项、添加`-h`标志或`--help`标志时，显示帮助文本。**'
- en: '**Display a concise help text by default.** If you can, display help by default
    when `myapp` or `myapp subcommand` is run. Unless your program is very simple
    and does something obvious by default (e.g. `ls`), or your program reads input
    interactively (e.g. `cat`).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认显示简洁的帮助文本。** 如果可以的话，在运行`myapp`或`myapp子命令`时，默认显示帮助。除非您的程序非常简单并且默认情况下执行某些明显的操作（例如`ls`），或者您的程序以交互方式读取输入（例如`cat`）。'
- en: 'The concise help text should only include:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁的帮助文本应仅包括：
- en: A description of what your program does.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的程序功能的描述。
- en: One or two example invocations.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或两个示例调用。
- en: Descriptions of flags, unless there are lots of them.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志的描述，除非有很多标志。
- en: An instruction to pass the `--help` flag for more information.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示传递`--help`标志以了解更多信息。
- en: '`jq` does this well. When you type `jq`, it displays an introductory description
    and an example, then prompts you to pass `jq --help` for the full listing of flags:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`jq`做得很好。当您键入`jq`时，它会显示一个简介描述和一个示例，然后提示您传递`jq --help`以获取有关标志的完整列表：'
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Show full help when `-h` and `--help` is passed.** All of these should show
    help:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**当传递`-h`和`--help`时显示完整的帮助。** 所有这些都应该显示帮助：'
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ignore any other flags and arguments that are passed—you should be able to add
    `-h` to the end of anything and it should show help. Don’t overload `-h`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略传递的其他标志和参数 — — 您应该能够在任何地方加上`-h`并显示出帮助。不要过度使用`-h`。
- en: 'If your program is `git`-like, the following should also offer help:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的程序类似于`git`，下面的内容也应该提供帮助：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Provide a support path for feedback and issues.** A website or GitHub link
    in the top-level help text is common.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**为反馈和问题提供支持途径。** 顶级帮助文本中常见的是网站或GitHub链接。'
- en: '**In help text, link to the web version of the documentation.** If you have
    a specific page or anchor for a subcommand, link directly to that. This is particularly
    useful if there is more detailed documentation on the web, or further reading
    that might explain the behavior of something.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**在帮助文本中，链接到文档的网页版本。** 如果特定子命令有特定页面或锚点，请直接链接到那里。如果网上有更详细的文档或相关阅读可能会解释某些行为，这将非常有用。'
- en: '**Lead with examples.** Users tend to use examples over other forms of documentation,
    so show them first in the help page, particularly the common complex uses. If
    it helps explain what it’s doing and it isn’t too long, show the actual output
    too.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**以示例开头。** 用户更倾向于使用示例而不是其他形式的文档，因此首先在帮助页面中显示示例，特别是常见的复杂用途。如果它有助于解释所做的事情，并且不太长，还可以显示实际输出。'
- en: You can tell a story with a series of examples, building your way toward complex
    uses.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过一系列示例讲述一个故事，逐步构建您的方式向复杂的用途发展。
- en: '**If you’ve got loads of examples, put them somewhere else,** in a cheat sheet
    command or a web page. It’s useful to have exhaustive, advanced examples, but
    you don’t want to make your help text really long.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你有大量示例，请将它们放在其他地方**，例如一个备忘单命令或一个网页。拥有详尽而高级的示例很有用，但你不希望使你的帮助文本变得非常长。'
- en: For more complex use cases, e.g. when integrating with another tool, it might
    be appropriate to write a fully-fledged tutorial.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的用例，例如与另一个工具集成时，编写一个成熟的教程可能是恰当的。
- en: '**Display the most common flags and commands at the start of the help text.**
    It’s fine to have lots of flags, but if you’ve got some really common ones, display
    them first. For example, the Git command displays the commands for getting started
    and the most commonly used subcommands first:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**在帮助文本的开头显示最常见的标志和命令。** 拥有大量标志是可以的，但是如果有一些非常常见的标志，请先显示它们。例如，Git 命令会首先显示开始和最常用的子命令：'
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Use formatting in your help text.** Bold headings make it much easier to
    scan. But, try to do it in a terminal-independent way so that your users aren’t
    staring down a wall of escape characters.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**在帮助文本中使用格式化。** 粗体标题会让扫描变得更容易。但是，尝试以与终端无关的方式做到这一点，以免用户一眼望去只看到一堆转义字符。'
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note: When `heroku apps --help` is piped through a pager, the command emits
    no escape characters.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当`heroku apps --help`通过分页器传输时，命令不会发出转义字符。
- en: '**If the user did something wrong and you can guess what they meant, suggest
    it.** For example, `brew update jq` tells you that you should run `brew upgrade
    jq`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果用户做错了些什么，而你猜到了他们的意思，那就建议一下。** 例如，`brew update jq`告诉你应该运行`brew upgrade jq`。'
- en: 'You can ask if they want to run the suggested command, but don’t force it on
    them. For example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以询问他们是否想运行建议的命令，但不要强迫他们。例如：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rather than suggesting the corrected syntax, you might be tempted to just run
    it for them, as if they’d typed it right in the first place. Sometimes this is
    the right thing to do, but not always.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与其建议正确的语法，你可能会想要为他们运行它，就好像他们一开始就正确输入了一样。有时候这样做是正确的，但并非总是。
- en: Firstly, invalid input doesn’t necessarily imply a simple typo—it can often
    mean the user has made a logical mistake, or misused a shell variable. Assuming
    what they meant can be dangerous, especially if the resulting action modifies
    state.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，无效的输入不一定意味着一个简单的拼写错误 - 它往往意味着用户已经犯了一个逻辑错误，或者误用了一个 shell 变量。假设他们的意图可能是危险的，特别是如果结果的操作会修改状态。
- en: Secondly, be aware that if you change what the user typed, they won’t learn
    the correct syntax. In effect, you’re ruling that the way they typed it is valid
    and correct, and you’re committing to supporting that indefinitely. Be intentional
    in making that decision, and document both syntaxes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，要注意如果你改变用户输入的内容，他们将无法学习正确的语法。实际上，你正在确定他们输入的方式是有效和正确的，并且承诺无限支持这种方式。在做出这个决定时要有意识，并记录两种语法。
- en: '*Further reading: [“Do What I Mean”](http://www.catb.org/~esr/jargon/html/D/DWIM.html)*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*进一步阅读：[“按我所想”](http://www.catb.org/~esr/jargon/html/D/DWIM.html)*'
- en: '**If your command is expecting to have something piped to it and `stdin` is
    an interactive terminal, display help immediately and quit.** This means it doesn’t
    just hang, like `cat`. Alternatively, you could print a log message to `stderr`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你的命令期望有数据被管道输入，且`stdin`是一个交互式终端，立即显示帮助并退出。** 这意味着它不会像 `cat` 那样永久停止。或者，你可以将日志消息打印到`stderr`。'
- en: Documentation
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档
- en: The purpose of [help text](#help) is to give a brief, immediate sense of what
    your tool is, what options are available, and how to perform the most common tasks.
    Documentation, on the other hand, is where you go into full detail. It’s where
    people go to understand what your tool is for, what it *isn’t* for, how it works
    and how to do everything they might need to do.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[帮助文本](#help)的目的是要给予一个简短、即时感知你的工具是什么，哪些选项可用，如何执行最常见的任务。而文档，则是你详尽阐述的地方。这是人们去了解你的工具是用来做什么的，它不适用于什么，它是如何工作的，以及如何进行他们可能需要做的所有事情的地方。'
- en: '**Provide web-based documentation.** People need to be able to search online
    for your tool’s documentation, and to link other people to specific parts. The
    web is the most inclusive documentation format available.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供基于 web 的文档。** 人们需要能够在网上搜索你的工具文档，并向其他人链接特定部分。网络是最具包容性的文档格式。'
- en: '**Provide terminal-based documentation.** Documentation in the terminal has
    several nice properties: it’s fast to access, it stays in sync with the specific
    installed version of the tool, and it works without an internet connection.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供基于终端的文档。** 终端中的文档具有几个优点：快速访问、与工具的特定安装版本保持同步，以及无需互联网连接即可使用。'
- en: '**Consider providing man pages.** [man pages](https://en.wikipedia.org/wiki/Man_page),
    Unix’s original system of documentation, are still in use today, and many users
    will reflexively check `man mycmd` as a first step when trying to learn about
    your tool. To make them easier to generate, you can use a tool like [ronn](http://rtomayko.github.io/ronn/ronn.1.html)
    (which can also generate your web docs).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑提供 man 页面。** [man 页面](https://en.wikipedia.org/wiki/Man_page)，Unix的原始文档系统，至今仍在使用，许多用户在试图了解你的工具时，会本能地检查`man
    mycmd`。为了更易于生成它们，你可以使用 [ronn](http://rtomayko.github.io/ronn/ronn.1.html) 这样的工具（它也可以生成你的网络文档）。'
- en: However, not everyone knows about `man`, and it doesn’t run on all platforms,
    so you should also make sure your terminal docs are accessible via your tool itself.
    For example, `git` and `npm` make their man pages accessible via the `help` subcommand,
    so `npm help ls` is equivalent to `man npm-ls`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非每个人都知道`man`，而且它并不在所有平台上运行，因此你还应确保你的终端文档可以通过你的工具本身访问。例如，`git` 和 `npm`通过`help`子命令可以访问他们的
    man 页面，因此`npm help ls`等同于`man npm-ls`。
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Output
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: '**Human-readable output is paramount.** Humans come first, machines second.
    The most simple and straightforward heuristic for whether a particular output
    stream (`stdout` or `stderr`) is being read by a human is *whether or not it’s
    a TTY*. Whatever language you’re using, it will have a utility or library for
    doing this (e.g. [Python](https://stackoverflow.com/questions/858623/how-to-recognize-whether-a-script-is-running-on-a-tty),
    [Node](https://nodejs.org/api/process.html#process_a_note_on_process_i_o), [Go](https://github.com/mattn/go-isatty)).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**人类可读的输出至关重要。** 人类优先，机器其次。是否是一个 TTY 是判断特定输出流（`stdout`或`stderr`）被人类读取的最简单和直接的启发式方法。无论您使用的是什么语言，它都将有一个用于执行此操作的实用程序或库（例如
    [Python](https://stackoverflow.com/questions/858623/how-to-recognize-whether-a-script-is-running-on-a-tty)，[Node](https://nodejs.org/api/process.html#process_a_note_on_process_i_o)，[Go](https://github.com/mattn/go-isatty)）。'
- en: '*Further reading on [what a TTY is](https://unix.stackexchange.com/a/4132).*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关 [TTY 是什么](https://unix.stackexchange.com/a/4132) 的更多阅读。*'
- en: '**Have machine-readable output where it does not impact usability.** Streams
    of text is the universal interface in UNIX. Programs typically output lines of
    text, and programs typically expect lines of text as input, therefore you can
    compose multiple programs together. This is normally done to make it possible
    to write scripts, but it can also help the usability for humans using programs.
    For example, a user should be able to pipe output to `grep` and it should do what
    they expect.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**在不影响可用性的情况下拥有机器可读的输出。** 文本流是 UNIX 中通用的接口。程序通常会输出文本行，而程序通常期望输入文本行，因此您可以将多个程序组合在一起。通常这样做是为了编写脚本，但它也可以帮助人类使用程序的可用性。例如，用户应该能将输出管道到`grep`并且它应该按照他们的期望工作。'
- en: “Expect the output of every program to become the input to another, as yet unknown,
    program.” — [Doug McIlroy](https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html)
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “预计每个程序的输出都会成为另一个尚未知的程序的输入。” — [Doug McIlroy](https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html)
- en: '**If human-readable output breaks machine-readable output, use `--plain` to
    display output in plain, tabular text format for integration with tools like `grep`
    or `awk`.** In some cases, you might need to output information in a different
    way to make it human-readable.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果人类可读的输出破坏了机器可读的输出，请使用 `--plain` 以纯文本格式显示输出，以便与 `grep` 或 `awk` 等工具集成。**
    在某些情况下，您可能需要以不同的方式输出信息以使其人类可读。'
- en: For example, if you are displaying a line-based table, you might choose to split
    a cell into multiple lines, fitting in more information while keeping it within
    the width of the screen. This breaks the expected behavior of there being one
    piece of data per line, so you should provide a `--plain` flag for scripts, which
    disables all such manipulation and outputs one record per line.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您正在显示基于行的表格，您可能会选择将单元格拆分成多行，以便在保持屏幕宽度的同时容纳更多信息。这将打破预期的行为，即每行只有一个数据片段，因此您应该为脚本提供`--plain`标志，禁用所有这样的操作，并每行输出一条记录。
- en: '**Display output as formatted JSON if `--json` is passed.** JSON allows for
    more structure than plain text, so it makes it much easier to output and handle
    complex data structures. [`jq`](https://stedolan.github.io/jq/) is a common tool
    for working with JSON on the command-line, and there is now a [whole ecosystem
    of tools](https://ilya-sher.org/2018/04/10/list-of-json-tools-for-command-line/)
    that output and manipulate JSON.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果传递了 `--json`，则显示格式化的 JSON 输出。** JSON 允许比纯文本更结构化，因此更容易输出和处理复杂数据结构。[`jq`](https://stedolan.github.io/jq/)
    是在命令行中处理 JSON 的常见工具，现在有一个 [完整的工具生态系统](https://ilya-sher.org/2018/04/10/list-of-json-tools-for-command-line/)，用于输出和操作
    JSON。'
- en: It is also widely used on the web, so by using JSON as the input and output
    of programs, you can pipe directly to and from web services using `curl`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它也被广泛用于 Web，所以通过使用 JSON 作为程序的输入和输出，您可以直接使用`curl`来通过管道与 Web 服务进行交互。
- en: '**Display output on success, but keep it brief.** Traditionally, when nothing
    is wrong, UNIX commands display no output to the user. This makes sense when they’re
    being used in scripts, but can make commands appear to be hanging or broken when
    used by humans. For example, `cp` will not print anything, even if it takes a
    long time.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**成功时显示输出，但保持简洁。** 传统上，当没有问题时，UNIX 命令不会向用户显示任何输出。这在脚本中使用时是有道理的，但当人类使用时，这可能使命令看起来似乎被悬挂或损坏。例如，即使`cp`花费很长时间，也不会打印任何东西。'
- en: It’s rare that printing nothing at all is the best default behavior, but it’s
    usually best to err on the side of less.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 很少出现打印什么都不是最佳的默认行为，但通常最好减少输出。
- en: For instances where you do want no output (for example, when used in shell scripts),
    to avoid clumsy redirection of `stderr` to `/dev/null`, you can provide a `-q`
    option to suppress all non-essential output.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些需要没有任何输出的情况（例如在 shell 脚本中使用时），要避免笨拙地将`stderr`重定向到`/dev/null`，您可以提供一个`-q`选项来抑制所有非必要的输出。
- en: '**If you change state, tell the user.** When a command changes the state of
    a system, it’s especially valuable to explain what has just happened, so the user
    can model the state of the system in their head—particularly if the result doesn’t
    directly map to what the user requested.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果更改状态，请告知用户。** 当命令更改系统的状态时，解释刚发生的事情是特别有价值的，这样用户可以在头脑中模拟系统的状态，特别是如果结果与用户请求的内容没有直接对应。'
- en: 'For example, `git push` tells you exactly what it is doing, and what the new
    state of the remote branch is:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`git push` 会准确告诉您它正在做什么，以及远程分支的新状态是什么：
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Make it easy to see the current state of the system.** If your program does
    a lot of complex state changes and it is not immediately visible in the filesystem,
    make sure you make this easy to view.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**使当前系统状态易于查看。** 如果您的程序进行了大量复杂的状态更改，且在文件系统中不立即可见，请确保轻松查看这一点。'
- en: 'For example, `git status` tells you as much information as possible about the
    current state of your Git repository, and some hints at how to modify the state:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`git status` 将向您提供有关 Git 存储库当前状态的尽可能多的信息，并提供一些建议，用于修改状态：
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Suggest commands the user should run.** When several commands form a workflow,
    suggesting to the user commands they can run next helps them learn how to use
    your program and discover new functionality. For example, in the `git status`
    output above, it suggests commands you can run to modify the state you are viewing.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**建议用户需要运行哪些命令。** 当多个命令构成工作流时，建议用户可以运行下一步的命令，有助于他们学习如何使用你的程序，并发现新功能。例如，在上面的`git
    status`输出中，它建议你可以运行的命令来修改你正在查看的状态。'
- en: '**Actions crossing the boundary of the program’s internal world should usually
    be explicit.** This includes things like:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序内部世界边界上的操作通常应该是明确的。** 这些内容包括：'
- en: Reading or writing files that the user didn’t explicitly pass as arguments (unless
    those files are storing internal program state, such as a cache).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取或写入用户未明确传递的文件（除非这些文件存储了内部程序状态，如缓存）。
- en: Talking to a remote server, e.g. to download a file.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与远程服务器通信，例如下载文件。
- en: '**Increase information density—with ASCII art!** For example, `ls` shows permissions
    in a scannable way. When you first see it, you can ignore most of the information.
    Then, as you learn how it works, you pick out more patterns over time.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**提高信息密度——使用 ASCII 艺术！** 例如，`ls`以一种易于扫描的方式显示权限。当你第一次看到它时，你可以忽略大部分信息。然后，随着你了解它是如何工作的，你会随着时间的推移发现更多的模式。'
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Use color with intention.** For example, you might want to highlight some
    text so the user notices it, or use red to indicate an error. Don’t overuse it—if
    everything is a different color, then the color means nothing and only makes it
    harder to read.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**有意识地使用颜色。** 例如，你可能想要突出一些文本，以便用户注意到它，或者使用红色来指示错误。不要滥用 —— 如果一切都是不同的颜色，那么颜色就毫无意义，只会使阅读变得更困难。'
- en: '**Disable color if your program is not in a terminal or the user requested
    it.** These things should disable colors:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你的程序不在终端中或者用户要求禁用颜色，请禁用颜色。** 这些事情应该禁用颜色：'
- en: '`stdout` or `stderr` is not an interactive terminal (a TTY). It’s best to individually
    check—if you’re piping `stdout` to another program, it’s still useful to get colors
    on `stderr`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdout`或`stderr`不是交互式终端（TTY）。最好是逐个检查——如果你正在将`stdout`传递给另一个程序，那么在`stderr`上获得颜色仍然是有用的。'
- en: The `NO_COLOR` environment variable is set.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置了`NO_COLOR`环境变量。
- en: The `TERM` environment variable has the value `dumb`.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERM`环境变量的值为`dumb`。'
- en: The user passes the option `--no-color`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户传递了选项`--no-color`。
- en: You may also want to add a `MYAPP_NO_COLOR` environment variable in case users
    want to disable color specifically for your program.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户还可以添加一个`MYAPP_NO_COLOR`环境变量，以便用户可以专门禁用你的程序的颜色。
- en: '*Further reading: [no-color.org](https://no-color.org/), [12 Factor CLI Apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*进一步阅读：[no-color.org](https://no-color.org/)，[12 因素 CLI 应用](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)*'
- en: '**If `stdout` is not an interactive terminal, don’t display any animations.**
    This will stop progress bars turning into Christmas trees in CI log output.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果`stdout`不是交互式终端，请不要显示任何动画。** 这样可以防止进度条在 CI 日志输出中变成圣诞树。'
- en: '**Use symbols and emoji where it makes things clearer.** Pictures can be better
    than words if you need to make several things distinct, catch the user’s attention,
    or just add a bit of character. Be careful, though—it can be easy to overdo it
    and make your program look cluttered or feel like a toy.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**在使事情更清晰的地方使用符号和表情符号。** 如果需要使几件事情变得不同、抓住用户的注意力或者增加一些个性，那么图片可能比文字更好。不过要小心，因为可能很容易就过火了，让你的程序看起来杂乱无章或者感觉像玩具一样。'
- en: 'For example, [yubikey-agent](https://github.com/FiloSottile/yubikey-agent)
    uses emoji to add structure to the output so it isn’t just a wall of text, and
    a ❌ to draw your attention to an important piece of information:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[yubikey-agent](https://github.com/FiloSottile/yubikey-agent)使用表情符号来为输出添加结构，使其不再是一堵文字墙，还有一个❌来吸引你的注意力，指向一个重要的信息：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**By default, don’t output information that’s only understandable by the creators
    of the software.** If a piece of output serves only to help you (the developer)
    understand what your software is doing, it almost certainly shouldn’t be displayed
    to normal users by default—only in verbose mode.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认情况下，不要输出只有软件创建者能理解的信息。** 如果一部分输出只为了帮助你（开发者）理解你的软件在做什么，那么它几乎肯定不应该默认显示给普通用户——只应在详细模式下显示。'
- en: Invite usability feedback from outsiders and people who are new to your project.
    They’ll help you see important issues that you are too close to the code to notice.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请邀请外部人和对你的项目不熟悉的人给出可用性反馈。他们会帮助你发现你太靠近代码而忽略了的重要问题。
- en: '**Don’t treat `stderr` like a log file, at least not by default.** Don’t print
    log level labels (`ERR`, `WARN`, etc.) or extraneous contextual information, unless
    in verbose mode.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要将`stderr`当作日志文件，至少不是默认情况下。** 不要打印日志级别标签（`ERR`、`WARN`等）或者多余的上下文信息，除非处于详细模式。'
- en: '**Use a pager (e.g. `less`) if you are outputting a lot of text.** For example,
    `git diff` does this by default. Using a pager can be error-prone, so be careful
    with your implementation such that you don’t make the experience worse for the
    user. You shouldn’t use a pager if `stdin` or `stdout` is not an interactive terminal.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果输出了大量文本，使用分页器（例如`less`）。** 例如，默认情况下`git diff`就会这样做。使用分页器可能会出现错误，所以要小心你的实现，以免让用户体验变得更糟。如果`stdin`或`stdout`不是交互式终端，就不应该使用分页器。'
- en: A good sensible set of options to use for `less` is `less -FIRX`. This does
    not page if the content fills one screen, ignores case when you search, enables
    color and formatting, and leaves the contents on the screen when `less` quits.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很明智的`less`选项设置是`less -FIRX`。如果内容填满一个屏幕，它不会分页；在搜索时忽略大小写，启用颜色和格式，以及当`less`退出时保留内容。
- en: There might be libraries in your language that are more robust than piping to
    `less`. For example, [pypager](https://github.com/prompt-toolkit/pypager) in Python.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你的语言中可能有比传输到`less`更强大的库。例如，Python 中的[pypager](https://github.com/prompt-toolkit/pypager)。
- en: Errors
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误
- en: One of the most common reasons to consult documentation is to fix errors. If
    you can make errors into documentation, then this will save the user loads of
    time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一条最常见的参考文档的原因是修复错误。如果你能将错误变成文档，那么这将为用户节省大量时间。
- en: '**Catch errors and rewrite them for humans.** If you’re expecting an error
    to happen, catch it and rewrite the error message to be useful. Think of it like
    a conversation, where the user has done something wrong and the program is guiding
    them in the right direction. Example: “Can’t write to file.txt. You might need
    to make it writable by running ‘chmod +w file.txt’.”'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**捕获错误并对人类进行重新编写。** 如果你预期会出现错误，就捕获它并将错误消息重新编写为有用的内容。把它看作一场对话，用户做错了一些事情，程序在引导他们走向正确的方向。例如：“无法写入
    file.txt。您可能需要通过运行''chmod +w file.txt''使其可写”。'
- en: '**Signal-to-noise ratio is crucial.** The more irrelevant output you produce,
    the longer it’s going to take the user to figure out what they did wrong. If your
    program produces multiple errors of the same type, consider grouping them under
    a single explanatory header instead of printing many similar-looking lines.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**信噪比至关重要。** 你产生的无关紧要的输出越多，用户弄清楚自己做错了什么就会花费更长的时间。如果你的程序产生了多个相同类型的错误，请考虑将它们分组在一个解释性的标题下，而不是打印许多看起来相似的行。'
- en: '**Consider where the user will look first.** Put the most important information
    at the end of the output. The eye will be drawn to red text, so use it intentionally
    and sparingly.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑用户首先会在哪里查找。** 将最重要的信息放在输出的末尾。眼睛会被红色文本吸引，所以要有意识地适度使用它。'
- en: '**If there is an unexpected or unexplainable error, provide debug and traceback
    information, and instructions on how to submit a bug.** That said, don’t forget
    about the signal-to-noise ratio: you don’t want to overwhelm the user with information
    they don’t understand. Consider writing the debug log to a file instead of printing
    it to the terminal.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果出现意外或无法解释的错误，请提供调试和跟踪信息，并说明如何提交错误。** 也不要忘记信噪比：你不想用用户不理解的信息压倒他们。考虑将调试日志写入文件，而不是打印到终端上。'
- en: '**Make it effortless to submit bug reports.** One nice thing you can do is
    provide a URL and have it pre-populate as much information as possible.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**让提交错误报告变得轻而易举。** 你可以做的一件好事就是提供一个 URL，并尽可能多地填充信息。'
- en: '*Further reading: [Google: Writing Helpful Error Messages](https://developers.google.com/tech-writing/error-messages),
    [Nielsen Norman Group: Error-Message Guidelines](https://www.nngroup.com/articles/error-message-guidelines)*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*更多阅读：[Google：编写有用的错误消息](https://developers.google.com/tech-writing/error-messages)，[尼尔森诺曼集团：错误消息指南](https://www.nngroup.com/articles/error-message-guidelines)*'
- en: Arguments and flags
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数和标志
- en: 'A note on terminology:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于术语的说明：
- en: '*Arguments*, or *args*, are positional parameters to a command. For example,
    the file paths you provide to `cp` are args. The order of args is often important:
    `cp foo bar` means something different from `cp bar foo`.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数*或*args*是命令的位置参数。例如，你提供给`cp`的文件路径就是参数。参数的顺序通常很重要：`cp foo bar`和`cp bar foo`的意义是不同的。'
- en: '*Flags* are named parameters, denoted with either a hyphen and a single-letter
    name (`-r`) or a double hyphen and a multiple-letter name (`--recursive`). They
    may or may not also include a user-specified value (`--file foo.txt`, or `--file=foo.txt`).
    The order of flags, generally speaking, does not affect program semantics.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标志*是命名参数，用连字符和单字母名称（`-r`）或双连字符和多字母名称（`--recursive`）表示。它们可能也可能不包括用户指定的值（`--file
    foo.txt`或`--file=foo.txt`）。总的来说，标志的顺序不会影响程序的语义。'
- en: '**Prefer flags to args.** It’s a bit more typing, but it makes it much clearer
    what is going on. It also makes it easier to make changes to how you accept input
    in the future. Sometimes when using args, it’s impossible to add new input without
    breaking existing behavior or creating ambiguity.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先使用标志而不是参数。** 这样打字可能会多一点，但这样会让情况变得更加清晰。这也让未来对输入方式的更改变得更容易。有时使用参数时，要添加新的输入而不破坏现有行为或产生歧义是不可能的。'
- en: '*Citation: [12 Factor CLI Apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46).*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用：[12 个因素 CLI 应用](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)*'
- en: '**Have full-length versions of all flags.** For example, have both `-h` and
    `--help`. Having the full version is useful in scripts where you want to be verbose
    and descriptive, and you don’t have to look up the meaning of flags everywhere.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**拥有所有标志的完整版本。** 例如，既有`-h`也有`--help`。在想要冗长和描述性的脚本中，拥有完整版本是非常有用的，这样你就不必到处查找标志的意义。'
- en: '*Citation: [GNU Coding Standards](https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html).*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用：[GNU 编码标准](https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html)*'
- en: '**Only use one-letter flags for commonly used flags,** particularly at the
    top-level when using subcommands. That way you don’t “pollute” your namespace
    of short flags, forcing you to use convoluted letters and cases for flags you
    add in the future.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**只使用一个字母的标志来表示常用的标志，** 特别是在使用子命令时的顶层。这样你就不会“污染”你的短标志名称空间，迫使你在未来添加标志时使用复杂的字母和规则。'
- en: '**Multiple arguments are fine for simple actions against multiple files.**
    For example, `rm file1.txt file2.txt file3.txt`. This also makes it work with
    globbing: `rm *.txt`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**对多个文件执行简单操作是可以的。** 例如，`rm file1.txt file2.txt file3.txt`。这也使它适用于通配符：`rm *.txt`。'
- en: '**If you’ve got two or more arguments for different things, you’re probably
    doing something wrong.** The exception is a common, primary action, where the
    brevity is worth memorizing. For example, `cp <source> <destination>`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你有两个或更多的参数用于不同的事情，那么你可能在做错什么。** 例外是一个常见的主要动作，其中简洁值得记忆。例如，`cp <source> <destination>`。'
- en: '*Citation: [12 Factor CLI Apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46).*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用：[12 个因素 CLI 应用](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)*'
- en: '**Use standard names for flags, if there is a standard.** If another commonly
    used command uses a flag name, it’s best to follow that existing pattern. That
    way, a user doesn’t have to remember two different options (and which command
    it applies to), and users can even guess an option without having to look at the
    help text.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果有标准，请使用标准名称的标志。**如果另一个常用命令使用标志名称，最好遵循现有模式。这样，用户不必记住两种不同的选项（以及它适用于哪个命令），甚至可以猜测一个选项，而不必查看帮助文本。'
- en: 'Here’s a list of commonly used options:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常用选项的列表：
- en: '`-a`, `--all`: All. For example, `ps`, `fetchmail`.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`，`--all`：全部。例如，`ps`，`fetchmail`。'
- en: '`-d`, `--debug`: Show debugging output.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`，`--debug`：显示调试输出。'
- en: '`-f`, `--force`: Force. For example, `rm -f` will force the removal of files,
    even if it thinks it does not have permission to do it. This is also useful for
    commands which are doing something destructive that usually require user confirmation,
    but you want to force it to do that destructive action in a script.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`，`--force`：强制。例如，`rm -f`将强制删除文件，即使它认为没有权限执行也会执行。这也适用于通常需要用户确认的具有破坏性操作的命令，但您想要在脚本中强制执行该破坏性操作。'
- en: '`--json`: Display JSON output. See the [output](#output) section.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--json`：显示JSON输出。请参见[输出](#output)部分。'
- en: '`-h`, `--help`: Help. This should only mean help. See the [help](#help) section.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`，`--help`：帮助。这应该只表示帮助。请参见[帮助](#help)部分。'
- en: '`--no-input`: See the [interactivity](#interactivity) section.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-input`：请参见[交互](#interactivity)部分。'
- en: '`-o`, `--output`: Output file. For example, `sort`, `gcc`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o`，`--output`：输出文件。例如，`sort`，`gcc`。'
- en: '`-p`, `--port`: Port. For example, `psql`, `ssh`.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`，`--port`：端口。例如，`psql`，`ssh`。'
- en: '`-q`, `--quiet`: Quiet. Display less output. This is particularly useful when
    displaying output for humans that you might want to hide when running in a script.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-q`，`--quiet`：安静。显示较少的输出。在显示人类可能想要在脚本中运行时隐藏的输出时特别有用。'
- en: '`-u`, `--user`: User. For example, `ps`, `ssh`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u`，`--user`：用户。例如，`ps`，`ssh`。'
- en: '`--version`: Version.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--version`：版本。'
- en: '`-v`: This can often mean either verbose or version. You might want to use
    `-d` for verbose and this for version, or for nothing to avoid confusion.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`：这通常可以表示详细或版本。您可能想要使用`-d`表示详细，使用这个表示版本，或者什么都不表示以避免混淆。'
- en: '**Make the default the right thing for most users.** Making things configurable
    is good, but most users are not going to find the right flag and remember to use
    it all the time (or alias it). If it’s not the default, you’re making the experience
    worse for most of your users.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**使默认选项适合大多数用户**。使事物可配置是好的，但大多数用户可能不会找到正确的标志并记住始终使用它（或者设置别名）。如果这不是默认选项，那么对于大多数用户来说，体验会变得更糟。'
- en: For example, `ls` has terse default output to optimize for scripts and other
    historical reasons, but if it were designed today, it would probably default to
    `ls -lhF`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ls`具有简洁的默认输出，以优化脚本和其他历史原因，但如果今天设计的话，它可能默认为`ls -lhF`。
- en: '**Prompt for user input.** If a user doesn’t pass an argument or flag, prompt
    for it. (See also: [Interactivity](#interactivity))'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示用户输入。**如果用户没有传递参数或标志，请提示输入。(另请参阅：[交互操作](#interactivity))'
- en: '**Never *require* a prompt.** Always provide a way of passing input with flags
    or arguments. If `stdin` is not an interactive terminal, skip prompting and just
    require those flags/args.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**永远不要*要求*提示。**始终提供通过标志或参数传递输入的方式。如果`stdin`不是交互式终端，则跳过提示，只需要求这些标志/参数。'
- en: '**Confirm before doing anything dangerous.** A common convention is to prompt
    for the user to type `y` or `yes` if running interactively, or requiring them
    to pass `-f` or `--force` otherwise.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**在执行任何危险操作前确认**。一个普遍约定是提示用户在交互式运行时键入`y`或`yes`，否则要求他们传递`-f`或`--force`。'
- en: '“Dangerous” is a subjective term, and there are differing levels of danger:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: “危险”是一个主观术语，有不同级别的危险：
- en: '**Mild:** A small, local change such as deleting a file. You might want to
    prompt for confirmation, you might not. For example, if the user is explicitly
    running a command called something like “delete,” you probably don’t need to ask.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻微:** 一个小的本地更改，比如删除文件。您可能要求确认，也可能不需要。例如，如果用户明确运行了一个称为“delete”的命令，您可能不需要询问。'
- en: '**Moderate:** A bigger local change like deleting a directory, a remote change
    like deleting a resource of some kind, or a complex bulk modification that can’t
    be easily undone. You usually want to prompt for confirmation here. Consider giving
    the user a way to “dry run” the operation so they can see what’ll happen before
    they commit to it.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中度:** 像删除目录这样的更大的本地更改，删除某种资源的远程更改，或者不能轻松撤销的复杂批量修改。通常，您需要提示用户进行确认。考虑为用户提供“干扰运行”操作的方式，以便他们在确定之前可以看到会发生什么。'
- en: '**Severe:** Deleting something complex, like an entire remote application or
    server. You don’t just want to prompt for confirmation here—you want to make it
    hard to confirm by accident. Consider asking them to type something non-trivial
    such as the name of the thing they’re deleting. Let them alternatively pass a
    flag such as `--confirm="name-of-thing"`, so it’s still scriptable.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**严重:** 删除复杂的东西，比如整个远程应用程序或服务器。您不仅仅想在这里提示用户确认—您想使意外确认变得困难。考虑要求他们键入非平凡的东西，例如要删除的事物的名称。让他们也可以传递类似`--confirm="name-of-thing"`这样的标志，这样它仍然可以用脚本编写。'
- en: Consider whether there are non-obvious ways to accidentally destroy things.
    For example, imagine a situation where changing a number in a configuration file
    from 10 to 1 means that 9 things will be implicitly deleted—this should be considered
    a severe risk, and should be difficult to do by accident.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑是否有非显而易见的方式会意外破坏事物。例如，想象一种情况，将配置文件中的数字从10改为1意味着将有9个事物被隐式删除—这应被视为严重风险，并且应难以意外发生。
- en: '**If input or output is a file, support `-` to read from `stdin` or write to
    `stdout`.** This lets the output of another command be the input of your command
    and vice versa, without using a temporary file. For example, `tar` can extract
    files from `stdin`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果输入或输出是文件，请支持 `-` 读取 `stdin` 或写入 `stdout`。**这样你可以在不使用临时文件的情况下，让另一个命令的输出成为你的命令的输入，反之亦然。例如，`tar`
    可以从 `stdin` 提取文件：'
- en: '[PRE11]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**If a flag can accept an optional value, allow a special word like “none.”**
    For example, `ssh -F` takes an optional filename of an alternative `ssh_config`
    file, and `ssh -F none` runs SSH with no config file. Don’t just use a blank value—this
    can make it ambiguous whether arguments are flag values or arguments.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果标志可以接受可选值，请允许使用 “none” 等特殊词语。** 例如，`ssh -F` 接受一个可选的 `ssh_config` 文件的文件名，并且
    `ssh -F none` 会以无配置文件的方式运行 SSH。不要只使用一个空值，这可能会使参数是标志值还是参数变得模糊不清。'
- en: '**If possible, make arguments, flags and subcommands order-independent.** A
    lot of CLIs, especially those with subcommands, have unspoken rules on where you
    can put various arguments. For example a command might have a `--foo` flag that
    only works if you put it before the subcommand:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果可能的话，请使参数、标志和子命令的顺序无关紧要。**许多命令行界面，尤其是那些带有子命令的界面，在放置各种参数的位置上都有不成文的规则。例如，一个命令可以有一个
    `--foo` 标志，只能在子命令之前使用。'
- en: '[PRE12]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This can be very confusing for the user—especially given that one of the most
    common things users do when trying to get a command to work is to hit the up arrow
    to get the last invocation, stick another option on the end, and run it again.
    If possible, try to make both forms equivalent, although you might run up against
    the limitations of your argument parser.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对用户来说这可能会很困惑，特别是当用户试图让命令正常工作时，最常见的事情之一就是按上箭头获取上次调用，添加其他选项并再次运行。如果可能的话，尽量使这两种形式等效，尽管你可能会受到参数解析器的限制。
- en: '**Do not read secrets directly from flags.** When a command accepts a secret,
    eg. via a `--password` argument, the argument value will leak the secret into
    `ps` output and potentially shell history. And, this sort of flag encourages the
    use of insecure environment variables for secrets.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要直接从标志中读取机密信息**。当一个命令接受机密信息时，例如通过 `--password` 参数，参数值会泄露机密信息到 `ps` 输出和潜在的
    shell 历史记录中。此类标志会鼓励使用不安全的环境变量来存储机密信息。'
- en: Consider accepting sensitive data only via files, e.g. with a `--password-file`
    argument, or via `stdin`. A `--password-file` argument allows a secret to be passed
    in discreetly, in a wide variety of contexts.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 应考虑仅通过文件接受敏感数据，例如通过 `--password-file` 参数或通过 `stdin`。 `--password-file` 参数允许将秘密信息在各种上下文中以隐蔽的方式传递。
- en: (It’s possible to pass a file’s contents into an argument in Bash by using `--password
    $(< password.txt)`. This approach has the same security issue of leaking the file’s
    contents into the output of `ps`. It’s best avoided.)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: （在Bash中可以通过使用 `--password $(< password.txt)` 将文件内容传递给参数。 这种方法有一个泄漏文件内容的安全问题，会在
    `ps` 的输出中暴露。 最好避免使用。）
- en: Interactivity
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互性
- en: '**Only use prompts or interactive elements if `stdin` is an interactive terminal
    (a TTY).** This is a pretty reliable way to tell whether you’re piping data into
    a command or whether it’s being run in a script, in which case a prompt won’t
    work and you should throw an error telling the user what flag to pass.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**只有当 `stdin` 是交互式终端（TTY）时，才使用提示或交互元素。**这是一个相当可靠的方法，可以确定您是将数据管道传入命令，还是在脚本中运行命令。在这种情况下，提示将不起作用，应该抛出一个错误，告诉用户应传递哪个标志。'
- en: '**If `--no-input` is passed, don’t prompt or do anything interactive.** This
    allows users an explicit way to disable all prompts in commands. If the command
    requires input, fail and tell the user how to pass the information as a flag.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果传递了 `--no-input`，不要提示或提供任何交互式功能。**这允许用户显式地禁用命令中的所有提示。如果命令需要输入，则应该提示失败，并告诉用户如何将信息作为标志传递。'
- en: '**If you’re prompting for a password, don’t print it as the user types.** This
    is done by turning off echo in the terminal. Your language should have helpers
    for this.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果提示输入密码，请不要随着用户输入而打印密码。**这可以通过在终端中关闭回显来实现。您的语言应该有相应的辅助程序。'
- en: '**Let the user escape.** Make it clear how to get out. (Don’t do what vim does.)
    If your program hangs on network I/O etc, always make Ctrl-C still work. If it’s
    a wrapper around program execution where Ctrl-C can’t quit (SSH, tmux, telnet,
    etc), make it clear how to do that. For example, SSH allows escape sequences with
    the `~` escape character.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**让用户有所逃逸。**清楚地说明如何退出。（不要像 vim 那样做。）如果您的程序在网络 I/O 等方面挂起，始终使 Ctrl-C 仍然有效。如果它是程序执行的包装器，其中
    Ctrl-C 无法退出（SSH、tmux、telnet 等），请明确说明如何做。例如，SSH 允许使用 `~` 逃逸字符的逃逸序列。'
- en: Subcommands
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子命令
- en: If you’ve got a tool that’s sufficiently complex, you can reduce its complexity
    by making a set of subcommands. If you have several tools that are very closely
    related, you can make them easier to use and discover by combining them into a
    single command (for example, RCS vs. Git).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个足够复杂的工具，可以通过创建一组子命令来降低其复杂性。如果有几个非常相关的工具，可以将它们合并成一个单一命令，以便更容易使用和发现（例如，RCS
    vs. Git）。
- en: They’re useful for sharing stuff—global flags, help text, configuration, storage
    mechanisms.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 用于共享内容——全局标志、帮助文本、配置、存储机制都很有用。
- en: '**Be consistent across subcommands.** Use the same flag names for the same
    things, have similar output formatting, etc.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**在各级子命令中保持一致。** 对相同的事物使用相同的标志名称，具有类似的输出格式等。'
- en: '**Use consistent names for multiple levels of subcommand.** If a complex piece
    of software has lots of objects and operations that can be performed on those
    objects, it is a common pattern to use two levels of subcommand for this, where
    one is a noun and one is a verb. For example, `docker container create`. Be consistent
    with the verbs you use across different types of objects.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于多级子命令，请使用统一的命名。** 如果一个复杂的软件有许多对象和可以对这些对象执行操作的操作，常见的模式是使用两级子命令，一个是名词，一个是动词。例如，`docker
    container create`。在不同类型的对象上使用相同的动词时要保持一致。'
- en: Either `noun verb` or `verb noun` ordering works, but `noun verb` seems to be
    more common.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`名词动词` 或 `动词名词` 的顺序都可以，但 `名词动词` 似乎更常见。'
- en: '*Further reading: [User experience, CLIs, and breaking the world, by John Starich](https://uxdesign.cc/user-experience-clis-and-breaking-the-world-baed8709244f).*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*延伸阅读：[用户体验、CLI和打破世界，约翰·斯塔里奇著](https://uxdesign.cc/user-experience-clis-and-breaking-the-world-baed8709244f)。*'
- en: '**Don’t have ambiguous or similarly-named commands.** For example, having two
    subcommands called “update” and “upgrade” is quite confusing. You might want to
    use different words, or disambiguate with extra words.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要有模糊或同名的命令。** 例如，拥有两个名为“update”和“upgrade”的子命令相当令人困惑。你可能希望使用不同的词，或者用额外的词来消除歧义。'
- en: Robustness
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鲁棒性
- en: '**Validate user input.** Everywhere your program accepts data from the user,
    it will eventually be given bad data. Check early and bail out before anything
    bad happens, and [make the errors understandable](#errors).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证用户输入。** 在你的程序接受用户数据的任何地方，它最终会收到错误的数据。尽早检查并在发生问题之前退出，然后[让错误也能被理解](#errors)。'
- en: '**Responsive is more important than fast.** Print something to the user in
    <100ms. If you’re making a network request, print something before you do it so
    it doesn’t hang and look broken.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应性比速度更重要。** 在<100ms内向用户打印一些东西。如果要进行网络请求，在执行之前打印一些内容，这样它就不会变得卡住看起来像是出了故障。'
- en: '**Show progress if something takes a long time.** If your program displays
    no output for a while, it will look broken. A good spinner or progress indicator
    can make a program appear to be faster than it is.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**在需要花费很长时间的事情上显示进度。** 如果你的程序一段时间没有显示任何输出，它看起来就像是出了故障。一个好的旋转器或进度指示器可以使程序看起来比实际更快。'
- en: Ubuntu 20.04 has a nice progress bar that sticks to the bottom of the terminal.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 20.04有一个漂亮的进度条，它粘贴在终端底部。
- en: If the progress bar gets stuck in one place for a long time, the user won’t
    know if stuff is still happening or if the program’s crashed. It’s good to show
    estimated time remaining, or even just have an animated component, to reassure
    them that you’re still working on it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进度条在一个地方停滞了很长时间，用户将不知道事情是否仍在进行，或者程序是否崩溃了。显示估计剩余时间是很好的，甚至只要有一个动画组件，来让他们放心你仍在努力。
- en: There are many good libraries for generating progress bars. For example, [tqdm](https://github.com/tqdm/tqdm)
    for Python, [schollz/progressbar](https://github.com/schollz/progressbar) for
    Go, and [node-progress](https://github.com/visionmedia/node-progress) for Node.js.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于生成进度条的好库。例如，Python的[tqdm](https://github.com/tqdm/tqdm)，Go的[schollz/progressbar](https://github.com/schollz/progressbar)，和Node.js的[node-progress](https://github.com/visionmedia/node-progress)。
- en: '**Do stuff in parallel where you can, but be thoughtful about it.** It’s already
    difficult to report progress in the shell; doing it for parallel processes is
    ten times harder. Make sure it’s robust, and that the output isn’t confusingly
    interleaved. If you can use a library, do so—this is code you don’t want to write
    yourself. Libraries like [tqdm](https://github.com/tqdm/tqdm) for Python and [schollz/progressbar](https://github.com/schollz/progressbar)
    for Go support multiple progress bars natively.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**在可以的地方并行做事情，但要慎之又慎。** 在shell中报告进度已经很困难了；对并行进程这样做要难上十倍。确保它是鲁棒的，并且输出不会被混在一起迷惑人。如果可以使用库，那就使用吧——这段代码你不想自己写。像Python的[tqdm](https://github.com/tqdm/tqdm)和Go的[schollz/progressbar](https://github.com/schollz/progressbar)这样的库天生支持多个进度条。'
- en: The upside is that it can be a huge usability gain. For example, `docker pull`’s
    multiple progress bars offer crucial insight into what’s going on.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 其好处在于这可以是巨大的可用性提升。例如，`docker pull`的多个进度条为用户提供了对正在进行的事情的重要见解。
- en: '[PRE13]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'One thing to be aware of: hiding logs behind progress bars when things go *well*
    makes it much easier for the user to understand what’s going on, but if there
    is an error, make sure you print out the logs. Otherwise, it will be very hard
    to debug.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是：当事情进行顺利时，将日志隐藏在进度条后面会使用户更容易理解正在发生什么，但是如果出现错误，一定要确保打印出日志。否则，调试将会非常困难。
- en: '**Make things time out.** Allow network timeouts to be configured, and have
    a reasonable default so it doesn’t hang forever.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置超时。** 允许网络超时进行配置，并设定一个合理的默认值，这样它就不会永远悬而未决。'
- en: '**Make it recoverable.** If the program fails for some transient reason (e.g.
    the internet connection went down), you should be able to hit `<up>` and `<enter>`
    and it should pick up from where it left off.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**使其可恢复。** 如果程序因一些暂时的原因（例如，网络连接断开）失败，你应该能够按 `<up>` 和 `<enter>`，它就应该从离开的地方继续下去。'
- en: '**Make it crash-only.** This is the next step up from idempotence. If you can
    avoid needing to do any cleanup after operations, or you can defer that cleanup
    to the next run, your program can exit immediately on failure or interruption.
    This makes it both more robust and more responsive.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**使其仅崩溃。** 这是从幂等性演进而来的下一个步骤。如果你可以避免需要在操作之后进行任何清理，或者你可以将那些清理推迟到下一次运行，你的程序在失败或中断时可以立即退出。这样它既更加鲁棒又更加响应。'
- en: '*Citation: [Crash-only software: More than meets the eye](https://lwn.net/Articles/191059/).*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用：[仅崩溃软件：远不止眼见的](https://lwn.net/Articles/191059/)。*'
- en: '**People are going to misuse your program.** Be prepared for that. They will
    wrap it in scripts, use it on bad internet connections, run many instances of
    it at once, and use it in environments you haven’t tested in, with quirks you
    didn’t anticipate. (Did you know macOS filesystems are case-insensitive but also
    case-preserving?)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**人们会误用你的程序。** 对此要有心理准备。他们会将其包装在脚本中，在不稳定的网络连接上使用它，同时运行许多实例，并在你没有测试过的环境中使用它，带有你没有预料到的怪癖。（你知道macOS文件系统是不区分大小写但同时又是保存大小写的吗？）'
- en: Future-proofing
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未来的准备
- en: 'In software of any kind, it’s crucial that interfaces don’t change without
    a lengthy and well-documented deprecation process. Subcommands, arguments, flags,
    configuration files, environment variables: these are all interfaces, and you’re
    committing to keeping them working. ([Semantic versioning](https://semver.org/)
    can only excuse so much change; if you’re putting out a major version bump every
    month, it’s meaningless.)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何种软件，至关重要的是，接口不会在没有长期和充分记录的废弃过程的情况下更改。子命令、参数、标志、配置文件、环境变量：这些都是接口，你要保证它们正常工作。([语义化版本](https://semver.org/)只能原谅这么多的改变；如果你每个月都发布一个主要版本更新，那就是毫无意义了。)
- en: '**Keep changes additive where you can.** Rather than modify the behavior of
    a flag in a backwards-incompatible way, maybe you can add a new flag—as long as
    it doesn’t bloat the interface too much. (See also: [Prefer flags to args](#arguments-and-flags).)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**在你可以的地方保持可附加更改。** 与其以不兼容的方式修改标志的行为，也许你可以添加一个新的标志—只要它不会使接口过于臃肿。(另见：[更喜欢标志而不是参数](#arguments-and-flags).)'
- en: '**Warn before you make a non-additive change.** Eventually, you’ll find that
    you can’t avoid breaking an interface. Before you do, forewarn your users in the
    program itself: when they pass the flag you’re looking to deprecate, tell them
    it’s going to change soon. Make sure there’s a way they can modify their usage
    today to make it future-proof, and tell them how to do it.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**在做非可附加更改之前警告用户。** 最终，你会发现无法避免破坏一个接口。在你这样做之前，在程序本身中警告用户：当他们传递你要废弃的标志时，告诉他们它很快就要改变了。确保他们能今天就修改他们的用法，使其能适应未来，并告诉他们如何做到。'
- en: 'If possible, you should detect when they’ve changed their usage and not show
    the warning any more: now they won’t notice a thing when you finally roll out
    the change.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，你应该检测到他们已经更改了他们的用法，并且不再显示警告：现在当你最终推出更改时，他们就不会察觉到任何事情了。
- en: '**Changing output for humans is usually OK.** The only way to make an interface
    easy to use is to iterate on it, and if the output is considered an interface,
    then you can’t iterate on it. Encourage your users to use `--plain` or `--json`
    in scripts to keep output stable (see [Output](#output)).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**更改人类输出通常是可以接受的。** 使接口易于使用的唯一方法是对其进行迭代，如果输出被认为是一个接口，那么你不能对其进行迭代。鼓励你的用户在脚本中使用`--plain`或`--json`来保持输出稳定（参见[输出](#output)）。'
- en: '**Don’t have a catch-all subcommand.** If you have a subcommand that’s likely
    to be the most-used one, you might be tempted to let people omit it entirely for
    brevity’s sake. For example, say you have a `run` command that wraps an arbitrary
    shell command:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要有一个捕获所有子命令的命令。** 如果你有一个子命令可能是最常用的，你可能会因为简洁起见而让人们完全省略它。例如，假设你有一个`run`命令，用来包装任意的shell命令：'
- en: '[PRE14]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You could make it so that if the first argument to `mycmd` isn’t the name of
    an existing subcommand, you assume the user means `run`, so they can just type
    this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让如果`mycmd`的第一个参数不是一个现有子命令的名称，你假设用户是指`run`，这样他们可以直接输入这个：
- en: '[PRE15]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This has a serious drawback, though: now you can never add a subcommand named
    `echo`—or *anything at all*—without risking breaking existing usages. If there’s
    a script out there that uses `mycmd echo`, it will do something entirely different
    after that user upgrades to the new version of your tool.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但这有一个严重的缺点：现在你永远不能添加一个名为`echo`的子命令—或者*任何东西*—而不至于冒着破坏现有用法的风险。如果有一个脚本使用了`mycmd
    echo`，那么当用户升级到工具的新版本后，它将做完全不同的事情。
- en: '**Don’t allow arbitrary abbreviations of subcommands.** For example, say your
    command has an `install` subcommand. When you added it, you wanted to save users
    some typing, so you allowed them to type any non-ambiguous prefix, like `mycmd
    ins`, or even just `mycmd i`, and have it be an alias for `mycmd install`. Now
    you’re stuck: you can’t add any more commands beginning with `i`, because there
    are scripts out there that assume `i` means `install`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**不允许对子命令进行任意缩写。** 例如，假设你的命令有一个`install`子命令。当你添加它时，你想节省用户一些输入时间，所以你允许他们输入任何非模糊的前缀，比如`mycmd
    ins`，甚至只是`mycmd i`，并将其作为`mycmd install`的别名。现在你陷入困境：你不能再添加以`i`开头的命令，因为有一些脚本假定`i`表示`install`。'
- en: There’s nothing wrong with aliases—saving on typing is good—but they should
    be explicit and remain stable.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 别名没有问题——节省输入是好事——但它们应该是明确的并保持稳定。
- en: '**Don’t create a “time bomb.”** Imagine it’s 20 years from now. Will your command
    still run the same as it does today, or will it stop working because some external
    dependency on the internet has changed or is no longer maintained? The server
    most likely to not exist in 20 years is the one that you are maintaining right
    now. (But don’t build in a blocking call to Google Analytics either.)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要制造“定时炸弹”。** 想象一下20年后。你的命令会像今天一样运行吗，还是会停止工作，因为一些互联网上的外部依赖已经改变，或者不再维护了？在20年后最有可能不存在的服务器，正是你现在在维护的那个。（但也不要自带阻塞调用Google
    Analytics。）'
- en: Signals and control characters
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号和控制字符
- en: '**If a user hits Ctrl-C (the INT signal), exit as soon as possible.** Say something
    immediately, before you start clean-up. Add a timeout to any clean-up code so
    it can’t hang forever.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果用户按下Ctrl-C（INT信号），尽快退出。** 在开始清理之前，立即说点什么。给任何清理代码添加一个超时，以防它永远挂起。'
- en: '**If a user hits Ctrl-C during clean-up operations that might take a long time,
    skip them.** Tell the user what will happen when they hit Ctrl-C again, in case
    it is a destructive action.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果用户在可能需要很长时间的清理操作期间按下Ctrl-C，就跳过它们。** 告诉用户在他们再次按下Ctrl-C时会发生什么，以防它是一个具有破坏性的操作。'
- en: For example, when quitting Docker Compose, you can hit Ctrl-C a second time
    to force your containers to stop immediately instead of shutting them down gracefully.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，退出Docker Compose时，你可以再次按下Ctrl-C，强制你的容器立即停止而不是优雅地关闭它们。
- en: '[PRE16]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Your program should expect to be started in a situation where clean-up has
    not been run. (See [Crash-only software: More than meets the eye](https://lwn.net/Articles/191059/).)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序应该期待在还没有运行清理的状态下启动。（参见[仅崩溃软件：超出预期的更多](https://lwn.net/Articles/191059/).)
- en: Configuration
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: Command-line tools have lots of different types of configuration, and lots of
    different ways to supply it (flags, environment variables, project-level config
    files). The best way to supply each piece of configuration depends on a few factors,
    chief among them *specificity*, *stability* and *complexity*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具有很多不同类型的配置，以及很多不同的提供方式（标志、环境变量、项目级配置文件）。为每个配置提供的最佳方式取决于一些因素，其中最重要的是*具体性*、*稳定性*和*复杂性*。
- en: 'Configuration generally falls into a few categories:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 配置通常可以分为几类：
- en: Likely to vary from one invocation of the command to the next.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有可能从一次命令调用到下一次命令调用会有所不同。
- en: 'Examples:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例子：
- en: Setting the level of debugging output
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置调试输出级别
- en: Enabling a safe mode or dry run of a program
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用程序的安全模式或试运行
- en: 'Recommendation: **Use [flags](#arguments-and-flags).** [Environment variables](#environment-variables)
    may or may not be useful as well.'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议：**使用[标志](#arguments-and-flags)**。[环境变量](#environment-variables)可能也有用，也可能没有。
- en: Generally stable from one invocation to the next, but not always. Might vary
    between projects. Definitely varies between different users working on the same
    project.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常从一次调用到下一次调用保持稳定，但并非总是如此。可能会因项目而异。绝对会因不同用户在同一项目上的工作而变化。
- en: This type of configuration is often specific to an individual computer.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种类型的配置通常特定于个人计算机。
- en: 'Examples:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例子：
- en: Providing a non-default path to items needed for a program to start
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供程序启动所需的非默认路径
- en: Specifying how or whether color should appear in output
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定输出中颜色应如何显示，或是否应显示颜色
- en: Specifying an HTTP proxy server to route all requests through
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定要将所有请求路由到的HTTP代理服务器
- en: 'Recommendation: **Use [flags](#arguments-and-flags) and probably [environment
    variables](#environment-variables) too.** Users may want to set the variables
    in their shell profile so they apply globally, or in `.env` for a particular project.'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议：**使用[标志](#arguments-and-flags)，可能还要使用[环境变量](#environment-variables)**。用户可能希望在其shell配置文件中设置变量，以便全局应用，或者在`.env`中为特定项目设置。
- en: If this configuration is sufficiently complex, it may warrant a configuration
    file of its own, but environment variables are usually good enough.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果此配置足够复杂，可能需要一个单独的配置文件，但通常环境变量就足够了。
- en: Stable within a project, for all users.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中稳定，适用于所有用户。
- en: This is the type of configuration that belongs in version control. Files like
    `Makefile`, `package.json` and `docker-compose.yml` are all examples of this.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是应该纳入版本控制的配置类型。`Makefile`、`package.json`和`docker-compose.yml`等文件都是此类文件的示例。
- en: 'Recommendation: **Use a command-specific, version-controlled file.**'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议：**使用特定于命令的、版本受控的文件。**
- en: '**Follow the XDG-spec.** In 2010 the X Desktop Group, now [freedesktop.org](https://freedesktop.org),
    developed a specification for the location of base directories where config files
    may be located. One goal was to limit the proliferation of dotfiles in a user’s
    home directory by supporting a general-purpose `~/.config` folder. The XDG Base
    Directory Specification ([full spec](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html),
    [summary](https://wiki.archlinux.org/index.php/XDG_Base_Directory#Specification))
    is supported by yarn, fish, wireshark, emacs, neovim, tmux, and many other projects
    you know and love.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**遵循 XDG 规范。** 2010年，X 桌面组织，现在是[freedesktop.org](https://freedesktop.org)，制定了一个规范，用于配置文件可能位于的基本目录的位置。其中一个目标是通过支持通用的`~/.config`文件夹来限制用户主目录中点文件的增多。XDG基本目录规范（[完整规范](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html)，[摘要](https://wiki.archlinux.org/index.php/XDG_Base_Directory#Specification)）得到了yarn、fish、wireshark、emacs、neovim、tmux等许多你熟悉并喜爱的项目的支持。'
- en: '**If you automatically modify configuration that is not your program’s, ask
    the user for consent and tell them exactly what you’re doing.** Prefer creating
    a new config file (e.g. `/etc/cron.d/myapp`) rather than appending to an existing
    config file (e.g. `/etc/crontab`). If you have to append or modify to a system-wide
    config file, use a dated comment in that file to delineate your additions.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您自动修改不属于您程序的配置，请征求用户同意，并告知他们您正在做什么。** 最好创建一个新的配置文件（例如`/etc/cron.d/myapp`），而不是追加到现有的配置文件（例如`/etc/crontab`）。如果必须追加或修改系统范围的配置文件，请在该文件中使用日期注释来划分您的添加内容。'
- en: '**Apply configuration parameters in order of precedence.** Here is the precedence
    for config parameters, from highest to lowest:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**按照优先顺序应用配置参数。** 这是配置参数的优先顺序，从高到低：'
- en: Flags
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志
- en: The running shell’s environment variables
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 shell 的环境变量
- en: Project-level configuration (eg. `.env`)
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目级配置（例如`.env`）
- en: User-level configuration
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户级配置
- en: System wide configuration
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统范围的配置
- en: Environment variables
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: '**Environment variables are for behavior that *varies with the context* in
    which a command is run.** The “environment” of an environment variable is the
    terminal session—the context in which the command is running. So, an env var might
    change each time a command runs, or between terminal sessions on one machine,
    or between instantiations of one project across several machines.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境变量适用于*随命令运行的上下文*而变化的行为。** 环境变量的“环境”是终端会话——命令运行的上下文。因此，环境变量可能会在每次命令运行时更改，或者在同一台机器上的终端会话之间更改，或者在跨多台机器上的同一个项目的实例化之间更改。'
- en: Environment variables may duplicate the functionality of flags or configuration
    parameters, or they may be distinct from those things. See [Configuration](#configuration)
    for a breakdown of common types of configuration and recommendations on when environment
    variables are most appropriate.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可能复制标志或配置参数的功能，也可能与这些内容不同。有关常见配置类型的详细信息以及关于何时使用环境变量最合适的建议，请参阅[配置](#configuration)。
- en: '**For maximum portability, environment variable names must only contain uppercase
    letters, numbers, and underscores (and mustn’t start with a number).** Which means
    `O_O` and `OWO` are the only emoticons that are also valid environment variable
    names.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了最大限度地提高可移植性，环境变量名称必须只包含大写字母、数字和下划线（并且不能以数字开头）。** 这意味着`O_O`和`OWO`是仅有的也是有效的环境变量名称。'
- en: '**Aim for single-line environment variable values.** While multi-line values
    are possible, they create usability issues with the `env` command.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**在环境变量值时，应力求单行。** 虽然多行值是可能的，但它们会在`env`命令中创建可用性问题。'
- en: '**Avoid commandeering widely used names.** Here’s a [list of POSIX standard
    env vars](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免占用广泛使用的名字。** 这里有一个[POSIX标准环境变量列表](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html)。'
- en: '**Check general-purpose environment variables for configuration values when
    possible:**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**在可能时，检查通用环境变量获取配置值：**'
- en: '`NO_COLOR`, to disable color (see [Output](#output)) or `FORCE_COLOR` to enable
    it and ignore the detection logic'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO_COLOR`，用于禁用颜色（见[输出](#output)）或 `FORCE_COLOR` 用于启用它并忽略检测逻辑'
- en: '`DEBUG`, to enable more verbose output'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG`，以启用更详细的输出'
- en: '`EDITOR`, if you need to prompt the user to edit a file or input more than
    a single line'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EDITOR`，如果你需要提示用户编辑文件或输入多于一行的内容'
- en: '`HTTP_PROXY`, `HTTPS_PROXY`, `ALL_PROXY` and `NO_PROXY`, if you’re going to
    perform network operations (The HTTP library you’re using might already check
    for these.)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_PROXY`，`HTTPS_PROXY`，`ALL_PROXY` 和 `NO_PROXY`，如果你要执行网络操作（你使用的HTTP库可能已经检查了这些）'
- en: '`SHELL`, if you need to open up an interactive session of the user’s preferred
    shell (If you need to execute a shell script, use a specific interpreter like
    `/bin/sh`)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHELL`，如果你需要打开用户首选shell的交互式会话（如果需要执行shell脚本，请使用指定的解释器，如`/bin/sh`）'
- en: '`TERM`, `TERMINFO` and `TERMCAP`, if you’re going to use terminal-specific
    escape sequences'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERM`，`TERMINFO` 和 `TERMCAP`，如果你将使用依赖于终端的转义序列'
- en: '`TMPDIR`, if you’re going to create temporary files'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TMPDIR`，如果你将创建临时文件'
- en: '`HOME`, for locating configuration files'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HOME`，用于定位配置文件'
- en: '`PAGER`, if you want to automatically page output'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PAGER`，如果你想自动分页输出'
- en: '`LINES` and `COLUMNS`, for output that’s dependent on screen size (e.g. tables)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINES` 和 `COLUMNS`，用于依赖于屏幕大小的输出（例如表格）'
- en: '**Read environment variables from `.env` where appropriate.** If a command
    defines environment variables that are unlikely to change as long as the user
    is working in a particular directory, then it should also read them from a local
    `.env` file so users can configure it differently for different projects without
    having to specify them every time. Many languages have libraries for reading `.env`
    files ([Rust](https://crates.io/crates/dotenv), [Node](https://www.npmjs.com/package/dotenv),
    [Ruby](https://github.com/bkeepers/dotenv)).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**在合适的情况下从 `.env` 读取环境变量。** 如果一个命令定义了环境变量，只要用户在特定目录中工作，这些变量不太可能改变，那么它应该还从本地的
    `.env` 文件中读取这些变量，这样用户就可以在不同的项目中以不同的方式配置它，而不必每次指定它们。许多编程语言都有用于读取 `.env` 文件的库（[Rust](https://crates.io/crates/dotenv)、[Node](https://www.npmjs.com/package/dotenv)、[Ruby](https://github.com/bkeepers/dotenv)）。'
- en: '**Don’t use `.env` as a substitute for a proper [configuration file](#configuration).**
    `.env` files have a lot of limitations:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要将 `.env` 用作适当的[配置文件](#configuration)的替代。** `.env` 文件有很多限制：'
- en: A `.env` file is not commonly stored in source control
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.env` 文件通常不存储在源代码管理中'
- en: (Therefore, any configuration stored in it has no history)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （因此，其中存储的任何配置都没有历史记录）
- en: 'It has only one data type: string'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只有一种数据类型：字符串
- en: It lends itself to being poorly organized
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它容易组织得不好
- en: It makes encoding issues easy to introduce
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会使编码问题很容易引入
- en: It often contains sensitive credentials & key material that would be better
    stored more securely
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它经常包含敏感凭据和更好地存储的关键材料
- en: If it seems like these limitations will hamper usability or security, then a
    dedicated config file might be more appropriate.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些限制看起来会影响到可用性或安全性，那么一个专门的配置文件可能更合适。
- en: '**Do not read secrets from environment variables.** While environment variables
    may be convenient for storing secrets, they have proven too prone to leakage:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要从环境变量中读取机密信息。** 虽然环境变量可能方便存储机密信息，但它们很容易泄漏：'
- en: Exported environment variables are sent to every process, and from there can
    easily leak into logs or be exfiltrated
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出的环境变量会传递给每个进程，从那里可以轻松泄漏到日志中或外泄
- en: 'Shell substitutions like `curl -H "Authorization: Bearer $BEARER_TOKEN"` will
    leak into globally-readable process state. (cURL offers the `-H @filename` alternative
    for reading sensitive headers from a file.)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类似`curl -H "Authorization: Bearer $BEARER_TOKEN"`的shell替换将泄漏到全局可读进程状态中。 （cURL提供了从文件中读取敏感标头的替代方法`-H
    @filename`。）'
- en: Docker container environment variables can be viewed by anyone with Docker daemon
    access via `docker inspect`
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器中的环境变量可以通过`docker inspect`由拥有Docker守护程序访问权限的任何人查看
- en: Environment variables in systemd units are globally readable via `systemctl
    show`
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Systemd单元中的环境变量是通过`systemctl show`全局可读取的
- en: Secrets should only be accepted via credential files, pipes, `AF_UNIX` sockets,
    secret management services, or another IPC mechanism.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 机密信息应仅通过凭证文件、管道、`AF_UNIX`套接字、秘密管理服务或其他IPC机制接受。
- en: Naming
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名
- en: “Note the obsessive use of abbreviations and avoidance of capital letters; [Unix]
    is a system invented by people to whom repetitive stress disorder is what black
    lung is to miners. Long names get worn down to three-letter nubbins, like stones
    smoothed by a river.” — Neal Stephenson, *[In the Beginning was the Command Line](https://web.stanford.edu/class/cs81n/command.txt)*
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “注意对缩写的过度使用和对大写字母的回避；[Unix] 是由患有重复性压力紊乱的人发明的，对他们来说，它就像煤矿工人的黑肺一样。长名称被磨平，变成了类似被河水冲平的三个字母。”
    — 尼尔·斯蒂芬森，《*在开始是命令行*》（https://web.stanford.edu/class/cs81n/command.txt）。
- en: 'The name of your program is particularly important on the CLI: your users will
    be typing it all the time, and it needs to be easy to remember and type.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在CLI上，程序的名称尤为重要：用户会一直输入它，并且它需要易记和易输入。
- en: '**Make it a simple, memorable word.** But not too generic, or you’ll step on
    the toes of other commands and confuse users. For example, both ImageMagick and
    Windows used the command `convert`.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**将其命名为简单、易记的单词。** 但不要太通用，否则会与其他命令冲突并使用户混淆。例如，ImageMagick 和 Windows 都使用命令 `convert`。'
- en: '**Use only lowercase letters, and dashes if you really need to.** `curl` is
    a good name, `DownloadURL` is not.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**只使用小写字母，如果可能的话可以使用破折号。** `curl` 是一个好名字，`DownloadURL` 不是。'
- en: '**Keep it short.** Users will be typing it all the time. Don’t make it *too*
    short: the very shortest commands are best reserved for the common utilities used
    all the time, such as `cd`, `ls`, `ps`.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**保持简短。** 用户会一直输入。不要*太*短：最短的命令最好保留给一直使用的基本工具，比如`cd` `ls` `ps`。'
- en: '**Make it easy to type.** If you expect people to type your command name all
    day, make it easy on their hands.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**让它更容易输入。** 如果你期望人们整天都会输入你的命令，就要让他们的手更轻松。'
- en: 'A real-world example: long before Docker Compose was `docker compose`, it was
    [`plum`](https://github.com/aanand/fig/blob/0eb7d308615bae1ad4be1ca5112ac7b6b6cbfbaf/setup.py#L26).
    This turned out to be such an awkward, one-handed hopscotch that it was immediately
    renamed to [`fig`](https://github.com/aanand/fig/commit/0cafdc9c6c19dab2ef2795979dc8b2f48f623379),
    which – as well as being shorter – flows much more easily.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真实的例子：早在 Docker Compose 变成`docker compose`之前，它叫[`plum`](https://github.com/aanand/fig/blob/0eb7d308615bae1ad4be1ca5112ac7b6b6cbfbaf/setup.py#L26)。但这个名字是如此别扭，一手玩跳房子，所以立刻改名为[`fig`](https://github.com/aanand/fig/commit/0cafdc9c6c19dab2ef2795979dc8b2f48f623379)，而且更短，流畅度更大。
- en: '*Further reading: [The Poetics of CLI Command Names](https://smallstep.com/blog/the-poetics-of-cli-command-names/)*'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '*查阅更多：[CLI命令名称的韵律](https://smallstep.com/blog/the-poetics-of-cli-command-names/)*'
- en: Distribution
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布
- en: '**If possible, distribute as a single binary.** If your language doesn’t compile
    to binary executables as standard, see if it has something like [PyInstaller](https://www.pyinstaller.org/).
    If you really can’t distribute as a single binary, use the platform’s native package
    installer so you aren’t scattering things on disk that can’t easily be removed.
    Tread lightly on the user’s computer.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果可能的话，分发成一个单一的二进制文件。** 如果你的语言不符合标准编译成二进制可执行文件，请查看类似[PyInstaller](https://www.pyinstaller.org/)的东西。如果真的无法作为一个单一的二进制文件分发，使用平台的本地软件包安装程序，这样就不会把东西随意散布在计算机上，很难清理。对用户的计算机小心翼翼。'
- en: If you’re making a language-specific tool, such as a code linter, then this
    rule doesn’t apply—it’s safe to assume the user has an interpreter for that language
    installed on their computer.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在制作一种特定语言的工具，比如代码检查器，那么这条规则不适用——可以假设用户的计算机里已经安装好了该语言的解释器。
- en: '**Make it easy to uninstall.** If it needs instructions, put them at the bottom
    of the install instructions—one of the most common times people want to uninstall
    software is right after installing it.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**让卸载容易。** 如果需要说明，把它们放在安装说明的最后一部分——在安装完软件后，人们最常见的时候之一就是想要卸载它。'
- en: Analytics
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析
- en: Usage metrics can be helpful to understand how users are using your program,
    how to make it better, and where to focus effort. But, unlike websites, users
    of the command-line expect to be in control of their environment, and it is surprising
    when programs do things in the background without telling them.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用度量指标有助于了解用户如何使用你的程序，如何使它更好，以及应该把工作重点放在哪里。但是，与网站不同，命令行的用户希望控制自己的环境，程序在不告知他们的情况下做事是令人惊讶的。
- en: '**Do not phone home usage or crash data without consent.** Users will find
    out, and they will be angry. Be very explicit about what you collect, why you
    collect it, how anonymous it is and how you go about anonymizing it, and how long
    you retain it for.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要未经同意就传送使用情况或崩溃数据**。用户会发现，他们会生气。非常明确地说明你收集了什么，为什么收集它，匿名程度如何，如何进行匿名化，以及保存多久。'
- en: Ideally, ask users whether they want to contribute data (“opt-in”). If you choose
    to do it by default (“opt-out”), then clearly tell users about it on your website
    or first run, and make it easy to disable.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最好询问用户是否愿意贡献数据（“选择加入”）。如果你选择默认进行（“选择退出”），那么在你的网站或者首次运行时要明确告知用户，并提供简单的禁用方法。
- en: 'Examples of projects that collect usage statistics:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 收集使用统计的项目范例：
- en: '**Consider alternatives to collecting analytics.**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑收集分析的替代方法。**'
- en: Instrument your web docs. If you want to know how people are using your CLI
    tool, make a set of docs around the use cases you’d like to understand best, and
    see how they perform over time. Look at what people search for within your docs.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的网络文档进行调查。如果你想了解人们如何使用你的CLI工具，制作一组围绕你最想了解的用例的文档，并查看它们随着时间的表现。查看人们在文档中搜索了什么。
- en: Instrument your downloads. This can be a rough metric to understand usage and
    what operating systems your users are running.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的下载进行调查。这可以是了解用户使用程度和用户正在使用的操作系统的一个粗略指标。
- en: Talk to your users. Reach out and ask people how they’re using your tool. Encourage
    feedback and feature requests in your docs and repos, and try to draw out more
    context from those who submit feedback.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用户交流。主动出击，询问人们如何使用你的工具。在你的文档和存储库中鼓励反馈和功能请求，并尝试从提交反馈的人那里获取更多上下文。
- en: '*Further reading: [Open Source Metrics](https://opensource.guide/metrics/)*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*查阅更多：[开源度量](https://opensource.guide/metrics/)*'
- en: Further reading
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多阅读
- en: </main>
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**主要页'
