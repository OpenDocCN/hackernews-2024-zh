["```\neffect Read a with\n    read : Unit -> a\n\nthe_value (value: a) (f: Unit -> b can Read a) : b =\n    handle f ()\n    | read () -> resume value \n```", "```\nfoo () : Unit can Read String =\n    s1 = read ()\n    s2 = read ()\n\nfoo () with the_value \"foo\"\n\n// The above is sugar for\n// the_value \"foo\" (fn () -> foo ()) \n```", "```\nthe_value (value: a) (f: Unit -> b can Read a) : b =\n    handle f ()\n    // Error: Handler body moves `value` which will still\n    //         be needed if the handler is called again\n    | read () -> resume value \n```", "```\nbad () : Unit can Read (&own mut Box String) =\n    s1 = read ()\n\n    // Uh-oh, we've just obtained a second mutable owning reference to the same String\n    s2 = read ()\n    s2_inner_ref = as_ref s2\n\n    // Drop the old Box referenced by s1 and s2\n    s1 := Box.of \"foo\"\n\n    // And now we're printing a dangling reference\n    print s2_inner_ref\n\nthe_ref (ref: &own mut t) (f: Unit -> a can Read (&own mut t)) : a =\n    handle f ()\n    | read () -> resume ref\n\nmy_string = mut Box.of \"bar\"\nbad () with the_ref &my_string \n```", "```\nbad () : Unit can Read (&own mut Box String) =\n    s1 = read ()\n\n    // Error: Cannot create a new aliased reference with `s1` still in scope\n    s2 = read ()\n\n    print s1 \n```", "```\nindirect () can Read (&own mut Box String) =\n    read ()\n\nfoo () can Read (&own mut Box String) =\n    r1 = read ()\n\n    // Error: Cannot borrow from `Read` effect again with `r1` still in scope\n    r2 = indirect () \n```", "```\neffect Yield a with\n    yield: a -> Unit\n\nfoo () : Unit can Yield (&own mut I32) =\n    vec = mut Vec.of [1, 2]\n    yield (get_mut &vec 0)\n    vec := Vec.of [3]\n    yield (get_mut &vec 0)\n\nbar () =\n    x = mut None\n\n    handle foo ()\n    | yield y ->\n        if Some x = x then\n            // foo has cleared the underlying vec by this point,\n            // so this would print a dangling reference!\n            print x\n\n        x := Some y\n        resume () \n```", "```\nhandle foo ()\n| MyEffect a b ->\n    ...\n\n// Conceptually the same as:\nhandle foo ()\n| MyEffect resume ->\n    a = resume.a\n    b = resume.b\n    resume = resume.continuation\n    ... \n```", "```\neffect Fork with\n    fork: Unit -> Bool\n\nfoo () : Unit can Fork =\n    message = \"branch\"\n\n    if fork () then\n        print \"${message} A\"\n        drop message\n    else\n        print \"${message} B\"\n\nhandle_fork (f: Unit -> a can Fork) : a =\n    handle f ()\n    | fork () ->\n        // Run `resume` twice, arbitrarily returning the second result\n        resume true\n        resume false\n\nhandle_fork foo \n```", "```\neffect Fork with\n    fork: Unit -> Bool\n\n    // The underscores here are because we're omitting the closure environment\n    // type as well as the actual function type - which is derived from fork's type.\n    // Although the environment type can be specified if desired, the function type of resume\n    // must be omitted because its return type will be the handler type, which is\n    // not known at this point.\n    fork.resume: FnMut _ _ \n```", "```\nfoo () : Unit can Fork =\n    message = \"branch\"\n\n    // Error: `fork` can be resumed multiple times, but `message` would\n    //         possibly be moved after the first call to `resume`.\n    if fork () then\n        print \"${message} A\"\n        // Note: `message` is moved here\n        drop message\n    else\n        print \"${message} B\" \n```", "```\neffect Foo with\n    foo: Unit -> Unit\n    foo.resume: FnOnce env _\n\n    // The above means:\n    // foo.resume: forall env. FnOnce env _ \n```", "```\neffect Foo env with\n    foo: Unit -> Unit\n    foo.resume: FnOnce env _ \n```", "```\nforced_example (x: &I32) =\n    foo ()\n    y = x\n    foo ()\n    print (x, y) \n```", "```\neffect FooCloneEnv with\n    foo: Unit -> Unit\n    foo.resume: FnOnce env _ given Clone env \n```", "```\ninner_fn () : Unit can FooCloneEnv =\n    // x may be cloned\n    x = 3\n    foo ()\n    print x\n\nouter_fn () : Unit can FooCloneEnv =\n    // vec may also be cloned\n    vec = Vec.of [1, 2, 3]\n    function2 ()\n    print vec \n```", "```\neffect Fork with\n    fork: Unit -> Bool\n\n    // Changed to Fn so that we can alias this twice below\n    fork.resume: Fn env _\n\nmultithread_fork (f: Unit -> a can Fork) : a =\n    handle f ()\n    | fork () ->\n        // Spawn two threads and wait for them both to complete\n        Thread.wait fn () ->\n            // Error: Expected argument of `Thread.spawn` to be `Send`\n            //        No impl found for `Send (Fn _ (Unit -> Bool))`\n            Thread.spawn (fn () -> resume true)\n            Thread.spawn (fn () -> resume false) \n```", "```\neffect Fork with\n    fork: Unit -> Bool\n    foo.resume: Fn env _ given Send &env\n\nmultithread_fork (f: Unit -> a can Fork) : a =\n    handle f ()\n    | fork () ->\n        Thread.wait fn () ->\n            Thread.spawn (fn () -> resume true)\n            Thread.spawn (fn () -> resume false) \n```", "```\nmap: Stream a -> FnMut a => b can e -> Unit can Emit b, e \n```", "```\ninner_fn () : Unit can FooCloneEnv =\n    // x may be cloned\n    x = 3\n    foo ()\n    print x\n\nouter_fn () : Unit can FooCloneEnv =\n    // vec may also be cloned\n    vec = Vec.of [1, 2, 3]\n    function2 ()\n    print vec \n```", "```\nmap: Stream a -> FnMut a => b can e -> Unit\n    given Clone e, Send e, Fn e.resume _\n    can Emit b, e \n```", "```\nasync  fn recursive()  {   recursive().await;   recursive().await;  } \n```", "```\nenum Recursive  {   First(Recursive),   Second(Recursive),  } \n```", "```\nuse  futures::future::{BoxFuture,  FutureExt};    fn recursive()  -> BoxFuture<'static,  ()>  {   async  move  {   recursive().await;   recursive().await;   }.boxed()  } \n```", "```\neffect Async with\n    await: Unit -> Unit\n\nrecursive () : Unit can Await =\n    // This doesn't quite match the semantics of the Rust example above,\n    // but lets us use a simpler definition for `await`\n    await ()\n    recursive ()\n    await ()\n    recursive ()\n\nhandle recursive ()\n| await f -> resume () \n```", "```\nrecursive () : Unit =\n    recursive ()\n    recursive () \n```", "```\nhandle recursive ()\n| await f ->\n    resume (f ())\n    print \"done\" \n```", "```\nrecursive k =\n    recursive fn () ->\n      recursive k\n      print \"done\"\n    print \"done\" \n```"]