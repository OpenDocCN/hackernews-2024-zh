["```\ntrait  Future  {  type Output;   fn poll(self: Pin<&mut  Self>,  cx: &mut  Context<'_>)  -> Poll<Self::Output>;   fn poll_cancel(self: Pin<&mut  Self>,  cx: &mut  Context<'_>)  -> Poll<()>  { // By default, futures do not have any async cancellation code Poll::Ready(()) } } \n```", "```\ndo  {  if  fallible_call()?  { println!(\"successful and true\") }  else  { panic!(\"successful but true\") } }  final  {  println!(\"exiting block\") } \n```", "```\nfoo.bar(); closure(&mut  foo)?; foo.unbar(); \n```", "```\nstruct Guard<'a>(&'a  mut  Foo);   impl  Drop  for  Guard<'_>  {  fn drop(&mut  self)  { self.0.unbar(); } }   let  mut  guard  =  Guard(&mut  foo); guard.0.bar(); closure(&mut  guard.0)?; drop(guard); \n```", "```\nfoo.bar(); do  {  closure(&mut  foo)?; }  final  {  foo.unbar(); } \n```", "```\nlet  mut  file  =  File::open(path)?; operate_on_file(&mut  file); drop(file); \n```", "```\n// Note that errors are ignored when closing a file descriptor. The // reason for this is that if an error occurs we don't actually know if // the file descriptor was closed or not, and if we retried (for // something like EINTR), we might close another valid file descriptor // opened after we closed ours. \n```", "```\nlet  mut  file  =  File::open(path)?; do  {  operate_on_file(&mut  file)?; }  final  {  if  let  Err(err)  =  file.close()  { info!(\"Error occurred closing file at {path}: {err}\"); } } \n```", "```\ndo  {  process_messages(&mut  socket).await?; }  final  {  socket.shutdown_graceful().await; } \n```", "```\ndo  {  read(&mut  file,  &mut  buffer)?; }  final  {  close(&mut  file)?; } \n```", "```\ngen  {  do  { for  elem  in  iter  { if  elem.has_foo()?  { yield  \"elem has foo\"; } } }  final  { yield  \"final yield\"; } } \n```", "```\npub  fn async  scope<'env,  F,  T>(f: F)  -> T where  F: for<'scope>  async  FnOnce(&'scope  Scope<'scope,  'env>)  -> T {  let  scope  =  ...; do  { f(&scope).await }  final  { scope.await_all_tasks().await; } } \n```"]