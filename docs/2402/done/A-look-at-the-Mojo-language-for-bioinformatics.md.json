["```\n$ curl https://get.modular.com | sh - && \\\nmodular auth [MY AUTHENTICATION CODE]\n[...]\nSorry, this system is not recognized. Please visit https://www.modular.com/mojo to learn about supported platforms. You can also build and run a Mojo container by following instructions at https://github.com/modularml/mojo\n```", "```\n@HWI-ST180_0186:3:1:1484:1936#GGCTAC/2\nGAGATCTCCAGCATCTGGGCGAGCGCGGCCTGACTGAACCCGCGTTCGCTCCGGAGTTGACGAAGGCGCCCTCAAACGTACGTTTTTGACACGTCGCGAG\n+\ndefegg___adefbdhfdadbeffffggfgggaeaf_cffga\\_a_babbZbbXdddT_\\c_cccca_TbBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n```", "```\nfn main() raises:\n    let vars = argv()\n    var parser = FastParser(vars[1], 64 * KB)\n\n    parser.parse_all()\n    print(parser.parsing_stats)\n\n    [some outcommented code...]\n```", "```\nfn parse_all(inout self) raises:\n    while True:\n        self.parse_chunk(self._current_chunk, start=0, end=self._chunk_last_index)\n        try:\n            self.fill_buffer()\n            self.check_EOF()\n        except:\n            break\n```", "```\n@always_inline\nfn parse_chunk(inout self, chunk: Tensor[DType.int8], start: Int, end: Int) raises:\n    let read: RecordCoord\n    var pos = 0\n    while True:\n        try:\n            read = self.parse_read(pos, chunk)\n            self.parsing_stats.tally(read)\n        except:\n            raise Error(\"failed read\")\n        if pos >= end - start:\n            break\n```", "```\n@always_inline\nfn parse_read(\n    self, inout pos: Int, chunk: Tensor[DType.int8]\n) raises -> RecordCoord:\n    let start = pos\n    let line1 = get_next_line_index(chunk, pos)\n    let line2 = get_next_line_index(chunk, line1 + 1)\n    let line3 = get_next_line_index(chunk, line2 + 1)\n    let line4 = get_next_line_index(chunk, line3 + 1)\n    pos = line4 + 1\n    return RecordCoord(start, line1, line2, line3, line4)\n```", "```\n@always_inline\nfn find_chr_next_occurance_simd[\n    T: DType\n](in_tensor: Tensor[T], chr: Int, start: Int = 0) -> Int:\n    \"\"\"\n    Function to find the next occurance of character using SIMD instruction.\n    The function assumes that the tensor is always in-bounds. any bound checks should be in the calling function.\n    \"\"\"\n    let len = in_tensor.num_elements() - start\n    let aligned = start + math.align_down(len, simd_width)\n\n    for s in range(start, aligned, simd_width):\n        let v = in_tensor.simd_load[simd_width](s)\n        let mask = v == chr\n        if mask.reduce_or():\n            return s + arg_true(mask)\n\n    for i in range(aligned, in_tensor.num_elements()):\n        if in_tensor[i] == chr:\n            return i\n\n    return -1\n```", "```\n$ ./fast_parser\nSegmentation fault (core dumped)\n```"]