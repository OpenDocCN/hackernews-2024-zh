- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-27 14:33:50'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024年05月27日 14:33:50
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: The Engineering behind Figma's Vector Networks
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Figma矢量网络背后的工程技术
- en: 来源：[https://alexharri.com/blog/vector-networks](https://alexharri.com/blog/vector-networks)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://alexharri.com/blog/vector-networks](https://alexharri.com/blog/vector-networks)
- en: <main class="css-fkkl8v">
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="css-fkkl8v">
- en: The Engineering behind Figma's Vector Networks
  id: totrans-split-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Figma矢量网络背后的工程技术
- en: November 24, 2019
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 2019年11月24日
- en: Adobe Illustrator introduced the pen tool back in [1987](https://www.youtube.com/watch?v=sT8Y7o-zsVw)
    as a tool for creating and modifying paths. Since then the pen tool has become
    incredibly widespread, so much so that is has become the de facto icon of the
    graphic design industry.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe Illustrator在[1987年](https://www.youtube.com/watch?v=sT8Y7o-zsVw)引入了画笔工具，作为创建和修改路径的工具。自那时以来，画笔工具已经广泛使用，以至于它已经成为图形设计行业的事实标志。
- en: The pen tool's functionality hasn't changed significantly in the 30 years since
    its introduction. Just click and drag to create smooth curves. Designers have
    learned to work with it, and around its idiosyncrasies.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自其引入以来，画笔工具的功能在过去30年里并没有发生显著变化。只需点击和拖动即可创建平滑曲线。设计师们已经学会了如何使用它，并且在它的特殊性周围进行了工作。
- en: The pen tool
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 画笔工具
- en: But Figma felt like they could improve some aspects of how the pen tool worked,
    so they had a go at redesigning it. Instead of it being used to work with traditional
    paths, they improved the pen tool by creating what they call Vector Networks.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Figma觉得他们可以改进一些关于画笔工具如何工作的方面，所以他们试图重新设计它。他们改进了画笔工具，不再仅仅用于处理传统路径，而是创建了他们称之为矢量网络的工具。
- en: In this post we will go through what Vector Networks are and what problems they
    try to solve. After we've defined what Vector Networks are, we will take a look
    at some of the engineering challenges you would face if you were to take a stab
    at implementing them.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将讨论什么是矢量网络以及它们试图解决的问题。在定义了矢量网络之后，我们将看看如果要实现它们，你可能面临的一些工程挑战。
- en: This post can be thought of as an introduction to a really interesting problem
    space, and as a resource for people interesting in making use of some aspects
    of Vector Networks for future applications. I hope it succeeds in providing value
    to both developers being introduced to new concepts and ideas, and to designers
    interesting in learning more about the tool they know and love.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章可以被看作是一个对非常有趣的问题空间的介绍，同时也是对那些有兴趣利用矢量网络部分功能进行未来应用的人的资源。我希望它能成功地为那些初次接触新概念和想法的开发者，以及希望更多了解他们熟悉和热爱工具的设计师提供价值。
- en: I will start off by laying out the core concepts behind the pen tool, and from
    there we will move onto Figma's Vector Networks.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先阐明画笔工具背后的核心概念，然后我们将转向Figma的矢量网络。
- en: Paths
  id: totrans-split-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径
- en: The pen tool is used to create and manipulate paths.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 画笔工具用于创建和操作路径。
- en: If you've every worked with graphics software like [Illustrator](https://www.adobe.com/products/illustrator.html)
    before, you've worked with paths. Paths are a series of lines and curves that
    may or may not form a loop.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前使用过像[Illustrator](https://www.adobe.com/products/illustrator.html)这样的图形软件，你就曾经使用过路径。路径是一系列可能形成或不形成循环的线条和曲线。
- en: Some paths
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一些路径
- en: The path to the left loops, while the path to the right doesn't. Both of these
    are valid paths.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的路径是一个环路，而右侧的路径不是。这两者都是有效的路径。
- en: The main characteristic of paths is that they form a single continuous unbroken
    chain. This means that each node can only be connected to one or two other nodes.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 路径的主要特征是它们形成一个单一连续的不间断链条。这意味着每个节点只能连接到一个或两个其他节点。
- en: Not valid paths
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的路径
- en: However, you could construct these shapes from multiple paths if you position
    them correctly together.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将它们正确地放置在一起，你可以用多条路径构建这些形状。
- en: Multiple paths are used to create more complex shapes
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多条路径创建更复杂的形状
- en: From a combination of paths, you can create any shape imaginable.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合多条路径，你可以创建任何想象得到的形状。
- en: This beer glass, for example, is just a combination of five different paths
    positioned and scaled a certain way.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个啤酒杯只是五条不同路径的组合，经过特定的位置和缩放。
- en: The building blocks of paths
  id: totrans-split-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径的基本组成部分
- en: A path is made up of two things, points and lines.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一条路径由两个东西组成，即点和线。
- en: Points and lines
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 点和线
- en: The points are known as **nodes** (or vertices) and the lines are called **edges**.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 点被称为**节点**（或顶点），而线被称为**边**。
- en: Together, they make a path
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它们一起形成一条路径
- en: Any path can be described as a list of nodes and edges.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 任何路径都可以被描述为一系列节点和边。
- en: This path can be described as the series of nodes `(0, 1, 2, 3, 4)`. It could
    also be thought of as the series of the edges that composed it. That list of edges
    would be `(0, 1)`, `(1, 2)`, `(2, 3)`, `(3, 4)`, `(4, 0)`.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这条路径可以描述为节点序列`(0, 1, 2, 3, 4)`。它也可以被看作是构成它的边的序列。边的列表将是`(0, 1)`，`(1, 2)`，`(2,
    3)`，`(3, 4)`，`(4, 0)`。
- en: 'You can think of this like the [dot to dot puzzles](https://www.google.com/search?q=dot+to+dot+for+kids&tbm=isch)
    that you used to do as a kid: Draw the edges of the path in the order that the
    points lay out.'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其视为小时候玩的[连线游戏](https://www.google.com/search?q=dot+to+dot+for+kids&tbm=isch)：按照点的顺序绘制路径的边缘。
- en: But instead of a kid drawing lines between numbered points on a paper, a cold
    calculating machine does it along the cartesian coordinate system.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是与孩童在纸上编号点之间画线不同，这是一台冷酷的计算机在笛卡尔坐标系上进行计算。
- en: Edges
  id: totrans-split-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边
- en: An edge is a connection between a pair of nodes. Visually, edges are a line
    from node `a` to node `b`.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 边是一对节点之间的连接。在视觉上，边是从节点`a`到节点`b`的一条线。
- en: But that line can be drawn in a lot of different ways. How do you describe those
    different types of lines?
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这条线可以用很多种不同的方式绘制。如何描述这些不同类型的线呢？
- en: Edges fall into two categories, straight and curvy.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 边可以分为两类，直线和曲线。
- en: Straight edges are as simple as they seem, just a line from `a` to `b`. But
    how are those curvy edges defined?
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 直边看起来很简单，只是从`a`到`b`的一条直线。但是曲边是如何定义的呢？
- en: Bezier curves
  id: totrans-split-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贝塞尔曲线
- en: Curvy edges are [bezier curves](https://en.wikipedia.org/wiki/B%C3%A9zier_curve).
    Bezier curves are a special type of curve defined by four points.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 曲边是[贝塞尔曲线](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)。贝塞尔曲线是由四个点定义的一种特殊类型的曲线。
- en: The positions of the two nodes in our edge make up the start and end points
    of the curve. Each of the two nodes has a *control point*.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们边的两个节点的位置构成了曲线的起点和终点。这两个节点各有一个*控制点*。
- en: In most applications, these control points are shown as *handles* that extend
    from their respective node. These handles are used to control the shape of the
    curve.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序中，这些控制点显示为从各自节点延伸出的*把手*。这些把手用于控制曲线的形状。
- en: Bezier curves can be chained to make more complex shapes that a single curve
    can't draw on its own. They can also be combined with straight lines to make some
    cool designs.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线可以链接在一起以创建单个曲线无法绘制的更复杂的形状。它们还可以与直线组合以创造一些酷炫的设计。
- en: But what exactly are the handles doing? How do the handles tell the computer
    to draw the curve like it does?
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些把手具体在做什么呢？它们如何告诉计算机绘制曲线的方式？
- en: Computers draw curves by splitting them into straight lines and drawing the
    individual lines.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通过将曲线分割成直线并绘制各个线段来绘制曲线。
- en: The more lines you split a curve into, the smoother the curve becomes.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您将曲线分割为更多线段，曲线将变得更加平滑。
- en: So to draw the curve we need to know how to get the different points that make
    up the curve. If we compute enough of them, we get a smooth curve.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要绘制曲线，我们需要知道如何获得组成曲线的不同点。如果我们计算足够多的点，我们就能得到一条平滑的曲线。
- en: Computing a point on a bezier curve
  id: totrans-split-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算贝塞尔曲线上的一个点
- en: Let's compute the point at 25% point of the curve. We can start by connecting
    the control points with a third blue line.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算曲线的25%点。我们可以通过连接控制点绘制第三条蓝线来开始。
- en: Then for each blue line, we draw a blue dot at the 25% point of the line.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对于每条蓝线，我们在该线的25%点处画一个蓝点。
- en: Next, draw two green lines between the three blue dots.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在三个蓝点之间绘制两条绿线。
- en: And we repeat the same step as we did with the blue dots. Draw green points
    at the 25% points of the green lines.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重复与蓝点相同的步骤。在绿线的25%点处画绿点。
- en: And then one more red line between the newly created green points.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再加一条红线连接新创建的绿点。
- en: Then we add a red point at the 25% point of the red line.
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在红线的25%点处添加一个红点。
- en: And just like that, we've computed the point at the 25% point of the curve.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们计算出了曲线25%点的位置。
- en: From now on we'll refer to points on curves through a `t` value, where `t` is
    a number from `0` to `1`. In the above example, the point would be at `t=0.25`
    (25%).
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将通过`t`值来引用曲线上的点，其中`t`是从`0`到`1`的数字。在上面的例子中，点将在`t=0.25`（25%）处。
- en: t=0.25, t=0.5 and t=0.75
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: t=0.25、t=0.5和t=0.75
- en: This way of computing the point at `t` is called [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)
    and can also be used to subdivide a bezier curve. Using the points we created
    along the way, we can also subdivide the bezier curve into two smaller bezier
    curves.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 计算参数`t`处的点的这种方式称为[De Casteljau算法](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)，也可以用于细分贝塞尔曲线。使用我们沿途创建的点，我们还可以将贝塞尔曲线分成两个较小的贝塞尔曲线。
- en: Bezier curves are pretty amazing things. Shaping the curve by adjusting the
    handles feels surprisingly natural, and chaining them together allows you to create
    detailed and complex shapes.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线是非常神奇的东西。通过调整手柄来塑造曲线感觉非常自然，将它们链接在一起可以创建详细和复杂的形状。
- en: And for computers, they're stable and inexpensive to compute. For this reason
    they're used for everything from [vector graphics](https://helpx.adobe.com/illustrator/using/drawing-pen-curvature-or-pencil.html#draw_curves_with_the_pen_tool)
    to [animation curves](https://www.austinsaylor.com/blog/2015/3/20/4-after-effects-graph-editor-basics-you-need-to-know)
    and [automobile bodies](https://en.wikipedia.org/wiki/Pierre_B%C3%A9zier#B%C3%A9zier_curve).
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算机而言，它们稳定且计算成本低廉。因此，它们被用于从[矢量图形](https://helpx.adobe.com/illustrator/using/drawing-pen-curvature-or-pencil.html#draw_curves_with_the_pen_tool)到[动画曲线](https://www.austinsaylor.com/blog/2015/3/20/4-after-effects-graph-editor-basics-you-need-to-know)和[汽车车身](https://en.wikipedia.org/wiki/Pierre_B%C3%A9zier#B%C3%A9zier_curve)的各种用途。
- en: You can see an interactive demo of bezier curves at [Jason Davies' site](https://www.jasondavies.com/animated-bezier/).
    It's fascinating to watch a series of straight lines trace out a smooth curve.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[Jason Davies的网站](https://www.jasondavies.com/animated-bezier/)看到贝塞尔曲线的交互演示。看着一系列直线追踪出平滑的曲线是非常迷人的。
- en: From [https://jasondavies.com/animated-bezier](https://jasondavies.com/animated-bezier)
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[https://jasondavies.com/animated-bezier](https://jasondavies.com/animated-bezier)
- en: The creative constraints of paths
  id: totrans-split-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径的创造性限制
- en: Earlier in this post, paths were defined as a continuous series of lines and
    curves that may or may not form a loop.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文的早些时候，路径被定义为一系列可能形成环路的直线和曲线。
- en: The fact that paths are a single continuous chain is a pretty big limitation.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是单一连续链的事实是一个相当大的限制。
- en: It means three way intersections are not possible using a single path. To create
    a three way intersection, two or more paths will have to be used. This means dealing
    with positioning and grouping different paths together. It also means that changes
    to a single path can lead to changes to multiple other paths.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着使用单一路径无法实现三路交叉。要创建三路交叉，必须使用两个或更多路径。这意味着处理不同路径的定位和分组。这也意味着对单一路径的更改可能会导致多个其他路径的更改。
- en: But that's simply the routine. Seasoned designers know how paths behave, they
    can plan around it without really thinking about it. For a static design it doesn't
    really matter how many paths and layers you have to create if the piece is planned
    properly upfront.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但那只是例行公事。经验丰富的设计师知道路径的行为，他们可以事先进行合理规划，而不必真正考虑它。对于静态设计，如果设计得当，创建多少路径和图层并不重要。
- en: But for some situations the constraints that paths impose cause a lot of friction.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于某些情况，路径所施加的约束会导致很多摩擦。
- en: Vector Networks
  id: totrans-split-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矢量网络
- en: In 2016, Figma [introduced Vector Networks](https://www.figma.com/blog/introducing-vector-networks/).
    They lift the “single continuous” limitation by allowing any two nodes to be joined
    together without restrictions.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年，Figma [推出了矢量网络](https://www.figma.com/blog/introducing-vector-networks/)。他们通过允许任意两个节点无限制地连接来解除了“单一连续”的限制。
- en: “A vector network improves on the path model by allowing lines and curves between
    any two points instead of requiring that they all join up to form a single chain.”
  id: totrans-split-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “矢量网络通过允许任意两点之间的线条和曲线，改进了路径模型，而不要求它们全部连接成单一链。”
- en: 'Source: [https://www.figma.com/blog/introducing-vector-networks/](https://www.figma.com/blog/introducing-vector-networks/)'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://www.figma.com/blog/introducing-vector-networks/](https://www.figma.com/blog/introducing-vector-networks/)
- en: The cube is the quintessential example for demonstrating Vector Networks.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体是展示矢量网络的典型例子。
- en: Via traditional paths, you would have to create at minimum 3 different paths
    to describe this shape.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传统路径，您至少需要创建3条不同的路径来描述此形状。
- en: This creates a lot of friction for a seemingly simple and common shape. To modify
    the cube, you would have to modify two or three different paths. But with Vector
    Networks you can simply grab an edge and move it around, and the shape behaves
    like you would expect.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个看似简单且常见的形状来说，这创造了很多摩擦。要修改立方体，您必须修改两个或三个不同的路径。但是使用矢量网络，您只需抓住一条边并移动它，形状就会表现得如您所期望的那样。
- en: So if you would want to increase the extrusion of the cube, you could just grab
    the two appropriate edges and move them together.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您想要增加立方体的挤压，您只需抓住两条适当的边并将它们移动在一起。
- en: This is the big selling point for Figma's Vector Networks. Ease of use.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Figma矢量网络的主要卖点。易于使用。
- en: Vector Networks don't enable you to create something that you couldn't create
    with other tools, but it does remove a lot of the friction in the process of creating
    things.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量网络不会让你创造以前不能用其他工具创造的东西，但它确实消除了在创建过程中的许多阻力。
- en: And you can take this even further. Say you want to add a hole to the side of
    the cube.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你可以更进一步。比如说你想在立方体的侧面添加一个孔。
- en: Just start off by selecting and copying the sides of the cube. You can then
    duplicate those edges and scale them to the size you want them to be.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 只需从选择和复制立方体的边开始。然后您可以复制这些边并将它们缩放到所需的大小。
- en: And just like that, you have a cube with a hole.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样，您就有了一个带孔的立方体。
- en: And to make this hole believable, you just need the inner edge.
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个洞看起来可信，你只需内部边缘。
- en: Again, Vector Networks may not allow you to create something you couldn't otherwise.
    Instead, they enable workflows that weren't previously possible.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，矢量网络可能不允许您创建以前无法创建的东西。相反，它们使以前不可能的工作流变得可能。
- en: Creating Vector Networks
  id: totrans-split-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建矢量网络
- en: With an understanding of what Vector Networks are, we can now take a look at
    how we would go about implementing them.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了什么是矢量网络后，我们现在可以看看如何实施它们。
- en: Graph
  id: totrans-split-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图
- en: The main data structure behind Vector Networks is a graph. A graph can be thought
    of as a collection of nodes and edges.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量网络背后的主要数据结构是图。图可以被看作是节点和边的集合。
- en: A graph
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图
- en: Nodes
  id: totrans-split-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点
- en: A graph may have any number of nodes. For our purposes nodes have two properties,
    a unique `id` and a `position`.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图可以有任意数量的节点。在我们的目的中，节点有两个属性，一个唯一的`id`和一个`position`。
- en: Edges
  id: totrans-split-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边
- en: Edges are the connection between two nodes. Each edge is a composed of two *edge
    parts*. An edge part contains a node's id and an optional control point.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 边是两个节点之间的连接。每条边由两个*边部分*组成。边部分包含一个节点的id和一个可选的控制点。
- en: The labels `n0` and `n1` will be used to refer to the nodes at the start and
    end of an edge, respectively. The control points will be labeled `cp0` and `cp1`.
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 标签`n0`和`n1`将用于分别引用边的起始和结束节点。控制点将被标记为`cp0`和`cp1`。
- en: If the control points of the edge are omitted, the edge becomes a straight line.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了边的控制点，该边就变成了一条直线。
- en: Filling the holes
  id: totrans-split-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填补孔洞
- en: 'Source: [https://www.figma.com/blog/introducing-vector-networks/](https://www.figma.com/blog/introducing-vector-networks/)'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://www.figma.com/blog/introducing-vector-networks/](https://www.figma.com/blog/introducing-vector-networks/)
- en: When working with vector networks, the Fill tool allows you to “toggle” the
    fill of different “areas” of the graph.
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用矢量网络时，填充工具允许您“切换”图的不同“区域”的填充。
- en: These areas can be defined as a sequence of node `id`s that go in a circle,
    a loop, if you will.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些区域可以被定义为一个环形的节点`id`序列，一个循环，如果你愿意的话。
- en: This loopy sequence is referred to as a *cycle*. In the above example, the cycle
    would consist of the nodes `n0`, `n1`, `n3`, `n4`, `n5`, `n6` and `n7`. These
    cycles will be written like `(0, 1, 3, 4, 5, 6, 7)`.
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环序列被称为*循环*。在上面的例子中，循环由节点`n0`、`n1`、`n3`、`n4`、`n5`、`n6`和`n7`组成。这些循环将被写成`(0,
    1, 3, 4, 5, 6, 7)`。
- en: If you were to count the different visually distinct “areas” of the cycle your
    answer would probably be three, but you could easily find more than three cycles.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要计算循环中不同的视觉上可区分的“区域”的数量，您的答案可能是三个，但您可能会轻松找到超过三个循环。
- en: What makes this correct or incorrect?
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么使得这个正确或者不正确？
- en: The sequence `(0, 1, 2, 3, 4, 5, 6, 7)` is a cycle and it loops, but it is not
    what we're looking for. The problem can be illustrated with the “how many triangles”
    puzzle you might have seen on Facebook.
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 序列`(0, 1, 2, 3, 4, 5, 6, 7)`是一个循环，并且循环，但这并不是我们寻找的。这个问题可以通过你可能在Facebook上看到的“多少个三角形”谜题来说明。
- en: How many triangles are in this image?
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图像中有多少个三角形？
- en: You should be able to count 24 different triangles depending on which areas
    you choose to include.
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够计算出 24 个不同的三角形，具体取决于您选择包括哪些区域。
- en: But that's not what we want. What we need to find are the 16 small areas.
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是我们想要的。我们需要找到的是 16 个小区域。
- en: We need a way to find the *“small cycles”* in the graph.
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来找到图中的*“小循环”*。
- en: Minimal cycle basis
  id: totrans-split-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小循环基础
- en: 'This [paper on Minimal Cycle Basis](https://www.geometrictools.com/Documentation/MinimalCycleBasis.pdf)
    is a bit less dense than most others academic papers (and it has pictures!). Its
    goal is:'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇关于[最小循环基础](https://www.geometrictools.com/Documentation/MinimalCycleBasis.pdf)的论文比大多数其他学术论文少了一些内容（而且还有图片！）。其目标是：
- en: …to compute a minimal number of cycles that form a cycle basis for the graph.
  id: totrans-split-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …来计算形成图形循环基础的最小循环数。
- en: What does “Minimal Cycle Basis” mean?
  id: totrans-split-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “最小循环基础”是什么意思？
- en: It's just a fancy way to refer to all of the “small areas” of a graph. You can
    think of these as the “visually distinct” areas of a graph. Enclosed areas.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一种指代图形的“小区域”的花哨方式。您可以把它们想象成图形的“视觉上不同”的区域。封闭区域。
- en: Left or right?
  id: totrans-split-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 左边还是右边？
- en: The main tool for finding the “minimal cycle basis” will be determining which
    edge to choose based on left- or rightness.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 找到“最小循环基础”的主要工具将确定基于左或右选择哪条边。
- en: Should we go to `a` or `b`?
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该去 `a` 还是 `b`？
- en: We'll think of this in terms of clockwise and counter clockwise.
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照顺时针和逆时针来思考。
- en: '`curr` for current, `prev` for previous'
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`curr` 表示当前，`prev` 表示前一个'
- en: When traveling left, we choose the counter clockwise most edge (CCW) relative
    to the previous one.
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当向左行进时，我们选择相对于前一个边最逆时针的边（CCW）。
- en: CCW
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 逆时针
- en: When traveling right, we choose the clockwise most edge (CW) relative to the
    previous one.
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在向右行进时，我们选择相对于前一个边最顺时针的边（CW）。
- en: CW
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 顺时针
- en: The algorithm
  id: totrans-split-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法
- en: We will be finding the minimal cycle basis for the graph we saw earlier.
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将找到之前看到的图的最小循环基础。
- en: The first step is choosing the leftmost node in the graph.
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是选择图中最左边的节点。
- en: When traveling from the first node, we want to go clockwise (CW). But relative
    to which edge?
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当从第一个节点出发时，我们希望顺时针走（CW）。但是相对于哪条边呢？
- en: For the first node, we imagine that the previous edge is “below” the current
    one. We then pick the CW edge relative to that.
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个节点，我们想象前一个边“在”当前边的下方。然后我们选择相对于那个边的顺时针边。
- en: In this case `a` is more CW relative to `prev` than `b`, so we'll walk to `a`.
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，相对于 `prev`，`a` 更顺时针，所以我们将走向 `a`。
- en: After the first walk, we start picking the CCW edge.
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次行走后，我们开始选择逆时针边。
- en: In this case, that's `b`. We repeat the previous step and keep selecting the
    CCW edge until we reach the original node.
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，那是 `b`。我们重复之前的步骤，并继续选择逆时针边，直到我们达到原始节点。
- en: When we reach the original node again, a cycle is found.
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次到达原始节点时，就找到了一个循环。
- en: We now have the first small cycle in the graph.
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在图中有了第一个小循环。
- en: When a cycle has been found, the first edge of the cycle is then removed from
    the graph.
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: 找到循环后，从图中移除循环的第一条边。
- en: The first edge, `(n0 n1)`, is removed
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条边 `(n0 n1)` 被移除了
- en: Then, the *filaments* of the first two nodes in the cycle are removed.
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，去除循环中前两个节点的*纤维*。
- en: In this case, we only have a single filament
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只有一个单一的纤维
- en: Filaments are nodes that only have one adjacent edge. Think of these as dead
    ends. When a filament is found, we also check whether or not the single adjacent
    node is a filament. This ensures that the first node of the next cycle has two
    adjacent nodes. We'll see an example of this later.
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 纤维是只有一个相邻边的节点。把它们想象成是死胡同。找到一个纤维时，我们还会检查单个相邻节点是否也是纤维。这确保了下一个循环的第一个节点有两个相邻节点。稍后我们会看到一个例子。
- en: Now we pick the first node in the next cycle. In our graph, there are two equally
    left most nodes.
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们选择下一个循环中的第一个节点。在我们的图中，有两个同样左边的节点。
- en: When this happens, we pick the bottom node, `n1` in this case.
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，我们选择底部节点，这里是 `n1`。
- en: We then repeat the process from before. CW from the bottom for the first node,
    then CCW from the previous node until we find the first node.
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从之前的过程中重复。从底部的第一个节点顺时针，然后从前一个节点逆时针，直到找到第一个节点。
- en: We find the cycle `(1, 2, 3)`.
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了循环 `(1, 2, 3)`。
- en: Now we have the cycles `(0, 1, 3, 4, 5, 6, 7)` and `(1, 2, 3)`.
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有循环 `(0, 1, 3, 4, 5, 6, 7)` 和 `(1, 2, 3)`。
- en: Then we remove the first edge of the cycle and filaments like before. We start
    by removing the filaments connected to the first two nodes of the cycle.
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们去除循环的第一条边和之前的纤维。我们从去除与循环的前两个节点相连的纤维开始。
- en: We keep going until there aren't any filaments left.
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续直到没有任何纤维剩余。
- en: Finding the next cycle is pretty obvious.
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: 找到下一个循环是显而易见的。
- en: CW then CCW
  id: totrans-split-146
  prefs: []
  type: TYPE_NORMAL
  zh: 顺时针然后逆时针
- en: We now have all the cycles of the graph.
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了图的所有循环。
- en: This is the minimal cycle basis of our graph! Now we can toggle the fills of
    these cycles as we please.
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们图形的最小循环基础！现在我们可以随意切换这些周期的填充。
- en: The math
  id: totrans-split-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学计算
- en: I want to dig into how the clockwise-ness of an edge relative to another edge
    is determined.
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我想深入探讨相对于另一条边缘的顺时针性如何确定。
- en: The only prerequisite for understanding this section are [vectors](https://www.mathsisfun.com/algebra/vectors.html);
    arrows pointing from one point of a 2D coordinate system to another.
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: 理解本节的唯一先决条件是[vectors](https://www.mathsisfun.com/algebra/vectors.html)；从二维坐标系的一个点指向另一个点的箭头。
- en: i = (1, 0), j = (0, 1)
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: i = (1, 0)，j = (0, 1)
- en: With two vectors sitting at the origin, `i` and `j`, we can create a square
    like so.
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个向量位于原点，`i`和`j`，我们可以这样创建一个正方形。
- en: For the unit vectors `(1, 0)` and `(0, 1)` the square has an area of 1.
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单位向量`(1, 0)`和`(0, 1)`，正方形的面积为1。
- en: We can do this with any two vectors.
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用任意两个向量做同样的事情。
- en: This shape is called a *parallelogram*. Parallelograms have one property that
    we care about, which is that their area is equal to the absolute value of their
    determinant.
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个形状被称为*平行四边形*。平行四边形有一个我们关心的特性，即它们的面积等于其行列式的绝对值。
- en: That may sound like jargon, but the determinant happens to be really useful
    for us. Take a look at what happens when we move the vectors of the one-by-one
    square closer together.
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能像行话，但对我们来说行列式确实非常有用。看看当我们逐个将一对一正方形的向量移动在一起时会发生什么。
- en: When the vectors get closer, their area gets smaller. And when the vectors are
    parallel, the determinant and area become 0.
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当向量靠近时，它们的面积变小。当向量平行时，行列式和面积变为0。
- en: At this point the natural question to ask is what happens when we keep going
    and the blue arrow is to the right of the green arrow?
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此时要问的自然问题是，当我们继续前进时，蓝箭头是否在绿箭头的右侧？
- en: The determinant becomes negative!
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
  zh: 行列式变为负数！
- en: When the blue vector `j` is to the left of the green vector `i` the determinant
    of the parallelogram becomes negative. When the opposite is true it becomes positive.
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当蓝色向量`j`在绿色向量`i`的左侧时，平行四边形的行列式变为负值。反之则为正。
- en: The implication for our use case is that we can check whether the determinant
    of two vectors is positive or negative to determine whether or not a vector is
    to the left or right of another vector.
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的使用情况的含义是，我们可以检查两个向量的行列式是正还是负，以确定一个向量是在另一个向量的左侧还是右侧。
- en: And we can do this no matter the direction because the area of a parallelogram
    does not change depending on the orientation of the vectors that create it.
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
  zh: 无论方向如何，因为平行四边形的面积不取决于创建它的向量的方向。
- en: The determinant changes when the orientation of the vectors change **relative
    to each other**.
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当向量的方向相对于彼此改变时，行列式会改变。
- en: With this knowledge as our weapon, we can create a function, `det(i, j)`, that
    takes in two vectors and returns the determinant.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个知识作为我们的武器，我们可以创建一个函数，`det(i, j)`，它接受两个向量并返回行列式。
- en: The function will return a positive value when `j` is to the left (CCW) of `i`.
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当`j`在`i`的左侧（逆时针）时，函数将返回一个正值。
- en: Applying the math
  id: totrans-split-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用数学
- en: Say we're in the middle of the finding a cycle and we're deciding whether or
    not to move to `n0` or `n1`.
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在查找循环的中间，并且我们正在决定是移动到`n0`还是`n1`。
- en: Let's move this into the coordinate system.
  id: totrans-split-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其移入坐标系统。
- en: We'll start off with `a`.
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`a`开始。
- en: We want to get the vector from `curr` to `a`, which we do by subtracting `curr`
    from `a`. We'll call this new vector `da`.
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要得到从`curr`到`a`的向量，我们通过从`curr`减去`a`来做到这一点。我们将这个新向量称为`da`。
- en: We can do the same for `curr` using `prev`.
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`prev`对`curr`做同样的事情。
- en: Now we can determine whether `a` is left of `curr` by computing the determinant
    of the parallelogram that `da` and `dcurr` form.
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过计算`da`和`dcurr`形成的平行四边形的行列式来确定`a`是否在`curr`的左侧。
- en: Note that the order is important. If we use `da` as `i` the area is negative.
    If we use it as `j` it becomes positive.
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意顺序很重要。如果我们使用`da`作为`i`，那么面积是负的。如果我们将其用作`j`，它变为正数。
- en: We can do the same with `b`.
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`b`做同样的事情。
- en: With this information as our weapon, we know whether or not `a`, `b` and `curr`
    are left or right of each other.
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息作为我们的武器，我们知道`a`、`b`和`curr`是左还是右。
- en: What do we do with this information?
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理这些信息？
- en: The green zone
  id: totrans-split-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绿色区域
- en: We will be focusing on determining whether `da` is more CCW than `db` relative
    to `curr`. Simply put, is `da` left of `db`?
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将集中在确定`da`相对于`curr`是否比`db`更逆时针方向。简单来说，`da`是否在`db`的左边？
- en: If `da` is more CCW than `db` relative to `dcurr`, `da` can be said to be *better*
    than `db`.
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`da`相对于`dcurr`更逆时针，可以说`da`比`db`*更好*。
- en: The first step is to determine whether the angle between `dcurr` and `db` is
    convex.
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确定`dcurr`和`db`之间的角度是否凸。
- en: 'This “convexity” can more easily visualized by shifting `dcurr` back and imagining
    an arc like so:'
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“凸性”可以更容易地通过将`dcurr`向后移动并想象一个弧来可视化，如下所示：
- en: The angle is convex
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: 角度是凸的
- en: If the angle is convex, we we use the following expression to check whether
    `da` is better than `db`.
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果角度是凸的，我们将使用以下表达式来检查`da`是否比`db`更好。
- en: The ∨ symbol represents the logical OR operator in math.
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
  zh: ∨ 符号代表数学中的逻辑或运算符。
- en: Let's take a look at the individual parts of this expression.
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个表达式的各个部分。
- en: Is `da` CCW of `dcurr`?
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`da`是否相对于`dcurr`是逆时针的？'
- en: Is `da` CCW of `db`?
  id: totrans-split-188
  prefs: []
  type: TYPE_NORMAL
  zh: 是否`da`相对于`db`是逆时针方向的？
- en: I find that it's pretty hard to visualize this mentally, so I think of the two
    different expressions creating a “green zone” where `da` is better than `db`.
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现在脑海中很难将这个形象化，所以我认为两个不同的表达式创建了一个“绿色区域”，在这个区域中`da`比`db`更好。
- en: For the first part of the expression (is `da` left of `dcurr`), the green area
    looks like so.
  id: totrans-split-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表达式的第一部分（`da`是否在`dcurr`的左边），绿色区域看起来是这样的。
- en: The second part of the expression asks if `da` is left of `db`. The green area
    look looks like so.
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的第二部分询问`da`是否在`db`的左边。绿色区域看起来是这样的。
- en: 'And since it''s an OR expression, either of these sub-expressions being true
    would result in `a` being better than `b`. Thus, the green area looks like this:'
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
  zh: 而且由于这是一个或表达式，这些子表达式中的任何一个为真都将导致`a`比`b`更好。因此，绿色区域看起来是这样的：
- en: Is `a` better than `b`?
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`是否比`b`更好？'
- en: We use this to determine the better-ness of `a` when the angle is convex.
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用这个来确定角度凸度时`a`的优势。
- en: But what if the angle from `dcurr` to `db` is concave?
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果从`dcurr`到`db`的角度是凹的呢？
- en: 'Then the expression looks like so:'
  id: totrans-split-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后表达式看起来是这样的：
- en: The only thing that changed here is that the logical OR operator (∨) changed
    to the logical AND operator (∧).
  id: totrans-split-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一改变的是逻辑或运算符（∨）变成了逻辑与运算符（∧）。
- en: Let's take a look at what happens with the green zones using this expression.
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用这个表达式时绿色区域会发生什么变化。
- en: Is `da` left of `dcurr`?
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`da`是否在`dcurr`的左边？'
- en: Is `da` left of `db`?
  id: totrans-split-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`da`是否在`db`的左边？'
- en: 'And since these sub-expressions are joined by logical AND, the green zone looks
    like so:'
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: 而且因为这些子表达式由逻辑与连接，绿色区域看起来是这样的：
- en: Using this method, we can always get the CCW or CW most node. And the great
    thing is that this method is independent of rotation and really cheap to compute.
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以始终得到最逆时针或最顺时针的节点。而且最棒的是，这种方法不受旋转影响，计算成本很低。
- en: Computing the determinant
  id: totrans-split-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算行列式
- en: 'Given two vectors, the [determinant](https://en.wikipedia.org/wiki/Determinant)
    can be computed with this formula:'
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个向量，可以用这个公式计算[determinant](https://en.wikipedia.org/wiki/Determinant)：
- en: Intersections in the graph
  id: totrans-split-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图中的交集
- en: Let's go back to our graph for a bit.
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微回到我们的图上。
- en: This graph is the simplest, most optimistic case. This graph only has straight
    lines, and no two lines cross each other.
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图是最简单、最乐观的情况。这个图只有直线，并且没有两条线相交。
- en: This box shape has an intersection. The edge `(0, 2)` crosses the edge `(1,
    3)`.
  id: totrans-split-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个盒状区域有一个交集。边缘`(0, 2)`穿过边缘`(1, 3)`。
- en: With the intersection, the above area looks fillable. But defining the “filled
    area” is pretty difficult.
  id: totrans-split-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有了交集，上面的区域看起来是可以填充的。但定义“填充区域”却相当困难。
- en: What makes defining this area so difficult? Consider this rectangle and line.
  id: totrans-split-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么定义这个区域如此困难？考虑这个矩形和线。
- en: There are two intersections with the edge `(4, 5)` intersecting `(0, 1)` and
    `(2, 3)`.
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘`(4, 5)`与`(0, 1)`和`(2, 3)`有两个交集。
- en: Say the area left of the line is filled. What happens if we move the line left?
  id: totrans-split-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设线左侧的区域被填充。如果我们将线移到左边会发生什么？
- en: Obviously the area shrinks, but what if we keep going and move the line outside
    of the rectangle? Which of these outcomes below should be the result, and why?
  id: totrans-split-213
  prefs: []
  type: TYPE_NORMAL
  zh: 显然区域会缩小，但如果我们继续并将线移到矩形外部会怎样？下面哪种结果应该是正确的，为什么？
- en: In this case kinda feels like the rectangle should be empty. But what if we
    move the line right?
  id: totrans-split-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，感觉矩形应该是空的。但如果我们把线移到右边呢？
- en: Should it then be filled? Sure, but what if we move the line up or down instead?
    Should the rectangle fill or empty when the line is no longer separating the two
    sections?
  id: totrans-split-215
  prefs: []
  type: TYPE_NORMAL
  zh: 应该填充吗？当然，但如果我们移动线条，而不是上下移动，那么当线条不再分隔两个部分时，矩形应该填充还是清空？
- en: Expanding the graph
  id: totrans-split-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展图形
- en: This is how I believe Figma solves this problem. I call it “expanding the graph”,
    but the engineers at Figma probably use a different vocabulary to describe it.
  id: totrans-split-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我认为 Figma 解决这个问题的方式。我称之为“扩展图形”，但 Figma 的工程师可能使用不同的术语来描述它。
- en: Expanding the graph means taking each intersection, creating a node at the point
    of the intersections, and then splitting the edges that intersected each other
    at that point.
  id: totrans-split-218
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展图形意味着获取每个交点，创建一个节点在交点处，然后拆分在该点相交的边。
- en: 'This is the original graph:'
  id: totrans-split-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始图形：
- en: 'The edge `(0, 2)` intersects the edge `(1, 3)`. When expanded, the graph would
    look like so:'
  id: totrans-split-220
  prefs: []
  type: TYPE_NORMAL
  zh: 边`(0, 2)`与边`(1, 3)`相交。在扩展后，图形将如下所示：
- en: A new node, `5` would be added at the point of the intersection.
  id: totrans-split-221
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点`5`将被添加到交点处。
- en: The edges `(0, 2)` and `(1, 3)` have been removed and replaced by the edges
    `(0, 5)`, `(5, 2)`, `(1, 5)`, and `(5, 3)`.
  id: totrans-split-222
  prefs: []
  type: TYPE_NORMAL
  zh: 边`(0, 2)`和`(1, 3)`已被移除，并被边`(0, 5)`、`(5, 2)`、`(1, 5)`和`(5, 3)`替换。
- en: The structure of the graph has been changed
  id: totrans-split-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图的结构已经改变了
- en: Here's a graphic that should illustrate this a bit more clearly.
  id: totrans-split-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示意图，应该更清晰地说明问题。
- en: Expanding an intersection
  id: totrans-split-225
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展交点
- en: Multiple intersections
  id: totrans-split-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个交点
- en: These steps are pretty simple for line edges with a single intersections. But
    each edge can have multiple other edges intersecting it, and two cubic bezier
    curves can create 9 intersections.
  id: totrans-split-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有单个交点的线边来说，这些步骤相当简单。但是每条边都可以有多个其他边与其相交，两条三次贝塞尔曲线可以创建9个交点。
- en: This complicates things a bit. Let's take a look at a bezier-line intersection.
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这使事情变得有些复杂。让我们看看贝塞尔线交点的情况。
- en: The best way to go about this is to treat the intersections for an edge as separate
    from the edge that intersected it.
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的最佳方法是将边的交点视为与其相交的边的独立部分。
- en: The `t` values go from 0 at the start of the curve to 1 at the end of it
  id: totrans-split-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`t`值从曲线的起点0到终点1'
- en: The line has two intersections at `t = 0.3` and `t = 0.7`. The bezier has two
    intersections, but at `t = 0.25` and `t = 0.75`.
  id: totrans-split-231
  prefs: []
  type: TYPE_NORMAL
  zh: 线条在`t = 0.3`和`t = 0.7`处有两个交点。贝塞尔曲线有两个交点，但在`t = 0.25`和`t = 0.75`处。
- en: Before we move on with this example, I want to introduce a different way of
    thinking about edges since I believe it will help with the overall understanding
    of the problem.
  id: totrans-split-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续这个示例之前，我想引入另一种边的思考方式，因为我相信这将有助于更好地理解问题。
- en: Duplicate edges
  id: totrans-split-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复边
- en: Two nodes may be connected multiple times by different edges.
  id: totrans-split-234
  prefs: []
  type: TYPE_NORMAL
  zh: 两个节点可以通过不同的边连接多次。
- en: In this graph, an edge represented by the node pair `(2, 3)` could represent
    either of the two edges that connect `n2` and `n3`.
  id: totrans-split-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，由节点对`(2, 3)`表示的边可以表示连接`n2`和`n3`的两条边中的任意一条。
- en: To get around this problem, we will give each edge a unique `id`.
  id: totrans-split-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将为每条边分配一个唯一的`id`。
- en: For most future examples, I will still refer to edges by the nodes they connect
    since I feel it's easier to think about. But for the next example it's better
    to separate nodes and edges.
  id: totrans-split-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数未来的示例，我仍然会根据它们连接的节点来引用边，因为我觉得这样更容易理解。但对于下一个示例，最好分开节点和边。
- en: Intersection map
  id: totrans-split-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交点映射
- en: 'We can structure the data for the intersections of the edges like so:'
  id: totrans-split-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式组织边的交点数据：
- en: Creating nodes at the intersection points of edges
  id: totrans-split-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在边的交点处创建节点
- en: When we encounter an intersection, we create a node whose position is at the
    intersection. We then add intersections to an *intersection map* that will contain
    the intersections for each edge with a corresponding `t` value and a `nodeId`.
    These intersections are sorted by the `t` value.
  id: totrans-split-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到交点时，我们创建一个节点，其位置位于交点处。然后我们将交点添加到一个*交点映射*中，该映射将包含每条边的交点，对应一个`t`值和一个`nodeId`。这些交点按`t`值排序。
- en: For the intersection with the lowest `t` value, we create an edge with the first
    *edge part* having the `nodeId` of the first edge part of the original edge. The
    second edge part should contain the `nodeId` of the intersection. This creates
    the edge `(2, 4)`.
  id: totrans-split-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有最低`t`值的交点，我们创建一个边，第一个*边部分*具有原始边的第一个边部分的`nodeId`。第二个边部分应包含交点的`nodeId`。这样创建了边`(2,
    4)`。
- en: Subsequent edges will have the first edge part's `nodeId` be the `nodeId` of
    the previous intersection and the second `nodeId` be the `nodeId` of the current
    intersection. In this example, that edge is `(4, 5)`.
  id: totrans-split-243
  prefs: []
  type: TYPE_NORMAL
  zh: 后续边将使第一个边部分的`nodeId`成为前一个交点的`nodeId`，第二个`nodeId`成为当前交点的`nodeId`。在此示例中，该边是`(4,
    5)`。
- en: One additional edge will be created for each edge with any intersections.
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条具有任何交点的边，将创建一个额外的边。
- en: The first edge part's `nodeId` will be the `nodeId` of the last intersection
    and the second edge part's `nodeId` will be the `nodeId` of the second edge part
    of the original edge.
  id: totrans-split-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个边部分的`nodeId`将是最后一个交点的`nodeId`，第二个边部分的`nodeId`将是原始边的第二个边部分的`nodeId`。
- en: This was a bit of a mouthful, so hopefully this graphic helps a bit with understanding
    that alphabet soup.
  id: totrans-split-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点啰嗦，希望这张图有助于更好地理解那些字母串。
- en: Separating the intersections of an edge from the edges that created those intersections
    makes it easier to think about. It alleviates some of the complexity that might
    arise from multiple edges intersecting with each other.
  id: totrans-split-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将边的交点与创建这些交点的边分开，使得思考变得更容易。这减轻了多个边相互交叉可能引起的复杂性。
- en: Self-intersection
  id: totrans-split-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自相交。
- en: Cubic beziers can self-intersect.
  id: totrans-split-249
  prefs: []
  type: TYPE_NORMAL
  zh: 三次贝塞尔曲线可以自相交。
- en: This, unfortunately, means that every single cubic bezier edge has to be checked
    for self-intersection. It's an interesting problem that involves finding the two
    different `t` values that the bezier intersects itself at, but I won't be covering
    how to find those values here.
  id: totrans-split-250
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这意味着必须检查每一条三次贝塞尔边是否自相交。这是一个涉及查找贝塞尔曲线在哪两个不同的`t`值处相交的有趣问题，但我不会在这里详细介绍如何找到这些值。
- en: 'Once you have the `t` values, a self-intersecting bezier can be expanded like
    so:'
  id: totrans-split-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了`t`值，自相交贝塞尔曲线可以扩展如下：
- en: The blue node should be invisible to the user
  id: totrans-split-252
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色节点应对用户不可见。
- en: We insert `n3` since having a node with an edge that has itself on both ends
    of the edge is problematic, but it should be hidden from the user.
  id: totrans-split-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插入`n3`，因为具有边界的节点，在边界的两端都有自身的边界是有问题的，但应该对用户隐藏。
- en: Intersecting the loop of a self-intersecting bezier
  id: totrans-split-254
  prefs: []
  type: TYPE_NORMAL
  zh: 交错自相交贝塞尔的环。
- en: Removing n3 at the first opportunity
  id: totrans-split-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次机会时移除`n3`。
- en: Curvy edges
  id: totrans-split-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弯曲的边。
- en: Earlier we covered the CW - CCW graph traversal algorithm to find the minimal
    cycle basis (small areas).
  id: totrans-split-257
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候我们讨论了CW-CCW图遍历算法，以找到最小循环基（小区域）。
- en: Finding the better (counter clockwise most) point adjacent to `curr`
  id: totrans-split-258
  prefs: []
  type: TYPE_NORMAL
  zh: 找到与`curr`相邻的更好的（逆时针最多的）点。
- en: But the algorithm described in the paper was designed to work with nodes connected
    by straight lines that don't intersect. Introducing edges defined by cubic beziers
    introduces significant complexity.
  id: totrans-split-259
  prefs: []
  type: TYPE_NORMAL
  zh: 但是论文中描述的算法是设计用来处理由直线连接的不相交节点的。引入由三次贝塞尔定义的边增加了显著的复杂性。
- en: Which edge to choose, blue or green?
  id: totrans-split-260
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪条边，蓝色还是绿色？
- en: In the example above, we can find out that the blue edge is better than the
    green one by using the determinant. We are stilling defining better to mean the
    CCW most edge.
  id: totrans-split-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们可以通过使用行列式找出蓝色边优于绿色边的信息。我们仍在定义更好来表示逆时针最多的边。
- en: When working with cubic bezier curves, the naive solution would be to just convert
    the bezier to a line defined by the points at the start and end of the curve.
  id: totrans-split-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理三次贝塞尔曲线时，天真的解决方案是将贝塞尔曲线转换为由曲线起始点和结束点定义的线。
- en: But that idea breaks down as soon as one edge curves over the other.
  id: totrans-split-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当一个边曲线超过另一个边时，这个想法就会崩溃。
- en: Oops
  id: totrans-split-264
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕
- en: Let's take a fresh look at a bezier curves and try to work from there.
  id: totrans-split-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视贝塞尔曲线并试着从那里工作。
- en: Looking at this, we notice that the tangent at the start of the curve, `n0`,
    is parallel to the line from `n0` to `cp0`. So to get the direction at the start
    of the edge we can use the line `(n0, cp0)`.
  id: totrans-split-266
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到曲线起始处的切线`n0`与从`n0`到`cp0`的线平行。因此，为了得到边开始处的方向，我们可以使用线`(n0, cp0)`。
- en: For clarity, the start of our edge, `n0`, is the same node as `curr`.
  id: totrans-split-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们边的开始`n0`与`curr`相同。
- en: So by converting edges defined by cubic beziers into a line defined by `(n0,
    cp0)`, we get the *initial* angle of the curve.
  id: totrans-split-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过将由三次贝塞尔定义的边转换为由`(n0, cp0)`定义的线，我们得到曲线的*初始*角度。
- en: This seems like a good solution when looking at the “curve around” case.
  id: totrans-split-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当看到“曲线周围”的情况时，这似乎是一个不错的解决方案。
- en: Looks like we've solved the problem. Right?
  id: totrans-split-270
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经解决了这个问题。对吧？
- en: No intersections
  id: totrans-split-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有交点。
- en: Before we move on to further edge cases, it helps to understand that any solutions
    assume that no two edges may intersect when deciding which edge to travel.
  id: totrans-split-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续研究更多边缘情况之前，理解任何解决方案都假设在决定要遍历的边缘时不会有两条边相交是有帮助的。
- en: This is not allowed
  id: totrans-split-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不允许的
- en: The edges of the graph we're traversing must not have any intersections when
    we compute the cycles (minimal cycle basis) of the graph.
  id: totrans-split-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历的图的边缘在计算图的循环（最小循环基础）时不能有任何交点。
- en: We can only operate on an *expanded graph*.
  id: totrans-split-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能在*扩展的图*上操作。
- en: Like we covered earlier, an expanded graph is a graph that has replaced all
    intersections with new nodes and edges. So if the original, user-defined graph
    has any intersections, they would have to be expanded before we can find the graph's
    cycles.
  id: totrans-split-276
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们前面讨论的那样，扩展图是一个用新节点和边替换所有交点的图。因此，如果原始的用户定义图有任何交点，它们必须在我们找到图的循环之前扩展。
- en: The same edges as above, but expanded
  id: totrans-split-277
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述相同的边缘，但扩展了
- en: Parallel edges
  id: totrans-split-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平行边缘
- en: The next edge case is two edges being parallel (pointing in the same direction).
  id: totrans-split-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个边缘情况是两条边平行（指向相同方向）。
- en: If the lines go in the same direction, determining which is better is impossible
    without more information.
  id: totrans-split-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线条方向相同，没有更多信息的情况下确定哪一个更好是不可能的。
- en: Here are a few possible solutions for the cases where the control points of
    the curves are parallel.
  id: totrans-split-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几种可能的解决方案，控制点为平行的情况。
- en: Point at `t`
  id: totrans-split-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`t`处的点
- en: What if we just take the point on the curve at, for example, `t = 0.1`?
  id: totrans-split-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是在曲线上取例如`t = 0.1`的点会怎样呢？
- en: This produces the correct result for curves of a similar length, but we can
    easily break this with one curve being significantly bigger than the other.
  id: totrans-split-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于长度相似的曲线产生了正确的结果，但如果一条曲线明显比另一条长，我们很容易就能打破这个结果。
- en: This is effectively the same problem as the “curve around” case we saw earlier.
  id: totrans-split-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前看到的“曲线环绕”情况实际上是同一个问题。
- en: Point at length
  id: totrans-split-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在长度处的点
- en: Instead of taking a point at a fixed `t` value, we could take a point at some
    length along the curve. The length would be determined by some point on the smaller
    curve, e.g. at `t=0.1`.
  id: totrans-split-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑在曲线上某个长度处取一个固定`t`值的点。长度由较小曲线上的某点决定，例如在`t=0.1`处。
- en: I have not tried implementing this since I have another working solution, but
    this could possibly be a viable and performant solution if it works for all edge
    cases.
  id: totrans-split-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我尚未尝试实施这一点，因为我有另一个有效的解决方案，但如果它能解决所有边缘情况，这可能是一个可行且高效的解决方案。
- en: Lasers!
  id: totrans-split-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激光！
- en: The next solution is a bit esoteric but produces the correct result. This is
    the solution I'm currently using.
  id: totrans-split-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个解决方案有点神秘，但可以产生正确的结果。这是我目前正在使用的解决方案。
- en: We begin by splitting each bezier at `t = 0.05` (image above is exaggerated).
    We then tesselate each part into n points.
  id: totrans-split-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从每个贝塞尔曲线在`t = 0.05`处分割（上图夸大）。然后我们将每个部分tesselate成n个点。
- en: Then, for each point of the tesselated bezier, we check whether a line from
    `n0` to that point intersects the other edge.
  id: totrans-split-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于tesselated bezier的每个点，我们检查从`n0`到该点的线是否与另一条边相交。
- en: It's pretty hard to see what's going on at this scale, so let's zoom in a bit.
  id: totrans-split-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个尺度上很难看清楚发生了什么，所以让我们放大一点。
- en: When a point intersects the other edge, we use the point before it.
  id: totrans-split-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个点与另一条边相交时，我们使用它之前的点。
- en: Found an intersection
  id: totrans-split-295
  prefs: []
  type: TYPE_NORMAL
  zh: 发现了一个交点
- en: Let's zoom in a bit.
  id: totrans-split-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们放大一点。
- en: The intersection close up
  id: totrans-split-297
  prefs: []
  type: TYPE_NORMAL
  zh: 靠近交点
- en: For the other edge, we have no intersection.
  id: totrans-split-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一条边，我们没有交点。
- en: In that case, we just use the end of the edge as the direction line.
  id: totrans-split-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需使用边缘的末端作为方向线。
- en: With this method we've produced lines that seem to represent their respective
    curves.
  id: totrans-split-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们生成了似乎代表各自曲线的线段。
- en: And this also works for the “curve around” case.
  id: totrans-split-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于“曲线环绕”情况。
- en: But it fails for a “curve behind” case.
  id: totrans-split-302
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于“后面的曲线”情况却失败了。
- en: This would produce the green edge as the more CCW edge, which is wrong.
  id: totrans-split-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生绿色边缘作为更CCW边缘，这是错误的。
- en: My solution to this problem is to shoot an infinite laser in the direction of
    the previous edge.
  id: totrans-split-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个问题的解决方案是向前一个边缘的方向射出无限激光。
- en: We then check whether the points of the tesselated bezier intersect this laser.
  id: totrans-split-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查tesselated bezier的点是否与这个激光相交。
- en: But a line from `n0` to the points would never intersect the laser.
  id: totrans-split-306
  prefs: []
  type: TYPE_NORMAL
  zh: 但是从`n0`到这些点的线永远不会与激光相交。
- en: Passes right through
  id: totrans-split-307
  prefs: []
  type: TYPE_NORMAL
  zh: 直接穿过
- en: Instead, we can create a line from the current point to the previous point and
    use that for the intersection test.
  id: totrans-split-308
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以从当前点到前一个点创建一条线，并在交点测试中使用它。
- en: When we intersect the laser, we use the previous point. The previous point will
    always be on the correct side of the laser.
  id: totrans-split-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们相交激光时，我们使用前一个点。前一个点始终位于激光的正确侧。
- en: The point we use
  id: totrans-split-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的点
- en: And like that, we have a solution.
  id: totrans-split-311
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样，我们有了一个解决方案。
- en: Parallel, but in reverse!
  id: totrans-split-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平行，但是反向！
- en: It could also be the case that the blue or green edges, `a` and `b` respectively,
    could be parallel to the edge from `curr` to `prev`.
  id: totrans-split-313
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能是蓝色或绿色的边，分别是`a`和`b`，与从`curr`到`prev`的边平行。
- en: '`a` is parallel to `prev`'
  id: totrans-split-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`与`prev`平行'
- en: The process for finding the better edge follows a process similar to the one
    described above so we will cover this very quickly.
  id: totrans-split-315
  prefs: []
  type: TYPE_NORMAL
  zh: 找到更好边缘的过程遵循与上述类似的过程，因此我们将很快涵盖这一点。
- en: 'There are two cases:'
  id: totrans-split-316
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种情况：
- en: A or B are parallel to `Prev` , but not both
  id: totrans-split-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A或B与`Prev`平行，但不是两者都平行
- en: If either `a` or `b`, but not both, are parallel to `prev`, we can simply compare
    the parallel edge to `prev`.
  id: totrans-split-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`a`或`b`中的一条边与`prev`平行，我们可以简单地将平行边与`prev`比较。
- en: If the parallel edge is CW of `prev`, the parallel edge is better.
  id: totrans-split-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果平行边在`prev`的顺时针方向，那么平行边更好。
- en: If the parallel edge is CCW of `prev`, the other edge is better.
  id: totrans-split-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果平行边是`prev`的逆时针方向，那么另一条边更好。
- en: Think a bit about why this is true.
  id: totrans-split-321
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想为什么这是正确的。
- en: If one edge is parallel to `prev` and curves CW, and the other is not parallel
    to `prev`, then the parallel edge is as CCW as can be. This means that the green
    zone for the other edge is completely empty.
  id: totrans-split-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一条边与`prev`平行并且向顺时针弯曲，另一条边不与`prev`平行，则平行边尽可能地逆时针。这意味着另一条边的绿色区域完全为空。
- en: The reverse is true if the parallel edge curves CCW, since it would be as CW
    as possible. This means that the green zone for the other edge is the whole circle.
  id: totrans-split-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果平行边逆时针弯曲，反之亦然，因为它尽可能地顺时针。这意味着另一条边的绿色区域是整个圆。
- en: Both A and B are parallel to Prev
  id: totrans-split-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A和B都与Prev平行
- en: Using the same laser solution as before, this case is covered.
  id: totrans-split-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的激光解决方案，这种情况已经涵盖了。
- en: Cycles inside of cycles
  id: totrans-split-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环中的循环
- en: Now we're going to look at fills for a bit.
  id: totrans-split-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将稍微看看填充。
- en: Let's take a look at a basic example of a graph with a cycle inside of another
    cycle.
  id: totrans-split-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个基本示例，图中有一个循环嵌套在另一个循环内部。
- en: 'You would expect the graph''s areas to be defined like so:'
  id: totrans-split-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望图形的区域像这样定义：
- en: But as it stands, if you hover over the outer area you get a different, unsatisfactory
    result.
  id: totrans-split-330
  prefs: []
  type: TYPE_NORMAL
  zh: 但目前为止，如果你悬停在外围区域上，你会得到一个不同的、令人不满意的结果。
- en: But this makes sense. Let's take a look at the nodes of the graph.
  id: totrans-split-331
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是有道理的。让我们看一看图中的节点。
- en: The cycle `(0, 1, 2, 3)` describes the outer boundary of the area we want, but
    we aren't describing the “inner boundary” of the area yet.
  id: totrans-split-332
  prefs: []
  type: TYPE_NORMAL
  zh: 循环`(0, 1, 2, 3)`描述了我们想要的区域的外边界，但我们还没有描述区域的“内边界”。
- en: Let's take a look at how we can do that.
  id: totrans-split-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以如何做到这一点。
- en: Even-odd rule
  id: totrans-split-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 偶数-奇数规则
- en: Telling a computer to draw the outline of a 2D shape is simple enough. But if
    you want to fill that shape, how do you tell the computer what is “inside” and
    what is “outside”?
  id: totrans-split-335
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉计算机如何绘制2D形状的轮廓是相当简单的。但是如果你想要填充这个形状，怎么告诉计算机什么是“内部”和什么是“外部”呢？
- en: One way of finding out whether a point is inside a shape or not is by shooting
    an infinite laser in any direction from that point and counting how many “walls”
    it passes through.
  id: totrans-split-336
  prefs: []
  type: TYPE_NORMAL
  zh: 找出一个点是否在形状内部的一种方法是从该点向任意方向发射无限激光，并计算它穿过多少“墙”。
- en: If the laser intersects an odd number of walls, it's inside of the shape. Otherwise
    it is outside of the shape.
  id: totrans-split-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果激光与奇数面墙相交，则位于形状内部。否则，它位于形状外部。
- en: Intersects 1 wall, we're inside of the shape
  id: totrans-split-338
  prefs: []
  type: TYPE_NORMAL
  zh: 相交1面墙，我们在形状内部
- en: Intersects 4 walls, we're outside of the shape
  id: totrans-split-339
  prefs: []
  type: TYPE_NORMAL
  zh: 相交4面墙，我们在形状外部
- en: This works for any 2D shape, no matter which point you choose and which direction
    you shoot the laser in.
  id: totrans-split-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于任何2D形状，无论你选择哪个点和向哪个方向发射激光。
- en: This also helps in the case of nested paths.
  id: totrans-split-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这也有助于嵌套路径的情况。
- en: This gives us an idea for how we can define the “inner boundary” of a shape.
  id: totrans-split-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个定义形状“内部边界”的想法。
- en: Reducing closed walks
  id: totrans-split-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少闭合路径
- en: Let's look at a graph with a cycle nested inside of another cycle, but with
    an edge connecting two nodes of the cycles.
  id: totrans-split-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个图形，一个循环嵌套在另一个循环内部，但是有一条边连接两个循环的节点。
- en: This will lead back to how we can think about nested cycles and give us a deeper
    understanding on how to think about them.
  id: totrans-split-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致我们如何考虑嵌套循环，并让我们更深入地理解如何考虑它们。
- en: Let's find the cycles. We use the same CW-CCW method as usual.
  id: totrans-split-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出循环。我们使用和往常一样的顺时针和逆时针方法。
- en: With this method, we go on what looks like a small detour around the inner cycle.
  id: totrans-split-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们似乎绕过内部循环进行了一个小小的绕道。
- en: When we reach the node we started at, this is what the cycle looks like.
  id: totrans-split-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达起始节点时，这就是循环的样子。
- en: This is the first cycle we've seen where we cross a node twice (both `n3` and
    `n4`). Something interesting appears when we take a look at the direction that
    the cycle takes throughout the graph.
  id: totrans-split-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次看到跨越一个节点两次（`n3`和`n4`）。当我们观察这个循环在整个图中的方向时，会出现一些有趣的东西。
- en: We start off traveling CCW, but when we cross the edge from the outer cycle
    to the inner cycle the orientation we travel seems to flip.
  id: totrans-split-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始逆时针旅行，但当我们穿过从外部循环到内部循环的边缘时，我们旅行的方向似乎发生了翻转。
- en: I will state for now that we want to separate the outer cycle from the inner
    cycle and treat the edge between them as if it didn't exist. I will go into the
    *why* later and explain the *how* here.
  id: totrans-split-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我暂时声明，我们想要将外部循环与内部循环分开，并将它们之间的边缘视为不存在。我稍后会解释为什么，这里解释如何操作。
- en: We take all repeated nodes, in this case `n3`, and remove them from the cycle.
    We also remove any nodes that are between the two repeated nodes.
  id: totrans-split-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有重复的节点，本例中为`n3`，从循环中移除。我们还移除任何位于两个重复节点之间的节点。
- en: You might notice that `n4` is also repeated, but since it's “inside” of the
    part of the cycle that `n3` removes, we can ignore it.
  id: totrans-split-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到`n4`也被重复了，但因为它“在”`n3`移除的部分循环内，我们可以忽略它。
- en: We leave one instance of the repeated node, and then we have the cycle that
    would have been found if the *crossing* didn't exist.
  id: totrans-split-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留下一个重复节点的实例，然后我们得到如果*交叉*不存在时将找到的循环。
- en: We then mark the edge that connected the outer cycle from the inner cycle. I
    call these marked edges *crossings*.
  id: totrans-split-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们标记连接外部循环与内部循环的边缘。我称这些标记的边缘为*交叉*。
- en: It could also be the case that an outer-inner cycle combo has multiple crossings.
  id: totrans-split-356
  prefs: []
  type: TYPE_NORMAL
  zh: 外-内循环组合可能有多个交叉点。
- en: In that case, we mark all edges adjacent to the node connected to the outer
    cycle as a crossing.
  id: totrans-split-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们标记所有与连接到外部循环的节点相邻的边缘为一个交叉。
- en: 'And after all this is done, our cycles look like so:'
  id: totrans-split-358
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们的循环看起来像这样：
- en: Subcycles
  id: totrans-split-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子循环
- en: Instead of referring to “inner” and “outer” cycles, I will refer to subcycles
    and parent cycles. This will make it easier to think about multiple cycles relative
    to each other.
  id: totrans-split-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我将不再提到“内部”和“外部”循环，而是称之为子循环和父循环。这将更容易思考多个循环相对于彼此的关系。
- en: Having said that, let's introduce a third cycle.
  id: totrans-split-361
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们引入第三个循环。
- en: When we hover over the outermost cycle, what do you expect to happen?
  id: totrans-split-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们悬停在最外层的循环上时，你期望会发生什么？
- en: Because of the even-odd rule, the innermost cycle is filled too!
  id: totrans-split-363
  prefs: []
  type: TYPE_NORMAL
  zh: 由于偶奇规则，最内层的循环也被填充了！
- en: To fix this, we can introduce the concept of *direct subcycles*.
  id: totrans-split-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以引入*直接子循环*的概念。
- en: Parent cycles (blue) and their direct subcycles (green)
  id: totrans-split-365
  prefs: []
  type: TYPE_NORMAL
  zh: 父循环（蓝色）及其直接子循环（绿色）
- en: A parent cycle may have multiple direct subcycles. But due to the non-intersection
    rule, a subcycle may only have a single parent cycle.
  id: totrans-split-366
  prefs: []
  type: TYPE_NORMAL
  zh: 父循环可能有多个直接子循环。但由于非交叉规则，子循环只能有一个父循环。
- en: Let's take a look at how this works.
  id: totrans-split-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何运作的。
- en: 'This graph has a a rectangle, our outermost cycle, which has two direct subcycles:
    a diamond and an hourglass. The diamond has two direct subcycles of its own, and
    the hourglass has three direct subcycles.'
  id: totrans-split-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图中有一个矩形，我们最外层的循环，它有两个直接子循环：一个菱形和一个沙漏。菱形有两个直接子循环，而沙漏有三个直接子循环。
- en: We will begin with the rectangle and its direct subcycles. We will name them,
    `c0`, `c1` and `c2`.
  id: totrans-split-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从矩形及其直接子循环开始。我们将它们命名为`c0`，`c1`和`c2`。
- en: The user has decided to fill some of these cycles, and leave some of them empty.
  id: totrans-split-370
  prefs: []
  type: TYPE_NORMAL
  zh: 用户决定填充其中一些循环，而另一些则留空。
- en: '`c0` and `c1` are filled, and `c2` is empty'
  id: totrans-split-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`c0`和`c1`被填充了，而`c2`是空的。'
- en: Let's draw the graph without a stroke and with a gray fill. When drawing this
    graph we start with the outermost cycle, `c0`.
  id: totrans-split-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用灰色填充，没有描边地绘制这张图。在绘制这张图时，我们从最外层的循环`c0`开始。
- en: The graph to the left with the render to the right
  id: totrans-split-373
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的图形与右边的渲染图
- en: Since `c0` is filled, we draw it. If it were not filled we could skip drawing
    it. We can shoot a laser out of the rectangle and see that it intersects the walls
    of the rectangle once, so we can expect it to be filled considering the even-odd
    rule.
  id: totrans-split-374
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`c0`已经填充，我们将其绘制出来。如果它没有被填充，我们可以跳过绘制它。我们可以从矩形中射出激光，看到它与矩形的边界相交一次，因此我们可以预期根据偶奇规则它将被填充。
- en: This may seem really obvious, but it's good to have the rules of the game laid
    out clearly before we move on.
  id: totrans-split-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来非常明显，但在我们继续之前，明确规定游戏规则是很好的。
- en: Next we want to draw `c1`, the diamond in our graph. It was filled, just like
    the rectangle so we should draw it as well. But if we try to draw the diamond
    as well, we get the wrong result.
  id: totrans-split-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要绘制`c1`，也就是图中的钻石。它被填充了，就像矩形一样，所以我们也应该绘制它。但是，如果我们尝试绘制钻石，我们会得到错误的结果。
- en: Our laser is intersecting two walls as a result of drawing both of the shapes
    when the have the same fill setting.
  id: totrans-split-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的激光在绘制两个形状时相交，当它们具有相同的填充设置时。
- en: We intersect an even number of walls, so we're “outside” of the shape
  id: totrans-split-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们交叉了偶数个墙壁，所以我们处于形状的“外部”。
- en: So to draw the image the user wanted we can simply skip drawing the diamond
    since the parent cycle implicitly draws direct subcycles with the same fill setting.
  id: totrans-split-379
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了绘制用户想要的图像，我们可以简单地跳过绘制钻石，因为父循环隐式地绘制了具有相同填充设置的直接子循环。
- en: The hourglass, `c2`, is supposed to be empty. With that being the case, just
    not drawing it seems like a reasonable conclusion. But since the parent cycle
    (rectangle) has already drawn the hourglass as if it were filled we need to “flip”
    the fill by drawing the hourglass.
  id: totrans-split-380
  prefs: []
  type: TYPE_NORMAL
  zh: 沙漏`c2`应该是空的。在这种情况下，仅仅不绘制它似乎是一个合理的结论。但由于父循环（矩形）已经绘制了沙漏，好像它是填充的，我们需要通过绘制沙漏来“翻转”填充。
- en: And again, if we try to use the laser intersection method we see that the number
    of intersections is 2, an even number. And with the even-odd rule, an even number
    of walls means you're “outside” of the shape.
  id: totrans-split-381
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们尝试使用激光交叉法，我们看到交叉点的数量是2，一个偶数。根据偶数-奇数规则，偶数个墙壁意味着你处于形状的“外部”。
- en: Now that we've drawn the rectangle and its direct subcycles, we can move onto
    the direct subcycles of those.
  id: totrans-split-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经绘制了矩形及其直接子循环，我们可以继续处理这些直接子循环的直接子循环。
- en: When working with `c3` and `c4`, the direct subcycles of `c1`, we can treat
    them as if they're direct subcycles of `c0` since `c1` had the same fill setting.
  id: totrans-split-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理`c3`和`c4`时，即`c1`的直接子循环时，我们可以将它们视为`c0`的直接子循环，因为`c1`具有相同的填充设置。
- en: For `c3`, we want to “flip” the fill setting so we draw it. But `c4` has the
    same fill setting as its parent cycle so we don't draw it.
  id: totrans-split-384
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`c3`，我们想要“翻转”填充设置，因此我们将其绘制出来。但是对于`c4`，由于它与其父循环具有相同的填充设置，我们不绘制它。
- en: Even number of intersections so we're outside of the shape
  id: totrans-split-385
  prefs: []
  type: TYPE_NORMAL
  zh: 偶数个交叉点，所以我们在形状的外面。
- en: And we can think of `c5`, `c6` and `c7` in the same way. We don't care whether
    they're filled or empty when rendering them. We care whether or not they have
    the same fill as their parent cycle.
  id: totrans-split-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以相同的方式考虑`c5`、`c6`和`c7`。当渲染它们时，我们不在乎它们是填充的还是空的。我们在乎的是它们与父循环的填充是否相同。
- en: We only need to draw cycles if their parent cycle has the opposite “fill setting”
    as themselves. If they have the same fill setting, we don't have to draw them.
  id: totrans-split-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要绘制循环，如果它们的父循环与它们自身的填充设置相反。如果它们具有相同的填充设置，我们不必绘制它们。
- en: This means that when drawing cycles, start by drawing the outermost “filled”
    cycle and then look at that cycle's subcycles. If a subcycle has the same fill
    setting as its parent cycle, it should not be drawn.
  id: totrans-split-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在绘制循环时，首先绘制最外层的“填充”循环，然后查看该循环的子循环。如果一个子循环与其父循环具有相同的填充设置，则不应绘制它。
- en: Contiguous cycles
  id: totrans-split-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连续循环
- en: A graph may have multiple “clusters” of cycles.
  id: totrans-split-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图可能有多个“循环簇”。
- en: I use the phrase *contiguous cycles* to describe the “togetherness” of the cycles,
    if you will. I often think of these contiguous groups of cycles as being in different
    colors.
  id: totrans-split-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用短语*连续循环*来描述这些循环的“紧密性”，如果可以这么说的话。我经常把这些连续的循环组想象成不同的颜色。
- en: 'Finding these contiguous cycles can be done with a depth-first traversal:'
  id: totrans-split-392
  prefs: []
  type: TYPE_NORMAL
  zh: 找到这些连续循环可以通过深度优先遍历完成：
- en: Start at the first node of the cycle
  id: totrans-split-393
  prefs: []
  type: TYPE_NORMAL
  zh: 从循环的第一个节点开始
- en: Color each node you find
  id: totrans-split-394
  prefs: []
  type: TYPE_NORMAL
  zh: 染上你找到的每个节点
- en: But remember the *crossings*? In the search, you may not crawl to adjacent nodes
    by edges marked as crossings.
  id: totrans-split-395
  prefs: []
  type: TYPE_NORMAL
  zh: 但是记住*交叉*吗？在搜索中，您可能不会通过标记为交叉的边缘爬到相邻节点。
- en: 'So in the end, our colors actually look like this:'
  id: totrans-split-396
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终，我们的颜色实际上是这样的：
- en: 'Take this group of contiguous cycles nested inside another group of contiguous
    cycles:'
  id: totrans-split-397
  prefs: []
  type: TYPE_NORMAL
  zh: 取这一组连续的循环，嵌套在另一组连续的循环中：
- en: Because of the non-intersection rule we know that if one of the nodes in a group
    of contiguous cycles is inside of a cycle not in the group, all of them are.
  id: totrans-split-398
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非交叉规则，我们知道如果一组连续循环中的一个节点位于不在该组中的循环内部，那么所有这些节点都在内部。
- en: This “contiguous cycles” idea is maybe not the most interesting part of this
    post on the surface, but I've found it to be useful when working on Vector Networks.
  id: totrans-split-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“连续循环”的想法表面上可能不是本文中最有趣的部分，但我发现在处理向量网络时它很有用。
- en: Partial expansion
  id: totrans-split-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分展开
- en: When hovering an area defined by intersections, we are showing a cycle of the
    expanded graph.
  id: totrans-split-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当悬停在由交点定义的区域时，我们显示了扩展图形的一个循环。
- en: Take this triangle as an example.
  id: totrans-split-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个三角形为例。
- en: If we hover over one of its areas, we see an area defined by nodes that don't
    exist yet.
  id: totrans-split-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们悬停在其区域之一上，我们会看到一个由尚不存在的节点定义的区域。
- en: What the blue striped area represents is the area whose fill state would be
    “toggled” if the user clicks the left mouse button. This area does not exist on
    the graph as the user defined it. It exists as a cycle on the expanded version
    of the original graph.
  id: totrans-split-404
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色条纹区域代表的是如果用户点击鼠标左键将“切换”其填充状态的区域。此区域不存在于用户定义的图形上，而是存在于原始图形的扩展版本上的一个循环中。
- en: The expanded graph
  id: totrans-split-405
  prefs: []
  type: TYPE_NORMAL
  zh: 展开的图
- en: When the user clicks to toggle the fill state of the area, we would first have
    to expand the graph for the nodes and edges that make up that area to exist.
  id: totrans-split-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击以切换区域填充状态时，我们首先必须扩展用于存在的节点和边的图形。
- en: The expanded graph
  id: totrans-split-407
  prefs: []
  type: TYPE_NORMAL
  zh: 展开的图
- en: But by doing that we've expanded two intersections that we didn't need to expand
    to be able to describe the area. These expansions are destructive in nature and
    should be avoided when possible.
  id: totrans-split-408
  prefs: []
  type: TYPE_NORMAL
  zh: 但通过这样做，我们扩展了两个我们不需要扩展以描述区域的交叉点。这些扩展具有破坏性质，应尽可能避免。
- en: Instead, we can *partially expand* the graph by only expanding the intersections
    that define the selected cycle.
  id: totrans-split-409
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以*部分展开*图形，只展开定义所选循环的交点。
- en: Partially expanded graph
  id: totrans-split-410
  prefs: []
  type: TYPE_NORMAL
  zh: 部分展开的图
- en: This allows us to maintain as much of the original graph as possible while still
    being able to define the fill.
  id: totrans-split-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够尽可能保留原始图形，同时仍能定义填充。
- en: Implementing partial expansions
  id: totrans-split-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现部分展开
- en: The basic implementation is reasonably simple. When you create the expanded
    graph, just add a little metadata to each expanded node that tells you which two
    edges of the original graph were used to create it and at what `t` values those
    intersections occurred.
  id: totrans-split-413
  prefs: []
  type: TYPE_NORMAL
  zh: 基本实现是相当简单的。当您创建扩展图形时，只需向每个扩展节点添加一些元数据，告诉您用于创建它的原始图形的哪两条边以及这些交点发生在什么`t`值。
- en: Then when the cycle is clicked, iterate over each node. If the node exists in
    the expanded graph but not the original graph, add it to a new partially expanded
    graph.
  id: totrans-split-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然后当点击循环时，迭代每个节点。如果节点存在于扩展图中但不存在于原始图中，则将其添加到一个新的部分展开的图中。
- en: There are edge cases, but I will not be covering them here.
  id: totrans-split-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些边缘案例，但我将不在此进行详细讨论。
- en: Omitted topics
  id: totrans-split-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被省略的主题
- en: Here are some of the topics that I decided to omit for this post. Go have a
    stab at them yourself!
  id: totrans-split-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我决定在本文中省略的主题。去试试看吧！
- en: Joins
  id: totrans-split-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: Figma offers three types of joins. Round, pointy and square. How could these
    different types of joins be implemented?
  id: totrans-split-419
  prefs: []
  type: TYPE_NORMAL
  zh: Figma提供了三种连接类型。圆形、尖角和方形。如何实现这些不同类型的连接？
- en: Stroke align
  id: totrans-split-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描边对齐
- en: 'Figma also offers three ways to align the stroke of a graph: center, inside
    and outside.'
  id: totrans-split-421
  prefs: []
  type: TYPE_NORMAL
  zh: Figma还提供了三种方式来对齐图形的描边：中心、内部和外部。
- en: How do you determine inside- or outside-ness and what happens when the graph
    has no cycles?
  id: totrans-split-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如何确定图中的内部或外部，当图中没有循环时会发生什么？
- en: Boolean operations
  id: totrans-split-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔运算
- en: Figma, like most vector graphics tools, offers [boolean operations](https://help.figma.com/article/65-boolean-operations).
    How could those be implemented?
  id: totrans-split-424
  prefs: []
  type: TYPE_NORMAL
  zh: Figma，像大多数矢量图形工具一样，提供了[布尔运算](https://help.figma.com/article/65-boolean-operations)。如何实现这些？
- en: '[Paper.js](http://paperjs.org/) is open source and has boolean operations for
    paths, maybe you can start there?'
  id: totrans-split-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[Paper.js](http://paperjs.org/)是开源的，具有路径的布尔运算，也许你可以从这里开始？'
- en: Future topics
  id: totrans-split-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来的主题
- en: These are some of the more open-ended features and ideas I want to explore in
    the future.
  id: totrans-split-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我未来想要探索的一些更开放性的功能和想法。
- en: A different way of working with fills
  id: totrans-split-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用填充的另一种工作方式
- en: There are alternatives to how Figma allows the user to work with fills.
  id: totrans-split-429
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以替代Figma允许用户处理填充的方式。
- en: One possible solution I'm interested in exploring is multiple different “fill
    layers” that use one vector object as a reference. This would solve the “[one
    graph, multiple colors](https://spectrum.chat/figma/feature-requests/paint-bucket-tool-with-multiple-colors~1b55179b-f911-468b-9355-fd361564fda0)”
    problem without having to duplicate the layer and keep multiple vector objects
    in sync if you want to make changes later on.
  id: totrans-split-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我感兴趣探索的一个可能解决方案是使用多个不同的“填充层”，这些层使用一个矢量对象作为参考。这将解决“一个图形，多种颜色”的问题，而无需复制层并保持多个矢量对象同步，如果以后要进行更改。
- en: Animating the graph
  id: totrans-split-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 给图形添加动画效果
- en: Given an [expression](https://helpx.adobe.com/after-effects/using/expression-basics.html)
    and reference based system similar to After Effects, what could you achieve when
    you combine it with Vector Networks?
  id: totrans-split-432
  prefs: []
  type: TYPE_NORMAL
  zh: 借助类似于 After Effects 的表达式和基于参考的系统，当你将它与矢量网络结合使用时，你可以实现什么？
- en: Or maybe we could make use of a node editor similar to [Blender's shader editor](https://docs.blender.org/manual/en/latest/editors/shader_editor/index.html)
    or [Fusion's node based workflow](https://www.blackmagicdesign.com/products/fusion/visualeffects)?
  id: totrans-split-433
  prefs: []
  type: TYPE_NORMAL
  zh: 或许我们可以利用类似于[Blender 的着色器编辑器](https://docs.blender.org/manual/en/latest/editors/shader_editor/index.html)或[Fusion
    的基于节点的工作流](https://www.blackmagicdesign.com/products/fusion/visualeffects)的节点编辑器？
- en: There's a lot of exploration to be done here and I'm really excited to dive
    into this topic.
  id: totrans-split-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多探索的空间，我对深入研究这个主题非常兴奋。
- en: In closing
  id: totrans-split-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Thanks for reading this post! I hope it served as a good introduction to what
    I think is a really interesting problem space. I've been working on this problem
    alongside school and work for a good while. It's part of an animation editor plus
    runtime for the web I'm working on. I intend for a modified version of Vector
    Networks to be the core of a few features.
  id: totrans-split-436
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读这篇文章！希望它作为对我认为非常有趣的问题空间的一个良好介绍。我在学校和工作之余一直在解决这个问题。这是我正在开发的 Web 动画编辑器加运行时的一部分。我打算将修改版的矢量网络作为几个功能的核心。
- en: I've been working on implementing Vector Networks for a bit over half a year
    now. The vector editor is pretty robust when it comes to creating, modifying and
    expanding the graph. But the edge cases when modifying the fill state have been
    stumping me for quite a while now.
  id: totrans-split-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在实现矢量网络上工作了半年多。在创建、修改和扩展图形方面，这个矢量编辑器非常强大。但是在修改填充状态时遇到的边缘案例已经困扰我很长时间了。
- en: I wanted to have a fully working demo before publishing this post, but it's
    going to be a few months until it's stable enough for it to be usable for people
    that are not me.
  id: totrans-split-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望在发布这篇文章之前能有一个完全可工作的演示版，但要使其对不是我自己的人可用，还需要几个月时间使其足够稳定。
- en: The big idea behind the project is to be a piece of animation software that's
    tailor-made for creating and running dynamic animations on the web. I'll share
    more about this project at a later date.
  id: totrans-split-439
  prefs: []
  type: TYPE_NORMAL
  zh: 项目背后的大思路是开发一款专门为 Web 上创建和运行动态动画而设计的动画软件。我将在稍后的时间分享更多关于这个项目的信息。
- en: I also just think that Figma's Vector Networks are super cool and it's really
    hard to find material about it online. I hope this post helps fix the lack of
    information that I encountered when attempting to find information about Vector
    Networks.
  id: totrans-split-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我也觉得 Figma 的矢量网络非常酷，但在网上很难找到相关资料。我希望这篇文章能帮助弥补我在查找矢量网络信息时遇到的信息匮乏。
- en: </main>
  id: totrans-split-441
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
