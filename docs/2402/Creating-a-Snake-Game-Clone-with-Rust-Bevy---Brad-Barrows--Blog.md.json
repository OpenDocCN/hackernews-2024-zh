["```\n let head_mesh = Mesh2dHandle(meshes.add(Rectangle::new(OBJECT_SIZE, OBJECT_SIZE)));\n    let box_color = Color::rgb(0.8, 0.2, 0.1);\n    commands.spawn((\n        MaterialMesh2dBundle {\n            mesh: head_mesh,\n            material: materials.add(box_color),\n            transform: Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),\n            ..default()\n        },\n        SnakeHead {\n            direction: Direction::Up,\n        },\n    )); \n```", "```\nfn check_collisions(\n    mut commands: Commands,\n    mut meshes: ResMut<Assets<Mesh>>,\n    mut materials: ResMut<Assets<ColorMaterial>>,\n    mut apple_query: Query<(&mut Transform), (With<Apple>, Without<SnakeHead>, Without<SnakeBody>)>,\n    mut snake_head_query: Query<(&mut Transform, &mut SnakeHead)>,\n    mut snake_body_query: Query<(&mut Transform, Entity), (With<SnakeBody>, Without<SnakeHead>)>, \n```", "```\nstruct FunctionSystem<Input, F> {\n    f: F,\n    marker: PhantomData<fn() -> Input>,\n}\n\ntrait System {\n    fn run(&mut self, resources: &mut HashMap<TypeId, Box<dyn Any>>);\n}\n\nmacro_rules! impl_system {\n    (\n        $(\n            $($params:ident),+\n        )?\n    ) => {\n        #[allow(non_snake_case, unused)]\n        impl<\n            F: FnMut(\n                $( $($params),+ )?\n            )\n            $(, $($params: 'static),+ )?\n        > System for FunctionSystem<($( $($params,)+ )?), F> {\n            fn run(&mut self, resources: &mut HashMap<TypeId, Box<dyn Any>>) {\n                $($(\n                    let $params = *resources.remove(&TypeId::of::<$params>()).unwrap().downcast::<$params>().unwrap();\n                )+)?\n\n                (self.f)(\n                    $($($params),+)?\n                );\n            }\n        }\n    }\n}\n\nimpl_system!();\nimpl_system!(T1);\nimpl_system!(T1, T2);\nimpl_system!(T1, T2, T3);\nimpl_system!(T1, T2, T3, T4);\n\ntrait IntoSystem<Input> {\n    type System: System;\n\n    fn into_system(self) -> Self::System;\n}\n\nmacro_rules! impl_into_system {\n    (\n        $($(\n                $params:ident\n        ),+)?\n    ) => {\n        impl<F: FnMut($($($params),+)?) $(, $($params: 'static),+ )?> IntoSystem<( $($($params,)+)? )> for F {\n            type System = FunctionSystem<( $($($params,)+)? ), Self>;\n\n            fn into_system(self) -> Self::System {\n                FunctionSystem {\n                    f: self,\n                    marker: Default::default(),\n                }\n            }\n        }\n    }\n}\n\nimpl_into_system!();\nimpl_into_system!(T1);\nimpl_into_system!(T1, T2);\nimpl_into_system!(T1, T2, T3);\nimpl_into_system!(T1, T2, T3, T4);\n\ntype StoredSystem = Box<dyn System>;\n\nstruct Scheduler {\n    systems: Vec<StoredSystem>,\n    resources: HashMap<TypeId, Box<dyn Any>>,\n}\n\nimpl Scheduler {\n    pub fn run(&mut self) {\n        for system in self.systems.iter_mut() {\n            system.run(&mut self.resources);\n        }\n    }\n\n    pub fn add_system<I, S: System + 'static>(&mut self, system: impl IntoSystem<I, System = S>) {\n        self.systems.push(Box::new(system.into_system()));\n    }\n\n    pub fn add_resource<R: 'static>(&mut self, res: R) {\n        self.resources.insert(TypeId::of::<R>(), Box::new(res));\n    }\n}\n\nfn main() {\n    let mut scheduler = Scheduler {\n        systems: vec![],\n        resources: HashMap::default(),\n    };\n\n    scheduler.add_system(foo);\n    scheduler.add_resource(12i32);\n\n    scheduler.run();\n}\n\nfn foo(int: i32) {\n    println!(\"int! {int}\");\n} \n```"]