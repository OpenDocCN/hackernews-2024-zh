["```\nenum StackPointerUnwindMechanism {\n  Undefined,\n  RegOffset(unsigned RegOrdinal, unsigned Offset),\n  ExprResult(uint8_t DwOpBytecode[unsigned Len]),\n};\n\nenum OtherRegUnwindMechanism {\n  Undefined,\n  LoadFromStackSlot(int StackSlotOffset),\n  AddressOfStackSlot(int StackSlotOffset),\n  CopyFromRegister(unsigned RegOrdinal),\n  LoadFromExprResult(uint8_t DwOpBytecode[unsigned Len]),\n  ExprResult(uint8_t DwOpBytecode[unsigned Len]),\n};\n\nstruct UnwindActions {\n  StackPointerUnwindMechanism sp;\n  OtherRegUnwindMechanism reg[NUM_REG];\n}; \n```", "```\nstruct RegState {\n  uintptr_t value[NUM_REG];\n};\n\nRegState UnwindOneFrame(RegState* input, UnwindActions* actions) {\n  RegState output;\n  uintptr_t NewSP;\n  switch (actions->sp) {\n  case RegOffset(unsigned RegOrdinal, unsigned Offset):\n    NewSP = input->value[RegOrdinal] + Offset;\n    break;\n  case ExprResult(uint8_t DwOpBytecode[unsigned Len]):\n    NewSP = EvalExpr(DwOpBytecode, 0, input);\n    break;\n  }\n  output->value[SP] = NewSP;\n  for (unsigned i = 0; i < NUM_REG; ++i) {\n    uintptr_t NewVal;\n    switch (actions->reg[i]) {\n    case LoadFromStackSlot(int StackSlotOffset):\n      NewVal = *(uintptr_t*)(NewSP + StackSlotOffset);\n      break;\n    case AddressOfStackSlot(int StackSlotOffset):\n      NewVal = NewSP + StackSlotOffset;\n      break;\n    case CopyFromRegister(unsigned RegOrdinal):\n      NewVal = input->value[RegOrdinal];\n      break;\n    case LoadFromExprResult(uint8_t DwOpBytecode[unsigned Len]):\n      NewVal = *(uintptr_t*)EvalExpr(DwOpBytecode, NewSP, input);\n      break;\n    case ExprResult(uint8_t DwOpBytecode[unsigned Len]):\n      NewVal = EvalExpr(DwOpBytecode, NewSP, input);\n      break;\n    default:\n      continue;\n    }\n    output->value[i] = NewVal;\n  }\n  return output;\n} \n```", "```\nstruct cie {\n  uint32_t length;           \n  int32_t  zero;             \n  uint8_t  version;          \n  char     aug_string[];     \n  if (aug_string[0] == 'e' && aug_string[1] == 'h') {\n    void* eh_ptr;            \n  }\n  if (version >= 4) {\n    uint8_t addr_size;       \n    uint8_t segment_size;    \n  }\n  uleb128 code_align;        \n  sleb128 data_align;        \n  if (version == 1) {\n    uint8_t return_address_ordinal;\n  } else {\n    uleb128 return_address_ordinal;\n  }\n  uint8_t aug_operands[];    \n  uint8_t dw_cfa_bytecode[];\n  uint8_t zero_padding[];    \n}; \n```", "```\nstruct fde {\n  uint32_t length;            \n  int32_t  cie_offset;        \n  uint8_t  func_start[];      \n  uint8_t  func_length[];     \n  uint8_t  aug_operands[];    \n  uint8_t  dw_cfa_bytecode[]; \n  uint8_t  zero_padding[];    \n}; \n```", "```\nstruct eh_frame_hdr {\n  uint8_t version;          \n  uint8_t eh_frame_ptr_enc; \n  uint8_t fde_count_enc;    \n  uint8_t table_enc;        \n  uint8_t eh_frame_ptr[];   \n  uint8_t fde_count[];      \n  struct {\n    int32_t func_start;     \n    int32_t fde_offset;     \n  } sorted_table[fde_count];\n}; \n```", "```\nuintptr_t EvalExpr(uint8_t DwOpBytecode[unsigned Len],\n                   uintptr_t StackInitial,\n                   RegState* original) {\n  const uint8_t* bpc = DwOpBytecode;\n  Stack<uintptr_t> stk;\n  stk.Push(StackInitial);\n  while (bpc < DwOpBytecode + Len) {\n    uint8_t opcode = *bpc++;\n\n    ...\n\n    ...\n  }\n  return stk.Pop();\n} \n```", "```\n0x92 0x07 0x08  DW_OP_bregx(7 /* rsp */, 8)\n0x90 0x10       DW_OP_regx(16 /* rip */)\n0x08 0x0f       DW_OP_const1u(15)\n0x1a            DW_OP_and\n0x08 0x0b       DW_OP_const1u(11)\n0x2a            DW_OP_ge\n0x08 0x03       DW_OP_const1u(3)\n0x24            DW_OP_shl\n0x22            DW_OP_plus \n```", "```\nrsp + 8 + ((((rip & 15) >= 11) ? 1 : 0) << 3) \n```"]