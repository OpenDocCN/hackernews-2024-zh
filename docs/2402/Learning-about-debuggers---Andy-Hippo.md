<!--yml

类别：未分类

日期：2024-05-27 14:54:44

-->

# 学习调试器 | Andy Hippo

> 来源：[https://werat.dev/blog/learning-about-debuggers/](https://werat.dev/blog/learning-about-debuggers/)

# 学习调试器

2024 年 1 月 8 日

今天的文章是一个材料集，旨在更深入了解调试器：它们如何工作，底层使用的技术是哪些，这个领域存在哪些问题。当然，这与编译器和链接器等相关组件有很大重叠，所以准备好学习大量新知识 😃。

当然，这个列表绝非详尽无遗。这些只是我多年来积累并发现对自己有用的链接。如果你想要添加任何内容，请告诉我！

> 注意：这里的许多链接都是博客文章，请务必查看这些博客中的其他文章！即使与主题无直接关系，它们通常也是值得阅读的。

* * *

## 调试器的工作方式

所有调试器都共享相同的基本原理：它们需要附加到一个进程，解析二进制和调试信息，处理断点等。虽然在操作系统之间的实现可能有显著差异，但是一旦你理解了其中一个，其他的看起来会非常熟悉。

+   **编写 Linux 调试器**

    +   [https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/](https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/)

    +   一个从头开始编写 Linux 调试器的 10 部分旅程。你将学习到 `ptrace` 的基础知识，断点是如何工作的，如何将源代码映射到机器代码，以及如何展开堆栈。强烈建议从这篇开始，如果你想学习基础知识。

+   **从头开始编写调试器**

+   **C 调试器是如何工作的？（GDB Ptrace/x86 示例）**

+   **与本地调试有关**

+   **工程记录和回放以实现可部署性**（又名“`rr` 是如何工作的？”）

+   **在 LLDB 中实现实时反向调试**

    +   [https://arxiv.org/abs/2105.12819](https://arxiv.org/abs/2105.12819)

    +   有关 LLDB 中反向调试实现的详细论文。提供了各种选项及其权衡，详细解释了 LLDB 所选择的方法。

+   **gdb 如何调用函数？**

## 栈展开

生成调用堆栈是最基本的调试器功能之一，但远非简单。为了理解它的工作原理，你需要了解帧指针、调用帧信息（CFI）、DWARF 表达式以及许多其他内容。以下是一些详细探讨这个主题的文章。

+   **费力地展开堆栈**

+   **栈展开**

+   **苹果紧凑展开格式：文档化与解释**

+   **使用帧指针和 ORC 手动展开堆栈**

+   **基于 DWARF 的使用 eBPF 进行堆栈遍历**

## 随机调试器琐事

我已经放弃分类，所以将剩余部分归类为“随机琐事”。

+   **我的变量去哪了？挖掘不完整调试信息的漏洞**

+   **将调试符号与可执行文件分离**

+   **调试器的谎言：堆栈损坏**

+   **一切都坏了：在 Mozilla 发布 rust-minidump**

+   **用于尴尬和崩溃的 Rust-minidump 模糊测试**

+   **在 Rust 中的崩溃报告**

+   **所以你想要实时重新加载 Rust**

## 一般有用的知识

+   **链接器**

+   **模具的设计与实现**

+   **Linux 系统调用的权威指南**

+   **Linux 内核中的系统调用**

* * *

讨论本文：
