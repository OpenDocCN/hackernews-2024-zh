- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-27 15:06:28'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 15:06:28
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: From Fill Prefix to TRAMP - Susam Pal
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从填充前缀到 TRAMP - Susam Pal
- en: 来源：[https://susam.net/from-fill-prefix-to-tramp.html](https://susam.net/from-fill-prefix-to-tramp.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://susam.net/from-fill-prefix-to-tramp.html](https://susam.net/from-fill-prefix-to-tramp.html)
- en: <main>
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: <main>
- en: From Fill Prefix to TRAMP
  id: totrans-split-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从填充前缀到 TRAMP
- en: By **Susam Pal** on 30 Dec 2023
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由 **Susam Pal** 于 2023 年 12 月 30 日撰写
- en: Our [tiny book club](cc/mastering-emacs/) that used to meet during the weekends
    and holidays and discuss the book [Mastering Emacs](https://www.masteringemacs.org/),
    2022 edition concluded today. In our [final meeting](cc/mastering-emacs/log.html#72)
    today, we first discussed how to work across multiple directories in the same
    Dired buffer. Then we did several demos of the various shells and terminal modes
    available in Emacs out of the box. That completed our discussion on Chapter 6\.
    Then we moved on to Chapter 7 (the final chapter) that first reiterates the importance
    of using the describe-system to ask Emacs questions about itself and then offers
    some recommendations about third-party packages and online Emacs communities.
    Completing this chapter brought our book club discussions to an end.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 [小型书籍俱乐部](cc/mastering-emacs/) 通常在周末和假期聚会，并讨论书籍 [Mastering Emacs](https://www.masteringemacs.org/)，2022
    年版今天结束了。在今天的 [最后一次会议](cc/mastering-emacs/log.html#72) 中，我们首先讨论了如何在同一个 Dired 缓冲区中跨多个目录工作。然后我们演示了
    Emacs 自带的各种 Shell 和终端模式。这完成了我们对第 6 章的讨论。然后我们转向第 7 章（最后一章），首先重申了使用 describe-system
    向 Emacs 提问其自身的重要性，然后提出了关于第三方包和在线 Emacs 社区的一些建议。完成这一章也结束了我们的书籍俱乐部讨论。
- en: A big thanks to Mickey Petersen for writing the book and also very generously
    granting me the permission to share his book on screen while discussing it.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢 Mickey Petersen 写了这本书，并且在我们讨论时非常慷慨地允许我分享他的书籍。
- en: This book club began on 16 Dec 2022 when we had our first meeting over Jitsi.
    About 3&half; months after beginning these meetings, I posted an update about
    this book club in another blog post titled [From Lunar Phases to Yank-Pop](from-lunar-phases-to-yank-pop.html).
    If you have not read that post yet, I suggest you read it before returning to
    this post. Especially if you have recently begun learning Emacs, I think you will
    find that post useful.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个读书俱乐部始于 2022 年 12 月 16 日，当时我们在 Jitsi 上举行了第一次会议。开始这些会议大约 3 个半月后，我在另一篇名为 [从月相到摇摇晃晃](from-lunar-phases-to-yank-pop.html)
    的博文中发布了关于这个书籍俱乐部的更新。如果你还没有阅读过那篇博文，我建议你在回到这篇文章之前先阅读一下。特别是如果你最近开始学习 Emacs，我认为你会发现那篇文章很有用。
- en: Back then, when I posted that last update, we had spent about 26 hours together
    across 36 meetings and we were reading Chapter 5 of the book. It took another
    36 meetings to complete that chapter and the remaining two chapters. After a total
    of 72 meetings, we completed discussing Chapter 7 of the book today which concluded
    this series of book club meetings. In total, we have spent a little over 52 hours
    together to discuss this book, trying out every concept and command introduced
    in the book, and sharing our insights about the material with each other.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我发布最后一次更新时，我们一共在 36 次会议中共同度过了约 26 小时，当时我们正在阅读这本书的第 5 章。完成这一章节和剩下的两章共计 36 次会议。在总共
    72 次会议后，我们今天完成了讨论该书第 7 章，这也结束了这一系列书籍俱乐部会议。总计，我们共度过了略多于 52 小时来讨论这本书，尝试了书中介绍的每一个概念和命令，并与彼此分享了对材料的见解。
- en: In this post, I will share some highlights from our meetings since the [last
    update](from-lunar-phases-to-yank-pop.html). These highlights share some concepts
    and commands we learnt that most members of our book club were not familiar with
    earlier but were found to be very useful after having learnt them.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我将分享自上次更新以来我们会议的一些亮点。这些亮点分享了我们学习到的一些概念和命令，这些概念和命令大多数我们的书籍俱乐部成员之前并不熟悉，但在学习后发现非常有用。
- en: Contents
  id: totrans-split-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录
- en: Fill Prefix
  id: totrans-split-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充前缀
- en: 'Most of us in the book discussion group knew about filling paragraphs with
    `M-q`. Consider the following badly formatted paragraphs with very long and very
    short lines:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们书籍讨论小组中的大多数人都知道如何使用 `M-q` 来填充段落。考虑以下格式混乱、行长短不一的段落：
- en: '[PRE0]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now put the point (cursor) anywhere on the paragraph and type `M-q`. The paragraph
    gets neatly formatted to something like this:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将光标放在段落的任何位置，然后键入 `M-q`。 段落将被整齐地格式化为以下内容：
- en: '[PRE1]'
  id: totrans-split-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The key sequence `M-q` invokes the `fill-paragraph` command that reformats
    the paragraph such that each line is as long as possible without exceeding the
    fill width (70 columns by default). Most of us already used this command very
    often while writing and editing text. However what some of us did not know was
    that there is such a thing as fill prefix which is taken into account while filling
    paragraphs. To illustrate this concept, we will first consider this badly formatted
    paragraph:'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 键序列 `M-q` 调用 `fill-paragraph` 命令，重新格式化段落，使每行尽可能长，但不超过填充宽度（默认为70列）。我们中的大多数人在写作和编辑文本时经常使用此命令。但是，一些人不知道的是在填充段落时会考虑填充前缀的存在。为了说明这个概念，我们首先考虑这个格式不良的段落：
- en: '[PRE2]'
  id: totrans-split-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each line has a prefix consisting of four colons and a space. After we reformat
    this paragraph with `M-q`, we get something like this:'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每行都有一个由四个冒号和一个空格组成的前缀。使用 `M-q` 重新格式化这个段落后，我们得到类似这样的结果：
- en: '[PRE3]'
  id: totrans-split-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is not what we want. We want the paragraph to be formatted such that each
    line does not exceed 70 characters in length (which we have, in fact, accomplished
    above) and each line contains the four colons and a space as the prefix (this
    is broken above). Can we do this? Yes, by setting the fill prefix. Type `C-/`
    or `C-x u` to undo the bad formatting we did just now and let us try again. This
    time move the point over to the `L` of `Lorem` and type `C-x .` to set the fill
    prefix to the current line up to the point. A confirmation is printed in the echo
    area that `":::: "` has been set as the fill prefix. Then type `M-q` and the paragraph
    is now neatly formatted to look like this:'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: '这不是我们想要的。我们希望段落的格式不要超过70个字符的长度（事实上，我们已经做到了），每一行都包含四个冒号和一个空格作为前缀（上面的格式已经破碎了）。我们能做到吗？可以，通过设置填充前缀。键入
    `C-/` 或 `C-x u` 来撤消刚才做的不良格式化，并让我们再试一次。这次将光标移动到 `Lorem` 的 `L` 上，键入 `C-x .` 来设置填充前缀为当前行直到光标的内容。确认消息会在回显区打印，告知
    `":::: "` 已被设置为填充前缀。然后键入 `M-q`，段落现在整齐地格式化如下：'
- en: '[PRE4]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how every line is as long as possible without exceeding 70 characters in
    length and each line has the fill prefix. Emacs took care to remove the fill prefix
    from each line, subtract the length of the fill prefix from the maximum character
    budget it has for each line, reformat the lines, and then reinsert the fill prefix
    on each line of the result.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每行尽可能长，但不超过70个字符的长度，并且每行都有填充前缀。Emacs 负责从结果的每一行中移除填充前缀，从每行的最大字符预算中减去填充前缀的长度，重新格式化行，并在结果的每一行上重新插入填充前缀。
- en: To turn off the fill prefix, simply set it to an empty prefix by typing `C-x
    .` at the beginning of the line. Thus `C-a C-x .` becomes an idiom for turning
    off the fill prefix.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭填充前缀，只需将其设置为空前缀，通过在行首键入 `C-x .`。因此 `C-a C-x .` 成为关闭填充前缀的惯用语。
- en: Elisp Expressions in Replacement Strings
  id: totrans-split-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换字符串中的 Elisp 表达式
- en: It was no surprise to anyone in the book discussion group that the key sequence
    `C-M-% f.. RET bar RET` starts a search-and-replace operation for strings that
    match the regular expression pattern `f..` to be replaced with the text `bar`.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 书讨论小组中没有人会对键序列 `C-M-% f.. RET bar RET` 开始的搜索和替换操作感到意外，该操作用于将与正则表达式模式 `f..` 匹配的字符串替换为文本
    `bar`。
- en: The concept of backreferences was also known to most. For example, `C-M-% \(f..\)-\(b..\)
    RET \2-\1 RET` searches for strings matching the given regular expression pattern
    and replaces it with a new string that swaps the positions of the first capturing
    group and the second capturing group. The backreference `\1` refers to the string
    matched by the first capturing group `\(f..\)` and similarly `\2` refers to the
    string matched by the second capturing group `\(b..\)`. In this example, a string
    like `foo-bar` is replaced with `bar-foo`, or `playful-banter` with `playban-fulter`.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人也知道反向引用的概念。例如，`C-M-% \(f..\)-\(b..\) RET \2-\1 RET` 搜索与给定正则表达式模式匹配的字符串，并用新字符串替换它，交换第一个捕获组和第二个捕获组的位置。反向引用
    `\1` 指的是第一个捕获组 `\(f..\)` 匹配的字符串，类似地 `\2` 指的是第二个捕获组 `\(b..\) `匹配的字符串。在这个例子中，像 `foo-bar`
    将被替换为 `bar-foo`，或者 `playful-banter` 将被替换为 `playban-fulter`。
- en: However what came as a surprise to some of us was that we could also use Elisp
    expressions in the replacement strings. The syntax to do so is to write `\,` followed
    by the Elisp expression in the replacement string. For example, consider the key
    sequence `C-M-% f.. RET \,(upcase \&) RET`. Note how we are using the backreference
    `\&` that refers to the whole match as the argument to the Elisp function `upcase`
    that converts its argument to upper-case. This example searches for strings that
    match the pattern `f..` and replaces them with the upper-case form of the match.
    A string like `foo-bar` is replaced with `FOO-bar`.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，令我们一些人感到惊讶的是，我们还可以在替换字符串中使用 Elisp 表达式。这样做的语法是在替换字符串中写入 `\,`，然后跟随替换字符串中的 Elisp
    表达式。例如，考虑键序列 `C-M-% f.. RET \,(upcase \&) RET`。请注意，我们使用了反向引用 `\&`，它将整个匹配作为参数传递给
    Elisp 函数 `upcase`，将其转换为大写形式。这个示例搜索与模式 `f..` 匹配的字符串，并用匹配项的大写形式替换它。例如，字符串 `foo-bar`
    将被替换为 `FOO-bar`。
- en: 'Here is another slightly more sophisticated example: `C-M-% port-\([0-9]+\)
    RET port-\,(+ 1000 \#1)`. The backreference `\#1` refers to the string matched
    by the first capturing group `\([0-9]+\)` as *number*. The Elisp expression in
    the replacement pattern simply adds 1000 to that number and replaces the matched
    string with the result. A string like `port-80` becomes `port-1080`.'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个稍微复杂一些的示例：`C-M-% port-\([0-9]+\) RET port-\,(+ 1000 \#1)`。反向引用 `\#1` 指的是第一个捕获组
    `\([0-9]+\)` 匹配的字符串作为*数字*。替换模式中的 Elisp 表达式简单地将1000添加到该数字，并用结果替换匹配的字符串。例如，字符串 `port-80`
    变成 `port-1080`。
- en: Keep Lines and Flush Lines
  id: totrans-split-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留行和清除行
- en: 'A nifty set of commands that our group members enjoyed learning were the commands
    for keeping and flushing lines. These commands can be incredibly useful while
    filtering large log files. Here is a brief illustration of a couple of these commands:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们小组成员喜欢学习的一组巧妙的命令是保留和清除行的命令。在过滤大型日志文件时，这些命令非常有用。以下是这些命令的简要说明：
- en: '`M-x keep-lines RET f.. RET`: Keep lines in region that match the regular expression
    `f..` and delete the rest. If no region is active, then keep matching lines between
    the point and end of buffer, and delete the rest. The deleted lines are not copied
    to kill ring.'
  id: totrans-split-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M-x keep-lines RET f.. RET`: 保留区域内与正则表达式 `f..` 匹配的行，删除其余行。如果没有活动区域，则保留指针和缓冲区末尾之间匹配的行，并删除其余行。删除的行不会复制到
    kill ring。'
- en: '`M-x flush-lines RET f.. RET`: Delete lines in the region that match the regular
    expression `f..`. If no region is active, then delete matching lines between the
    point and end of buffer. The deleted lines are not copied to kill ring.'
  id: totrans-split-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M-x flush-lines RET f.. RET`: 删除区域内与正则表达式 `f..` 匹配的行。如果没有活动区域，则删除指针和缓冲区末尾之间匹配的行。删除的行不会复制到
    kill ring 中。'
- en: 'Note how each point above mentions that the deleted lines are not copied to
    the kill ring. This can be an inconvenience if we want to quickly yank the deleted
    lines to another buffer. Emacs 28.1 introduces a couple of more commands that
    remedy this situation to an extent. Here they are:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上述每个要点都提到删除的行不会复制到 kill ring 中。如果我们想快速将删除的行粘贴到另一个缓冲区，这可能有些不便。Emacs 28.1 引入了一些更多命令，在一定程度上解决了这种情况。以下是这些命令：
- en: '`M-x copy-matching-lines RET f.. RET`: Copy lines in the region that match
    the regular expression `f..`. If no region is active, then copy matching lines
    between the point and end of buffer.'
  id: totrans-split-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M-x copy-matching-lines RET f.. RET`: 复制区域内与正则表达式 `f..` 匹配的行。如果没有活动区域，则复制指针和缓冲区末尾之间匹配的行。'
- en: '`M-x kill-matching-lines RET f.. RET`: Kill lines in region that match the
    regular expression `f..` to the kill ring. If no region is active, then kill matching
    lines between the point and end of buffer.'
  id: totrans-split-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M-x kill-matching-lines RET f.. RET`: 删除区域内与正则表达式 `f..` 匹配的行到 kill ring 中。如果没有活动区域，则删除指针和缓冲区末尾之间匹配的行。'
- en: Keyboard Macros
  id: totrans-split-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键盘宏
- en: Most experienced Emacs users in our group were aware of keyboard macros. However,
    some people did learn this wonderful automation feature for the first time in
    our meetings, so I thought this deserves its own section in this post.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们小组中大多数有经验的 Emacs 用户都知道键盘宏。然而，一些人在我们的会议中第一次了解到这一优秀的自动化功能，因此我认为这在本文中值得单独一节。
- en: 'Keyboard macros is a large topic on its own which is best learnt from section
    [Keyboard Macros](https://www.gnu.org/software/emacs/manual/html_node/emacs/Keyboard-Macros.html)
    of the manual. On Emacs, type `M-: (info "(emacs) Keyboard Macros") RET` to open
    this section using the Info documentation browser. In this blog post though, we
    will very briefly talk about keyboard macros that should be enough to get someone
    very new to it started with them quickly.'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: '键盘宏是一个庞大的主题，最好从手册中的[键盘宏](https://www.gnu.org/software/emacs/manual/html_node/emacs/Keyboard-Macros.html)部分学习。在
    Emacs 中，键入 `M-: (info "(emacs) Keyboard Macros") RET` 来使用 Info 文档浏览器打开此部分。在本博文中，我们将简要讨论足以让初学者快速入门的键盘宏。'
- en: 'Say, we have a buffer that looks like this:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个如下所示的缓冲区：
- en: '[PRE5]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now suppose we want to swap the first two fields separated by colon in each
    line. Of course, we could do it using regular expressions, for example, with the
    key sequence `C-M-% ^\(.+?:\)\(.+?:\) RET \2\1 RET`. But we can also solve this
    problem in a "dumb" way by simply performing the edits necessary to do the swap
    on one line and then asking Emacs to repeat what we did on the other lines. Here
    are the steps:'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要交换每行中由冒号分隔的前两个字段。当然，我们可以使用正则表达式来完成，例如使用键序列 `C-M-% ^\(.+?:\)\(.+?:\)
    RET \2\1 RET`。但我们也可以通过简单地对一行执行必要的编辑来解决这个问题。然后要求 Emacs 在其他行上重复我们所做的。以下是步骤：
- en: First move the point to somewhere on the first line.
  id: totrans-split-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将光标移动到第一行的某处。
- en: Then type `C-x (` to start recording a keyboard macro.
  id: totrans-split-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后输入 `C-x (` 开始录制键盘宏。
- en: 'Then type `C-a M-d C-d M-f : C-y C-n` to swap the first and second fields on
    the first line and move the point to the next line. This is just one way to achieve
    the swap. You may use any editing commands you are comfortable with to make the
    swap happen and move the point to the next line.'
  id: totrans-split-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后输入 `C-a M-d C-d M-f : C-y C-n` 来交换第一行的第一个和第二个字段，并将光标移动到下一行。这只是实现交换的一种方式。您可以使用任何您熟悉的编辑命令来进行交换并移动光标到下一行。'
- en: Now type `C-x )` to stop macro recording.
  id: totrans-split-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入 `C-x )` 来停止宏录制。
- en: Now type `C-x e` to replay the macro in the second line. As soon as we type
    this key sequence, the swap occurs in the second line and the cursor moves to
    the third line. Keep repeating this key sequence to keep repeating the swap operation
    on subsequent lines.
  id: totrans-split-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入 `C-x e` 来在第二行重放宏。一旦我们键入此键序列，第二行中的交换就会发生，光标移动到第三行。重复此键序列以在后续行上重复交换操作。
- en: To summarise, `C-x (` starts recording a new keyboard macro, `C-x )` stops recording
    the keyboard macro, and `C-x e` replays the last keyboard macro. Alternatively,
    we could also use the function keys `F3` and `F4`. To start recording a keyboard
    macro, type `F3`. Type `F4` to stop recording a keyboard macro. Then type `F4`
    again to replay the last macro.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`C-x (` 开始录制新的键盘宏，`C-x )` 停止录制键盘宏，`C-x e` 重放最后一个键盘宏。或者，我们还可以使用功能键 `F3`
    和 `F4`。要开始录制键盘宏，请键入 `F3`。键入 `F4` 来停止录制键盘宏。然后再次键入 `F4` 来重放最后一个宏。
- en: Pay close attention to step 3 above. We start the key sequence with `C-a` to
    move the point to the first column. This may feel redundant when the cursor is
    already at the first column. However in our meetings, I used to emphasise often
    about the importance of doing this. Typing `C-a` at the beginning ensures that
    we do not carry over any assumption about where the cursor is on the line into
    the rest of the keyboard macro definition we are going to record. By typing `C-a`,
    we ensure that no matter where the cursor is on the line, when we replay the macro,
    the cursor would first move to the beginning of the line. This guarantee allows
    us to confidently define the rest of the editing operations necessary to perform
    the swap.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意上述步骤 3。我们以 `C-a` 开始键序列，将光标移动到第一列。当光标已经位于第一列时，这可能会感觉多余。然而，在我们的会议中，我经常强调这一点的重要性。在定义要记录的键盘宏的其余部分时，键入
    `C-a` 确保我们不会带入任何关于光标位置的假设。通过键入 `C-a`，我们确保无论光标位于行的何处，当我们重放宏时，光标首先会移动到行的开头。这一保证使我们能够自信地定义执行交换所需的其余编辑操作。
- en: Similarly, at the end we type `C-n` to move the point to the next line. I used
    to emphasise the importance of doing this too in our meetings. Moving the cursor
    to the next line ensures that the cursor is in a good place to allow repeating
    the keyboard macro again immediately. This is why we could type `C-x e` (or alternatively,
    `F4`) over and over again to replay the macro on subsequent lines. In fact, if
    we feel confident about the keyboard macro, we can repeat it several times automatically
    using the digit argument. For example, type `C-3 C-x e` (or alternatively `C-3
    F4`) to repeat the keyboard macro 3 times. We could also type `C-0 C-x e` (or
    alternatively `C-0 F4`) to repeat the keyboard macro until there is an error (e.g.,
    reaching the end of the buffer).
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，最后我们输入`C-n`将光标移动到下一行。在我们的会议中，我曾强调过这样做的重要性。将光标移动到下一行可以确保光标处于一个良好的位置，以便立即再次重复键盘宏。这就是为什么我们可以一遍又一遍地输入`C-x
    e`（或者`F4`）来重放宏。实际上，如果我们对键盘宏感到自信，我们可以使用数字参数自动重复执行多次。例如，输入`C-3 C-x e`（或者`C-3 F4`）来重复执行键盘宏3次。我们也可以输入`C-0
    C-x e`（或者`C-0 F4`）来重复执行键盘宏，直到出现错误（例如，达到缓冲区末尾）。
- en: DAbbrev
  id: totrans-split-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DAbbrev
- en: 'DAbbrev stands for *dynamic abbrevation*. This is a pretty useful package that
    many of us learnt only from our book club meetings. We discussed two simple key
    sequences supported by this package:'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: DAbbrev 代表*dynamic abbrevation*。这是一个非常有用的包，我们中的许多人只是从我们的书籍俱乐部会议中了解到它。我们讨论了这个包支持的两个简单的键序列：
- en: '`M-/`: Expand the word before the point to the nearest preceding word for which
    the current word is a prefix. If no suitable preceding word is found, then expand
    the current word to the nearest succeeding word for which the current word is
    a prefix.'
  id: totrans-split-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M-/`: 将光标前的单词扩展到最近的前导词，其中当前单词是前缀。如果找不到合适的前导词，则将当前单词扩展到最近的后继单词，其中当前单词是前缀。'
- en: '`C-M-/`: Find all words in the buffer that has the current word before the
    cursor as the prefix and expand the current word to the longest common prefix
    of all these matching words. However, if the longest common prefix of the matching
    words is same as the word before the cursor, then present them as suggestions
    for completion. If there is exactly one matching word, expand the word before
    the cursor to that word.'
  id: totrans-split-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C-M-/`: 查找缓冲区中所有具有光标前的当前单词作为前缀的单词，并将当前单词扩展到所有这些匹配单词的最长公共前缀。然而，如果匹配单词的最长公共前缀与光标前的单词相同，则将它们作为完成建议呈现。如果只有一个匹配单词，则将光标前的单词扩展为该单词。'
- en: 'Let us look at some examples. Suppose there is a buffer with the following
    one line of text:'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子。假设缓冲区中有以下一行文本：
- en: '[PRE6]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now if we type `ap` on the next line and type `M-/`, DAbbrev automatically expands
    the partially written word to `application` because that is the nearest word that
    has `ap` as the prefix.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在下一行输入`ap`并键入`M-/`，DAbbrev 将自动将部分输入的单词扩展为`application`，因为这是具有`ap`前缀的最近单词。
- en: But if we type `ap` and type `C-M-/`, the word expands to `appl` since that
    is the longest common prefix among all the matching words. If we type `C-M-/`
    again, then `apple`, `appliance`, and `application` are presented as possible
    completions in a temporary buffer named `*Completions*`. If we type `ic`, so that
    the word before the cursor becomes `applic`, and type `C-M-/`, it is expanded
    to `application` because that is the only possible completion now.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们输入`ap`并键入`C-M-/`，则该单词扩展为`appl`，因为这是所有匹配单词中的最长公共前缀。如果我们再次键入`C-M-/`，则`apple`、`appliance`和`application`将作为可能的完成选项出现在名为`*Completions*`的临时缓冲区中。如果我们输入`ic`，使光标前的单词变为`applic`，然后键入`C-M-/`，它将扩展为`application`，因为现在这是唯一可能的完成选项。
- en: These two commands are simpler than it sounds from the verbose descriptions
    of these commands presented in the above paragraphs. When we actually begin to
    use them, they become intuitive in no time. Roughly speaking, while `M-/` expands
    the word before the point to the nearest preceding word, `C-M-/` considers all
    matching words in the file for expansion and presents completion options to the
    user when it finds multiple of them.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令比上面段落中详细描述的内容听起来简单得多。当我们实际开始使用它们时，它们会立即变得直观。粗略地说，`M-/` 将扩展到光标前的最近的前导词，`C-M-/`
    则会考虑文件中所有匹配的单词进行扩展，并在发现多个匹配时向用户呈现完成选项。
- en: TAB vs M-i
  id: totrans-split-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TAB vs M-i
- en: The behaviour of Emacs when we type `TAB` can be surprising to beginners. In
    most other mainstream editors, this key either inserts a tab character or it inserts
    enough number of spaces so that the cursor moves to the next tab stop. But in
    Emacs, `TAB` most often indents the current line according to the syntax rules
    implemented by the major mode enabled in the buffer.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Emacs 中键入 `TAB` 键时，它的行为对初学者来说可能会令人惊讶。在大多数其他主流编辑器中，该键要么插入一个制表符字符，要么插入足够数量的空格，以便将光标移动到下一个制表位。但在
    Emacs 中，`TAB` 键大多数情况下根据缓冲区中启用的主要模式实现的语法规则对当前行进行缩进。
- en: What is a simple key on other editors happens to be a complex feature in Emacs.
    The exact behaviour of `TAB` is controlled by variables like `tab-always-indent`,
    `indent-line-function`, etc. Some major modes may refer to other such special
    variables to decide what `TAB` should do. However, as a user of Emacs this is
    not something we normally have to worry about. Most major modes set up all these
    variables appropriately, so that `TAB` almost always does what an experienced
    Emacs user expects, i.e., indent the current line of code correctly.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编辑器上是一个简单的键，在 Emacs 中却是一个复杂的功能。`TAB` 的确切行为由诸如 `tab-always-indent`、`indent-line-function`
    等变量控制。某些主要模式可能会参考其他类似的特殊变量来决定 `TAB` 的操作。然而，作为 Emacs 的用户，这并不是我们通常需要担心的事情。大多数主要模式适当设置所有这些变量，以便
    `TAB` 几乎总是按照经验丰富的 Emacs 用户的期望行为，即正确缩进当前行的代码。
- en: But what if we really do want to just insert a tab or enough number of spaces
    to move the point to the next tab stop column? That is done with `M-i`. If the
    variable `indent-tabs-mode` is set to `t`, then `M-i` inserts a literal tab character.
    If it is set to `nil`, then `M-i` inserts enough number of spaces to move the
    point to the next tab stop column.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们真的只想插入一个制表符或足够数量的空格以将光标移动到下一个制表位列中，该怎么办？这可以通过按下 `M-i` 来实现。如果变量 `indent-tabs-mode`
    设置为 `t`，那么 `M-i` 将插入一个字面上的制表符字符。如果设置为 `nil`，那么 `M-i` 将插入足够数量的空格，以将光标移动到下一个制表位列中。
- en: To summarise, the behaviour of `M-i` is similar to the `TAB` behaviour we observe
    in other editors. In practice though, the key sequence `M-i` is rarely required.
    Most people just type `TAB` to automatically indent code. In fact, we can also
    select a region of code and type `TAB` to reindent the whole region.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`M-i` 的行为类似于我们在其他编辑器中观察到的 `TAB` 行为。但实际上，在实践中，很少需要使用键序列 `M-i`。大多数人只需键入 `TAB`
    即可自动缩进代码。事实上，我们也可以选择代码区域，然后键入 `TAB` 来重新缩进整个区域。
- en: Project Management
  id: totrans-split-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目管理
- en: The project management commands that come out of the box (from the package named
    `project.el`) came as a surprise to some. In fact, some members of our group who
    never used the project management commands earlier happen to use them regularly
    now after learning about them in our meetings.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 出自名为 `project.el` 的包的默认项目管理命令使一些人感到惊讶。事实上，我们组中一些之前从未使用过项目管理命令的成员，现在在我们的会议中学习到它们后经常使用它们。
- en: When we use a project command like `C-x p f` to visit a file in the current
    project, the command automatically detects the top-level directory of the project
    by checking parent directories for version control system artefacts (e.g., `.git`
    directory) and presents files within that top-level directory as autocomplete
    options.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用类似 `C-x p f` 的项目命令来访问当前项目中的文件时，该命令会自动检测项目的顶级目录，方法是检查父目录中的版本控制系统工件（例如 `.git`
    目录），并在该顶级目录中显示文件作为自动完成选项。
- en: 'There is a lot that can be written about the project management features that
    come out of the box in Emacs. The following list introduces only the very simple
    ones to get someone started with them:'
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Emacs 默认提供的项目管理功能，可以写很多东西。以下列表仅介绍了一些非常简单的功能，以便让初学者开始使用：
- en: '`C-x p f logger RET`: Find file with name that matches `logger` in the current
    project. This searches all subdirectories recursively. If there is only one matching
    file (say, `src/logger.cc`), that file is opened. If there are multiple matching
    files, they are presented as completion options. Running this command or, in fact,
    running any project command leads to discovering the current project and adding
    an entry for the discovered project to `~/.emacs.d/projects`. This is useful for
    a command like the one presented in the next point.'
  id: totrans-split-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C-x p f logger RET`：在当前项目中查找与 `logger` 匹配的文件。这会递归搜索所有子目录。如果只有一个匹配的文件（例如 `src/logger.cc`），则打开该文件。如果有多个匹配文件，则它们作为完成选项呈现。运行此命令或者事实上运行任何项目命令都会发现当前项目，并将发现的项目条目添加到
    `~/.emacs.d/projects`。这对于像下一个点中提到的命令非常有用。'
- en: '`C-x p f foo TAB RET logger TAB RET`: When we type `C-x p f` while visiting
    a file that does not belong to any project, then its prompts for a project path
    first. In this example, we type `foo TAB RET` to automatically expand it to a
    known project path such as `~/git/foo/` and enter it. Then we type `logger TAB
    RET` to automatically expand it to a file name such as `src/logger.cc` and visit
    it.'
  id: totrans-split-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C-x p f foo TAB RET logger TAB RET`：当我们在访问不属于任何项目的文件时键入`C-x p f`，它首先提示输入项目路径。在这个例子中，我们输入`foo
    TAB RET`来自动扩展到已知的项目路径，如`~/git/foo/`并进入其中。然后，我们输入`logger TAB RET`来自动扩展到文件名，如`src/logger.cc`并访问它。'
- en: '`C-x p p bar TAB RET f logger TAB RET`: Say we are in project `~/git/foo/`
    but we want to switch to another previously discovered project `~/git/bar/` and
    find a file there. To do so, we first type `C-x p p` to switch project. At the
    project selection prompt, we type `bar TAB` to automatically complete the directory
    path of the known project `~/git/bar/`. Then another prompt is presented to choose
    an action from a number of actions. In this case, we type `f` to find a file in
    the project we have switched to. Finally, we type `logger TAB RET` to automatically
    expand the partially entered name to a path like `src/logger.cc` and visit it.
    The key sequence `C-x p p` is very useful when the current file belongs to one
    project but we want to run a project command on another project.'
  id: totrans-split-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C-x p p bar TAB RET f logger TAB RET`：假设我们在项目`~/git/foo/`中，但我们想要切换到另一个先前发现的项目`~/git/bar/`并在那里找到一个文件。为此，我们首先输入`C-x
    p p`来切换项目。在项目选择提示符处，我们输入`bar TAB`来自动完成已知项目`~/git/bar/`的目录路径。然后，另一个提示出现以选择多个操作中的一个。在这种情况下，我们输入`f`来在我们切换到的项目中查找文件。最后，我们输入`logger
    TAB RET`来自动扩展部分输入的名称到路径，例如`src/logger.cc`并访问它。当当前文件属于一个项目但我们想要在另一个项目上运行项目命令时，关键序列`C-x
    p p`非常有用。'
- en: '`C-x p p ... RET ~/git/baz/ RET f logger TAB RET`: This awkward key sequence
    discovers a new project directory at `~/git/baz/` and then finds a file in it.
    The key sequence `C-x p p ... RET` is rarely required though. See the notes after
    the end of this list to read why.'
  id: totrans-split-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C-x p p ... RET ~/git/baz/ RET f logger TAB RET`：这个奇怪的键序列发现了一个位于`~/git/baz/`的新项目目录，然后在其中找到一个文件。尽管如此，关键序列`C-x
    p p ... RET`很少需要。请参阅列表结束后的注释以了解原因。'
- en: '`C-x p g ^key\> RET`: Find all matches for the regular expression `^key\>`
    in the current project. The results are displayed in `*xref*` buffer.'
  id: totrans-split-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C-x p g ^key\> RET`：在当前项目中查找正则表达式`^key\>`的所有匹配项。结果显示在`*xref*`缓冲区中。'
- en: '`C-x p s`: Start a shell in the current project''s root directory.'
  id: totrans-split-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C-x p s`：在当前项目的根目录中启动shell。'
- en: '`C-x p d`: Start Dired in the current project''s root directory.'
  id: totrans-split-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C-x p d`：在当前项目的根目录中启动Dired。'
- en: '`C-x p k yes RET`: Kill all buffers belonging to the current project.'
  id: totrans-split-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C-x p k yes RET`：关闭属于当前项目的所有缓冲区。'
- en: There are several more project commands but we will end the above list here
    for the sake of brevity. Do pay attention to the second point that mentions that
    if the current file does not belong to any project, we are first prompted to enter
    the project name. This is a common theme for all project commands. Anytime we
    invoke a project command, it works on the current project. However if there is
    no current project, then it automatically prompts us to enter a project name before
    executing the command.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们将以上项目命令列表到此为止。请注意第二点，即如果当前文件不属于任何项目，我们首先被提示输入项目名称。这是所有项目命令的共同主题。每当我们调用项目命令时，它会在当前项目上执行。但是，如果没有当前项目，则会自动提示我们输入项目名称以执行命令。
- en: The key sequence `C-x p p ... RET` is very rarely required during day-to-day
    editing activities. Once a project has been discovered (say, due to having run
    a project command on that project earlier) and added to the list of known projects
    at `~/.emacs.d/projects`, we never have to discover it again. We can use the other
    key sequences to switch to or work on a known project. Most day-to-day project
    activities involve working on known projects.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`C-x p p ... RET` 这个关键序列在日常编辑活动中很少需要。一旦一个项目被发现（例如因为早些时候在该项目上运行了一个项目命令并将其添加到`~/.emacs.d/projects`的已知项目列表中），我们就不需要再次发现它了。我们可以使用其他键序列来切换或处理已知项目。大多数日常项目活动涉及处理已知项目。'
- en: Further, even when we do want to discover a new project and add it to the list
    of known projects, a much more natural way to do it is to run a project command
    while we are visiting a file in the project directory. In most cases, we already
    have a file from some project open in the current buffer. Therefore it makes more
    sense to just go ahead with a project command, say, with `C-x p f`, `C-x p g`,
    etc. directly instead of explicitly discovering the project with `C-x p p ...
    RET`. Merely running a project command while we have a file from a project open
    ends up discovering the current project automatically. Explicitly discovering
    projects with `C-x p p ... RET` is almost never necessary.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使我们想要发现一个新项目并将其添加到已知项目列表中，更自然的方法是在访问项目目录中的文件时运行项目命令。在大多数情况下，我们已经在当前缓冲区中打开了某个项目的文件。因此，直接运行项目命令，比如
    `C-x p f`、`C-x p g` 等，而不是显式地通过 `C-x p p ... RET` 发现项目更有意义。仅仅在打开了某个项目文件时运行项目命令就会自动发现当前项目。几乎从不需要显式通过
    `C-x p p ... RET` 发现项目。
- en: Eshell with TRAMP
  id: totrans-split-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eshell 与 TRAMP
- en: 'Many members of our group knew about Eshell and TRAMP separately. For example,
    `M-x eshell RET` starts Eshell. Eshell is implemented purely in Elisp and we can
    use it much like a regular shell. Here is an example session:'
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们团队中的许多成员分别了解了 Eshell 和 TRAMP。例如，`M-x eshell RET` 启动 Eshell。Eshell 完全使用 Elisp
    实现，我们可以像使用常规 shell 一样使用它。以下是一个示例会话：
- en: '[PRE7]'
  id: totrans-split-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We also knew about TRAMP. For example, when we type the key sequence `C-x C-f
    /ssh:alice@box:/tmp/foo.txt RET`, TRAMP notices that we intend to connect to a
    remote system named `box` as the user `alice` via SSH and edit a file named `/tmp/foo.txt`
    on the remote system. TRAMP then transparently establishes the SSH connection
    for us. If public key authentication is already set up, then the connection is
    successfully established immediately. Otherwise it prompts for a password. In
    the end, we get a buffer to edit the remote file `/tmp/foo.txt`. Once we have
    this buffer, we never have to do anything special to work on the remote file.
    All Emacs commands work seamlessly on this buffer for the remote file. For example,
    when we type `C-x C-s` TRAMP would go ahead and save the file to the remote system
    using the established SSH connection. If we type `C-x d`, TRAMP would create a
    Dired buffer for the remote directory `/tmp/`. All the Emacs commands for working
    with files and directories we know just work fine with the remote file or directory.
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也了解了 TRAMP。例如，当我们输入键序列 `C-x C-f /ssh:alice@box:/tmp/foo.txt RET` 时，TRAMP 察觉到我们打算通过
    SSH 连接到名为 `box` 的远程系统，用户名为 `alice`，并编辑远程系统上名为 `/tmp/foo.txt` 的文件。TRAMP 然后会为我们透明地建立
    SSH 连接。如果公钥身份验证已设置，则连接会立即成功建立。否则，它会提示输入密码。最终，我们得到一个编辑远程文件 `/tmp/foo.txt` 的缓冲区。一旦我们有了这个缓冲区，就无需额外操作即可在远程文件上工作。所有
    Emacs 命令都能无缝地在这个远程文件的缓冲区上运行。例如，当我们键入 `C-x C-s` 时，TRAMP 会使用已建立的 SSH 连接保存文件到远程系统。如果我们键入
    `C-x d`，TRAMP 会为远程目录 `/tmp/` 创建一个 Dired 缓冲区。所有我们熟悉的用于文件和目录操作的 Emacs 命令都可以正常与远程文件或目录一起使用。
- en: 'So we knew about Eshell and we knew about TRAMP. However what many of us found
    pleasantly surprising was how remarkably well Eshell and TRAMP work together.
    Here is an example Eshell session that illustrates this point:'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道了 Eshell 和 TRAMP。然而，令我们许多人感到惊喜的是，Eshell 和 TRAMP 的协同工作效果如此显著。以下是一个示例 Eshell
    会话，用以说明这一点：
- en: '[PRE8]'
  id: totrans-split-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Look at how the command `cd /ssh:alice@box:/tmp/` above has seamlessly and
    transparently set the current directory of the shell to the remote directory.
    When we create a file after that, it gets created on the remote directory! We
    can work across directories opened with multiple TRAMP methods too. For example
    first consider this session where the current local user does not have the permissions
    to write to the local `/etc/` directory:'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 看看上面的命令 `cd /ssh:alice@box:/tmp/` 是如何无缝透明地将 shell 的当前目录设置为远程目录的。在此之后，如果我们创建一个文件，它会被创建在远程目录中！我们也可以在使用多个
    TRAMP 方法打开的目录间工作。例如，首先考虑这样一个会话，当前本地用户没有权限写入本地 `/etc/` 目录：
- en: '[PRE9]'
  id: totrans-split-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But if the current user has `sudo` privilege, we can do something like this:'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果当前用户具有 `sudo` 特权，我们可以这样做：
- en: '[PRE10]'
  id: totrans-split-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We copied a file from a remote system and wrote it to a protected directory
    on the local system by using the `sudo` privilege. We used the `ssh` method to
    read a remote file and the `sudo` method to write the file to a protected local
    directory. TRAMP really does live up to its name: *Transparent Remote Access,
    Multiple Protocol*!'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sudo`特权从远程系统复制文件，并将其写入本地系统上受保护的目录。我们使用`ssh`方法读取远程文件，并使用`sudo`方法将文件写入受保护的本地目录。TRAMP确实名副其实：*透明远程访问，多协议*！
- en: Thanks
  id: totrans-split-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感谢
- en: It has been a pleasure hosting these Emacs book club meetings throughout this
    year. I have really enjoyed discussing the book in great detail, examining each
    new concept introduced in the book carefully, and performing demos to illustrate
    the concepts. A big thank you to the Emacs communities on Libera and Matrix networks
    who showed interest in these meetings, joined these meetings, participated in
    the discussions, and helped make these meetings successful!
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 今年来主持这些Emacs图书俱乐部会议真是一大乐事。我非常享受讨论书中的内容，仔细研究每个新概念的引入，并进行演示来说明这些概念。特别感谢Libera和Matrix网络上的Emacs社区对这些会议的关注，参与讨论，并帮助这些会议取得成功！
- en: </main>
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
