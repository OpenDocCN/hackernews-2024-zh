- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:04:55'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'An Introduction to Optimization: Combinatorial Optimization | Doug Fenstermacher'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://dougfenstermacher.com/blog/combinatorial-optimization](https://dougfenstermacher.com/blog/combinatorial-optimization)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Home](/) *[Blog](/blog/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*## Overview[üîó](#overview)'
  prefs: []
  type: TYPE_NORMAL
- en: During my time working in fundraising, I worked on the web development side,
    building and maintaining websites and tools for public and internal use. Many
    of the problems that kept coming up in my department were optimization problems,
    many of which were directly related to business operations. Producing print collateral
    at optimal pricing, optimizing table layouts for events, scheduling/assigning
    work, minimizing travel costs, etc. Here I learned that while rule-based programming
    was useful automating known processes, optimization problems tend to make the
    biggest difference and time commitment for the majority of business decisions.
    These decisions ranged from simple (minimizing paper costs for print invitations),
    to complex (prioritizing content based on audience demographics/giving potential).
    Since moving on to other opportunities, I still dwell on the value of solving
    optimization problems in business scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning is a very prominent field right now. It is enabling companies
    to use data to resolve issues and gains insights that were unfeasible to find
    or even tackle using other methods. But not all problems can be resolved using
    machine learning, and historical data does not provide insights for all problems.
    For example, there is no amount of seating data for past weddings that will enable
    a machine learning model to learn to create a wedding seating chart for minimizing
    conflicts (that is, unless there are previous weddings where the exact same group
    attends, which would unusual). Or for finding the optimal travel route s for FedEx
    delivery trucks. These are the problems that are slower to find answers to, but
    crucial for business (or wedding) operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving optimization problems efficiently in a computer program is ultimately
    using mathematical optimization techniques to solve a given problem. Wikipedia
    defines **Mathematical Optimization** as:'
  prefs: []
  type: TYPE_NORMAL
- en: the selection of a best element (with regard to some criterion) from some set
    of available alternatives.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: which is a good simple explanation of optimization. There is no correct solution,
    only varying degrees of better and worse solutions. For example if a store wants
    to set the price for a product to maximize theirs profits, they should not sell
    a product for less than they purchased it for, and should not sell the product
    for more than customers will buy it for. If the store sells the product at a minimal
    value, their profit will be lower, but if they sell it at a price greater than
    what customers will pay, then they will get fewer sales. There is no right or
    wrong answer, just answers that lead to more/less profit. Those prices that lead
    to less profit can be considered sub-optimal solutions to the profit maximization
    problem. There are many possible prices that can be set for a given problem, optimization
    algorithms are used to reduce the computations needed to arrive at an optimal
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Combinatorial optimization is a subset of mathematical optimization for identifying
    how to optimize their finite set of resources to optimize production or profits.
    While less commonly used than linear programming, combinatorial optimization is
    an essential skill for finding optimal solutions for business problems.
  prefs: []
  type: TYPE_NORMAL
- en: Subset Sums[üîó](#subset-sums)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Combinatorial optimization problems are a very common type of problem, writing
    programs that determine a solution quickly can be difficult, and in some cases,
    impossible. For many combinatorial optimization problems, there are currently
    no efficient methods to solve them at scale. But, there are many optimization
    problems that do have efficient solutions, which we will cover. To start off,
    we will go through the most common situations for optimizations. To get started,
    we will work through the [subset-sum problem](https://en.wikipedia.org/wiki/Subset_sum_problem):'
  prefs: []
  type: TYPE_NORMAL
- en: given a set (or multiset) of integers, is there a non-empty subset whose sum
    is zero?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this problem, we are attempting to efficiently determine the set of items
    with the largest sum without exceeding a given number. This is useful for determining
    how to efficiently load a shipping truck, without exceeding its maximum weight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'def subset_sum(input_data, limit, labels=None):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not labels:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: labels = input_data
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'elif labels and len(input_data) != len(labels):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: raise ValueError('input_data(%r) and labels(%r) must be of equal length' % (input_data,  labels))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not limit or limit < 0:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: raise ValueError('limit(%s) must be a positive number' % limit)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cache = [None for _ in range(limit+1)]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cache[0] = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cache_labels = [None for _ in range(limit+1)]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cache_labels[0] = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for label, new_value in zip(labels, input_data):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for i in range(limit - new_value, -1, -1):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if cache[i] is not None:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cache[i + new_value] = cache[i] + [new_value]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cache_labels[i + new_value] = cache_labels[i] + [label]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return max(zip(cache_labels, cache), key=lambda v: sum(v[1]))'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: data = [13, -3, -25, 20, -3, -16, 0, 18, 20, -7, 12, -5, 12, -5, -22, 15, -4,
    7]
  prefs: []
  type: TYPE_NORMAL
- en: 'correct answer: max subset: [20, -3, -16, 0, 18, 20, -7, 12, -5, 12], sum:
    51 print ''Maximum Subarray: %r, Max: %r'' % max_subarray(data)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The subset-sum problem can be used to identify how to fill a container with
    the most items without exceeding a given capacity. This could be how to effectively
    fill a filing cabinet, how to fill a shipping container with the most weight,
    or how to fill a hard drive with the most files, while leaving minimal unused
    space
  prefs: []
  type: TYPE_NORMAL
- en: Knapsacks[üîó](#knapsacks)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The subset-sum problem, is actually a special case of the [knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem),:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a set of items, each with a weight and a value, determine the number of
    each item to include in a collection so that the total weight is less than or
    equal to a given limit and the total value is as large as possible.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So this is similar to the subset-sum problem, except we are trying to maximize
    our `value` as well. This problem involves maximizing the value of the chosen
    items, while not exceeding the value of our ‚Äúknapsack‚Äù.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'def knapsack(weights, values, capacity):'
  prefs: []
  type: TYPE_NORMAL
- en: item_count = len(weights)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cache = [[0 for _ in range(capacity + 1)] for _ in range(item_count + 1)]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for i in range(item_count + 1):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for j in range(capacity + 1):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: old_value = cache[i-1][j]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if i == 0 or j == 0:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cache[i][j] = 0
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'elif weights[i-1] <= j:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: new_value = values[i-1] + cache[i-1][j-weights[i-1]]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cache[i][j] = max(old_value, new_value)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cache[i][j] = old_value
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return cache[-1][-1]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: values = [60, 100, 120]
  prefs: []
  type: TYPE_NORMAL
- en: weights = [10, 20, 30]
  prefs: []
  type: TYPE_NORMAL
- en: capacity = 50
  prefs: []
  type: TYPE_NORMAL
- en: 'max_value = knapsack(weights, values, capacity)  # 220'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the index of items that were included in the knapsack, we can update
    the knapsack function to use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'def knapsack_items(weights, values, capacity):'
  prefs: []
  type: TYPE_NORMAL
- en: item_count = len(weights)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cache = [[0 for _ in range(capacity + 1)] for _ in range(item_count + 1)]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: find max value
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for i in range(item_count + 1):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for j in range(capacity + 1):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: old_value = cache[i-1][j]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if i == 0 or j == 0:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cache[i][j] = 0
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'elif weights[i-1] <= j:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: new_value = values[i-1] + cache[i-1][j-weights[i-1]]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cache[i][j] = max(old_value, new_value)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: cache[i][j] = old_value
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: fetch list of items in knapsack
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: max_value = cache[item_count][capacity]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: indices = set()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for i in range(item_count, 0, -1):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if max_value <= 0:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if max_value == cache[i - 1][j]:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: indices.add(i - 1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: max_value = max_value - values[i - 1]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: j = j - weights[i - 1]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return cache[item_count][capacity], indices
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: values = [60, 100, 120]
  prefs: []
  type: TYPE_NORMAL
- en: weights = [10, 20, 30]
  prefs: []
  type: TYPE_NORMAL
- en: capacity = 50
  prefs: []
  type: TYPE_NORMAL
- en: max_value, item_indices = knapsack(weights, values, capacity)
  prefs: []
  type: TYPE_NORMAL
- en: 'print(max_value, item_indices) # 220, {1, 2}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**: in cases where an two items have the same weight and value, they
    can be considered as iterchangeable items, as doing so would not affect the weight
    or value of the optimal knapsack.'
  prefs: []
  type: TYPE_NORMAL
- en: If you examine this code closely, you may notice that the code is very inefficient,
    by checking every capacity between 0 and the specified `capacity`. In cases like
    above, where the weights are all multiples of 10, we can know that most capacities
    will not require changes. We can transform our `weights` and `capacity` values
    to minimize the number of iterations over the capacity by calculating the greatest
    common divisor (GCD) of the `weights` and `capacity` values and dividing the values
    by the GCD. Here is an example below, which results in the same solution as the
    original problem as above
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: knapsack_gcd = gcd(capacity, *weights)
  prefs: []
  type: TYPE_NORMAL
- en: minified_weights = [int(value / knapsack_gcd) for value in weights]
  prefs: []
  type: TYPE_NORMAL
- en: minified_capacity = int(capacity / knapsack_gcd)
  prefs: []
  type: TYPE_NORMAL
- en: max_value, item_indices = knapsack_items(minified_weights, values, minified_capacity)
  prefs: []
  type: TYPE_NORMAL
- en: print(max_value, item_indices)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Another variation of the knapsack problem is the [Continuous knapsack problem](https://en.wikipedia.org/wiki/Continuous_knapsack_problem),
    which allows fractions of items to be put in the knapsack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: '48'
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'def continuous_knapsack(capacity, values, weights):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fill a container (the "knapsack") with fractional amounts of different
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: materials chosen to maximize the value of the selected materials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'capacity (int&#124;float): Total weight capacity of the knapsack'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'values (list&#124;tuple): Values of weights that can be placed in the knapsack'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'weights (list&#124;tuple): Weights of items that can be placed in the knapsack'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'total_value (float):  Total value that can be stored in the knapsack'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'selected_indices (list):  List of indices of items stored in the knapsack'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'selected_fractions (list):  List of fractions of items stored in the knapsack'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"""'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: costs = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: values = [float(value) for value in values]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: weights = [float(weight) for weight in weights]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: indices = range(len(weights))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for i in range(len(weights)):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: costs.append(values[i] / weights[i])
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: selected_indices = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: selected_fractions = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sorting items by value
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'items = sorted(zip(indices, values, weights, costs), key=lambda item: item[3],
    reverse=True)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total_value = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for index, value, weight, cost in items:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: selected_indices.append(index)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if capacity - weight >= 0:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: capacity -= weight
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: total_value += value
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: selected_fractions.append(1.0)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: fraction = capacity / weight
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: total_value += value * fraction
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: capacity = capacity - (weight * fraction)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if fraction > 0:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: selected_fractions.append(fraction)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return total_value, selected_indices, selected_fractions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: weights = [10, 40, 20, 30]
  prefs: []
  type: TYPE_NORMAL
- en: values = [60, 40, 100, 120]
  prefs: []
  type: TYPE_NORMAL
- en: capacity = 50
  prefs: []
  type: TYPE_NORMAL
- en: 'max_value, selected_indices, selected_fractions = continuous_knapsack(capacity,
    values, weights)  # (240.0, [0, 2, 3], [1.0, 1.0, 0.6666666666666666])'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Activity Selection[üîó](#activity-selection)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next problem we will tackle is the [activity selection problem](https://en.wikipedia.org/wiki/Activity_selection_problem):'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is to select the maximum number of activities that can be performed
    by a single person or machine, assuming that a person can only work on a single
    activity at a time.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This problem can be generalized to this: maximize the number of intervals that
    can be sequenced without overlapping.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: import heapq
  prefs: []
  type: TYPE_NORMAL
- en: 'def activity_selection(names, start_times, finish_times):'
  prefs: []
  type: TYPE_NORMAL
- en: assert len(names) == len(start_times) == len(finish_times)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: heap = zip(finish_times, start_times, names)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: heapq.heapify(heap)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: previous_selection = heapq.heappop(heap)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: selections = [previous_selection]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'while heap:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: selection = heapq.heappop(heap)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if selection[1] >= previous_selection[0]:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: selections.append(selection)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: previous_selection = selection
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return selections
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: But what about the case where we some intervals are more important than others?
    We want to make sure that we maximize the weights of our set of chosen events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: import heapq
  prefs: []
  type: TYPE_NORMAL
- en: 'def activity_selection_weighted(names, start_times, finish_times, weights):'
  prefs: []
  type: TYPE_NORMAL
- en: assert len(names) == len(start_times) == len(finish_times) == len(weights)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: heap = zip(finish_times, start_times, names, weights)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: heapq.heapify(heap)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: item_count = len(heap)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: weight_cache = [0] * item_count
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: selections = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: previous_selection = heapq.heappop(heap)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: selections = [previous_selection]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: maxi = -float('inf')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for i, item in enumerate(heapq.nsmallest(item_count, heap)):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for j, other_item in enumerate(heapq.nsmallest(i, heap)):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if other_item[0] <= item[1]:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: weight_cache[i] = max(weight_cache[i], weight_cache[j] + item[3])
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: maxi = max(weight_cache[i], maxi)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for i, item in reversed(list(enumerate(heapq.nsmallest(item_count, heap)))):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if weight_cache[i] == maxi:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: maxi -= item[3]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: selections.append(item)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return list(reversed(selections))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: activities = 'abcde'
  prefs: []
  type: TYPE_NORMAL
- en: start_times = [10, 12, 12, 13, 15]
  prefs: []
  type: TYPE_NORMAL
- en: finish_times = [11, 13, 12.5, 15, 17]
  prefs: []
  type: TYPE_NORMAL
- en: weights = [1, 3, 2, 5, 1]
  prefs: []
  type: TYPE_NORMAL
- en: 'print ''Selected Activities (unweighted): %r'' % activity_selection(activities,
    start_times, finish_times)'
  prefs: []
  type: TYPE_NORMAL
- en: 'print ''Selected Activities (weighted): %r'' % activity_selection_weighted(activities,
    start_times, finish_times, weights)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Activity selection has applications for scheduling events. The activity selection
    problem has applications in scheduling meets, conference scheduling, and in recommending
    schedules to attendees of events. This solution to the problem would have been
    particularly useful for providing a recommended attendance scheduling for alumni.
  prefs: []
  type: TYPE_NORMAL
- en: Task Assignment[üîó](#task-assignment)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last combinatorial problem we will cover is the [assignment problem](https://en.wikipedia.org/wiki/Assignment_problem):'
  prefs: []
  type: TYPE_NORMAL
- en: The problem instance has a number of agents and a number of tasks. Any agent
    can be assigned to perform any task, incurring some cost that may vary depending
    on the agent-task assignment. It is required to perform all tasks by assigning
    exactly one agent to each task and exactly one task to each agent in such a way
    that the total cost of the assignment is minimized.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This problem requires us to calculate a cost matrix, made of m rows of workers,
    and n columns of tasks to be completed. My example is for tasking workers on a
    flower farm to maximize profit for the farm, based on their wages and rate at
    which they pick flowers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'def build_cost_matrix(workers, tasks, cost_func):'
  prefs: []
  type: TYPE_NORMAL
- en: return [[cost_func(worker, task) for task in tasks] for worker in workers]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def profit(worker, task):'
  prefs: []
  type: TYPE_NORMAL
- en: return (worker['rate'] * task) - worker['pay']
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'workers = [{''pay'': 20, ''rate'': 300}, {''pay'': 10.5, ''rate'': 200}, {''pay'':
    15, ''rate'': 150}, {''pay'': 6.5, ''rate'': 100}, {''pay'': 17.5, ''rate'': 200}]'
  prefs: []
  type: TYPE_NORMAL
- en: flowers =dict(orchid=10, daisy=2.25, daffodil=1.70, dandelion=0.001, grass=0.0001)
  prefs: []
  type: TYPE_NORMAL
- en: flower_labels = flowers.keys()
  prefs: []
  type: TYPE_NORMAL
- en: flower_assignments = flowers.values()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We could normally could iterate through every possible combination of workers
    and flowers and find the maximum profit, especially since we only have 5 workers
    and 5 assignments, but that would not scale well if we had a large flower-growing
    business with hundred of workers and hundreds of types of flowers. We will need
    to use a more scaleable method. If we did not have a library, we would implement
    a [Hungarian algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm), however
    it is a rather complicated algorithm which is a topic for another day. Fortunately,
    scipy has an [implementation](https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.optimize.linear_sum_assignment.html)
    that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: from scipy.optimize import linear_sum_assignment
  prefs: []
  type: TYPE_NORMAL
- en: 'def flower_picker_cost(worker, task):'
  prefs: []
  type: TYPE_NORMAL
- en: return 0 - abs(profit(worker, task))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cost_matrix = build_cost_matrix(workers, flower_assignments, flower_picker_cost)
  prefs: []
  type: TYPE_NORMAL
- en: worker_indexes, assignment_indexes = linear_sum_assignment(cost_matrix)
  prefs: []
  type: TYPE_NORMAL
- en: 'for worker_index, assignment_index in zip(worker_indexes, assignment_indexes):'
  prefs: []
  type: TYPE_NORMAL
- en: worker = workers[worker_index]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: flower = flower_labels[assignment_index]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print 'Worker=%r, flower=%s, profitability=$%s' %  (worker, flower, profit(worker,
    flowers[flower]))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: minimum_cost =  np.array(cost_matrix)[worker_indexes, assignment_indexes].sum()
  prefs: []
  type: TYPE_NORMAL
- en: 'print ''Maximum profit: $%s'' % abs(minimum_cost)'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'Worker={''pay'': 20, ''rate'': 300}, flower=orchid, profitability=$2980/hour'
  prefs: []
  type: TYPE_NORMAL
- en: 'Worker={''pay'': 10.5, ''rate'': 200}, flower=daisy, profitability=$439.5/hour'
  prefs: []
  type: TYPE_NORMAL
- en: 'Worker={''pay'': 15, ''rate'': 150}, flower=dandelion, profitability=$-14.85/hour'
  prefs: []
  type: TYPE_NORMAL
- en: 'Worker={''pay'': 6.5, ''rate'': 100}, flower=grass, profitability=$-6.49/hour'
  prefs: []
  type: TYPE_NORMAL
- en: 'Worker={''pay'': 17.5, ''rate'': 200}, flower=daffodil, profitability=$322.5/hour'
  prefs: []
  type: TYPE_NORMAL
- en: 'Maximum Profit: $3720.6600000000003/hour'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we made our `flower_picker_cost` function return `0 - profit(worker,
    task)`. `scipy.optimize.linear_sum_assignment` implementation is used to minimize
    a cost function. Since our measure of success is profitability, we ensure that
    the cost our most profitable worker-flower assignments return the lowest cost.
    We could have used the formula `1 / - profit(worker, task)`, but I wanted to make
    the cost function simple and easy to interpret for users. Let‚Äôs try the same code
    on a large number of tasks and workers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: workers = [dict(pay=random.random(), rate=random.random()) for i in range(150)]
  prefs: []
  type: TYPE_NORMAL
- en: flowers = dict((flower, random.random() * 2) for flower in ["african corn lily",
    "ixia", "african lily, agapanthus", "alpine thistle, eryngium", "amaryllis, hippeastrum",
    "amazon lily, eucharis", "arum, zantedeschia", "baby‚Äôs breath, gypsophila", "balloon
    flower, platycodon", "barberton daisy, gerbera", "bee balm, monarda", "bell flower,
    campanula", "bells of Ireland, moluccella", "bergamot, monarda", "bird of paradise,
    strelizia", "bloom, chrysanthemum", "blue throatwort, trachelium", "bottlebrush,
    banksia", "brodiaea, triteleia (syn)", "broom, genista", "calla lily, zantedeschia",
    "canterbury bells, campanula", "carnation, dianthus", "china aster, callistephus",
    "chincerinchee, ornithogalum", "chinese bellflower, platycodon", "christmas rose,
    hellebore", "cockscomb, celosia", "columbine, aquilegia", "coneflower, rudbeckia/echinacea",
    "cornflower, centaurea", "corsage orchid, cattleya", "cosmos, cosmea (syn)", "cuban
    lily, scilla", "daffodil, narcissus", "dill, anethum", "drumstick, craspedia",
    "eustoma, lisianthus (syn)", "evening primrose, oenothera", "false goat‚Äôs beard,
    false spirea/astilbe", "feverfew, tanacetum parthenium", "flame lily, gloriosa",
    "flame tip, leucadendron", "flamingo flower, anthurium", "florist‚Äôs nighmare,
    ornithogalum", "floss flower, ageratum", "flowering cherry, prunus", "flowering
    onion, allium", "forget-me-not, myosotis", "foxglove, digitalis", "foxtail lily,
    eremurus", "gay feather, liatris", "gentian, gentiana", "gillyflower, matthiola",
    "ginger, alpinia", "globe amarath, gomphrena", "globe artichoke, cynara", "globe
    flower, trollius", "globe thistle, echinops", "glory lily, gloriosa", "golden
    rod, solidago", "golden shower orchid, oncidium", "goosefoot, chenpodium", "grape
    hyacinth, muscari", "guelder rose, viburnum opulus", "guernsey lily, nerine",
    "hyacinth, hyacinthus", "jersey lily, alstroemeria", "kangaroo paw, anigozanthos",
    "kansas feather, liatris", "lady‚Äôs mantle, alchemilla", "lady‚Äôs slipper orchid,
    paphiopedilum", "larkspur, delphinium consolida", "lavender, lavandula", "lilac,
    syringa", "lily, lilium", "lily of the valley, convallaria", "lisianthus, eustoma",
    "lobster claw, heliconia", "loose strife, lysimachia", "love lies bleeding, amaranthus",
    "love-in-a-mist, nigella", "lupin, lupinus", "marguerite, chrysanthemum frutescens",
    "marigold, calendula", "masterwort, astrantia", "michaelmas daisy, aster", "mimosa,
    acacia", "monkshood, aconitum", "montbretia, crocosmia", "moth orchid, phalenopsis",
    "mum, chrysanthemum", "obedient plant, physostegia", "ox-eye daisy, leucanthemum
    vulgare aka chrysanthemum leucanthemum", "painter‚Äôs palette, anthurium", "peony,
    paeonia", "peruvian lily, alstroemeria", "pincushion protea, leucospermum", "plumed
    thistle, cirsium", "prairie gentian, lisianthus", "prince of Wales feather, amaranthus",
    "queen Anne‚Äôs lace, ammi", "queen Fabiola lily, triteleia (syn brodiaea)", "red-hot
    poker, kniphofia", "rose, rosa", "safari sunset, leucadendron", "safflower, carthamus",
    "scabious, scabiosa", "scarlet plume, euphorbia fulgens", "scorpion orchid, aranthera",
    "sea holly, eryngium", "sea lavender, limonium", "september flower, aster", "singapore
    orchid, dendrobium", "slipper orchid, paphiopedilum", "snake head, chelone", "snapdragon,
    antirrhinum", "sneezeweed, helenium", "snow berry, symphoricarpos", "snow on the
    mountain, eurphorbia marginata", "speedwell, veronica", "spider orchid, arachnis",
    "spray carnation, dianthus", "spurge, euphorbia", "st john‚Äôs wort, hypericum",
    "star of bethlehem, ornithogalum", "statice, limonium", "stock, matthiola", "stonecrop,
    sedum", "sugarbush, protea", "sunflower, helianthus", "sweet pea, lathyrus", "sweet
    sultan, centaurea", "sweet William, dianthus barbatus", "sword lily, gladiolus",
    "tansy, tanacetum", "tazetta, narcissus", "thistle, eryngium", "tjenkenrientjee,
    ornithogalum", "transvaal daisy, gerbera", "tuberose, polianthes tuberosa", "tulip,
    tulipa", "turban buttercup/French buttercup/Persian buttercup, ranunculus", "turtle
    head, chelone", "ulster mary, alstroemeria", "waxflower, chamaelaucium", "windflower,
    anemone", "wormwood, artemesia", "yarrow", "achillea"])
  prefs: []
  type: TYPE_NORMAL
- en: flower_labels = flowers.keys()
  prefs: []
  type: TYPE_NORMAL
- en: flower_assignments = flowers.values()
  prefs: []
  type: TYPE_NORMAL
- en: cost_matrix = build_cost_matrix(workers, flower_assignments, flower_picker_cost)
  prefs: []
  type: TYPE_NORMAL
- en: worker_indexes, assignment_indexes = linear_sum_assignment(cost_matrix)
  prefs: []
  type: TYPE_NORMAL
- en: 'for worker_index, assignment_index in zip(worker_indexes, assignment_indexes):'
  prefs: []
  type: TYPE_NORMAL
- en: worker = workers[worker_index]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: flower = flower_labels[assignment_index]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print 'Worker=%r, flower=%s, profitability=$%s/hour' %  (worker, flower, profit(worker,
    flowers[flower]))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The assignment problem comes up often in everyday life, such as optimally determining
    which athletic trainer to assign to each athlete in a queue, determining how to
    assign technicians to support tickets based on their skillset and location, or
    determining the optimal way to assign salesperson to potential companies.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum Set Cover[üîó](#minimum-set-cover)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One such approximation algorithm is that of the [Minimum Set Cover problem](https://en.wikipedia.org/wiki/Set_cover_problem):'
  prefs: []
  type: TYPE_NORMAL
- en: Given a set of elements {1,2,...,n} (called the universe) and a collection S
    of m sets whose union equals the universe, the set cover problem is to identify
    the smallest sub-collection of S whose union equals the universe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'def set_cover(target_set, all_sets, selection_func=None, max_iterations=1000,
    min_max=max):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finds a list of sets from all_sets that covers all (or the most) items in covering_set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If not able to cover all the items in the covering set in max_iterations, will
    return the best result found
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"""'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if selection_func and not hasattr(selection_func, ''__call__''):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: raise ValueError('scoring_func(%r) is not callable' % selection_func)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: remaining_items = target_set
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: best_solution = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not selection_func:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'selection_func = lambda item: len(set(item) & set(remaining_items))'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: iterations = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: old_remaining_items = remaining_items
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'while len(remaining_items) and iterations < max_iterations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: iterations += 1
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not selection_func:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: selected_set = min_max(all_sets, key=selection_func)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: selected_set = selection_func(remaining_items)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: all_sets.remove(selected_set)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: remaining_items = set(remaining_items) - set(selected_set)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if len(old_remaining_items) == len(remaining_items):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if min_max == min:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'elif min_max == max:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: best_solution.append(selected_set)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: old_remaining_items = remaining_items
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return best_solution
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import itertools
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: import string
  prefs: []
  type: TYPE_NORMAL
- en: alphabet_list = [letter for letter in string.lowercase]
  prefs: []
  type: TYPE_NORMAL
- en: combinations = [list(combo) for combo in itertools.combinations(alphabet_list,
    4)]
  prefs: []
  type: TYPE_NORMAL
- en: set_to_cover = random.sample(alphabet_list, 9) + ['!']
  prefs: []
  type: TYPE_NORMAL
- en: 'print ''Set to Cover: %r'' % set_to_cover'
  prefs: []
  type: TYPE_NORMAL
- en: 'print ''Minimum Set Cover: %r, Uncovered Items %r'' % set_cover(set_to_cover,
    combinations)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Set coverings can be used to create solutions for purchasing inventory, creating
    work schedules for shift hours a training room, creating the minimal team that
    has the required skillset for a project, or finding the minimal number of officials
    required to host a meet based on the division requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In our examples, the algorithms solved our problems almost instantaneously.
    In a production setting with larger datasets, we would likely rewrite these algorithms
    as a separate library in Cython to solv larger instances of the problems without
    performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Larger problems[üîó](#larger-problems)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problems we have examined so far are fairly simple problems. In a business
    settings, many problems that need to be resolved have more potential solutions,
    more constraints, and more dimensions. Computer scientists and operations research
    specialists have spent decades building and optimizing specialized libraries for
    solving these types of problems. The most time-efficient way for us to use would
    be to use their optimized libraries to solve our optimization problems. Their
    libraries will allow us to focus on solving our business-related issues using
    the best methods available.
  prefs: []
  type: TYPE_NORMAL
- en: The above all are very reputable and optimized libraries for solving optimization
    problems. For Python, I would recommend using Google‚Äôs [ORTools](https://developers.google.com/optimization/).
    Google ORTools provides a Python interface to many of the above tools, allowing
    Python developers to leverage the above libraries without needing to know how
    each of them work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a real-life scenario: Let‚Äôs say we want to invest in our online advertising
    and we want to get the most conversions we can using our limited budget, but we
    have a set of business constraints that we have to meet. Using only conversion
    rates across mediums, and our customer reach/dollar, we can find the optimal allocation
    of funds in less than a quarter of a second.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: '48'
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  prefs: []
  type: TYPE_NORMAL
- en: '52'
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: from ortools.linear_solver import pywraplp
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: channels = ['Social Media', 'Referral', 'Organic Search', 'Email', 'Direct']
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: probabilities of conversion from each of the above channels
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: conversion_probabilities = [0.0675, 0.128, 0.0577, 0.1723, 0.7387]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: customer_reach = [2, 0.3, 1.8, 0.9, 2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constraint_table = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''Overall Budget'': dict(max=5000, min=0, coefficients=[1, 1, 1, 1, 1]),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''Direct Budget < 25% of Budget'': dict()'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: solver = pywraplp.Solver('ROI', pywraplp.Solver.CBC_MIXED_INTEGER_PROGRAMMING)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: budgets = dict()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: objective = solver.Objective()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: create variables for the budget of each channel
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for channel, probability in zip(channels, conversion_probabilities):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: budget cannot be negative
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: budget_variable = solver.NumVar(0.0, solver.infinity(), channel)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: for each channel allocate funds based on conversion rates for each channel
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: objective.SetCoefficient(budget_variable, probability)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: budgets[channel] = budget_variable
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: maximize the number of conversions (ROI)
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: objective.SetMaximization()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total budget
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: total_budget = solver.Sum(budgets.values())
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total budget <= $5000
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: solver.Add(total_budget <= 5000)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Social Media < $50
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: solver.Add(budgets['Social Media'] <= 50)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Direct is < 25% of Total budget
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: solver.Add(budgets['Direct'] <= .25 * total_budget)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: E-mail budget is at least $200
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: solver.Add(budgets['Email'] >= 200)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Email budget < 3 x Social Media
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: solver.Add(budgets['Email'] <= 3 * budgets['Social Media'])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Referral budget >= 12% of total budget
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: solver.Add(budgets['Referral'] >= .12 * total_budget)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reach 30,000 or more users
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: total_reach = sum([budgets[channel] * reach for channel, reach in zip(channels,
    customer_reach)])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: solver.Add(total_reach >= 30000)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: status = solver.Solve()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if status == solver.OPTIMAL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for channel, value in budgets.items():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print ''%s: $%r'' % (channel, value.solution_value())'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print ''Optimal budget: $%r, reaching %s users'' % (total_budget.solution_value(),
    total_reach.solution_value())'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'elif status == solver.FEASIBLE:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print 'A potentially suboptimal solution was found.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print 'The solver could not solve the problem.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A significant benefit of ORTools is its ability to solve linear, integer and
    mixed-integer problems and to define the problem at runtime. Many specialized
    optimization tools have their own language syntax for creating optimization programs,
    which makes building the problem at runtime more painful for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Seating Assignment[üîó](#seating-assignment)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the biggest pains of brides (so I hear), is to organize the seating
    charts for wedding receptions. In a perfect world this wouldn‚Äôt be a problem because
    all relatives/friends would love each other‚Äôs company. But that‚Äôs not going to
    happen. So brides have to find a way to group the guests so that everyone can
    enjoy the company of fellow guests, and not be seated with company they don‚Äôt
    enjoy (and potentially cause wedding drama). Fortunately, operations researchers
    identified this type of issue as one worth solving. In our seating assignment
    problem, our objective is simple: maximize the number of people sitting together
    who like each other. We can create a data representation to use to maximize our
    objective by creating a matrix representation of all sentiments/relationships
    between all attendees of the wedding. an edge‚Äôs weight reflects the sentiment/relationship
    that one guest has for another. If the relationship is non-existent or a person
    feels ambivalent towards the other, the weight should be ~0. We will have a number
    of constraints that we will need to account for:'
  prefs: []
  type: TYPE_NORMAL
- en: A table cannot be assigned more guests than it has seats for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A guest cannot have more than 1 assigned seat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A guests must have know more at least a given number of guests at their table.
    some guests may require more/less known guests than others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tables may have varying capacities due to different types of tables, or different
    numbers of available chairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have our objectives and constraints we can write our actual model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: '48'
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  prefs: []
  type: TYPE_NORMAL
- en: '52'
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  prefs: []
  type: TYPE_NORMAL
- en: '59'
  prefs: []
  type: TYPE_NORMAL
- en: '60'
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  prefs: []
  type: TYPE_NORMAL
- en: '66'
  prefs: []
  type: TYPE_NORMAL
- en: '67'
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  prefs: []
  type: TYPE_NORMAL
- en: '71'
  prefs: []
  type: TYPE_NORMAL
- en: '72'
  prefs: []
  type: TYPE_NORMAL
- en: '73'
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  prefs: []
  type: TYPE_NORMAL
- en: '75'
  prefs: []
  type: TYPE_NORMAL
- en: '76'
  prefs: []
  type: TYPE_NORMAL
- en: '77'
  prefs: []
  type: TYPE_NORMAL
- en: '78'
  prefs: []
  type: TYPE_NORMAL
- en: '79'
  prefs: []
  type: TYPE_NORMAL
- en: '80'
  prefs: []
  type: TYPE_NORMAL
- en: '81'
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  prefs: []
  type: TYPE_NORMAL
- en: '83'
  prefs: []
  type: TYPE_NORMAL
- en: '84'
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  prefs: []
  type: TYPE_NORMAL
- en: '86'
  prefs: []
  type: TYPE_NORMAL
- en: '87'
  prefs: []
  type: TYPE_NORMAL
- en: '88'
  prefs: []
  type: TYPE_NORMAL
- en: '89'
  prefs: []
  type: TYPE_NORMAL
- en: '90'
  prefs: []
  type: TYPE_NORMAL
- en: '91'
  prefs: []
  type: TYPE_NORMAL
- en: '92'
  prefs: []
  type: TYPE_NORMAL
- en: '93'
  prefs: []
  type: TYPE_NORMAL
- en: '94'
  prefs: []
  type: TYPE_NORMAL
- en: '95'
  prefs: []
  type: TYPE_NORMAL
- en: '96'
  prefs: []
  type: TYPE_NORMAL
- en: '97'
  prefs: []
  type: TYPE_NORMAL
- en: '98'
  prefs: []
  type: TYPE_NORMAL
- en: '99'
  prefs: []
  type: TYPE_NORMAL
- en: '100'
  prefs: []
  type: TYPE_NORMAL
- en: '101'
  prefs: []
  type: TYPE_NORMAL
- en: '102'
  prefs: []
  type: TYPE_NORMAL
- en: '103'
  prefs: []
  type: TYPE_NORMAL
- en: '104'
  prefs: []
  type: TYPE_NORMAL
- en: '105'
  prefs: []
  type: TYPE_NORMAL
- en: '106'
  prefs: []
  type: TYPE_NORMAL
- en: '107'
  prefs: []
  type: TYPE_NORMAL
- en: '108'
  prefs: []
  type: TYPE_NORMAL
- en: '109'
  prefs: []
  type: TYPE_NORMAL
- en: '110'
  prefs: []
  type: TYPE_NORMAL
- en: '111'
  prefs: []
  type: TYPE_NORMAL
- en: '112'
  prefs: []
  type: TYPE_NORMAL
- en: '113'
  prefs: []
  type: TYPE_NORMAL
- en: '114'
  prefs: []
  type: TYPE_NORMAL
- en: '115'
  prefs: []
  type: TYPE_NORMAL
- en: '116'
  prefs: []
  type: TYPE_NORMAL
- en: '117'
  prefs: []
  type: TYPE_NORMAL
- en: '118'
  prefs: []
  type: TYPE_NORMAL
- en: '119'
  prefs: []
  type: TYPE_NORMAL
- en: '120'
  prefs: []
  type: TYPE_NORMAL
- en: '121'
  prefs: []
  type: TYPE_NORMAL
- en: '122'
  prefs: []
  type: TYPE_NORMAL
- en: '123'
  prefs: []
  type: TYPE_NORMAL
- en: '124'
  prefs: []
  type: TYPE_NORMAL
- en: '125'
  prefs: []
  type: TYPE_NORMAL
- en: '126'
  prefs: []
  type: TYPE_NORMAL
- en: '127'
  prefs: []
  type: TYPE_NORMAL
- en: '128'
  prefs: []
  type: TYPE_NORMAL
- en: '129'
  prefs: []
  type: TYPE_NORMAL
- en: '130'
  prefs: []
  type: TYPE_NORMAL
- en: '131'
  prefs: []
  type: TYPE_NORMAL
- en: '132'
  prefs: []
  type: TYPE_NORMAL
- en: '133'
  prefs: []
  type: TYPE_NORMAL
- en: '134'
  prefs: []
  type: TYPE_NORMAL
- en: '135'
  prefs: []
  type: TYPE_NORMAL
- en: '136'
  prefs: []
  type: TYPE_NORMAL
- en: '137'
  prefs: []
  type: TYPE_NORMAL
- en: '138'
  prefs: []
  type: TYPE_NORMAL
- en: '139'
  prefs: []
  type: TYPE_NORMAL
- en: '140'
  prefs: []
  type: TYPE_NORMAL
- en: '141'
  prefs: []
  type: TYPE_NORMAL
- en: '142'
  prefs: []
  type: TYPE_NORMAL
- en: '143'
  prefs: []
  type: TYPE_NORMAL
- en: '144'
  prefs: []
  type: TYPE_NORMAL
- en: '145'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: from __future__ import print_function
  prefs: []
  type: TYPE_NORMAL
- en: from ortools.sat.python import cp_model
  prefs: []
  type: TYPE_NORMAL
- en: 'def seat_assignment(all_tables, table_capacities, min_known_neighbors, relationships,
    names):'
  prefs: []
  type: TYPE_NORMAL
- en: num_guests = len(relationships)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all_guests = range(num_guests)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if isinstance(table_capacities, int):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: table_capacities = [table_capacities] * len(all_tables)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if isinstance(min_known_neighbors, int):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: min_known_neighbors = [min_known_neighbors] * len(all_tables)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the cp model.
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: model = cp_model.CpModel()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Decision variables
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: seats = {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for table in all_tables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for guest in all_guests:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: seats[(table, guest)] = model.NewBoolVar("guest %i seats on table %i" % (guest,
    table))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: colocated = {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for g1 in range(num_guests - 1):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for g2 in range(g1 + 1, num_guests):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: colocated[(g1, g2)] = model.NewBoolVar("guest %i seats with guest %i" % (g1,
    g2))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: same_table = {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for g1 in range(num_guests - 1):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for g2 in range(g1 + 1, num_guests):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for table in all_tables:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: same_table[(g1, g2, table)] = model.NewBoolVar("guest %i seats with guest %i
    on table %i" % (g1, g2, table))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: total_score = sum(relationships[g1][g2] * colocated[g1, g2] for g1 in range(num_guests
    - 1) for g2 in range(g1 + 1, num_guests) if relationships[g1][g2] > 0)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: model.Maximize(total_score)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Everybody seats at one table.
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for guest in all_guests:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: seats_per_guest = sum(seats[(table, guest)] for table in all_tables)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: model.Add(seats_per_guest == 1)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Tables have a max capacity.
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for table, table_capacity in zip(all_tables, table_capacities):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assigned_seats_per_table = sum(seats[(table, guest)] for guest in all_guests)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: model.Add(assigned_seats_per_table <= table_capacity)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Link colocated with seats
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for g1 in range(num_guests - 1):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for g2 in range(g1 + 1, num_guests):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for table in all_tables:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Link same_table and seats.  Keeps variables in sync
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: guest_table_1 = seats[(table, g1)]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: guest_table_2 = seats[(table, g2)]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: same_table_pairing = same_table[(g1, g2, table)]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: model.AddBoolOr([guest_table_1.Not(), guest_table_2.Not(), same_table_pairing])
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if same_table_pairing is True, then guest_table_1/2 must be True
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: model.AddImplication(same_table_pairing, guest_table_1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: model.AddImplication(same_table_pairing, guest_table_2)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Link colocated and same_table.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: guests_sit_together = sum(same_table[(g1, g2, table)] for table in all_tables)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: model.Add(guests_sit_together == colocated[(g1, g2)])
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Min known neighbors rule.
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for t, min_neighbors in zip(all_tables, min_known_neighbors):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: known_neighbors = sum(same_table[(g1, g2, t)] for g1 in range(num_guests - 1)
    for g2 in range(g1 + 1, num_guests) for t in all_tables if relationships[g1][g2]
    > 0)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: model.Add(known_neighbors >= min_neighbors)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Symmetry breaking. First guest seats on the first table.
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: model.Add(seats[(0, 0)] == 1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Solve model.
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: solver = cp_model.CpSolver()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: status = solver.Solve(model)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print("conflicts    : %i" % solver.NumConflicts())'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print(" branches     : %i" % solver.NumBranches())'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print("wall time    : %f ms" % solver.WallTime())'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: output = dict()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for (table, guest), seat_variable in seats.items():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is_seated_at_table = solver.Value(seat_variable)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if is_seated_at_table:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: guest_name = names[guest]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: output[guest_name] = table
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return output, solver.Value(total_score)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: solve_with_discrete_model()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Connection matrix: who knows who, and how strong'
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: is the relation
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: relations = [
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1, 50, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[50, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1, 1, 1, 50, 1, 1, 1, 1, 10, 0, 0, 0, 0, 0, 0, 0, 0],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1, 1, 50, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1, 1, 1, 1, 1, 50, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1, 1, 1, 1, 50, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1, 1, 1, 1, 1, 1, 1, 50, 1, 0, 0, 0, 0, 0, 0, 0, 0],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1, 1, 1, 1, 1, 1, 50, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1, 1, 10, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 50, 1, 1, 1, 1, 1, 1],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 1, 1, 1, 1, 1, 1, 1],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Names of the guests. B: Bride side, G: Groom side'
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: names = [
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"John (G)", "Mike (B)", "Kathy (G)", "Cory (B)", "Carmela (G)",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Jeff (B)", "Matt (B)", "Brad (B)", "Abby (B)", "Ann (B)",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Lee (G)", "Mary (B)", "Bob (B)", "Will (G)", "Scott (B)",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Diane (G)", "Laura (B)"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: table_count = 4
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all_tables = range(table_count)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: table_capacities = 5
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: table_capacities = [random.randint(4,6) for table in all_tables]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: min_known_neighbors = 3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: min_known_neighbors = [random.randint(0,3) for table in all_tables]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print(''total guests: %i'' % len(relations))'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if isinstance(table_capacities, (list, tuple)):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total_seats = sum(table_capacities)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total_seats = len(all_tables) * table_capacities
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print(''total seats: %i'' % total_seats)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: results, score = seat_assignment(all_tables, table_capacities, min_known_neighbors,
    relations, names)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print('Seating assignments:')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for guest, table in results.items():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print(''Guest: %r, Table: %r'' % (guest, table))'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print('Optimal Score:', score)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Using ortools, we were able to create a flexible model that meets all our constraints.
    We even allow developers to specify table_capacity and min_known_neighbor constraints
    as an integer or as a list. Let‚Äôs check our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This model can be expanded to include even more constraints, so our model still
    has room to grow as more more constraints arise. This same model can also be applied
    to other scenarios such as conference seating charts, assigning project teams,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: from networkx import Graph
  prefs: []
  type: TYPE_NORMAL
- en: from networkx.algorithms import matching
  prefs: []
  type: TYPE_NORMAL
- en: 'def lane_matching(athletes, lanes, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: athlete_count = len(athletes)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: G = Graph()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: G.add_nodes_from([athlete['name'] for athlete in athletes])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: average_height = sum([athlete['height'] for athlete in athletes]) / athlete_count
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for lane in range(1, lane_count+1):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: G.add_node(lane)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for athlete in athletes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: athlete_name = athlete['name']
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: preferred_lane = athlete['preferred_lane']
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: athlete_height = athlete['height']
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for lane in range(1, lane_count+1):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: score = lane_count
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if lane < kwargs.get(''furthest_inner_lane'', 3):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: score -= (1.0 / lane * (athlete_height - average_height))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: score -= abs(preferred_lane - lane)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: G.add_edge(athlete_name, lane, weight=score)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: start_time = time.time()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: matches = matching.max_weight_matching(G, maxcardinality=True)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total_time = (time.time() - start_time) * 1000
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print ''match time: %sms'' % total_time'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return matches
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: import time
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: athletes = [
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dict(name='Sanya Richards-Ross', height=68.0, preferred_lane=4),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: dict(name='Carmelita Jeter', height=64.0, preferred_lane=5),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: dict(name='Wyomia Tyus', height=68.0, preferred_lane=6),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: dict(name='Veronica Campbell-Brown', height=65.0, preferred_lane=6),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: dict(name='Florence Griffith-Joyner', height=67.0, preferred_lane=5),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: dict(name='Wilma Rudolph', height=71.0, preferred_lane=6),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: dict(name='Allyson Felix', height=66.0, preferred_lane=4),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: dict(name='Gail Devers', height=63.0, preferred_lane=4)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lane_count = 8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lanes = range(1, lane_count + 1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lane_matches = lane_matching(athletes, lanes)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print lane_matches
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code for creating the heats for the
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: '48'
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  prefs: []
  type: TYPE_NORMAL
- en: '52'
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  prefs: []
  type: TYPE_NORMAL
- en: '59'
  prefs: []
  type: TYPE_NORMAL
- en: '60'
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  prefs: []
  type: TYPE_NORMAL
- en: '66'
  prefs: []
  type: TYPE_NORMAL
- en: '67'
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  prefs: []
  type: TYPE_NORMAL
- en: '71'
  prefs: []
  type: TYPE_NORMAL
- en: '72'
  prefs: []
  type: TYPE_NORMAL
- en: '73'
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  prefs: []
  type: TYPE_NORMAL
- en: '75'
  prefs: []
  type: TYPE_NORMAL
- en: '76'
  prefs: []
  type: TYPE_NORMAL
- en: '77'
  prefs: []
  type: TYPE_NORMAL
- en: '78'
  prefs: []
  type: TYPE_NORMAL
- en: '79'
  prefs: []
  type: TYPE_NORMAL
- en: '80'
  prefs: []
  type: TYPE_NORMAL
- en: '81'
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  prefs: []
  type: TYPE_NORMAL
- en: '83'
  prefs: []
  type: TYPE_NORMAL
- en: '84'
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  prefs: []
  type: TYPE_NORMAL
- en: '86'
  prefs: []
  type: TYPE_NORMAL
- en: '87'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: 'def exponential_moving_average(iterable, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: iterable_size = len(iterable)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: alpha = kwargs.get('alpha', 2.0 / (iterable_size + 1))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: numerator = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: denominator = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: base_factor = 1 - alpha
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for i in range(iterable_size):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not i:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: numerator = iterable[i]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: denominator = 1.0
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: factor = math.pow(base_factor, i)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: numerator += factor * iterable[i]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: denominator += factor
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return numerator / denominator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def time_series_exponential_moving_average(iterable, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: iterable_size = len(iterable)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: alpha = kwargs.get('alpha', 2.0 / (iterable_size + 1))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: numerator = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: denominator = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: base_factor = 1.0 - alpha
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for i in range(iterable_size):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: date, value = iterable[i]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not i:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: numerator = value
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: denominator = 1.0
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: previous_date = date
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: time_difference = 0.0
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: time_difference = time_difference + (previous_date - date).days
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not time_difference:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: time_difference = 1.0
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: factor = math.pow(base_factor, time_difference)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: numerator += factor * value
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: denominator += factor
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: previous_date = date
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return numerator / denominator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: import time
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import csv
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import datetime
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: file_name = 'performances.csv'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'with open(file_name, ''rb'') as input_file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: data = list(csv.DictReader(input_file))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: athlete_lookup = dict()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for performance in data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: entity_id = performance['entity_id']
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: performance['date'] = datetime.datetime.strptime(performance['date'], '%Y-%m-%d')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: performance['value'] = float(performance['value'])
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if entity_id not in athlete_lookup:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: athlete_lookup[entity_id] = dict(entity_id=entity_id, performances=[])
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if performance[''value'']:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: athlete_lookup[entity_id]['performances'].append(performance)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: athletes = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for athlete, performance_data in athlete_lookup.items():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dated_performances = [(performance['date'], performance['value']) for performance
    in performance_data['performances'][::-1]]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: raw_performances = [performance['value'] for performance in performance_data['performances'][::-1]]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: performance_count = len(raw_performances)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if performance_count:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: average = sum(raw_performances) / performance_count
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ema = exponential_moving_average(raw_performances, alpha=0.7)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: tsema = time_series_exponential_moving_average(dated_performances, alpha=0.7)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: average = ema = tsema = 0
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: performance_data['average'] = average
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: performance_data['ema'] = ema
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: performance_data['tsema'] = tsema
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: athletes.append(performance_data)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: heat_size = 10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: heats = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'athletes = sorted(athletes, key=lambda athlete: athlete[''tsema''])'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: heat = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for athlete in athletes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: heat.append(athlete)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if len(heat) == heat_size or athlete == athletes[-1]:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: heats.append(heat)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: heat = []
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print heats
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]*'
  prefs: []
  type: TYPE_NORMAL
