<!--yml

category: 未分类

date: 2024-05-27 14:40:15

-->

# 保持代码简单：通过避免过度工程化实现快速前进

> 来源：[https://graphite.dev/blog/keeping-code-simple](https://graphite.dev/blog/keeping-code-simple)

在工程中，我总是以最简洁的架构来构建最小的规范。为什么呢？因为我想尽快构建软件。时间紧张，注意力不足，我希望尽快获得反馈。快速前进是一个常见的目标，但意图性也非常重要。在压力下，很容易跳过规划阶段，但匆忙的开发周期通常会导致降低质量标准，同时无意识地过度工程化。

我的建议：如果你想快速前进，尽可能编写干净简洁的代码。

**注意**

格雷格花费整个工作日撰写关于工程实践和开发工具的每周深入分析文章。这得益于这些文章帮助推广 Graphite。如果你喜欢这篇文章，今天就试试[Graphite](https://graphite.dev?utm_source=blog-note)，并开始提高 30% 的交付速度！

## **紧急地慢慢构建待办事项列表**[](/blog/keeping-code-simple#urgently-building-a-todo-list-slowly)

考虑以下故事：你正在开发一个新的待办事项应用程序。你首先澄清产品需求并制定简单的设计文档。你被告知待办事项需要支持添加和删除，并且当然，需要在会话之间保存列表。标准需求。

在设计文档中，一些工程师的第一个问题可能是：“我应该使用哪个前端框架来渲染列表？我应该使用哪个数据库来存储数据？我可能需要的 ORM 来读写数据存储？如果列表变得很长，我是否需要对其进行虚拟化以提高性能？”

默认答案可能涉及选择最新的前端框架，在 SQLite 存储中存储数据，并使用当下的 ORM 访问数据。你可能可以推迟虚拟化列表的处理，尽管也许有一个简单的库可以使用。当然，在你考虑虚拟化时，你甚至可能会诱惑将整个应用程序容器化。

加入更多现实主义的故事，假设你在编码待办列表时，你的经理和产品经理开始逼近你。时间不多了，功能昨天就该上线。你开始打字速度更快，但也开始跳过干净的编码模式。你的函数变得更加耦合，到处直接调用外部库，并跳过编写任何单元测试。一路上，你还随处削减和修改范围，把最初的规范大幅度削减。

任务清单按时发货，尽管会有比预期更多的错误。 不幸的是，你的工作还没有完成。 你对 SQLite 和虚拟化的精彩运用让任务清单在不降低性能的情况下存储数百万元素，但产品却向你抛出了一个曲线球。 根据用户反馈，下一个进化需要将清单同步到云端。 是时候放弃你的 SQLite 实现了——此外，你还需要重构代码中散乱的 ORM 调用。 这是可行的，但需要一些时间…

## **更快地构建待办事项清单**[](/blog/keeping-code-simple#building-the-todo-list-faster)

我会在这里结束故事，因为这一切都太熟悉了。 我经常陷入这种陷阱，甚至偶尔自己也会上当——在交付松散的架构的同时，过度工程化性能、可扩展性和安全性。 这不可避免地会降低质量，因为更多时间用于调试和迭代更改的慢估计成本，而过度工程化的规范往往永远不会被使用。

假设产品需求在未来不会发生显著变化，并且即使变化，你也预测到了这些变化。 过度工程化试图预测未来，而质量工程化则是最大化可扩展性。

我坚信编写干净的代码和编写混乱的代码一样快——尽管这可能需要更多的经验和智慧。 质量软件是*柔软的*——易于重塑。 让我们再次看看我们之前的待办事项清单，但这次实现得更加干净，使其更具可塑性。

最低规范的数据存储需要能够读写数千条文本记录。 未来可能需要更快、更大、更安全或由网络支持的存储。 但你现在还不知道，所以你能做的最好的事情就是推迟决定，并将数据存储放在一个窄接口后面。 编写一个具有简单通用读写接口的模块，并为你的 MVP，最初将整个数据存储实现为写入磁盘的 JSON blob。

你刚刚节省了一天的时间，在数据库上摸索和阅读别人建立的 ORM 文档。 此外，你成功地实现了明智的依赖反转模式。 所有数据调用都通过你拥有的接口路由，而简单的 JSON 存储可能足够快速，可以永远持续。 此外，你始终可以通过简单更新数据模块，未来将其切换到云存储。 无需调整任何应用逻辑，通过保持代码清晰和灵活，你使未来的改进*更快*和更安全。

## 为什么过度工程化很慢[](/blog/keeping-code-simple#why-over-engineering-is-slow)

过度工程化之所以低效，有两个根本原因：

1.  浪费的时间：任何不必要的功能都会耗费实现时间，这些时间本可以用来实现其他必要的功能。

1.  开发放慢：额外的特性导致额外的复杂性。代码库的复杂性减缓了未来的开发速度。

第一个观点是显而易见的，第二个最好通过这本书的引用来解释 [“软件设计哲学”](https://www.goodreads.com/en/book/show/39996759)：

> 随着程序的演变和功能的增加，它变得复杂起来，其组件之间存在微妙的依赖关系。随着时间的推移，复杂性累积，程序员在修改系统时难以记住所有相关因素。这减慢了开发速度，导致错误，进而减慢了开发并增加了成本。程序越大，参与开发的人数越多，管理复杂性就越困难。

通过保持核心架构尽可能简单，您避免增加不必要的复杂性。您编写的代码净额外，并且每个必要的特性更容易插入。

## 尽可能推迟复杂性[](/blog/keeping-code-simple#punt-complexity-as-long-as-possible)

考虑这段关于测试自动化Web服务器 [FitNesse](https://en.wikipedia.org/wiki/FitNesse) 开发的摘录，出自优秀的工程书籍“清洁架构”：

> 另一个早期决策是避免考虑数据库。我们有MySQL在脑海中，但我们故意通过采用一个使这个决策变得无关紧要的设计来推迟决策。这个设计只是在所有数据访问和数据仓库之间放置一个接口。
> 
> 我们将数据访问方法放入一个名为`WikiPage`的接口中。这些方法提供了我们需要的所有查找、获取和保存页面的功能。当然，最初我们没有实现这些方法；在我们工作于不涉及获取和保存数据的特性时，我们只是对它们进行了存根处理。
> 
> 的确，三个月来我们只是专注于将维基文本翻译为HTML。这并不需要任何形式的数据存储，因此我们创建了一个名为`MockWikiPage`的类，它只是留下了存根数据访问方法。
> 
> 最终，这些存根对于我们想要编写的特性变得不够。我们需要真正的数据访问，而不是存根。因此，我们创建了一个名为`InMemoryPage`的`WikiPage`衍生类。这个衍生类实现了管理wiki页面哈希表的数据访问方法，我们将其保存在RAM中。
> 
> 这使我们能够连续一整年地编写特性。事实上，我们完全通过这种方式让`FitNesse`程序的第一个版本运行起来了。我们可以创建页面，链接到其他页面，进行所有花哨的维基格式化，甚至用FIT运行测试。但我们做不到的是保存我们的任何工作。
> 
> 到了实现持久化的时候，我们重新考虑了MySQL，但决定短期内不必要，因为把哈希表写成平面文件真的很容易。因此，我们实现了`FileSystemWikiPage`，只是把功能移到了平面文件上，然后我们继续开发更多功能。
> 
> 三个月后，我们得出结论认为平面文件解决方案已经足够好；我们决定完全放弃MySQL的想法。我们将那个决定推迟到不存在，并且再也没有回头看过。
> 
> 如果不是一个客户决定将wiki放入MySQL以满足自己的目的，故事就结束了。我们向他展示了能够让我们推迟决策的`WikiPages`架构。他一天后用MySQL完全搞定了整个系统。他只是编写了一个`MySqlWikiPage`的衍生版本并让它运行起来。
> 
> 我们过去会将这个选项与`FitNesse`捆绑在一起，但其他人从来没有使用过，所以最终我们放弃了。甚至是编写衍生产品的客户最终也放弃了。
> 
> 在`FitNesse`的早期开发阶段，我们在业务规则和数据库之间划定了一个*边界线*。这条线不允许业务规则了解除了简单数据访问方法之外的数据库任何信息。这个决定使我们能够推迟选择和实现数据库超过一年。它让我们可以尝试文件系统选项，并且在发现更好的解决方案时改变方向。然而，它并没有阻止或甚至妨碍想要使用原始方向（MySQL）的人。
> 
> 我们在18个月的开发过程中没有运行数据库的事实意味着在这18个月里，我们没有模式问题、查询问题、数据库服务器问题、密码问题、连接时间问题以及其他任何在启动数据库时显现的麻烦。这也意味着我们所有的测试运行得很快，因为没有数据库来拖慢它们。
> 
> 简而言之，划定边界线帮助我们延迟决策，最终节省了大量时间和头疼。而这正是一个良好架构应该做到的。

这里的主要教训是始终以最简单的方式满足产品需求的核心功能，而不将自己锁定在特定的实现方式上。这样，您可以轻松地模块化添加或修改功能，而无需从头开始重建。

## **核心原则**[](/blog/keeping-code-simple#core-principle)

工程师们应该按时建立到需要的最低产品规格，同时坚持高质量的工程标准。为了遵循简单、清晰编码的最佳实践，优先考虑：

+   单元测试

+   代码检查工具

+   窄接口

+   低耦合

+   清晰的变量名

暂时放弃：

+   强大的数据存储

+   复杂的API

+   无必要的框架

工程化的最快方法是尽可能地推迟决策——通常是通过将核心应用逻辑与未来可能更改的依赖项分离。

在Graphite项目中，有时我做得对，有时我做得不对。我们的业务逻辑最初在[超过一千个调用点](https://graphite.dev/blog/call-site-attribution)中显然调用了GitHub和TypeORM。这使得库升级变得不可测试且灾难性。最终，我们偿清了这笔债务，并将它们迁移到我们拥有的接口后面，具有可测试的接口。

另一次，我在首次尝试中干净地设计了事务性电子邮件。尽管有过度工程化的诱惑，我编写了一个只有一个方法`sendEmail`的电子邮件模块，它隐藏了关于电子邮件客户端和日志记录的细节。最终，我们迁移了电子邮件发送器，但是只用了一个PR且没有bug。

请从我的伤疤中学习。快速行动，编写干净的代码，并且无论如何都要避免过度工程化——简单而高质量的编码几乎总是最快的路径。
