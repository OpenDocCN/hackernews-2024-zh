<!--yml

category: 未分类

date: 2024-05-27 13:34:17

-->

# Type Safety Doesn't Matter - FP Complete

> 来源：[https://www.fpcomplete.com/blog/type-safety-doesnt-matter/](https://www.fpcomplete.com/blog/type-safety-doesnt-matter/)

我坚信使用强类型语言并在我的代码库中利用类型级别的保护措施是非常重要的。但我想澄清一下我的新观点，有些修改：

**类型安全并不重要。**

我的意思是，单独看来，类型安全并不重要。它之所以有用，是因为它完成了什么：将错误从运行时移到编译时。但这本身并不是一个目标。真正的目标是减少运行时错误。类型安全是实现这些级联目标的最佳方法之一，但绝非唯一途径。

这听起来可能有些迂腐和标题党，但在我看来，这是一个具有现实世界影响的极其重要的区别。例如，在讨论代码架构或审查拉取请求时，我经常会反对增加类型系统复杂性的更改。原因是，即使一个改动增加了“类型安全性”，只有在它实现我们的主要目标——即减少运行时错误——时才是合理的。

这样的评估很大程度上是推测性的、主观的，以及基于风险的。在最后一点上，我借鉴了我的精算背景。其核心思想是，当考虑代码变更时，问题始终是：我认为这个变更在长期内是否有显著减少错误数量的可能性，超过了我可以花在其他活动上的时间？如果你看过我的演讲 [函数式编程的经济论证](https://www.youtube.com/watch?v=n7QETok5hYI)（或者阅读了幻灯片](https://www.snoyman.com/reveal/economic-argument-functional-programming)），你可能已经熟悉这种思维方式，称之为在类型安全上花费更多时间的*机会成本*。

这就是为什么提供带有类型推断的强类型语言最终效果非常好。基本类型安全机制的成本相对较低，但收益显著。这就是80/20法则。我继续认为，我从像Rust、Haskell甚至TypeScript这样的强类型语言中获得的绝大多数价值来自“最简单”的特性，比如枚举/代数数据类型和模式匹配。

强类型的好处不仅仅是减少错误。还有：更易于维护的代码库、重构的简单性、新工程师的入职、潜在的性能提升，还有可能有其他我没提到的好处。但对我来说，减少错误仍然是最主要的好处。

通过评估从类型安全性减少 bug 的价值来扩展我们的视野。如果我们想要在生产中减少 bug，并且我们认为将 bug 从运行时移到编译时是一个好方法，我们自然可以找到一些相关的技术。一个显而易见的技术是“静态代码分析”。但我也会使用 80/20 规则来简化到 *linting 工具*。使用 linting 工具是一种以较小成本获取许多好处的好方法。

仅仅为了证明这不仅仅是关于类型，让我们从每个人都喜欢的语言 JavaScript 中的一个具体例子来看。如果我在 JavaScript 中编写 React 应用程序，几乎没有类型安全性。（TypeScript 是另一回事，当我在前端代码上工作时，它是唯一使我保持理智的东西。）考虑一下这段几乎正确的 React 代码片段：

```
const { userName, gameLevel } = props
const [userScore, setUserScore] = useState()

useEffect(() => {
const helper = async () => {
const res = await fetchUserScore(userName, gameLevel)
const body = await res.json()
setUserScore(body.score)
}
helper()
}, [userName, setUserScore]) 
```

对于不熟悉的人来说：`useEffect` 允许我执行某种操作，本例中是从服务器异步加载数据。这是 React 中的常见模式。当用户使用此应用并更改游戏关卡时，我希望执行一个操作，从服务器加载他们当前的分数，并将其设置在一个本地存储中，以便应用的其余部分使用。`useEffect` 接受两个参数：要执行的函数和要使用的依赖项列表。当这些依赖项之一发生变化时，效果将重新运行。

这段代码中有很多改进的空间，但有一个明显的 bug：我的 `useEffect` 依赖列表中没有包括 `gameLevel`。这在运行时会产生 bug：一旦用户的分数加载完毕，我们将永远不会重新加载，尽管已经进入其他关卡。这是一种很容易在手动测试中忽略的 bug，并且很容易进入生产环境。

自动化测试、单元测试、QA 接受指南……基本上所有与质量保证相关的事物都将有助于改善这样的 bug。但在这里，静态分析可能做得更好。上面的代码将立即触发 lint，说“嘿，我看到你在函数中使用了 `gameLevel`，但你没有将其列入你的依赖项。”这是将 bug 从运行时（或至少是开发时）移到编译时（或开发时）的一个典型例子，防止了一整类 bug 的发生，而且不需要任何类型安全性就能实现。当然，它并不能消除每一个潜在的 bug，但它确实消除了大量的 bug。

正如你可能想象的，这篇博文受到了我在工作中遇到的一组特定问题的启发。我考虑在这里详细说明这些细节，如果有兴趣的话，我可以写一篇后续博文，但老实说，具体案例并不是特别有趣。我在这里要表达的是一般原则：

1.  理解为什么要使用类型安全性。它是为了防止某种类型的 bug 发生吗？你花在实现类型安全解决方案上的时间是否在减少 bug 和其他好处方面得到了回报？

1.  有许多其他减少错误的技术值得考虑。静态分析就是其中之一。自动化测试也属于这一类别。不要在选择方法时被意识形态所左右。选择当前处理情况下功率重量比最佳的工具。

[通过电子邮件订阅我们的博客](https://blogtrottr.com/?subscribe=https://www.fpcomplete.com/feed/atom)

电子邮件订阅来自我们的[Atom feed](/feed/atom)，由[Blogtrottr](https://blogtrottr.com)处理。您将仅收到博客文章的通知，并可以随时取消订阅。
