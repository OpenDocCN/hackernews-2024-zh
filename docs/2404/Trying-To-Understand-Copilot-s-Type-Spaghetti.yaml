- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 13:13:38'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 13:13:38'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Trying To Understand Copilot's Type Spaghetti
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试理解Copilot的类型混乱
- en: 来源：[https://rtpg.co/2024/03/07/parsing-copilots-type-spaghetti/](https://rtpg.co/2024/03/07/parsing-copilots-type-spaghetti/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://rtpg.co/2024/03/07/parsing-copilots-type-spaghetti/](https://rtpg.co/2024/03/07/parsing-copilots-type-spaghetti/)
- en: 'The other day [this snippet](https://twitter.com/ataiiam/status/1765089261374914957)
    of Typescript generated by Github copilot was floating around:'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 几天前，[这段代码片段](https://twitter.com/ataiiam/status/1765089261374914957)由Github
    Copilot生成的Typescript正在流传：
- en: '[PRE0]'
  id: totrans-split-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is some type-level programming that can transform an array of field definitions
    into a type. The above is the original code, and I was able to fill in the blanks
    for `TypeMap` and `Parameter` with the following:'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些可以将字段定义数组转换为类型的类型级编程。上面是原始代码，我能够用以下内容填补`TypeMap`和`Parameter`的空白：
- en: '[PRE1]'
  id: totrans-split-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first question is how do you use something like `MappedParameterTypes`?
    I've definitely seen this code in many projects, especially those with bespoke
    ORMs. The basic idea is to map an object configuration to some type.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先的问题是，你如何使用类似`MappedParameterTypes`这样的东西？我肯定在许多项目中看到过这段代码，特别是那些拥有定制ORM的项目。基本思想是将对象配置映射到某种类型。
- en: '[PRE2]'
  id: totrans-split-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I have an object definition, with `foo` being a number, `bar` being a string,
    and `baz` being an enum. I have added `const` everywhere to "make sure" that Typescript
    doesn't lose track of the object literals in `parameters` (a constant thing to
    take care of in type-level programming in Typescript).
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个对象定义，其中`foo`是一个数字，`bar`是一个字符串，`baz`是一个枚举。我已经到处添加了`const`来“确保”Typescript不会丢失`parameters`中的对象字面量（在Typescript的类型级编程中是一个固定的事情要注意）。
- en: 'But the end result here is that `mappedObjs` is of the "type" `{foo: number,
    bar: string, baz: "b" | "c"}[]`. We were able to take our parameter structure
    and transform that into a type.'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: '但最终结果是，`mappedObjs`的“类型”是`{foo: number, bar: string, baz: "b" | "c"}[]`。我们能够将我们的参数结构转换为一种类型。'
- en: This is a very common task in Typescript, and can catch a lot of bugs! If I
    didn't include `foo` or `bar` in the objects, then there would be an error. But
    the code as-written still can be fragile.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Typescript中非常常见的任务，可以捕捉到很多错误！如果在对象中没有包含`foo`或`bar`，那么就会出错。但按照现有的代码，仍然可能很脆弱。
- en: For example, in the above, I can set `baz` to `"a"` or `"d"` and won't get an
    error, despite me having created `baz` as an enum type! I can't set a string,
    but at some point in the type unification process, Typescript decided that `["b",
    "c"] as const` is not `("b" | "c")[]` but instead is just `string[]`.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上面的例子中，我可以将`baz`设置为`"a"`或`"d"`，并不会得到错误，尽管我已经创建了`baz`作为一个枚举类型！我不能设置一个字符串，但在类型统一过程中，Typescript决定`["b",
    "c"] as const`不是`("b" | "c")[]`，而是只是`string[]`。
- en: 'However, if I had written:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我写了：
- en: '[PRE3]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: then this problem disappears. Type programming is a fidget-y process in general.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个问题就消失了。类型编程总的来说是一个不断调整的过程。
- en: Is there a cleaner version of this code?
  id: totrans-split-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这段代码有更简洁的版本吗？
- en: This current type is, quite honestly, not the worst kind of type-level programming
    out there. There's comments, and the indentation is being used to follow the ternary
    flow relatvely well. But errors are a bit illegible because everything is object
    literals.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的类型，坦率地说，并不是最糟糕的类型级编程。有注释，并且缩进被用来相对良好地遵循三元流。但错误有点难以理解，因为一切都是对象字面量。
- en: The simplest thing you can do is factor out some of the type logic into its
    own intermediate types.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的做法就是将一些类型逻辑分解到自己的中间类型中。
- en: '[PRE4]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: here I factored out the enum parameter shape, as well as the logic to extract
    the array.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我分离了枚举参数形状，以及提取数组的逻辑。
- en: Another option would involve factoring out the "required" check, and actually
    including the `string` check higher up directly, avoiding the need for `never`.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择涉及分离出“必需”的检查，并直接在更高层次上包含`string`检查，避免需要`never`。
- en: '[PRE5]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The nice thing with this kind of code is that later on, when you're writing
    your parameter values, you could make sure you're not making a mistake by actually
    annotating the types. Instead of seeing errors on the mapped types, you'll see
    the errors (correctly) shown on the parametesr.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码的好处在于，稍后当你编写参数值时，你可以通过实际标注类型来确保没有犯错。而不是在映射类型上看到错误，你会看到（正确地）显示在参数上的错误。
- en: '[PRE6]'
  id: totrans-split-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This might seem silly on smaller constants like this, but is invaluable when
    composing code, to keep track of where you're at.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这在像这样较小的常量上可能看起来很愚蠢，但在编写代码时非常宝贵，可以帮助你跟踪你所处的位置。
- en: Ultimately this sort of thing is like any one-liner, extremely subjective in
    terms of readability. I was able to walk through the thing and understand how
    it works. But when building these sorts of one-liners and not factoring things
    out you can easily miss the forest for the trees.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这种事情就像任何一个单行器，从可读性角度来说极其主观。我能够浏览这个东西并理解它是如何工作的。但是当构建这些单行时，如果不把事情拆分出来，你很容易把森林看错。
- en: 'For example:'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE7]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Why go through the trouble of writing a type mapping system, only for your code
    to be able to introduce `any[]` because one of your attributes was slightly mistyped?
    This sort of code will lead to type errors being reported in unexpected places
    (or not at all), instead of where the error actually came from.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要费力写一个类型映射系统，只是为了你的代码能够引入`any[]`，因为你的属性被轻微地拼写错误了？这种代码将导致类型错误报告在意料之外的地方（或者根本不报告），而不是错误实际发生的地方。
- en: I similary find that the `P["requires"] extends false` check being placed somewhat
    haphazardly leads to weird usability issues. I can make an enum or a string or
    number field optional, but I can't make an object field optional?
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我同样发现，放置在有些地方有些令人困惑的检查`P["requires"] extends false`，会导致奇怪的可用性问题。我可以将枚举或字符串或数字字段设置为可选的，但我不能将对象字段设置为可选的？
- en: Losing Information In Type-Level Programming
  id: totrans-split-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在类型级编程中失去信息
- en: I lied a bit above. `EnumParameter< "b" | "c">` causes problems downstream,
    because by annotating the object, we lose whether the element is required or not.
    We also lose the name of the parameter.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上面有点撒谎。`EnumParameter< "b" | "c">` 在下游会引起问题，因为通过注释对象，我们失去了元素是否必需的信息。我们还丢失了参数的名称。
- en: 'Typescript is powerful enough that you can get away with a *lot* by just annotating
    a lot of constant dictionary maps. But really the pedantic way to do this ends
    up being things like the following:'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: Typescript足够强大，你可以通过注释大量的常量字典映射来应付*很多*事情。但真正迂腐的做法最终会变成以下这样：
- en: '[PRE8]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you want to access information about a type, generally speaking you will
    want it to be present *somewhere* in your generic signature. Otherwise, type annotations
    will affect your results. Best case, you "merely" have some ambiguous type errors.
    But worst case, you end up with some implicit `any`s floating around.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问类型的信息，一般来说你会希望它在你的通用签名中的*某个地方*存在。否则，类型注解将影响你的结果。最好的情况是，你“仅仅”有一些模糊的类型错误。但最坏的情况是，你最终会得到一些隐式的`any`在四处飘荡。
- en: The beauty of the original one liner, is that the spaghetti-code is ammenable
    to good UX in Typescript! The world is a cruel place, where annotating and trying
    to make things explicit can make your life harder. Beauty might not be a word
    ammenable to Copilot's "quantum superposition of a million code repositories".
    But it somehow works well enough in many circumstances.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的单行美丽之处在于，在Typescript中，这种意大利面代码对良好的UX是友好的！这个世界是一个残酷的地方，注释和试图使事物显式化可能会让你的生活变得更加困难。美丽可能不是Copilot的“量子叠加的一百万个代码仓库”的一个适合的词。但在许多情况下，它似乎工作得足够好。
- en: But if you want something that is easy to maintain, that unfortunately often
    requires a lot of pedantic work and putting things into generic types.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想要一个易于维护的东西，很不幸，通常需要大量的迂腐工作并将事物放入通用类型中。
- en: 'A core takeaway with type-level programming, at least in Typescript: If you
    want certain information to be used, having it be available in a generic type
    signature will avoid code that "accidentally" works thanks to the type inference
    system.'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型级编程中的一个核心经验教训，至少在Typescript中是如此：如果你希望某些信息被使用，将其作为通用类型签名的一部分可避免因类型推断系统而“意外”工作的代码。
- en: Change The Shape Of Your Problem If You Can
  id: totrans-split-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果可能，改变你的问题的形状
- en: If you're intent on doing this sort of type-level thing, laaning into what is
    easy can save you a lot of time. Instead of using arrays of parameters, maps of
    parameters would reduce the cost of a pedantic type.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算做这种类型级别的事情，倾向于简单易行的方式可以节省大量时间。与其使用参数数组，不如使用参数映射来减少迂腐类型的成本。
- en: '[PRE9]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you have this sort of structure, you can more easily re-use constants defined
    elsewhere. This means that if you do end up with pedantic signatures, you're not
    paying a huge cost for them. And if you have pedantic type signatures, your errors
    might also be pedantic, but they are more likely to be where the problem is, and
    not downstream.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有了这种结构之后，你可以更容易地重复使用其他地方定义的常量。这意味着，如果你最终得到了一些迂腐的签名，你不需要为它们付出巨大的代价。如果你有了迂腐的类型签名，你的错误可能也很迂腐，但更可能出现在问题所在，而不是在下游。
- en: It's very easy to get asymptotically close to something that works. But often
    times, you might be one slight transformation from something that is much more
    straightforward. For example, here, decoupling the naming and the requiredness
    from the type development might lead to more lines of codes, but that are easier
    to grok.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易接近一些基本可行的解决方案。但通常情况下，你可能只需稍作调整，就能找到更为直接的解决方案。例如，在这里，将命名和类型开发中的必要性解耦可能会导致更多行的代码，但更易于理解。
- en: 'But I have to be honest: I tried a couple "easy win" refactors, and often would
    hit some other problem. Sometimes the clean answer requires some good inspiration.'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但我必须诚实地说：我尝试了几次“简单胜利”的重构，经常会遇到其他问题。有时，清晰的答案需要一些良好的灵感。
- en: If you are curious about diving deeper into this sort of type-level programming,
    I highly recommend [Execute Program's Advanced Typescript Course](https://www.executeprogram.com/courses/advanced-typescript).
    It offers a very detailed look into how you can accomplish very powerful things,
    with more detail than you'll find simply looking at the Typescript Handbook.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对深入研究这种类型级编程感兴趣，我强烈推荐[Execute Program 的高级 TypeScript 课程](https://www.executeprogram.com/courses/advanced-typescript)。它提供了非常详细的探索，展示了如何实现非常强大的功能，比你仅仅查看
    TypeScript 手册要详细得多。
