- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:13:38'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Trying To Understand Copilot's Type Spaghetti
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://rtpg.co/2024/03/07/parsing-copilots-type-spaghetti/](https://rtpg.co/2024/03/07/parsing-copilots-type-spaghetti/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The other day [this snippet](https://twitter.com/ataiiam/status/1765089261374914957)
    of Typescript generated by Github copilot was floating around:'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-7
  prefs: []
  type: TYPE_PRE
- en: 'This is some type-level programming that can transform an array of field definitions
    into a type. The above is the original code, and I was able to fill in the blanks
    for `TypeMap` and `Parameter` with the following:'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-9
  prefs: []
  type: TYPE_PRE
- en: The first question is how do you use something like `MappedParameterTypes`?
    I've definitely seen this code in many projects, especially those with bespoke
    ORMs. The basic idea is to map an object configuration to some type.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-11
  prefs: []
  type: TYPE_PRE
- en: I have an object definition, with `foo` being a number, `bar` being a string,
    and `baz` being an enum. I have added `const` everywhere to "make sure" that Typescript
    doesn't lose track of the object literals in `parameters` (a constant thing to
    take care of in type-level programming in Typescript).
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: 'But the end result here is that `mappedObjs` is of the "type" `{foo: number,
    bar: string, baz: "b" | "c"}[]`. We were able to take our parameter structure
    and transform that into a type.'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: This is a very common task in Typescript, and can catch a lot of bugs! If I
    didn't include `foo` or `bar` in the objects, then there would be an error. But
    the code as-written still can be fragile.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the above, I can set `baz` to `"a"` or `"d"` and won't get an
    error, despite me having created `baz` as an enum type! I can't set a string,
    but at some point in the type unification process, Typescript decided that `["b",
    "c"] as const` is not `("b" | "c")[]` but instead is just `string[]`.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if I had written:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
- en: then this problem disappears. Type programming is a fidget-y process in general.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: Is there a cleaner version of this code?
  id: totrans-split-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This current type is, quite honestly, not the worst kind of type-level programming
    out there. There's comments, and the indentation is being used to follow the ternary
    flow relatvely well. But errors are a bit illegible because everything is object
    literals.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: The simplest thing you can do is factor out some of the type logic into its
    own intermediate types.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
- en: here I factored out the enum parameter shape, as well as the logic to extract
    the array.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: Another option would involve factoring out the "required" check, and actually
    including the `string` check higher up directly, avoiding the need for `never`.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
- en: The nice thing with this kind of code is that later on, when you're writing
    your parameter values, you could make sure you're not making a mistake by actually
    annotating the types. Instead of seeing errors on the mapped types, you'll see
    the errors (correctly) shown on the parametesr.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-27
  prefs: []
  type: TYPE_PRE
- en: This might seem silly on smaller constants like this, but is invaluable when
    composing code, to keep track of where you're at.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately this sort of thing is like any one-liner, extremely subjective in
    terms of readability. I was able to walk through the thing and understand how
    it works. But when building these sorts of one-liners and not factoring things
    out you can easily miss the forest for the trees.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
- en: Why go through the trouble of writing a type mapping system, only for your code
    to be able to introduce `any[]` because one of your attributes was slightly mistyped?
    This sort of code will lead to type errors being reported in unexpected places
    (or not at all), instead of where the error actually came from.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: I similary find that the `P["requires"] extends false` check being placed somewhat
    haphazardly leads to weird usability issues. I can make an enum or a string or
    number field optional, but I can't make an object field optional?
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: Losing Information In Type-Level Programming
  id: totrans-split-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I lied a bit above. `EnumParameter< "b" | "c">` causes problems downstream,
    because by annotating the object, we lose whether the element is required or not.
    We also lose the name of the parameter.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Typescript is powerful enough that you can get away with a *lot* by just annotating
    a lot of constant dictionary maps. But really the pedantic way to do this ends
    up being things like the following:'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
- en: If you want to access information about a type, generally speaking you will
    want it to be present *somewhere* in your generic signature. Otherwise, type annotations
    will affect your results. Best case, you "merely" have some ambiguous type errors.
    But worst case, you end up with some implicit `any`s floating around.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of the original one liner, is that the spaghetti-code is ammenable
    to good UX in Typescript! The world is a cruel place, where annotating and trying
    to make things explicit can make your life harder. Beauty might not be a word
    ammenable to Copilot's "quantum superposition of a million code repositories".
    But it somehow works well enough in many circumstances.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: But if you want something that is easy to maintain, that unfortunately often
    requires a lot of pedantic work and putting things into generic types.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: 'A core takeaway with type-level programming, at least in Typescript: If you
    want certain information to be used, having it be available in a generic type
    signature will avoid code that "accidentally" works thanks to the type inference
    system.'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: Change The Shape Of Your Problem If You Can
  id: totrans-split-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're intent on doing this sort of type-level thing, laaning into what is
    easy can save you a lot of time. Instead of using arrays of parameters, maps of
    parameters would reduce the cost of a pedantic type.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
- en: When you have this sort of structure, you can more easily re-use constants defined
    elsewhere. This means that if you do end up with pedantic signatures, you're not
    paying a huge cost for them. And if you have pedantic type signatures, your errors
    might also be pedantic, but they are more likely to be where the problem is, and
    not downstream.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: It's very easy to get asymptotically close to something that works. But often
    times, you might be one slight transformation from something that is much more
    straightforward. For example, here, decoupling the naming and the requiredness
    from the type development might lead to more lines of codes, but that are easier
    to grok.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: 'But I have to be honest: I tried a couple "easy win" refactors, and often would
    hit some other problem. Sometimes the clean answer requires some good inspiration.'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about diving deeper into this sort of type-level programming,
    I highly recommend [Execute Program's Advanced Typescript Course](https://www.executeprogram.com/courses/advanced-typescript).
    It offers a very detailed look into how you can accomplish very powerful things,
    with more detail than you'll find simply looking at the Typescript Handbook.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
