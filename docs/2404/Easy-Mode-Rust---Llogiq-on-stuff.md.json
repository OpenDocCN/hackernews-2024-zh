["```\n// Don't nest patterns in match arms\nmatch err_opt_val {\n  Some(Err(e)) => panic!(\"{e}\"),\n  _ => (),\n}\n\n// instead, nest `match` expressions\nmatch err_opt_val {\n  Some(err_val) => match err_val {\n    Err(e) => panic!(\"{e}\"),\n    _ => (),\n  },\n  _ => (),\n}\n\n// Don't use guards\nmatch w {\n  Some(x) if x > 3 => { one(x) },\n  Some(x) => { other(x) },\n  None => (),\n}\n\n// instead, nest with `if`\n// (that might require you to copy code)\nmatch w {\n  Some(x) => {\n    if x > 3 {\n      one(x)\n    } else {\n      other(x)\n    }\n  },\n  None => (),\n} \n```", "```\nfor item in items.iter() {\n  if predicate(item) {\n    items.push(modify(item));\n  }\n} \n```", "```\n Compiling unfortunate v0.0.1\nerror[E0502]: cannot borrow `items` as mutable because it is also borrowed as immutable\n  --> src/main.rs:16:13\n   |\n13 |     for item in items.iter() {\n   |                 ------------\n   |                 |\n   |                 immutable borrow occurs here\n   |                 immutable borrow later used here\n...\n16 |             items.push(new_item);\n   |             ^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\nFor more information about this error, try `rustc --explain E0502`. \n```", "```\n//               vvvvvvvv\nfor item in items.clone().iter() {\n  if predicate(item) {\n    items.push(modify(item));\n  }\n} \n```", "```\nfor i in 0..items.len() {\n  if predicate(&items[i]) {\n    let new_item = modify(&items[i]);\n    items.push(new_item);\n  }\n} \n```", "```\nfn main() {\n  println!(\"Hello, World!\");\n} \n```", "```\nmacro_rules! make_foo {\n  { $($a:ident),* } => { $(let $a = { \"foo\" };)* };\n}\nmake_foo!(a, b); \n```", "```\nlet a = { \"foo\" };\nlet b = { \"foo\" }; \n```", "```\nfn format_code(names: &[&str]) -> String {\n  let mut result = String::new();\n  for name in names {\n    result += format!(\"\\nlet {name} = \\\"foo\\\";\");\n  }\n  result\n} \n```", "```\n#[test]\nfn update_code() {\n  let (prefix, actual, suffix) = read_code();\n  let expected = format_code(&[\"a\", \"b\"]);\n  if expected == actual { return; }\n  write_code(prefix, expected, suffix);\n  panic!(\"updated generated code, please commit\");\n} \n```", "```\nstruct Foo<A, B> { .. }\nfn foo<A, B>(a: A, b: B) { .. } \n```", "```\n// given `struct X; struct Y`\nstruct FooXY { .. }\nfn foo_x_y(a: X, b: Y) { .. } \n```", "```\nstruct Borrowed<'a>(&'a u32);\nfn borrowing<'a, 'b>(a: &'a str, b: &'b str) -> &'a str { .. } \n```", "```\nstruct Arced(Arc<u32>);\nfn cloned(a: String, b: String) -> String { .. }\nfn arced(a: Arc<String>, b: Arc<String>) -> String { .. } \n```", "```\n#[derive(Copy, Clone, Default, Eq, PartialEq, Hash)]\nstruct MyVeryBadExampleIAmSoSorry {\n  size: usize,\n  makes_sense: bool,\n} \n```", "```\npub fn a() {}\npub fn b() {} \n```", "```\nmod b;\npub use b::b;\n\npub fn a() {}\npub fn b() {} \n```", "```\nuse super::*;\n\n// moved from `lib.rs`:\npub fn b() {} \n```", "```\npub mod b; // added `pub` here\n//pub use b::b; <-- no longer needed\n\npub fn a() {} \n```", "```\nvec![\"start\", \"more\", \"end\"] \n```", "```\nHashMap::from([\n  (\"recursion\", \"please look at recursion\"),\n]) \n```", "```\nfn return_custom_iterator() -> Box<dyn Iterator<Item = MyItemType>> {\n  // let's say we filter and map an effectively infinite range of integers\n  let iter = (0_usize..).filter(predicate).map(modify);\n  Box::new(iter) as Box<dyn Iterator<Item = MyItemType>>\n} \n```"]