["```\npackage numbers\n\nfunc addNumbers(numbers ...int) int {\n\tsum := 0\n\n\tfor _, number := range numbers {\n\t\tsum += number\n\t}\n\n\treturn sum\n} \n```", "```\npackage numbers\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_addNumbers(t *testing.T) {\n\tif addNumbers(3, 7) != 10 {\n\t\tt.FailNow()\n\t}\n} \n```", "```\nok      github.com/example/package/numbers \n```", "```\n--- FAIL: Test_addNumbers (0.00s)\nFAIL\nFAIL    github.com/example/package/numbers    0.255s\nFAIL \n```", "```\npackage numbers\n\nimport (\n\t\"testing\"\n)\n\ntype addNumbersTestCase struct {\n  inputs []int\n  expectedOutput int\n}\n\nfunc Test_addNumbers_table(t *testing.T) {\n\ttestCases := []addNumbersTestCase{\n\t\t{\n\t\t\tinputs:         []int{4, 4},\n\t\t\texpectedOutput: 8,\n\t\t},\n\t\t{\n\t\t\tinputs:         []int{10, 0},\n\t\t\texpectedOutput: 10,\n\t\t},\n\t\t{\n\t\t\tinputs:         []int{-1, 1},\n\t\t\texpectedOutput: 0,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tactual := addNumbers(testCase.inputs...)\n\t\tif testCase.expectedOutput != actual {\n\t\t\tt.FailNow()\n\t\t}\n\t}\n} \n```", "```\npackage whatever\n\nfunc TestQuerier_GetWebhook(t *testing.T) {\n\ttype fields struct {\n\t\ttracer                  tracing.Tracer\n\t\tlogger                  logging.Logger\n\t\tsecretGenerator         random.Generator\n\t\toauth2ClientTokenEncDec encryption.EncryptorDecryptor\n\t\tgeneratedQuerier        generated.Querier\n\t\ttimeFunc                func() time.Time\n\t\tconfig                  *dbconfig.Config\n\t\tdb                      *sql.DB\n\t\tmigrateOnce             sync.Once\n\t}\n\ttype args struct {\n\t\tctx         context.Context\n\t\twebhookID   string\n\t\taccountID string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\tfields  fields\n\t\targs    args\n\t\twant    *types.Webhook\n\t\twantErr assert.ErrorAssertionFunc\n\t}{\n\t\t// TODO: Add test cases.  }\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tq := &Querier{\n\t\t\t\ttracer:                  tt.fields.tracer,\n\t\t\t\tlogger:                  tt.fields.logger,\n\t\t\t\tsecretGenerator:         tt.fields.secretGenerator,\n\t\t\t\toauth2ClientTokenEncDec: tt.fields.oauth2ClientTokenEncDec,\n\t\t\t\tgeneratedQuerier:        tt.fields.generatedQuerier,\n\t\t\t\ttimeFunc:                tt.fields.timeFunc,\n\t\t\t\tconfig:                  tt.fields.config,\n\t\t\t\tdb:                      tt.fields.db,\n\t\t\t\tmigrateOnce:             tt.fields.migrateOnce,\n\t\t\t}\n\t\t\tgot, err := q.GetWebhook(tt.args.ctx, tt.args.webhookID, tt.args.accountID)\n\t\t\tif !tt.wantErr(t, err, fmt.Sprintf(\"GetWebhook(%v, %v, %v)\", tt.args.ctx, tt.args.webhookID, tt.args.accountID)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Equalf(t, tt.want, got, \"GetWebhook(%v, %v, %v)\", tt.args.ctx, tt.args.webhookID, tt.args.accountID)\n\t\t})\n\t}\n} \n```", "```\npackage numbers\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_addNumbers(t *testing.T) {\n\tt.Parallel()\n\n\texpected := 10\n\tactual := addNumbers(3, 7)\n\n\tif expected != actual {\n\t\tt.FailNow()\n\t}\n} \n```", "```\npackage numbers\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_addNumbers(T *testing.T) {\n\tT.Parallel()\n\n\tT.Run(\"standard\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texpected := 10\n\t\tactual := addNumbers(3, 7)\n\n\t\tif expected != actual {\n\t\t\tt.FailNow()\n\t\t}\n\t})\n} \n```", "```\npackage numbers\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_addNumbers(T *testing.T) {\n\tT.Parallel()\n\n\tT.Run(\"standard\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texpected := 10\n\t\tactual := addNumbers(3, 7)\n\n\t\tif expected != actual {\n\t\t\tt.FailNow()\n\t\t}\n\t})\n\n\tT.Run(\"with many numbers\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texpected := 15\n\t\tactual := addNumbers(1, 2, 3, 4, 5)\n\n\t\tif expected != actual {\n\t\t\tt.FailNow()\n\t\t}\n\t})\n\n\tT.Run(\"with negative numbers\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texpected := 3\n\t\tactual := addNumbers(4, -1)\n\n\t\tif expected != actual {\n\t\t\tt.FailNow()\n\t\t}\n\t})\n} \n```", "```\npackage whatever\n\nimport (\n\t\"github.com/example/project/internal/authorization\"\n\t\"github.com/example/project/internal/pkg/pointer\"\n\t\"github.com/example/project/pkg/types\"\n\n\tfake \"github.com/brianvoe/gofakeit/v7\"\n)\n\nfunc buildFakeTime() time.Time {\n\treturn fake.Date().Add(0).Truncate(time.Second).UTC()\n}\n\nfunc BuildFakeUser() *types.User {\n\tfakeDate := buildFakeTime()\n\n\treturn &types.User{\n\t\tID:                        identifiers.New(),\n\t\tFirstName:                 fake.FirstName(),\n\t\tLastName:                  fake.LastName(),\n\t\tEmailAddress:              fake.Email(),\n\t\tUsername:                  fmt.Sprintf(\"%s_%d_%s\", fake.Username(), fake.Uint8(), fake.Username()),\n\t\tBirthday:                  pointer.To(buildFakeTime()),\n\t\tAccountStatus:             string(types.UnverifiedHouseholdStatus),\n\t\tTwoFactorSecret:           base32.StdEncoding.EncodeToString([]byte(fake.Password(false, true, true, false, false, 32))),\n\t\tTwoFactorSecretVerifiedAt: &fakeDate,\n\t\tServiceRole:               authorization.ServiceUserRole.String(),\n\t\tCreatedAt:                 buildFakeTime(),\n\t}\n} \n```", "```\npackage numbers\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_addNumbers(T *testing.T) {\n\tT.Parallel()\n\n\tT.Run(\"standard\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texpected := 10\n\t\tactual := addNumbers(3, 7)\n\n\t\tassert.Equal(t, expected, actual)\n\t})\n} \n```", "```\npackage whatever\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSomeFunction(T *testing.T) {\n\tT.Parallel()\n\n\tT.Run(\"standard\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tf, err := os.Create(\"some_path.txt\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\t})\n} \n```", "```\npackage something\n\ntype UserRetriever interface {\n\tGetUser(ctx context.Context, userID string) (*User, error)\n} \n```", "```\npackage something\n\nimport (\n\t\"github.com/stretchr/testify/mock\"\n)\n\ntype mockUserRetriever struct {\n\tmock.Mock\n}\n\nfunc (m *mockUserRetriever) GetUser(ctx context.Context, userID string) (*User, error) {\n\treturnValues := m.Called(ctx, userID)\n\n\treturn returnValues.Get(0).(*User), returnValues.Error(1)\n} \n```", "```\npackage something\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/mock\"\n)\n\nfunc TestUserRetrieval(T *testing.T) {\n\tT.Parallel()\n\n\tT.Run(\"standard\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texpected := &User{ID: \"something\"}\n\n\t\tmur := &mockUserRetriever{}\n\t\tmur.On(\"GetUser\", mock.Anything, expected.ID).Return(expected, nil)\n\n\t\t// pass our mock to whatever uses it and test it's functionality  mock.AssertExpectationsForObjects(t, mur)\n\t})\n} \n```", "```\nmock.MatchedBy(func(context.Context) bool { return true }) \n```", "```\npackage whatever\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/example/project/pkg/types\"\n\t\"github.com/example/project/pkg/types/converters\"\n\t\"github.com/example/project/pkg/types/fakes\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"gopkg.in/matryer/try.v1\"\n)\n\nfunc buildDatabaseClientForTest(t *testing.T, ctx context.Context) (*Querier, *postgres.PostgresContainer) {\n\tt.Helper()\n\n\tdbUsername := fmt.Sprintf(\"%d\", hashStringToNumber(t.Name()))\n\ttestcontainers.Logger = log.New(io.Discard, \"\", log.LstdFlags)\n\n\tvar container *postgres.PostgresContainer\n\terr := try.Do(func(attempt int) (bool, error) {\n\t\tvar containerErr error\n\t\tcontainer, containerErr = postgres.RunContainer(\n\t\t\tctx,\n\t\t\ttestcontainers.WithImage(defaultImage),\n\t\t\tpostgres.WithDatabase(splitReverseConcat(dbUsername)),\n\t\t\tpostgres.WithUsername(dbUsername),\n\t\t\tpostgres.WithPassword(reverseString(dbUsername)),\n\t\t\ttestcontainers.WithWaitStrategyAndDeadline(2*time.Minute, wait.ForLog(\"database system is ready to accept connections\").WithOccurrence(2)),\n\t\t)\n\n\t\treturn attempt < 5, containerErr\n\t})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, container)\n\n\tconnStr, err := container.ConnectionString(ctx, \"sslmode=disable\")\n\trequire.NoError(t, err)\n\n\tdbc, err := ProvideDatabaseClient(ctx, logging.NewNoopLogger(), tracing.NewNoopTracerProvider(), &config.Config{ConnectionDetails: connStr, RunMigrations: true, OAuth2TokenEncryptionKey: \"blahblahblahblahblahblahblahblah\"})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, dbc)\n\n\treturn dbc, container\n}\n\nfunc createWebhookForTest(t *testing.T, ctx context.Context, exampleWebhook *types.Webhook, dbc *Querier) *types.Webhook {\n\tt.Helper()\n\n\t// create  if exampleWebhook == nil {\n\t\texampleWebhook = fakes.BuildFakeWebhook()\n\t}\n\tdbInput := converters.ConvertWebhookToWebhookDatabaseCreationInput(exampleWebhook)\n\n\tcreated, err := dbc.CreateWebhook(ctx, dbInput)\n\tassert.NoError(t, err)\n\trequire.NotNil(t, created)\n\n\tassert.Equal(t, exampleWebhook, created)\n\n\twebhook, err := dbc.GetWebhook(ctx, created.ID, created.BelongsToAccount)\n\tassert.NoError(t, err)\n\tassert.Equal(t, webhook, exampleWebhook)\n\n\treturn created\n}\n\nfunc TestQuerier_Integration_Webhooks(t *testing.T) {\n\tctx := context.Background()\n\tdbc, container := buildDatabaseClientForTest(t, ctx)\n\n\tdatabaseURI, err := container.ConnectionString(ctx)\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, databaseURI)\n\n\tdefer func(t *testing.T) {\n\t\tt.Helper()\n\t\tassert.NoError(t, container.Terminate(ctx))\n\t}(t)\n\n\tuser := createUserForTest(t, ctx, nil, dbc)\n\taccountID, err := dbc.GetDefaultAccountIDForUser(ctx, user.ID)\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, accountID)\n\n\texampleWebhook := fakes.BuildFakeWebhook()\n\texampleWebhook.BelongsToAccount = accountID\n\tcreatedWebhooks := []*types.Webhook{}\n\n\t// create  createdWebhooks = append(createdWebhooks, createWebhookForTest(t, ctx, exampleWebhook, dbc))\n\n\t// other tests would go here  // delete  for _, webhook := range createdWebhooks {\n\t\tassert.NoError(t, dbc.ArchiveWebhook(ctx, webhook.ID, accountID))\n\n\t\tvar exists bool\n\t\texists, err = dbc.WebhookExists(ctx, webhook.ID, accountID)\n\t\tassert.NoError(t, err)\n\t\tassert.False(t, exists)\n\n\t\tvar y *types.Webhook\n\t\ty, err = dbc.GetWebhook(ctx, webhook.ID, accountID)\n\t\tassert.Nil(t, y)\n\t\tassert.Error(t, err)\n\t\tassert.ErrorIs(t, err, sql.ErrNoRows)\n\t}\n} \n```", "```\ntype BreakableStruct struct {\n\t\tThing json.Number\n}\n\nfunc TestRenderToJSON(T *testing.T) {\n\tT.Parallel()\n\n\tT.Run(\"with invalid structure\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tx := &BreakableStruct{Thing: \"stuff\"}\n\t\tactual, err := json.Marshal(x)\n\n\t\tassert.Nil(t, actual)\n\t\tassert.Error(t, err)\n\t})\n} \n```", "```\nfmt.Sprintf(`%s://`, string(byte(127))) \n```"]