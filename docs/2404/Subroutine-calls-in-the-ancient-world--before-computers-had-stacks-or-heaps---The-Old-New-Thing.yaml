- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:52:53'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Subroutine calls in the ancient world, before computers had stacks or heaps
    - The Old New Thing
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://devblogs.microsoft.com/oldnewthing/20240401-00/?p=109599](https://devblogs.microsoft.com/oldnewthing/20240401-00/?p=109599)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Subroutine calls in the ancient world, before computers had stacks or heaps
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We take stacks and heaps for granted nowadays, but back in the very old days
    of computing, computers operated without a stack or a heap.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: Tell a recent college graduate this, and you may as well tell them that there
    was a time when you didn’t have instant access to millions of cat videos.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: It’s not too hard to imagine computing without dynamic memory allocation. You
    just have to use fixed-size memory buffers for everything. If you have to operate
    on variable-sized data, you reserved a fixed-size buffer of some capacity that
    is large enough to accommodate any data you would reasonably be expected to process,
    and if somebody asked for more, you just exited the program with a fatal error.
    If you were really nice, you would provide a compile-time configuration so your
    clients could adjust the maximum capacity to suit their datasets. And if you were
    really fancy, you wrote a custom allocator that operated on that fixed-size buffer
    so people could “allocate” and “free” memory from the buffer.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: But operating without a stack? How did you call a function if you didn’t have
    a stack for the return address or local variables?
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how it worked.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: First, the compiler defined a secret global variable for each inbound function
    parameter, plus another secret global variable for each function to hold the return
    address. It also defined a secret global variable for each of the function’s local
    variables.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: To generate a function call, the compiler assigned the parameter values to the
    corresponding secret global variables, assigned the return address to the function’s
    secret “return address variable”, and then jumped to the start of the function.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: The function read its parameters from its secret global variables, and used
    the pre-defined secret global variables that corresponded to its logically local
    variables. When the function was finished, it jumped to the address held in the
    function’s secret “return address variable.”
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you had code like this, written in a C-like language:'
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-16
  prefs: []
  type: TYPE_PRE
- en: 'This would be transformed by the compiler into something like this:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-18
  prefs: []
  type: TYPE_PRE
- en: 'Check it out: We did a function call and return without a stack!'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can optimize the ABI by, say, passing some of these values in registers
    rather than globals. For example, most processors had a special “link” register
    and a special instruction “branch with link” that automatically set the link register
    equal to the address of the instruction after the “branch with link” instruction,
    And maybe you optimize the calling convention to pass the first two parameters
    in registers, resulting in this:'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-21
  prefs: []
  type: TYPE_PRE
- en: 'There was just one catch: You can’t do recursion.'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: Recursion doesn’t work because a recursive call would overwrite the return-address
    variable with the return address of the recursive call, and when the outer call
    completed, it would jump to the wrong place.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The programming languages of the day solved this problem by simply declaring
    it illegal: They didn’t support recursion.¹'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Bonus chatter**: Some compilers were even sneakier and used self-modifying
    code: The special return-address variable was really the address field of the
    jump instruction at the end of the function!'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: 'This was occasionally not so much a sneaky trick as a practical necessity:
    [The processor might not support indirect jumps either](https://en.wikipedia.org/wiki/MIX)!'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: 'After the practical value of subroutines was recognized, quite a few processors
    added a subroutine call instruction that worked by storing the return address
    at the first word of the subroutine, and beginning execution at the second word
    of the subroutine. To return from a subroutine, you execute an indirect jump through
    the subroutine start label. (As I recall, some processors stored the return address
    at the word *before* the first instruction of the subroutine.) Here’s what it
    looked like using a made-up assembly language:'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
- en: When the CPU executed the `bsr` branch-to-subroutine instruction, it stored
    the return address into the first word of `add_two_values` (overwriting the sacrificial
    `nop`) and began execution at the following instruction, the `add r1 = r1, r2`.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: ¹ FORTRAN initially didn’t even support subroutines! Those were added in 1958\.
    And support in FORTRAN for recursion didn’t become standard until 1991, and even
    then, you had to explicitly declare your subroutine as `RECURSIVE`.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
