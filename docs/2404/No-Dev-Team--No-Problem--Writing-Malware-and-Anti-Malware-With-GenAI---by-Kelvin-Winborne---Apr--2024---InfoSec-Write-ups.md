<!--yml

分类：未分类

日期：2024年5月27日13:39:47

-->

# 没有开发团队？没问题：使用GenAI编写恶意软件和反恶意软件 | 作者：Kelvin Winborne | 2024年4月 | InfoSec Write-ups

> 来源：[https://infosecwriteups.com/no-dev-team-no-problem-writing-malware-and-anti-malware-with-genai-cbce13160e13?gi=1ae1a8ad0126](https://infosecwriteups.com/no-dev-team-no-problem-writing-malware-and-anti-malware-with-genai-cbce13160e13?gi=1ae1a8ad0126)

# 没有开发团队？没问题：使用GenAI编写恶意软件和反恶意软件

## 无人参与的安全软件开发，适用于防御和攻击两端。

来源：由Microsoft Copilot生成的图像。

根据您阅读的内容、来源以及作者，软件工程工作面临威胁，无需担心，甚至可以通过生成AI *增强*。

甚至有些公司声称，他们的AI解决方案可以像[完全自主的软件工程师](https://www.cognition-labs.com/introducing-devin)一样运作。或者，也有人反驳说[这并不是真的](https://www.youtube.com/watch?v=tNmgmwEtoWE)。（我在这里进行了改述）

就个人而言，我只是想在开发程序时更轻松些，所以我愿意至少尝试“普通”的生成AI或LLMs。对于这篇博客，我想看看这些工具在初学者编写脚本方面的表现如何，而且不需要用户直接修改。我还试图避免深入阅读代码行并直接建议改进任何由AI生成的脚本。

我最初想到的是尝试让AI开发一个基本的反恶意软件脚本，但是测试其对真实恶意软件的效果让我感觉并不是很舒服。于是我想，有什么比让我自己制作恶意软件更能“信任”它的呢？

唯一的问题是我不是恶意软件或漏洞开发人员，尽管过去曾对此进行过简短研究。关于我的编程能力的一些背景，我可以读、写和编辑Python、Rust和Go的基本脚本。我远非经验丰富的开发人员。所以我的自然思维是，“如果我使用AI来编写我的反恶意软件脚本，那么为什么不用它来编写恶意软件呢？”

然后当我开始构建我的测试虚拟机时，我意识到我需要一个通用的脚本，不一定是针对安全的，来帮助设置我的测试环境。为什么不让AI帮我做第三个呢？

讽刺的是，我最想让AI为我编写的第一个程序，反恶意软件，竟然要在最后才能创建。

# 目标和设置

我的目标是完全使用生成AI或大型语言模型解决方案创建几种类型的功能完整脚本。我目标是三种类型：

+   通用的IT自动化脚本 — 为了节省处理乏味任务的时间。

+   恶意软件 — 我选择勒索软件，因为它的影响最为显著和明显。如果成功或失败都很容易看到。

+   反恶意软件 — 更具体地说是反勒索软件，它必须是基于行为的检测。我不想建立一个只能检测和减轻我为本博客创建的特定勒索软件可执行文件的脚本。基于签名的检测只对特定文件有用。一旦单个字节更改，文件就会有一个新的哈希值。

我特意想要构建这些脚本，而不是直接手动修改*一行代码*。我只想将代码复制粘贴到空的 *.py 文件中并让它们执行。

此文中使用的每个脚本均使用了我一个 Azure OpenAI Web 应用程序之一创建。所有脚本都在我个人机器上的 Debian 12 VM 上进行了测试。所有视频都是使用 [OBS Studio](https://obsproject.com/) 创建的，然后使用 [Adobe Express](https://www.adobe.com/express/feature/video/crop/mp4) 裁剪，并使用 [CloudConvert](https://cloudconvert.com/) 或 [EZgif](https://ezgif.com/) 转换为 GIF。

我创建了三个脚本：

+   **cpauto.py** — 通用的 IT 自动化脚本

+   **rudi_ransom.py** — 勒索软件脚本

+   **rrw.py** — 反勒索软件脚本

现在开始工作吧。

# cpauto.py

（复制粘贴自动化）

首先，我创建了一个单独的垃圾文件来进行加密。最初我制作了10个我手动复制粘贴的文件，而在这期间，我想到了开始自动化这个过程。最初的尝试：

是的，我的主要 Debian VM 用户名为“asdf”，因为我很懒。

在遇到错误时：

在遇到更多“文件已存在”错误后，我输入了另一个提示：

既然现在它试图把文件放在一个单独的目录中，而我不想要这样做，我发出了另一个提示，但在完成时：

之后删除了，然后就到时间了。因为我厌倦了来回操作，我修改了`source_file = “/home/asdf/Documents/looks_important_10.txt”`这一行中的文件名，并将其修改为`source_file = “/home/asdf/Documents/looks_important_1.txt”`。我删除了一个字符，从技术上讲违反了自己的规则，因为我不耐烦。

进行测试！我从名为“looks_important_1.txt”的单个文件开始，然后运行我的脚本：

砰！

它的效果像魔法一样。

完整的脚本：

```
#This is designed to create new 2400 copies of the junk file specified. 

import os
import shutil

source_file = "/home/asdf/Documents/looks_important_1.txt"
destination_folder = "/home/asdf/Documents/"

# Check if the source file exists
if os.path.isfile(source_file):

    # Create 2400 copies of the file with sequential numbering
    for i in range(2, 2401):
        new_file = os.path.join(destination_folder, f"looks_important_{i}.txt")
        shutil.copy(source_file, new_file)

    print("Files copied successfully.")
else:
    print("Source file not found.")
```

所以你看到了。现在我有一整个驱动器的数据准备加密：

还有，数据应该是这样的：

100% 垃圾。

现在我有大约19GB的垃圾数据准备加密，是时候开始加密了。

**AI 对人类的比较**：99% 由 AI 生成

**按预期工作**：是的

# rudi_ransom.py

（初级勒索软件）

我不会撒谎。这让我很害怕。我是在做午饭的时候做的。

我设法在30分钟内完成了这个脚本的初始迭代，并成功测试了其加密能力。只需几个提示。

希望（希望）显而易见的原因，我不会提供我用来生成此勒索软件脚本的具体提示，也不会提供完整的代码。不过，我愿意展示几个片段。

我从`/`目录开始攻击：

```
root_dir = "/"
```

我在加密文件上追加了`.locked`扩展名：

```
new_file_path = file_path + ".locked"
```

我的“赎金笔记”创建在多个目录中：

```
 file_path = os.path.join(directory, "[LOCKED_BY_NOTTA_HACKER].txt")
```

从技术上讲，这不是勒索软件，只是因为我没有打算在执行时存储或记录解密密钥，使数据无法恢复。这意味着这种“勒索软件”在功能上只是一个数据擦除器。出于我的测试目的，我只需要一个仅能进行*加密*的脚本。

为了展示测试加密脚本的有效性：

在几分钟内完成加密后，当它尝试空闲屏幕超时锁定时，它破坏了我的 VM 桌面环境：

因此，我按照这些说明操作：

看起来我失去了对 GUI 桌面环境的访问！

所以在我列出`/home/asdf/Documents/`目录并`cat`其中一个`.locked`文件之后：

现在我必须想办法停止这个。我恢复到快照并继续测试。

**AI vs Human**：100% 由 AI 生成

**按预期运行**：是的（!!!）

# rrw.py

（基本的勒索软件拆除者）

这实际上是最难让它适当工作的脚本，这增加了整个练习的可怕性。同样地，虽然我选择了基于行为的检测反勒索软件脚本，但我不希望它过于细化，以至于只能检测到`rudi_ransom.py`脚本，而是任何表现出类似行为的东西。

我只是对我最早的尝试感到尴尬。为了节省时间，我将从展示我的后续脚本版本 4.0 开始：

与任何由生成性 AI 工具编写的脚本的初始执行一样，我遇到了一些错误。因此，我尝试解决这些错误：

我觉得它已经准备好了，所以我再次执行勒索软件/擦除脚本，这次同时运行系统监视器。在运行 Linux 时，我更倾向于使用`bpytop`。然而：

一切如常……

回到起点……

当我的勒索软件在运行时，我注意到 CPU 使用情况：

所以：

让我们测试最近的更改，然后……：

也许我的 AI 应用程序还让我的勒索软件逃避了防御？

我试图让我的应用程序解决问题：

这听起来像是放弃的话……

总是要礼貌地问。当 AI 统治者接管时……

因此，我再次测试新脚本，然后……：

asdfasfsdafsdafsadfsdafsdaf

也许我把我的勒索软件做得太好了？

我放弃了最后一次聊天，并开始用略微修改的初始提示重新开始一个全新的聊天：

在执行`rudi_ransom.py`时，发生了一些有趣的事情：

好吧，这是我第一次看到我的`rrw.py`脚本有任何操作的迹象。回到我的 AP 应用程序：

我尝试了新版本：

哎呀，至少我知道我的勒索软件运行得很好……（注意：此 GIF 在移动和桌面浏览器中有效。在移动 Medium 应用程序中可能看不到。）

没事！我没事！

好的，是时候再次改变策略了。与其反恶意软件，让我创建更类似于限制应用程序白名单的东西：

因此，当我测试它时……：

进展！（注意：此 GIF 在移动和桌面浏览器中有效。在移动 Medium 应用程序中可能看不到。）

唯一的问题是这会结束多个良性进程。多次尝试仅仅杀死以`python3`为参数启动的进程失败了。最终我到了`rrw.py`的v41版本，唯一能动态阻止勒索软件脚本的迭代是如此严格，它阻止了多个与Linux系统正常运行相关的脚本。我基本上不得不在自己的系统上创建了一个拒绝服务的条件来防止……由勒索软件引发的我的系统的拒绝服务条件。

> KW：与一位同事/导师交谈后，我重新审视了“反恶意软件”角度，并获得了一些检测机会的建议。

我真的很高兴我有这次简短的交谈，因为他给了我不仅使用动态分析（行为）还使用静态分析的想法。所以我接受这一点并发布了一个新的提示：

在后续提示中，我确保包含语言以避免我注意到的一些错误：

所以我去测试`rrw.py`的**VERSION 42**，然后……：

哎呀！（注：此GIF适用于手机和桌面浏览器。在手机Medium应用程序中可能看不到。）

它成功地对文件中包含的字符串进行了静态分析，并基于其中的内容删除了它。但即便如此，它也突显了此脚本的潜在危险，因为它意外删除了位于`/home/asdf/Downloads`目录中的`rrw.py`的早期版本。

虽然`rrw.py`的最新版本已经在运行，我在同一目录中创建了`rudi_ransom.py`的新版本，它能够避免被删除，这意味着`rrw.py`仅在初始执行时扫描该目录*一次*，而不像预期的那样在某种循环中持续执行。只要脚本运行，可以很容易地调整为定期运行，比如每5毫秒运行一次。

让我们看看它如何动态执行：

…（注：此GIF适用于手机和桌面浏览器。在手机Medium应用程序中可能看不到。）

它仍然允许`rudi_ransom.py`无问题地加密。我觉得现在是时候……

这里是供任何人分析的脚本：

```
import os
import time
import psutil

def scan_files(directory):
    for root, dirs, files in os.walk(directory):
        # Exclude hidden directories
        dirs[:] = [d for d in dirs if not d.startswith('.')]
        for file in files:
            file_path = os.path.join(root, file)
            if file.endswith('.py'):
                with open(file_path, 'r') as f:
                    content = f.read()
                    if any(keyword in content for keyword in ['cryptography', 'cryptodome', 'ransom', 'locked', 'encrypt']):
                        os.remove(file_path)

def monitor_filesystem():
    while True:
        for proc in psutil.process_iter(['pid', 'name', 'num_fds']):
            try:
                num_fds = proc.info['num_fds']
                if num_fds >= 20:
                    start_time = time.time()
                    time.sleep(1)
                    end_time = time.time()
                    elapsed_time = end_time - start_time
                    if elapsed_time < 1 and proc.info['num_fds'] >= 20:
                        proc.kill()
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass

def monitor_processes():
    while True:
        for proc in psutil.process_iter(['pid', 'cmdline']):
            try:
                if any('cryptography' in arg for arg in proc.info['cmdline']) and '/home/asdf' in proc.cwd():
                    proc.kill()
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass

if __name__ == '__main__':
    scan_files('/home')
    monitor_filesystem()
    monitor_processes()
```

它绝对需要进一步改进。

**AI vs Human**：100%由AI生成

**Works as Intended**：RAGE

# 结论

再次请记住，我将其视为一个完全不懂如何编辑的新手来处理的。我故意没有仔细查看代码。我希望这是一个锻炼，看看有多容易让生成式AI和LLM仅仅使用错误消息的输出和系统行为来编写完全功能的代码。

事实证明，生成式AI完全可以用来编写基本脚本，只要你给他们明确的要求。所以这很好。然而，根据我的经验，普通聊天机器人需要很多来回提示才能修复错误和幻觉。所以这不好。

我在测试写博客期间，给朋友和同事们播放着各种脚本的不同迭代过程，大家一致认为我凭一时兴起所能做到的事情令人恐惧。

我不想撒谎，我也倾向于同意。我能如此迅速地创建勒索软件/数据擦除脚本确实令人害怕，但花费了多个小时，几天时间，尝试了42个不同版本，并进行了更多次的微小编辑，*失败*于阻止该勒索软件脚本的执行或在执行后将其杀死。我很高兴静态分析部分起作用了，但这有很高的概率会因为误报而导致意外删除。

我只想重申，我在做午餐的时候，让我的人工智能应用程序生成了我的勒索软件脚本 *...*
