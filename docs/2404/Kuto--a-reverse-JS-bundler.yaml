- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:02:29'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Kuto, a reverse JS bundler
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://samthor.au/2024/kuto/](https://samthor.au/2024/kuto/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kuto, a reverse JS bundler
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Kuto](https://kuto.dev) is a novel approach to shipping code on the web. It
    lets you re-use code a client *already has* for shipping updates.'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: 'For a ''real-world'' site with ~3mb of JS, updating the React dependency resulted
    in:'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: 71% smaller download
  id: totrans-split-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28% faster start time (on a ~5yo old phone, a [Pixel 3](https://en.wikipedia.org/wiki/Pixel_3)).
  id: totrans-split-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‚Ä¶vs a single bundle, or any case where all the code is invalidated.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Note that Kuto works really well on the final ESM bundles of real sites or apps,
    but probably *not* libraries themselves, even though Kuto's output will be valid.
    Kuto also works as a predictable 'chunk' generator for large bundles.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: If this is interesting to you‚Äîdo *you* have too much JavaScript?‚Äîthen do the
    thing, and [do a Kuto on your code](https://kuto.dev). (Is Kuto a verb? Who knows.
    I'm trying it out.) ‚úÇÔ∏è
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  id: totrans-split-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of focusing on minifying output or anything idempotent, Kuto takes a
    different route.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first build:'
  id: totrans-split-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kuto splits source JS into a 'main' part, and a normally larger 'corpus' of
    code which has no side effects.
  id: totrans-split-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This corpus can be cached [forever](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#immutable),
    and a hashed timestamp is included in its output name.
  id: totrans-split-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On every further build:'
  id: totrans-split-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kuto still splits out the source JS
  id: totrans-split-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It identifies code from any existing corpus that can be used to 'satisfy' the
    source JS
  id: totrans-split-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each corpus will either stay the same or *shrink* as functions, statements etc
    change
  id: totrans-split-22
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any code that cannot be satisfied is put into a brand new corpus, which can
    also be cached forever.
  id: totrans-split-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a little complicated. Here''s a ~~gif~~ video:'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: <https://storage.googleapis.com/hwhistlr.appspot.com/assets/kuto-demo.mp4>
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: Kuto will build an additional corpus when something changes
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: After each build, you're likely to generate another corpus with changed code.
    (This will eventually be an issue with fragmentation, more on this later.)
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: Why does it work?
  id: totrans-split-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each corpus, once fetched by a client, can be cached forever. However, on every
    build, that corpus *may* shrink in size. New clients will get the smaller version.
    (Kuto's corpuses have a hashed timestamp, and you *do* have to set up your webserver
    to send the [right headers](https://web.dev/articles/love-your-cache) here).
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: But‚Ä¶this breaks all we know about caching responses on the web! I've changed
    an immutable file! ü§Ø
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: The result is that older clients will have bigger files, and newer clients will
    have smaller ones, even for the same filename. But that bigger file simply has
    now-deprecated code. Kuto's primary thesis is that disk I/O to load a slightly
    bigger file than you need is faster than compling anew.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: (Note that at least [v8-based browsers](https://v8.dev/blog/code-caching-for-devs)
    cache the bytecode of the source, which provides the speed benefit. If you were
    compiling anew every time, Kuto wouldn't help.)
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside the remarkably bonkers way this leverages your browser, Kuto also basically
    performs code-splitting in a completely predictable, useful and automated fashion.
    Other bundlers either require you to:'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: (not codesplit an output bundle at all)
  id: totrans-split-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: explicitly mark dependencies to be put into their own bundle
  id: totrans-split-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: put code in bundles on (effectively) random boundaries, just trying to restrict
    the size of each 'chunk'.
  id: totrans-split-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No really, how does it work?
  id: totrans-split-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The above explanation was fairly high-level. At a lower level, Kuto looks for
    code with no side effects to include in its corpuses, and it uses circular dependencies
    to ensure they're safe to call.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: No Side Effects
  id: totrans-split-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Turns out, defining a function has no side effects. No, really! The *definition*
    of a function does nothing except creates a variable:'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-41
  prefs: []
  type: TYPE_PRE
- en: 'Since `foo` isn''t *actually called*, and we declare it in a module scope,
    nothing happens. Until we run `foo`, it might as well be:'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-43
  prefs: []
  type: TYPE_PRE
- en: Kuto takes this theory to the extreme, putting classes into the same form, and
    even arbitrary statements. We *hand wave* can hoist statements to be within a
    function.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: Circular Dependencies
  id: totrans-split-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each corpus contains silo'ed^ functions which reference back to the main file
    in order to work out their dependencies. A good way to see this is to check out
    Kuto itself and run its "./release.sh" script, which builds Kuto itself this way.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: 'For a trivial site that appends a custom element to your page, where the custom
    element has changed and been rebuilt, this might look like:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-48
  prefs: []
  type: TYPE_PRE
- en: This all looks awkward‚Ä¶and it is, but the output isn't really meant for human
    consumption, but we benefit from ESM's "seen as a bug" feature of circular dependencies.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: ^Kuto will in future reference *between* corpuses
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: Should I use this?
  id: totrans-split-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maybe!
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Kuto is new, and while the science says it works, it''s a bit weird. And as
    I''ve mentioned above, it works really well on:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: single bundle output sites
  id: totrans-split-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that have a large JS bundle (maybe >1mb?)
  id: totrans-split-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‚Ä¶which are made up of lots of top-level ESM code, such as functions and classes
  id: totrans-split-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need to:'
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: use a regular bundler first
  id: totrans-split-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: keep or have access to your old build artifacts‚ÄîKuto doesn't know what you *already
    shipped* by magic ü™Ñ
  id: totrans-split-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: trade off a slightly larger *first load* for a better update experience
  id: totrans-split-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other issue with this is that more and more browsers are moving to a world
    where cache is regularly evicted. If your visitors don't have your site cached,
    then Kuto *is* pointless‚Äîevery load is slightly more expensive for an update that
    never happens. YMMV.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, the tool emits a few statistics, including how much overhead the
    initial load costing you, and what % of code is able to be identifed as having
    "no side effects" and put into a corpus. And to be clear, running Kuto on tiny
    codebases has no benefit‚Äîthe 'cost' of parsing a few kb of JS is trivial, even
    for potato phones. ü•î
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: So you can experiment and see if it works for you. My view is that Kuto will
    help for enterprise apps (because the JS is bloated, and no-one *really* cares)
    or social media (because power users come *so often*).
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: Fragmentation
  id: totrans-split-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kuto generates multiple files over time. Right now, it actually only uses the
    top 4 (by size) previous bundles, although this is configurable by flag. This
    is‚Ä¶not very good, and I'm yet to come up with a good automatic metric as to when
    to 'clean up' vs 're-use'.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this though: if you just don''t provide Kuto with historic bundles,
    it‚Ä¶ obviously can''t use them. So you can decide whether that typo fix generating
    a 100-byte file is worth it for the *next build*.'
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: Why Only 28% Faster?
  id: totrans-split-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ignoring some of the possible downsides, there's a big question for me at play.
    My test case above showed 71% reduction in size, but only 28% increase in speed.
    ü§î
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: I have a suspicion that v8's assembly of a bunch of module code *is still quite
    costly*. Yes, it's great that huge chunks of static code can be outsourced and
    cached forever, but in the end, your website still needs to assemble it all together.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: An Ask
  id: totrans-split-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I would love to hear from you if Kuto makes a material difference to the way
    you bundle and update your code, even in just a theoretical test environment.
    Please feel free to contact me, including filing [a GitHub issue](https://github.com/samthor/kuto/issues/new),
    if you can give me some sweet, sweet numbers.
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: Thanks
  id: totrans-split-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks for reading! Kuto has been incredibly interesting to build, yet honestly
    it's only taken me a few days of full-time engineering to make it work. It's been
    an idea I've been noodling on for a few years, and I'm really proud to have it
    come to fruition. üçá
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
