- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:29:05'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and avoiding visually ambiguous characters in IDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://gajus.com/blog/avoiding-visually-ambiguous-characters-in-ids](https://gajus.com/blog/avoiding-visually-ambiguous-characters-in-ids)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is not uncommon that I need to write down or communicate IDs when interacting
    with systems, e.g. reporting a bug, entering a discount code, or tracking a package.
    It is frustrating when the experience is marred by an easy mistake to avoid -
    visually ambiguous characters.
  prefs: []
  type: TYPE_NORMAL
- en: '`O` / `0` - The letter `O` and the number `0` can look very similar, especially
    in fonts where the number zero isn’t slashed or dotted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I` / `l` / `1` / `7` - The letter `I` (uppercase `i`), lowercase `l` (`L`),
    the number `1`, and the number `7` ^([1](#user-content-fn-1)) can be indistinguishable
    in many types of print and handwriting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5` / `S` - In some fonts, the number `5` and the letter `S` can appear quite
    similar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` / `Z` - These can also be confused with each other, particularly in handwritten
    forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`8` / `B` - These characters might be mixed up when poorly written or in certain
    stylized fonts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6` / `G` - These characters can be confused in some fonts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9` / `q` / `g` - These characters can be confused in some fonts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cause confusion and errors in data entry, especially when the characters
    are handwritten or when the font is not clear. For example, if a user is trying
    to enter a code that contains the letter 'O' and the number '0', they might not
    be able to tell which character is which. This leads to frustrating user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few examples using different system fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: 9qg6G8B2Z5SIl170O (arial)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9qg6G8B2Z5SIl170O (helvetica)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9qg6G8B2Z5SIl170O (courier)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9qg6G8B2Z5SIl170O (times)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9qg6G8B2Z5SIl170O (verdana)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9qg6G8B2Z5SIl170O (georgia)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9qg6G8B2Z5SIl170O (tahoma)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9qg6G8B2Z5SIl170O (impact)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9qg6G8B2Z5SIl170O (comic sans)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some pairs are visually ambiguous in all fonts (e.g. `I` and `l`), while others
    are much harder to distinguish in handwritten forms, e.g. try writing `9qg` in
    your own handwriting.
  prefs: []
  type: TYPE_NORMAL
- en: Any time that the ID might need to be communicated verbally or written down,
    e.g.
  prefs: []
  type: TYPE_NORMAL
- en: Customer support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discount codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also consider whether your IDs should be case-sensitive or not. Is `abc`
    the same as `ABC`?
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that you are going with case sensitivity, you have 53 characters to
    choose from (adjusted for visually ambiguous characters). On the other hand, if
    you decide to make your IDs case-insensitive, you have only 22 characters to choose
    from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming an ID length of 5 characters, you have the following number of possible
    IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case-sensitive: 53^5 = 418,195,493'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case-insensitive: 22^5 = 5,153,632'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, as the number of members in the set increases, the number of possible
    IDs increases exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case-sensitive: 53^8 = 62,259,690,411,361'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case-insensitive: 22^8 = 54,875,873,536'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the real question is whether what's preferable is a shorter ID with
    a higher chance of visual ambiguity or a longer ID with a lower chance of visual
    ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: As pointed out in a Hacker News comment ^([2](#user-content-fn-2)), if you use
    both upper and lower case, you are likely to eventually be surprised by some third
    party system or protocol that is case insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: I even found a commercial system which allowed users to choose IDs with case
    sensitivity (iD and id being distinct) but if you query it for one which does
    not exist they do case insensitive matching and return the wrong data.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When I reported this bug they said it was for convenience!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As my preference is readability, this is the character set that I use for generating
    IDs in my projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`rn` (looks like `m`) ^([3](#user-content-fn-3))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vv` (looks like `w`) ^([4](#user-content-fn-4))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personally, I would be wary of excluding characters just because they look like
    other characters when combined. Avoiding these particular combinations might be
    a good idea at the ID generation level.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you might also want to avoid characters that sound similar when
    spoken. For example, `b` and `p` can sound similar when spoken out loud. This
    can be especially important in situations where IDs are communicated verbally.
  prefs: []
  type: TYPE_NORMAL
- en: Crockford’s [Base32](https://www.crockford.com/base32.html) (distinct from the
    [IETF Base32](https://www.rfc-editor.org/rfc/rfc4648#page-8))
  prefs: []
  type: TYPE_NORMAL
- en: This takes the approach of allowing ambiguous characters by decoding them to
    the same value, and also considers the problem of accidental obscenities.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Open Location Code](https://github.com/google/open-location-code)'
  prefs: []
  type: TYPE_NORMAL
- en: A character set I like to use when I need something like this is the one used
    by Open Location Code, which is 23456789CFGHJMPQRVWX. It was apparently chosen
    not only to avoid visually ambiguous characters, but also to [avoid spelling words
    in common languages](https://github.com/google/open-location-code/wiki/Evaluation-of-Location-Encoding-Systems#open-location-code).
    It does however include both 6 and G, as well as 9 and Q.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
