- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:56:28'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Dr George W Stagg - Fortran on WebAssembly
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://gws.phd/posts/fortran_wasm/](https://gws.phd/posts/fortran_wasm/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Fortran](https://fortran-lang.org) is one of the oldest programming languages
    around. It first appeared in 1957, making it older than the C programming language,
    the Intel 4004 CPU, and even the IBM System/360 series of mainframe computers.
    Fortran was created at a time when the byte had just been invented, and computers
    were still made of vacuum tubes and frustration.'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: ¬π¬†The name is derived from *Formula Translator*. Fortran was originally stylised
    in all-caps, but modern Fortran has dropped it.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: ¬≤¬†The System/360 was released around 1965\. The 4004 around 1970\. And [K&R
    C](https://en.wikipedia.org/wiki/The_C_Programming_Language) was published in
    1978.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: ¬≥¬†The argument goes that Fortran‚Äôs lack of aliasing and use of native arrays
    rather than pointer arithmetic allow the optimiser to generate more efficient
    output than an equivalent C program. However, there are also counter-arguments
    against this.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, Fortran has formed a rich history of use for computationally
    intensive scientific and engineering applications. It has powered the fluid dynamics
    of weather prediction and climate models, provided the condensed matter simulations
    for my [PhD](../../docs/thesis_gws.pdf), and is still considered by some to be
    more efficient than C for numerically heavy work. The syntax of modern Fortran
    is also surprisingly easy to get up and running with. This is not your parent‚Äôs
    Fortran¬†77 code; most restrictions that make fixed‚Äëform Fortran awful to use are
    no longer in place in modern Fortran.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: In a clash of computational eras, this blog post is about compiling existing
    Fortran code for WebAssembly so that it can run in a web browser. I‚Äôll describe
    the method we currently use for the [webR](https://github.com/r-wasm/webr) project,
    compiling Fortran code using a patched version of [LLVM](https://llvm.org)‚Äôs `flang-new`
    compiler. The post also serves as a request for help. The method I describe unfortunately
    relies on a hack, and this hack means that I cannot contribute the changes back
    to LLVM without assistance from a more experienced compiler developer.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: ‚Å¥¬†‚ÄúLLVM‚Äù is not an acronym, it is the full name of the project.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: So, what‚Äôs the problem?
  id: totrans-split-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a surprising number of potential methods and toolchains available
    to compile Fortran to WebAssembly. Unfortunately, none of the available options
    are feature complete. Each method has its drawbacks, and none are a simple plug-and-play
    solution.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: Back in 2020, the situation was summarised wonderfully by Christoph Honal‚Äôs
    article [FORTRAN in the Browser](https://chrz.de/2020/04/21/fortran-in-the-browser/).
    Even now, the article is worth reading and provides a nice background for this
    post. I personally owe a lot to Christoph‚Äôs article, particularly for its description
    of the [Dragonegg](https://dragonegg.llvm.org) toolchain. Without that article,
    I would have given up on Fortran for WebAssembly a long time ago.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: Our goal by the end of this post is to be able to compile a modern Fortran routine
    to WebAssembly that takes in some numerical arguments, computes the output of
    [BLAS](http://www.netlib.org/blas/) and [LAPACK](https://netlib.org/lapack/) routines,
    and either returns the result or prints it to console. From what I remember, in
    2020 none of the methods outlined in Christoph‚Äôs article could do this satisfactorily.
    Dragonegg and `f2c` both get close but have some drawbacks, as I‚Äôll describe below.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: ‚Åµ¬†LAPACK (Linear Algebra Package) is a popular library of routines used to numerically
    solve problems in linear algebra. It‚Äôs written in Fortran 90 and itself relies
    on a BLAS (Basic Linear Algebra Subprograms) library.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: ‚Å∂¬†via [Pyodide](https://pyodide.org/en/stable/) and [webR](https://github.com/r-wasm/webr).
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: Together, BLAS and LAPACK routines provide a powerful numerical platform. Running
    them in the browser opens the door for several higher-level programming environments
    that rely on them under the hood, such as SciPy or R. The beauty of this approach
    is that it allows you to bring existing and extensively battle-tested tools and
    libraries to the web without having to rewrite them all in Rust or JavaScript.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: Later, I‚Äôll show an example of this with a machine learning demo that directly
    uses BLAS routines compiled from Fortran to WebAssembly. Rather than having to
    write fiddly linear algebra numerical algorithms in JavaScript, we can use reliable
    and efficient BLAS routines directly.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: ‚Å∑¬†Whilst running machine learning algorithms in a web browser will never be
    as efficient as using dedicated hardware, such as a GPU, I still think it‚Äôs a
    fun demo.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: Compiler round-up
  id: totrans-split-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since [FORTRAN in the Browser](https://chrz.de/2020/04/21/fortran-in-the-browser/)
    was published things have changed a little, particularly when it comes to the
    LLVM-based Fortran compilers. As far as I am aware, here‚Äôs a brief round-up of
    the current situation in 2024.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: The `f2c` utility
  id: totrans-split-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`f2c`](https://en.wikipedia.org/wiki/F2c) program converts Fortran 77 to
    C code, which Emscripten can then compile into WebAssembly. This is the method
    that the [Pyodide](https://pyodide.org/en/stable/) project uses to compile Python
    packages containing Fortran code. They say that this [‚Äúdoes not work very well‚Äù](https://pyodide.org/en/0.25.0/project/roadmap.html#find-a-better-way-to-compile-fortran).
    The tool doesn‚Äôt work with modern Fortran code, and even after conversion the
    result still throws fatal errors and requires extensive patching.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: LFortran
  id: totrans-split-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LFortran
- en: The LFortran compiler has made great strides over the last few years. In 2020,
    it was [missing a lot of features](https://gitlab.com/lfortran/lfortran/-/issues/121)
    and only supported a very small subset of Fortran. Now it now supports a much
    wider range of language features and can be used to compile a reasonable amount
    of Fortran code. It can even compile to WebAssembly out of the box!
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: ËøáÂéªÂá†Âπ¥ÈáåÔºåLFortranÁºñËØëÂô®ÂèñÂæó‰∫ÜÈïøË∂≥ÁöÑËøõÊ≠•„ÄÇ2020Âπ¥Êó∂ÔºåÂÆÉ[Áº∫Â∞ëÂæàÂ§öÂäüËÉΩ](https://gitlab.com/lfortran/lfortran/-/issues/121)Ôºå‰ªÖÊîØÊåÅÊûÅÂ∞èÁöÑFortranÂ≠êÈõÜ„ÄÇÁé∞Âú®ÔºåÂÆÉÊîØÊåÅÊõ¥ÂπøÊ≥õÁöÑËØ≠Ë®ÄÁâπÊÄßÔºåÂπ∂ÂèØ‰ª•Áî®Êù•ÁºñËØëÁõ∏ÂΩìÊï∞ÈáèÁöÑFortran‰ª£Á†Å„ÄÇÂÆÉÁîöËá≥ÂèØ‰ª•Áõ¥Êé•ÁºñËØëÂà∞WebAssemblyÔºÅ
- en: ‚Å∏¬†Check out the LFortran demo at [https://dev.lfortran.org](https://dev.lfortran.org).
    While extremely impressive, note that the first thing I tried was changing `x
    ** 2` to `x ** 3` and saw that such a change is currently not supported by the
    code generator.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: ‚Å∏¬†ËØ∑Êü•Áúã[LFortranÊºîÁ§∫](https://dev.lfortran.org)„ÄÇÂ∞ΩÁÆ°‰ª§‰∫∫Âç∞Ë±°Ê∑±ÂàªÔºå‰ΩÜËØ∑Ê≥®ÊÑèÔºåÊàëÂ∞ùËØïÁöÑÁ¨¨‰∏Ä‰ª∂‰∫ãÊòØÂ∞Ü`x ** 2`Êîπ‰∏∫`x
    ** 3`ÔºåÁªìÊûúÂèëÁé∞ÂΩìÂâç‰ª£Á†ÅÁîüÊàêÂô®‰∏çÊîØÊåÅËøôÊ†∑ÁöÑÊõ¥Êîπ„ÄÇ
- en: However, there are still some barriers that make using LFortran a little rough.
    The project is currently considered to be in alpha phase and the developers state
    that issues compiling real-world code are expected. While it can successfully
    compile some projects, such as [MINPACK](https://github.com/fortran-lang/minpack),
    the full Fortran specification is not yet supported and so many larger projects
    still cannot be compiled.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: ‰ΩÜÊòØÔºåLFortran‰ªçÁÑ∂Â≠òÂú®‰∏Ä‰∫õ‰ΩøÁî®‰∏äÁöÑÈöúÁ¢ç„ÄÇËØ•È°πÁõÆÁõÆÂâçË¢´ËÆ§‰∏∫Â§Ñ‰∫éalphaÈò∂ÊÆµÔºåÂºÄÂèë‰∫∫ÂëòË°®Á§∫È¢ÑËÆ°‰ºöÂá∫Áé∞ÁºñËØëÁé∞ÂÆû‰∏ñÁïå‰ª£Á†ÅÁöÑÈóÆÈ¢ò„ÄÇËôΩÁÑ∂ÂÆÉÂèØ‰ª•ÊàêÂäüÁºñËØë‰∏Ä‰∫õÈ°πÁõÆÔºå‰æãÂ¶Ç[MINPACK](https://github.com/fortran-lang/minpack)Ôºå‰ΩÜÂÆåÊï¥ÁöÑFortranËßÑËåÉÂ∞öÊú™ÂÆåÂÖ®ÊîØÊåÅÔºåÂõ†Ê≠§ËÆ∏Â§öËæÉÂ§ßÁöÑÈ°πÁõÆ‰ªçÊó†Ê≥ïÁºñËØë„ÄÇ
- en: The LFortran developers are targeting full support for Fortran 2018, and its
    standout feature is an interactive Jupyter-like Fortran REPL. With a few more
    years of development, I expect that LFortran will be an excellent choice for compiling
    Fortran code for WebAssembly.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: LFortranÂºÄÂèë‰∫∫ÂëòÊ≠£Âú®Âä™ÂäõÊîØÊåÅÂÆåÊï¥ÁöÑFortran 2018ÔºåÂπ∂‰∏îÂÖ∂ÊòæËëóÁâπÊÄßÊòØ‰∏Ä‰∏™Á±ª‰ºº‰∫é‰∫§‰∫íÂºèJupyterÁöÑFortran REPL„ÄÇÂÜçÁªèËøáÂá†Âπ¥ÁöÑÂèëÂ±ïÔºåÊàëÈ¢ÑËÆ°LFortranÂ∞ÜÊàê‰∏∫ÁºñËØëFortran‰ª£Á†ÅÂà∞WebAssemblyÁöÑ‰ºòÁßÄÈÄâÊã©„ÄÇ
- en: Dragonegg
  id: totrans-split-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dragonegg
- en: '[Dragonegg](https://dragonegg.llvm.org) is a plugin for GCC that uses the GNU
    compilers as a frontend and emits LLVM IR. With this, LLVM can be used as the
    backend to produce WebAssembly output. The technique works, and it was the original
    method that I used to compile Fortran sources for the [webR](https://github.com/r-wasm/webr)
    project.'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dragonegg](https://dragonegg.llvm.org)ÊòØGCCÁöÑ‰∏Ä‰∏™Êèí‰ª∂Ôºå‰ΩøÁî®GNUÁºñËØëÂô®‰Ωú‰∏∫ÂâçÁ´ØÔºåÂπ∂ÁîüÊàêLLVM IR„ÄÇÈÄöËøáËøôÁßçÊñπÂºèÔºåLLVMÂèØ‰ª•‰Ωú‰∏∫ÂêéÁ´ØÁîüÊàêWebAssemblyËæìÂá∫„ÄÇËøôÁßçÊäÄÊúØÂèØË°åÔºåÂπ∂‰∏îËøôÊòØÊàë‰∏∫[webRÈ°πÁõÆ](https://github.com/r-wasm/webr)ÁºñËØëFortranÊ∫ê‰ª£Á†ÅÊúÄÂàù‰ΩøÁî®ÁöÑÊñπÊ≥ï„ÄÇ'
- en: However, there are some pretty serious drawbacks to this approach. Dragonegg
    requires a very old version of GCC and LLVM. For most users, this means setting
    up a virtual machine or Docker container to provide the necessary environment.
    The LLVM IR emitted by Dragonegg also needs some fairly nasty post-processing
    before LLVM can produce WebAssembly output. Take a look at the [script originally
    used by webR](https://github.com/r-wasm/webr/blob/v0.1.0/tools/dragonegg/emfc.in)
    to get an idea of the extra processing required.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: ÁÑ∂ËÄåÔºåËøôÁßçÊñπÊ≥ï‰πüÂ≠òÂú®‰∏Ä‰∫õ‰∏•ÈáçÁöÑÁº∫ÁÇπ„ÄÇDragoneggÈúÄË¶ÅÈùûÂ∏∏ÊóßÁöÑGCCÂíåLLVMÁâàÊú¨„ÄÇÂØπÂ§ßÂ§öÊï∞Áî®Êà∑ËÄåË®ÄÔºåËøôÊÑèÂë≥ÁùÄÈúÄË¶ÅËÆæÁΩÆËôöÊãüÊú∫ÊàñDockerÂÆπÂô®Êù•Êèê‰æõÂøÖË¶ÅÁöÑÁéØÂ¢É„ÄÇDragoneggÁîüÊàêÁöÑLLVM
    IRËøòÈúÄË¶Å‰∏Ä‰∫õÁõ∏ÂΩìÂ§çÊùÇÁöÑÂêéÂ§ÑÁêÜÊâçËÉΩÁî±LLVMÁîüÊàêWebAssemblyËæìÂá∫„ÄÇÊü•Áúã[webRÊúÄÂàù‰ΩøÁî®ÁöÑËÑöÊú¨](https://github.com/r-wasm/webr/blob/v0.1.0/tools/dragonegg/emfc.in)ÂèØ‰ª•‰∫ÜËß£ÊâÄÈúÄÁöÑÈ¢ùÂ§ñÂ§ÑÁêÜ„ÄÇ
- en: ‚Åπ¬†The latest supported versions are `gcc-4.8` and `llvm-3.3`
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: ‚Åπ¬†ÊúÄÊñ∞ÊîØÊåÅÁöÑÁâàÊú¨ÊòØ`gcc-4.8`Âíå`llvm-3.3`
- en: Nevertheless, in 2020 this was the only real way to compile Fortran code for
    WebAssembly.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: ÁÑ∂ËÄåÔºåÂú®2020Âπ¥ÔºåËøôÊòØÁºñËØëFortran‰ª£Á†ÅÂà∞WebAssemblyÁöÑÂîØ‰∏ÄÁúüÊ≠£ÊñπÊ≥ï„ÄÇ
- en: Classic flang
  id: totrans-split-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ÁªèÂÖ∏Flang
- en: '[‚ÄúClassic‚Äù Flang](https://github.com/flang-compiler/flang) is another Fortran
    compiler targeting LLVM, based on an open-sourced PGI/NVIDIA compiler `pgfortran`.
    Classic Flang never supported 32-bit output, so it is not an option for us since
    we‚Äôll be using `wasm32` for our target architecture. This will likely be the case
    until browser support for 64-bit Wasm memory has improved.'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[‚ÄúÁªèÂÖ∏‚ÄùFlang](https://github.com/flang-compiler/flang)ÊòØÂè¶‰∏Ä‰∏™ÈíàÂØπLLVMÁöÑFortranÁºñËØëÂô®ÔºåÂü∫‰∫éÂºÄÊ∫êÁöÑPGI/NVIDIAÁºñËØëÂô®`pgfortran`„ÄÇÁªèÂÖ∏Flang‰ªéÊú™ÊîØÊåÅ32‰ΩçËæìÂá∫ÔºåÂõ†Ê≠§ÂØπÊàë‰ª¨Êù•ËØ¥‰∏çÊòØ‰∏Ä‰∏™ÈÄâÊã©ÔºåÂõ†‰∏∫Êàë‰ª¨Â∞Ü‰ΩøÁî®`wasm32`‰Ωú‰∏∫ÁõÆÊ†áÊû∂ÊûÑ„ÄÇÂú®ÊµèËßàÂô®ÂØπ64‰ΩçWasmÂÜÖÂ≠òÁöÑÊîØÊåÅÊîπÂñÑ‰πãÂâçÔºåËøôÂèØËÉΩ‰ºö‰∏ÄÁõ¥ÊòØÈóÆÈ¢ò„ÄÇ'
- en: ^(10)¬†Previously, Flang or Flang-7.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: ^(10)¬†‰ª•ÂâçÊòØFlangÊàñFlang-7„ÄÇ
- en: ^(11)¬†At the time of writing Firefox, Chrome and Node supports `wasm64`, but
    locked behind a feature flag.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: ^(11)¬†Êà™Ëá≥Êí∞ÂÜôÊó∂ÔºåFirefox„ÄÅChromeÂíåNodeÈÉΩÊîØÊåÅ`wasm64`Ôºå‰ΩÜÈúÄË¶ÅÈÄöËøáÂäüËÉΩÊ†áÂøóÊù•ÈîÅÂÆö„ÄÇ
- en: 'Even so, the project documentation itself suggests that choosing to use Classic
    Flang for a new project today is probably not a great idea:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: Â∞ΩÁÆ°Â¶ÇÊ≠§ÔºåÈ°πÁõÆÊñáÊ°£Êú¨Ë∫´Âª∫ËÆÆÔºåÈÄâÊã©Âú®Êñ∞È°πÁõÆ‰∏≠‰ΩøÁî®ÁªèÂÖ∏FlangÂèØËÉΩ‰∏çÊòØ‰∏Ä‰∏™Â•Ω‰∏ªÊÑèÔºö
- en: Classic Flang [‚Ä¶] continues to be maintained, but the plan is to replace Classic
    Flang with the new Flang in the future.
  id: totrans-split-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ÁªèÂÖ∏Flang[‚Ä¶]ÁªßÁª≠Áª¥Êä§Ôºå‰ΩÜËÆ°ÂàíÊú™Êù•Â∞ÜÂÖ∂ÊõøÊç¢‰∏∫Êñ∞ÁöÑFlang„ÄÇ
- en: LLVM Flang
  id: totrans-split-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LLVM Flang
- en: '[‚ÄúLLVM Flang‚Äù](https://flang.llvm.org/docs/) is a full ground-up reimplementation
    of a Fortran frontend for LLVM. It was designed to replace Classic Flang, developed
    by much of the same team, and was accepted as part of the LLVM project as of LLVM
    11\. As such, the Flang sources can now be found in [the official LLVM source
    tree](https://github.com/llvm/llvm-project/tree/main/flang).'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[‚ÄúLLVM Flang‚Äù](https://flang.llvm.org/docs/)ÊòØ‰∏Ä‰∏™ÂÆåÂÖ®‰ªéÂ§¥ÂºÄÂßãÈáçÊñ∞ÂÆûÁé∞ÁöÑÁî®‰∫éLLVMÁöÑFortranÂâçÁ´Ø„ÄÇÂÆÉÊó®Âú®Âèñ‰ª£Áî±Âêå‰∏ÄÂõ¢ÈòüÂºÄÂèëÁöÑÁªèÂÖ∏FlangÔºåÂπ∂‰∏îÂ∑≤Áªè‰Ωú‰∏∫LLVMÈ°πÁõÆÁöÑ‰∏ÄÈÉ®ÂàÜË¢´Êé•ÂèóÔºå‰ªéLLVM
    11ÁâàÊú¨ÂºÄÂßãÔºåFlangÁöÑÊ∫ê‰ª£Á†ÅÁé∞Âú®ÂèØ‰ª•Âú®[ÂÆòÊñπLLVMÊ∫êÁ†ÅÊ†ë](https://github.com/llvm/llvm-project/tree/main/flang)‰∏≠ÊâæÂà∞„ÄÇ'
- en: ^(12)¬†Also known as Flang, new Flang, or `flang-new`. Previously, F18.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: ^(12)¬†‰πüË¢´Áß∞‰∏∫Flang„ÄÅÊñ∞FlangÊàñ`flang-new`„ÄÇ‰ª•ÂâçÊòØF18„ÄÇ
- en: Flang is not yet considered to be ready for production use, but its development
    is extremely active right now and pre-production versions of the `flang-new` compiler
    have been made available by the team. In recent years, the compiler has become
    very usable for compiling real-world Fortran code.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: FlangÁõÆÂâçÂ∞öÊú™Ë¢´ËÆ§‰∏∫Â∑≤ÁªèÂáÜÂ§áÂ•ΩÁî®‰∫éÁîü‰∫ßÔºå‰ΩÜÂÖ∂ÂºÄÂèëÁõÆÂâçÈùûÂ∏∏Ê¥ªË∑ÉÔºåÂõ¢ÈòüÂ∑≤ÁªèÂèëÂ∏É‰∫Ü`flang-new`ÁºñËØëÂô®ÁöÑÈ¢ÑÁîü‰∫ßÁâàÊú¨„ÄÇËøëÂπ¥Êù•ÔºåËØ•ÁºñËØëÂô®Âú®ÁºñËØëÂÆûÈôÖÁöÑFortran‰ª£Á†ÅÊñπÈù¢ÂèòÂæóÈùûÂ∏∏ÂèØÁî®„ÄÇ
- en: Currently, LLVM Flang cannot generate WebAssembly output out of the box. Despite
    this, we‚Äôll soon see that with LLVM‚Äôs modular design it‚Äôs possible to use the
    Flang frontend with LLVM‚Äôs WebAssembly backend. With this, we can take advantage
    of all the development work put into the Flang frontend by the NVIDIA and PGI
    teams for our own purposes of compiling Fortran to WebAssembly.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: ÁõÆÂâçÔºåLLVM FlangÊó†Ê≥ïÁõ¥Êé•ÁîüÊàêWebAssemblyËæìÂá∫„ÄÇÂ∞ΩÁÆ°Â¶ÇÊ≠§ÔºåÁî±‰∫éLLVMÁöÑÊ®°ÂùóÂåñËÆæËÆ°ÔºåÊàë‰ª¨ÂæàÂø´Â∞ÜÁúãÂà∞ÂèØ‰ª•Â∞ÜFlangÂâçÁ´Ø‰∏éLLVMÁöÑWebAssemblyÂêéÁ´ØÁªìÂêà‰ΩøÁî®„ÄÇÈÄöËøáËøôÁßçÊñπÂºèÔºåÊàë‰ª¨ÂèØ‰ª•Âà©Áî®NVIDIAÂíåPGIÂõ¢Èòü‰∏∫ÁºñËØëFortranÂà∞WebAssemblyÊâÄÂÅöÁöÑÊâÄÊúâÂºÄÂèëÂ∑•‰Ωú„ÄÇ
- en: This was also possible back in 2020, though it required larger patches to LLVM,
    injecting custom maths routines, and a multi-step compilation process. Now, due
    to the impressive development efforts in the `flang-new` frontend, creating a
    Fortran to WebAssembly compiler is possible with just a few small changes to LLVM‚Äôs
    source code.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: ËøôÂú®2020Âπ¥‰πüÊòØÂèØËÉΩÁöÑÔºåÂ∞ΩÁÆ°ÈúÄË¶ÅÂØπLLVMËøõË°åËæÉÂ§ßÁöÑË°•‰∏ÅÔºåÊ≥®ÂÖ•Ëá™ÂÆö‰πâÊï∞Â≠¶ÂáΩÊï∞ÔºåÂπ∂ËøõË°åÂ§öÊ≠•È™§ÁöÑÁºñËØëËøáÁ®ã„ÄÇÁé∞Âú®ÔºåÁî±‰∫é`flang-new`ÂâçÁ´ØÁöÑÊòæËëóÂºÄÂèëÂ∑•‰ΩúÔºåÂè™ÈúÄÂØπLLVMÁöÑÊ∫ê‰ª£Á†ÅËøõË°åÂ∞ëÈáèÊõ¥ÊîπÔºåÂ∞±ÂèØ‰ª•ÂàõÂª∫‰∏Ä‰∏™FortranÂà∞WebAssemblyÁöÑÁºñËØëÂô®„ÄÇ
- en: Building and using LLVM Flang for WebAssembly
  id: totrans-split-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ÊûÑÂª∫Âπ∂‰ΩøÁî®LLVM FlangÁî®‰∫éWebAssembly
- en: If one were interested in trying out LLVM Flang, they might grab an LLVM release
    using their package manager of choice. However, following that route will disappoint
    us, as a `flang-new` binary is not included.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: Â¶ÇÊûúÊúâÂÖ¥Ë∂£Â∞ùËØïLLVM FlangÔºåÂèØ‰ª•ÈÄöËøáÂñúÊ¨¢ÁöÑÂåÖÁÆ°ÁêÜÂô®Ëé∑ÂèñLLVMÁöÑÂèëÂ∏ÉÁâàÊú¨„ÄÇÁÑ∂ËÄåÔºåÊåâÁÖßËøôÊù°Ë∑ØÁ∫øËµ∞‰ºöËÆ©Êàë‰ª¨Â§±ÊúõÔºåÂõ†‰∏∫`flang-new`‰∫åËøõÂà∂Êñá‰ª∂Âπ∂‰∏çÂåÖÂê´Âú®ÂÜÖ„ÄÇ
- en: ^(13)¬†At least, not with LLVM v17.0.6 for macOS using `brew`.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: ^(13)¬†Ëá≥Â∞ëÔºåÂú®‰ΩøÁî®`brew`ÂÆâË£ÖLLVM v17.0.6ÁöÑmacOS‰∏ä‰∏çË°å„ÄÇ
- en: '[~/fortran]brew install llvm'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]brew install llvm'
- en: ==> Downloading https://formulae.brew.sh/api/formula.jws.json
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: ==> ‰∏ãËΩΩ https://formulae.brew.sh/api/formula.jws.json
- en: '################################################################################
    100.0%'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: '################################################################################
    100.0%'
- en: ==> Downloading https://ghcr.io/v2/homebrew/core/llvm/manifests/17.0.6_1
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: ==> ‰∏ãËΩΩ https://ghcr.io/v2/homebrew/core/llvm/manifests/17.0.6_1
- en: '################################################################################
    100.0%'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: '################################################################################
    100.0%'
- en: ==> Fetching llvm
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: ==> Ëé∑Âèñ llvm
- en: ==> Downloading https://ghcr.io/v2/homebrew/core/llvm/blobs/sha256:8d739bdfa4152
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: ==> ‰∏ãËΩΩ https://ghcr.io/v2/homebrew/core/llvm/blobs/sha256:8d739bdfa4152
- en: '################################################################################
    100.0%'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: '################################################################################
    100.0%'
- en: ==> Installing llvm
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: ==> ÂÆâË£Ö llvm
- en: ==> Pouring llvm--17.0.6_1.arm64_sonoma.bottle.tar.gz
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: ==> Ê≠£Âú®Ëß£Âéã llvm--17.0.6_1.arm64_sonoma.bottle.tar.gz
- en: ==> Summary
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: ==> ÊÄªÁªì
- en: 'üç∫ /opt/homebrew/Cellar/llvm/17.0.6_1: 7,207 files, 1.7GB'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'üç∫ /opt/homebrew/Cellar/llvm/17.0.6_1: 7,207 files, 1.7GB'
- en: ==> Checking for dependents of upgraded formulae...
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: ==> Ê£ÄÊü•ÂçáÁ∫ßÂÖ¨ÂºèÁöÑ‰æùËµñÈ°π...
- en: ==> No broken dependents to reinstall!
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: ==> Ê≤°ÊúâÈúÄË¶ÅÈáçÊñ∞ÂÆâË£ÖÁöÑÂ∑≤ÊçüÂùè‰æùËµñÈ°πÔºÅ
- en: '[~/fortran]flang-new'
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[~/fortran]flang-new'
- en: 'zsh: command not found: flang-new'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'zsh: command not found: flang-new'
- en: Since we will be modifying the LLVM Flang source in any case, we‚Äôll have to
    compile from scratch. Let‚Äôs grab the LLVM v18.1.1 sources and start there instead.
    Feel free to follow along at home; I‚Äôll try to provide all the commands and everything
    you need.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: ^(14)¬†I‚Äôm going to assume you‚Äôre familiar with [Emscripten](https://emscripten.org)
    and have a version of that toolchain on your path. If not, and you want to play
    along, start with [emsdk](https://github.com/emscripten-core/emsdk) to setup Emscripten
    on your machine, get comfortable with compiling C code for WebAssembly, then return
    here to continue.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]git clone --depth=1 --branch=llvmorg-18.1.1 https://github.com/llvm/llvm-project.git'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: Cloning into 'llvm-project'...
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: 'remote: Enumerating objects: 138937, done.'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Receiving objects: 100% (138937/138937), 199.81 MiB | 11.36 MiB/s, done.'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: switching to ''6009708b4367171ccdbf4b5905cb6a803753fe18''.'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating files: 100% (132077/132077), done.'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]cmake -G Ninja -S llvm-project/llvm -B build \'
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: -DCMAKE_INSTALL_PREFIX=llvm-18.1.1 \
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: -DCMAKE_BUILD_TYPE=MinSizeRel \
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: -DLLVM_DEFAULT_TARGET_TRIPLE="wasm32-unknown-emscripten" \
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: -DLLVM_TARGETS_TO_BUILD="WebAssembly" \
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: -DLLVM_ENABLE_PROJECTS="clang;flang;mlir"
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: -- The C compiler identification is AppleClang 15.0.0.15000100
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: '-- Found assembler: /Library/Developer/CommandLineTools/usr/bin/cc'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: -- Detecting C compiler ABI info - done
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: -- Performing Test HAVE_POSIX_REGEX -- success
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
- en: -- Configuring done (29.0s)
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
- en: -- Generating done (2.9s)
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
- en: '-- Build files have been written to: fortran/build'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]cmake --build build'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: '[6136/6136] Linking CXX executable bin/obj2yaml'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: Grab a cuppa, this step uses a lot of resources and can take a **very** long
    time.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
- en: '^(15)¬†**cuppa** (/Ààk åp.…ô/): noun, informal, UK. A hot drink, usually tea or
    coffee.'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
- en: Interlude ‚Äî Calling Fortran subroutines from C
  id: totrans-split-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we wait for LLVM to build, start up a new terminal and we‚Äôll remind ourselves
    how to compile and link a Fortran subroutine as part of a C program. The principles
    here will help us later when it comes to calling Fortran from JavaScript.
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let‚Äôs write a simple subroutine that takes in three integer arguments:
    `x`, `y`, and `z`. It will set the value of `z` to the sum of `x` and `y`. Name
    our new subroutine `foo` and save the file containing your subroutine as `foo.f08`.'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Notice how, generally, Fortran routines pass arguments by reference and we
    can declare how an argument will be used in the subroutine using `INTENT()`. Assuming
    you already have a traditional Fortran compiler like `gfortran` installed, compile
    the Fortran source into an object file.'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
- en: ^(16)¬†You don‚Äôt *need* a native fortran compiler to follow along with the rest
    of the post, but if you‚Äôd like one you can get `gfortran` from your OS‚Äôs usual
    package manager as part of the GCC compiler suite. There‚Äôs also [`ifort`](https://www.intel.com/content/www/us/en/developer/tools/oneapi/fortran-compiler.html),
    if you‚Äôre on an Intel CPU.
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]gfortran -c foo.f08 -o foo.o'
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]file foo.o'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
- en: 'foo.o: Mach-O 64-bit object arm64'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]nm foo.o'
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
- en: 0000000000000038 s EH_frame1
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
- en: 0000000000000000 T _foo_
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
- en: 0000000000000000 t ltmp0
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
- en: 0000000000000038 s ltmp1
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
- en: I‚Äôm on an M1 macOS machine, so my resulting object is a Mach object for ARM.
    If you‚Äôre a Linux user, you should see something like `ELF 64-bit LSB shared object,
    x86-64`. I‚Äôve also run `nm` to take a look at the names of the symbols in the
    object that the compiler has built. Keep an eye on the symbol for our subroutine
    ‚Äî on my machine it‚Äôs named `_foo_`. The leading underscore is fairly standard,
    but the trailing underscore differs from what is usual for C procedures.
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs write a C program that calls our Fortran subroutine. Notice again how
    we pass the arguments by reference to the external symbol. Also, if your Fortran
    compiler added the trailing underscore, we‚Äôll need to include it when we declare
    the symbol name in C.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
- en: ^(17)¬†Modern Fortran standards provide a Fortran module [`iso_c_binding`](https://fortranwiki.org/fortran/show/iso_c_binding)
    and a C header file `ISO_Fortran_binding.h` to improve C interoperability, but
    our code is going to be simple enough that we can do without those today.
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Compile the C source using `gcc` or equivalent, and then run the resulting
    binary to observe a truly staggering level of numerical computation.'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]gcc main.c foo.o -o main'
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]./main'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
- en: 1 + 1 = 2**  **## Returning to LLVM Flang
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
- en: Once LLVM has finished compiling, the `flang-new` binary should be available
    in the directory `build/bin`. We can now run it and confirm that it has been set
    up to produce binaries for `wasm32` and Emscripten.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]./build/bin/flang-new --version'
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
- en: flang-new version 18.1.1 (https://github.com/llvm/llvm-project.git dba2a75e9c7ef81fe84774ba5eee5e67e01d801a)
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Target: wasm32-unknown-emscripten'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread model: posix'
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
- en: 'InstalledDir: .../fortran/build/bin'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
- en: Great! Let‚Äôs try compiling our Fortran subroutine using our freshly built compiler.
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]./build/bin/flang-new -c foo.f08 -o foo.o'
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
- en: 'error: fortran/llvm-project/flang/lib/Optimizer/CodeGen/Target.cpp:1162:'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
- en: 'not yet implemented: target not implemented'
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
- en: 'LLVM ERROR: aborting'
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
- en: Ah, not so great. The `wasm32-unknown-emscripten` target triple unfortunately
    hasn‚Äôt been implemented yet in the `flang-new` compiler.
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
- en: And so here comes our first patch to LLVM. We will implement the target by extending
    Flang‚Äôs list of known target specifics. The required changes, shown below as a
    diff, can be mostly deduced by looking at the other targets implemented in the
    file `flang/lib/Optimizer/CodeGen/Target.cpp`.
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Save the contents of the above diff as the file `add-wasm32-target.diff`,
    and then apply it to the `llvm-project` directory using `git` or the `patch` utility.
    Then, rebuild LLVM Flang. It should be quicker to build the second time, as most
    generated objects are unaffected by the change.'
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]patch -p1 -d llvm-project < add-wasm32-target.diff'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]cmake --build build'
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
- en: '[180/180] Generating ../../../../include/flang/ieee_arithmetic.mod'
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
- en: Once LLVM has been recompiled, try compiling our Fortran source once again.
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]./build/bin/flang-new -c foo.f08 -o foo.o'
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]file foo.o'
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
- en: 'foo.o: WebAssembly (wasm) binary module version 0x1 (MVP)'
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]llvm-nm foo.o'
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
- en: 00000001 T foo_
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
- en: Success! We can confirm this is a real WebAssembly object using the `file` utility,
    and `llvm-nm` can see the `foo` symbol within, corresponding to our Fortran subroutine.
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
- en: ^(18)¬†You might need to use a WebAssembly aware version of this tool from Emscripten.
    If you‚Äôre using [emsdk](https://github.com/emscripten-core/emsdk), ensure that
    `.../emsdk/upstream/bin/` is on your `$PATH`.
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
- en: ^(19)¬†Here I‚Äôm using Node v18, but I think anything newer than Node v16 should
    work. Emscripten is bundled with a version of Node, but I like using [nvm](https://github.com/nvm-sh/nvm)
    to manage my Node installations.
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs continue compiling our C function for WebAssembly using Emscripten and
    running it using Node. We should see the same output as with our native binary.
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]emcc main.c foo.o -o main.js'
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]node main.js'
  id: totrans-split-146
  prefs: []
  type: TYPE_NORMAL
- en: 1 + 1 = 2*  *## Interlude ‚Äî Calling a Fortran routine from JavaScript
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section we used a C program to call Fortran code, but we don‚Äôt
    technically need to do that. If we tell Emscripten about the Fortran subroutine,
    we can call it directly from JavaScript without writing any C code.
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
- en: First, let‚Äôs link our Fortran object with Emscripten, producing a script that
    loads our WebAssembly binary into memory but does not execute any routines. In
    addition to our symbol `_foo_`, we‚Äôll also export `_malloc` and `_free` so that
    we can use them from JavaScript.
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
- en: ^(20)¬†See the [Emscripten documentation](https://emscripten.org/docs/tools_reference/settings_reference.html)
    for more details about `emcc` command line options. By the way, if you‚Äôve not
    used Emscripten much before you might see extra `cache:INFO` lines emitted during
    various steps in this post. They are nothing to worry about and can be ignored.
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]emcc foo.o -sEXPORTED_FUNCTIONS=_foo_,_malloc,_free -o foo.js'
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
- en: 'cache:INFO: generating system asset: symbol_lists/ae47d07bfa3321ac4dde96bd87821b4aa93f9a19.json...
    (this will be cached in ".../emsdk/upstream/emscripten/cache/symbol_lists/ae47d07bfa3321ac4dde96bd87821b4aa93f9a19.json"
    for subsequent builds)'
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
- en: 'cache:INFO: - ok'
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]node foo.js'
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]'
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we run the script `foo.js` directly‚Ä¶ nothing happens.
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
- en: Next, we‚Äôll write a JavaScript file that loads `foo.js` and then calls our Fortran
    subroutine. We‚Äôll need to allocate some memory to hold our integers `x`, `y` and
    `z` using the exported `_malloc()` function. We‚Äôll also need to set our input
    arguments `x` and `y` to some integer values, and we can do that by setting values
    in the allocated WebAssembly memory through `Module.HEAPU32`.
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*[~/fortran]node standalone.js'
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
- en: x = 123
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
- en: y = 456
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
- en: x + y = 579
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
- en: You should also be able to run the resulting WebAssembly binary in a web browser.
    Remove the line `var Module = require('./foo.js');` from `standalone.js`, and
    instead load the script `foo.js` in your HTML.
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Spin up a local web server, visit the page, and the same output should be
    seen in the browser‚Äôs JavaScript console.'
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
- en: '^(22)¬†Something like `Rscript -e ''httpuv::runStaticServer()''` or `python3
    -m http.server` should work well.**  **## The Fortran runtime library: A journey
    to ‚ÄúHello, World!‚Äù'
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
- en: The ubiquitous ‚ÄúHello, World!‚Äù test program is the usual way to introduce a
    programming language, but I didn‚Äôt introduce Fortran using such a program above.
    As you‚Äôll see, that was for a good reason. Let‚Äôs see what happens when we try
    to build a ‚ÄúHello, World!‚Äù subroutine in Fortran and call it from C. As before,
    we‚Äôll compile the Fortran object using `flang-new` and use Emscripten to compile
    and link the C code.
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*[PRE6]'
  id: totrans-split-169
  prefs: []
  type: TYPE_NORMAL
- en: '*[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o'
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]emcc hello.c hello.o -o hello.js'
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
- en: 'wasm-ld: error: hello.o: undefined symbol: _FortranAioBeginExternalListOutput'
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
- en: 'wasm-ld: error: hello.o: undefined symbol: _FortranAioOutputAscii'
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
- en: 'wasm-ld: error: hello.o: undefined symbol: _FortranAioEndIoStatement'
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
- en: 'emcc: error: ''wasm-ld -o hello.wasm [...] --no-entry --stack-first --table-base=1''
    failed (returned 1)'
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
- en: The build failed due to some missing symbols. This is a consequence of a more
    general issue in that we have not yet compiled the LLVM Fortran runtime library
    for WebAssembly. There are a bunch of library symbols that we‚Äôre currently missing,
    including some functions that are required to print output!
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the runtime library is written in C++ as part of the LLVM source tree
    at `llvm-project/flang/runtime`. So, in principle, all we need to do is build
    the library using Emscripten‚Äôs `em++` compiler and then link to it whenever we‚Äôre
    using Fortran code in our WebAssembly program.
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
- en: Here is a `Makefile` designed to make this step easy. Save it in the current
    directory and then run `make`. It should go ahead and use the version of Emscripten
    on your path to build a static Fortran runtime library at `build/flang/runtime/libFortranRuntime.a`.
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
- en: ^(24)¬†Be sure to indent the rules in this file using tabs, not spaces.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*[~/fortran]make'
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
- en: em++ .../ISO_Fortran_binding.o -c .../ISO_Fortran_binding.cpp
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
- en: em++ .../allocatable.o -c .../allocatable.cpp
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
- en: em++ .../array-constructor.o -c .../array-constructor.cpp
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
- en: emar -rcs build/flang/runtime/libFortranRuntime.a .../binary-to-decimal.o
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]file build/flang/runtime/libFortranRuntime.a'
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
- en: 'build/flang/runtime/libFortranRuntime.a: current ar archive'
  id: totrans-split-188
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs try again, linking in our shiny new library as part of the Emscripten
    build step.
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o'
  id: totrans-split-190
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]emcc hello.c hello.o build/flang/runtime/libFortranRuntime.a -o
    hello.js'
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
- en: 'wasm-ld: warning: function signature mismatch: _FortranAioOutputAscii'
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
- en: '>>> defined as (i32, i32, i64) -> i32 in hello.o'
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
- en: '>>> defined as (i32, i32, i32) -> i32 in build/flang/runtime/libFortranRuntime.a(io-api.o)'
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
- en: Success? Not quite. A warning is issued, letting us know about a signature mismatch.
    Emscripten has compiled the symbol `_FortranAioOutputAscii` to take three `i32`
    arguments. However, `flang-new` has compiled `hello.f08` with the expectation
    that the symbol takes two `i32` arguments and a single `i64` argument.
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
- en: ^(25)¬†This is [LLVM IR notation](https://llvm.org/docs/LangRef.html#integer-type),
    meaning an integer of size 32 bits.
  id: totrans-split-196
  prefs: []
  type: TYPE_NORMAL
- en: ^(26)¬†This continues to crop up when compiling R packages for webR. Package
    authors or vendored libraries may have used tools such as `f2c` that declare a
    Fortran `SUBROUTINE` to return an `int`, while other libraries might declare a
    Fortran `SUBROUTINE` to return `void`. Who is right? I‚Äôm not sure, as I understand
    it early Fortran did not have a standard interface to C. Personally, I think returning
    `void` makes most sense.
  id: totrans-split-197
  prefs: []
  type: TYPE_NORMAL
- en: This is unfortunate. Despite being emitted as just a warning, if you try running
    the emitted program using Node you will see that the problem is catastrophic.
    WebAssembly, unlike a lot of target systems, absolutely requires that symbols
    defined over multiple compilation units have consistent function signatures, both
    in argument and return type.
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]node hello.js'
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
- en: '.../fortran/hello.js:128'
  id: totrans-split-200
  prefs: []
  type: TYPE_NORMAL
- en: throw ex;
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
- en: ^
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
- en: 'RuntimeError: unreachable'
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
- en: at wasm://wasm/001a0366:wasm-function[20]:0x15d9
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
- en: at removeRunDependency (/Users/georgestagg/fortran/hello.js:630:7)
  id: totrans-split-205
  prefs: []
  type: TYPE_NORMAL
- en: Node.js v18.18.0
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than going over the debugging process that eventually leads us to what
    is going on here, let me point you directly to the cause of the problem. Take
    a look at this comment from the LLVM source:'
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-split-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*And therein lies the problem. For us, the host is different to the target,
    breaking assumptions in the LLVM source code. Surprisingly, this does not cause
    as much chaos as you might expect. From what I can tell, this machinery is used
    only to make the Fortran runtime library functions, written in C++, available
    to Fortran. There is a compile-time calculation using `sizeof()`, and since most
    of the sizes match anyway it mostly works fine.'
  id: totrans-split-210
  prefs: []
  type: TYPE_NORMAL
- en: ^(27)¬†The [C data model](https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models)
    for the host and target defines how many bits certain fundamental C types are
    represented with. The specific sizes can differ based on the hardware architecture
    and your OS.
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately for us, assuming you‚Äôre following along on a modern 64-bit Unix-like
    system such as Linux or macOS, the sizes don‚Äôt match for the `long` data type.
    The result of `sizeof(long)` on our compiler‚Äôs host platform is 8 bytes (`i64`),
    but for the target platform of `wasm32-unknown-emscripten` the returned value
    should be 4 bytes (`i32`).
  id: totrans-split-212
  prefs: []
  type: TYPE_NORMAL
- en: When we compile the Fortran runtime library C++ code using Emscripten, things
    are fine. The resulting symbols are compiled with signatures such that `long`
    arguments are `i32`. However, when we compile our Fortran code with `flang-new`
    the external library symbols are declared such that `long` arguments are `i64`.
    This difference leads to the inconsistent function signature warning and runtime
    failure.
  id: totrans-split-213
  prefs: []
  type: TYPE_NORMAL
- en: Why did using `PRINT()` in our ‚ÄúHello, World!‚Äù program invoke a function that
    takes an argument of type `long`? Well, in some implementations of Fortran there
    are so-called ‚Äúhidden‚Äù arguments that are added whenever you pass a Fortran `CHARACTER`
    type to a function or subroutine. These extra arguments pass in the length of
    the strings. In the Fortran runtime library the hidden arguments are declared
    with type `size_t` which, following a chain of `typedef`s, ends up being the same
    as `unsigned long`. This hidden implicit argument is the one with inconsistent
    size.****  ***## Hacking around the issue
  id: totrans-split-214
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, I don‚Äôt know enough about the LLVM or Flang internals to implement
    a real solution to this problem. Ideally, `flang-new` would emit the correct use
    of `i32` or `i64` for the target architecture and data model when cross-compiling,
    no matter the host architecture the compiler is running on.
  id: totrans-split-215
  prefs: []
  type: TYPE_NORMAL
- en: Since I can‚Äôt solve this today, let‚Äôs hack around it for now. We‚Äôll build a
    version of `flang-new` with the size of a `long` hard-coded to what we need for
    `wasm32` and Emscripten. We‚Äôll also make some changes so that calls to `malloc()`
    from Fortran are emitted with an `i32` argument.
  id: totrans-split-216
  prefs: []
  type: TYPE_NORMAL
- en: ^(28)¬†This additionally fixes dynamic allocation with `ALLOCATE()`, a feature
    introduced in Fortran 90.
  id: totrans-split-217
  prefs: []
  type: TYPE_NORMAL
- en: The required patches are again shown as a diff below. If you‚Äôre following along,
    save it as a file named `force-4-byte-values.diff` and apply it to the `llvm-project`
    directory using `git` or the `patch` utility. Finally, recompile `flang-new` once
    more.
  id: totrans-split-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*[~/fortran]patch -p1 -d llvm-project < force-4-byte-values.diff'
  id: totrans-split-220
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]cmake --build build'
  id: totrans-split-221
  prefs: []
  type: TYPE_NORMAL
- en: '[0/60] Building CXX object tools/flang/lib/Lower/Runtime.cpp.o'
  id: totrans-split-222
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-split-223
  prefs: []
  type: TYPE_NORMAL
- en: '[49/49] Generating ../../../../include/flang/ieee_arithmetic.f18.mod'
  id: totrans-split-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Once LLVM has been rebuilt, try compiling our program once again. This time,
    it should compile without any warnings and successfully run under Node:'
  id: totrans-split-225
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o'
  id: totrans-split-226
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]emcc hello.c hello.o build/flang/runtime/libFortranRuntime.a -o
    hello.js'
  id: totrans-split-227
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]node hello.js'
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
- en: Hello, World!*********  ***# Compiling BLAS and LAPACK for WebAssembly
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a Fortran compiler that can output WebAssembly objects, let‚Äôs
    build some Fortran projects. [BLAS](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms)
    (Basic Linear Algebra Subprograms) is a set of low-level routines that perform
    many common operations in linear algebra, including tools for matrix and vector
    multiplication. They are a de facto standard in numerical computation, with several
    different implementations of the BLAS routines available. Some implementations
    have been tuned for use on certain hardware, others have been well optimised on
    account of being around for a long time ‚Äî the original BLAS routines were released
    in 1979!
  id: totrans-split-230
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs grab a copy of the latest release of the so-called ‚Äúreference implementation‚Äù
    of BLAS, written in Fortran 90, and compile it using the patched LLVM we built
    above.
  id: totrans-split-231
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]curl -L https://www.netlib.org/blas/blas-3.12.0.tgz > blas-3.12.0.tgz'
  id: totrans-split-232
  prefs: []
  type: TYPE_NORMAL
- en: '% Total % Received % Xferd Average Speed Time Time Time Current'
  id: totrans-split-233
  prefs: []
  type: TYPE_NORMAL
- en: Dload Upload Total Spent Left Speed
  id: totrans-split-234
  prefs: []
  type: TYPE_NORMAL
- en: 100 323k 100 323k 0 0 317k 0 0:00:01 0:00:01 --:--:-- 317k
  id: totrans-split-235
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]tar xzf blas-3.12.0.tgz'
  id: totrans-split-236
  prefs: []
  type: TYPE_NORMAL
- en: We‚Äôll need to modify `BLAS-3.12.0/make.inc` to tell it about our version of
    `flang-new` and the Emscripten tools. Modify the following settings, leaving the
    other lines in that file as they are, then build BLAS using `make`.
  id: totrans-split-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*[~/fortran]cd BLAS-3.12.0'
  id: totrans-split-239
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran/BLAS-3.12.0]make'
  id: totrans-split-240
  prefs: []
  type: TYPE_NORMAL
- en: ../build/bin/flang-new -O2 -c -o isamax.o isamax.f
  id: totrans-split-241
  prefs: []
  type: TYPE_NORMAL
- en: ../build/bin/flang-new -O2 -c -o sasum.o sasum.f
  id: totrans-split-242
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-split-243
  prefs: []
  type: TYPE_NORMAL
- en: emar cr blas_LINUX.a isamax.o ... xerbla_array.o
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
- en: emranlib blas_LINUX.a
  id: totrans-split-245
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran/BLAS-3.12.0]cd ..'
  id: totrans-split-246
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]'
  id: totrans-split-247
  prefs: []
  type: TYPE_NORMAL
- en: That went pretty well! Let‚Äôs try using it in a Fortran subroutine compiled for
    WebAssembly. For fun, we‚Äôll try working with double precision complex numbers.
    We‚Äôll use the BLAS level 2 routine [`ZGEMV()`](https://netlib.org/lapack/explore-html-3.6.1/dc/dc1/group__complex16__blas__level2_gafaeb2abd9fffa7442b938dc384aeaf47.html#gafaeb2abd9fffa7442b938dc384aeaf47),
    which performs the matrix-vector operation
  id: totrans-split-248
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{equation} \mathbf{y} \leftarrow \alpha\mathbf{A}\mathbf{x} + \beta\mathbf{y},
    \end{equation}\]
  id: totrans-split-249
  prefs: []
  type: TYPE_NORMAL
- en: where \(\alpha\) and \(\beta\) are scalar constants, \(\mathbf{x}\) and \(\mathbf{y}\)
    are vectors, and \(\mathbf{A}\) is a matrix. Our Fortran routine will take in
    `alpha`, `beta`, `A`, `X`, and `Y`, with a fixed parameter `N` so that \(\mathbf{A}\)
    is a square matrix with three rows and columns. The result is written back into
    \(\mathbf{y}\), so we declare that `Y` is of intent `INOUT`.
  id: totrans-split-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Notice how with some BLAS routines, `CHARACTER` strings of length one control
    configuration settings. Here, we pass `''N''` as the first argument. It is one
    of the reasons we spent time and care above building a version of `flang-new`
    that can deal with `CHARACTER` arguments and their hidden implicit length arguments
    for the `wasm32` target.'
  id: totrans-split-252
  prefs: []
  type: TYPE_NORMAL
- en: Next, we‚Äôll write a C program to create some complex variables, send them to
    Fortran and BLAS for processing, and print the result. This will let us know both
    that passing double precision complex numbers to Fortran and calling BLAS routines
    works as expected.
  id: totrans-split-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-split-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*[~/fortran]./build/bin/flang-new -c bar.f08 -o bar.o'
  id: totrans-split-255
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]emcc bar.c bar.o build/flang/runtime/libFortranRuntime.a BLAS-3.12.0/blas_LINUX.a
    -o bar.js'
  id: totrans-split-256
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]node bar.js'
  id: totrans-split-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Y[0]: 23.000000 + 6.000000i, Y[1]: 18.000000 + 10.000000i, Y[2]: 6.000000 +
    16.000000i'
  id: totrans-split-258
  prefs: []
  type: TYPE_NORMAL
- en: 'And there we have it: BLAS compiled from Fortran 90 sources and running under
    WebAssembly! To finish up, let‚Äôs confirm for ourselves that this output is correct,'
  id: totrans-split-259
  prefs: []
  type: TYPE_NORMAL
- en: ^(31)¬†Keeping in mind Fortran‚Äôs column-major array layout.
  id: totrans-split-260
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{equation} \begin{split} \alpha\mathbf{A}\mathbf{x} & + \beta\mathbf{y}
    \\[0.5em] & = \begin{pmatrix} i & 7 & 8\\ 4 & 2i & 9\\ 5 & 6 & 3i \end{pmatrix}
    \cdot \begin{pmatrix} 0\\1\\2 \end{pmatrix} + 2i \begin{pmatrix} 3\\4\\5 \end{pmatrix}\\[0.5em]
    & = \begin{pmatrix} 23+6i\\18+10i\\6+16i \end{pmatrix}. \end{split} \end{equation}\]
  id: totrans-split-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: A handwritten digit classifier'
  id: totrans-split-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following demo uses a [multi-layer perceptron (MLP)](https://en.wikipedia.org/wiki/Multilayer_perceptron)
    artificial neural network to classify hand-drawn digits. Try it out with your
    mouse or touchscreen! Just draw a digit from 0-9 in the box, and the classifier
    will try to label what digit you wrote. The relative probabilities according to
    the network are shown in a plot on the right.
  id: totrans-split-263
  prefs: []
  type: TYPE_NORMAL
- en: It‚Äôs not a perfect model, but it works fairly well for me! The weights powering
    the model have been pre-trained using Python, but the classification is performed
    at runtime using JavaScript and WebAssembly, running in your browser right now.
  id: totrans-split-264
  prefs: []
  type: TYPE_NORMAL
- en: With an MLP network, the classification process is essentially a repeated application
    of matrix-vector addition and multiplication. In this demo the heavy lifting is
    done by a single Fortran subroutine making use of the BLAS level 2 routine [`DGEMV()`](https://netlib.org/lapack/explore-html-3.6.1/d7/d15/group__double__blas__level2_gadd421a107a488d524859b4a64c1901a9.html).
  id: totrans-split-265
  prefs: []
  type: TYPE_NORMAL
- en: Building LAPACK
  id: totrans-split-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[LAPACK](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms) (Linear
    Algebra Package) is a software library for solving linear algebra problems numerically.
    It‚Äôs built upon BLAS and has similarly become a standard with many reimplementations
    designed for specific hardware or systems.'
  id: totrans-split-267
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs finish this post by also building the ‚Äúreference implementation‚Äù of LAPACK.
  id: totrans-split-268
  prefs: []
  type: TYPE_NORMAL
- en: ^(32)¬†Also available from [netlib](https://www.netlib.org/lapack/), released
    under a modified BSD licence.
  id: totrans-split-269
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]curl -L https://github.com/Reference-LAPACK/lapack/archive/refs/tags/v3.12.0.tar.gz
    > lapack-3.12.0.tgz'
  id: totrans-split-270
  prefs: []
  type: TYPE_NORMAL
- en: '% Total % Received % Xferd Average Speed Time Time Time Current'
  id: totrans-split-271
  prefs: []
  type: TYPE_NORMAL
- en: Dload Upload Total Spent Left Speed
  id: totrans-split-272
  prefs: []
  type: TYPE_NORMAL
- en: 100 7747k 0 7747k 0 0 4117k 0 --:--:-- 0:00:01 --:--:-- 6655k
  id: totrans-split-273
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]tar xzf lapack-3.12.0.tgz'
  id: totrans-split-274
  prefs: []
  type: TYPE_NORMAL
- en: Similar to BLAS, we need to modify some configuration options to let LAPACK
    know about Emscripten and `flang-new`. Copy the file `lapack-3.12.0/make.inc.example`
    to `lapack-3.12.0/make.inc`, then make the following modifications. Be sure to
    replace `[...]` with the full path to the build directory on your machine, and
    leave the other options in the file as they are.
  id: totrans-split-275
  prefs: []
  type: TYPE_NORMAL
- en: ^(33)¬†A relative path doesn‚Äôt work here. Alternatively, simply set the option
    to read `flang-new` and make it available on your `$PATH`.
  id: totrans-split-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-split-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Then, build LAPACK using the `make lib` command to create the WebAssembly
    static library `liblapack.a`.'
  id: totrans-split-278
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]cd lapack-3.12.0'
  id: totrans-split-279
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran/lapack-3.12.0]make lib'
  id: totrans-split-280
  prefs: []
  type: TYPE_NORMAL
- en: make -C SRC
  id: totrans-split-281
  prefs: []
  type: TYPE_NORMAL
- en: '.../build/bin/flang-new -O2 -c -o sbdsvdx.o sbdsvdx.f'
  id: totrans-split-282
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-split-283
  prefs: []
  type: TYPE_NORMAL
- en: emar cr ../../libtmglib.a slatms.o ... dlarnd.o
  id: totrans-split-284
  prefs: []
  type: TYPE_NORMAL
- en: emranlib ../../libtmglib.a
  id: totrans-split-285
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran/lapack-3.12.0]cd ..'
  id: totrans-split-286
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]'
  id: totrans-split-287
  prefs: []
  type: TYPE_NORMAL
- en: '[~/fortran]file lapack-3.12.0/liblapack.a'
  id: totrans-split-288
  prefs: []
  type: TYPE_NORMAL
- en: 'lapack-3.12.0/liblapack.a: current ar archive'
  id: totrans-split-289
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, LAPACK routines can be called in a similar way to the BLAS routine
    example in the previous section.*  *## Example: Polynomial Interpolation with
    Linear Algebra'
  id: totrans-split-290
  prefs: []
  type: TYPE_NORMAL
- en: The following demo finds interpolating polynomials for a set of points, demonstrating
    LAPACK routines running in your web browser.
  id: totrans-split-291
  prefs: []
  type: TYPE_NORMAL
- en: Click the plot to add new points. An interpolating polynomial will be found
    to pass through all the points using [Vandermonde‚Äôs method](https://en.wikipedia.org/wiki/Vandermonde_matrix).
    The linear algebra equation given by this method is then solved numerically in
    LAPACK using the [`DGELS()`](https://netlib.org/lapack/explore-html-3.6.1/d7/d3b/group__double_g_esolve_ga1df516c81d3e902cca1fc79a7220b9cb.html#ga1df516c81d3e902cca1fc79a7220b9cb)
    routine.
  id: totrans-split-292
  prefs: []
  type: TYPE_NORMAL
- en: ^(34)¬† It is always possible to find an \(n-1\) degree polynomial containing
    \(n\) data points exactly. However, when \(n\) is large the polynomial fluctuates
    wildly between successive data points. This problem is known as [Runge‚Äôs phenomenon](https://en.wikipedia.org/wiki/Runge%27s_phenomenon)
    and can be avoided by using [spline interpolation](https://en.wikipedia.org/wiki/Spline_interpolation).*******
  id: totrans-split-293
  prefs: []
  type: TYPE_NORMAL
