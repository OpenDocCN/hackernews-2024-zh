- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:32:33'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: HTML attributes vs DOM properties - JakeArchibald.com
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://jakearchibald.com/2024/attributes-vs-properties/](https://jakearchibald.com/2024/attributes-vs-properties/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Attributes and properties are *fundamentally* different things. You can have
    an attribute and property of the same name set to different values. For example:'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-7
  prefs: []
  type: TYPE_PRE
- en: 'It seems like fewer and fewer developers know this, partially thanks to frameworks:'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-9
  prefs: []
  type: TYPE_PRE
- en: If you do the above in a framework's templating language, you're using attribute-like
    syntax, but under the hood it'll sometimes be setting the property instead, and
    when it does that differs from framework to framework. In some cases, it'll set
    a property *and* an attribute as a side-effect, but that isn't the framework's
    fault.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, these distinctions don't matter. I think it's good that developers
    can have a long and happy career without caring about the differences between
    properties and attributes. But, if you need to dig down into the DOM at a lower
    level, it helps to know. Even if you feel you know the difference, maybe I'll
    touch on a couple of details you hadn't considered. So let's dig in…
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to the interesting stuff, let''s get some of the technical differences
    out of the way:'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes serialise to HTML, whereas properties don''t:'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-14
  prefs: []
  type: TYPE_PRE
- en: So when you're looking at the elements panel in browser developer tools, you're
    only seeing attributes on elements, not properties.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to work in the serialised format, attribute values are always strings,
    whereas properties can be any type:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
- en: Attribute names are case-insensitive, whereas property names are case-sensitive.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-19
  prefs: []
  type: TYPE_PRE
- en: However, attribute *values* are case-sensitive.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, here''s where things start to get blurry:'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this:'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-23
  prefs: []
  type: TYPE_PRE
- en: This seems to contradict the first example in the post, but the above only works
    because `Element` has an `id` getter & setter that 'reflects' the `id` attribute.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: When a property reflects an attribute, the *attribute* is the source of the
    data. When you set the property, it's updating the attribute. When you read from
    the property, it's reading the attribute.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, most specs will create a property equivalent for every defined
    attribute. It didn't work in the example at the start of the article, because
    `foo` isn't a spec-defined attribute, so there isn't a spec-defined `foo` property
    that reflects it.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: '[Here''s the spec for `<ol>`](https://html.spec.whatwg.org/multipage/grouping-content.html#the-ol-element).
    The "Content attributes" section defines the attributes, and the "DOM interface"
    defines the properties. If you click on `reversed` in the DOM interface, it takes
    you to this:'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: The `reversed` and `type` IDL attributes must [reflect](https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#reflect)
    the respective content attributes of the same name.
  id: totrans-split-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But some reflectors are more complex…
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: Ok, this is relatively minor, but sometimes the property has a different name
    to the attribute it reflects.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases it''s just to add the kind of casing you''d expect from a property:'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: On `<img>`, `el.crossOrigin` reflects the `crossorigin` attribute.
  id: totrans-split-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On all elements, `el.ariaLabel` reflects the `aria-label` attribute (the aria
    reflectors became cross browser in late 2023\. Before that you could only use
    the attributes).
  id: totrans-split-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some cases, names had to be changed due to old JavaScript reserved words:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: On all elements, `el.className` reflects the `class` attribute.
  id: totrans-split-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On `<label>`, `el.htmlFor` reflects the `for` attribute.
  id: totrans-split-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Properties come with validation and defaults, whereas attributes don''t:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-38
  prefs: []
  type: TYPE_PRE
- en: In this case, the validation is handled by the `type` getter. The setter allowed
    the invalid value `'foo'`, but when the getter saw the invalid value, or no value,
    it returned `'text'`.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Some properties perform type coercion:'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-41
  prefs: []
  type: TYPE_PRE
- en: In this case, the `open` property is a boolean, returning whether the attribute
    exists. The setter also coerces the type - even though the setter is given `'hello'`,
    it's turned to a boolean rather than going directly to the attribute.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: Properties like `img.height` coerce the attribute value to a number. The setter
    converts the incoming value to a number, and treats negative values as 0.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: '`value` is a fun one. There''s a `value` property and a `value` attribute.
    However, the `value` property does not reflect the `value` attribute. Instead,
    the `defaultValue` property reflects the `value` attribute.'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: I know, I know.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the `value` property doesn't reflect *any* attribute. That isn't unusual,
    there's loads of these (`offsetWidth`, `parentNode`, `indeterminate` on checkboxes
    for some reason, and many more).
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, the `value` property defers to the `defaultValue` property. Then,
    once the `value` property is set, either via JavaScript or through user interaction,
    it switches to an internal value. It''s as if it''s implemented *roughly* like
    this:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-48
  prefs: []
  type: TYPE_PRE
- en: 'So:'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-50
  prefs: []
  type: TYPE_PRE
- en: This would have made way more sense if the `value` attribute was named `defaultvalue`.
    Too late now.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, attributes should be for configuration, whereas properties can
    contain state. I also believe that the light-DOM tree should have a single owner.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: In that sense, I think `<input value>` gets it right (aside from the naming).
    The `value` attribute configures the default value, whereas the `value` property
    gives you the current state.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: It also makes sense that validation applies when getting/setting properties,
    but never when getting/setting attributes.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: I say 'in my opinion', because a couple of recent HTML elements have done it
    differently.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: The `<details>` and `<dialog>` elements represent their open state via the `open`
    attribute, and the browser will self add/remove this attribute in response to
    user interaction.
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: I think this was a design mistake. It breaks the idea that attributes are for
    configuration, but more importantly it means that the system in charge of maintaining
    the DOM (a framework, or vanilla JS) needs to be prepared for the DOM to change
    itself.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: 'I think it should have been:'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
- en: And a `details.open` property to get/set the current state, along with a CSS
    pseudo-class for targeting that state.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Update: [Simon Peters](https://twitter.com/zcorpan) unearthed some of the [early
    design discussion around this](https://lists.whatwg.org/pipermail/whatwg-whatwg.org/2007-August/054532.html).'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: I guess `contenteditable` also breaks that contract, but… well… it's a opt-in
    to a lot of breakage.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the example from earlier:'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-64
  prefs: []
  type: TYPE_PRE
- en: How do frameworks handle this?
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: Aside from a predefined set of cases where they favour attributes, they'll set
    the prop as a property if `propName in element`, otherwise they'll set an attribute.
    Basically, they prefer properties over attributes. Their render-to-string methods
    do the opposite, and ignore things that are property-only.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: React does things the other way around. Aside from a predefined set of cases
    where they favour properties, they'll set an attribute. This makes their render-to-string
    method similar in logic.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: This explains why custom elements don't seem to work in React. Since they're
    custom, their properties aren't in React's 'predefined list', so they're set as
    attributes instead. Anything that's property-only on the custom element simply
    won't work. This will be fixed in React 19, where they'll switch to the Preact/VueJS
    model for custom elements.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: The funny thing is, React popularised using `className` instead of `class` in
    what *looks like* an attribute. But, even though you're using the property name
    rather than the attribute name, [React will set the `class` attribute under the
    hood](https://github.com/facebook/react/blob/699d03ce1a175442fe3443e1d1bed14f14e9c197/packages/react-dom-bindings/src/client/ReactDOMComponent.js#L388-L389).
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Lit does things a little differently:'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-71
  prefs: []
  type: TYPE_PRE
- en: It keeps the distinction between attributes and properties, requiring you to
    prefix the name with `.` if you want to set the property rather than the attribute.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: That's pretty much everything I know about the difference between properties
    and attributes. If there's something I've missed, or you have a question, let
    me know in the comments below!
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to my [podcast husband](https://offthemainthread.tech/) [Surma](https://surma.dev/)
    for his usual reviewing skills.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
