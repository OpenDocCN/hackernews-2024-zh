<!--yml

category: 未分类

date: 2024-05-27 13:23:14

-->

# 协程和效果

> 来源：[https://without.boats/blog/coroutines-and-effects/](https://without.boats/blog/coroutines-and-effects/)

在过去的几个月里，我一直在思考一些事情，这些都是由Russell Johnston让我意识到的关于效果系统与协程之间关系的。你可以在这里阅读更多他对这个主题的想法：[链接](https://www.abubalay.com/blog/2024/01/14/rust-effect-lowering)，他让我意识到效果系统（例如Koka中的那种）和协程（例如Rust的async函数或生成器）在某些方面是同构的。我一直在思考它们之间的差异，试图理解每种方法的优势和劣势。

几周前，Will Crichton在[Twitter](https://twitter.com/tonofcrates/status/1770560175835058573)上发布了一些东西，帮助我更清晰地理解了它们之间的对比：

> PL领域整体：如果它是动态作用域的&mldr;但是静态类型的&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;（效果，能力，上下文，元变量&mldr;）

我只是一个谦逊的语言设计者（尤其不是什么理论家，尤其不是PL的理论家），所以我的重点是用户体验和可负担性的差异。但这似乎是一个尖锐的洞察力，效果处理程序的这种属性 - 静态类型但动态作用域 - 对我来说似乎是理解效果处理程序和协程之间差异的一个很好的起点。

# 背景

## 什么是协程？

协程是一种可以在完成之前将控制权返回给其调用者的函数。然后，调用者具有协程在暂停时的状态的引用，因此如果选择的话，可以再次恢复协程。通过让协程产生值，可以使用协程来模拟许多有意义的“效果”。例如：

+   协程可以通过产生像`Pending`这样的值来“异步”执行IO时的操作。

+   协程可以通过在遍历某些集合时产生值来实现可迭代。

+   协程可以通过产生异常值来模拟异常（在这种情况下，恢复协程不会产生效果）。

例如，Rust使用协程模型来同时处理异步和迭代。另一方面，异常不是用这种方式建模的；而是用`Result`类型建模。具体来说，Rust使用“无栈”协程，但这种区别对本文中的概念并不是很重要。

## 什么是效果处理程序？

我需要澄清一点，因为术语在Rust社区中变得混乱：这篇文章与“效果泛型”（Rust项目中的概念）没有特别的关系，后者是与Rust处理效果相关的一组不同的语义特征。在这篇文章中，我关注的是像[Koka](https://koka-lang.github.io/koka/doc/index.html)和[Effekt](https://effekt-lang.org)等语言中提出的效果系统。我对这些系统的理解可能不完美或错误，但这是我理解它们的方式。

在效果系统中，除了类型之外，表达式还会有一个*效果*。从形式上讲，效果是另一种“种类”，在类型系统中的意义上（就像生命周期在Rust中是另一种“种类”一样）。通常情况下，表达式会继承其包含的其他表达式的效果。函数会继承其主体的效果。

例如，Koka有一个“发散”效果，这意味着一个表达式可能发散（即，可能无法完成评估）。包含发散表达式的表达式也是发散的。因此，你可以在类型系统中区分保证完成和可能不会完成的函数（当然，由于停机问题的不可判定性，一些不发散的函数也会被标记为发散）。

然而，这些语言还有一个*效果处理程序*的概念，它们接受具有效果的表达式并“处理”它，生成一个没有该效果的表达式。并非所有效果都可以处理（例如，据我了解，不能有意义地处理发散效果），但有些可以。处理效果的语义是效果系统变得类似于协程的地方。

当发生可处理的效果时，具有效果的表达式会将控制权交给该效果的最近处理程序，这可能会或可能不会将控制权归还。这可用于模拟与协程相同类型的所有效果。例如：

+   IO效果可以将控制权交给IO处理程序，后者在IO完成时将控制权归还给表达式。

+   可迭代效果可以将控制权每个值都交给循环消费者，然后再归还给可迭代对象以继续迭代。

+   异常效果可以将控制权交给异常处理程序，而后者将不会将控制权归还。

# 这两者之间的区别在于静态和动态作用域。

协程和效果处理程序之间的关键区别在于，协程将控制权归还给其调用者，而具有效果的表达式将控制权归还给其处理程序。这意味着它所承载的功能差异是协程优于效果处理程序的实质性优势。

让我们想象一种编程语言，在这种语言中，每个函数都是一个可以yield `Pending`或异常（用于模拟IO和异常）的协程，而且还有多种调用操作符会“处理效果”：

+   有一个普通的调用运算符，只能用于从不产生`yield`的协程（这些协程实际上是纯函数）。

+   有一个异步`().await`调用运算符，可以在产生`Pending`的协程上调用，它产生`Pending`然后再次调用它们（因此只能从另一个产生`Pending`的协程中调用）。

+   有一个抛出异常的`()?`调用运算符，可以在产生异常的协程上调用，它会将异常向外传递。

+   还有一个结合的`().await?`调用运算符，可以在产生`Pending`和异常的协程上调用，以同时处理这两种效果。

假设你想在这种语言中进行HTTP请求（它执行IO并且还可以引发代表某种IO错误的异常）：

```
fn get_blog() -> HttpResponse yields (Pending | Exception) {  http::get("https://without.boats").await? } 
```

现在，让我们将其与一个类似的语言进行对比，该语言使用效果来模拟IO和异常。在这种语言中，没有特殊的调用运算符的需求：具有IO或异常效果的函数可以调用同样具有IO或异常效果的函数。

```
fn get_blog() -> HttpResponse effect (IO | Exception) {  http::get("https://without.boats") } 
```

这些特性之间的区别在于，对`http::get`的调用必须使用`await`和`?`语法进行注释以转发其效果，而使用效果处理程序时，被调用者的效果转发是隐含的。

我想再退一步，然后我保证我会得出结论。除了我提供的定义之外，还有其他的协程定义，尤其是旧的定义。如果你仔细阅读[Wikipedia](https://en.wikipedia.org/wiki/Coroutine)，你会发现一个略有不同的定义，我所说的协程被称为“生成器”或“半协程”。在旧的定义中，协程可以指定它何时放弃控制权。这实际上是基于一个程序执行模型，其中没有程序堆栈：相反，每个协程是一个全局单例，将控制权交给它意味着在它上次离开的地方继续执行。相比之下，对于半协程来说，调用协程会产生一个新的堆栈帧，只能通过具有对该堆栈帧的引用的代码来恢复执行。

程序堆栈是今天程序执行的通用模型，我们将其视为不可避免的，但像其他任何东西一样，它也必须被发明出来。它是为了支持递归函数定义而发明的，但它在启用局部推理的方式上有其他优势：从函数体中，存在一个动态跳转点 - 即它返回的地方。从调用者的角度来看，这现在是静态已知的：函数将跳回到被调用的地方。

只有当语言引入允许额外动态跳转点的新功能时，才能违反此规则。长期以来流行的一种方式是异常的概念，它会展开调用堆栈直至处理它们的点。有两种类型的异常：未经检查的异常完全没有类型，而检查的异常则需要在可能抛出它们的任何函数上进行注释。

**效果处理器是检查异常的一种泛化形式**，具有该特性的所有优缺点。它们要求你注释具有效果的函数，但不要求你注释*可以发生*该效果的调用。因此，在检查函数体时，要理解效果发生的时机需要检查每个调用函数的类型签名。由于这是有意义的控制流，因此能够在不检查每个函数调用签名的情况下识别出错误发生点似乎非常有价值。这就是为什么Rust使用`Result`和`?`操作符而不是检查异常。

在这里有一个评估轴线，有三个观点：语言可以以完全在编译时不受检查的方式模拟效果：既动态类型又动态作用域。未经检查的异常（包括panic）就是一个例子；阻塞IO也是如此。语言可以在类型系统中模拟效果，但具有动态作用域。检查的异常和效果处理器都是这方面的例子。语言也可以以静态类型和词法作用域的方式模拟效果。这就是Rust对这些效果使用`Result`和`async/await`的方式。

（你可能注意到，设计空间中还有一个未涵盖的第四个位置：动态类型和词法作用域。这一类别的例子包括动态类型语言（如Python和JavaScript）中的async/await特性；你必须用`await`标注异步调用以获取其结果，但如果未这样做则不会导致编译时错误。）

```
 │   EXCEPTIONS          │   IO ──────────────────────────────────────────┼───────────────────────┼───────────────  │                       │ DYNAMICALLY TYPED & DYNAMICALLY SCOPED  │   panicking           │   blocking │                       │ STATICALLY TYPED & DYNAMICALLY SCOPED  │   checked exceptions  │   IO effect │                       │ STATICALLY TYPED & LEXICALLY SCOPED  │   Result              │   async/await │                       │ 
```

这些不是唯一可以用来模拟效果的语言特性，其他特性也属于这些类别之一。例如，单子（monads）也是静态类型和词法作用域的。然而，对单子的一个主要反对意见是它们以特定的分层方式模拟效果，例如`IO<Result<T, E>>`和`Result<IO<T>, E>`之间存在区别。而协程则是无序的：所有产生`Pending`和`Exception`的协程类型相同，没有顺序的区别。效果处理器也是如此。

例如，在Rust中就出现了关于[异步迭代器设计](/blog/poll-next)的辩论。基于`async fn next`的设计通过引入多个协程引入了任意的顺序，而基于单个协程的设计则没有做出区分；协程只是像`Pending`一样产生项目。这是我之前链接的文章中Russell Johnston的论点的关键：这种无分层特性被协程和效果处理器共享，并且是这些特性的优点。

另一方面，通过使用`Result`模拟错误，而不是某种协程，Rust确实引入了一种顺序。这在大多数情况下都是可以接受的，因为“抛出异常”的函数（通过`Err`求值）不应该被恢复，尽管它引入了一些怪癖，例如无法区分`Result`的迭代器（可能在`Err`后继续）和抛出错误的迭代器（不会继续）。如果生成器能够“产生异常”，那么它将与产生`Result`序列的生成器不同。但在实践中，我发现这种不足并不经常出现，所以我愿意把它留给未来语言解决理论问题。

总体而言，协程让我觉得是处理多种类型效果函数最有前途的方法，因为它们似乎处于设计的甜蜜点：静态类型、词法作用域且无分层。这就是为什么在任何语言中处理效果的起点都应该是协程特性（尽管如果语言不受Rust的限制，我更喜欢它是一个具有堆栈的协程特性，以便可以递归）。
