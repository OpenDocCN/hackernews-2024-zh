- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:28:02'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL: Documentation: 16: F.7. bloom — bloom filter index access method'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.postgresql.org/docs/current/bloom.html](https://www.postgresql.org/docs/current/bloom.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A Bloom filter is a space-efficient data structure that is used to test whether
    an element is a member of a set. In the case of an index access method, it allows
    fast exclusion of non-matching tuples via signatures whose size is determined
    at index creation.
  prefs: []
  type: TYPE_NORMAL
- en: A signature is a lossy representation of the indexed attribute(s), and as such
    is prone to reporting false positives; that is, it may be reported that an element
    is in the set, when it is not. So index search results must always be rechecked
    using the actual attribute values from the heap entry. Larger signatures reduce
    the odds of a false positive and thus reduce the number of useless heap visits,
    but of course also make the index larger and hence slower to scan.
  prefs: []
  type: TYPE_NORMAL
- en: This type of index is most useful when a table has many attributes and queries
    test arbitrary combinations of them. A traditional btree index is faster than
    a bloom index, but it can require many btree indexes to support all possible queries
    where one needs only a single bloom index. Note however that bloom indexes only
    support equality queries, whereas btree indexes can also perform inequality and
    range searches.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of creating a bloom index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The index is created with a signature length of 80 bits, with attributes i1
    and i2 mapped to 2 bits, and attribute i3 mapped to 4 bits. We could have omitted
    the `length`, `col1`, and `col2` specifications since those have the default values.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a more complete example of bloom index definition and usage, as well
    as a comparison with equivalent btree indexes. The bloom index is considerably
    smaller than the btree index, and can perform better.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A sequential scan over this large table takes a long time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Even with the btree index defined the result will still be a sequential scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the bloom index defined on the table is better than btree in handling
    this type of search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the main problem with the btree search is that btree is inefficient when
    the search conditions do not constrain the leading index column(s). A better strategy
    for btree is to create a separate index on each column. Then the planner will
    choose something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Although this query runs much faster than with either of the single indexes,
    we pay a penalty in index size. Each of the single-column btree indexes occupies
    2 MB, so the total space needed is 12 MB, eight times the space used by the bloom
    index.
  prefs: []
  type: TYPE_NORMAL
