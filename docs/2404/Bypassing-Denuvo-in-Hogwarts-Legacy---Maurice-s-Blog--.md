<!--yml

类别：未分类

日期：2024-05-27 12:47:49

-->

# 在《霍格沃茨传奇》中绕过Denuvo | Maurice的博客 🐍

> 来源：[https://momo5502.com/posts/2024-03-31-bypassing-denuvo-in-hogwarts-legacy/](https://momo5502.com/posts/2024-03-31-bypassing-denuvo-in-hogwarts-legacy/)

当我宣布我的《黑色行动3》完整性绕过时，有人评论说我的研究不令人印象深刻，建议我尝试分析Denuvo。

那种想法一直萦绕在我心中，所以我做了每个人都会做的事情，并在过去的五个月里利用空闲时间逆向工程并绕过《霍格沃茨传奇》中的Denuvo DRM。

显然，我没有EMPRESS那样的技术和经验，在几天内就完成这项任务，但没关系 😃

# Denuvo是如何工作的？[#](#how-does-denuvo-work)

![](img/c3455a23c82a01c7d2d2405ea61a9b69.png)

游戏收集硬件/软件特征形成指纹，并生成Steam票据（游戏拥有的证据）。

然后指纹和票据被发送到Denuvo服务器。

然后，Steam票据发送到Steam以确保用户确实拥有该游戏（显然我不知道他们服务器上在发生什么，所以这只是一个假设，但应该足够准确）。

如果用户真的拥有游戏，将生成一个仅在具有完全匹配指纹的PC上有效的Denuvo Token。

使用该Token，玩家现在可以运行游戏。

该游戏无法在没有Token的情况下运行，因为它用于例如在运行时解密某些值等用途。

除了使用Token解密值外，Denuvo还定期在运行时验证硬件特征以确保与Token匹配。

# 我的目标是什么？[#](#what-was-my-goal)

破解游戏不是我的目标。我喜欢《霍格沃茨传奇》，因此不打算造成任何伤害。我仅为自己进行纯研究。

因此，本文将故意保持模糊，不详细展示我如何分析和详细修补游戏，因为我不想再多惹任何法律麻烦。

我心中的真正目标是找到游戏用于生成指纹的所有特征，并修补它们。除此之外，我还想修补大部分运行时检查。

对于真正的破解，显然需要修补所有运行时检查。找到所有检查仍然是一项极其耗时的任务，所以任何能够完成的人都值得我最高的尊重。

但是，我确信一旦我修补了大部分运行时检查并发现了所有硬件特征，我将能够在足够的时间和动力下修补所有运行时检查。

我为自己设定的真正挑战是分析保护措施，以发现它用于指纹的所有绑定。

# 我是如何做到的？[#](#how-did-i-do-it)

使用在具有不匹配指纹的PC上的Denuvo Token将显示以下对话框：

![](img/d35fd0a6c1f4108a66e128c50a5e3fca.png)

因此，目标是跳过该对话框。

这是我希望能更多谈论的部分，但我认为这不是一个好主意。相反，我将粗略地概述我使用的工具。

为了弄清楚游戏收集了哪些功能，我使用了[Qiling](https://qiling.io/)反向工程框架。

Qiling模拟任何类型的二进制文件，允许完全对其进行仪器化。这真是一个强大的框架：

![Qiling](img/775b82dff2e264bcdbf38313b5a14063.png)

但是，它需要大量的脚本编写和适应。这绝对不是一个可以一键完成所有工作的工具。

事实上，它甚至有相当多的bug（例如错误仿真的Windows API）和缺少相当多的基本功能：我不得不实现很多我希望框架处理的基础功能，例如TLS支持 🥲。

它似乎主要是为Linux设计的，所以也许有一天我可以将我的补丁/修复上游，或者编写我自己的框架。谁知道呢。

但即使存在这些缺陷，我还是不能强调这个工具有多么有帮助。

完全适应Qiling并找到大部分指纹特征花了我大约两个月的时间。发现最后一个特征花了剩下的三个月，而且我是偶然发现的。

为了验证某个功能是否真的是指纹的一部分，我对其进行了补丁/欺骗，并检查了之前有效的Denuvo令牌现在无效并显示错误对话框。

对于我的大部分补丁，我不得不使用相当多的运行时反汇编来动态构建我的钩子和存根，这让我在各种反汇编器中发现了不少bug 😂。（事后看来，想想这个，Denuvo的人可能有意地包含了导致这些反汇编器出bug的指令。我不知道是不是这样，但如果是的话，那真是太聪明了。）

但是，由于制作便携式破解并不是目标，我大量使用了我自己的[hypervisor](https://github.com/momo5502/hypervisor)。例如，我用它在几个位置安装了EPT钩子，否则这些位置将太繁琐以手动修补。

有了所有功能，我强制游戏在我的PC上生成一个令牌，使用我的PC的指纹。使用所有我的补丁和钩子（总共约2000个），我现在想要使用为我的PC生成的令牌在我的笔记本电脑上运行游戏。

过了一段时间，我成功地让它运行到启动画面：

![](img/6a7caeade614fbe897ae83813141dddc.png)

这是我想达到的点。现在游戏可以使用为另一台机器发行的令牌启动，我非常高兴。

显然游戏仍然会偶尔在PC令牌上崩溃。有时我可以启动游戏并进行游戏，有时会崩溃。这是需要对所有运行时检查进行补丁的地方。

了解游戏如何执行这些操作只是时间和动力的问题。

然而，正如前面提到的，这仍然是一个巨大的任务，因此每个成功做到这一点的人都值得我最崇高的尊重。

# 我可以告诉你没有细节吗？[#](#are-there-no-details-i-can-tell-you)

Denuvo有一件事非常简单，但却如此复杂。它并不占保护的大部分，我还没看到它在任何地方有文档记录：

Denuvo并不总是以线性方式使用堆栈。

在现代计算机上，堆栈通常向下增长。如果将某些内容推送到堆栈上，堆栈指针会递减。如果从堆栈中移除，指针会递增。

这意味着指针上方的所有内存都被保留，下方的所有内容都是空闲的。

这个概念在Denuvo存在的情况下并不适用。元素存储在指针上方，以及下方。

只要每个人都遵守这一点，一切都会很顺利。但是，一旦有人试图线性使用堆栈，看似空闲区域中的值就会被覆盖，导致游戏崩溃。

例如，当使用硬件断点时会发生这种情况。当由断点触发的异常分派到应用程序时，异常上下文存储在堆栈上，覆盖了游戏使用的值。

这基本上使得硬件断点和许多其他技术要么极其难以使用，要么甚至不可能。

相反，我所做的是，为了仍然能够使用硬件断点，我编写了一个小型调试器。它附加到游戏上，其唯一工作是接收由硬件断点触发的异常。这样，异常就不会分派到游戏，因此也不会破坏堆栈。

这样的技术非常简单，但仍导致所有钩子都必须考虑到这一点，从而变得极为复杂。非常令人印象深刻。

# 那性能呢？[#](#what-about-performance)

每个人都知道Denuvo会降低性能，但这是否真的属实？

准确测量Denuvo造成的性能影响非常困难。需要知道Denuvo执行的所有确切代码片段。识别这些是一项极其庞大的工作。

相反，我将使用我的钩子完成这项工作的理由。

这不会直接测量Denuvo对性能的影响，但它会给我们一个估计，一个感觉，关于与Denuvo结合谈论性能损失的相关性。

一个很好的类比来形象化我即将测量的是：

想象一下你是一名开发者，想要衡量会议对你开发速度的影响。这正是我认为难以衡量的事情。

相反，我要测量的是：你是否有这么多会议，以至于考虑它们减慢你的速度是相关的？

换句话说，如果你一年只开一次会议，做详尽的测试根本不值得，因为它并不真正那么重要。

请注意，此分析仅适用于霍格沃茨传奇。我不知道其他由Denuvo保护的游戏是否适用！

[https://www.youtube.com/embed/6JriEmiZ1t0](https://www.youtube.com/embed/6JriEmiZ1t0)

视频

每次控制台打印`[MOMO] OVERHEAD`时，我的一个钩子就会触发。这基本上意味着 Denuvo 干预了游戏的执行（我不得不对其进行补丁）。这反过来意味着 Denuvo 在这些时候至少会造成“一些”（非零）性能开销。

人们可以看到 Denuvo 确实不时干预，但可以清楚地看到：它并不经常这样做，绝对不是每一帧。

它只是每隔几秒钟一次。有时甚至什么都不做。只有在主要事件发生时，场景切换、加载屏幕或类似情况时，日志似乎会累积。

这确切地告诉我们的是，在正常游戏过程中，与场景切换或加载屏幕期间相比，只执行了少量的 Denuvo 代码。然而，在这些情况下可能存在的性能问题对我来说似乎不相关。

事实上，我对记录的`OVERHEAD`行数非常惊讶，因为我预期传言是真实的，会有大量的行被刷屏，但事实并非如此！我没有看到任何刷屏发生，不像其他在每帧中交互的 DRM。

我不知道每行的确切开销是多少，但我知道我必须进行补丁。我的钩子只需要微调执行。虽然这并不意味着什么确定的事情，但我得出结论是，如果 Denuvo 做得更多，我的改动就必须更复杂。

我也不知道在那个时候 Denuvo 是否执行了其他的代码片段，只是我不需要挂钩而已。

然而，有了 2000 个钩子，我补丁了这么多检查，我认为这至少可以给出一个很好的近似估计。

对我个人而言，这表明 Denuvo 检查的频率如此之低，以至于它引起主要性能问题的可能性似乎相当低。在类比上，它可能更像是每年一次会议的范围内。

我不知道这是否属实。这需要一种不同、更耗时的测量方法，而在我看来，这似乎不值得设立。

下次我玩受 Denuvo 保护的游戏时，我不会担心它是性能问题的主要原因。

看来该保护非常好地集成到了游戏中。作为一个 DRM 开发者，我知道这通常是一个非常棘手的挑战，绝对需要手动集成和适应游戏。

# 为什么不测量 FPS？[#](#why-not-measure-fps)

我了解之前的所有测试测量的只是 Denuvo 交互的频率。缺少的是它们的大小。

不幸的是，我没有办法测量这些开销。单纯看 FPS 也不会给我任何确定的结果。

这是由于两个原因：

1.  Denuvo整合到游戏中可能本身就很复杂。这意味着游戏本身可能正在执行复杂的任务，这可能会导致性能下降，而不管Denuvo在此时执行检查。这很可能是事实，因为DRM检查通常会插入到这些位置。

1.  我的钩子导致了这些开销。我引入了许多复杂性层次。通过我的虚拟机管理程序使用EPT钩子会导致至少2次页面错误，导致2次VM退出（由于权限切换）。除此之外，我正在使用`OutputDebugString`向控制台记录日志，这是非常昂贵的，因为会引发异常。然而更糟糕的是，我让游戏自身进行调试。这导致异常和控制台日志被调试器同步拦截，而游戏必须等待。

因此，观察FPS并测量性能下降会产生两种情况：

根本没有性能下降，这意味着一切都被超级优化了，或者存在FPS下降。

如果FPS下降，结果可能会不明确，因为这可能意味着Denuvo有问题，游戏有问题，或者最可能的情况是：我的钩子有问题。

我的测量目标只是让人们对性能方向有直观感觉。

对我来说，至少表明Denuvo并不是那么糟糕。绝对不像我见过的其他DRM那样糟糕。

# 摘要[#](#summary)

这是我目前清单上的最后一件事情，我很高兴能划掉这一项。需要注意的是，Denuvo本可以采取一些不同的方式，这将使我的分析变得更加困难。

然而，我仍然不得不承认它是一种非常强大的保护机制。肯定有不止一次我差点要放弃了。除了其保护功能外，它似乎非常好地集成到游戏中，我无法测量到任何由此引起的相关性能开销。

开发DRM始终是一项极具挑战性的任务。无论使用DRM是否好，无论是为资本主义服务还是仅仅是保护开发者的辛勤工作，这是我无法决定的事情。尽管如此，我认为Denuvo并不应该因获得的所有厌恶而受到谴责。
