- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 13:40:28'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 13:40:28'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: ryjo.codes - Tour of CLIPS
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ryjo.codes - Tour of CLIPS
- en: 来源：[https://ryjo.codes/tour-of-clips.html](https://ryjo.codes/tour-of-clips.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://ryjo.codes/tour-of-clips.html](https://ryjo.codes/tour-of-clips.html)
- en: 0\. Introduction
  id: totrans-split-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 0\. 简介
- en: Over the last year and a half or so, I've been learning about the [CLIPS](https://www.clipsrules.net/)
    programming language. [A team of developers at NASA](https://clipsrules.net/AboutCLIPS.html)
    created CLIPS in the mid-'80s. It was released into the public domain in the mid-'90s,
    and it has been actively developed by one of the original team members [Gary Riley](http://www.clipsrules.net/AboutTheDeveloper.html)
    ever since.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 过去一年半左右，我一直在学习关于 [CLIPS](https://www.clipsrules.net/) 编程语言。[NASA 的一个开发团队](https://clipsrules.net/AboutCLIPS.html)
    在 80 年代中期创建了 CLIPS。它于 90 年代中期进入公共领域，并且自那时起一直由原始团队成员之一的 [Gary Riley](http://www.clipsrules.net/AboutTheDeveloper.html)
    积极开发。
- en: CLIPS has this air of mystery about it. There's no npm-like service that centralizes
    common CLIPS "libraries." A lot of writing about the language appears, on the
    surface, academic or higher-level. To top it off, the [Rete algorithm](https://en.wikipedia.org/wiki/Rete_algorithm)
    central to CLIPS can be rather intimidating to wrap one's head around.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: CLIPS 给人一种神秘感。没有像 npm 这样集中常见 CLIPS “库”的服务。关于这种语言的大部分写作表面上看起来都是学术性或更高层次的。更重要的是，CLIPS
    的核心 [Rete 算法](https://en.wikipedia.org/wiki/Rete_algorithm) 对于理解可能有些令人望而却步。
- en: Don't let these things deter you; CLIPS is well worth learning. Its Rules-based
    approach is a good primer to learning neural networks and AI. With this tutorial,
    you'll take your first steps into Rules Engines and Expert Systems.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这些事情吓到；CLIPS 绝对值得学习。它的基于规则的方法是学习神经网络和人工智能的良好入门。通过这个教程，你将迈出进入规则引擎和专家系统的第一步。
- en: First, we'll talk about why you should consider using CLIPS. At the heart of
    CLIPS is the [Rete algorithm](https://en.wikipedia.org/wiki/Rete_algorithm). This
    algorithm does a few very nice things for us. For one, it determines the order
    in which Rules should run. This allows us to focus on **what the domain business
    logic is** of our program rather than **how the software runs**. Second, the Rete
    network "caches" common calculations our software will make. Those who have written
    an in-app cache understand the benefits of this feature.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论为什么应该考虑使用 CLIPS。CLIPS 的核心是 [Rete 算法](https://en.wikipedia.org/wiki/Rete_algorithm)。该算法对我们有几个非常好的特性。首先，它确定规则运行的顺序。这使我们可以专注于我们程序的领域业务逻辑，而不是软件如何运行。其次，Rete
    网络“缓存”了软件将进行的常见计算。编写过应用内缓存的人都理解这一功能的好处。
- en: Another huge win for CLIPS is the excellent documentation and support provided
    by the lead developer [Gary Riley](http://www.clipsrules.net/AboutTheDeveloper.html).
    Take a look at the various guides of all levels linked in the [documentation section](https://clipsrules.net/#documentation)
    of the CLIPS homepage. Also, Mr. Riley is very active in various forums providing
    support for CLIPS. Once again, look at the main CLIPS website to find links to
    the [various avenues of support](https://clipsrules.net/#support).
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: CLIPS 的另一个巨大优势是主要开发者 [Gary Riley](http://www.clipsrules.net/AboutTheDeveloper.html)
    提供的出色文档和支持。请查看 CLIPS 主页的 [文档部分](https://clipsrules.net/#documentation)，里面链接了各种级别的指南。此外，Riley
    先生在各种论坛上活跃，为 CLIPS 提供支持。再次查看 CLIPS 主网站，找到 [各种支持途径的链接](https://clipsrules.net/#support)。
- en: Finally, CLIPS is still actively developed; its latest release 6.40 was published
    in May of 2021\. Pretty incredible!
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，CLIPS 仍在积极开发中；其最新版本 6.40 于 2021 年 5 月发布。相当不可思议！
- en: 0.a This Tutorial
  id: totrans-split-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 0.a 这个教程
- en: This tutorial is greatly inspired by the fantastic [A Tour of Go](https://go.dev/tour/welcome/1).
    Run the examples presented in this tutorial by clicking the `(batch*)` button
    under the code. The code in the box is editable, so tweak the code to test your
    curiosity. The output from the code will display in the box below the buttons.
    Navigate between the previous and next Chapters by clicking the links at the bottom
    of the screen. The left link (←) will navigate you to the previous chapter while
    the right link (→) will advance to the next chapter. Between these two links will
    show the name of the current Chapter. Click that link to reveal a list of all
    Chapters in this book. Clicking one of these Chapters should navigate you to the
    appropriate Chapter.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程深受精彩的[A Tour of Go](https://go.dev/tour/welcome/1)的启发。点击代码下方的`(batch*)`按钮运行本教程中的示例。框中的代码可编辑，因此可以调整代码以测试您的好奇心。代码的输出将显示在按钮下方的框中。通过点击屏幕底部的链接在前后章节之间导航。左链接（←）将导航到前一章节，右链接（→）将进入下一章节。这两个链接之间将显示当前章节的名称。点击该链接将显示本书中所有章节的列表。点击其中一个章节将导航到相应的章节。
- en: '[PRE0]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 1\. Saying Hello
  id: totrans-split-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1\. 说Hello
- en: The classic "first program" is the "Hello, World" program. This will show you
    how to output some text from your program. Click the `(batch*)` button under the
    code on the right hand side. You should see text appear in the box beneath the
    buttons.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的"第一个程序"是"Hello, World"程序。这将向您展示如何从您的程序中输出一些文本。在右侧代码下方点击`(batch*)`按钮。您应该会看到文本出现在按钮下方的框中。
- en: With CLIPS, there are a few ways we can print text to the screen. Using `(print)`
    will print words out, while `(println)` will print words out **with a new line
    at the end**. In the code sample to the right, you can see us using `(print)`
    to print the word "Hello". We then use `(println)` to print ", World!" and a new
    line character. Things printed after this text will appear on the next line.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CLIPS，我们可以通过几种方式将文本打印到屏幕上。使用`(print)`将输出单词，而`(println)`将输出带有**结尾处的新行**。在右侧的代码示例中，您可以看到我们使用`(print)`来打印单词"Hello"。然后我们使用`(println)`来打印",
    World!"和一个新行字符。在此文本后打印的内容将出现在下一行。
- en: '`(printout t)` is like `(print)` and `(println)`, but it allows you to send
    text to a given "router." In this case, we send the text to the router `t` which
    is what `(print)` and `(println)` send text to by default. We also use the text
    `crlf` as the last argument to `(printout`. We do this so that our text "breaks"
    at the end of the line; the next thing we print will appear beneath this current
    line. `crlf` stands for "carriage return line feed," which means "move the cursor
    to the beginning of the next line."'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`(printout t)`类似于`(print)`和`(println)`，但它允许您将文本发送到指定的"路由器"。在本例中，我们将文本发送到默认情况下发送文本的路由器`t`。我们还使用文本`crlf`作为`(printout`的最后一个参数。我们这样做是为了使我们的文本在行末"断开"；我们下一个打印的内容将出现在当前行下方。`crlf`代表"回车换行"，这意味着"将光标移动到下一行的开头"。'
- en: '`(format t)` allows you to print a sentence structure that contains "format
    flags." The `%s` and `%n` are format flags that specify a string and newline respectively.
    The next argument (in this case "fun") will be substituted in place of the `%s`.
    `%n` will be replaced with a new line character. To see more of these "format
    flags," check out the [Basic Programming Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf)
    -- specifically the section entitled **12.4.6 Formatted Printing** -- to learn
    more.'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`(format t)`允许您打印包含"格式标志"的句子结构。`%s`和`%n`是格式标志，分别指定字符串和换行符。下一个参数（在本例中是"fun"）将替换`%s`的位置。`%n`将被新行字符替换。要了解更多这些"格式标志"，请查看[Basic
    Programming Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf)
    -- 特别是**12.4.6格式化打印**一节 -- 以了解更多。'
- en: '[PRE1]'
  id: totrans-split-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 2\. Learning the Rules
  id: totrans-split-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2\. 学习规则
- en: Rules are an important part of understanding how CLIPS works. Rules consist
    of an "antecedent" and a "consequent." The antecedent is also known as the "if
    portion" or the "left-hand side." This part consists of the conditions that must
    be satisfied for the Rule to run.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是理解CLIPS工作原理的重要部分。规则由"前提"和"结论"组成。前提也称为"if部分"或"左侧部分"。此部分包含必须满足的条件，以使规则运行。
- en: The consequent is also known as the "then portion" or the "right-hand side."
    This part describes what will happen when the Rule is run.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: '"后续"也称为"then部分"或"右侧部分"。这部分描述了规则运行时会发生什么。'
- en: These two pieces are separated by a `=>`. The antecedent is before this symbol
    while the consequent is after it.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两部分由`=>`分隔开。前件在此符号之前，而后件在此符号之后。
- en: In this example, we define a Rule called `will-run-no-matter-what`. This particular
    Rule has nothing on the left-hand side so it will always run. The right-hand side
    specifies that a `(println)` will run.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个名为`will-run-no-matter-what`的规则。这个特定规则在左手边没有任何内容，所以它将始终运行。右手边指定了一个`(println)`将会运行。
- en: Finally after the Rule is defined, there is a `(run)`. In order for this to
    work, click the `(batch*)` button.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在规则被定义之后最后，有一个`(run)`。为了使其工作，请点击`(batch*)`按钮。
- en: '[PRE2]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 3\. Just the Facts
  id: totrans-split-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3\. Just the Facts
- en: In addition to Rules in CLIPS, we have "Facts." A Fact represents "data" in
    CLIPS. In order to put data into CLIPS, we `(assert)`. Once we have `(assert)`ed
    Facts, they are said to be "in working memory."
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CLIPS中的规则，我们还有“Facts”。事实在CLIPS中表示“数据”。为了将数据放入CLIPS中，我们使用`(assert)`。一旦我们`(assert)`了事实，它们就被称为“在工作内存中”。
- en: In the code to the right, we `(assert)` one `(name` Fact with `ryjo` in its
    second field.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的代码中，我们`(assert)`了一个`(name`事实，并在其第二个字段中使用了`ryjo`。
- en: We then print a single line of text with our old friend `(println)`.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着用我们的老朋友`(println)`打印一行文本。
- en: '`(facts)` is a new one. We use this to print out the Facts stored in Working
    Memory. In this case, we see 1 fact printed with an index `1` as denoted by `f-1`.'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`(facts)` is a new one. We use this to print out the Facts stored in Working
    Memory. In this case, we see 1 fact printed with an index `1` as denoted by `f-1`.'
- en: Finally, we'll `(retract` this Fact that we just asserted. We can reference
    this Fact with its index `1`.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`(retract)`刚刚断言的这个事实。我们可以通过其索引`1`引用这个事实。
- en: 'Note: If you click `(batch*)` multiple times in a row, an error will appear.
    This is because we must `(reset)` or `(clear)` the environment to reset the ids
    assigned to Facts in Working Memory. If we do not, the Fact that we assert will
    have an id of `2`, not `1`. If you click `(reset)` or `(clear)` and then click
    `(batch*)` again, the code will behave as expected.'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你连续点击`(batch*)`多次，将会出现错误。这是因为我们必须`(reset)`或`(clear)`环境以重置在工作内存中给事实分配的 ID。如果我们不这样做，我们所断言的事实将会有
    ID `2`，而不是 `1`。如果你点击`(reset)`或`(clear)`，然后再次点击`(batch*)`，代码将按预期运行。
- en: '**Bonus**: if you are returning to this Chapter after completing [Chapter 5](#5),
    you may see a few more than 1 Fact returned. That''s because we do not `(clear)`
    at the top of the code to first "clean up" the environment. You''ll learn more
    about `(clear)` in [Chapter 18](#18).'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励**：如果你在完成[第 5 章](#5)后返回此章节，你可能会看到多于 1 个事实返回。这是因为我们在代码顶部没有`(clear)`来首先“清理”环境。你将在[第
    18 章](#18)中了解更多关于`(clear)`的信息。'
- en: '[PRE3]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 4\. Running the Engine
  id: totrans-split-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4\. Running the Engine
- en: 'The "Facts" stored in "Working Memory" can be used to satisfy the LHS (left-hand
    side) of a rule. Remember: when the LHS of a Rule is satisfied, the Rule''s RHS
    (right-hand side) will run.'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: “Working Memory”中存储的“Facts”可用于满足规则的左手边（LHS）。记住：当规则的左手边满足时，规则的右手边（RHS）将运行。
- en: In the code to the right, we create a Rule using `(defrule)` called `greet`.
    This Rule will "activate" when a Fact that matches the form `(name ?)` is entered
    into Working Memory. Once we `(run)` the rules engine, the Right Hand side of
    this Rule will run if a `name` Fact exists in the system with a second field.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的代码中，我们使用`(defrule)`创建了一个名为`greet`的规则。当一个匹配`(name ?)`形式的事实输入到工作内存中时，这个规则将“激活”。一旦我们`(run)`规则引擎，如果系统中存在一个`name`事实与第二字段，则该规则的右手边将运行。
- en: Next, we `(assert)` a `name` Fact with the value `ryjo` in its second field.
    Once we do this, the `greet` rule is "activated;" when we `(run)` our Rules Engine
    next, this Rule's RHS will be executed.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在其第二个字段中`assert`了一个`name`事实，并赋予其值`ryjo`。一旦这样做，`greet`规则将被“激活”；当我们下次`(run)`我们的规则引擎时，该规则的右手边将被执行。
- en: '**Bonus**: if you are returning to this Chapter after completing [Chapter 5](#5),
    you may see a few more than 1 greeting. That''s because we do not `(clear)` at
    the top of the code to first "clean up" the environment. You''ll learn more about
    `(clear)` in [Chapter 18](#18).'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励**：如果你在完成[第 5 章](#5)后返回此章节，你可能会看到多于 1 个问候语。这是因为我们在代码顶部没有`(clear)`来首先“清理”环境。你将在[第
    18 章](#18)中了解更多关于`(clear)`的信息。'
- en: '[PRE4]'
  id: totrans-split-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 5\. Negative, Ghostrider
  id: totrans-split-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5\. Negative, Ghostrider
- en: Sometimes you want to activate a Rule when there is a Fact in Working Memory
    that does not match a certain pattern. The tilde (`~`) character is used to negate
    a given pattern. It's like saying "a Fact that does not have this here."
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你希望在“Working Memory”中有一个事实不匹配某个模式时激活一个规则。波浪符（`~`）字符用于否定给定的模式。这就像是在说“一个事实不在这里”。
- en: Note that we are not able to use the non-matching names in the RHS of this Rule
    like we did in [Chapter 4](#4). We'll cover how to use these names in [Chapter
    6](#6).
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们无法像在[第四章](#4)中那样在此规则的RHS中使用不匹配的名称。我们将在[第6章](#6)讨论如何使用这些名称。
- en: 'First, we `(clear)` our environment of all previously defined Rules and Facts
    from the CLIPS Environment. We then `(assert` two `(name`s: `Zach` and `Zethus`.
    Finally, our Rule `non-ryjos-only` will "activate" when a Fact matching the pattern
    `(name ~ryjo)` enters working memory. This pattern might be read in English as
    "a Fact that starts with `name` and does not have `ryjo` in its second field."
    Finally, the RHS of this Rule prints the text "Hello, not ryjo!"'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们使用`(clear)`清除CLIPS环境中所有之前定义的规则和事实。然后，我们使用`(assert`两个`(name`s: `Zach`和`Zethus`。最后，我们的`non-ryjos-only`规则将在工作内存中进入匹配模式`(name
    ~ryjo)`的事实时激活。这个模式可能在英语中被解读为“以`name`开头，其第二个字段不含`ryjo`。”最后，这个规则的RHS打印文本“Hello,
    not ryjo!”'
- en: '**Bonus:** After you `(batch*)` this code, try navigating to [Chapter 4](#4);
    you''ll see that the previously defined `greet` Rule runs for these two new names.
    That''s because the examples in this tutorial use the same CLIPS Environment.
    In this example, we use `(clear)` at the top which removes everything defined
    in previous examples. You will see this convention more in following chapters.'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外奖励:** 在执行此代码之后`(batch*)`，尝试导航到[第四章](#4); 您将看到先前定义的`greet`规则适用于这两个新名称。这是因为本教程中的示例使用相同的CLIPS环境。在此示例中，我们在顶部使用`(clear)`，它会删除前面示例中定义的所有内容。在后续章节中，您将看到这种惯例更多。'
- en: '[PRE5]'
  id: totrans-split-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 6\. Capturing the Name
  id: totrans-split-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6\. 捕获名称
- en: Now we'll combine two previously presented concepts using a `&`. First, we'll
    capture the value in the first field with `?n` ([Chapter 4](#4)). Next, we'll
    specify "not ryjo" with `~` ([Chapter 5](#5)). The `&` symbol acts as an "and."
    We can read the pattern `(name ?n&~ryjo)` as "a value and it is not ryjo."
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将结合两个先前介绍的概念使用`&`。首先，我们将使用`?n`捕获第一个字段的值（[第四章](#4)）。接下来，我们将用`~`指定“不是ryjo”（[第五章](#5)）。`&`符号充当“和”的作用。我们可以将模式`(name
    ?n&~ryjo)`解读为“一个值，它不是ryjo。”
- en: 'Additionally, we `(assert)` three facts. Only two of them will "activate" the
    `non-ryjos-only` rule we define right below it. Something neat to make note of:
    we only need to call `(assert)` once in order to put three new Facts into Working
    Memory.'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们`(assert)`三个事实。只有其中两个将激活我们在其下定义的`non-ryjos-only`规则。有一点需要注意：我们只需调用`(assert)`一次，就能将三个新事实放入工作内存。
- en: We define a second rule `ryjo` here to demonstrate the "opposite" of the `non-ryjos-only`
    rule. This will activate when a Fact enters Working Memory that looks exactly
    like `(name ryjo)`.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了第二个规则`ryjo`，以展示`non-ryjos-only`规则的“相反”。当一个事实进入工作内存，其看起来像`(name ryjo)`时，这个规则将被激活。
- en: Note how the Rules in this example don't execute in the order in which they
    were written. The reason for this is **the order in which Rules are run is determined
    algorithmically**. Read more about how CLIPS determines the order in which Rules
    are run in section **5.2 Basic Cycle Of Rule Execution** of the [Basic Programming
    Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf) . We can
    use `(salience` to explicitly declare the order in which Rules run. We'll discuss
    this in [Chapter 15](#15).
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意本示例中规则不按照编写顺序执行。这是因为**规则运行的顺序是由算法确定的**。更多关于CLIPS如何确定规则执行顺序的信息，请参阅[基本编程指南](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf)的第5.2节“规则执行的基本循环”。我们可以使用`(salience`来显式声明规则运行的顺序。我们将在[第15章](#15)讨论这个问题。
- en: '[PRE6]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 7\. And/Or
  id: totrans-split-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7\. 与/或
- en: We can make use of "Connective Constraints" to better refine the LHS of our
    Rules. For example, in the Rule `ors` in the code editor, we match on a Fact whose
    second field matches either `Gabe` or `Peter`. This can be read as "A `name` Fact
    whose first field we store the variable `?name` and matches either `Gabe` or `Peter`."
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用“连接约束”来更好地细化我们规则的左侧。例如，在代码编辑器中的`ors`规则中，我们匹配第二个字段匹配`Gabe`或`Peter`的事实。这可以解读为“一个`name`事实，其第一个字段我们存储为变量`?name`，并且匹配`Gabe`或`Peter`。”
- en: In the `and-nots` Rule, we store the second field of a `name` Fact in the variable
    `?name`. This time, we say "the value in the first field cannot match `ryjo` and
    it cannot match `Zach` and it cannot match `Zethus`."
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`and-nots`规则中，我们将`name`事实的第二个字段存储在变量`?name`中。这一次，我们说“第一个字段的值不能匹配`ryjo`，也不能匹配`Zach`，也不能匹配`Zethus`。”
- en: '[PRE7]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 8\. Predicate Constraints
  id: totrans-split-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8\. 谓词约束
- en: Predicate Constraints sound fancy, but they're pretty straight forward. Basically
    they allow you to further specify what value a field holds. For example, with
    our current knowledge, we can specify *exact* matches for values such as `(name
    ?n&ryjo)`. Predicate Conditions allow us to perform a function on the value to
    determine if it matches.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词约束听起来很复杂，但它们非常直观。基本上，它们允许您进一步指定字段所包含的值。例如，根据我们当前的知识，我们可以为诸如 `(name ?n&ryjo)`
    的值指定*确切*匹配。谓词条件允许我们对值执行函数以确定是否匹配。
- en: In our code example for this chapter, we write a basic Rule that describes a
    rule that allows entry into a bar. In the United States of America, we require
    a person to be 21 years of age or older. If they are under 21 years of age, they
    are not allowed into a bar.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的代码示例中，我们编写了一个描述允许进入酒吧的基本规则。在美国，我们要求一个人年满 21 岁。如果他们未满 21 岁，则不允许他们进入酒吧。
- en: Note the familiar form of `?variable&`. We use the `and` symbol here (`&`) to
    signify that `?variable` must match certain criteria. This allows us to read this
    as "the age of a person and it is greater than or equal to 21" in the `allow-entry-to-bar`
    Rule.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `?variable&` 的熟悉形式。我们在这里使用 `and` 符号 (`&`) 来表示 `?variable` 必须符合特定条件。这使我们可以将其解读为
    "一个人的年龄及其大于或等于 21" 在 `allow-entry-to-bar` 规则中。
- en: 'Also note that we make use of 2 different Facts in Working Memory to activate
    our rules: the `name` and `age` Facts. Also note that in the LHS of our Rules,
    we specify that the first field of these Facts must match by using `?person` in
    both. Since `?person` is used in both of these conditions, we say that this Rule
    is "activated" when these Facts have the same value in their first field.'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，我们利用了工作内存中的两个不同事实来激活我们的规则：`name` 和 `age` 事实。此外，请注意，在规则的 LHS 中，我们使用 `?person`
    来指定这些事实的第一个字段必须匹配。由于 `?person` 在这两个条件中都使用了，我们称此规则在这些事实的第一个字段具有相同值时为 "激活"。
- en: For example, the `(name ryjo)` Fact and the `(age ryjo 32)` Fact will activate
    the `allow-entry-to-bar` Rule together. Both the value in the first field match
    for these Facts *and* the number 32 is greater than or equal to 21\. The Facts
    `(name ryjo)` and `(age someone 20)` will not activate the `no-entry-to-bar` Rule.
    The number `20` is indeed less than 21, but these two Facts will not activate
    the Rule together. However, the 2 Facts `(name someone)` and `(age someone 20)`
    will. Not only is `20` less than `21` as noted in the Predicate Condition `(>=
    ?a 21)`, but the Symbol `someone` matches in both Facts.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`(name ryjo)` 事实和 `(age ryjo 32)` 事实将一起激活 `allow-entry-to-bar` 规则。这些事实的第一个字段匹配的值相同，并且数字
    `32` 大于或等于 `21`。事实 `(name ryjo)` 和 `(age someone 20)` 将不会激活 `no-entry-to-bar`
    规则。数字 `20` 确实小于 `21`，但这两个事实不会一起激活规则。然而，两个事实 `(name someone)` 和 `(age someone 20)`
    将会。如谓词条件 `(>= ?a 21)` 所示，`20` 确实小于 `21`，并且符号 `someone` 在两个事实中匹配。
- en: '[PRE8]'
  id: totrans-split-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 9\. Test Conditional
  id: totrans-split-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9\. 测试条件
- en: This example looks like the previous section. Instead of using `&:`, we define
    our constraints using the `(test` Conditional Element.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子看起来像前一节。我们不再使用 `&:`，而是使用 `(test` 条件元素来定义我们的约束条件。
- en: The output for this example should look very similar to last example's.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例的输出应该与上一个示例非常相似。
- en: '[PRE9]'
  id: totrans-split-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 10\. One forall
  id: totrans-split-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10\. 一个 forall
- en: Sometimes you want to know if all Facts in Working Memory match a given pattern.
    `(forall` provides this check. In our example, `(forall` will match if every `(name`
    Fact in working memory can be matched with an `(age` Fact (and vice versa).
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您想知道工作内存中的所有事实是否与给定模式匹配。 `(forall` 提供了这种检查。在我们的例子中，如果每个工作内存中的 `(name` 事实都可以与
    `(age` 事实匹配（反之亦然），`(forall` 将匹配。
- en: In our example, the Fact `(name another)` does not have an `(age` Fact with
    a matching value `?n`. Therefore, our Engine tells us that the "Roster has been
    declined."
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，事实 `(name another)` 没有与匹配值 `?n` 的 `(age` 事实。因此，我们的引擎告诉我们 "名单已被拒绝"。
- en: '[PRE10]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 11\. Aliens exists
  id: totrans-split-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11\. 外星人存在
- en: This is a bit of a longer example, but it showcases a few things combined together.
    `(exists` will match once if a Fact in Working Memory matches the pattern within.
    It will not run again while the condition continues to match. In our example,
    we match for "any fact that starts with `(age` and is followed with two values."
    When we use `?`, it doesn't matter what these values are; it only matters that
    they are there at all.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个稍长的例子，但它结合了几个方面。 `(exists` 将在工作内存中的事实与其中的模式匹配一次时匹配。只要条件继续匹配，它将不会再次运行。在我们的例子中，我们匹配
    "任何以 `(age` 开头并跟随两个值的事实"。当我们使用 `?` 时，这些值是什么并不重要；重要的是它们是否存在。
- en: Try modifying our `any-age-reported` Rule to capture the `?name` and `(println
    ?name)` it in the RHS of the Rule.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改我们的 `any-age-reported` 规则，捕获 `?name` 并在规则的 RHS 中 `(println ?name)`。
- en: We also use `(forall` to determine when every user has reported their age.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `(forall` 来确定每个用户何时报告了他们的年龄。
- en: It may seem strange to give up control of our code's order of execution. Remember,
    this lets us focus on our Business Logic rather than Control Flow of our domain.
    Make sure to review the section **Performance Considerations** in the [Basic Programming
    Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf) to learn
    how to write code in harmony with this approach.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃控制代码执行顺序可能看起来有点奇怪。请记住，这使我们能够专注于业务逻辑而不是领域控制流。确保阅读 [Basic Programming Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf)
    中的 **性能注意事项** 部分，学习如何与此方法编写代码的和谐性。
- en: '[PRE11]'
  id: totrans-split-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 12\. Do you read(line) me?
  id: totrans-split-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12\. 你读取了(line)我吗？
- en: Sometime you want to take input from the user rather than "hard-code" their
    name, age, and other details. We can take input from the user using `(readline)`.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望从用户那里获取输入，而不是"硬编码"他们的姓名、年龄和其他细节。我们可以使用 `(readline)` 从用户那里获取输入。
- en: 'In this example, we take input from the user, then we tell them what they entered.
    Note: when you run this example, a prompt will pop up on your screen. Enter your
    text into the field, then click the "OK" button.'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从用户那里获取输入，然后告诉他们他们输入了什么。注意：当您运行此示例时，屏幕上将弹出一个提示框。将您的文本输入到字段中，然后点击"OK"按钮。
- en: Similarly, `(read)` will take the input from a user, but it'll only take a single
    word. Change `(readline)` to `(read)` in the code editor. If you enter "foo bar
    123" into the text box and then click the "OK" button, it'll only echo out "foo."
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`(read)` 将从用户输入中获取数据，但只接受单个单词。请在代码编辑器中将`(readline)`更改为`(read)`。如果您在文本框中输入了"foo
    bar 123"，然后点击"OK"按钮，它只会回显"foo"。
- en: '[PRE12]'
  id: totrans-split-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 13\. Say the secret word
  id: totrans-split-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13\. 说出秘密词
- en: '**Be warned:** note that there is a line commented out in this example. If
    you uncomment this line, the pop-up prompt will continue to show until you enter
    the word `secret`.'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意：** 注意这个例子中有一行被注释掉了。如果您取消注释此行，弹出式提示将继续显示，直到您输入单词 `secret`。'
- en: The reason that this loop occurs is because we `(retract` the `(word` Fact which
    we captured as `?f` in the LHS of the `user-did-not-say-secret` Rule. This triggers
    the pattern `(not (word ?))` in the `get-word-from-user` which is the absence
    of a `(word` Fact with one field in Working Memory.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环发生的原因是因为我们在 `user-did-not-say-secret` 规则的 LHS 中 `(retract` 捕获的 `(word ?f`
    事实。这触发了在 `get-word-from-user` 中的模式 `(not (word ?))`，即工作内存中没有一个带有一个字段的 `(word`
    事实的存在。
- en: This example is a little more complex, but it provides a good example of a way
    in which you can "validate" user input. This is not the *only* way, mind you.
    It is, however, a good example of how the "main loop" of a program can be made
    using only Rules and Facts.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有点复杂，但它提供了一个展示如何"验证"用户输入的好例子。请注意，这不是*唯一*的方法。然而，它确实是展示如何使用规则和事实构建程序的"主循环"的好例子。
- en: '[PRE13]'
  id: totrans-split-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 14\. So many words
  id: totrans-split-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14\. 这么多词语
- en: The `(readline)` function will capture user input and return a string. If the
    user's input has any spaces between words, we can use `(explode$` to break the
    input up into a "multifield value." This lets us define patterns in our Rules
    that will match on individual words entered by the user.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`(readline)` 函数将捕获用户输入并返回一个字符串。如果用户的输入在单词之间有任何空格，我们可以使用 `(explode$` 将输入拆分成"多字段值"。这使我们能够在我们的规则中定义模式，以匹配用户输入的单个单词。'
- en: Take a look at the Rule `first-word-one`. This Rule will activate when the first
    word entered by the user is "**one**." Similarly, the Rule `last-word-last` will
    activate when the last word entered is "**last**."
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查看规则 `first-word-one`。当用户输入的第一个单词是 "**one**" 时，此规则将被激活。同样地，规则 `last-word-last`
    在用户输入的最后一个单词是 "**last**" 时将被激活。
- en: The `anywhere` Rule will trigger if "**anywhere**" is entered anywhere in the
    prompt. The `$?` will match for any number of words. For example, we see in the
    `counter` Rule the pattern `(exploded-words $?words)`. This means "match any number
    of values and reference them as a "multifield value" `?words`. Just like `?`,
    `$?` allows us to say "match on any number of fields" without referencing it in
    the RHS.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**任何地方** 规则将在提示中输入 "**任何地方**" 时触发。`$?` 将匹配任意数量的单词。例如，我们在 `counter` 规则中看到模式
    `(exploded-words $?words)`。这意味着"匹配任意数量的值并将其引用为“多字段值” `?words`。就像 `?` 一样，`$?` 允许我们在
    RHS 中声明"匹配任意数量的字段"，而不需要在其中引用它。'
- en: 'Speaking of the `counter` Rule: take a look at `(length$ ?words)`. As you may
    have guessed, `(length$` will return the number of values in the multifield value
    passed to it. In this case, it returns the number of words (as referenced by `?words`)
    entered by the user in the prompt.'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到`counter`规则：看一下`(length$ ?words)`。正如你可能已经猜到的那样，`(length$`将返回传递给它的多域值中的值数量。在这种情况下，它返回用户在提示中输入的单词数（由`?words`引用）。
- en: '[PRE14]'
  id: totrans-split-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 15\. Prominently salient
  id: totrans-split-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15\. 显著突出
- en: By using `(declare (salience` in our Rule, we can specify the "priority" of
    a Rule. This allows us to declare that **some Rules must always run before others**.
    We "hard-code" the execution order for our rules, and the Rete algorithm builds
    around it.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的规则中使用`(declare (salience`，我们可以指定规则的“优先级”。这允许我们声明**某些规则必须在其他规则之前始终运行**。我们对规则的执行顺序进行了“硬编码”，而Rete算法则围绕它构建。
- en: 'Rules have a salience of `0` by default. Rules with a salience greater than
    `0` will execute before them. Similarly, Rules with a lower salience will execute
    after them. According to the [Basic Programming Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf),
    this feature should be used sparingly:'
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，规则的显著性为`0`。具有大于`0`显著性的规则将在它们之前执行。类似地，具有较低显著性的规则将在它们之后执行。根据[基本编程指南](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf)，这个功能应该谨慎使用：
- en: Despite the large number of possible values, with good design there's rarely
    a need for more than five salience values in a simple program and ten salience
    values in a complex program.
  id: totrans-split-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管可能值有很多，但在简单程序中，通过良好设计很少需要超过五个显著值，在复杂程序中十个显著值。
- en: For the most part, a Rules Engine should be order independent. This allows CLIPS
    to do the "heavy lifting" of determining when Rules run. This is subtle, but rather
    powerful. With Rules, you do not "pass" values into a "function" that runs and
    returns a value. Instead, the algorithm "activates" Rules based on "matched" Facts
    in Working Memory. This decouples the data stored in your system (Facts) from
    the business logic (Rules).
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，规则引擎应该是无序的。这使得CLIPS能够“重活”确定规则运行的时机。这是微妙但相当强大的功能。使用规则时，你不会将值“传递”给运行并返回值的“函数”。相反，算法基于工作内存中“匹配”的事实“激活”规则。这种解耦了系统中存储的数据（事实）与业务逻辑（规则）。
- en: This decoupling can help express the domain you're modeling with less references
    to the "control flow" of the software. The more transparent the software, the
    closer your system brings the user to the "truth" of your domain.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解耦有助于用更少的引用来表达您正在建模的领域的域。软件越透明，您的系统就越接近您领域的“真理”。
- en: '[PRE15]'
  id: totrans-split-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 16\. What's your function?
  id: totrans-split-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16\. 你的功能是什么？
- en: Functions allow you to reference chunks of code that you write repeatedly throughout
    your program. If we were writing a book, we may find it easier to "wrap" text
    that has been spoken in quotes as well as a reference to the speaker. We do the
    same for shouting.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 函数允许您在程序中重复引用您编写的代码块。如果我们在写书，可能会发现把“说出来的话”放在引号中更容易理解，以及对说话者的引用。我们对喊叫也是这样处理。
- en: We can also store difficult-to-remember formulas as Functions. Personally, I
    have trouble remembering the formula for converting fahrenheit to celsius. With
    the help of `deffunction`, I can store this calculation and reference it easily.
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将难以记住的公式存储为函数。就个人而言，我很难记住华氏转摄氏的公式。通过`deffunction`的帮助，我可以轻松地存储并随时引用这个计算。
- en: 'Take note of the `(*`, `(-` and `(/` functions. These are basic math operations:
    multiplication, subtraction and division. In CLIPS, we write the math problem
    `1 + 2` as `(+ 1 2)`. That''s because CLIPS uses a "LISP-like" syntax.'
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`(*`、`(-`和`(/`函数。这些是基本的数学运算：乘法、减法和除法。在CLIPS中，我们将数学问题`1 + 2`写成`(+ 1 2)`。这是因为CLIPS使用“类似LISP”的语法。
- en: '[PRE16]'
  id: totrans-split-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 17\. Templatize me
  id: totrans-split-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17\. 模板化我
- en: Templates are used to define a formal structure for Facts. By using `(deftemplate
    person` in our example, we describe the structure of a `(person` Fact. We wrote
    Facts as lists of values in previous Chapters. We would describe these Facts as
    having ordered "fields." `(person Sally "Hi")` would describe a `(person` Fact
    with the values `Sally` in its second field and `"Hi"` in its third field.
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 模板用于定义事实的正式结构。通过在我们的例子中使用`(deftemplate person`，我们描述了`(person`事实的结构。我们在前几章中将事实写成值列表。我们将这些事实描述为具有有序“字段”的列表。`(person
    Sally "Hi")`将描述一个`(person`事实，其第二个字段中有值`Sally`，第三个字段中有值`"Hi"`。
- en: With Templates, we are no longer bound to storing people's information in a
    particular order. Instead, we store values in named "Slots." For example, we can
    choose to define our Fact as `(person (greeting "Hi") (name Sally))`, greeting
    first. We can also define "default" values for these named slots and omit them
    in asserted Facts.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板，我们不再受限于以特定顺序存储人们的信息。相反，我们将值存储在命名为"Slots"的位置。例如，我们可以选择将我们的事实定义为`(person
    (greeting "Hi") (name Sally))`，首先是问候语。我们还可以为这些命名的插槽定义"默认"值，并在断言的事实中省略它们。
- en: Using Templates gives us some flexibility in how we define our Facts as well
    as how we write the matching patterns in the LHS of our Rules. Take a look at
    the Rule `people-greet-each-other`. Our second pattern matches "a person whos
    name is not `?name1`." We do not need to include a reference to this Fact's `(greeting`
    Slot in this Rule, so we can omit it.
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板使我们在定义事实以及在规则左侧手边写匹配模式时具有一定的灵活性。看看规则`people-greet-each-other`。我们的第二个模式匹配“名字不是`?name1`的人”。在这个规则中，我们不需要包括对该事实的`(greeting`
    Slot的引用，因此我们可以省略它。
- en: You'll also notice we define a default value for `(greeting` in the Template's
    definition. There are many other ways to describe a Slot besides `default`. Take
    a look at the [Basic Programming Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf)
    in the section titled "Deftemplate Construct" to learn what these are.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到我们在模板定义中为`(greeting`定义了默认值。除了`default`之外，还有许多其他描述Slot的方法。请查看[Basic Programming
    Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf)中名为“Deftemplate
    Construct”的部分，了解这些方法。
- en: '[PRE17]'
  id: totrans-split-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 18\. Clearly resetting
  id: totrans-split-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18\. 明确重置
- en: Let's talk about `(clear)` and `(reset)`. We're familiar with `(clear)` which
    makes our environment like new again. No more Rules, no more Facts.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下`(clear)`和`(reset)`。我们熟悉的`(clear)`使我们的环境再次如新。没有规则，没有事实了。
- en: '`(reset)` does a little less. It retracts all Facts in your system and Rule
    activations while leaving the Rules themselves defined. In this way, you can use
    `(reset)` to return your Engine to a known default "state" before running it again
    with new input.'
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`(reset)`做得少一点。它撤销系统中的所有事实和规则激活，但保留规则本身的定义。通过这种方式，您可以使用`(reset)`将引擎返回到已知的默认“状态”，然后再次运行它以获取新的输入。'
- en: What happens if we need some Facts asserted to return to the "default" state?
    Introducing `(deffacts`. When you use `(reset)`, the Facts defined in your `(deffacts`
    will be asserted. Consider the example in this chapter and its output. On the
    first run, we `(assert` 2 more fruit Facts than in the second. As a result, we
    see two more people eat their favorite fruit.
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一些事实被断言以返回到“默认”状态会发生什么？介绍`(deffacts`。当您使用`(reset)`时，将会断言您的`(deffacts`中定义的事实。考虑本章中的例子及其输出。在第一次运行时，我们比第二次多`(assert`了2个水果事实。因此，我们看到两个更多的人吃他们喜欢的水果。
- en: '[PRE18]'
  id: totrans-split-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 19\. Who watches the statistics?
  id: totrans-split-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19\. 谁观察统计数据？
- en: '[PRE19]'
  id: totrans-split-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '20\. Rules: Activate!'
  id: totrans-split-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20\. 规则：激活！
- en: '[PRE20]'
  id: totrans-split-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 21\. Watching functions
  id: totrans-split-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21\. 观察函数
- en: '[PRE21]'
  id: totrans-split-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 22\. ???
  id: totrans-split-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22\. ???
- en: That's it for now! Thanks for sticking with the tutorial up to this point. I'll
    be adding to this over time, so make sure to bookmark this page and check back
    :).
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！感谢您到目前为止坚持使用本教程。我会随着时间的推移继续添加内容，所以请确保收藏此页面并定期查看 :).
- en: This entire page is written from scratch when possible. No frameworks, just
    good ol' fashioned procedural Javascript, CSS and HTML. I took a lot of inspiration
    from the [Tour of Go](https://go.dev/tour/welcome/1). I found it super helpful
    to not need to install anything when learning Go years back. I used [emscripten](https://emscripten.org/)
    to compile [CLIPS](https://www.clipsrules.net/) into a WASM binary. I wrote the
    code editor + syntax highlighter from scratch with code snippets pulled from [Stackoverflow](https://stackoverflow.com/).
    I'll admit I'm a bit proud of that :).
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这整个页面在可能时都是从头编写的。没有框架，只有经典的过程式Javascript、CSS和HTML。多年前学习Go时，我发现[Go之旅](https://go.dev/tour/welcome/1)非常有帮助，因为不需要安装任何东西。我使用[emscripten](https://emscripten.org/)将[CLIPS](https://www.clipsrules.net/)编译成WASM二进制文件。我从头开始编写了代码编辑器和语法高亮器，并从[Stackoverflow](https://stackoverflow.com/)中获取了代码片段。我承认我对此有些自豪
    :).
- en: My goal with this tutorial is to spread the word about CLIPS. I'd like to see
    it used in more everyday applications because it's a very powerful way of expressing
    complex business logic with less lines of code.
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本教程中的目标是传播有关CLIPS的信息。我希望看到它在更多日常应用中的使用，因为它是一种用更少代码表达复杂业务逻辑的非常强大的方式。
- en: '[PRE22]'
  id: totrans-split-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
