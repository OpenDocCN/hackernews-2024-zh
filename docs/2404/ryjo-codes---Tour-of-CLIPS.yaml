- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:40:28'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: ryjo.codes - Tour of CLIPS
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://ryjo.codes/tour-of-clips.html](https://ryjo.codes/tour-of-clips.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0\. Introduction
  id: totrans-split-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Over the last year and a half or so, I've been learning about the [CLIPS](https://www.clipsrules.net/)
    programming language. [A team of developers at NASA](https://clipsrules.net/AboutCLIPS.html)
    created CLIPS in the mid-'80s. It was released into the public domain in the mid-'90s,
    and it has been actively developed by one of the original team members [Gary Riley](http://www.clipsrules.net/AboutTheDeveloper.html)
    ever since.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: CLIPS has this air of mystery about it. There's no npm-like service that centralizes
    common CLIPS "libraries." A lot of writing about the language appears, on the
    surface, academic or higher-level. To top it off, the [Rete algorithm](https://en.wikipedia.org/wiki/Rete_algorithm)
    central to CLIPS can be rather intimidating to wrap one's head around.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: Don't let these things deter you; CLIPS is well worth learning. Its Rules-based
    approach is a good primer to learning neural networks and AI. With this tutorial,
    you'll take your first steps into Rules Engines and Expert Systems.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll talk about why you should consider using CLIPS. At the heart of
    CLIPS is the [Rete algorithm](https://en.wikipedia.org/wiki/Rete_algorithm). This
    algorithm does a few very nice things for us. For one, it determines the order
    in which Rules should run. This allows us to focus on **what the domain business
    logic is** of our program rather than **how the software runs**. Second, the Rete
    network "caches" common calculations our software will make. Those who have written
    an in-app cache understand the benefits of this feature.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Another huge win for CLIPS is the excellent documentation and support provided
    by the lead developer [Gary Riley](http://www.clipsrules.net/AboutTheDeveloper.html).
    Take a look at the various guides of all levels linked in the [documentation section](https://clipsrules.net/#documentation)
    of the CLIPS homepage. Also, Mr. Riley is very active in various forums providing
    support for CLIPS. Once again, look at the main CLIPS website to find links to
    the [various avenues of support](https://clipsrules.net/#support).
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Finally, CLIPS is still actively developed; its latest release 6.40 was published
    in May of 2021\. Pretty incredible!
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: 0.a This Tutorial
  id: totrans-split-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This tutorial is greatly inspired by the fantastic [A Tour of Go](https://go.dev/tour/welcome/1).
    Run the examples presented in this tutorial by clicking the `(batch*)` button
    under the code. The code in the box is editable, so tweak the code to test your
    curiosity. The output from the code will display in the box below the buttons.
    Navigate between the previous and next Chapters by clicking the links at the bottom
    of the screen. The left link (←) will navigate you to the previous chapter while
    the right link (→) will advance to the next chapter. Between these two links will
    show the name of the current Chapter. Click that link to reveal a list of all
    Chapters in this book. Clicking one of these Chapters should navigate you to the
    appropriate Chapter.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
- en: 1\. Saying Hello
  id: totrans-split-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The classic "first program" is the "Hello, World" program. This will show you
    how to output some text from your program. Click the `(batch*)` button under the
    code on the right hand side. You should see text appear in the box beneath the
    buttons.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: With CLIPS, there are a few ways we can print text to the screen. Using `(print)`
    will print words out, while `(println)` will print words out **with a new line
    at the end**. In the code sample to the right, you can see us using `(print)`
    to print the word "Hello". We then use `(println)` to print ", World!" and a new
    line character. Things printed after this text will appear on the next line.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: '`(printout t)` is like `(print)` and `(println)`, but it allows you to send
    text to a given "router." In this case, we send the text to the router `t` which
    is what `(print)` and `(println)` send text to by default. We also use the text
    `crlf` as the last argument to `(printout`. We do this so that our text "breaks"
    at the end of the line; the next thing we print will appear beneath this current
    line. `crlf` stands for "carriage return line feed," which means "move the cursor
    to the beginning of the next line."'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: '`(format t)` allows you to print a sentence structure that contains "format
    flags." The `%s` and `%n` are format flags that specify a string and newline respectively.
    The next argument (in this case "fun") will be substituted in place of the `%s`.
    `%n` will be replaced with a new line character. To see more of these "format
    flags," check out the [Basic Programming Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf)
    -- specifically the section entitled **12.4.6 Formatted Printing** -- to learn
    more.'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-21
  prefs: []
  type: TYPE_PRE
- en: 2\. Learning the Rules
  id: totrans-split-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rules are an important part of understanding how CLIPS works. Rules consist
    of an "antecedent" and a "consequent." The antecedent is also known as the "if
    portion" or the "left-hand side." This part consists of the conditions that must
    be satisfied for the Rule to run.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: The consequent is also known as the "then portion" or the "right-hand side."
    This part describes what will happen when the Rule is run.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: These two pieces are separated by a `=>`. The antecedent is before this symbol
    while the consequent is after it.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we define a Rule called `will-run-no-matter-what`. This particular
    Rule has nothing on the left-hand side so it will always run. The right-hand side
    specifies that a `(println)` will run.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: Finally after the Rule is defined, there is a `(run)`. In order for this to
    work, click the `(batch*)` button.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
- en: 3\. Just the Facts
  id: totrans-split-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to Rules in CLIPS, we have "Facts." A Fact represents "data" in
    CLIPS. In order to put data into CLIPS, we `(assert)`. Once we have `(assert)`ed
    Facts, they are said to be "in working memory."
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: In the code to the right, we `(assert)` one `(name` Fact with `ryjo` in its
    second field.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: We then print a single line of text with our old friend `(println)`.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: '`(facts)` is a new one. We use this to print out the Facts stored in Working
    Memory. In this case, we see 1 fact printed with an index `1` as denoted by `f-1`.'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll `(retract` this Fact that we just asserted. We can reference
    this Fact with its index `1`.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: If you click `(batch*)` multiple times in a row, an error will appear.
    This is because we must `(reset)` or `(clear)` the environment to reset the ids
    assigned to Facts in Working Memory. If we do not, the Fact that we assert will
    have an id of `2`, not `1`. If you click `(reset)` or `(clear)` and then click
    `(batch*)` again, the code will behave as expected.'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: '**Bonus**: if you are returning to this Chapter after completing [Chapter 5](#5),
    you may see a few more than 1 Fact returned. That''s because we do not `(clear)`
    at the top of the code to first "clean up" the environment. You''ll learn more
    about `(clear)` in [Chapter 18](#18).'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
- en: 4\. Running the Engine
  id: totrans-split-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The "Facts" stored in "Working Memory" can be used to satisfy the LHS (left-hand
    side) of a rule. Remember: when the LHS of a Rule is satisfied, the Rule''s RHS
    (right-hand side) will run.'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: In the code to the right, we create a Rule using `(defrule)` called `greet`.
    This Rule will "activate" when a Fact that matches the form `(name ?)` is entered
    into Working Memory. Once we `(run)` the rules engine, the Right Hand side of
    this Rule will run if a `name` Fact exists in the system with a second field.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: Next, we `(assert)` a `name` Fact with the value `ryjo` in its second field.
    Once we do this, the `greet` rule is "activated;" when we `(run)` our Rules Engine
    next, this Rule's RHS will be executed.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: '**Bonus**: if you are returning to this Chapter after completing [Chapter 5](#5),
    you may see a few more than 1 greeting. That''s because we do not `(clear)` at
    the top of the code to first "clean up" the environment. You''ll learn more about
    `(clear)` in [Chapter 18](#18).'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-43
  prefs: []
  type: TYPE_PRE
- en: 5\. Negative, Ghostrider
  id: totrans-split-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you want to activate a Rule when there is a Fact in Working Memory
    that does not match a certain pattern. The tilde (`~`) character is used to negate
    a given pattern. It's like saying "a Fact that does not have this here."
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are not able to use the non-matching names in the RHS of this Rule
    like we did in [Chapter 4](#4). We'll cover how to use these names in [Chapter
    6](#6).
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we `(clear)` our environment of all previously defined Rules and Facts
    from the CLIPS Environment. We then `(assert` two `(name`s: `Zach` and `Zethus`.
    Finally, our Rule `non-ryjos-only` will "activate" when a Fact matching the pattern
    `(name ~ryjo)` enters working memory. This pattern might be read in English as
    "a Fact that starts with `name` and does not have `ryjo` in its second field."
    Finally, the RHS of this Rule prints the text "Hello, not ryjo!"'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Bonus:** After you `(batch*)` this code, try navigating to [Chapter 4](#4);
    you''ll see that the previously defined `greet` Rule runs for these two new names.
    That''s because the examples in this tutorial use the same CLIPS Environment.
    In this example, we use `(clear)` at the top which removes everything defined
    in previous examples. You will see this convention more in following chapters.'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-49
  prefs: []
  type: TYPE_PRE
- en: 6\. Capturing the Name
  id: totrans-split-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we'll combine two previously presented concepts using a `&`. First, we'll
    capture the value in the first field with `?n` ([Chapter 4](#4)). Next, we'll
    specify "not ryjo" with `~` ([Chapter 5](#5)). The `&` symbol acts as an "and."
    We can read the pattern `(name ?n&~ryjo)` as "a value and it is not ryjo."
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we `(assert)` three facts. Only two of them will "activate" the
    `non-ryjos-only` rule we define right below it. Something neat to make note of:
    we only need to call `(assert)` once in order to put three new Facts into Working
    Memory.'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: We define a second rule `ryjo` here to demonstrate the "opposite" of the `non-ryjos-only`
    rule. This will activate when a Fact enters Working Memory that looks exactly
    like `(name ryjo)`.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: Note how the Rules in this example don't execute in the order in which they
    were written. The reason for this is **the order in which Rules are run is determined
    algorithmically**. Read more about how CLIPS determines the order in which Rules
    are run in section **5.2 Basic Cycle Of Rule Execution** of the [Basic Programming
    Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf) . We can
    use `(salience` to explicitly declare the order in which Rules run. We'll discuss
    this in [Chapter 15](#15).
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
- en: 7\. And/Or
  id: totrans-split-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can make use of "Connective Constraints" to better refine the LHS of our
    Rules. For example, in the Rule `ors` in the code editor, we match on a Fact whose
    second field matches either `Gabe` or `Peter`. This can be read as "A `name` Fact
    whose first field we store the variable `?name` and matches either `Gabe` or `Peter`."
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: In the `and-nots` Rule, we store the second field of a `name` Fact in the variable
    `?name`. This time, we say "the value in the first field cannot match `ryjo` and
    it cannot match `Zach` and it cannot match `Zethus`."
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
- en: 8\. Predicate Constraints
  id: totrans-split-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Predicate Constraints sound fancy, but they're pretty straight forward. Basically
    they allow you to further specify what value a field holds. For example, with
    our current knowledge, we can specify *exact* matches for values such as `(name
    ?n&ryjo)`. Predicate Conditions allow us to perform a function on the value to
    determine if it matches.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: In our code example for this chapter, we write a basic Rule that describes a
    rule that allows entry into a bar. In the United States of America, we require
    a person to be 21 years of age or older. If they are under 21 years of age, they
    are not allowed into a bar.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: Note the familiar form of `?variable&`. We use the `and` symbol here (`&`) to
    signify that `?variable` must match certain criteria. This allows us to read this
    as "the age of a person and it is greater than or equal to 21" in the `allow-entry-to-bar`
    Rule.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that we make use of 2 different Facts in Working Memory to activate
    our rules: the `name` and `age` Facts. Also note that in the LHS of our Rules,
    we specify that the first field of these Facts must match by using `?person` in
    both. Since `?person` is used in both of these conditions, we say that this Rule
    is "activated" when these Facts have the same value in their first field.'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `(name ryjo)` Fact and the `(age ryjo 32)` Fact will activate
    the `allow-entry-to-bar` Rule together. Both the value in the first field match
    for these Facts *and* the number 32 is greater than or equal to 21\. The Facts
    `(name ryjo)` and `(age someone 20)` will not activate the `no-entry-to-bar` Rule.
    The number `20` is indeed less than 21, but these two Facts will not activate
    the Rule together. However, the 2 Facts `(name someone)` and `(age someone 20)`
    will. Not only is `20` less than `21` as noted in the Predicate Condition `(>=
    ?a 21)`, but the Symbol `someone` matches in both Facts.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-66
  prefs: []
  type: TYPE_PRE
- en: 9\. Test Conditional
  id: totrans-split-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example looks like the previous section. Instead of using `&:`, we define
    our constraints using the `(test` Conditional Element.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: The output for this example should look very similar to last example's.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-70
  prefs: []
  type: TYPE_PRE
- en: 10\. One forall
  id: totrans-split-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you want to know if all Facts in Working Memory match a given pattern.
    `(forall` provides this check. In our example, `(forall` will match if every `(name`
    Fact in working memory can be matched with an `(age` Fact (and vice versa).
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the Fact `(name another)` does not have an `(age` Fact with
    a matching value `?n`. Therefore, our Engine tells us that the "Roster has been
    declined."
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
- en: 11\. Aliens exists
  id: totrans-split-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a bit of a longer example, but it showcases a few things combined together.
    `(exists` will match once if a Fact in Working Memory matches the pattern within.
    It will not run again while the condition continues to match. In our example,
    we match for "any fact that starts with `(age` and is followed with two values."
    When we use `?`, it doesn't matter what these values are; it only matters that
    they are there at all.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: Try modifying our `any-age-reported` Rule to capture the `?name` and `(println
    ?name)` it in the RHS of the Rule.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: We also use `(forall` to determine when every user has reported their age.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: It may seem strange to give up control of our code's order of execution. Remember,
    this lets us focus on our Business Logic rather than Control Flow of our domain.
    Make sure to review the section **Performance Considerations** in the [Basic Programming
    Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf) to learn
    how to write code in harmony with this approach.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-80
  prefs: []
  type: TYPE_PRE
- en: 12\. Do you read(line) me?
  id: totrans-split-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometime you want to take input from the user rather than "hard-code" their
    name, age, and other details. We can take input from the user using `(readline)`.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we take input from the user, then we tell them what they entered.
    Note: when you run this example, a prompt will pop up on your screen. Enter your
    text into the field, then click the "OK" button.'
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `(read)` will take the input from a user, but it'll only take a single
    word. Change `(readline)` to `(read)` in the code editor. If you enter "foo bar
    123" into the text box and then click the "OK" button, it'll only echo out "foo."
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-85
  prefs: []
  type: TYPE_PRE
- en: 13\. Say the secret word
  id: totrans-split-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Be warned:** note that there is a line commented out in this example. If
    you uncomment this line, the pop-up prompt will continue to show until you enter
    the word `secret`.'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
- en: The reason that this loop occurs is because we `(retract` the `(word` Fact which
    we captured as `?f` in the LHS of the `user-did-not-say-secret` Rule. This triggers
    the pattern `(not (word ?))` in the `get-word-from-user` which is the absence
    of a `(word` Fact with one field in Working Memory.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: This example is a little more complex, but it provides a good example of a way
    in which you can "validate" user input. This is not the *only* way, mind you.
    It is, however, a good example of how the "main loop" of a program can be made
    using only Rules and Facts.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-split-90
  prefs: []
  type: TYPE_PRE
- en: 14\. So many words
  id: totrans-split-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `(readline)` function will capture user input and return a string. If the
    user's input has any spaces between words, we can use `(explode$` to break the
    input up into a "multifield value." This lets us define patterns in our Rules
    that will match on individual words entered by the user.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the Rule `first-word-one`. This Rule will activate when the first
    word entered by the user is "**one**." Similarly, the Rule `last-word-last` will
    activate when the last word entered is "**last**."
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
- en: The `anywhere` Rule will trigger if "**anywhere**" is entered anywhere in the
    prompt. The `$?` will match for any number of words. For example, we see in the
    `counter` Rule the pattern `(exploded-words $?words)`. This means "match any number
    of values and reference them as a "multifield value" `?words`. Just like `?`,
    `$?` allows us to say "match on any number of fields" without referencing it in
    the RHS.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of the `counter` Rule: take a look at `(length$ ?words)`. As you may
    have guessed, `(length$` will return the number of values in the multifield value
    passed to it. In this case, it returns the number of words (as referenced by `?words`)
    entered by the user in the prompt.'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-split-96
  prefs: []
  type: TYPE_PRE
- en: 15\. Prominently salient
  id: totrans-split-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By using `(declare (salience` in our Rule, we can specify the "priority" of
    a Rule. This allows us to declare that **some Rules must always run before others**.
    We "hard-code" the execution order for our rules, and the Rete algorithm builds
    around it.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Rules have a salience of `0` by default. Rules with a salience greater than
    `0` will execute before them. Similarly, Rules with a lower salience will execute
    after them. According to the [Basic Programming Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf),
    this feature should be used sparingly:'
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
- en: Despite the large number of possible values, with good design there's rarely
    a need for more than five salience values in a simple program and ten salience
    values in a complex program.
  id: totrans-split-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the most part, a Rules Engine should be order independent. This allows CLIPS
    to do the "heavy lifting" of determining when Rules run. This is subtle, but rather
    powerful. With Rules, you do not "pass" values into a "function" that runs and
    returns a value. Instead, the algorithm "activates" Rules based on "matched" Facts
    in Working Memory. This decouples the data stored in your system (Facts) from
    the business logic (Rules).
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
- en: This decoupling can help express the domain you're modeling with less references
    to the "control flow" of the software. The more transparent the software, the
    closer your system brings the user to the "truth" of your domain.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-split-103
  prefs: []
  type: TYPE_PRE
- en: 16\. What's your function?
  id: totrans-split-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions allow you to reference chunks of code that you write repeatedly throughout
    your program. If we were writing a book, we may find it easier to "wrap" text
    that has been spoken in quotes as well as a reference to the speaker. We do the
    same for shouting.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
- en: We can also store difficult-to-remember formulas as Functions. Personally, I
    have trouble remembering the formula for converting fahrenheit to celsius. With
    the help of `deffunction`, I can store this calculation and reference it easily.
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Take note of the `(*`, `(-` and `(/` functions. These are basic math operations:
    multiplication, subtraction and division. In CLIPS, we write the math problem
    `1 + 2` as `(+ 1 2)`. That''s because CLIPS uses a "LISP-like" syntax.'
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-split-108
  prefs: []
  type: TYPE_PRE
- en: 17\. Templatize me
  id: totrans-split-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Templates are used to define a formal structure for Facts. By using `(deftemplate
    person` in our example, we describe the structure of a `(person` Fact. We wrote
    Facts as lists of values in previous Chapters. We would describe these Facts as
    having ordered "fields." `(person Sally "Hi")` would describe a `(person` Fact
    with the values `Sally` in its second field and `"Hi"` in its third field.
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
- en: With Templates, we are no longer bound to storing people's information in a
    particular order. Instead, we store values in named "Slots." For example, we can
    choose to define our Fact as `(person (greeting "Hi") (name Sally))`, greeting
    first. We can also define "default" values for these named slots and omit them
    in asserted Facts.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
- en: Using Templates gives us some flexibility in how we define our Facts as well
    as how we write the matching patterns in the LHS of our Rules. Take a look at
    the Rule `people-greet-each-other`. Our second pattern matches "a person whos
    name is not `?name1`." We do not need to include a reference to this Fact's `(greeting`
    Slot in this Rule, so we can omit it.
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
- en: You'll also notice we define a default value for `(greeting` in the Template's
    definition. There are many other ways to describe a Slot besides `default`. Take
    a look at the [Basic Programming Guide](https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf)
    in the section titled "Deftemplate Construct" to learn what these are.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-split-114
  prefs: []
  type: TYPE_PRE
- en: 18\. Clearly resetting
  id: totrans-split-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's talk about `(clear)` and `(reset)`. We're familiar with `(clear)` which
    makes our environment like new again. No more Rules, no more Facts.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
- en: '`(reset)` does a little less. It retracts all Facts in your system and Rule
    activations while leaving the Rules themselves defined. In this way, you can use
    `(reset)` to return your Engine to a known default "state" before running it again
    with new input.'
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we need some Facts asserted to return to the "default" state?
    Introducing `(deffacts`. When you use `(reset)`, the Facts defined in your `(deffacts`
    will be asserted. Consider the example in this chapter and its output. On the
    first run, we `(assert` 2 more fruit Facts than in the second. As a result, we
    see two more people eat their favorite fruit.
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-split-119
  prefs: []
  type: TYPE_PRE
- en: 19\. Who watches the statistics?
  id: totrans-split-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-split-121
  prefs: []
  type: TYPE_PRE
- en: '20\. Rules: Activate!'
  id: totrans-split-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-split-123
  prefs: []
  type: TYPE_PRE
- en: 21\. Watching functions
  id: totrans-split-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-split-125
  prefs: []
  type: TYPE_PRE
- en: 22\. ???
  id: totrans-split-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That's it for now! Thanks for sticking with the tutorial up to this point. I'll
    be adding to this over time, so make sure to bookmark this page and check back
    :).
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
- en: This entire page is written from scratch when possible. No frameworks, just
    good ol' fashioned procedural Javascript, CSS and HTML. I took a lot of inspiration
    from the [Tour of Go](https://go.dev/tour/welcome/1). I found it super helpful
    to not need to install anything when learning Go years back. I used [emscripten](https://emscripten.org/)
    to compile [CLIPS](https://www.clipsrules.net/) into a WASM binary. I wrote the
    code editor + syntax highlighter from scratch with code snippets pulled from [Stackoverflow](https://stackoverflow.com/).
    I'll admit I'm a bit proud of that :).
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
- en: My goal with this tutorial is to spread the word about CLIPS. I'd like to see
    it used in more everyday applications because it's a very powerful way of expressing
    complex business logic with less lines of code.
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-split-130
  prefs: []
  type: TYPE_PRE
