- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:00:21'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Is the frequency domain a real place? - lcamtufâ€™s thing
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: æ¥æºï¼š[https://lcamtuf.substack.com/p/is-the-frequency-domain-a-real-place](https://lcamtuf.substack.com/p/is-the-frequency-domain-a-real-place)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In an [earlier article on the Fourier transform](https://lcamtuf.substack.com/p/not-so-fast-mr-fourier),
    I talked about the *frequency domain* â€” a wondrous mathematical place where complex
    signals are transmuted into the amplitudes and phases of sine waveforms. The frequency
    domain allows us to perform all kinds of signal processing tricks that seem nearly
    impossible to pull off when we stare at the data in its most straightforward form
    â€” that is, in the time domain.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: '*A waveform (top) and a frequency view (bottom) of â€œ[Girl in Blue](https://www.youtube.com/watch?v=hZPrKy2WgAo)â€.*'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of that deep dive, I left one question unanswered: how *real* is
    this frequency place, anyway? The discrete Fourier transform (DFT) plays a central
    role in communications and signal processing â€” but does it reveal some deeper,
    unseen truth about the universe? For example, do square waves exist at all? After
    all, the transform turns them into [a series of odd-numbered sine harmonics](https://lcamtuf.substack.com/p/square-waves-or-non-elephant-biology)
    â€” and this model somehow predicts the behavior of electronic circuits in real
    life.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: Today, Iâ€™d like to knock the Fourier transform off the pedestal. To be sure,
    sine waves are ubiquitous in nature, so this analytical tool is well-suited for
    a number of tasks. That said, itâ€™s eminently possible to construct other well-behaved
    frequency domains that play by different rules â€” including one where only square
    waves are real, and everything else is just harmonics.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, letâ€™s circle back to discrete cosine transform â€” a simplified,
    real-numbers-only version of DFT. From the earlier article, you might recall the
    following DCT-II formula:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: \(F_k = \sum\limits_{n=0}^{N-1} s_n \cdot cos ( \pi k { n + \frac12 \over N}
    )\)
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: The operation boils down to taking a series of input values (*s[n]*â€” say, audio
    samples), multiplying each by the value of a particular cosine expression, and
    then summing the result to get the magnitude reading for a particular frequency
    bin (*F[k]*).
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The construct at the heart of this algorithm is the *cos()* expression that
    generates a sine wave with a frequency corresponding to the number of the current
    DCT bin. This is known as the *basis function*; we can abstract it away and rewrite
    the formula as:'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: \(F_k = \sum\limits_{n=0}^{N-1} s_n \cdot B(k,n)\)
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: 'In this generalized notation for a frequency-domain transform, *B(k, n)* returns
    *some sort of a*  *multiplier* based on the values of *k* and *n*.Software engineers
    might find it intuitive to think about *B(k, n)* as a lookup array. In fact, letâ€™s
    calculate that array â€” a *matrix* in the math parlance â€” for *N=16*:'
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: '*DCT-II basis function plot for N=16.*'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: If you remember the operation of DCT, this visual should be easy to parse. The
    first row *(k=0)* corresponds to the DC component â€” i.e., a cosine â€œrunningâ€ at
    0 Hz, perpetually stuck at +1.00\. The next row contains a cosine completing one
    half of a cycle, going from +1.00 to -1.00; this is followed by a full cycle at
    *k=2*, a cycle and a half at *k=3*, and so on.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è®°å¾— DCT çš„æ“ä½œï¼Œè¿™ä¸ªè§†è§‰åº”è¯¥å¾ˆå®¹æ˜“ç†è§£ã€‚ç¬¬ä¸€è¡Œ *(k=0)* å¯¹åº”äºç›´æµåˆ†é‡ â€” å³ï¼Œä¸€ä¸ªåœ¨ 0 Hz å¤„è¿è¡Œçš„ä½™å¼¦æ³¢ï¼Œæ°¸è¿œå›ºå®šåœ¨ +1.00ã€‚ä¸‹ä¸€è¡ŒåŒ…å«ä¸€ä¸ªå®ŒæˆåŠä¸ªå‘¨æœŸçš„ä½™å¼¦æ³¢ï¼Œåœ¨
    *k=2* å¤„æ˜¯ä¸€ä¸ªå®Œæ•´çš„å‘¨æœŸï¼Œåœ¨ *k=3* å¤„æ˜¯ä¸€ä¸ªåŠå‘¨æœŸï¼Œä¾æ­¤ç±»æ¨ã€‚
- en: 'So, how does one go about building a new basis function that splits signals
    not into sine frequencies, but into square waves? Foreshadowing a bit, the answer
    appears almost ridiculously simple:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œå¦‚ä½•æ„å»ºä¸€ä¸ªæ–°çš„åŸºå‡½æ•°ï¼Œå°†ä¿¡å·åˆ†æˆæ–¹æ³¢è€Œä¸æ˜¯æ­£å¼¦é¢‘ç‡ï¼Ÿç¨å¾®é¢„ç¤ºä¸€ä¸‹ï¼Œç­”æ¡ˆä¼¼ä¹éå¸¸ç®€å•ï¼š
- en: '*The Walsh matrix for N=16.*'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*N=16* çš„ Walsh çŸ©é˜µã€‚'
- en: 'This is known as the Walsh matrix. It essentially consists of square waves
    running at different speeds, although with some complex symmetries thrown in.
    And yes: every multiplier is just a +1 or a -1, so the computation boils down
    to flipping some signs in the input data and then summing the results.'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯ Walsh çŸ©é˜µã€‚å®ƒæœ¬è´¨ä¸Šç”±ä»¥ä¸åŒé€Ÿåº¦è¿è¡Œçš„æ–¹æ³¢ç»„æˆï¼Œå°½ç®¡è¿˜æœ‰ä¸€äº›å¤æ‚çš„å¯¹ç§°æ€§ã€‚æ˜¯çš„ï¼šæ¯ä¸ªä¹˜æ•°åªæ˜¯ +1 æˆ– -1ï¼Œå› æ­¤è®¡ç®—å½’ç»“ä¸ºåœ¨è¾“å…¥æ•°æ®ä¸­ç¿»è½¬ä¸€äº›ç¬¦å·ï¼Œç„¶åæ±‚å’Œã€‚
- en: The matrix looks fairly trivial, but its design is involved. To capture all
    frequency and phase information, the rows have increasing *sequency* â€” that is,
    each next row has just one more sign flip than the one before. Further, the pattern
    is carefully engineered to ensure *orthogonality* â€” the fragile input-output symmetry
    that allows seamless conversions back and forth between the frequency representation
    and the original time-series data.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µçœ‹èµ·æ¥ç›¸å½“å¾®ä¸è¶³é“ï¼Œä½†å…¶è®¾è®¡å¾ˆå¤æ‚ã€‚ä¸ºäº†æ•æ‰æ‰€æœ‰é¢‘ç‡å’Œç›¸ä½ä¿¡æ¯ï¼Œè¡Œå…·æœ‰é€’å¢çš„ *åºåˆ—æ€§* â€” æ¯ä¸ªä¸‹ä¸€è¡Œæ¯”å‰ä¸€è¡Œå¤šä¸€ä¸ªç¬¦å·ç¿»è½¬ã€‚æ­¤å¤–ï¼Œæ¨¡å¼è¢«ç²¾å¿ƒè®¾è®¡ä»¥ç¡®ä¿
    *æ­£äº¤æ€§* â€” è¿™ç§è„†å¼±çš„è¾“å…¥-è¾“å‡ºå¯¹ç§°æ€§å…è®¸åœ¨é¢‘ç‡è¡¨ç¤ºå’ŒåŸå§‹æ—¶é—´åºåˆ—æ•°æ®ä¹‹é—´æ— ç¼è½¬æ¢ã€‚
- en: 'Because of its complex structure, the most practical way to construct the Walsh
    matrix is to start by generating something known as the Hadamard matrix. For *N=16*,
    this intermediate matrix looks the following way:'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºå…¶å¤æ‚çš„ç»“æ„ï¼Œæ„é€  Walsh çŸ©é˜µçš„æœ€å®ç”¨æ–¹æ³•æ˜¯ä»ç”Ÿæˆæ‰€è°“çš„ Hadamard çŸ©é˜µå¼€å§‹ã€‚å¯¹äº *N=16*ï¼Œè¿™ä¸ªä¸­é—´çŸ©é˜µçœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '*The Hadamard matrix for N=16\. Huh?*'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*N=16* çš„ Hadamard çŸ©é˜µã€‚å—¯ï¼Ÿ'
- en: 'At a glance, the plot looks chaotic, but itâ€™s simply a reordering of the Walsh
    layout. For example, row #15 is moved to #1, while the original #1 now sits at
    #8\. But importantly, unlike Walsh, this fractal-esque pattern is actually fairly
    easy to create from scratch.'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹ä¸€çœ‹ï¼Œç»˜å›¾çœ‹èµ·æ¥æ··ä¹±ï¼Œä½†å®ƒåªæ˜¯ Walsh å¸ƒå±€çš„é‡æ–°æ’åºã€‚ä¾‹å¦‚ï¼Œç¬¬ 15 è¡Œç§»åŠ¨åˆ°ç¬¬ 1 è¡Œï¼Œè€ŒåŸå§‹çš„ç¬¬ 1 è¡Œç°åœ¨ä½äºç¬¬ 8 è¡Œã€‚ä½†æ˜¯é‡è¦çš„æ˜¯ï¼Œä¸
    Walsh ä¸åŒï¼Œè¿™ç§ç±»ä¼¼åˆ†å½¢çš„æ¨¡å¼å®é™…ä¸Šç›¸å½“å®¹æ˜“ä»å¤´å¼€å§‹åˆ›å»ºã€‚
- en: 'To get the ball rolling with Hadamard, we start with the following trivial
    1Ã—1 array:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: è¦å¼€å§‹ Hadamard çš„è¿ç®—ï¼Œæˆ‘ä»¬ä»ä»¥ä¸‹å¾®ä¸è¶³é“çš„ 1Ã—1 æ•°ç»„å¼€å§‹ï¼š
- en: \(H_0 = \begin{bmatrix} +1 \end{bmatrix}\)
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: \(H_0 = \begin{bmatrix} +1 \end{bmatrix}\)
- en: 'From there, we iteratively extend it by taking the array generated in the previous
    step (*H[n-1]*) and tiling four copies of it on a grid with twice the original
    dimensions. The first three copies are verbatim, and the final one â€” bottom right
    â€” has all the signs flipped. The mathematical notation for this extension is:'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œé€šè¿‡å–å‰ä¸€æ­¥éª¤ç”Ÿæˆçš„æ•°ç»„ (*H[n-1]*) å¹¶åœ¨åŸå§‹å°ºå¯¸çš„ä¸¤å€ç½‘æ ¼ä¸Šé“ºè®¾å››ä¸ªå‰¯æœ¬æ¥è¿­ä»£åœ°æ‰©å±•å®ƒã€‚å‰ä¸‰ä¸ªå‰¯æœ¬å®Œå…¨ç›¸åŒï¼Œæœ€åä¸€ä¸ª â€” å³ä¸‹è§’ â€”
    æ‰€æœ‰ç¬¦å·éƒ½ç¿»è½¬ã€‚è¿™ç§æ‰©å±•çš„æ•°å­¦è¡¨ç¤ºå¦‚ä¸‹ï¼š
- en: \(H_{n} = H_{n-1} \otimes \begin{bmatrix} +1 & +1 \\ +1 & -1 \end{bmatrix}\)
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: \(H_{n} = H_{n-1} \otimes \begin{bmatrix} +1 & +1 \\ +1 & -1 \end{bmatrix}\)
- en: 'The fancy operator (âŠ—) is known as the *Kronecker product*, but itâ€™s really
    just glorified copy-and-paste. The first extension â€” consisting of four copies
    of *H[0]* â€” looks the following way:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªèŠ±å¼è¿ç®—ç¬¦ (âŠ—) è¢«ç§°ä¸º *Kronecker ä¹˜ç§¯*ï¼Œä½†å®é™…ä¸Šåªæ˜¯ä¸€ä¸ªç‚«è€€çš„å¤åˆ¶ç²˜è´´ã€‚ç¬¬ä¸€ä¸ªæ‰©å±• â€” ç”±å››ä¸ª *H[0]* çš„å‰¯æœ¬ç»„æˆ â€” çœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: \(H_1 = \begin{bmatrix} \begin{array}{c | c } +1 & +1 \\ \hline +1 & -1 \end{array}\end{bmatrix}
    \)
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: \(H_1 = \begin{bmatrix} \begin{array}{c | c } +1 & +1 \\ \hline +1 & -1 \end{array}\end{bmatrix}
    \)
- en: 'Another iteration makes four copies of *H[1]*, producing this layout:'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ä¸ªè¿­ä»£äº§ç”Ÿå››ä¸ª *H[1]* çš„å‰¯æœ¬ï¼Œç”Ÿæˆè¿™æ ·çš„å¸ƒå±€ï¼š
- en: \(H_2 = \begin{bmatrix} \begin{array}{c c | c c} +1 & +1 & +1 & +1 \\ +1 & -1
    & +1 & -1 \\ \hline +1 & +1 & -1 & -1 \\ +1 & -1 & -1 & +1 \end{array} \end{bmatrix}\)
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: \(H_2 = \begin{bmatrix} \begin{array}{c c | c c} +1 & +1 & +1 & +1 \\ +1 & -1
    & +1 & -1 \\ \hline +1 & +1 & -1 & -1 \\ +1 & -1 & -1 & +1 \end{array} \end{bmatrix}\)
- en: â€¦and so on. The size of the resulting Hadamard matrix is always *2^nÃ—2^n,* where
    *n* is the number of construction steps we went through.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: â€¦ç­‰ç­‰ã€‚ç”Ÿæˆçš„HadamardçŸ©é˜µçš„å¤§å°å§‹ç»ˆæ˜¯*2^nÃ—2^n*ï¼Œå…¶ä¸­*n*æ˜¯æˆ‘ä»¬ç»å†çš„æ„é€ æ­¥éª¤æ•°é‡ã€‚
- en: 'On a computer, the matrix can be computed by following this tiling algorithm,
    but thereâ€™s a cute bitwise arithmetic trick we can employ instead: as it turns
    out, the value of the Hadamard function at a particular cell can be divined by
    calculating *x & y* and then checking if the number of bits set in the result
    is even or odd. The following C code does just that, and then displays an 8Ã—8
    Hadamard matrix on the screen:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¡ç®—æœºä¸Šï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹å¹³é“ºç®—æ³•è®¡ç®—çŸ©é˜µï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§å·§å¦™çš„ä½è¿ç®—æŠ€å·§ï¼šäº‹å®è¯æ˜ï¼Œé€šè¿‡è®¡ç®—*x & y*ï¼Œç„¶åæ£€æŸ¥ç»“æœä¸­è®¾ç½®çš„ä½æ•°æ˜¯å¶æ•°è¿˜æ˜¯å¥‡æ•°ï¼Œå¯ä»¥æ¨æ–­ç‰¹å®šå•å…ƒæ ¼ä¸­Hadamardå‡½æ•°çš„å€¼ã€‚ä»¥ä¸‹Cä»£ç æ­£æ˜¯å¦‚æ­¤ï¼Œå¹¶åœ¨å±å¹•ä¸Šæ˜¾ç¤ºäº†ä¸€ä¸ª8Ã—8çš„HadamardçŸ©é˜µï¼š
- en: '[PRE0]'
  id: totrans-split-35
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In principle, this matrix is sufficient to construct a frequency-domain transform.
    That said, its ordering of the frequency bins is unintuitive, so letâ€™s try to
    fix that before we leave.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: åŸåˆ™ä¸Šï¼Œæ­¤çŸ©é˜µè¶³ä»¥æ„å»ºé¢‘åŸŸå˜æ¢ã€‚å°½ç®¡å¦‚æ­¤ï¼Œå…¶é¢‘ç‡ç®±çš„æ’åºä¸ç›´è§‚ï¼Œæ‰€ä»¥åœ¨ç¦»å¼€ä¹‹å‰è®©æˆ‘ä»¬è¯•ç€ä¿®å¤å®ƒã€‚
- en: To turn the Hadamard matrix in the nicely-ordered flavor showcased earlier,
    we need to sort the rows based on their sequency.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: è¦å°†ä¹‹å‰å±•ç¤ºçš„æœ‰åºHadamardçŸ©é˜µè½¬æ¢ä¸ºæ¼‚äº®çš„å½¢å¼ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®å®ƒä»¬çš„åºåˆ—æ€§å¯¹è¡Œè¿›è¡Œæ’åºã€‚
- en: 'The most straightforward way, found in just about every reference implementation,
    is just to count the number of sign changes in each row. That said, [a reader](https://icosahedron.website/@gaditb/112228725360149921)
    pointed out another clever bit-twiddling hack: for an array with *2^n*rows, Hadamard
    row mappings can be computed by XORing Walsh row numbers with their own value
    shifted by a single bit to the right, and then reversing the order of the last
    *n* bits.'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ç®€å•çš„æ–¹å¼ï¼Œåœ¨å‡ ä¹æ¯ä¸ªå‚è€ƒå®ç°ä¸­éƒ½å¯ä»¥æ‰¾åˆ°ï¼Œåªéœ€è®¡ç®—æ¯è¡Œä¸­ç¬¦å·æ›´æ”¹çš„æ•°é‡ã€‚å°½ç®¡å¦‚æ­¤ï¼Œ[ä¸€ä½è¯»è€…](https://icosahedron.website/@gaditb/112228725360149921)æŒ‡å‡ºå¦ä¸€ä¸ªå·§å¦™çš„ä½æ“ä½œæŠ€å·§ï¼šå¯¹äºä¸€ä¸ªå…·æœ‰*2^n*è¡Œçš„æ•°ç»„ï¼ŒHadamardè¡Œæ˜ å°„å¯ä»¥é€šè¿‡å°†Walshè¡Œå·ä¸å…¶è‡ªèº«å‘å³ç§»åŠ¨ä¸€ä¸ªä½å¹¶åè½¬æœ€å*n*ä½çš„é¡ºåºæ¥è®¡ç®—ã€‚
- en: 'Hereâ€™s an implementation that does just that and prints a sorted 8Ã—8 array
    on the screen:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæ‰§è¡Œæ­¤æ“ä½œå¹¶åœ¨å±å¹•ä¸Šæ‰“å°æ’åºåçš„8Ã—8æ•°ç»„çš„å®ç°ï¼š
- en: '[PRE1]'
  id: totrans-split-40
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Equipped with this, we can gut the DCT implementation and make a â€œdiscrete
    square transformâ€ and its inverse:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: å¸¦æœ‰æ­¤æŠ€æœ¯ï¼Œæˆ‘ä»¬å¯ä»¥æ·±å…¥DCTå®ç°å¹¶åˆ¶ä½œâ€œç¦»æ•£æ–¹å½¢å˜æ¢â€åŠå…¶é€†å˜æ¢ï¼š
- en: '[PRE2]'
  id: totrans-split-42
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Technically, this is called the *Walshâ€“Hadamard transform* (WHT), but never
    mind. Letâ€™s confirm that it works:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: æŠ€æœ¯ä¸Šï¼Œè¿™è¢«ç§°ä¸º*åå°”ä»€-å“ˆè¾¾ç›å˜æ¢*ï¼ˆWHTï¼‰ï¼Œä½†ä¸è¦ç´§ã€‚è®©æˆ‘ä»¬ç¡®è®¤å®ƒæ˜¯å¦æœ‰æ•ˆï¼š
- en: '[PRE3]'
  id: totrans-split-44
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The input is a square-wave-ish sequence of numbers: 1 1 1 1 5 5 5 5\. The output
    from DFT or DCT would be a bunch of harmonics across multiple frequency bins:'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: è¾“å…¥æ˜¯ä¸€ä¸²ç±»ä¼¼æ–¹æ³¢çš„æ•°å­—åºåˆ—ï¼š1 1 1 1 5 5 5 5ã€‚ä»DFTæˆ–DCTçš„è¾“å‡ºå°†ä¼šæ˜¯è·¨è¶Šå¤šä¸ªé¢‘ç‡ç®±çš„å¤šä¸ªè°æ³¢ï¼š
- en: '[PRE4]'
  id: totrans-split-46
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In contrast, the frequency-domain representation generated by the program shows
    non-zero components only in *F[0]* (DC) and *F[1]*, confirming that we have an
    algorithm that deconstructs the signal into pure square waves:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼Œç”±ç¨‹åºç”Ÿæˆçš„é¢‘åŸŸè¡¨ç¤ºä»…æ˜¾ç¤ºåœ¨*F[0]*ï¼ˆDCï¼‰å’Œ*F[1]*ä¸­çš„éé›¶åˆ†é‡ï¼Œè¯å®æˆ‘ä»¬æœ‰ä¸€ç§å¯ä»¥å°†ä¿¡å·åˆ†è§£ä¸ºçº¯æ–¹æ³¢çš„ç®—æ³•ï¼š
- en: '[PRE5]'
  id: totrans-split-48
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we can verify that the inverse function â€” *isqft() â€”* transforms the
    frequency domain back to what we started with:'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬å¯ä»¥éªŒè¯é€†å‡½æ•°â€”â€”*isqft()â€”â€”*å°†é¢‘åŸŸè½¬æ¢å›æˆ‘ä»¬èµ·å§‹çš„å†…å®¹ï¼š
- en: '[PRE6]'
  id: totrans-split-50
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I couldnâ€™t find any visual comparisons of the algorithmsâ€™ outputs, so I prepared
    my own. Hereâ€™s the quasi-conventional DCT spectrogram of an [ğŸ”ˆ 11-second clip](https://lcamtuf.coredump.cx/dare.mp3)
    from â€œDAREâ€ by Gorillaz:'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æ‰¾ä¸åˆ°ç®—æ³•è¾“å‡ºçš„å¯è§†åŒ–æ¯”è¾ƒï¼Œæ‰€ä»¥æˆ‘å‡†å¤‡äº†è‡ªå·±çš„ã€‚è¿™æ˜¯â€œDAREâ€ by Gorillazçš„[ğŸ”ˆ 11ç§’ç‰‡æ®µ](https://lcamtuf.coredump.cx/dare.mp3)çš„å‡†ä¼ ç»ŸDCTé¢‘è°±å›¾ï¼š
- en: '*Your old-fashioned, family-friendly sine spectrogram.*'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä½ è€å¼ã€å®¶åº­å‹å¥½çš„æ­£å¼¦æ³¢é¢‘è°±å›¾*ã€‚'
- en: 'â€¦and hereâ€™s the cool-looking Walsh-Hadamard equivalent:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: â€¦è¿™æ˜¯åå°”ä»€-å“ˆè¾¾ç›çš„é…·ç‚«ç­‰æ•ˆå›¾ï¼š
- en: '*A world premiere of the square-wave spectrogram.*'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ–¹æ³¢é¢‘è°±å›¾çš„ä¸–ç•Œé¦–ç§€*ã€‚'
- en: The Walsh-Hadamard transform, being computationally efficient and well-suited
    for certain types of data, finds uses in a couple of niches. The point isnâ€™t that
    it needs to be used more; itâ€™s just that discrete Fourier doesnâ€™t have a monopoly
    on truth.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: åå°”ä»€-å“ˆè¾¾ç›å˜æ¢å› å…¶è®¡ç®—æ•ˆç‡é«˜ä¸”é€‚ç”¨äºæŸäº›æ•°æ®ç±»å‹è€Œåœ¨æŸäº›é¢†åŸŸä¸­å¾—åˆ°åº”ç”¨ã€‚é‡ç‚¹ä¸åœ¨äºå®ƒéœ€è¦æ›´å¤šä½¿ç”¨ï¼›åªæ˜¯ç¦»æ•£å‚…é‡Œå¶å˜æ¢å¹¶éå”¯ä¸€çš„çœŸç†ã€‚
- en: '*For more articles on electronics, click [here](https://lcamtuf.coredump.cx/offsite.shtml).*'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ›´å¤šæœ‰å…³ç”µå­å­¦çš„æ–‡ç« ï¼Œè¯·ç‚¹å‡»[è¿™é‡Œ](https://lcamtuf.coredump.cx/offsite.shtml)*ã€‚'
