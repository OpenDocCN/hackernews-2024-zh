<!--yml

category: 未分类

date: 2024-05-27 13:37:36

-->

# 你不能只是假设UTF-8

> 来源：[https://csvbase.com/blog/9](https://csvbase.com/blog/9)

人类说着无数不同的语言。这些语言不兼容，而且运行时的转译真的很痛苦。遗憾的是，每一个[标准化](https://en.wikipedia.org/wiki/Esperanto) [倡议](https://en.wikipedia.org/wiki/Lojban) 都以失败告终。

至少有一个人应该为这种局面负责：上帝。毕竟是他在[早期关于一个有争议的房地产开发问题](https://www.kingjamesbibleonline.org/Genesis-11-7/)上，诅咒了人类说不同的语言。

然而，人类只能责备自己，因为*计算机*之间的通信困难。

而最大的问题之一是最简单的：计算机对如何用二进制写字母意见不一。

## 如何用二进制写字母

如何把字母编码成二进制？

比如，让我们以字符“A”为例。它在美国信息交换标准码（或[ASCII](https://man7.org/linux/man-pages/man7/ascii.7.html)）中被分配了编号65。这个编号被[继承到](https://codepoints.net/U+0041)了Unicode，不过Unicode的人们把65写成十六进制，即`U+0041`，并称其为“码点”。

足够简单——至少关于“A”的数字享有广泛的共识。但计算机不能简单地存储十进制数，它们只能存储二进制。

在最流行的字符编码UTF-8中，字符编号65（“A”）被写成：

`01000001`

只有第二和最后的两位是`1`，或者说“打开”的。第二位值为64，最后一位值为1。这两位加起来就是65。非常简单。

另一个流行的编码是UTF-16，在Windows、Java和JavaScript世界中主要使用。65在UTF-16中表示为：

`01000001 00000000`

这与UTF-16类似，除了UTF-16使用（至少）两个完整字节表示每个字符，但不需要任何额外的位来表示65，所以第二个字节为空白。

其他编码怎么样？这里只列出了几个流行的：

+   [Win-1252](https://en.wikipedia.org/wiki/Windows-1252)，一个非Unicode编码，在欧洲语言使用地区使用

+   [KOI8](https://en.wikipedia.org/wiki/KOI8-RU) - 非Unicode，在使用[西里尔字母](https://en.wikipedia.org/wiki/Cyrillic_script)的地方使用

+   [GB18030](https://en.wikipedia.org/wiki/GB_18030) - 是Unicode，但主要在中国大陆使用

+   [Big5](https://en.wikipedia.org/wiki/Big5) - 非Unicode，在繁体中文使用广泛

+   [Shift_JIS](https://en.wikipedia.org/wiki/Shift_JIS) - 非Unicode，在日本使用

好吧，所有这些其他编码也都继承了ASCII字母，所以它们都将`A`表示为：

`01000001`

就像UTF-8一样。

所以美好的日子来了。这就是为什么基本的西方字母表通常在文档的其余部分是混乱不堪的情况下仍然有效。许多流行的编码 - 除了 UTF-16 外 - 至少对于拉丁字母表都遵循 ASCII。

嗯，到目前为止一切都还好。但现在让我们看看一个更棘手的字符。欧元符号，€。由 Unicode 联盟编号为 [8364](https://codepoints.net/U+20AC)（`U+20AC`）。

在 UTF-8 中，8364 由以下方式表示：

`11100010 10000010 10101100`

注意，这需要 UTF-8 三个字节。UTF-8 是一种“可变长度”字符编码 - Unicode 数字越高，需要的字节就越多。（这对于 UTF-16 也是如此，但更少见。）

然而在 UTF-16 中，8364 的编码完全不同：

`10101100 00100000`

然而，Win-1252 不遵循 Unicode。它将欧元符号编号为128。然后它这样表示128：

`10000000`

因此只有第一个位上是开的，价值128。

这就是麻烦的开始所在。一旦离开英文字母的叶状郊区，表示方式很快就会变得一塌糊涂。

`€` 在 KOI8 中完全无法表示。

在 GB18030 中，€ 被编码为：

`10100010 11100011`

在 Big5 中，€ 是：

`10100011 11100001`

在 Shift JIS 中，它是：

`10000000 00111111`

完全不同且完全不兼容。如果假设是 UTF-8，会得到完全无意义的结果。

## 如何确定正在使用的编码方式？

一些格式规定了编码，例如 JSON 规定必须是 UTF-8。这确实简化了事情 - 一旦知道是 JSON，就知道必须是 UTF-8。

其他时候，可以通过“带外”方式传输编码。HTTP 允许您将编码放在 `Content-Type` 头部中：

```
Content-type:  text/html;  charset=ISO-8859-1 
```

而一些格式有一种“带内”方式来指示编码。例如，一些文本文件有头部：

```
# -*- encoding: utf-16be -*- 
```

虽然这有点令人费解，因为您需要能够读取文件才能找到那一位。

但是如果没有标签呢？

如果标签错误怎么办？接下来我会讨论这点是很常见的。

特别是 CSV 文件没有办法“带内”地信号哪种编码被使用。您不能放置注释，因为没有空间 - 并且 csv 阅读器在大多数情况下无法解析您的 csv。许多处理 CSV 文件的流行工具（如 MS Excel）也不使用 UTF-8。

然后呢？

答案是：统计数据。

## 使用统计数据检测编码

有两种基本策略用于检测未标记文本串的编码。

1.  字节级别

1.  字符级别

大多数实现首先使用字节级，然后是字符级，如果必要的话。

### 字节级启发式

字节级别相对直接。您可以查看字节并判断它们是否适合给定的字符编码。

例如，正如我之前所说的，UTF-16（大多数情况下）每个字符使用两个字节。对于拉丁文本（例如英文），这往往导致许多“空白”的第二字节。幸运的是，许多标记语言使用大量的拉丁文本（例如`<`，`>`，`[`，`]`等），即使文档不是拉丁文。如果您的测试字符串包含大量的空白第二字节——那么很可能它是UTF-16。

还有其他的线索。想象你是一个网络浏览器，链接把用户带到一个文件，这个文件的前两个字节是这些：

`00111100 00100001`

如果这是UTF-16，这两个字节将是ℼ，一个名为["double struck small pi"](https://codepoints.net/U+213C)的符号，Unicode编码为8508（U+213C）。这是HTML文件中常见的第一个字符吗？

或者，也许，更可能是UTF-8编码的两个字符序列`<!`？也许接下来的字节是`doctype>`，或者任何HTML文档的标准模板？仅供参考！

另一个线索是特定的字节。令人沮丧的是，UTF-16有两个版本，一个是您按照正常方式编写位，另一个是您将它们全部反转。为了让人们区分这两种形式，UTF-16的标准包括一个["字节顺序标记"](https://en.wikipedia.org/wiki/Byte_order_mark)，您可以将其放在文本流的开头以指示您使用的版本。这对字节在其他编码中并不经常出现，特别是在开头，因此通常是关于接下来内容的一个好提示。

所以字节可以让你走得相当远。如果你现在可以明确地将其缩小到UTF-8或UTF-16，那么你的工作就完成了。

### 字符级的启发式方法。

棘手的情况往往是非Unicode的单字节编码。例如，区分Win-1252和KOI8，因为它们都使用ASCII的空白第一位来编码不同的东西。

你如何区分它们？通过频率分析。你看看文档中可能出现的字母，例如如果它是KOI8，然后问：“这是一个西里尔文档的典型字母分布吗？”。

这里是一个基本算法：

+   排除所有被先前的字节级启发式方法排除的编码

+   对于每个剩余可能的编码`X`

    +   作为若被编码为`X`的输入解析。

    +   将字符串中字符的频率与已知频率表中的字符进行比较

    +   可选地，也比较*字母对*（例如`qu`）与已知的频率表。

    +   如果它们是一个很好的匹配，返回`X`

+   否则，失败。

通常你也可以通过这种方式告诉文档使用的语言——这是网页浏览器知道弹出“是否要翻译此页面”的对话框的一种方式。

## 它真的有效吗？

启发式方法往往让人感到不安，但答案是：是的。它的效果出奇地好。它当然比简单地假定文本是UTF-8要好得多——而且最终这是基准。

这些统计数据能很好地工作可能不应该令人惊讶。它们通常在语言上表现良好，从[第一个有效的垃圾邮件过滤器](https://paulgraham.com/better.html)到[许多其他事物](https://research.google.com/pubs/archive/35179.pdf)。

启发式方法同样重要，因为人们经常搞错编码。

如果你假设在最新版的 MS Excel 中将 Excel 表格导出为 CSV 文件会得到 UTF-8 或者 UTF-16 编码，那你就错了。在大多数配置中，默认情况下，Excel 会输出你的 CSV 以 Win-1252 编码。

Win-1252 是一种非 Unicode 的单字节编码。它是 ASCII 的扩展，将几乎所有欧洲语言的字符塞入了未使用的第八位。典型的 Excel 用户从未听说过它，即使他们听说过字符编码。[无知是福](https://www.kingjamesbibleonline.org/Ecclesiastes-1-18/)。

## 另见

大多数编码检测代码可能都基于早期 2000 年代 Netscape 奠定的原则。原始作者描述他们方法的论文[存于 Mozilla 的档案](https://www-archive.mozilla.org/projects/intl/universalcharsetdetection)。

自动检测文本编码确实体现了[波斯特尔法则](https://en.wikipedia.org/wiki/Robustness_principle)的一种实例：“在你所做的事情上保守，在你接受别人的事情上宽容”。波斯特尔法则是我一直认为是真理的东西，但现在[越来越有争议](https://datatracker.ietf.org/doc/html/rfc9413)。或许有理由认为 csvbase 的自动检测应该是一个更显式的用户界面操作，而不是一个预选的组合框。关于此问题请寄明信片至[常用地址](mailto:cal@calpaterson.com)。
