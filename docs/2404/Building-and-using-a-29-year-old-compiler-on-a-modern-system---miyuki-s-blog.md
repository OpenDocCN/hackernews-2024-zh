<!--yml

category: 未分类

date: 2024-05-27 12:51:28

-->

# 在现代系统上构建和使用29年前的编译器 · miyuki's blog

> 来源：[https://miyuki.github.io/2017/10/04/gcc-archaeology-1.html](https://miyuki.github.io/2017/10/04/gcc-archaeology-1.html)

# 在现代系统上构建和使用29年前的编译器

04 Oct 2017

在这篇文章中，我将分享我在现代系统上构建和使用最早版本之一的 GNU C 编译器 —— GCC 1.27（发布于1988年）的经历。

## 环境

对于我的实验，我使用了基于 Debian 8 的 LXC 容器（为什么不用 9？因为我在 Debian 9 发布前就已经开始写这篇文章）。我决定使用 i386 容器（而非 amd64 容器）以免费力；我相信在一些路径和符号链接的处理后，amd64 也能够正常使用。

Debian 8 提供 GCC 4.9.2 作为主机编译器，Binutils 2.25 和 Glibc 2.19。

## 获取源代码

可以在[官方服务器](https://gcc.gnu.org/pub/gcc/old-releases/)下载到 GCC 的旧版本。第一个可用的版本是 [0.9](https://gcc.gnu.org/pub/gcc/old-releases/gcc-1/gcc-0.9.tar.bz2)。不幸的是，这个版本对我们来说并不太有趣，因为它不支持 i386 架构（或者任何兼容的架构）。

[1.27](https://gcc.gnu.org/pub/gcc/old-releases/gcc-1/gcc-1.27.tar.bz2)版的 GNU C 编译器（请注意当时它被称为 GNU C 编译器而不是 GNU 编译器集合）是第一个支持 i386 架构的版本。它于 1988 年 05.09 发布（当时还没有 Linux）。

## 构建和测试

与现代版本不同的是，GCC 1.27 不包含任何巨大的配置脚本，配置需要手动完成。尽管如此，这是非常直接并且有很好的文档支持。事实上，它仅涉及创建 4 个符号链接。

令人惊讶的是，GNU 工具链在维护 C 标准兼容性方面的表现如此出色。此外，基本的 Glibc 头文件也向后兼容老旧的编译器。因此，只需在码中改变不到一千分之一的部分（约92000行代码）后，我们就能够使用现代编译器编译 GCC 1.27。其中大部分关于 C 库的更改，还有一些是由于现代 C 编译器实现的更严格的 C 语法规则（见[gcc-1.27.patch](https://gist.github.com/miyuki/9eab2c6a43e23c95183eb39e1f5e6833)）。

另一个问题是缺少名为 `syms.h` 的头文件，它显然定义了在 SDB 格式中生成调试信息所用到的某些常量。头文件丢失并不奇怪：在 Linux 上，SDB 早在很久以前就被 DWARF 格式取代了。我设法在 MIT 网站找到了这些头文件：[syms.h](http://www.mit.edu/afs.new/athena/system/rs_aix32/os/usr/include/syms.h)。URL 暗示着这些文件与 IBM AIX 操作系统有关。

### 头文件和规格

使源码在现代系统上可编译还不足以获得一个可工作的编译器。正如你可能知道的，GNU工具链包括其他工具，比如汇编器和链接器，与编译器互动。幸运的是，生成的汇编代码的语法与现代版本的GNU汇编器完全兼容（除了调试信息）。至于链接器，则需要一些调整来适应所谓的链接器规范（即GCC驱动程序使用的命令行选项）。

应用了这些修复之后，现在我们有一个能够生成有效的`elf`二进制文件的编译器。

### 引导

快速提醒一下：引导一个编译器意味着使用自身来编译它。更多详情请参考维基百科上的"[引导（编译器）](https://zh.wikipedia.org/wiki/%E5%BC%95%E5%AF%BC_(%E7%BC%96%E8%AF%91%E5%99%A8))"条目。

引导的第一个小问题来自于glibc头文件：现代版本的glibc假设编译器支持64位整型，而对于GCC 1.27来说这并不成立。罪魁祸首是`/usr/include/bits/byteswap.h`。可以通过向编译器传递`-D_BITS_BYTESWAP_H`标志来轻松禁用它。

现在，尝试引导编译器导致在名为`cccp.c`的文件的编译过程中失败：编译器因为段错误而崩溃。经过一番调查失败原因，我使用[C-Reduce](https://embed.cs.utah.edu/creduce/)成功制作出一个最小化的失败测试案例：

```
struct file_buf { } fn1(), a;
fn2() { a = fn1(); }
```

编译器在尝试将表达式`a = fn1()`从AST翻译成其中间表示（RTL）时，由于i386后端在处理返回结构体类型函数调用的代码时存在错误，导致尝试解引用空指针而崩溃。

修复这个错误其实相对来说很简单。添加一个单一的检查，这在GCC 1.31中已经存在，可以修复这个错误并且现在可以成功地启动引导过程。

顺便说一句，这可能意味着之前没有人尝试在x86上引导GCC 1.27。

此外，我成功进行了引导比较，即构建：

+   第1阶段编译器，即由主机编译器（GCC 4.9.2）编译的GCC 1.27

+   第2阶段编译器，即由主机编译器（GCC 4.9.2）编译的GCC 1.27

+   第3阶段编译器，即由第2阶段编译器编译的GCC 1.27

正如我预料的那样，第2阶段和第3阶段是相同的。

### 玩耍

我试图找一些代码（除了GCC本身）来编译和测试。记住：我们需要用所谓的K&R C编写的代码（因为当时还不存在ANSI C89标准）。

例如，我使用一个[程序](https://people.sc.fsu.edu/~jburkardt/c_src/mandelbrot_ascii/mandelbrot_ascii.html)，它可以生成Mandelbrot集的ASCII图像（不幸的是，我没能找到这段代码的作者是谁）。

这是为了更好地可读性而格式化的代码：

```
main (n)
{
  float r, i, R, I, b;
  for (i = -1; i < 1; i += .06, puts (""))
    for (r = -2; I = i, (R = r) < 1; r += .03, putchar (n + 31))
      for (n = 0; b = I * I, 26 > n++ && R * R + b < 4;
        I = 2 * R * I + i, R = R * R - b + r);
}
```

正如您所见，它涉及相当复杂的控制流和浮点运算。GCC 1.27在编译时没有错误，并且与现代版本的GCC编译的相同代码输出相匹配。

GCC 1.27包含许多现代编译器典型的功能，例如：

+   编译器警告

+   优化

+   调试信息输出

+   用于代码分析的仪器化

+   控制上述所有内容的命令行标志

## 探索GCC源代码

另一件让我惊讶的事情是，这些旧版本的GCC中许多想法甚至大部分代码仍然在今天使用。

编译器通过可切换的头文件（例如，在i386 System V上使用`config-i386v.h`，在Sparc Sun上使用`config-sparc.h`）支持多个后端。机器描述`.md`文件描述了CPU指令模式。在构建阶段，它们被解析并转换为C源文件，稍后与编译器链接。当然，在过去的几十年里，`.md`的DSL已经发展，但原理仍然相同。此外，LLVM编译器基础设施[使用](http://llvm.org/docs/CodeGenerator.html#using-tablegen-for-target-description)了类似的技术。

两种无处不在的数据类型`tree`和`rtl`分别用于表示编译器前端和后端中的程序，仍然发挥着它们的作用。

当然，这并不意味着当前版本的GCC停留在80年代。尽管有些相似之处，但主要增强的数量确实非常庞大，我不打算逐一列举它们（这是一篇带有一些基准测试、图表和信息图的好文章主题）。

旧版本的GCC没有故障跟踪站点，因此，故障和增强请求的列表存储在名为`PROBLEMS`的文件中。截至1.27版本，其中包含27个条目，编号间有很多空缺。实际上，最后一项编号为122。这可能意味着在此版本发布之前，其余的95个问题已经修复。
