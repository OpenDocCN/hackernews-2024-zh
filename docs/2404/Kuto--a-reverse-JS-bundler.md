<!--yml

category: 未分类

date: 2024-05-27 13:02:29

-->

# Kuto，一个反向JS打包工具

> 来源：[https://samthor.au/2024/kuto/](https://samthor.au/2024/kuto/)

# Kuto，一个反向JS打包工具

[Kuto](https://kuto.dev) 是一种在网络上交付代码的新方法。它允许您重复使用客户端已有的代码以进行更新。

对于一个拥有约3mb JS的“真实世界”网站，更新React依赖项导致：

+   下载量减少了71%

+   在~5岁的手机上启动时间快了28%（[Pixel 3](https://en.wikipedia.org/wiki/Pixel_3)）。

…与单个捆绑包或所有代码失效的任何情况相比。

请注意，Kuto在真实站点或应用程序的最终ESM捆绑包上效果非常好，但可能*不*适用于库本身，尽管Kuto的输出将是有效的。Kuto还作为大捆绑包的可预测“块”生成器运行。

如果这对您有兴趣——您是否有太多的JavaScript？——那么就去做吧，并在您的代码上做一个Kuto。（Kuto是一个动词吗？谁知道。我在试验。）✂️

## 它是如何工作的？

不专注于最小化输出或任何幂等操作，Kuto选择了一条不同的路线。

1.  在第一次构建时：

    +   Kuto将源JS分成“主”部分和通常更大的没有副作用的“代码库”。

    +   这个代码库可以被永久缓存（[forever](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#immutable)），并且其输出名称中包含了一个散列时间戳。

1.  在每次进一步构建时：

    +   Kuto仍然将源JS拆分出来

    +   它可以从任何现有的代码库中识别可以用来“满足”源JS的代码。

        +   每个代码库将会保持不变或*缩小*，如函数、语句等的变化

    +   任何无法满足的代码将被放入一个全新的代码库中，这也可以永久缓存。

这有点复杂。这里有一个~~gif~~视频：

<https://storage.googleapis.com/hwhistlr.appspot.com/assets/kuto-demo.mp4>

当某些内容发生变化时，Kuto将构建一个额外的代码库

每次构建后，您很可能会生成另一个具有更改代码的代码库。 （这最终将成为碎片化的问题，稍后详述。）

## 为什么它有效？

每个代码库一旦被客户端获取，就可以永久缓存。然而，每次构建时，该代码库*可能*会缩小。新客户端将获得更小的版本。（Kuto的代码库具有散列时间戳，并且您确实需要设置您的Web服务器以发送正确的[标头](https://web.dev/articles/love-your-cache)。）

但是…这打破了我们对Web缓存响应的所有了解！我改变了一个不可变的文件！🤯

结果是老客户端将有更大的文件，新客户端将有更小的文件，即使是相同的文件名。但是那个更大的文件现在只是有过时代码。Kuto的主要论点是，加载比您需要的稍大文件的磁盘I/O速度比重新编译要快。

（请注意至少 [基于 v8 的浏览器](https://v8.dev/blog/code-caching-for-devs) 缓存源代码的字节码，从而提供速度优势。 如果每次重新编译，Kuto 将无法帮助。）

除了这种显著疯狂的方式利用您的浏览器外，Kuto 还基本上以完全可预测、有用和自动化的方式执行代码拆分。 其他捆绑器要么要求您：

+   （完全不对输出捆绑包进行代码拆分）

+   明确标记依赖项以放入自己的捆绑包中。

+   在（实际上）随机边界上放置代码捆绑包，试图限制每个“块”的大小。

## 不是真的，它是如何工作的？

上面的解释相当高级。 在更低的级别上，Kuto 寻找没有副作用的代码，将其包含在其语料库中，并使用循环依赖确保其安全调用。

### 没有副作用

结果，定义函数没有副作用。 不，真的！ 函数的*定义*除了创建一个变量外什么也不做：

```
function foo() {
  console.info(`Side effect`);
} 
```

由于 `foo` *实际上没有被调用*，并且我们在模块范围内声明它，所以什么都不会发生。 直到运行 `foo`，它可能如同：

```
function foo() {

} 
```

Kuto 将这一理论推向极致，将类放入相同的形式中，甚至是任意语句。 我们*手势*可以将语句提升为函数内部。

### 循环依赖

每个语料库都包含独立的^函数，这些函数引用主文件以解析它们的依赖关系。 查看 Kuto 本身并运行其 "./release.sh" 脚本是查看此过程的好方法，这样构建 Kuto 本身。

对于一个简单的网站，追加自定义元素到您的页面，其中自定义元素已更改并重新构建，可能看起来像这样：

```
 import { _1 } from './main.kt-abc.js';
import { _2 } from './main.kt-def.js';
_1();
export { _2 };

import { _2 } from './main.js';
export var _1 = function setupSite() {
  const element = new _2();
  document.body.append(element);
}

export var _2 = class MyElement extends HTMLElement {  }; 
```

这一切看起来都很尴尬……确实是这样，但输出并不是真正为人类消费设计的，而是因为 ESM 的“被视为错误”特性而从中受益，循环依赖。

^Kuto 将在将来引用 *之间* 的语料库

## 我应该使用这个吗？

或许！

Kuto 是新产品，虽然科学说它有效，但有点奇怪。 正如我上面提到的，它在以下方面表现良好：

+   单一捆绑包输出网站

+   那些具有大型 JS 包（也许 >1mb？）的网站。

+   ……这些都由许多顶级 ESM 代码组成，例如函数和类

你需要做的是：

+   首先使用常规的捆绑工具

+   保留或访问您的旧构建工件 —— Kuto 不知道您已经通过魔术🪄*已经发货*什么。

+   为了更好的更新体验，需要在稍大的*首次加载*之间权衡。

另一个问题是，越来越多的浏览器正向缓存定期删除的世界迈进。 如果您的访问者没有缓存您的网站，则 Kuto *毫无意义* ——每次加载对于永远不会发生的更新都稍微昂贵。 个人经验可能有所不同。

无论如何，这个工具会输出一些统计数据，包括初始加载给你带来的额外开销，以及能够识别为具有“无副作用”的代码占总代码的百分比。需要明确的是，在小型代码库上运行 Kuto 没有任何好处——即使在土豆手机上解析几 kb 的 JS 代码成本微乎其微。🥔

所以你可以进行实验，看看它对你是否有效。我认为 Kuto 对企业应用程序会有所帮助（因为 JS 太臃肿，没有人*真正*关心），或者社交媒体（因为电力用户*如此频繁*出现）。

### 分裂

Kuto 随时间生成多个文件。现在，它实际上只使用了前 4 个（按大小排序）之前的捆绑包，尽管可以通过标志进行配置。这……不太好，我还没有想出一个好的自动度量标准来决定何时“清理”而不是“重用”。

但请考虑这一点：如果你只是不向 Kuto 提供历史捆绑包，那它……显然就无法使用它们了。因此，你可以决定是否为*下一个构建*值得修正一个 100 字节的文件中的拼写错误。

## 为什么只快了 28%？

忽略一些可能的负面影响，我在此面临一个重要问题。我的测试案例显示体积减少了 71%，但速度只增加了 28%。🤔

我怀疑 v8 对一堆模块代码的汇编*仍然相当昂贵*。是的，将大块静态代码外包并永久缓存是很棒的，但最终，你的网站仍然需要将所有这些组件汇编在一起。

## 一个问题

如果 Kuto 对你的代码捆绑和更新方式产生了实质性影响，即使在理论测试环境中，我也很愿意听到你的想法。如果你能提供一些甜甜的数据，欢迎随时联系我，包括提交 [GitHub issue](https://github.com/samthor/kuto/issues/new)。

## 谢谢

谢谢阅读！Kuto 的构建过程非常有趣，但老实说，我只花了几天全职工程的时间就让它运行起来了。这个想法我已经思考了几年，现在看到它得以实现，我感到非常自豪。🍇
