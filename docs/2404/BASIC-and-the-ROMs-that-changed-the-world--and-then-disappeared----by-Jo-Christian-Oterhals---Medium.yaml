- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:54:48'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: BASIC and the ROMs that changed the world (and then disappeared) | by Jo Christian
    Oterhals | Medium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://jcoterhals.medium.com/basic-and-the-roms-that-changed-the-world-and-then-disappeared-38318db4611c](https://jcoterhals.medium.com/basic-and-the-roms-that-changed-the-world-and-then-disappeared-38318db4611c)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For all practical purposes, BASIC is seldom used and mostly forgotten today.
    But given my praise for it, why is it like that? As I see there were three reasons,
    and as time went by, their accumulated effect was devastating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reason #1.'
  prefs: []
  type: TYPE_NORMAL
- en: The IBM PC, and later it’s clones, completely overtook the home computer market.
    On the PCs, very little were in ROMs. Instead, MS-DOS was usually loaded from
    diskettes or hard drive, and suddenly the operating system itself became the face
    of the computer. Not BASIC.
  prefs: []
  type: TYPE_NORMAL
- en: So from the get-go you were one degree removed from BASIC. If you wanted to
    use it, you had to explicitly start it *after* you had started DOS. BASIC was
    in that sense just like any other application. Within the BASIC application you
    typed and run your BASIC programs as you did on the previous generation of home
    computers. But, ironically in a world where DOS was the face of the computer,
    there was no immediate way to run saved BASIC programs from the MS-DOS command
    line. You had to load the BASIC environment first and run them from there.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, BASIC on these machines felt like an afterthought.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reason #2.'
  prefs: []
  type: TYPE_NORMAL
- en: If Street BASIC had caused incompatibilities between computer systems earlier,
    the newer OS-based PCs could cause incompatibilities *within* a system.
  prefs: []
  type: TYPE_NORMAL
- en: Since BASIC for MS-DOS were run from disk, you could obtain and use any version
    of BASIC that you liked. Borland’s Turbo Basic might interest you more than the
    Microsoft offerings. You might call this freedom of choice, something most of
    us value. But the downside was that if you gave your program to a friend, you
    couldn’t be certain that your friend’s BASIC were the same as yours.
  prefs: []
  type: TYPE_NORMAL
- en: And even if you didn’t choose to use non-bundled BASICs, but exclusively used
    the version that came with MS-DOS, you could be in trouble anyway. Before MS-DOS
    5.0, GW-BASIC was bundled with the operating system. It was more or less like
    the Dartmouth inspired ones you had found on home computers. But if you had MS-DOS
    5.0 or newer installed, GW-BASIC had been replaced by QBasic.
  prefs: []
  type: TYPE_NORMAL
- en: QBasic was an attempt at a modern BASIC. Depending on your point of view, it
    really was an improvement. From a usage standpoint, it was quite different. You
    edited your BASIC programs in a dedicated editor, and when you ran them, the editor
    was completely replaced by a new screen. On this screen you could interact with
    your programs. When you were finished, the interactive screen closed and you were
    back in the editor. The tight coupling between programming and usage was now gone.
  prefs: []
  type: TYPE_NORMAL
- en: Language wise, QBasic got rid of line numbers (unless you insisted on using
    them). Instead, it gained labels and sub-routines with named parameters. You could
    also differ between local and global variables. To a certain extent, you could
    even explicitly type variables. It looked more like BASICs to come, than the old
    ones it replaced. But even though these represented a maturation of the language,
    it was also the start of turning BASIC from being a language where you described
    your algorithm step by step in a linear fashion, to a non-linear one.
  prefs: []
  type: TYPE_NORMAL
- en: All of this arguably made for a better BASIC. But the changes also made the
    language less comprehensible for beginners. BASIC stopped being basic.
  prefs: []
  type: TYPE_NORMAL
- en: As for compatibility, GW-BASIC programs would mostly run fine in QBasic, provided
    that the programs were saved as ASCII files. But as this was a non-default option,
    few programs were. The other way around was more or less impossible. Given the
    improvements in and modernization of QBasic, programs written for it could not
    run on GW-BASIC.
  prefs: []
  type: TYPE_NORMAL
- en: But even if you and your friend’s software stack was identical, issues could
    still arise. Given the modularity of PCs, you couldn’t even be sure that the graphics
    modes supported were identical between them. That was a solvable problem, but
    still a nuisance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reason #3.'
  prefs: []
  type: TYPE_NORMAL
- en: Windows, and similar graphical user interfaces, removed BASIC even further from
    its roots by being something very different. You could of course choose to stay
    text based in a windowed world. But in that context, staying text based just wasn’t
    very satisfactory.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem with adapting BASIC to work with windows, is that Windows programs
    is a collection of, well, windows and buttons, text fields, etc. Even though parts
    of the software can be somewhat step-by-step, most of the software consists of
    fragments catering to each button, text field and window independently. The code
    has no obvious entry point, and can’t be read and understood as a recipe from
    A-Z.
  prefs: []
  type: TYPE_NORMAL
- en: We now also got a world where the environment was so function rich that it was
    no longer possible to have a separate command for each function of the computer.
    Libraries and modules became necessary, and the notation changed into something
    like Module.Class.Sub(). The modularity made the ecosystem grow so big that almost
    no one could have a complete overview of it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: This was inevitable, but the sheer size of these modern programming languages
    and their corresponding libraries, is now so large that the barrier of entry for
    newcomers is orders of magnitude bigger than it was in the 80s.
  prefs: []
  type: TYPE_NORMAL
