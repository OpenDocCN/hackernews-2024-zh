- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:00:23'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Currying - HaskellWiki
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://wiki.haskell.org/Currying](https://wiki.haskell.org/Currying)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Currying is the process of transforming a function that takes multiple arguments
    in a tuple as its argument, into a function that takes just a single argument
    and returns another function which accepts further arguments, one by one, that
    the original function would receive in the rest of that tuple.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: <haskell>[PRE0]
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: is the **curried** form of
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: <haskell>You can convert these two types in either directions with the Prelude
    functions <hask>`curry` and <hask>`uncurry`.</hask></hask>
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: <haskell>[PRE1]
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Both forms are equally expressive. It holds
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: <haskell>however the curried form is usually more convenient because it allows
    [partial application](/Partial_application "Partial application").
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: 'In Haskell, *all* functions are considered curried: That is, *all functions
    in Haskell take just one argument.* This is mostly hidden in notation, and so
    may not be apparent to a new Haskeller. It can be said that arrows in the types
    notation associate *to the right*, so that <hask>`f :: a -> b -> c` is really
    <hask>`f :: a -> (b -> c)`. Functional application, correspondingly, associates
    *to the left*: <hask>`f x y` is really <hask>`(f x) y`, so the types fit.</hask></hask></hask></hask>'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: As an illustration, let's take the function <haskell>[PRE2]
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: which performs integer division. The expression <hask>`div 11 2` unsurprisingly
    evaluates to <hask>`5`.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: But there's more going on here than immediately meets the untrained eye. It
    could be a two-part process.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: On its own, <hask>`div 11` is a function of type <hask>`Int -> Int`. Then that
    resulting function can be applied to the value <hask>`2`, so <hask>`(div 11) 2`
    yields <hask>`5`. Of course an optimizing compiler will probably handle that whole
    expression at once, but conceptually that's what's going on.</hask></hask></hask></hask></hask>
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that the notation for types reflects this: you can read <hask>`Int
    -> Int -> Int` incorrectly as "takes two <hask>`Int`s and returns an <hask>`Int`",
    but what it''s *really* saying is "takes an <hask>`Int` and returns something
    of the type <hask>`Int -> Int`" -- that is, it returns a function that takes an
    <hask>`Int` and returns an <hask>`Int`. (One can write the type as <hask>`Int
    x Int -> Int` if you really mean the former -- but since all functions in Haskell
    are curried, that''s not legal Haskell. Alternatively, using tuples, you can write
    <hask>`(Int, Int) -> Int`, but keep in mind that the tuple constructor <hask>`(,)`
    itself can be curried.)</hask></hask></hask></hask></hask></hask></hask></hask></hask></hask>'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Much of the time, currying can be ignored by the new programmer. The major
    advantage of considering all functions as curried is theoretical: formal proofs
    are easier when all functions are treated uniformly (one argument in, one result
    out). Having said that, there *are* Haskell idioms and techniques for which you
    need to understand currying.'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: See
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-split-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simplify <hask>`curry id`</hask>
  id: totrans-split-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify <hask>`uncurry const`</hask>
  id: totrans-split-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express <hask>`snd` using <hask>`curry` or <hask>`uncurry` and other basic Prelude
    functions and without lambdas</hask></hask></hask>
  id: totrans-split-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the function <hask>`\(x,y) -> (y,x)` without lambda and with only Prelude
    functions</hask></hask></hask></haskell></haskell></haskell></haskell></haskell>
  id: totrans-split-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
