- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:35:46'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Laws of Software Evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://two-wrongs.com/laws-of-software-evolution](https://two-wrongs.com/laws-of-software-evolution)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The software I encounter most is software that interacts with a changing world.
    It’s software that needs to adapt to other software, but critically, it needs
    to adapt to its users – to *people*! People change their attitudes and processes
    in response to the environment, and the software needs to adapt around that.¹
    This is ultimately a good thing. Imagine if we didn’t change how we build roads
    in response to new types of vehicles! Or didn’t change how we handle user data
    in response to security breaches. In almost any human behaviour change, there
    is a software system that will struggle to accept it, because software is not
    good at improvisation.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this, Lehman formulated some laws of software evolution.² *On understanding
    laws, evolution, and conservation in the large-program life cycle*; Lehman; Journal
    of Systems and Software; 1980. This was in 1974, before companies had started
    with the practises Andrew Kelley discusses, so the idea of software needing continuous
    maintenance may be older than exploiting finished software for more profit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the observations Lehman offers in his 1980 article directly contradict
    observations I’ve made myself, so I don’t propose a blind acceptance of all he
    says.³ I suggest reading his paper to evaluate the scientific basis more clearly
    for yourself. But the first two laws he summarises I carry close to my heart:'
  prefs: []
  type: TYPE_NORMAL
- en: Software exists to support a real-world task, and as the real world changes,
    the software must change with it or become increasingly less relevant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As software is changed, its complexity will increase, increasing the cost of
    further changes – unless effort is spent countering this effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I have found these laws to be useful guides through multiple problems I’ve encountered
    professionally. One example was when a team was stuck in a [reinforcing feedback
    loop of increasing difficulty of change](the-reinforcing-nature-of-toil.html),
    and the way out was to establish stricter quality controls on changes to turn
    the loop around.
  prefs: []
  type: TYPE_NORMAL
- en: Another case was when a product was discontinued but bug fixes were supported
    for existing customers of that product. There was a temptation to make fixes through
    ugly hacks to spend as little development time as possible on that product. As
    sensible as that sounds, in this case the customers would not be migrated off
    that product for several years. When problems are solved with quick hacks, the
    second law of software evolution is accelerated, and thus maintenance will cost
    more and more as time goes on. On a long time frame, such as in that case, the
    better choice is to spend more on fixes up front, to reduce the total cost. The
    cost savings of discontinuing the product should come from a reduced number of
    fixes (only fix critical bugs, not long-lived quirks), rather than reduced effort
    per bug fix.
  prefs: []
  type: TYPE_NORMAL
