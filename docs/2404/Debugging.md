<!--yml

category: 未分类

date: 2024-05-27 12:50:12

-->

# 调试

> 来源：[https://airs.com/ian/essays/debug/debug.html](https://airs.com/ian/essays/debug/debug.html)

|   |  **“我突然完全意识到，我余下的一大部分生命将会花在找自己程序中的错误上。”**  |
| --- | --- |
|   | *莫里斯·威尔克斯* |

上次更改时间：$Date: 2003/04/15 04:18:55 $。

一个实践中的程序员不可避免地会花费大量时间来追踪和修复 bug。调试，特别是调试别人的代码，是一种独立于首次编写程序的技能。然而，尽管调试经常被实践，但很少被教授。关于调试技术的典型课程仅仅包括阅读调试器手册。

这篇文章包含了我在作为一名职业程序员二十年间对调试的思考。这篇文章是针对那些已经具有一定编程经验的人群。

* * *

调试意味着从程序中消除 bug。bug 是程序产生的意外和不希望的行为。

偶尔会有一个程序需要遵循的正式规范，这种情况下 bug 就是未能遵循规范。更频繁地，程序规范是非正式的，这种情况下人们可能对某个程序行为是否真的是 bug 存有分歧。

作为编写程序的人之一，你应该是 bug 报告的来源。不要仅仅依赖测试人员或用户。如果在运行程序时注意到一些奇怪的现象，很容易忽视它并希望它会消失。尤其是在此时正在处理其他事情时。抵制诱惑。记录下 bug。如果有数据文件或日志，请保存它们。如果以后有时间，回到这个问题；否则，将其传递给其他人。作为了解程序应如何工作的人之一，你处于检测意外行为的最佳位置。

一旦有了 bug 报告，消除 bug 的第一步是找出它。这在处理由其他人生成的 bug 报告时尤为重要，比如测试团队或用户提供的。有些 bug 相对明显，比如程序意外崩溃。其他一些 bug 则较隐晦，比如程序生成略微不正确的输出。

很多用户反馈的 bug 报告形式是：“我做了某事，然后出了问题。” 在做任何其他事情之前，你必须找出问题出在哪里——也就是说，你必须通过确定意外和不希望的程序行为来识别 bug。在理解问题出在哪里之前尝试修复 bug 通常是浪费时间。

通常，确定用户报告的 bug 需要回答两个问题：“程序做了什么？”和“你希望程序做什么？”目标是确定程序的行为精确地是意外和不希望的。

一旦确定了 bug，最简单最快速的修复方法是确定它根本不是 bug。如果程序有正式的规范，可能需要修改规范。在其他情况下，可能需要修改用户的期望。这种快速修复通常被称为声明行为为“未记录的特性”。尽管有滥用的明显潜力，但有时这确实是处理问题的正确方式。

不幸的是，大多数 bug 是真正的 bug，并需要进一步的工作。

* * *

修复 bug 的第一步是复制它。这意味着在受控条件下重新创建不良行为。目标是找到一组精确指定的步骤来演示 bug。

在许多情况下，这很简单。您在特定输入上运行程序，或者在特定对话框上按下特定按钮，bug 就会发生。在其他情况下，复制可能非常困难。可能需要一系列冗长的步骤，或者在像游戏这样的交互式程序中，可能需要精确的时间控制。在最坏的情况下，复制可能几乎不可能。

* * *

程序员有时候会想要跳过复制步骤，直接从 bug 报告到修复。然而，未能复制 bug 意味着无法验证修复结果。修复可能会变成针对另一个 bug，或者根本没有显著影响。如果 bug 没有被复制，就无法确定。

未能复制 bug 是一个真正的问题，我已经看到这种情况发生了很多次。在复杂的程序中，往往很容易找到要修复的东西--也许是一个真正的问题，也许只是看起来像一个问题。人类倾向于假设任何特定的修复解决了手头的问题。没有验证手段，任何看似合理的修复都将被接受，无论它是正确还是错误的。不正确的修复会导致未来问题。总体而言，跳过复制步骤比节省的时间更多地浪费时间。

* * *

通过完全控制的系统上复制 bug 是迄今为止最好的方法，使用您自己构建的程序副本。在您自己的系统上复制 bug 意味着您可以轻松测试程序的修补版本。不幸的是，在某些情况下这是不可能的。

在您的系统上无法复制问题的一个原因可能是报告 Bug 的用户可能有独特的系统配置，或者用户可能在使用您无法获取的私有输入文件。在这些情况下，您必须努力确保用户能可靠地复制 Bug，并且用户可以测试已修补的程序。如果没有用户的帮助，调试基本上就只能靠猜测。通常不值得继续。如果这不是一个选择，那么您至少应该尝试为任何可能的补丁构建某种测试案例，以确认即使您无法验证其是否修复了原始 Bug，该补丁确实会起作用。

更常见的问题是，用户可以演示 Bug，但您无法在自己的系统上复制它，也不知道原因。解决这个问题没有确定的方法，但有一些可以考虑的可能性。

+   用户可能只是错误地报告了问题，或者复制问题的方式不正确。再检查一遍。确认用户实际输入了什么以及用户实际点击了哪里。确认用户在屏幕上看到了什么。尽量不要假设程序的运行方式——用户可能在做某些非常特殊的事情，你从未考虑过。

+   一些程序在不寻常的条件下会表现出奇怪的行为。检查用户的系统是否磁盘空间非常低，或者网络连接状况不佳，或者负载非常重。检查是否有其他程序意外失败——硬件问题很少见，但确实会发生。检查系统日志中是否有消息。

+   检查用户运行的软件版本。检查操作系统版本以及任何系统库的版本。检查已应用的系统补丁。检查确切的系统类型、显示器类型、键盘类型等。

在某些情况下，Bug 可能很少发生，看起来是随机的，因此非常难以确定触发它的条件以及如何复制它。在这种令人沮丧的情况下，我只知道一种可靠的方法，那就是自动记录所有可能相关的事件，并在 Bug 发生时保存日志。在某些情况下，能够使用日志重新运行程序非常有用，这可以是复制 Bug 的有效机制。当然，这需要有一个日志记录设施，并且向大型程序添加一个日志记录设施可能是一个很大的工作。尽管如此，当您发现自己第二次在搜索似乎随机发生的 Bug 时，这可能是值得做的。

* * *

一旦您能够复制 Bug，您必须弄清楚是什么原因引起了它。这通常是最耗时的步骤。

* * *

作为一名实践程序员，你可能熟悉一个称为调试器的工具。这个工具的名称让人觉得它是调试的首选工具--似乎逻辑上讲，要调试就要用调试器。然而，这是不准确的。正如我最初所说，调试意味着从程序中移除错误；虽然调试器是一个强大的工具，但它无法去除错误。这个工具的一个更好的名称应该是“检查器”。（由于现在改名为工具已经太晚，我将继续称其为调试器。）

为了修复错误，你必须理解它。调试器有时可以帮助你理解错误，但它只是用于此目的的几个工具之一。只有在特定情况下，它才应该是你首选的工具之一。

* * *

为了理解程序中的错误，你必须对程序有一些了解。

如果你编写了程序，那么你可能已经理解了它。如果没有，那么你就有了更严重的问题。[[1]](#FTN.AEN75)

如果你没有编写该程序，你需要掌握其一般结构。大多数程序在你了解一般方法后，组织得相当合理。如果你幸运的话，一般方法是有文档记录的，或者你可以询问原始设计者。

更普遍地说，你需要从源代码中提取结构。最好的方法是从程序的开始处开始查看源代码（例如，在C程序中的`main`函数）。快速浏览程序，逐步进入函数，直到找到主要的行动中心--在大多数程序中，通常是某种循环。这通常可以很快完成。这个行动中心的性质应该告诉你在源代码中查找特定活动的位置。它还应该告诉你程序的一般行为方式。

最糟糕的情况是多年来由许多不同人编写的大型程序。这些通常变成了各种不同想法的混杂，缺乏一致性。这种情况令人沮丧地普遍存在。你只能尽力而为。至少要尽量避免让混乱变得更糟。

在检查大型程序时，有些人发现使用源代码分析工具（例如[Source Navigator](https://sourcenav.sourceforge.net/)）很有帮助。就我个人而言，我通常简单依赖Emacs的标签表。

调试器在试图理解程序时也可能很有帮助。通过在调试器下运行程序并设置断点，你可以看到程序的动态行为。当你到达一个断点时，查看调用堆栈以了解你是如何到达那里的，并查看关键变量。或者如果你没有达到预期的断点，那么你也学到了一些东西。

* * *

接下来的步骤是定位程序源代码中的错误。

有两个源代码位置你需要考虑：引起可见错误行为的代码，以及实际上有问题的代码。这些代码通常是相同的一部分是很常见的。然而，这些代码也往往在程序的不同部分。一个典型的例子是，程序的某一部分中的错误导致内存损坏，从而在程序的完全不同部分导致可见的糟糕行为。不要让你修复 bug 的急切心情误导你以为直接导致不良行为的代码实际上是错误的。

通常你必须首先找到导致不正确行为的代码。了解不正确的行为，并知道源代码的排列方式，通常会迅速帮助你找到有问题的程序部分。有时，简单扫描源代码就足以识别有问题的代码。

否则，将不良行为缩小到特定代码片段的过程是调试器非常有用的地方。如果你有幸有一个核心转储，调试器可以立即识别失败的行。否则，在复制 bug 时审慎设置断点可以快速锁定你需要的代码。

现代调试器，如 gdb，具有强大的功能，使这一过程更加可管理，如条件断点、数据监视点、忽略特定次数的断点和支持在断点处执行简单代码等。这些功能在定位执行多次但只在特定情况下失败的代码中的不良行为时非常有用。了解你的调试器提供的这些功能是个好主意。

当然，有时候调试器也无法帮助。在某些情况下，即使程序在调试器下运行时不会出现 bug，但在没有调试器的情况下可以可靠地重现；这通常表明问题取决于精确的时间或内存布局。在其他情况下，你可能无法访问调试器，或者调试器可能不够强大；这在嵌入式系统或其他资源匮乏的编程环境中常见，或者在使用调试器不支持的编程特性（例如在某些环境中使用线程）时可能会发生。

在这种情况下，简单的打印语句有时可以帮助定位不良行为的来源。在相关位置添加打印语句，重新构建程序，使用新程序复制问题，并使用打印语句精确查找问题发生时执行的代码。理想情况下，程序已经具有某种日志记录设施，您可以重复使用。即使没有，您也应考虑系统化地添加打印语句，以便在将来调试相同程序时建立在此基础上。特别是，每个打印语句都应清楚地指示其在程序中的位置，以便以后可以快速找到。

另一种有用的方法是将检查例程添加到代码中，以验证数据结构是否处于有效状态。这些例程可以帮助缩小数据损坏发生的位置。如果检查例程运行速度很快，您可能希望始终启用它们。否则，保留它们在代码中，并提供某种机制，在需要时打开它们。

在特定的内存损坏 bug 情况下，您可以使用执行各种检查的替代标准内存分配例程。例如，在 GNU/Linux 系统上，阅读 `malloc` 文档，了解如何使用环境变量 `MALLOC_CHECK_` 来执行此操作。

定位不良行为来源的最后退路是简单的源代码检查。如果无法复制问题，这是唯一的选择。对整体程序源代码的清晰理解绝对是使其正常工作的要求。不幸的是，仅通过阅读源代码几乎不可能隔离复杂的问题。您将不得不猜测可能的可能性，并仔细跟踪代码，看看它们是否真的有问题。

如果您非常不幸，bug 可能根本不在程序源代码中。它可能在库例程中、操作系统中或编译器中。这些情况很少见，而且怀疑编译器 bug 过早是一个经验不足的程序员的标志。但是，它们确实发生过--我自己经历过--所以当所有其他方法都失败时，请考虑这些可能性。通过编写检查程序验证库例程或操作系统中的 bug，并通过直接检查机器代码来验证编译器中的 bug。

* * *

现在，您已经找到了导致不良行为的代码，您需要确定实际的编码错误。通常它们是同一段代码--也就是说，编码错误直接导致不良行为。但是，您应始终考虑实际错误可能在其他地方的可能性。

例如，导致不良行为的例程可能会表现正确，但是在输入错误或错误的时间调用。其他地方的编码错误可能导致数据结构持有不合理的值。另一种可能性是错误的用户输入。

在这种情况下的修复可能是双重的。当然，你应该修复调用例程错误或以其他方式创建错误输入数据的代码。对于不良用户输入，你应该验证输入。但是，此外，你可能还希望向使用这些值的代码添加检查。它应该检查不合理的输入，并报告错误或以其他方式处理错误，而不会导致无效的行为。

* * *

调试过程的最后一步当然是修复错误。我不会详细讨论这一步，因为修复错误意味着您离开调试阶段并回到编程。我只是提一下几点。

如果您希望程序在将来可以维护，那么确保以正确的方式修复错误非常重要。这意味着要进行一个符合程序其余部分的修复，并且要修复问题的所有方面，而不引入任何新问题。不要忘记更新所有相关文档。

在某些情况下，您可能需要快速修补以解决一个即时问题。这没有问题，只要您事后花时间回头正确修复它。

显然，始终要测试你所做的任何修复，以确保无法再现错误行为。不要忘记确保程序继续通过其测试套件。考虑扩展测试套件以检测你刚刚修复的情况，确保它不会再次出现。

* * *

修复错误后，请考虑是否可以从中学到些什么。以下是一些需要考虑的事项：

+   这种编程错误是否在程序的其他地方也发生？

+   修复错误可能会引入什么新问题？

+   这个错误本可以如何预防？你可以做些什么不同的事情，以避免首次创建这个错误？即使是一些优秀的程序员也会反复地犯一些特定的错误；是否有些编程类型需要特别小心？

+   如果你自己没有找到这个错误，它是否可以更早地被检测到？你的测试程序需要改进吗？如果还没有这样做，你能否自动化测试？是否可能使用自动化代码检查工具来找到这个错误？

* * *

本文采纳了Jonathan Mark的建议。

* * *
