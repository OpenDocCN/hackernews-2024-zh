- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:08:13'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: ULIDs and Primary Keys | Dave Allie
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.daveallie.com/ulid-primary-keys](https://blog.daveallie.com/ulid-primary-keys)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When it comes to picking the type for your database's primary keys, there are
    a few divided camps. When making this decision for [Visibuild](https://www.linkedin.com/company/visibuild-pty-ltd/)
    I had to choose between the simplicity of sequential IDs and the longevity/future
    benefits of non-sequential IDs. I chose non-sequential IDs to make it easier to
    deal with sharding and regional databases in the future. Out of the many flavours
    of non-sequential IDs I chose ULIDs.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Here's how I got there.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: Let's start where most people do, with UUIDs.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: UUIDs (universally unique identifiers) are 128-bit labels typically represented
    as a hexadecimal string broken up into 5 sections containing 32 bits, 16 bits,
    16 bits, 16 bits, and 48 bits respectively.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Within the UUID standard (which you can read about in [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)),
    there are 5 different versions of that same 128-bit label. The differences between
    the versions are which inputs are required to generate the UUID and the structure
    of the bits that are output.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Version 1 requires knowledge of the computer's MAC address to generate the label.
    Version 2 is only guaranteed to be unique if at most one is generated per computer
    about every 7 minutes. Versions 3 and 5, are deterministic based on the supplied
    input. This leaves only version 4 as a suitable choice for scalable, non-deterministic
    UUIDs.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: When people say UUID they're almost always referring to UUIDv4\. It's the most
    prevalent and widely supported UUID standard, even the example UUID given above
    is a UUIDv4\. As UUIDv4 is based solely on randomness, it is extremely portable
    and can be used with very little prior knowledge about the state of the system.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: UUIDv4 are composed of **122** bits of randomness, and **6** bits of version/variant
    identification.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: info_outline
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: Click the "Regenerate" button to see a few different UUIDv4.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: The only non-random sections of a UUDv4 are the version and variant. The version
    is represented by 4 bits and is always set to 4 for UUIDv4, you can see it highlighted
    as the first orange nibble above. The variant is represented by 2 bits and is
    set to 2 for the UUIDv4 standard, you can see it highlighted as the second orange
    nibble above.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: info_outline
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: The variant is only the first 2 bits of the second highlighted nibble. While
    the remaining 2 are random, meaning the value of that nibble can be 8 (
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: '`1000`'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: ), 9 (
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '`1001`'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: ), a (
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: '`1010`'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: ), or b (
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: '`1011`'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: '). While there are only 5 UUID variants in the RFC, there''s [a draft](https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format)
    that includes 3 new ones: UUIDv6, UUIDv7, and UUIDv8.'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: The three new versions are all based on a similar structure of a combination
    of time bits in the most significant positions, followed by random bits. The difference
    between the three is which kind of clock is used to generate the time bits. Version
    7 from the draft is using Unix Epoch time, making it the likely candidate for
    adoption in the future.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: Even within version 7, there are a few different ways to represent the time.
    Different levels of sub-second precision can be used, but the more precise in
    time you get, the fewer random bits you'll be able to use. Let's take a look at
    the millisecond precision setup of UUIDv7.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: With the millisecond precision setup, there are **48** bits of time, **6** bits
    of version/variant, **12** bits for a monotonic sequence, and **62** bits of randomness.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: UUIDv7 always dedicates the first 36 bits to the seconds of the timestamp, and
    then a variable amount of bits for the sub-second precision, in our case that's
    12 bits for the milliseconds within the second.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: info_outline
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: If you click "Regenerate" a few times, you should see the first 9 characters
    of the timestamp only change once a second, these are the bits representing the
    Unix Epoch time in seconds. The last three bits are the milliseconds within that
    second.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: The version and variant follow the same setup as UUIDv4, however the version
    is set to 7.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: The main value for the timestamp at the front of the UUID is that UUIDv7s (and
    the other new UUIDs in the draft) are monotonically increasing (within the same
    sub-second), meaning that a UUIDv7 generated now is always going to be larger
    than a UUIDv7 generated a millisecond ago.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: You'll also notice a new kind of section in UUIDv7, the "monotonic sequence"
    section. This section of 12 bits is designed to ensure that the UUIDs generated
    within the same sub-second are also monotonically increasing. In our case, for
    each subsequent UUIDv7 generated within the same millisecond, the monotonic sequence
    counter will increase by one. Note that this is only relevant for UUIDs generated
    on the same machine within the same millisecond, it will not ensure any ordering
    of UUIDs if they're generated independently of each other in the same millisecond.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example UUIDs generated in the same millisecond:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: '*   `061ff8d8-e24b-7000-8092-ca1e5440d491`'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: '`061ff8d8-e24b-7001-b653-1c41e471cd78`'
  id: totrans-split-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`061ff8d8-e24b-7002-9bc2-82b5da559f1d`'
  id: totrans-split-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using UUIDv7 as a primary key, you get the same sortability as a sequential
    ID with the flexibility of distributed generation. If you're looking to do a performant
    sort on creation time using UUIDv4, you'd need a separate indexed creation time
    column, but if you're using UUIDv7 then you can use the primary key as the sort
    column (since it's already indexed).
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: In late 2017, almost 4 years before the UUIDv7 specification was drafted, the
    Universally Unique Lexicographically Sortable Identifier (or ULID) was proposed,
    not as an RFC Draft, but as a grassroots proposal over GitHub. You can take a
    read of the (quite concise) [specification for ULID](https://github.com/ulid/spec)
    on GitHub.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: A ULID is a 128-bit label, just like a UUID. It's sortable, has millisecond
    precision, and is monotonically increasing, just like UUIDv7.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: ULIDs are typically represented as a [Crockford's Base 32](http://www.crockford.com/base32.html)
    encoded string, instead of a hexadecimal string like UUIDs. As an example, instead
    of `017eb31e-1440-b69e-d82f-5f0937f823c8`, the same value can be represented as
    `0GWWXY2G84DFMRVWQNJ1SRYCMC`.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of comparison with UUIDs, I'm going to represent all ULIDs as
    hexadecimal strings, in the same 8, 4, 4, 4, 12 segments which we have been using.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: Within a ULID, there are **48** bits of time and **80** bits of randomness.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: While there are 48 bits of time information in both UUIDv7 (with millisecond
    precision) and ULID, the ULID standard encodes the time as Unix Epoch in milliseconds
    for the whole 48 bits whereas UUIDv7 splits the time into 36 seconds bits and
    12 millisecond bits.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: ULIDs also remove the bits pertaining to the version and variant, giving us
    6 extra bits to play with but removing all indication that ULIDs are in fact ULIDs.
    Because UUIDs encode version and variant information inside the label, they can
    be reliably decoded into their composite parts (e.g. timestamp and randomness).
    If you wanted to extract the timestamp from a ULID, the client would need to know
    that the string being processed is a ULID, and not an invalid (or potentially
    valid looking) UUID.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: ULIDs are monotonically increasing, but there is no defined monotonic counter
    like in UUIDv7\. Instead, ULIDs generated in the same millisecond on the same
    machine will have sequential randomness sections.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example ULIDs generated in the same millisecond:'
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: '*   `017ece40-2a1e-63ac-a58d-e336f30c1d76`'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: '`017ece40-2a1e-63ac-a58d-e336f30c1d77`'
  id: totrans-split-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`017ece40-2a1e-63ac-a58d-e336f30c1d78`'
  id: totrans-split-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ULIDs are a great alternative to UUIDv7s. They contain more randomness and a
    straightforward structure at the cost of not explicitly exposing the version,
    variant, or monotonic counter. UUIDs are also the perfect choice if you're writing
    some apocalypse-scenario software (assuming you have a working computer) as they
    can continue to be generated until 10,889AD compared to UUIDv7s measly 4,147AD
    death date.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The main differences between UUIDv7 and ULID are:'
  id: totrans-split-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*   UUIDv7'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: UUIDv7 will work until 4,147AD whereas ULID will work until 10,889AD
  id: totrans-split-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Format | Sortable | Monotonic | Randomness |'
  id: totrans-split-58
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-split-59
  prefs: []
  type: TYPE_TB
- en: '| UUIDv4 | No | No | 122 bits |'
  id: totrans-split-60
  prefs: []
  type: TYPE_TB
- en: '| UUIDv7 | Yes | Yes | 62 bits |'
  id: totrans-split-61
  prefs: []
  type: TYPE_TB
- en: '| ULID | Yes | Yes | 80 bits* |'
  id: totrans-split-62
  prefs: []
  type: TYPE_TB
- en: '* - Random bits are incremented sequentially within the same millisecond.'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: Implementing UUIDs/ULIDs in PostgreSQL
  id: totrans-split-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: info_outline
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: This section is tailored to PostgreSQL, if you're using a different database
    engine then you'll need to look elsewhere to understand how to implement these
    kinds of primary keys.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: While all of these formats can be generated by the client before inserting them
    into the database, for the purpose of simplicity and consistency, having them
    be generated within the database engine is preferred.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, PostgreSQL includes a [`uuid` data type](https://www.postgresql.org/docs/14/datatype-uuid.html)
    which accepts a case insensitive 128-bit hexadecimal string, parses it into binary
    data and stores it as 16 bytes of data. This is drastically better than storing
    the value as a string in the database, which would take up 37 bytes of space including
    the dashes, or 33 bytes of space with the dashes stripped out.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some implementation details for populating those `uuid` columns and
    setting up tables with UUID/ULID primary keys:'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL has built in support for UUIDv4 through the `pgcrypto` or the `uuid-ossp`
    extensions.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-71
  prefs: []
  type: TYPE_PRE
- en: CREATE EXTENSION IF NOT EXISTS pgcrypto;
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: SELECT gen_random_uuid(); --> f449a5bc-a221-4e9d-8819-e7f22b83d8ae
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
- en: 'This makes it extremely easy to setup a table with a UUIDv4 primary key:'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-76
  prefs: []
  type: TYPE_PRE
- en: CREATE  TABLE my_uuidv4_things(  id  UUID  NOT  NULL  DEFAULT gen_random_uuid(),  name  TEXT  NOT  NULL,
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: PRIMARY KEY (id) );
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: INSERT  INTO my_uuidv4_things(name) VALUES ('foo');
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM my_uuidv4_things; --                  id                  | name  ----------------------------------------+------  --
    8501364b-b669-4c17-bd98-00bad8cd8f7d | foo
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-81
  prefs: []
  type: TYPE_PRE
- en: There don't seem to be any existing built-in or extension functions that support
    generating UUIDv7s in PostgreSQL. To generate a UUIDv7, the function below could
    be tweaked in order to support the correct formatting.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different implementations of ULIDs in [Go](https://github.com/iCyberon/pg_ulid),
    or in [plsql](https://github.com/geckoboard/pgulid). However, both of these implementations
    return the Crockford Base 32 text representation of ULID (taking up 26 bytes),
    instead of as a UUID datatype (taking up 16 bytes). Due to the natural multiplexing
    nature of PostgreSQL (and relational databases in general), having a consistent,
    shared monotonic counter is difficult, if not impossible. The [Go library](https://github.com/oklog/ulid)
    used by the Go PostgreSQL implementation includes an implementation of the monotonic
    counter, however, it's not used by the Go PostgreSQL extension. The plsql implementation
    doesn't have a monotonic counter at all.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: 'I wanted a simple ULID PostgreSQL implementation without the complexity of
    the monotonic counter that generated a UUID data typed value. So I wrote one:'
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-85
  prefs: []
  type: TYPE_PRE
- en: CREATE  EXTENSION  IF  NOT  EXISTS pgcrypto;
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
- en: CREATE  OR REPLACE  FUNCTION generate_ulid() RETURNS  uuid   AS $$   SELECT
    (lpad(to_hex(floor(extract(epoch  FROM clock_timestamp()) * 1000)::bigint), 12,
    '0') || encode(gen_random_bytes(10), 'hex'))::uuid;
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
- en: $$  LANGUAGE  SQL;
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: SELECT generate_ulid(); --> 017eb31e-1440-b69e-d82f-5f0937f823c8
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-90
  prefs: []
  type: TYPE_PRE
- en: 'Breaking down the function:'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: '*   The first half `lpad(to_hex(floor(extract(epoch FROM clock_timestamp())
    * 1000)::bigint), 12, ''0'')` gets the milliseconds since the Unix Epoch, and
    converts it to a hexadecimal string of length 12 (it''ll have a leading 0 for
    the next 500 years or so).'
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
- en: The second half `encode(gen_random_bytes(10), 'hex')` generates 10 random bytes
    and converts them to hexadecimal.
  id: totrans-split-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together these make the 16-byte (or 128-bit) ULID label, which is finally cast
    to a UUID data type with `::uuid`.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new function can now be used as a default value for a primary key:'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-96
  prefs: []
  type: TYPE_PRE
- en: CREATE  TABLE my_ulid_things(  id  UUID  NOT  NULL  DEFAULT generate_ulid(),  name  TEXT  NOT  NULL,
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
- en: PRIMARY KEY (id) );
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
- en: INSERT  INTO my_ulid_things(name) VALUES ('foo');
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM my_ulid_things; --                  id                  | name  ----------------------------------------+------  --
    017eb31e-1440-b69e-d82f-5f0937f823c8 | foo
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-101
  prefs: []
  type: TYPE_PRE
- en: When compared to the native implementation of `gen_random_uuid()`, `generate_ulid()`
    performs **73% slower** when **generating** 10 million values, but only **31%
    slower** when **generating and inserting** 1 million values.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
- en: Meaning that while ULIDs are slower to generate (at least with this implementation),
    they are much faster to insert. My guess is that due to the sequential and highly
    clustered significant bytes of the ULIDs, they are much faster to create the index
    entries for. Meanwhile, the UUIDv4s are extremely sparse, so they are much slower
    to create the index entries for.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how I got these numbers:'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-105
  prefs: []
  type: TYPE_PRE
- en: generate-benchmark.sql
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-107
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  id: totrans-split-108
  prefs: []
  type: TYPE_PRE
- en: generate-insert-benchmark.sql
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-110
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  id: totrans-split-111
  prefs: []
  type: TYPE_PRE
