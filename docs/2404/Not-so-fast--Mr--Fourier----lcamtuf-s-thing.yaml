- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:48:44'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Not so fast, Mr. Fourier! - lcamtuf‚Äôs thing
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://lcamtuf.substack.com/p/not-so-fast-mr-fourier](https://lcamtuf.substack.com/p/not-so-fast-mr-fourier)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The discrete Fourier transform (DFT) is one of the most important algorithms
    in modern computing: it plays a key role in communications, image and audio processing,
    machine learning, data compression, and much more. Curiously, it‚Äôs also among
    the worst explained topics in computer science. For example, the Wikipedia article
    on the matter assaults the reader with around three dozen cryptic formulas, but
    offers no accessible explanation how or why the algorithm works.'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: 'My goal today is to change this. Let‚Äôs start with the basics: DFT takes a time-domain
    waveform ‚Äî for example, an audio track ‚Äî and turns it into frequency-domain data:
    a series of sine wave intensities that describe the underlying signal. If summed
    back together, these sine waves of different frequencies, phases, and magnitudes
    should faithfully recreate the original waveform.'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the utility of DFT, let‚Äôs have a look at a conventional waveform
    representation of a [üîà police siren](https://lcamtuf.coredump.cx/police.mp3) next
    to its frequency-domain treatment. On both plots, the horizontal axis represents
    time. In the bottom image, the vertical axis represents frequency and pixel color
    represents intensity. The top view tells us very little about the recording; in
    the bottom plot, the shifting pitch of the siren is easy to see, at its base frequency
    and [a number of harmonics](https://lcamtuf.substack.com/p/square-waves-or-non-elephant-biology):'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: '*Police siren: time-domain versus frequency-domain*'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, the bottom plot ‚Äî known as a spectrogram ‚Äî is not the result
    of a single DFT operation; the transform doesn't show us how frequencies change
    over time. Instead, the spectrogram is created by dividing the audio into a number
    of short time slices and calculating a separate frequency-domain representation
    for each, each making up a column in the plot. This is sometimes referred to as
    a *short-time Fourier transform* (STFT); that said, this divergent terminology
    is of no real consequence, as the underlying math is the same.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Either way, the frequency-domain representation of signals allows us to perform
    a variety of interesting tricks. For example, when it comes to music, we can easily
    isolate specific instruments, remove unwanted AC hum, or pitch-shift the vocals.
    With the edits done, we can then convert the data back to to the time-domain waveform.
    Indeed, the infamous Auto-Tune pitch corrector, employed by some pop singers to
    cover up the lack of skill, is one of many applications of DFT.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: 'To get it out of the way, let‚Äôs start with the official formula ‚Äî which to
    a layperson, is rather opaque:'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: \(F_k = \sum\limits_{n=0}^{N-1} s_n \cdot e^{-i 2 \pi k\frac{n}{N} }\)
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: In this equation, *F[k]*is the DFT value (‚Äúcoefficient‚Äù) for a particular frequency
    bin *k.* Bin numbers are integers corresponding to fractions of the input sample
    rate. Moving on, *s[0]*to *s[N-1]* are the time-domain samples that make up the
    DFT input window; and the rest is‚Ä¶ some voodoo?
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: To make sense of the voodoo, let‚Äôs conduct a simple thought experiment. Imagine
    a mechanical arm rotating at a constant angular speed. The arm is holding a pen
    that makes contact with a piece of drawing paper. The pen moves up and down the
    length of the arm in response to an input waveform.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs assume that the arm is completing one rotation per second, and that the
    input signal is a sine wave running three times as fast (3 Hz). In this setting,
    the pen will end up drawing a neatly centered, three-lobed shape with every single
    turn:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: '*A polar plot of a 3 Hz signal at an angular speed of 1 turn per second.*'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer, you can watch an animated version below:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: 'In some circumstances ‚Äî for example if the signal has a frequency lower than
    the rotation of the arm ‚Äî it might take multiple revolutions to produce a closed
    shape. Still, the result should be similar; for example, here‚Äôs a pretty nine-lobed
    figure drawn for a signal at 0.9 Hz:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: '*A polar plot of 0.9 Hz at 1 turn per second (multiple turns).*'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, you can watch an animation below:'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: 'This radial symmetry crops up every time except for one special case: when
    the speed of the rotating arm matches the period of the sine waveform. In this
    scenario, the peaks of the waveform always end up on one side of the plot, and
    the valleys stay on the other side:'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: '*1 Hz signal @ 1 turn / sec.*'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: The shape may end up being rotated depending on the phase of the input waveform,
    but one side is always sticking out.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Wondrously, this also works for composite signals consisting of superimposed
    sine waves. For example, if we take a 1 + 5 Hz signal, it will be off-center when
    plotted by an arm rotating at 1 Hz or 5 Hz ‚Äî but will appear centered at 2 Hz:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: '*Deconstructing composite signals.*'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we have a fairly ingenious *frequency detector:* we set the
    speed of the rotating arm, plot the samples ‚Äî and if the results are not distributed
    evenly around (0,0), we know that there is a matching sine frequency component
    present in the input signal. We can even quantify the component‚Äôs magnitude by
    measuring the deviation of the shape from the center of rotation.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: The discrete Fourier transform boils down to this exact operation. It takes
    a sequence of *N* values in the input window and distributes them radially in
    two dimensions at a given speed, completing *k* rotations. It then sums the resulting
    coordinates (the ‚àë part). The distance from the center of rotation to the computed
    midpoint is the magnitude of the calculated frequency component; the angle of
    the vector is the (sometimes disregarded) phase of the waveform. Note that some
    online sources, including a wildly-popular YouTube video, mistakenly state that
    the *x* axis component is the magnitude; this is incorrect.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: 'This algorithm can be implemented with polar coordinates ‚Äî angle and distance
    ‚Äî mimicking what we did above. It can be done with Cartesian *x,y* coordinate
    pairs and simple trigonometry. The definition quoted at the beginning of this
    section does it in the most obtuse way possible ‚Äî with a wacky device known as
    [Euler‚Äôs formula](https://en.wikipedia.org/wiki/Euler%27s_formula) ‚Äî but all the
    methods are equivalent. The *e^(-i2)*^œÄ*^(kn/N)* part is simply an apparatus for
    spinning things around in the complex plane by exploiting this surprising equality:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: \(e^{it} = cos \ t + i \cdot sin \ t\)
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: 'If you‚Äôre unfamiliar with complex numbers, the *i* part (*i = ‚àö-1*) is essentially
    a math trick to keep two values at an arm‚Äôs length in a single equation. To avoid
    it, the DFT formula can be rewritten using a pair of separate Cartesian coordinates
    ‚Äî (*x, y*):'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: \(F_k =\Biggl ( { \sum\limits_{n=0}^{N-1} s_n \cdot cos ( 2 \pi k \frac{n}{N}
    )}, \ - { \sum\limits_{n=0}^{N-1} s_n \cdot sin( 2 \pi k \frac{n}{N} )} \Biggl
    )\)
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: 'This notation should be much easier to parse: the *2œÄ* part is equal to 360¬∞
    expressed in radians; *k* is the number of turns we want to use to distribute
    the samples; and *n/N* determines the position of each sample within these *k*
    turns. Meanwhile, *x = cos(t)* and *y = sin(t)* are just a recipe to draw a circle.'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: 'A rudimentary implementation of DFT is straightforward; for example, in C,
    all you need is the following code:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-35
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: The code accepts and outputs complex numbers; for real number inputs, *in_buf*
    can be changed to *double**. To convert the resulting complex coefficients in
    *out_buf* to magnitude, call *cabs().* To get phase information (in radians),
    use *carg().*
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs start with the maximum frequency range. If the input data consists of
    real numbers, the DFT will produce useful output only up to the so-called Nyquist
    frequency ‚Äî that is, one half of the sample rate. This frequency component can
    be found in the bin at *k = N/2*. The coefficients above that can and sometimes
    need to be computed ‚Äî but perhaps a bit surprisingly, they just contain mirrored
    data from the lower-frequency bins.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why this is happening, consider the following animation of our
    rotating arm. In the video, the arm is spinning so fast in relation to the input
    sample rate that successive samples are placed more than 180¬∞ apart. In fact,
    the angular distance is 330¬∞, suggesting that we‚Äôre running the DFT at ~92% of
    the input sample rate:'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: After watching the clip, it should become clear that the end result is identical
    to what would be produced by a much slower arm spinning in the opposite direction.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The coefficient mirroring behavior is an artifact of the DFT algorithm, but
    the curse of the Nyquist frequency itself is not. It‚Äôs a fundamental bandwidth
    limitation for signal sampling techniques: above it, there‚Äôs simply not enough
    samples available to faithfully discern the frequency. The Nyquist limit is the
    reason why music is commonly recorded at ~44 kHz, even though our hearing only
    goes up to about 20 kHz (and only on a good day).'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: The other limitation of DFT has to do with frequency separation. A discrete
    Fourier transform that could use an infinitely-long sample window would have perfect
    selectivity ‚Äî that is, it would be able to precisely discern chosen frequencies
    while rejecting everything else. In practice, DFT is run on finite sample windows,
    causing each bin to pick up something extra.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the cause, let‚Äôs assume we‚Äôre doing DFT with bins spaced three
    hertz apart ‚Äî i.e., *F[0]* is the DC component, *F[1]* is 3 Hz, and *F[2]* is
    6 Hz. The *F[1]* bin is always calculated by completing a single turn (the timing
    expression is *k √ó 2œÄ* and *k = 1).* But with an input signal frequency of 2 Hz,
    we‚Äôd need three turns to form a closed shape. Instead, we run out of time ‚Äî and
    out of input samples ‚Äî by the time we‚Äôve drawn only one off-center lobe:'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: '*The limitations of DFT: a nearby frequency creeping into the F[1] bin.*'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, the plot ends up badly off-center only if the two frequencies
    are quite close to each other. To illustrate, here‚Äôs an animation for our 3 Hz
    *F[1]* bin across a range of input signals. Watch the computed blue dot that tracks
    the ‚Äúcenter of mass‚Äù of the shape ‚Äî and thus mirrors the resulting DFT coefficient:'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, the bias is significant only within roughly +/- 75% of bin
    step size. At lower frequencies, the partial shape is pretty close to a circle;
    at higher signal rates, it has enough symmetrical lobes that the missing part
    doesn‚Äôt upset the balance much.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: 'We can measure this more rigorously. The following plot shows the average frequency
    response across all possible signal phases for a couple of 1 Hz-spaced bins:'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: '*Real-world DFT bin frequency response.*'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: The overlaps mean that the standard set of DFT bins ends up accounting for the
    entire spectrum between DC and Nyquist. Nothing stops us from calculating ad-hoc
    DFT coefficients for any non-integer *k* in between, but these ‚Äúpartial-turn‚Äù
    bins don‚Äôt extract any new, finer-grained information from the system. If you
    need better frequency discrimination, you gotta up the window size.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to temporal resolution. A single DFT operation outputs frequency
    coefficients for the entire input waveform ‚Äî and nothing else. Within the time
    span it covers, we can no longer easily pinpoint when a particular tone start
    or ends, or whether its intensity is going up or down. Indeed, sharp signal discontinuities
    within the waveform produce wide-spectrum ‚Äúhalos‚Äù that are hard to interpret as
    any specific frequency. The more localized is the time-domain signal, the more
    ambiguous is its frequency-domain image.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why spectrograms divide the signal into short time slices and compute
    separate transforms for each slice, rather than performing one DFT for the entire
    buffer. But these slices can‚Äôt be arbitrarily short: at minimum, you must use
    a window large enough so that the bottom bin (*F[1]*) aligns with the lowest frequency
    you wish to discern. To illustrate, if you have a 44.1 kHz audio stream and want
    to measure down to 20 Hz, you need a window of 44,100 / 20 = 2,205 samples ‚Äî spanning
    50 milliseconds ‚Äî per each DFT.'
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: A lot can happen within 50 milliseconds; it follows that various workarounds
    ‚Äî such as the use of overlapping windows, weighted sampling, or specialized aliasing
    methods ‚Äî might be necessary to get acceptable temporal resolution in certain
    applications. Audio processing tends to be one of them.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: The inverse discrete Fourier transform is conceptually simple. It boils down
    to generating waveforms for to every previously-calculated frequency bin, adjusting
    their magnitude and phase in accordance with the DFT-produced *F[k]* coefficients,
    and then summing the results to recreate the contents of the time-domain sample
    window (*s[0]* to *s[N-1]*).
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs the IDFT formula that does just that:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: \(s_n = \frac{1}{N} { \sum\limits_{k=0}^{N-1} F_k \cdot e^{i{{2 \pi n \frac{k}{N}
    }}} } \)
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: Note the similarity of this equation to the forward DFT formula. There is an
    important symmetry in respect to inputs and outputs at the core of the algorithm;
    this is known as *orthogonality*. In a mildly mind-bending sense, the frequency
    domain is just the time domain turned ‚Äúinside out‚Äù.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs a simple implementation of IDFT in C:'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-57
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: As earlier, if working with real-number signals, *out_buf* can be declared as
    *double** instead.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: Remarkably, forward DFT followed by IDFT is lossless - i.e., it gets you the
    exact same time-domain data that you started with. In practice, some attention
    should be paid to the precision of floating-point calculations to avoid cumulative
    errors, but it‚Äôs usually not a big deal.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: 'The DFT is perfectly adequate except for one tiny problem: even if we precompute
    the exponentiation part, the algorithm still involves *K √ó N* complex-number multiplications.
    Because the number of computed bins (*K*) is frequently the same as window size
    (*N*), some computer science buffs with a penchant for vagueness describe the
    computational complexity of DFT as *O(n¬≤)*.'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: This is where fast Fourier transform (FFT) comes to play; FFT is still a discrete
    Fourier transform and it produces the same results, but the calculation is cleverly
    optimized for large input windows and for the *K = N* use case (the algorithm
    can‚Äôt be used to selectively compute only some frequency bins).
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: The performance gains are due to a technique known as the [radix-2 Cooley-Tukey
    algorithm](https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm).
    The derivation of this optimization is somewhat involved, but on a high level,
    it involves iteratively splitting the full DFT calculation into smaller sub-sums,
    and then exploiting the fact that the *e^(-i2)*^œÄ*^(kn/N)* expression is periodic
    ‚Äî it literally goes in circles! ‚Äî to factor out many redundant multiplications.
    For larger windows, the resulting complexity of FFT approaches *O(n ‚ãÖ log‚ÇÇ n*),
    which is a pretty substantial improvement.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerous reference FFT implementations exist for [almost every language imaginable](https://rosettacode.org/wiki/Fast_Fourier_transform);
    a particularly clean, minimalistic C implementation for power-of-two window sizes
    is as follows:'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-64
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Turning this code into inverse FFT (IFFT) boils down to removing the minus sign
    in the *cexp(‚Ä¶)* expression and dividing the final values by *len.*
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: Again, in practical applications, it would be wise to precompute the results
    of complex exponentiation; the value depends only on the *pos* index and the chosen
    window size.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: Discrete cosine transform can be thought of as a partial, real-numbers-only
    version of DFT. Just like discrete Fourier, it converts time-domain samples into
    a frequency spectrum. And just like DFT, it gets there by multiplying input data
    by cosine waveforms and then summing the results to obtain a bunch of binned coefficients.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, this description falls a bit short; the algorithm differs from discrete
    Fourier in a handful of interesting ways. First, let‚Äôs have a look at the usual
    formula for DCT-II, the most common variation of DCT:'
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: \(F_k = \sum\limits_{n=0}^{N-1} s_n \cdot cos ( \pi k { n + \frac12 \over N}
    )\)
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: 'If you scroll back to the DFT equation, you might notice that in the formula
    above, *k* is multiplied by œÄ (180¬∞) instead of 2œÄ (360¬∞). In effect, the waveform-generating
    part uses an interleaved pattern of full-turn and partial-turn bins, running at
    half the frequency of DFT and putting F[N-1] at the Nyquist limit. This change
    isn‚Äôt just about being more efficient: if you try to switch the timing expression
    back to *2œÄ*, the entire algorithm goes sideways and many frequency bins start
    reading zero. In a moment, we‚Äôll discuss why.'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: The other new element is the *+¬Ω* offset in the timing expression. Recall that
    sample numbers run from *n = 0* to *N - 1*, so dividing *n* by *N* leaves a gap
    on the upper end of the range. A +*¬Ω* shift centers the waveform; the symmetry
    is important for making the inverse function work. Discrete Fourier doesn‚Äôt use
    this because its symmetry comes from the more basic relationship between cosine
    and sine in the complex plane.
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual inverse DCT-II (IDCT-II) formula is:'
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: \(s_n = \frac{1}{N} \sum\limits_{k=0}^{N-1} F_k \cdot w_k \cdot cos [ \pi (n
    + \frac12) {k \over N} ]\)
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: The *w[k]* value is *1* for the DC bin (*k = 0*) and 2 for all the subsequent
    partial-turn bins (*k > 0*). You might encounter variants that put *w[k]* and
    the scaling factor (*1/N*) in the forward DCT formula instead; heck, some authors
    split the factors between DCT and IDCT. These changes result in differently-scaled
    coefficients, but the overall operation is the same.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: Now, let‚Äôs examine the fundamental mechanism of discrete cosine transform. Imagine
    we‚Äôre working with one second‚Äôs worth of data sampled at 2 kHz. With DFT, we get
    N / 2 = 1,000 usable frequency bins before hitting the Nyquist limit (1 kHz);
    bin spacing is 1 Hz. With the cosine transform, we‚Äôre getting N = 2,000 bins representing
    DC to Nyquist in 0.5 Hz increments.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs pick the 4 Hz bin (*F[8]*). First, consider what happens if we‚Äôre analyzing
    an input signal that‚Äôs running at 8 Hz. The image shows the reference 4 Hz waveform
    for the bin (blue), followed the input frequency (green), and then the computed
    product of the two (red). The product is centered around the *x* axis, so the
    DCT coefficient is zero:'
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: '*DCT: mismatched frequencies.*'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if the frequencies (and phases) match? In the plot below, we‚Äôre still
    looking at the *F[8]* bin, but the input signal is now aligned at 4 Hz. The multiplication
    is always involving two positive or two negative values, so the product waveform
    now has a positive sum:'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: '*DCT behavior with matching frequencies and phases.*'
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: If the phases of the signals are off by half a cycle (180¬∞), the discrete cosine
    transform still works ‚Äî except the reading is negative.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the behavior observed here, one might wonder why we partook in all that
    complex-number chicanery that comes with real DFT. The answer becomes obvious
    if we consider the case of a 90¬∞ or 270¬∞ phase shift (one-fourth or three-fourths
    of a wavelength). In this situation, any detectable offset in the multiplied waveform
    simply disappears, and the *F[8]* coefficient is zero despite the presence of
    a matching signal frequency:'
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: '*DCT bin #8 undone by a phase shift.*'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: The original Fourier transform has no problem handling this case; at 90¬∞, the
    DFT vector simply points up, the magnitude of the signal represented solely by
    the imaginary part (aka the *y* coordinate). In contrast, in discrete cosine transform,
    the imaginary part is AWOL, and we‚Äôre not registering anything in the expected
    frequency bin.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you might be wondering if the misaligned signals are simply
    lost. The answer is no ‚Äî the genius of DCT is that the out-of-phase data ends
    up in the nearby ‚Äúpartial-turn‚Äù bins that are not computed in normal DFT. Sticking
    to our phase-shifted 4 Hz problem signal featured above, let‚Äôs peek into the next
    bin ‚Äî *F[9]* at 4.5 Hz:'
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: '*DCT partial-turn bins doing their job.*'
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
- en: If you take a local view, the signal appears 90¬∞ out of phase at the beginning;
    seemingly snaps into phase in the middle; and then goes -90¬∞ out of phase at the
    end. Within this ‚Äúpartial-turn‚Äù bin‚Äôs measurement window, the average product
    is positive. If we go to the next ‚Äúfull-turn‚Äù bin (5 Hz), the product of the waveforms
    is once again zero.
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
- en: In other words, DCT bins encode magnitude **and** phase information, just not
    always where we‚Äôre expecting it. This explains why the transform needs twice as
    many bins ‚Äî and why trying to increase their spacing to match DFT breaks the algorithm.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
- en: This messy encoding scheme makes discrete cosine transform a fairly poor tool
    for most signal analysis tasks. That said, it‚Äôs great for fast, space-efficient
    compression algorithms where the aesthetics of the frequency-domain representation
    don‚Äôt matter much. A classic example is the JPEG image format, which performs
    DCT on 8√ó8 pixel tiles and then quantizes (i.e., reduces the precision of) the
    calculated coefficients to make them easier to compress using conventional lossless
    compression (Huffman coding).
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh ‚Äî if you wish to experiment with DCT-II, a simple implementation is included
    below:'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-90
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: For a nonsensical but amusing demo that lets you watch what happens if you apply
    JPEG-style lossy compression to text, check out [this post](https://lcamtuf.substack.com/p/afternoon-project-jpeg-dct-text-lossifizer).
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: '*If you‚Äôre interested in how DFT and DCT relate to the operation of radio receivers,
    check out [this feature](https://lcamtuf.substack.com/p/radios-how-do-they-work).
    For an article on alternative frequency domains, [see here](https://lcamtuf.substack.com/p/is-the-frequency-domain-a-real-place).
    For a thematic catalog of articles about electronics and signal processing, [click
    here](https://lcamtuf.coredump.cx/offsite.shtml).*'
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
