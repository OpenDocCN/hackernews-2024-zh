<!--yml

category: 未分类

date: 2024-05-27 12:48:35

-->

# 你的数据库技能并非“可有可无”

> 来源：[https://renegadeotter.com/2023/11/12/your-database-skills-are-not-good-to-have.html](https://renegadeotter.com/2023/11/12/your-database-skills-are-not-good-to-have.html)

### 一场MySQL的战争故事

当时是2006年，纽约杂志的数字团队着手为其时装周门户创建新的搜索体验。这是一个那种技术可行性甚至没有与技术团队讨论的项目 - 那时很常见。敏捷开发还很新，更不用说在出版界了。这只是一个愿景，一个真正的天方夜谭，10到12周内开发产品的线框版本。几乎没有时间进行适当的质量保证。时装周不是从慢慢开始，而是一眨眼间就从零到六十。

这个愿景呢？成千上万的近实时时装秀图像，每个图像都有其子项目进行分类：“2006年”，“包”，“红色”，“皮革”等等。用户会着陆在搜索页面，有能力“深入挖掘”，根据这些属性缩小结果。为了让事情变得*更*难，所有这些属性都将附有精确的计数。

工作流程将会非常紧张。摄影师们将把他们的数字存储卡带从纽约市中心快递到我们在麦迪逊大道的办公室，那里的图像将被处理，由实习生标记，然后我们的Perl脚本每小时读取嵌入的EXIF信息中的标签，并进行索引。如果我们的这一侧未能构建出搜索产品，整个已经就位、准备好进行战斗的生态系统将会崩溃。

“哦！只需在Solr中使用facets，老兄”。是的，并不那么快 - *老兄*。在2006年，那种技术甚至还不存在。我经历了多次企业搜索引擎演示，而所有的产品（它们花费了大量的钱）都不能进行深层次的facet搜索。我们已经拥有了Autonomy许可证，我的第一次尝试证明了……它就是不能做到。它本来应该能做到，但计数全都错了。Endeca（现在由Oracle拥有），[在项目设计部分已经启动](https://www.digitalcommerce360.com/2006/03/31/endeca-unveils-the-endeca-information-access-platform-takes-aim/)。太新了，太原始了，太冒险了。这个想法对于当时的时间来说，特别是对于一个非技术公司中的小团队来说，只是有点太雄心勃勃了。

所以在这里，我们是一个三人团队，我和两位顾问，为索引脚本编写Perl代码，查询解析逻辑，并对数据进行建模 - 在MySQL 4中。这是一个单个无法逾越的技术风险将会使整个项目失败的项目。我会简短地切断故事，免得让你激动不已。我们做到了，然后我们出去在卡拉OK酒吧庆祝（在那里我第一次因工作压力导致了严重的宿醉）🤮

对于那些负责SQL模型和查询的人来说，调优是日复一日的工作，计时每一个查询并研究`EXPLAIN`输出，看看还能做些什么来从数据库中挤出另外50ms。没有免费的夜晚或周末。最终，这是试错的结合，深入研究MySQL服务器设置，以及精心设计的`GROUP BY`查询，可能会让你感到恶心。那时的MySQL查询分析工具是烦躁不安的，有时候重新排列`SELECT`子句中的字段可以改变查询的性能。想象一下，如果`SELECT field1, field2 FROM my_table`比`SELECT field2, field1 FROM my_table`更快。为什么会这样？直到今天我也不知道，而且我也不想知道。

不幸的是，我丢失了这项工作的例子，但是[Way Back Machine](https://web.archive.org/web/20070519214259/http://nymag.com/fashion/fashionshows/2007/spring/main/newyork/womenrunway/yigalazrouel/)可以证明我们的最终产品。

这里的关键是 - 如果你真的了解你的数据库，你可以做出相当疯狂的事情，而且随着现代存储技术和更强大的硬件的出现，你甚至不需要推动极限 - 它应该可以轻松处理我所称的“常规规模”。

### SQL这门日渐衰落的艺术

在过去的几年里，我注意到一个令人不安的趋势 - 软件工程师渴望在处理相当基础的问题时使用外来的“星球规模”数据库，与此同时，他们对自己可能已经在使用的强大的关系型数据库引擎的掌握程度并不高，更不用说理解这些技术更高级和更有用的能力了。SQL层被深深埋藏在库下面，被过于聪明的ORMs所掩盖，一切都变成了高级别的代码。

现代硬件确实允许我们从CPU提升到更高的抽象层，虽然过去将某些功能转换为汇编代码以挤压处理器的每一位性能并不罕见。现在计算和存储变得更便宜了 - 这是真的 - 但是滥用这种丰富训练了我们的懒惰和自满。突然间，云账单有点高，而且谁知道世界每秒运行数十亿个自动生成的“Squeel”查询对巨大数据库实例的能源消耗有多大。

2004年我第一次求职面试的早晨，我在地铁上背诵数据库规范化的九个级别。还是五个级别吗？我不记得了，但这已经无关紧要了 - 在软件工程师的面试中现在永远不会有人问你这个。

只需大略浏览您选择的数据库的目录，比如现在 [风靡一时的 Postgres](https://www.crunchydata.com/blog/when-did-postgres-become-cool)，您会发现一个绝对宝藏般的功能组合，适合处理几乎所有，除了最棘手的全球规模计算机科学问题。像您现在阅读的这样的 PB 级 Postgres 盒子，已经轻松复制运行了。

窍门在于不要指望您的数据库或 ORM 能够读懂您的心思。说到……

### ORM 不是魔法

我是一家电子商务公司的新员工，一开始就被抛入修复公司产品目录页面的严重性能问题中。只是一个简单的、分页的产品图片网格。这能有多难？信不信由你——确实难。页面加载超过 10 秒，有时更长，数据库挣扎不堪，解决方案是“只需缓存它”。最后一个数据点——这不是一个高流量网站。即使没有流量，页面也会非常缓慢。这表明问题严重。

仔细查看后，我意识到我一次性犯了前三大主要数据库和编码错误。

#### ❌ 错误 #1：没有索引

每个关键任务查询中被命中的列都没有索引。一个都没有。在生产中添加了非常需要的索引后，您几乎可以听到 MySQL 在松了口气。然而，性能还没有完全达到预期，所以我不得不深入代码。

#### ❌ 错误 #2：假设每个 ORM 调用都是免费的

在本地激活查询日志并重新加载产品列表页面时，我看到……为了加载一个页面，竟然发出了 200、300、500 次查询。这是什么鬼？结果，这是经典的 ORM 滥用导致的，每个记录都通过循环进行查询，效果如下：

```
for product_id in product_ids:
   product = my_orm.products.get(id=product_id)
   products.append(product) 
```

高数量的查询也是因为部分逻辑是*嵌套*的事实。明显的解决方案是使用 ORM 的能力将每个请求中的查询数量保持最小化，将数据联接和组合成一个单一的块。这是关系型数据库做的事情——*这就是它的名字*。

上述情况是每个单独的查询需要访问数据库，[进行解析、转换、分析、计划、执行](https://postgrespro.com/blog/pgsql/5969262#:~:text=Any%20query%20can%20be%20executed,rows%20that%20match%20your%20query)，然后返回给调用者。这是你能做的最昂贵的操作之一，ORM 会乐意为了性能做最糟糕的事情。ORM 调用如何转换为 SQL？如果不符合您的预期，是 ORM 的限制还是您没有使用正确的库调用？这是特定的非 ANSI 厂商 SQL 的风格吗？对于这个调用，您最终是否需要切换到原始 SQL，但其他不需要？等等。

<photo-element source="database-skills/55.png" aspect="original-size" alt="Don't do this">#### ❌ 错误 #3：引入整个世界

更糟糕的是，这里的数据量相对较小，但列数却多达数十个。ORM 通常默认做什么以使你的生活“更轻松”？他们发送整个内容，所有列，用你甚至不需要的数据堵塞你的网络管道。这是一种*有毒的技术债务*，其中开发速度最终将开始影响性能。

我花了几个小时在同一个项目中，深入挖掘 Django 后台的黑暗角落，覆盖默认的 ORM 查询以减少“急迫性”。这大大改善了面向办公环境的体验。

### 性能本身就是一种特性。

数十年来，严肃的、关键任务的系统一直在经典而乏味的关系型数据库上运行，每秒服务成千上万的请求。这些系统变得更加先进、更有能力和更相关。它们是计算机科学的奇迹，可以说。你可能会认为像 Postgres 这样的古老数据库（自 1982 年起开发）在某种程度上处于某种遗留维护模式，但事实恰恰相反。事实上，工作进展只是在加速，规模和[功能变得非常令人印象深刻](https://www.se-radio.net/2019/04/se-radio-episode-362-simon-riggs-on-advanced-features-of-postgresql/)。几年前需要多次查询的任务现在只需一次查询。

为什么这一点很重要？长期以来，[亚马逊的发现](https://www.conductor.com/academy/page-speed-resources/faq/amazon-page-speed-study/)表明，每增加 100 毫秒用户等待页面加载时间，企业就会损失一定的收入。我们现在也知道，从用户的角度来看，[网页的最大目标响应时间大约是 100 毫秒](https://designingforperformance.com/performance-is-ux/#:~:text=A%20delay%20of%20less%20than,start%20to%20mentally%20context-switch)。

> 对用户来说，少于 100 毫秒的延迟感觉瞬间完成，但在 100 到 300 毫秒之间的延迟是可察觉的。300 到 1,000 毫秒之间的延迟会让用户感觉像机器正在工作，但如果延迟超过 1,000 毫秒，你的用户可能会开始进行心理上的切换。

“如果慢了，只需增加更多的 CPU 和 RAM”这种方法可能一度有效，但[很多人正在苦苦发现](https://venturebeat.com/data-infrastructure/the-shift-to-the-cloud-could-be-costing-businesses-more-than-its-saving/)，这种懒惰在成本至上的商业环境中是不可持续的。

### 数据库反模式。

知道**不**做什么与知道**要**做什么同样重要。以下是一些常见的错误：

#### ❌ 反模式 #1\. 出于错误的原因使用异类数据库。

类似DynamoDB这样的技术是为了处理Postgres和MySQL开始失败的规模而设计的。这是通过非规范化、大量复制数据来实现的，数据库并没有进行实时数据操作或连接。你的数据现在是根据查询方式建模的，而不是根据它们的*关系*。常规的关系概念在这种疯狂的规模下会解体。不用说，如果你为“常见规模”问题而采用这种存储方式，那么你已经在 [解决你并没有的问题](/2023/09/10/death-by-a-thousand-microservices.html) 了。

#### ❌ 反模式 #2\. 无谓的缓存

缓存是一种必要之恶，*但并不总是必需的*。有一整类错误和即时问题源于过时的缓存数据。只读数据库副本是一种经典架构模式，至今仍然非常有效，它可以在你需要担心任何问题之前大幅提升性能。不应该让人感到意外的是，成熟的关系型数据库已经实施了查询缓存 - 只需要根据你的具体需求进行调优。它必须 [进行调优](https://severalnines.com/blog/overview-caching-postgresql/) 才能达到最佳效果。

缓存失效是困难的。它给系统增加了更多复杂性和不确定状态。这使得调试变得更加困难。在我职业生涯中，我收到了许多来自内容团队的电子邮件，他们想知道“为什么数据不在那里，我30分钟前更新了它？”

*缓存不应该作为糟糕架构和非高效代码的一种紧急措施。*

<photo-element source="database-skills/two-problems.png" aspect="original-size" alt="缓存">#### ❌ 反模式 #3\. 存储一切及厨房水槽

尽管行业标准数据库可以承受如此多的惩罚，但完全不关心输入内容，将其视为某种数据垃圾场可能并不是一个好主意。管理、查询、备份、迁移 - 一旦数据库规模显著增长，所有这些都会变得痛苦。即使你使用托管云数据库不关心这些，成本也是个问题。关系型数据库是一种复杂的技术，存储数据在其中是*昂贵的*。

### 首先要确定常见规模

使用Postgres或MySQL数据库，如果你指望它们在不做额外工作的情况下自动优化，那么让它们变得不堪重负是相当容易的。*“老板，它不适合Web规模。我们的200万条记录似乎太多了。我们需要DynamoDB、Kafka和事件源！”*

关系型数据库不是一种只有我们这些技术化石才选择成为专家的古老技术，也不是可以像讨厌的昆虫一样轻易忽略的东西。*“在这里，我们用React和GraphQL搞定一切，老头子”*。从法律角度来看，现代关系型数据库是无辜的，除非被证明有罪，并且证明的负担应该极其严格 - 几乎完全由你承担。

最后，如果我必须弄清楚“为什么很慢”，我的大致操作步骤是：

+   编制一个独特查询列表，包括日志、慢查询日志等。

+   首先查看最频繁的查询

+   使用 `EXPLAIN` 来检查索引使用的慢查询计划

+   只选择需要通过网络传输的数据

+   如果 ORM 在没有解决方法的情况下做了一些愚蠢的事情，请打开引擎盖，与原始的 SQL 管道进行深入交流

<photo-element source="database-skills/merry-xmas.gif" aspect="landscape" alt="圣诞快乐！">最重要的是，学习你的数据库（以及 SQL）。学习它，热爱它，使用它，甚至滥用它。花几天时间翻阅一下那本 PostgreSQL 手册，看看它*能*做什么，可能会比花更多时间在下一个风靡一时的 JavaScript 框架上更能成为一名优秀的工程师。再说一遍。

### 最新

### 相关文章

[我不是你的云计算人](/2023/07/26/i-am-not-your-cloud-person.html)

### 进一步阅读

[使用索引，卢克 - SQL 索引和调优电子书](https://use-the-index-luke.com/)

[不要这样做 - 一个 PostgreSQL 维基](https://wiki.postgresql.org/wiki/Don't_Do_This)</photo-element></photo-element></photo-element>
