- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:57:12'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroZed Chronicles: Linear Feedback Shift Register'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.adiuvoengineering.com/post/microzed-chronicles-linear-feedback-shift-register](https://www.adiuvoengineering.com/post/microzed-chronicles-linear-feedback-shift-register)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a follow on from last week, one of the techniques I like to use to stimulate
    or capture data in our FPGA designs is a Linear Feedback Shift Register (LFSR).
  prefs: []
  type: TYPE_NORMAL
- en: In the ten-plus years of this blog, I have never talked much about LFSRs, so
    I am going to focus this blog on exploring them as they are helpful for our FPGA
    designs. These days, we are a little spoiled with the modern fabric being so capable.
  prefs: []
  type: TYPE_NORMAL
- en: 'LFSRs can be used for a range of applications in our FPGAs:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating random test patterns – Leveraging the pseudo random nature of the
    LFSR to generate data for test patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Counters – using a LFSR as a counter can often provide a more efficient and
    higher performing implementation than alternate approaches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data scrambling / descrambling – The output from the LFSR can be combined with
    data to ensure that long runs of ones or zeros are removed which could result
    in synchronization problems when received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Error detection and correction – By selecting the specific polynomial to generate
    code words, we are able to detect errors in the transmission when the data is
    received and applied to the same LFSR. Ethernet is a commonly used example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LFSR is formed around a shift register which has one or several of the register
    outputs fed back into the input of the first register. The elements, which are
    fed back to the input, are often called taps and the tap selection will determine
    the behavior of the LFSR. Of course, the LFSR  will eventually repeat its pattern
    because it has feedback. For a maximal length implementation, the shift register
    will repeat after 2^n-1 iterations. This is a result of the two methods of implementing
    a LFSR. Both have illegal values which prohibit further operation and as such,
    are avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two methods of implementation for a LFSR are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Galois – In this architecture, the XOR/XNOR gates are implemented between register
    stages within the shift register and the output of the last stage is wrapped around
    to the first register input and connected to the XOR/XNOR gate input. This means
    when the output is 0, the register simply shifts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing both architectures can result in maximal length LFSR being implemented.
    However, we do need to do a translation between the location of the taps in a
    Fibonacci implementation versus a Galois implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For a Fibonacci implementation of a simple 8-bit LFSR, we will have taps at
    4,5,6,8 when the registers are numbered 1 to 8 (with 1 being the input and 8 being
    the output element). This leads to a diagram as below.
  prefs: []
  type: TYPE_NORMAL
- en: For a Galois implementation, however, the taps need to be updated so the register
    position is updated. Be aware that it is also common to number Galois registers
    in the opposite direction to Fibonacci.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of using a Galois implementation is that there is never more than
    one logic level between registers regardless of the number of taps used. However,
    in modern FPGAs, this can limit the implementation to registers and not enable
    the use of SRL for sections of the shift register if appropriate within the CLB.
    The implementation of the XOR can be handled by the LUT which proves very capable
    for larger XOR/XNOR Implementations with six input LUT. As such, the usage of
    Fibonacci or Galois implementation comes down to the engineer understanding what
    is best suited for your application.
  prefs: []
  type: TYPE_NORMAL
- en: The use of an XNOR or XOR gate depends on the application, however, both Fibonacci
    and Galois LFRS implementations support both gates. When a XOR gate is used, the
    illegal state for the register is all zeros while the illegal state is all ones
    for the XNOR gate. As AMD devices generally initialize to having all registers
    at zero (see my blog on resets here), it makes sense for us to use the XNOR style
    approach, although it is possible to create a modulo 2^n counter with a little
    extra decoding logic.
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this blog, we are going to create simple LFSR implementations
    using the Galois and Fibonacci techniques and demonstrate the result when implemented
    in an AMD 7 series device.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for both can be seen below. For the test bench, I run through
    the sequence and record them to text files which ensures I can double check that
    the sequence is correct. As a maximal length sequence, it should repeat after
    255 iterations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we modify the design slightly, the parallel word is not being output but
    instead, a serial output is generated. This is a common use case. We can then
    synthesize the design and observe how it is implemented. Note how it uses SRL
    whenever it can.
  prefs: []
  type: TYPE_NORMAL
- en: In our next blog, we will be using a LFSR as part of our miniseries that looks
    at how we are able to capture data using the ILA and test equipment.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for a list of LFSR feedback taps, the great Peter Alfke wrote
    an interesting [app note](https://docs.amd.com/v/u/en-US/xapp052) a while back
    which targets now obsolete devices and provides a great introduction to LFSR,
    along with an extensive LFSR table of taps.
  prefs: []
  type: TYPE_NORMAL
- en: If you enjoyed the blog why not take a look at the free webinars, workshops
    and training courses we have created over the years. Highlights include
  prefs: []
  type: TYPE_NORMAL
- en: Do you want to know more about designing embedded systems from scratch? Check
    out our book on creating embedded systems. This book will walk you through all
    the stages of requirements, architecture, component selection, schematics, layout,
    and FPGA / software design. We designed and manufactured the board at the heart
    of the book! The schematics and layout are available in Altium [here](https://www.e3designers.com/altium-365)Learn
    more about the board (see previous blogs on [Bring up](https://www.adiuvoengineering.com/post/microzed-chronicles-configuring-zynq-on-a-custom-board),
    [DDR validation,](https://www.adiuvoengineering.com/post/microzed-chronicles-validating-your-custom-zynq-board-memory)
    [USB](https://www.adiuvoengineering.com/post/microzed-chronicles-smart-sensor-iot-board-getting-usb-up-and-running),
    [Sensors](https://www.adiuvoengineering.com/post/microzed-chronicles-petalinux-i2c-in-the-ps-and-axi-iic))
    and view the schematics [here](https://www.adiuvoengineering.com/post/sensorsthink-board-schematic).
  prefs: []
  type: TYPE_NORMAL
