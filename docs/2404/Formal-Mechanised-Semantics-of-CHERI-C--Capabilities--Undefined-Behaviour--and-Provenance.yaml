- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:17:56'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Formal Mechanised Semantics of CHERI C: Capabilities, Undefined Behaviour,
    and Provenance | Proceedings of the 29th ACM International Conference on Architectural
    Support for Programming Languages and Operating Systems, Volume 1'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://dl.acm.org/doi/10.1145/3617232.3624859?ai=&ui=&af=](https://dl.acm.org/doi/10.1145/3617232.3624859?ai=&ui=&af=)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ABSTRACT
  id: totrans-split-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory safety issues are a persistent source of security vulnerabilities, with
    conventional architectures and the C codebase chronically prone to exploitable
    errors. The CHERI research project has shown how one can provide radically improved
    security for that existing codebase with minimal modification, using unforgeable
    hardware capabilities in place of machine-word pointers in CHERI dialects of C,
    implemented as adaptions of Clang/LLVM and GCC. CHERI was first prototyped as
    extensions of MIPS and RISC-V; it is currently being evaluated by Arm and others
    with the Arm Morello experimental architecture, processor, and platform, to explore
    its potential for mass-market adoption, and by Microsoft in their CHERIoT design
    for embedded cores.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: 'There is thus considerable practical experience with CHERI C implementation
    and use, but exactly what CHERI C''s semantics is (or should be) remains an open
    question. In this paper, we present the first attempt to rigorously and comprehensively
    define CHERI C semantics, discuss key semantics design questions relating to capabilities,
    provenance, and undefined behaviour, and clarify them with semantics in multiple
    complementary forms: in prose, as an executable semantics adapting the Cerberus
    C semantics, and mechanised in Coq.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: This establishes a solid foundation for CHERI C, for those porting code to it,
    for compiler implementers, and for future semantics and verification.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
