["```\nSUBROUTINE foo(x, y, z)\n IMPLICIT NONE\n INTEGER, INTENT(IN)  :: x, y\n INTEGER, INTENT(OUT) :: z\n z = x + y\nEND\n```", "```\n#include <stdio.h>\n\nextern void foo_(int*, int*, int*);\n\nint main() {\n int x = 1, y = 1, z;\n foo_(&x, &y, &z);\n\n printf(\"%d + %d = %d\\n\", x, y, z);\n return 0;\n}\n```", "```\ndiff --git a/flang/lib/Optimizer/CodeGen/Target.cpp b/flang/lib/Optimizer/CodeGen/Target.cpp\nindex 83e7fa9b440b..49e73ec48e0a 100644\n--- a/flang/lib/Optimizer/CodeGen/Target.cpp\n+++ b/flang/lib/Optimizer/CodeGen/Target.cpp\n@@ -1109,6 +1109,44 @@ struct TargetLoongArch64 : public GenericTarget<TargetLoongArch64> {\n };\n } // namespace\n\n+//===----------------------------------------------------------------------===//\n+// WebAssembly (wasm32) target specifics.\n+//===----------------------------------------------------------------------===//\n+\n+namespace {\n+struct TargetWasm32 : public GenericTarget<TargetWasm32> {\n+  using GenericTarget::GenericTarget;\n+\n+  static constexpr int defaultWidth = 32;\n+\n+  CodeGenSpecifics::Marshalling\n+  complexArgumentType(mlir::Location, mlir::Type eleTy) const override {\n+    assert(fir::isa_real(eleTy));\n+    CodeGenSpecifics::Marshalling marshal;\n+    // Use a type that will be translated into LLVM as:\n+    // { t, t }   struct of 2 eleTy, byval, align 4\n+    auto structTy =\n+        mlir::TupleType::get(eleTy.getContext(), mlir::TypeRange{eleTy, eleTy});\n+    marshal.emplace_back(fir::ReferenceType::get(structTy),\n+                         AT{/*alignment=*/4, /*byval=*/true});\n+    return marshal;\n+  }\n+\n+  CodeGenSpecifics::Marshalling\n+  complexReturnType(mlir::Location loc, mlir::Type eleTy) const override {\n+    assert(fir::isa_real(eleTy));\n+    CodeGenSpecifics::Marshalling marshal;\n+    // Use a type that will be translated into LLVM as:\n+    // { t, t }   struct of 2 eleTy, sret, align 4\n+    auto structTy = mlir::TupleType::get(eleTy.getContext(),\n+                                          mlir::TypeRange{eleTy, eleTy});\n+    marshal.emplace_back(fir::ReferenceType::get(structTy),\n+                          AT{/*alignment=*/4, /*byval=*/false, /*sret=*/true});\n+    return marshal;\n+  }\n+};\n+} // namespace\n+\n // Instantiate the overloaded target instance based on the triple value.\n // TODO: Add other targets to this file as needed.\n std::unique_ptr<fir::CodeGenSpecifics>\n@@ -1158,6 +1196,9 @@ fir::CodeGenSpecifics::get(mlir::MLIRContext *ctx, llvm::Triple &&trp,\n case llvm::Triple::ArchType::loongarch64:\n return std::make_unique<TargetLoongArch64>(ctx, std::move(trp),\n std::move(kindMap), dl);\n+  case llvm::Triple::ArchType::wasm32:\n+    return std::make_unique<TargetWasm32>(ctx, std::move(trp),\n+                                               std::move(kindMap), dl);\n }\n TODO(mlir::UnknownLoc::get(ctx), \"target not implemented\");\n }\n```", "```\nvar Module = require('./foo.js');\n\nsetTimeout(() => {\n const x = Module._malloc(4);\n const y = Module._malloc(4);\n const z = Module._malloc(4);\n Module.HEAPU32[x / 4] = 123;\n Module.HEAPU32[y / 4] = 456;\n\n Module._foo_(x, y, z);\n\n console.log(\"x = \", Module.HEAP32[x / 4]);\n console.log(\"y = \", Module.HEAP32[y / 4]);\n console.log(\"x + y = \", Module.HEAP32[z / 4]);\n\n Module._free(x);\n Module._free(y);\n Module._free(z);\n}, 100);\n```", "```\n<html>\n <head>\n <title>Fortran Demo</title>\n </head>\n <body>\n <script src=\"foo.js\"></script>\n <script src=\"standalone.js\"></script>\n </body>\n</html>\n```", "```\nSUBROUTINE hello()\n IMPLICIT NONE\n PRINT *, \"Hello, World!\"\nEND\n```", "```\nextern void hello_();\n\nint main() {\n hello_();\n return 0;\n}\n```", "```\nROOT =  $(abspath .)\nSOURCE =  $(ROOT)/llvm-project\nBUILD =  $(ROOT)/build\n\nRUNTIME_SOURCES :=  $(wildcard  $(SOURCE)/flang/runtime/*.cpp)\nRUNTIME_SOURCES +=  $(SOURCE)/flang/lib/Decimal/decimal-to-binary.cpp\nRUNTIME_SOURCES +=  $(SOURCE)/flang/lib/Decimal/binary-to-decimal.cpp\nRUNTIME_OBJECTS =  $(patsubst  $(SOURCE)/%,$(BUILD)/%,$(RUNTIME_SOURCES:.cpp=.o))\n\nRUNTIME_CXXFLAGS += -I$(BUILD)/include -I$(BUILD)/tools/flang/runtime\nRUNTIME_CXXFLAGS += -I$(SOURCE)/flang/include -I$(SOURCE)/llvm/include\nRUNTIME_CXXFLAGS += -DFLANG_LITTLE_ENDIAN\nRUNTIME_CXXFLAGS += -fPIC -Wno-c++11-narrowing -fvisibility=hidden\nRUNTIME_CXXFLAGS += -DFE_UNDERFLOW=0 -DFE_OVERFLOW=0 -DFE_INEXACT=0\nRUNTIME_CXXFLAGS += -DFE_INVALID=0 -DFE_DIVBYZERO=0 -DFE_ALL_EXCEPT=0\n\n$(BUILD)/flang/runtime/libFortranRuntime.a:  $(RUNTIME_OBJECTS)\n @rm -f $@\n emar -rcs $@ $^\n\n$(BUILD)%.o :  $(SOURCE)%.cpp\n @mkdir -p $(@D)\n em++ $(RUNTIME_CXXFLAGS) -o $@ -c $<\n\n.PHONY: clean\nclean:\n @rm $(RUNTIME_OBJECTS)  $(BUILD)/flang/runtime/libFortranRuntime.a\n```", "```\nflang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h\n```", "```\n//===----------------------------------------------------------------------===//\n// Type builder models\n//===----------------------------------------------------------------------===//\n\n// TODO: all usages of sizeof in this file assume build ==  host == target.\n// This will need to be re-visited for cross compilation.\n\n/// Return a function that returns the type signature model for the type `T`\n/// when provided an MLIRContext*. This allows one to translate C(++) function\n/// signatures from runtime header files to MLIR signatures into a static table\n/// at compile-time.\n///\n/// For example, when `T` is `int`, return a function that returns the MLIR\n/// standard type `i32` when `sizeof(int)` is 4.\n```", "```\ndiff --git a/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h b/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h\nindex b3fe52f4b..c3c7326da 100644\n--- a/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h\n+++ b/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h\n@@ -146,7 +146,7 @@ constexpr TypeBuilderFunc getModel<void **>() {\n template <>\n constexpr TypeBuilderFunc getModel<long>() {\n return [](mlir::MLIRContext *context) -> mlir::Type {\n-    return mlir::IntegerType::get(context, 8 * sizeof(long));\n+    return mlir::IntegerType::get(context, 8 * 4);\n };\n }\n template <>\n@@ -187,7 +187,7 @@ constexpr TypeBuilderFunc getModel<long long *>() {\n template <>\n constexpr TypeBuilderFunc getModel<unsigned long>() {\n return [](mlir::MLIRContext *context) -> mlir::Type {\n-    return mlir::IntegerType::get(context, 8 * sizeof(unsigned long));\n+    return mlir::IntegerType::get(context, 8 * 4);\n };\n }\n template <>\ndiff --git a/flang/lib/Optimizer/CodeGen/CodeGen.cpp b/flang/lib/Optimizer/CodeGen/CodeGen.cpp\nindex ba5946415..2931753a8 100644\n--- a/flang/lib/Optimizer/CodeGen/CodeGen.cpp\n+++ b/flang/lib/Optimizer/CodeGen/CodeGen.cpp\n@@ -1225,7 +1225,7 @@ getMalloc(fir::AllocMemOp op, mlir::ConversionPatternRewriter &rewriter) {\n return mlir::SymbolRefAttr::get(userMalloc);\n mlir::OpBuilder moduleBuilder(\n op->getParentOfType<mlir::ModuleOp>().getBodyRegion());\n-  auto indexType = mlir::IntegerType::get(op.getContext(), 64);\n+  auto indexType = mlir::IntegerType::get(op.getContext(), 32);\n auto mallocDecl = moduleBuilder.create<mlir::LLVM::LLVMFuncOp>(\n op.getLoc(), mallocName,\n mlir::LLVM::LLVMFunctionType::get(getLlvmPtrType(op.getContext()),\n@@ -1281,6 +1281,7 @@ struct AllocMemOpConversion : public FIROpConversion<fir::AllocMemOp> {\n mlir::Type heapTy = heap.getType();\n mlir::Location loc = heap.getLoc();\n auto ity = lowerTy().indexType();\n+    auto i32ty = mlir::IntegerType::get(rewriter.getContext(), 32);\n mlir::Type dataTy = fir::unwrapRefType(heapTy);\n mlir::Type llvmObjectTy = convertObjectType(dataTy);\n if (fir::isRecordWithTypeParameters(fir::unwrapSequenceType(dataTy)))\n@@ -1291,9 +1292,10 @@ struct AllocMemOpConversion : public FIROpConversion<fir::AllocMemOp> {\n for (mlir::Value opnd : adaptor.getOperands())\n size = rewriter.create<mlir::LLVM::MulOp>(\n loc, ity, size, integerCast(loc, rewriter, ity, opnd));\n+    auto size_i32 = integerCast(loc, rewriter, i32ty, size);\n heap->setAttr(\"callee\", getMalloc(heap, rewriter));\n rewriter.replaceOpWithNewOp<mlir::LLVM::CallOp>(\n-        heap, ::getLlvmPtrType(heap.getContext()), size, heap->getAttrs());\n+        heap, ::getLlvmPtrType(heap.getContext()), size_i32, heap->getAttrs());\n return mlir::success();\n }\n```", "```\nFC = ../build/bin/flang-new\nFFLAGS = -O2\nFFLAGS_NOOPT = -O0\n\nAR = emar\nRANLIB = emranlib\n```", "```\nSUBROUTINE bar(alpha, A, X, beta, Y)\n IMPLICIT NONE\n INTEGER, PARAMETER :: N = 3\n COMPLEX(KIND=8), INTENT(IN) :: alpha, beta, A(N,N), X(N)\n COMPLEX(KIND=8), INTENT(INOUT) :: Y(N)\n EXTERNAL zgemv\n\n CALL zgemv('N', N, N, alpha, A, N, X, 1, beta, Y, 1)\nEND\n```", "```\n#include <stdio.h>\n#include <complex.h>\n\nextern void bar_(double complex*, double complex*, double complex*,\n double complex*, double complex*);\n\nint main() {\n double complex alpha = 1.;\n double complex beta = 2.*I;\n double complex A[] = {\n 1.*I, 4.  , 5.,\n 7.  , 2.*I, 6.,\n 8.  , 9.  , 3.*I\n };\n double complex X[] = { 0., 1., 2. };\n double complex Y[] = { 3., 4., 5. };\n\n bar_(&alpha, A, X, &beta, Y);\n\n printf(\"Y[0]: %f + %fi, Y[1]: %f + %fi, Y[2]: %f + %fi\\n\",\n creal(Y[0]), cimag(Y[0]),\n creal(Y[1]), cimag(Y[1]),\n creal(Y[2]), cimag(Y[2]));\n return 0;\n}\n```", "```\nFC = [...]/build/bin/flang-new\nFFLAGS = -O2\nFFLAGS_DRV =  $(FFLAGS)\nFFLAGS_NOOPT = -O0\n\nAR = emar\nRANLIB = emranlib\n\nTIMER = INT_CPU_TIME\n```"]