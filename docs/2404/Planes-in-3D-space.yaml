- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 13:35:26'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 13:35:26'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Planes in 3D space
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D空间中的平面
- en: 来源：[https://alexharri.com/blog/planes](https://alexharri.com/blog/planes)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://alexharri.com/blog/planes](https://alexharri.com/blog/planes)
- en: <main class="css-fkkl8v">
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="css-fkkl8v">
- en: Planes in 3D space
  id: totrans-split-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D空间中的平面
- en: April 27, 2024
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 2024年4月27日
- en: A plane in 3D space can be thought of as a flat surface that stretches infinitely
    far, splitting space into two halves.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 3D空间中的平面可以看作是一个平坦的表面，无限延伸，将空间分为两半。
- en: Planes have loads of uses in applications that deal with 3D geometry. I've mostly
    been working with them in the context of an [architectural modeler](https://www.arkio.is/),
    where geometry is defined in terms of planes and their intersections.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理3D几何的应用程序中，平面有很多用途。我主要在[建筑建模师](https://www.arkio.is/)的背景下使用它们，其中几何图形是通过平面及其交集来定义的。
- en: Learning about planes felt abstract and non-intuitive to me. *“Sure, that's
    a plane equation, but what do I do with it? What does a plane look like?”* It
    took some time for me to build an intuition for how to reason about and work with
    them.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 学习平面感觉抽象且不直观。*“当然，那是一个平面方程，但我该怎么办？平面看起来什么样？”* 我花了一些时间来建立关于如何理解和处理它们的直觉。
- en: In writing this, I want to provide you with an introduction that focuses on
    building a practical, intuitive understanding of planes. I hope to achieve this
    through the use of visual (and interactive!) explanations which will accompany
    us as we work through progressively more complex problems.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我希望为您提供一个专注于建立对平面实用和直观理解的介绍。我希望通过视觉（和互动！）解释来实现这一目标，这些解释将随着我们逐步解决更复杂的问题而进行。
- en: With that out of the way, let's get to it!
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 说完这些，让我们开始吧！
- en: Describing planes
  id: totrans-split-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述平面
- en: There are many ways to describe planes, such as through
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 描述平面的方法有很多，比如通过
- en: a point in 3D space and a normal,
  id: totrans-split-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3D空间中的一个点和一个法线，
- en: three points in 3D space, forming a triangle, or
  id: totrans-split-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3D空间中的三个点形成一个三角形，或者
- en: a normal and a distance from an origin.
  id: totrans-split-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个法线和一个来自原点的距离。
- en: Throughout this post, the term *normal* will refer to a *normalized direction
    vector* (unit vector) whose magnitude (length) is equal to 1, typically denoted
    by <mjx-container classname="MathJax" jax="SVG"></mjx-container>where <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，“*正常*”一词将指代一个*标准化方向向量*（单位向量），其大小（长度）等于1，通常表示为<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>其中<mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: 'Starting with the point-and-normal case, here''s an example of a plane described
    by a point in 3D space <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从点和法线情况开始，这是一个由3D空间中一个点<mjx-container classname="MathJax" jax="SVG"></mjx-container>和一个法线<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>描述的平面的示例：
- en: The normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    the plane's orientation, where the surface of the plane is perpendicular to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, while the point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>describes *a* point on the plane.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 法线<mjx-container classname="MathJax" jax="SVG"></mjx-container>描述了平面的方向，其中平面的表面垂直于<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，而点<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>描述了平面上的*一个*点。
- en: We described this plane in terms of a single point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, but keep in mind that this plane—let's call it <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>—contains infinitely many points.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一个点<mjx-container classname="MathJax" jax="SVG"></mjx-container>描述了这个平面，但请记住这个平面——我们称之为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>——包含无限多个点。
- en: If <mjx-container classname="MathJax" jax="SVG"></mjx-container>were described
    by one of those other points contained by <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    we would be describing the exact same plane. This is a result of the infinite
    nature of planes.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<mjx-container classname="MathJax" jax="SVG"></mjx-container>由其中一个其他点描述，我们将描述相同的平面。这是平面无限性质的结果。
- en: This way of describing planes—in terms of a point and a normal—is the [point-normal
    form](https://en.wikipedia.org/wiki/Euclidean_planes_in_three-dimensional_space#Point%E2%80%93normal_form_and_general_form_of_the_equation_of_a_plane)
    of planes.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种描述平面的方式——通过一个点和一个法线——是平面的[点法式](https://en.wikipedia.org/wiki/Euclidean_planes_in_three-dimensional_space#Point%E2%80%93normal_form_and_general_form_of_the_equation_of_a_plane)。
- en: 'We can also describe a plane using three points in 3D space <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, <mjx-container classname="MathJax" jax="SVG"></mjx-container>forming
    a triangle:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用三维空间中的三个点 <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 来描述一个平面形成的三角形：
- en: The triangle forms an implicit plane, but for us to be able to do anything useful
    with the plane we'll need to calculate its normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>. Once we've calculated the plane's normal, we can use
    that normal along with one of the triangle's three points to describe the plane
    in point-normal form.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个三角形形成一个隐式平面，但为了能够对平面进行有用的操作，我们需要计算它的法向量 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>。一旦我们计算出平面的法向量，我们就可以使用这个法向量以及三角形的一个顶点来描述平面的点法式。
- en: As mentioned earlier, the normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describing
    a plane is a unit vector (<mjx-container classname="MathJax" jax="SVG"></mjx-container>)
    perpendicular to the plane.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，描述平面的法向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    是一个垂直于平面的单位向量 (<mjx-container classname="MathJax" jax="SVG"></mjx-container>)。
- en: We can use <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>as two edge vectors
    that are parallel to the plane's surface.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 作为平面表面平行的两个边向量。
- en: By virtue of being parallel to the plane's surface, the vectors <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>are perpendicular to the plane's normal. This is where
    the cross product becomes useful to us.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与平面表面平行，向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和
    <mjx-container classname="MathJax" jax="SVG"></mjx-container> 都垂直于平面的法向量。这就是叉乘对我们有用的地方。
- en: The [cross product](https://en.wikipedia.org/wiki/Cross_product) takes in two
    vectors <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and returns a vector <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>that is perpendicular to both of
    them.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[叉乘](https://en.wikipedia.org/wiki/Cross_product) 接受两个向量 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 和 <mjx-container classname="MathJax" jax="SVG"></mjx-container>，返回一个垂直于它们的向量
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>。'
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'For example, given the vectors <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, their cross product
    is the vector <mjx-container classname="MathJax" jax="SVG"></mjx-container>, which
    we''ll label <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，它们的叉乘是向量 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，我们将其标记为 <mjx-container classname="MathJax" jax="SVG"></mjx-container>：
- en: This explanation is simple on purpose. We'll get into more detail about the
    cross product later on.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释故意简单。稍后我们将更详细地讨论叉乘。
- en: 'Because the edge vectors of the triangle, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    are both parallel to the triangle''s surface, their cross product will be perpendicular
    to the triangle''s surface. Let''s name the cross product of our two edge vectors
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为三角形的边向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 都与三角形的表面平行，它们的叉乘将垂直于三角形的表面。让我们将两个边向量的叉乘命名为
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>has been scaled
    down for illustrative purposes
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container> 已经被缩小了，仅用于说明目的。
- en: '<mjx-container classname="MathJax" jax="SVG"></mjx-container>points in the
    right direction, but it''s not a normal. For <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>to be a normal, its magnitude needs to equal 1\. We
    can normalize <mjx-container classname="MathJax" jax="SVG"></mjx-container>by
    dividing it by its magnitude, the result of which we''ll assign to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>指向正确的方向，但它不是一个法线。要成为法线，其大小必须等于1。我们可以通过将<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>除以其大小来对其进行归一化，将结果分配给<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'This gives us a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>where
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个常态<mjx-container classname="MathJax" jax="SVG"></mjx-container>，其中<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>：
- en: Having found the triangle's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>we
    can use it and any of the points <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>to describe the plane containing
    the three points in point-normal form.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 找到三角形的法线<mjx-container classname="MathJax" jax="SVG"></mjx-container>后，我们可以使用它和任意的点<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，<mjx-container classname="MathJax" jax="SVG"></mjx-container>来描述包含这三个点的平面的点法线形式。
- en: It doesn't matter which of <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>we use as the point in the point-normal
    form; we always get the same plane.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点法线形式时，无论我们使用哪个点作为<mjx-container classname="MathJax" jax="SVG"></mjx-container>，我们始终得到同一个平面。
- en: Constant-normal form
  id: totrans-split-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常数法线形式
- en: There's one more way to describe a plane that we'll look at, which is through
    a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>and a distance
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 描述平面的另一种方法是通过一个法线<mjx-container classname="MathJax" jax="SVG"></mjx-container>和一个距离<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>。
- en: This is the *constant-normal form* of planes. It makes lots of calculations
    using planes much simpler.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是平面的*常数法线形式*，它使得使用平面进行许多计算变得更简单。
- en: 'In the constant-normal form, the distance <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>denotes how close the plane gets to the origin. Thought
    of another way: multiplying the normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>by
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>yields the point
    on the plane that''s closest to the origin.'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在常数法线形式中，距离<mjx-container classname="MathJax" jax="SVG"></mjx-container>表示平面靠近原点的程度。另一种想法：将法线<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>乘以<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，得到离原点最近的平面上的点。
- en: 'This is a simplification. More formally, given a point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>on a plane whose normal is <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, we can describe all points <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>on the plane in two forms: the point-normal form <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, and the constant-normal form <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>where <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>. See [further reading](/blog/planes#further-reading).'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化。更正式地说，给定平面上一点<mjx-container classname="MathJax" jax="SVG"></mjx-container>其法线为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，我们可以用两种形式描述平面上的所有点：点法线形式<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和常数法线形式<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，其中<mjx-container classname="MathJax" jax="SVG"></mjx-container>。详见[进一步阅读](/blog/planes#further-reading)。
- en: 'In getting a feel for the difference between the point-normal and constant-normal
    forms, take this example which describes the same plane in both forms:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受点法线形式和常数法线形式之间的差异，可以看这个例子，它在两种形式中描述了同一个平面：
- en: The green arrow represents <mjx-container classname="MathJax" jax="SVG"></mjx-container>from
    the constant-normal form, while the blue point and arrow represent the point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>from the point-normal form.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色箭头代表常法式中的<mjx-container classname="MathJax" jax="SVG"></mjx-container>，而蓝色点和箭头代表点法式中的点<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和法向量<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>。
- en: 'Translating from the point-normal to the constant-normal form is very easy:
    the distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the
    [dot product](https://en.wikipedia.org/wiki/Dot_product) of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>.'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从点法式到常法式的转换非常简单：距离<mjx-container classname="MathJax" jax="SVG"></mjx-container>是[mjx-container
    classname="MathJax" jax="SVG"></mjx-container]的点积。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: If you're not familiar with the dot product, don't worry. We'll cover it later
    on.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对点积不熟悉，别担心，我们稍后会介绍。
- en: The notation for <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>might seem to indicate
    that they're of different types, but they're both vectors. I'm differentiating
    between points in space (e.g. <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>) and direction vectors
    (e.g. <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>) by using the arrow notation only
    for direction vectors.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的符号表示可能表明它们属于不同类型，但它们都是向量。我通过仅使用箭头符号区分空间中的点（例如<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>）和方向向量（例如<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>）。
- en: The normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>stays
    the same across both forms.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 法向量<mjx-container classname="MathJax" jax="SVG"></mjx-container>在两种形式中保持不变。
- en: Distance from plane
  id: totrans-split-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平面距离
- en: Given an arbitrary point <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    a plane <mjx-container classname="MathJax" jax="SVG"></mjx-container>in constant-normal
    form, we may want to ask how far away the point is from the plane. In other words,
    what is the minimum distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>needs
    to travel to lie on the plane?
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 给定任意点<mjx-container classname="MathJax" jax="SVG"></mjx-container>和常法式的平面<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，我们可能想知道点到平面的距离有多远。换句话说，<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>需要移动多少才能在平面上。
- en: 'We can frame this differently if we construct a plane <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>containing <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    is parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    which we can do in point-normal form using <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>as the point and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>''s normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    the normal:'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构造一个包含<mjx-container classname="MathJax" jax="SVG"></mjx-container>的平面<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>并且平行于<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，我们可以使用点法式，其中<mjx-container classname="MathJax" jax="SVG"></mjx-container>作为点，<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的法向量作为法向量：
- en: With two parallel planes, we can frame the problem as finding the distance between
    the two planes. This becomes trivial using their constant-normal form since it
    allows us to take the difference between their distance components <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有了两个平行平面，我们可以将问题构造为找到两个平面之间的距离。使用它们的常法式使这变得微不足道，因为它允许我们取其距离分量<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>的差异。
- en: 'So let''s find <mjx-container classname="MathJax" jax="SVG"></mjx-container>''s
    distance using the <mjx-container classname="MathJax" jax="SVG"></mjx-container>equation
    we learned about:'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们使用我们学到的方程式来找到<mjx-container classname="MathJax" jax="SVG"></mjx-container>的距离：
- en: 'With two distances <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>from the planes <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>the solution simply becomes:'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过平面的两个距离<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，解决方案简化为：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'So, to simplify, given a plane <mjx-container classname="MathJax" jax="SVG"></mjx-container>having
    a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>and distance
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can calculate
    a point <mjx-container classname="MathJax" jax="SVG"></mjx-container>''s distance
    from <mjx-container classname="MathJax" jax="SVG"></mjx-container>like so:'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，给定一个法线为<mjx-container classname="MathJax" jax="SVG"></mjx-container>距离为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的平面，我们可以这样计算点<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>到<mjx-container classname="MathJax" jax="SVG"></mjx-container>的距离：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: The distance may be positive or negative depending on which side of the plane
    the point is on.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 距离可能是正数或负数，这取决于点位于平面的哪一侧。
- en: Projecting a point onto a plane
  id: totrans-split-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影点到平面上
- en: A case where calculating a point's distance from a plane becomes useful is,
    for example, if you want to project a point onto a plane.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 计算点到平面的距离变得有用的一个情况是，例如，如果你想将一个点投影到平面上。
- en: 'Given a point <mjx-container classname="MathJax" jax="SVG"></mjx-container>which
    we want to project onto plane <mjx-container classname="MathJax" jax="SVG"></mjx-container>whose
    normal is <mjx-container classname="MathJax" jax="SVG"></mjx-container>and distance
    is <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can do that
    fairly easily. First, let''s define <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    the point''s distance from the plane:'
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个点<mjx-container classname="MathJax" jax="SVG"></mjx-container>我们希望投影到法线为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>距离为<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>的平面上，我们可以相对容易地做到这一点。首先，让我们定义<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>作为点到平面的距离：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Multiplying the plane''s normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>by
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>gives us a vector
    which when added to <mjx-container classname="MathJax" jax="SVG"></mjx-container>projects
    it onto the plane. Let''s call the projected point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>:'
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将平面的法线<mjx-container classname="MathJax" jax="SVG"></mjx-container>乘以<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>得到一个向量，将其加到<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>可以将其投影到平面上。我们将投影后的点称为<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: The projection occurs along the plane's normal, which is sometimes useful. However,
    it is much more useful to be able to project a point onto a plane along an *arbitrary*
    direction instead. Doing that boils down finding the point of intersection of
    a line and a plane.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 投影沿着平面的法线进行，这有时是有用的。然而，能够沿着*任意*方向将点投影到平面上则更加有用。这涉及到找到直线和平面的交点。
- en: Line-plane intersection
  id: totrans-split-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线平面交点
- en: We can describe lines in 3D space using a point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    The normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    the line's orientation, while the point <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    a point which the line passes through.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个点<mjx-container classname="MathJax" jax="SVG"></mjx-container>和法线<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>描述三维空间中的直线。法线<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>描述了线的方向，而点<mjx-container classname="MathJax" jax="SVG"></mjx-container>描述了线通过的点。
- en: In this chapter, the line will be composed of the point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    while the plane—given in constant-normal form—has a normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and a distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，线由点<mjx-container classname="MathJax" jax="SVG"></mjx-container>和法线<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>组成，而平面——以常法形式给出——具有法线<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和距离<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>。
- en: Our goal will be to find a distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>needs to travel along
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>such that it lies
    on the plane.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到一个距离<mjx-container classname="MathJax" jax="SVG"></mjx-container>，使得<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>沿着<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>移动，使其位于平面上。
- en: We can figure out the distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    we'd need to travel if <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>were parallel, which
    is what we did when projecting along the plane's normal.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算出<mjx-container classname="MathJax" jax="SVG"></mjx-container>需要移动的距离，如果<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>是平行的，这就是我们在投影平面法线时所做的。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Let''s try projecting <mjx-container classname="MathJax" jax="SVG"></mjx-container>along
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>using <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>as a scalar like so:'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用<mjx-container classname="MathJax" jax="SVG"></mjx-container>作为标量来沿着<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>投影<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'We''ll visualize <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    a red point:'
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将<mjx-container classname="MathJax" jax="SVG"></mjx-container>视为一个红点：
- en: As <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>become parallel, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>gets us closer and closer to the
    correct solution. However, as the angle between <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>increases,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes increasingly
    too small.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>变得平行时，<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>使我们越来越接近正确的解。然而，随着<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>和<mjx-container classname="MathJax" jax="SVG"></mjx-container>之间的角度增加，<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>变得越来越小。
- en: Here, the dot product comes in handy. For two vectors <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    the dot product is defined as
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，点积非常有用。对于两个向量<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，点积定义为
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: where <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the angle
    between <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<mjx-container classname="MathJax" jax="SVG"></mjx-container>是<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>之间的角度。
- en: Consider the dot product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>. Since both normals
    are unit vectors whose magnitudes are 1
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的点积。由于两个法线都是单位向量，其大小为1
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: we can remove their magnitudes from the equation,
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从方程中消去它们的大小，
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: making the dot product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>the cosine of the
    angle between them.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 的点积成为它们之间角度的余弦。
- en: For two vectors, the cosine of their angles approaches 1 as the vectors become
    increasingly parallel, and approaches 0 as they become perpendicular.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个向量，它们的夹角余弦随着向量变得越来越平行而接近 1，随着向量变得越来越垂直而接近 0。
- en: 'Since <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes
    increasingly too small as <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>become more perpendicular,
    we can use <mjx-container classname="MathJax" jax="SVG"></mjx-container>as a denominator
    for <mjx-container classname="MathJax" jax="SVG"></mjx-container>. We''ll assign
    this scaled-up version of <mjx-container classname="MathJax" jax="SVG"></mjx-container>to
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在两个向量变得越来越垂直时，<mjx-container classname="MathJax" jax="SVG"></mjx-container>
    变得越来越小，我们可以用它作为 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    的分母。我们将这个放大版本的 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 赋给
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'With <mjx-container classname="MathJax" jax="SVG"></mjx-container>as our scaled-up
    distance, we find the point of intersection <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>via:'
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们放大的距离，我们通过以下方法找到交点：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'We can now get rid of <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    which was defined as <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    giving us the full equation for <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以摆脱被定义为 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 的
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>，从而得到 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 的完整方程：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Putting this into code, we get:'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些转化为代码，我们得到：
- en: '[PRE0]'
  id: totrans-split-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, our code is not completely yet. In the case where the line is parallel
    to the plane's surface, the line and plane do not intersect.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的代码还没有完全完成。在直线与平面表面平行的情况下，直线和平面不相交。
- en: That happens when <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are perpendicular,
    in which case their dot product is zero. So if <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, the line and plane do not intersect. This gives us
    an easy test we can add to our code to yield a result of "no intersection".
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 垂直时，它们的点积为零。因此，如果 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，则直线和平面不相交。这给了我们一个可以添加到代码中的简单测试，以产生“无交点”的结果。
- en: However, for many applications we'll want to treat being *almost* parallel as
    actually being parallel. To do that, we can check whether the dot product is smaller
    than some very small number—customarily called epsilon
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于许多应用场景，我们希望将*几乎*平行视为实际平行。为了做到这一点，我们可以检查点积是否小于某个非常小的数值——通常称为 epsilon。
- en: '[PRE1]'
  id: totrans-split-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See if you can figure out why Mathf.Abs is used here. We'll cover it later,
    so you'll see if you're right.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能否弄清楚为什么在这里使用 Mathf.Abs。我们稍后会详细介绍，所以你会知道自己是否正确。
- en: We'll take a look at how to select the value of epsilon in a later chapter on
    two plane intersections.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的一章中讨论如何选择 epsilon 的值，用于两个平面的交点。
- en: 'With this, our line-plane intersection implementation becomes:'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的线平面交点实现变成了：
- en: '[PRE2]'
  id: totrans-split-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rays and lines
  id: totrans-split-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 射线和直线
- en: We've been talking about line-plane intersections, but I've been lying a bit
    by visualizing ray-plane intersections instead for visual clarity.
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在谈论线与平面的交点，但为了视觉上的清晰度，我有点撒谎，其实是在想射线与平面的交点。
- en: A ray and a line are very similar; they're both represented through a normal
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and a point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 射线和直线非常相似；它们都通过一个法向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    和一个点 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 表示。
- en: 'The difference is that a ray (colored red) extends in the direction of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>away from <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, while a line (colored green) extends in the other
    direction as well:'
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于射线（红色）朝 远离扩展，而线段（绿色）朝另一个方向扩展：
- en: 'What this means for intersections is that a ray will not intersect planes when
    traveling backward along its normal:'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着射线沿其法向后退时不会与平面相交：
- en: Our implementation for ray-plane intersections will differ from our existing
    line-plane intersection implementation only in that it should yield a result of
    "no intersection" when the ray's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    pointing "away" from the plane's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>at
    an obtuse angle.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的射线-平面交点实现与现有的线-平面交点实现不同，只是在射线的法向量 指向平面的法向量 为钝角时应得到 "无交点" 的结果。
- en: 'Since <mjx-container classname="MathJax" jax="SVG"></mjx-container>represents
    how far to travel along the normal to reach the point of intersection, we could
    yield "no intersection" when <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes
    negative:'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 表示沿法向量前进到达交点的距离，所以当 变为负数时我们可以得到 "无交点" 的结果：
- en: '[PRE3]'
  id: totrans-split-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But then we'd have to calculate <mjx-container classname="MathJax" jax="SVG"></mjx-container>first.
    That's not necessary since <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes
    negative as a consequence of the dot product <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>being a negative number when <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>are
    at an obtuse angle between 90° and 180°.
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后我们必须首先计算 。由于 和 之间的角度为90°至180°之间，所以这并不必要。
- en: If this feels non-obvious, it helps to remember that the dot product encodes
    the cosine of the angle between its two component vectors, which is why the dot
    product becomes negative for obtuse angles.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来不明显，记住点乘编码其两个分量向量之间的余弦值，这就是为什么在钝角时点乘的结果变为负数。
- en: 'Knowing that, we can change our initial "parallel normals" test from this:'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 知道了这一点，我们可以将初始的 "法向量平行" 测试改为：
- en: '[PRE4]'
  id: totrans-split-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To this:'
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点：
- en: '[PRE5]'
  id: totrans-split-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <mjx-container classname="MathJax" jax="SVG"></mjx-container>check covers
    both the *"line parallel to plane"* case *and* the case where the two normal vectors
    are at an obtuse angle.
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 检查同时涵盖了 *"平行于平面的直线"* 情况 *以及* 两个法向量成钝角的情况。
- en: 'Note: <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the symbol
    for epsilon.'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意： 是表示epsilon的符号。
- en: Plane-plane intersection
  id: totrans-split-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平面-平面交点
- en: The intersection of two planes forms an infinite line.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: 两个平面的交点形成一个无限长的直线。
- en: 'As a quick refresher: lines in 3D space are represented using a point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>where normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    the line''s orientation, while the point <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    a point which the line passes through.'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下：在三维空间中，线段用一个点 和法向量 来表示，其中法向量 描述了线段的方向，而点 是线段经过的一个点。
- en: Let's take two planes <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>whose normals are
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们取两个平面的法向量分别为 和 。
- en: Finding the direction vector of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s intersection is
    deceptively simple. Since the line intersection of two planes lies on the surface
    of both planes, the line must be perpendicular to both plane normals, which means
    that the direction of the intersection is the cross product of the two plane normals.
    We'll assign it to <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 的方向向量看似简单。因为两个平面的交线位于两个平面的表面上，所以交线必须垂直于两个平面的法线，这意味着交线的方向是两个平面法线的叉积。我们将其赋值给
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: The magnitude of the cross product is equal to the [area of the parallelogram](https://en.wikipedia.org/wiki/Cross_product#/media/File:Cross_product_parallelogram.svg)
    formed by the two component vectors. This means that we can't expect the cross
    product to be a unit vector, so we'll normalize <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and assign the normalized direction vector to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
  zh: 叉积的大小等于两个分量向量形成的平行四边形的[面积](https://en.wikipedia.org/wiki/Cross_product#/media/File:Cross_product_parallelogram.svg)。这意味着我们不能期望叉积是单位向量，因此我们将对
    <mjx-container classname="MathJax" jax="SVG"></mjx-container> 进行归一化，并将归一化后的方向向量赋给
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: This gives us the intersection's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    Let's zoom in and see this close up.
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们交点的法线 <mjx-container classname="MathJax" jax="SVG"></mjx-container>。让我们放大看一看这个过程。
- en: But this is only half of the puzzle! We'll also need to find a point in space
    to represent the line of intersection (i.e. a point which the line passes through).
    We'll take a look at how to do just that, right after we discuss the no-intersection
    case.
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是问题的一半！我们还需要找到一个空间点来表示交线（即线通过的点）。我们将在讨论无交点情况之后详细讨论如何做到这一点。
- en: Handling parallel planes
  id: totrans-split-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理平行平面
- en: Two planes whose normals are parallel will never intersect, which is a case
    that we'll have to handle.
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: 两个法线平行的平面永远不会相交，这是一个我们必须处理的情况。
- en: The cross product of two parallel normals is <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>. So if <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    the planes do not intersect.
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
  zh: 两个平行法线的叉积是 <mjx-container classname="MathJax" jax="SVG"></mjx-container>。所以如果
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>，那么这两个平面不相交。
- en: As previously mentioned, for many applications we'll want to treat planes that
    are *almost* parallel as being parallel. This means that our plane-plane intersection
    procedure should yield a result of "no intersection" when the magnitude of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is less than some very small number
    called epsilon.
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，对于许多应用，我们希望将几乎平行的平面视为平行。这意味着我们的平面相交过程应在 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 的大小小于称为 epsilon 的非常小的数时产生“无交点”的结果。
- en: '[PRE6]'
  id: totrans-split-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But what should the value of epsilon be?
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但 epsilon 的值应该是多少？
- en: 'Given two normals <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>where the angle between
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, we can find a reasonable epsilon by charting <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>for different values of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个法线 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，其中 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 和 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    之间的角度是 <mjx-container classname="MathJax" jax="SVG"></mjx-container>，我们可以通过绘制
    <mjx-container classname="MathJax" jax="SVG"></mjx-container> 的不同值来找到一个合理的 epsilon：
- en: Both of the axes are [logarithmic](https://en.wikipedia.org/wiki/Logarithmic_scale).
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: 两个轴都是[对数](https://en.wikipedia.org/wiki/Logarithmic_scale)的。
- en: 'The relationship is linear: as the angle between the planes halves, so does
    the magnitude of the cross product of their normals. <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>yields a magnitude of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, and <mjx-container classname="MathJax" jax="SVG"></mjx-container>yields
    half of that.'
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关系是线性的：随着平面之间夹角减半，它们法向量的叉积大小也减半。<mjx-container classname="MathJax" jax="SVG"></mjx-container>的大小为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>的大小为它的一半。
- en: 'So to determine the epsilon, we can ask: how low does the angle in degrees
    need to become for us to consider two planes parallel? Given an angle <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, we can find the epsilon <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>via:'
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要确定 epsilon，我们可以问：角度需要多小（以度为单位）才能认为两个平面是平行的？给定角度<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，我们可以通过以下公式找到 epsilon：<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'If that angle is 1/256°, then we get:'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果那个角度是1/256°，我们得到：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: With this you can determine the appropriate epsilon based on how small the angle
    between the planes needs to be for you to consider them parallel. That will depend
    on your use case.
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，您可以根据平面之间的角度多小来确定适当的 epsilon。这将取决于您的使用情况。
- en: Finding a point of intersection
  id: totrans-split-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找交点
- en: Having computed the normal and handled parallel planes, we can move on to finding
    a point <mjx-container classname="MathJax" jax="SVG"></mjx-container>along the
    line of intersection.
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算法向量并处理平行平面后，我们可以继续找到沿交线的点<mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: Since the line describing a plane-plane intersection is infinite, there are
    infinitely many points we could choose as <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于描述平面-平面交点的线是无限的，我们可以选择无限多个点作为<mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: We can narrow the problem down by taking the plane parallel to the two plane
    normals <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and observing that it intersects
    the line at a single point.
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过取与两个平面法线平行的平面<mjx-container classname="MathJax" jax="SVG"></mjx-container>来缩小问题范围，并观察它在一点上的交点。
- en: Since the point lies on the plane parallel to the two plane normals, we can
    find it by exclusively traveling along those normals.
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该点位于与两个平面法线平行的平面上，我们可以通过沿着这些法线独占行进来找到它。
- en: 'The simplest case is the one where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are perpendicular.
    In that case, the solution is just <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    Here''s what that looks like visually:'
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>垂直的情况。在这种情况下，解决方案就是<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>。以下是其可视化效果：
- en: When dragging the slider, notice how the tip of the parallelogram gets further
    away from the point of intersection as the planes become more parallel.
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当拖动滑块时，请注意随着平面变得更加平行，平行四边形顶点离交点的距离增加。
- en: 'We can also observe that as we get further away from the point of intersection,
    the longer of the two vectors (colored red) pushes us further away from the point
    of intersection than the shorter (blue) vector does. This is easier to observe
    if we draw a line from the origin to the point of intersection:'
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以观察到，随着我们远离交点，较长的两个向量（红色）将我们远离交点，而较短的（蓝色）向量则不会。如果我们从原点到交点画一条线，这更容易观察：
- en: 'Let''s define <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>as the scaling factors
    that we apply to <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>(the result of which
    are the red and blue vectors). Right now we''re using the distance components
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>of the planes as the scaling factors:'
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>为我们应用于<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>和<mjx-container classname="MathJax" jax="SVG"></mjx-container>的缩放因子（其结果是红色和蓝色向量）。现在我们正在使用平面的距离分量<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>作为缩放因子：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: To solve this asymmetric pushing effect, we need to travel less in the direction
    of the longer vector as the planes become more parallel. We need some sort of
    "pulling factor" that adjusts the vectors such that their tip stays on the line
    as the planes become parallel.
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这种不对称的推力效应，我们需要沿着较长向量的方向行进较少。我们需要某种调整向量的“拉动因子”，使其尖端在平行平面上保持在直线上。
- en: Here our friend the dot product comes in handy yet again. When the planes are
    perpendicular the dot product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>equals 0, but as
    the planes become increasingly parallel, it approaches 1\. We can use this to
    gradually increase our yet-to-be-defined pulling factor.
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们的老朋友点积再次派上了用场。当平面垂直时，<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的点积等于0，但随着平面逐渐平行，它接近于1。我们可以利用这一点逐渐增加我们尚未定义的拉动因子。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: 'Let''s give the dot product <mjx-container classname="MathJax" jax="SVG"></mjx-container>the
    name <mjx-container classname="MathJax" jax="SVG"></mjx-container>to make this
    a bit less noisy:'
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给点积<mjx-container classname="MathJax" jax="SVG"></mjx-container>一个名字<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，以减少一些噪音：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: The perfect pulling factors happen to be the distance components <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>used as counterweights against each other!
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
  zh: 完美的拉动因子恰好是距离分量<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>作为彼此的抵消！
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: Consider why this might be. When <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are perpendicular,
    their dot product equals 0, which results in
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑为什么会这样。当<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>垂直时，它们的点积等于0，这导致
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: which we know yields the correct solution.
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这将产生正确的解。
- en: 'In the case where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are parallel, their
    dot product equals 1, which results in:'
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>平行的情况下，它们的点积等于1，导致：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mjx-container classname="MathJax" jax="SVG"></mjx-container>`'
- en: 'Because the absolute values of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are equal, it means
    that the magnitude of the two vectors—defined as <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>—is
    equal:'
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因为<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的绝对值相等，这意味着两个向量的大小—定义为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>—是相等的：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: This means that the magnitude of our vectors will become *more* equal as the
    planes become parallel, which is what we want!
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着随着平面变得平行，我们的向量大小将变得*更加*相等，这正是我们想要的！
- en: 'Let''s see this in action:'
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这一过程：
- en: The vectors stay on the line, but they become increasingly too short as <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>become parallel.
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
  zh: 向量保持在同一条直线上，但当<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>变得平行时，它们的长度逐渐变短。
- en: Yet again, we can use the dot product. Since we want the length of the vectors
    to increase as the planes become parallel, we can divide our scalars <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>by <mjx-container classname="MathJax" jax="SVG"></mjx-container>where
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the dot product
    of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>is the absolute value of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以使用点积。因为我们希望向量的长度随着平面变得平行而增加，我们可以将我们的标量<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>和<mjx-container classname="MathJax" jax="SVG"></mjx-container>除以<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，其中<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>是<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的点积，而<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>是<mjx-container classname="MathJax" jax="SVG"></mjx-container>的绝对值。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'The result of this looks like so:'
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果看起来是这样的：
- en: Using <mjx-container classname="MathJax" jax="SVG"></mjx-container>as the denominator
    certainly increases the size of the parallelogram, but by too much.
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<mjx-container classname="MathJax" jax="SVG"></mjx-container>作为分母确实会增加平行四边形的大小，但增幅过大。
- en: 'However, notice what happens when we visualize the quadrants of the parallelogram:'
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意当我们可视化平行四边形的象限时发生了什么：
- en: As the planes become more parallel, the point of intersection approaches the
    center of the parallelogram.
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
  zh: 随着平面变得更加平行，交点逼近平行四边形的中心。
- en: In understanding why that is, consider the effect that our denominator <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>has on the area of the parallelogram.
    When <mjx-container classname="MathJax" jax="SVG"></mjx-container>, both of the
    vectors forming the parallelogram double in length, which has the effect of quadrupling
    the area of the parallelogram.
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么是这样，请考虑我们的分母<mjx-container classname="MathJax" jax="SVG"></mjx-container>对平行四边形面积的影响。当<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>时，形成平行四边形的两个向量长度加倍，这导致平行四边形的面积增加四倍。
- en: This means that when we scale the component vectors of the parallelogram by
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们按照平行四边形的分量向量进行缩放时，
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-188
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'it has the effect of scaling the area of the parallelogram by:'
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有通过缩放平行四边形的面积的效果：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-190
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'To instead scale the *area* of the parallelogram by <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, we need to square <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>in the denominator:'
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过<mjx-container classname="MathJax" jax="SVG"></mjx-container>来缩放平行四边形的*面积*，我们需要将<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>在分母中平方：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: Squaring allows us to remove <mjx-container classname="MathJax" jax="SVG"></mjx-container>because
    the square of a negative number is positive.
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
  zh: 平方使我们可以去除 <mjx-container classname="MathJax" jax="SVG"></mjx-container>，因为负数的平方是正数。
- en: With this, our scalars <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>become
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的标量 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 变为：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-196
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'which scales the parallelogram such that its tip lies at the point of intersection:'
  id: totrans-split-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这会缩放平行四边形，使其顶点位于交点处：
- en: 'Putting all of this into code, we get:'
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
  zh: 把所有这些放进代码，我们得到：
- en: '[PRE7]'
  id: totrans-split-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Based on code from [Real-Time Collision Detection by Christer Ericson](/blog/planes#further-reading)
  id: totrans-split-200
  prefs: []
  type: TYPE_NORMAL
  zh: 基于来自 [Christer Ericson 的《实时碰撞检测》](/blog/planes#further-reading) 的代码。
- en: 'Which through some mathematical magic can be optimized down to:'
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些数学魔法，可以将其优化为：
- en: '[PRE8]'
  id: totrans-split-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How this optimization works can be found in chapter 5.4.4 of [Real-Time Collision
    Detection by Christer Ericson](/blog/planes#further-reading).
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如何进行这种优化可以在 [Christer Ericson 的《实时碰撞检测》](/blog/planes#further-reading) 的第5.4.4章找到。
- en: 'This completes our plane-plane intersection implementation:'
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的平面-平面相交实现：
- en: '[PRE9]'
  id: totrans-split-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By the way, an interesting property of only traveling along the plane normals
    is that it yields the point on the line of intersection that is closest to the
    origin. Cool stuff!
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，沿着平面法线旅行的一个有趣特性是，它给出了与原点最近的交线上的点。很酷的东西！
- en: Three plane intersection
  id: totrans-split-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三平面相交
- en: 'Given three planes <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, there are five possible configurations
    in which they intersect or don''t intersect:'
  id: totrans-split-208
  prefs: []
  type: TYPE_NORMAL
  zh: 给定三个平面 <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，它们有五种可能的配置，可以相交或不相交：
- en: All three planes are parallel, with none of them intersecting each other.
  id: totrans-split-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有三个平面都平行，彼此不相交。
- en: Two of the planes are parallel, and the third plane intersects the other two.
  id: totrans-split-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个平面平行，第三个平面与其他两个相交。
- en: All three planes intersect along a single line.
  id: totrans-split-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有三个平面沿一条直线相交。
- en: The three planes intersect each other in pairs, forming three parallel lines
    of intersection.
  id: totrans-split-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个平面两两相交，形成三条平行的相交线。
- en: All three planes intersect each other at a single point.
  id: totrans-split-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有三个平面在一个点相交。
- en: When finding the point of intersection, we'll first need to determine whether
    all three planes intersect at a single point—which for configurations 1 through
    4, they don't.
  id: totrans-split-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到交点时，我们首先需要确定所有三个平面是否在一个点相交——对于配置1到4，它们不会相交。
- en: 'Given <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>as the plane normals for <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can determine
    whether the planes intersect at a single point with the formula:'
  id: totrans-split-215
  prefs: []
  type: TYPE_NORMAL
  zh: 给定平面法线 <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，我们可以使用以下公式确定平面是否在一个点相交：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-216
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: When I first saw this, I found it hard to believe this would work for all cases.
    Still, it does! Let's take a deep dive to better understand what's happening.
  id: totrans-split-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次看到这个时，我觉得难以相信这对所有情况都有效。但它确实有效！让我们深入了解发生了什么。
- en: Two or more planes are parallel
  id: totrans-split-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个或更多平面平行
- en: 'We''ll start with the configurations where two or more planes are parallel:'
  id: totrans-split-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从两个或更多平面平行的配置开始：
- en: If <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are parallel then <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is a vector whose magnitude is zero.
  id: totrans-split-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 平行，则 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 是一个大小为零的向量。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-221
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'And since the dot product is a multiple of the magnitudes of its component
    vectors:'
  id: totrans-split-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于点乘是其组分向量的大小的倍数：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-223
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: the final result is zero whenever <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are parallel.
  id: totrans-split-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，当 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 平行时，结果为零。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-225
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: This takes care of the "all-planes-parallel" configuration, and the configuration
    where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are parallel
  id: totrans-split-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了“所有平面平行”配置，以及 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    和 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 平行的配置。
- en: With that, let's consider the case where <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>is parallel to either <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>or <mjx-container classname="MathJax" jax="SVG"></mjx-container>but
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are not parallel to each other.
  id: totrans-split-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们考虑 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 平行于 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 或 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 的情况，但 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    和 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 之间不平行。
- en: Let's take the specific case where <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>but <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is parallel to neither.
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 平行于 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，但 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 既不平行于这个也不平行于那个的特定情况。
- en: Here the cross product <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    a vector (colored red) that's perpendicular to both <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，叉乘 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 是一个向量（红色），它垂直于
    <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>。
- en: 'Since <mjx-container classname="MathJax" jax="SVG"></mjx-container>is parallel
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>, that means that
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>is also perpendicular
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>. As we''ve learned,
    the dot product of two perpendicular vectors is zero, meaning that:'
  id: totrans-split-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 平行于 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，这意味着 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 也垂直于 <mjx-container classname="MathJax" jax="SVG"></mjx-container>。正如我们所学，两个垂直向量的点积为零，这意味着：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-231
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: This also holds in the case where <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>instead
    of <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 平行于 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 而非 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 的情况。
- en: Parallel lines of intersection
  id: totrans-split-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平行的交线
- en: We've demonstrated that two of the three normals being parallel results in <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>. But what about the configurations
    where the three planes intersect along parallel lines? Those configurations have
    no parallel normals.
  id: totrans-split-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经证明，其中三个法线中有两个平行会导致 <mjx-container classname="MathJax" jax="SVG"></mjx-container>。但是对于三个平面沿平行线交叉的配置，这些配置没有平行的法线。
- en: As we learned when looking at plane-plane intersections, the cross product of
    two plane normals gives us the direction vector of the planes' line of intersection.
  id: totrans-split-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们观察平面平行交线时，两个平面法线的叉乘给出了平面交线的方向向量。
- en: When all of the lines of intersection are parallel, all of the plane normals
    defining those lines are perpendicular to them.
  id: totrans-split-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有交线都平行时，定义这些线的平面法线都垂直于它们。
- en: Yet again, because the dot product of perpendicular vectors is 0 we can conclude
    that <mjx-container classname="MathJax" jax="SVG"></mjx-container>for these configurations
    as well.
  id: totrans-split-237
  prefs: []
  type: TYPE_NORMAL
  zh: 再次因为垂直向量的点积为 0，我们可以得出这些配置下 <mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: 'We can now begin our implementation. As usual, we''ll use an epsilon to handle
    the *"roughly parallel"* case:'
  id: totrans-split-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始我们的实现。像往常一样，我们将使用一个 epsilon 来处理 *"大致平行"* 的情况：
- en: '[PRE10]'
  id: totrans-split-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Computing the point intersection
  id: totrans-split-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算交点
- en: 'We want to find the point at which our three planes <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>intersect:'
  id: totrans-split-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想找到三个平面 <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 的交点：
- en: Some of what we learned about two-plane intersections will come into play here.
    Let's start by taking the line of intersection for <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    varying the position of <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    You'll notice that the point of intersection is the point at which <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>intersects the line.
  id: totrans-split-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两平面交点部分学到的一些知识将在这里发挥作用。让我们从取得 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    和 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 的交线开始，并改变 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 的位置。你会注意到交点就是 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 与这条线相交的点。
- en: When <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s distance
    from the origin is 0, the vector pointing from the origin to the point of intersection
    is parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>(and
    perpendicular to <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s
    normal).
  id: totrans-split-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 距离原点为 0 时，从原点指向交点的向量与
    <mjx-container classname="MathJax" jax="SVG"></mjx-container> 平行（且垂直于 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 的法线）。
- en: This vector—let's call it <mjx-container classname="MathJax" jax="SVG"></mjx-container>—will
    play a large role in computing the point of intersection.
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向量，我们称之为 <mjx-container classname="MathJax" jax="SVG"></mjx-container>，在计算交点时起到了重要作用。
- en: We can find <mjx-container classname="MathJax" jax="SVG"></mjx-container>through
    the cross product of two other vectors <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>. The first of those,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, is just <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>'s normal.
  id: totrans-split-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两个其他向量的叉乘我们可以找到 <mjx-container classname="MathJax" jax="SVG"></mjx-container>，这两个向量分别是
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>，第一个只是 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 的法线。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-246
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: The latter vector can be found via the equation
  id: totrans-split-247
  prefs: []
  type: TYPE_NORMAL
  zh: 后一个向量可以通过方程找到：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-248
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are the distances in the constant-normal
    form of planes <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-249
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 是平面 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 和 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    的常法形式中的距离。
- en: 'With <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>defined, we assign their cross product
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 的定义，我们将它们的叉乘赋给 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-251
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Let''s see what it looks like:'
  id: totrans-split-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是什么样子：
- en: Hmm, not quite long enough. <mjx-container classname="MathJax" jax="SVG"></mjx-container>certainly
    points in the right direction, but to make <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>'s tip lie on the line of intersection, we need to compute
    some scaling factor for <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-253
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，还不够长。 <mjx-container classname="MathJax" jax="SVG"></mjx-container>确实指向了正确的方向，但要使
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>的顶端位于交线上，我们需要计算一些缩放因子
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: 'As it turns out, we''ve already computed this scaling factor:'
  id: totrans-split-254
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们已经计算出了这个缩放因子：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-255
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: The product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>—let's
    call that <mjx-container classname="MathJax" jax="SVG"></mjx-container>—can be
    thought to represent how parallel <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s
    normal is to the line intersection of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-256
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>的乘积——我们称之为 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>——可以被认为表示 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>的法向量与 <mjx-container classname="MathJax" jax="SVG"></mjx-container>交线的平行程度。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>approaches <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>as <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>'s normal becomes parallel to the line of intersection
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, and approaches
    0 as they become perpendicular.
  id: totrans-split-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <mjx-container classname="MathJax" jax="SVG"></mjx-container>的法向量与交线平行时，<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>趋近于 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，而它们垂直时趋近于 0。
- en: We want the <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s
    magnitude to increase as <mjx-container classname="MathJax" jax="SVG"></mjx-container>decreases,
    so we'll make <mjx-container classname="MathJax" jax="SVG"></mjx-container>the
    scaling factor for <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 <mjx-container classname="MathJax" jax="SVG"></mjx-container>的大小随着 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的减小而增加，因此我们将 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>作为 <mjx-container classname="MathJax" jax="SVG"></mjx-container>的缩放因子。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-259
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Fully expanded, the equation for <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes:'
  id: totrans-split-260
  prefs: []
  type: TYPE_NORMAL
  zh: 完全展开，<mjx-container classname="MathJax" jax="SVG"></mjx-container>的方程为：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-261
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: Bam! The problem is now reduced to traveling along the direction of the line
    intersection until we intersect with <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-262
  prefs: []
  type: TYPE_NORMAL
  zh: 啪！现在问题已经简化为沿着交线方向行进，直到与 <mjx-container classname="MathJax" jax="SVG"></mjx-container>相交。
- en: We could use our knowledge of line-plane intersections to solve this, but there
    is a more efficient approach I want to demonstrate.
  id: totrans-split-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用我们对直线平面交点的知识来解决这个问题，但我想展示一种更有效的方法。
- en: It involves finding a scaling factor for the direction vector <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>that scales it such that it's tip
    ends at <mjx-container classname="MathJax" jax="SVG"></mjx-container>. Let's call
    this direction vector <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它涉及寻找一个方向向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container>的缩放因子，使其顶端位于
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>。让我们称这个方向向量为 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>。
- en: There's one observation we can make that simplifies that. Since <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is perpendicular to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>'s normal, the distance from <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>'s tip to <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>along the direction vector <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>is the same as the distance from the origin to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>along that same direction.
  id: totrans-split-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出一个简化的观察结论。由于<mjx-container classname="MathJax" jax="SVG"></mjx-container>垂直于<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的法向量，从<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>的尖端到<mjx-container classname="MathJax" jax="SVG"></mjx-container>沿着方向向量<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的距离与从原点到<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>沿着相同方向的距离相同。
- en: With that, consider the vector <mjx-container classname="MathJax" jax="SVG"></mjx-container>where
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are the normal and distance of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-266
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到向量<mjx-container classname="MathJax" jax="SVG"></mjx-container>，其中<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>是<mjx-container classname="MathJax" jax="SVG"></mjx-container>的法向量和距离。
- en: 'If <mjx-container classname="MathJax" jax="SVG"></mjx-container>were parallel
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>, then <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>would be the scaling factor we need,
    but let''s see what happens with <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<mjx-container classname="MathJax" jax="SVG"></mjx-container>与<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>平行，则<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>将是我们所需的缩放因子，但让我们看看<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>会发生什么：
- en: As <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>become less parallel, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>becomes increasingly too short.
  id: totrans-split-268
  prefs: []
  type: TYPE_NORMAL
  zh: 随着<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>变得不那么平行，<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>变得越来越短。
- en: One thing to note as well is that even when <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>are
    completely parallel, <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    still too short, which is due to <mjx-container classname="MathJax" jax="SVG"></mjx-container>not
    being a unit vector. If we normalize <mjx-container classname="MathJax" jax="SVG"></mjx-container>prior
    to multiplying with <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    problem goes away.
  id: totrans-split-269
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的一点是，即使<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>完全平行，由于<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>不是单位向量，<mjx-container classname="MathJax" jax="SVG"></mjx-container>仍然太短了。如果我们在乘以<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>之前将其归一化，这个问题就解决了。
- en: 'But we''re getting ahead of ourselves—we won''t need to normalize <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>. Let''s take a fresh look at how
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>is defined:'
  id: totrans-split-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们在这里过早地——我们不需要对<mjx-container classname="MathJax" jax="SVG"></mjx-container>进行归一化。让我们重新审视一下<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的定义：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-271
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: Having defined <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can simplify
    this to
  id: totrans-split-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将<mjx-container classname="MathJax" jax="SVG"></mjx-container>定义为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>之后，我们可以简化为
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-273
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: Earlier I mentioned that we could think of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>as a measure of how parallel <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>'s normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>(the line intersection
    of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>). That's correct, but it's not
    the whole truth!
  id: totrans-split-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，我们可以将<mjx-container classname="MathJax" jax="SVG"></mjx-container>看作是<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>与<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>的正交正面的测量标准。这是正确的，但不是全部的真相！
- en: 'Since the dot product is a multiple of the magnitudes of its component vectors,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>also encodes the
    magnitude of <mjx-container classname="MathJax" jax="SVG"></mjx-container>. Hence,
    scaling <mjx-container classname="MathJax" jax="SVG"></mjx-container>by <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>does two things:'
  id: totrans-split-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于点积是其组成向量的大小的倍数，<mjx-container classname="MathJax" jax="SVG"></mjx-container>还编码了<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的大小。因此，通过<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>乘以<mjx-container classname="MathJax" jax="SVG"></mjx-container>做两件事：
- en: it normalizes <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    and
  id: totrans-split-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将<mjx-container classname="MathJax" jax="SVG"></mjx-container>归一化，并且
- en: it increases the length of <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    it becomes less parallel with <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它增加了<mjx-container classname="MathJax" jax="SVG"></mjx-container>的长度，因为它与<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>变得不那么平行。
- en: 'So <mjx-container classname="MathJax" jax="SVG"></mjx-container>is both the
    scaling factor we need for <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    as well as <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，<mjx-container classname="MathJax" jax="SVG"></mjx-container>既是我们所需的<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的缩放因子，也是<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>：
- en: We've got our solution! Let's do a quick overview.
  id: totrans-split-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了解决方案！让我们快速回顾一下。
- en: 'We define <mjx-container classname="MathJax" jax="SVG"></mjx-container>as:'
  id: totrans-split-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将<mjx-container classname="MathJax" jax="SVG"></mjx-container>定义为：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-281
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'We''ll redefine <mjx-container classname="MathJax" jax="SVG"></mjx-container>to
    include <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新定义<mjx-container classname="MathJax" jax="SVG"></mjx-container>，以包含<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-283
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Our denominator, <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    remains defined as :'
  id: totrans-split-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的分母<mjx-container classname="MathJax" jax="SVG"></mjx-container>仍然定义为：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-285
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'With this, we find our point of intersection <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>by adding <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>together and scaling
    them by <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们通过将<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>相加并按<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>缩放，找到了我们的交点：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-287
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Which fully expanded becomes:'
  id: totrans-split-288
  prefs: []
  type: TYPE_NORMAL
  zh: 完全展开后变成：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-289
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Putting this into code, we get:'
  id: totrans-split-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将此放入代码中，我们得到：
- en: '[PRE11]'
  id: totrans-split-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Parting words
  id: totrans-split-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分手的话
- en: Thanks for reading!
  id: totrans-split-293
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢阅读！
- en: A whole lot of hours went into writing and building the visualizations for this
    post, so I hope it achieved its goal of helping you build an intuitive mental
    model of planes.
  id: totrans-split-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写和构建本文可视化过程中，花费了大量的时间，希望它达到了帮助您建立平面直观心理模型的目标。
- en: Massive thanks goes to [Gunnlaugur Þór Briem](https://www.linkedin.com/in/gunnlaugur-briem/)
    and [Eiríkur Fannar Torfason](https://eirikur.dev/) for providing invaluable feedback
    on this post. I worked with them at [GRID](https://grid.is/); they're fantastic
    people to work with and be around.
  id: totrans-split-295
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢[Gunnlaugur Þór Briem](https://www.linkedin.com/in/gunnlaugur-briem/)和[Eiríkur
    Fannar Torfason](https://eirikur.dev/)在这篇文章中提供的宝贵反馈。我在[GRID](https://grid.is/)与他们合作过；他们是非常棒的人，与他们一起工作和相处是一种享受。
- en: — Alex Harri
  id: totrans-split-296
  prefs: []
  type: TYPE_NORMAL
  zh: — Alex Harri
- en: 'PS: If you''re interested in taking a look at how the visualizations in this
    post were built, this website is [open source on GitHub](https://github.com/alexharri/website).'
  id: totrans-split-297
  prefs: []
  type: TYPE_NORMAL
  zh: PS：如果你有兴趣了解本文中可视化的构建方式，请查看这个网站在[Github上的开源](https://github.com/alexharri/website)。
- en: Further reading
  id: totrans-split-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: I highly recommend checking out [Real-Time Collision Detection by Christer Ericson](https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323).
    If you're building applications using 3D geometry, it will prove to be an incredibly
    useful resource. This post would not exist were it not for this book—especially
    the two chapters on the intersections of planes.
  id: totrans-split-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐阅读[克里斯特·埃里克森的《实时碰撞检测》](https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323)。如果你在构建使用3D几何的应用程序，它将证明是一个非常有用的资源。如果没有这本书——特别是关于平面相交的两章——这篇文章不会存在。
- en: I recently analyzed the edit performance in [Arkio](https://www.arkio.is/) and
    noticed that a method for solving three-plane intersections took around half of
    the total compute time when recalculating geometry. By implementing the more efficient
    method for three-plane intersections described in the book, we made the method
    **~500% faster**, increasing Arkio's edit performance by over **1.6x**. Crazy
    stuff!
  id: totrans-split-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我最近分析了[Arkio](https://www.arkio.is/)中的编辑性能，并注意到在重新计算几何时，解决三平面相交的方法占用了大约一半的总计算时间。通过实施书中描述的更有效的三平面相交方法，我们使这个方法**快了约500%**，将Arkio的编辑性能提高了**超过1.6倍**。疯狂的事情！
- en: I started writing this post to understand how the three-plane intersection method
    worked. However, I felt that readers would need a better foundation and understanding
    of planes for this post to be of any value. In building that foundation, this
    post ended up quite a bit longer than I intended.
  id: totrans-split-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始写这篇文章是为了理解三平面相交方法的工作原理。然而，我觉得读者需要对平面有更好的基础和理解，才能使这篇文章有价值。在建立这个基础过程中，这篇文章比我预期的长了很多。
- en: Anyway, it's a great book. [Check it out](https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323)!
  id: totrans-split-302
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这是一本很棒的书。[去看看吧](https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323)!
- en: </main>
  id: totrans-split-303
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
