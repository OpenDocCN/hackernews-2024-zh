- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:35:26'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Planes in 3D space
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://alexharri.com/blog/planes](https://alexharri.com/blog/planes)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <main class="css-fkkl8v">
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Planes in 3D space
  id: totrans-split-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: April 27, 2024
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: A plane in 3D space can be thought of as a flat surface that stretches infinitely
    far, splitting space into two halves.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: Planes have loads of uses in applications that deal with 3D geometry. I've mostly
    been working with them in the context of an [architectural modeler](https://www.arkio.is/),
    where geometry is defined in terms of planes and their intersections.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Learning about planes felt abstract and non-intuitive to me. *“Sure, that's
    a plane equation, but what do I do with it? What does a plane look like?”* It
    took some time for me to build an intuition for how to reason about and work with
    them.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: In writing this, I want to provide you with an introduction that focuses on
    building a practical, intuitive understanding of planes. I hope to achieve this
    through the use of visual (and interactive!) explanations which will accompany
    us as we work through progressively more complex problems.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: With that out of the way, let's get to it!
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: Describing planes
  id: totrans-split-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to describe planes, such as through
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: a point in 3D space and a normal,
  id: totrans-split-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: three points in 3D space, forming a triangle, or
  id: totrans-split-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a normal and a distance from an origin.
  id: totrans-split-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throughout this post, the term *normal* will refer to a *normalized direction
    vector* (unit vector) whose magnitude (length) is equal to 1, typically denoted
    by <mjx-container classname="MathJax" jax="SVG"></mjx-container>where <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the point-and-normal case, here''s an example of a plane described
    by a point in 3D space <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: The normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    the plane's orientation, where the surface of the plane is perpendicular to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, while the point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>describes *a* point on the plane.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: We described this plane in terms of a single point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, but keep in mind that this plane—let's call it <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>—contains infinitely many points.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: If <mjx-container classname="MathJax" jax="SVG"></mjx-container>were described
    by one of those other points contained by <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    we would be describing the exact same plane. This is a result of the infinite
    nature of planes.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: This way of describing planes—in terms of a point and a normal—is the [point-normal
    form](https://en.wikipedia.org/wiki/Euclidean_planes_in_three-dimensional_space#Point%E2%80%93normal_form_and_general_form_of_the_equation_of_a_plane)
    of planes.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also describe a plane using three points in 3D space <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, <mjx-container classname="MathJax" jax="SVG"></mjx-container>forming
    a triangle:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用三维空间中的三个点 <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 来描述一个平面形成的三角形：
- en: The triangle forms an implicit plane, but for us to be able to do anything useful
    with the plane we'll need to calculate its normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>. Once we've calculated the plane's normal, we can use
    that normal along with one of the triangle's three points to describe the plane
    in point-normal form.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个三角形形成一个隐式平面，但为了能够对平面进行有用的操作，我们需要计算它的法向量 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>。一旦我们计算出平面的法向量，我们就可以使用这个法向量以及三角形的一个顶点来描述平面的点法式。
- en: As mentioned earlier, the normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describing
    a plane is a unit vector (<mjx-container classname="MathJax" jax="SVG"></mjx-container>)
    perpendicular to the plane.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，描述平面的法向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    是一个垂直于平面的单位向量 (<mjx-container classname="MathJax" jax="SVG"></mjx-container>)。
- en: We can use <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>as two edge vectors
    that are parallel to the plane's surface.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 作为平面表面平行的两个边向量。
- en: By virtue of being parallel to the plane's surface, the vectors <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>are perpendicular to the plane's normal. This is where
    the cross product becomes useful to us.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与平面表面平行，向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和
    <mjx-container classname="MathJax" jax="SVG"></mjx-container> 都垂直于平面的法向量。这就是叉乘对我们有用的地方。
- en: The [cross product](https://en.wikipedia.org/wiki/Cross_product) takes in two
    vectors <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and returns a vector <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>that is perpendicular to both of
    them.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[叉乘](https://en.wikipedia.org/wiki/Cross_product) 接受两个向量 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 和 <mjx-container classname="MathJax" jax="SVG"></mjx-container>，返回一个垂直于它们的向量
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>。'
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'For example, given the vectors <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, their cross product
    is the vector <mjx-container classname="MathJax" jax="SVG"></mjx-container>, which
    we''ll label <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，它们的叉乘是向量 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，我们将其标记为 <mjx-container classname="MathJax" jax="SVG"></mjx-container>：
- en: This explanation is simple on purpose. We'll get into more detail about the
    cross product later on.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释故意简单。稍后我们将更详细地讨论叉乘。
- en: 'Because the edge vectors of the triangle, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    are both parallel to the triangle''s surface, their cross product will be perpendicular
    to the triangle''s surface. Let''s name the cross product of our two edge vectors
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为三角形的边向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 都与三角形的表面平行，它们的叉乘将垂直于三角形的表面。让我们将两个边向量的叉乘命名为
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>has been scaled
    down for illustrative purposes
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container> 已经被缩小了，仅用于说明目的。
- en: '<mjx-container classname="MathJax" jax="SVG"></mjx-container>points in the
    right direction, but it''s not a normal. For <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>to be a normal, its magnitude needs to equal 1\. We
    can normalize <mjx-container classname="MathJax" jax="SVG"></mjx-container>by
    dividing it by its magnitude, the result of which we''ll assign to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>指向正确的方向，但它不是一个法线。要成为法线，其大小必须等于1。我们可以通过将<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>除以其大小来对其进行归一化，将结果分配给<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'This gives us a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>where
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个常态<mjx-container classname="MathJax" jax="SVG"></mjx-container>，其中<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>：
- en: Having found the triangle's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>we
    can use it and any of the points <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>to describe the plane containing
    the three points in point-normal form.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 找到三角形的法线<mjx-container classname="MathJax" jax="SVG"></mjx-container>后，我们可以使用它和任意的点<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，<mjx-container classname="MathJax" jax="SVG"></mjx-container>来描述包含这三个点的平面的点法线形式。
- en: It doesn't matter which of <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>we use as the point in the point-normal
    form; we always get the same plane.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点法线形式时，无论我们使用哪个点作为<mjx-container classname="MathJax" jax="SVG"></mjx-container>，我们始终得到同一个平面。
- en: Constant-normal form
  id: totrans-split-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常数法线形式
- en: There's one more way to describe a plane that we'll look at, which is through
    a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>and a distance
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 描述平面的另一种方法是通过一个法线<mjx-container classname="MathJax" jax="SVG"></mjx-container>和一个距离<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>。
- en: This is the *constant-normal form* of planes. It makes lots of calculations
    using planes much simpler.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是平面的*常数法线形式*，它使得使用平面进行许多计算变得更简单。
- en: 'In the constant-normal form, the distance <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>denotes how close the plane gets to the origin. Thought
    of another way: multiplying the normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>by
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>yields the point
    on the plane that''s closest to the origin.'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在常数法线形式中，距离<mjx-container classname="MathJax" jax="SVG"></mjx-container>表示平面靠近原点的程度。另一种想法：将法线<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>乘以<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，得到离原点最近的平面上的点。
- en: 'This is a simplification. More formally, given a point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>on a plane whose normal is <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, we can describe all points <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>on the plane in two forms: the point-normal form <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, and the constant-normal form <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>where <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>. See [further reading](/blog/planes#further-reading).'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化。更正式地说，给定平面上一点<mjx-container classname="MathJax" jax="SVG"></mjx-container>其法线为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，我们可以用两种形式描述平面上的所有点：点法线形式<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和常数法线形式<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，其中<mjx-container classname="MathJax" jax="SVG"></mjx-container>。详见[进一步阅读](/blog/planes#further-reading)。
- en: 'In getting a feel for the difference between the point-normal and constant-normal
    forms, take this example which describes the same plane in both forms:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受点法线形式和常数法线形式之间的差异，可以看这个例子，它在两种形式中描述了同一个平面：
- en: The green arrow represents <mjx-container classname="MathJax" jax="SVG"></mjx-container>from
    the constant-normal form, while the blue point and arrow represent the point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>from the point-normal form.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色箭头代表常法式中的<mjx-container classname="MathJax" jax="SVG"></mjx-container>，而蓝色点和箭头代表点法式中的点<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和法向量<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>。
- en: 'Translating from the point-normal to the constant-normal form is very easy:
    the distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the
    [dot product](https://en.wikipedia.org/wiki/Dot_product) of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>.'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从点法式到常法式的转换非常简单：距离<mjx-container classname="MathJax" jax="SVG"></mjx-container>是[mjx-container
    classname="MathJax" jax="SVG"></mjx-container]的点积。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: If you're not familiar with the dot product, don't worry. We'll cover it later
    on.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对点积不熟悉，别担心，我们稍后会介绍。
- en: The notation for <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>might seem to indicate
    that they're of different types, but they're both vectors. I'm differentiating
    between points in space (e.g. <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>) and direction vectors
    (e.g. <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>) by using the arrow notation only
    for direction vectors.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的符号表示可能表明它们属于不同类型，但它们都是向量。我通过仅使用箭头符号区分空间中的点（例如<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>）和方向向量（例如<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>）。
- en: The normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>stays
    the same across both forms.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 法向量<mjx-container classname="MathJax" jax="SVG"></mjx-container>在两种形式中保持不变。
- en: Distance from plane
  id: totrans-split-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平面距离
- en: Given an arbitrary point <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    a plane <mjx-container classname="MathJax" jax="SVG"></mjx-container>in constant-normal
    form, we may want to ask how far away the point is from the plane. In other words,
    what is the minimum distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>needs
    to travel to lie on the plane?
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 给定任意点<mjx-container classname="MathJax" jax="SVG"></mjx-container>和常法式的平面<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，我们可能想知道点到平面的距离有多远。换句话说，<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>需要移动多少才能在平面上。
- en: 'We can frame this differently if we construct a plane <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>containing <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    is parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    which we can do in point-normal form using <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>as the point and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>''s normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    the normal:'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构造一个包含<mjx-container classname="MathJax" jax="SVG"></mjx-container>的平面<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>并且平行于<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，我们可以使用点法式，其中<mjx-container classname="MathJax" jax="SVG"></mjx-container>作为点，<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的法向量作为法向量：
- en: With two parallel planes, we can frame the problem as finding the distance between
    the two planes. This becomes trivial using their constant-normal form since it
    allows us to take the difference between their distance components <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有了两个平行平面，我们可以将问题构造为找到两个平面之间的距离。使用它们的常法式使这变得微不足道，因为它允许我们取其距离分量<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>的差异。
- en: 'So let''s find <mjx-container classname="MathJax" jax="SVG"></mjx-container>''s
    distance using the <mjx-container classname="MathJax" jax="SVG"></mjx-container>equation
    we learned about:'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们使用我们学到的方程式来找到<mjx-container classname="MathJax" jax="SVG"></mjx-container>的距离：
- en: 'With two distances <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>from the planes <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>the solution simply becomes:'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过平面的两个距离<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，解决方案简化为：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'So, to simplify, given a plane <mjx-container classname="MathJax" jax="SVG"></mjx-container>having
    a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>and distance
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can calculate
    a point <mjx-container classname="MathJax" jax="SVG"></mjx-container>''s distance
    from <mjx-container classname="MathJax" jax="SVG"></mjx-container>like so:'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，给定一个法线为<mjx-container classname="MathJax" jax="SVG"></mjx-container>距离为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的平面，我们可以这样计算点<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>到<mjx-container classname="MathJax" jax="SVG"></mjx-container>的距离：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: The distance may be positive or negative depending on which side of the plane
    the point is on.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 距离可能是正数或负数，这取决于点位于平面的哪一侧。
- en: Projecting a point onto a plane
  id: totrans-split-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影点到平面上
- en: A case where calculating a point's distance from a plane becomes useful is,
    for example, if you want to project a point onto a plane.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 计算点到平面的距离变得有用的一个情况是，例如，如果你想将一个点投影到平面上。
- en: 'Given a point <mjx-container classname="MathJax" jax="SVG"></mjx-container>which
    we want to project onto plane <mjx-container classname="MathJax" jax="SVG"></mjx-container>whose
    normal is <mjx-container classname="MathJax" jax="SVG"></mjx-container>and distance
    is <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can do that
    fairly easily. First, let''s define <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    the point''s distance from the plane:'
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个点<mjx-container classname="MathJax" jax="SVG"></mjx-container>我们希望投影到法线为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>距离为<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>的平面上，我们可以相对容易地做到这一点。首先，让我们定义<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>作为点到平面的距离：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Multiplying the plane''s normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>by
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>gives us a vector
    which when added to <mjx-container classname="MathJax" jax="SVG"></mjx-container>projects
    it onto the plane. Let''s call the projected point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>:'
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将平面的法线<mjx-container classname="MathJax" jax="SVG"></mjx-container>乘以<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>得到一个向量，将其加到<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>可以将其投影到平面上。我们将投影后的点称为<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: The projection occurs along the plane's normal, which is sometimes useful. However,
    it is much more useful to be able to project a point onto a plane along an *arbitrary*
    direction instead. Doing that boils down finding the point of intersection of
    a line and a plane.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 投影沿着平面的法线进行，这有时是有用的。然而，能够沿着*任意*方向将点投影到平面上则更加有用。这涉及到找到直线和平面的交点。
- en: Line-plane intersection
  id: totrans-split-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线平面交点
- en: We can describe lines in 3D space using a point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    The normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    the line's orientation, while the point <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    a point which the line passes through.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个点<mjx-container classname="MathJax" jax="SVG"></mjx-container>和法线<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>描述三维空间中的直线。法线<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>描述了线的方向，而点<mjx-container classname="MathJax" jax="SVG"></mjx-container>描述了线通过的点。
- en: In this chapter, the line will be composed of the point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    while the plane—given in constant-normal form—has a normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and a distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，线由点<mjx-container classname="MathJax" jax="SVG"></mjx-container>和法线<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>组成，而平面——以常法形式给出——具有法线<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和距离<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>。
- en: Our goal will be to find a distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>needs to travel along
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>such that it lies
    on the plane.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到一个距离<mjx-container classname="MathJax" jax="SVG"></mjx-container>，使得<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>沿着<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>移动，使其位于平面上。
- en: We can figure out the distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    we'd need to travel if <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>were parallel, which
    is what we did when projecting along the plane's normal.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算出<mjx-container classname="MathJax" jax="SVG"></mjx-container>需要移动的距离，如果<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>是平行的，这就是我们在投影平面法线时所做的。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Let''s try projecting <mjx-container classname="MathJax" jax="SVG"></mjx-container>along
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>using <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>as a scalar like so:'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用<mjx-container classname="MathJax" jax="SVG"></mjx-container>作为标量来沿着<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>投影<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'We''ll visualize <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    a red point:'
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将<mjx-container classname="MathJax" jax="SVG"></mjx-container>视为一个红点：
- en: As <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>become parallel, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>gets us closer and closer to the
    correct solution. However, as the angle between <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>increases,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes increasingly
    too small.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>变得平行时，<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>使我们越来越接近正确的解。然而，随着<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>和<mjx-container classname="MathJax" jax="SVG"></mjx-container>之间的角度增加，<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>变得越来越小。
- en: Here, the dot product comes in handy. For two vectors <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    the dot product is defined as
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，点积非常有用。对于两个向量<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，点积定义为
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: where <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the angle
    between <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<mjx-container classname="MathJax" jax="SVG"></mjx-container>是<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>和<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>之间的角度。
- en: Consider the dot product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>. Since both normals
    are unit vectors whose magnitudes are 1
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>的点积。由于两个法线都是单位向量，其大小为1
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: we can remove their magnitudes from the equation,
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从方程中消去它们的大小，
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: making the dot product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>the cosine of the
    angle between them.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 的点积成为它们之间角度的余弦。
- en: For two vectors, the cosine of their angles approaches 1 as the vectors become
    increasingly parallel, and approaches 0 as they become perpendicular.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个向量，它们的夹角余弦随着向量变得越来越平行而接近 1，随着向量变得越来越垂直而接近 0。
- en: 'Since <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes
    increasingly too small as <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>become more perpendicular,
    we can use <mjx-container classname="MathJax" jax="SVG"></mjx-container>as a denominator
    for <mjx-container classname="MathJax" jax="SVG"></mjx-container>. We''ll assign
    this scaled-up version of <mjx-container classname="MathJax" jax="SVG"></mjx-container>to
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在两个向量变得越来越垂直时，<mjx-container classname="MathJax" jax="SVG"></mjx-container>
    变得越来越小，我们可以用它作为 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    的分母。我们将这个放大版本的 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 赋给
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'With <mjx-container classname="MathJax" jax="SVG"></mjx-container>as our scaled-up
    distance, we find the point of intersection <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>via:'
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们放大的距离，我们通过以下方法找到交点：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'We can now get rid of <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    which was defined as <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    giving us the full equation for <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以摆脱被定义为 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 的
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>，从而得到 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 的完整方程：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'Putting this into code, we get:'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些转化为代码，我们得到：
- en: '[PRE0]'
  id: totrans-split-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, our code is not completely yet. In the case where the line is parallel
    to the plane's surface, the line and plane do not intersect.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的代码还没有完全完成。在直线与平面表面平行的情况下，直线和平面不相交。
- en: That happens when <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are perpendicular,
    in which case their dot product is zero. So if <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, the line and plane do not intersect. This gives us
    an easy test we can add to our code to yield a result of "no intersection".
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 垂直时，它们的点积为零。因此，如果 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，则直线和平面不相交。这给了我们一个可以添加到代码中的简单测试，以产生“无交点”的结果。
- en: However, for many applications we'll want to treat being *almost* parallel as
    actually being parallel. To do that, we can check whether the dot product is smaller
    than some very small number—customarily called epsilon
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于许多应用场景，我们希望将*几乎*平行视为实际平行。为了做到这一点，我们可以检查点积是否小于某个非常小的数值——通常称为 epsilon。
- en: '[PRE1]'
  id: totrans-split-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See if you can figure out why Mathf.Abs is used here. We'll cover it later,
    so you'll see if you're right.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能否弄清楚为什么在这里使用 Mathf.Abs。我们稍后会详细介绍，所以你会知道自己是否正确。
- en: We'll take a look at how to select the value of epsilon in a later chapter on
    two plane intersections.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的一章中讨论如何选择 epsilon 的值，用于两个平面的交点。
- en: 'With this, our line-plane intersection implementation becomes:'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的线平面交点实现变成了：
- en: '[PRE2]'
  id: totrans-split-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rays and lines
  id: totrans-split-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 射线和直线
- en: We've been talking about line-plane intersections, but I've been lying a bit
    by visualizing ray-plane intersections instead for visual clarity.
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在谈论线与平面的交点，但为了视觉上的清晰度，我有点撒谎，其实是在想射线与平面的交点。
- en: A ray and a line are very similar; they're both represented through a normal
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and a point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 射线和直线非常相似；它们都通过一个法向量 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    和一个点 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 表示。
- en: 'The difference is that a ray (colored red) extends in the direction of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>away from <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, while a line (colored green) extends in the other
    direction as well:'
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于射线（红色）朝 远离扩展，而线段（绿色）朝另一个方向扩展：
- en: 'What this means for intersections is that a ray will not intersect planes when
    traveling backward along its normal:'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着射线沿其法向后退时不会与平面相交：
- en: Our implementation for ray-plane intersections will differ from our existing
    line-plane intersection implementation only in that it should yield a result of
    "no intersection" when the ray's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    pointing "away" from the plane's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>at
    an obtuse angle.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的射线-平面交点实现与现有的线-平面交点实现不同，只是在射线的法向量 指向平面的法向量 为钝角时应得到 "无交点" 的结果。
- en: 'Since <mjx-container classname="MathJax" jax="SVG"></mjx-container>represents
    how far to travel along the normal to reach the point of intersection, we could
    yield "no intersection" when <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes
    negative:'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 表示沿法向量前进到达交点的距离，所以当 变为负数时我们可以得到 "无交点" 的结果：
- en: '[PRE3]'
  id: totrans-split-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But then we'd have to calculate <mjx-container classname="MathJax" jax="SVG"></mjx-container>first.
    That's not necessary since <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes
    negative as a consequence of the dot product <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>being a negative number when <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>are
    at an obtuse angle between 90° and 180°.
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后我们必须首先计算 。由于 和 之间的角度为90°至180°之间，所以这并不必要。
- en: If this feels non-obvious, it helps to remember that the dot product encodes
    the cosine of the angle between its two component vectors, which is why the dot
    product becomes negative for obtuse angles.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来不明显，记住点乘编码其两个分量向量之间的余弦值，这就是为什么在钝角时点乘的结果变为负数。
- en: 'Knowing that, we can change our initial "parallel normals" test from this:'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 知道了这一点，我们可以将初始的 "法向量平行" 测试改为：
- en: '[PRE4]'
  id: totrans-split-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To this:'
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点：
- en: '[PRE5]'
  id: totrans-split-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <mjx-container classname="MathJax" jax="SVG"></mjx-container>check covers
    both the *"line parallel to plane"* case *and* the case where the two normal vectors
    are at an obtuse angle.
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 检查同时涵盖了 *"平行于平面的直线"* 情况 *以及* 两个法向量成钝角的情况。
- en: 'Note: <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the symbol
    for epsilon.'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意： 是表示epsilon的符号。
- en: Plane-plane intersection
  id: totrans-split-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平面-平面交点
- en: The intersection of two planes forms an infinite line.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: 两个平面的交点形成一个无限长的直线。
- en: 'As a quick refresher: lines in 3D space are represented using a point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>where normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    the line''s orientation, while the point <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    a point which the line passes through.'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下：在三维空间中，线段用一个点 和法向量 来表示，其中法向量 描述了线段的方向，而点 是线段经过的一个点。
- en: Let's take two planes <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>whose normals are
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们取两个平面的法向量分别为 和 。
- en: Finding the direction vector of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s intersection is
    deceptively simple. Since the line intersection of two planes lies on the surface
    of both planes, the line must be perpendicular to both plane normals, which means
    that the direction of the intersection is the cross product of the two plane normals.
    We'll assign it to <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container> 的方向向量看似简单。因为两个平面的交线位于两个平面的表面上，所以交线必须垂直于两个平面的法线，这意味着交线的方向是两个平面法线的叉积。我们将其赋值给
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: The magnitude of the cross product is equal to the [area of the parallelogram](https://en.wikipedia.org/wiki/Cross_product#/media/File:Cross_product_parallelogram.svg)
    formed by the two component vectors. This means that we can't expect the cross
    product to be a unit vector, so we'll normalize <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and assign the normalized direction vector to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
  zh: 叉积的大小等于两个分量向量形成的平行四边形的[面积](https://en.wikipedia.org/wiki/Cross_product#/media/File:Cross_product_parallelogram.svg)。这意味着我们不能期望叉积是单位向量，因此我们将对
    <mjx-container classname="MathJax" jax="SVG"></mjx-container> 进行归一化，并将归一化后的方向向量赋给
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: This gives us the intersection's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    Let's zoom in and see this close up.
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们交点的法线 <mjx-container classname="MathJax" jax="SVG"></mjx-container>。让我们放大看一看这个过程。
- en: But this is only half of the puzzle! We'll also need to find a point in space
    to represent the line of intersection (i.e. a point which the line passes through).
    We'll take a look at how to do just that, right after we discuss the no-intersection
    case.
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是问题的一半！我们还需要找到一个空间点来表示交线（即线通过的点）。我们将在讨论无交点情况之后详细讨论如何做到这一点。
- en: Handling parallel planes
  id: totrans-split-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理平行平面
- en: Two planes whose normals are parallel will never intersect, which is a case
    that we'll have to handle.
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: 两个法线平行的平面永远不会相交，这是一个我们必须处理的情况。
- en: The cross product of two parallel normals is <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>. So if <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    the planes do not intersect.
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
  zh: 两个平行法线的叉积是 <mjx-container classname="MathJax" jax="SVG"></mjx-container>。所以如果
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>，那么这两个平面不相交。
- en: As previously mentioned, for many applications we'll want to treat planes that
    are *almost* parallel as being parallel. This means that our plane-plane intersection
    procedure should yield a result of "no intersection" when the magnitude of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is less than some very small number
    called epsilon.
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，对于许多应用，我们希望将几乎平行的平面视为平行。这意味着我们的平面相交过程应在 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 的大小小于称为 epsilon 的非常小的数时产生“无交点”的结果。
- en: '[PRE6]'
  id: totrans-split-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But what should the value of epsilon be?
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但 epsilon 的值应该是多少？
- en: 'Given two normals <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>where the angle between
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, we can find a reasonable epsilon by charting <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>for different values of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个法线 <mjx-container classname="MathJax" jax="SVG"></mjx-container> 和 <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，其中 <mjx-container classname="MathJax"
    jax="SVG"></mjx-container> 和 <mjx-container classname="MathJax" jax="SVG"></mjx-container>
    之间的角度是 <mjx-container classname="MathJax" jax="SVG"></mjx-container>，我们可以通过绘制
    <mjx-container classname="MathJax" jax="SVG"></mjx-container> 的不同值来找到一个合理的 epsilon：
- en: Both of the axes are [logarithmic](https://en.wikipedia.org/wiki/Logarithmic_scale).
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: 两个轴都是[对数](https://en.wikipedia.org/wiki/Logarithmic_scale)的。
- en: 'The relationship is linear: as the angle between the planes halves, so does
    the magnitude of the cross product of their normals. <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>yields a magnitude of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, and <mjx-container classname="MathJax" jax="SVG"></mjx-container>yields
    half of that.'
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关系是线性的：随着平面之间夹角减半，它们法向量的叉积大小也减半。<mjx-container classname="MathJax" jax="SVG"></mjx-container>的大小为<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>，<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>的大小为它的一半。
- en: 'So to determine the epsilon, we can ask: how low does the angle in degrees
    need to become for us to consider two planes parallel? Given an angle <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, we can find the epsilon <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>via:'
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要确定 epsilon，我们可以问：角度需要多小（以度为单位）才能认为两个平面是平行的？给定角度<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>，我们可以通过以下公式找到 epsilon：<mjx-container classname="MathJax"
    jax="SVG"></mjx-container>。
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: 'If that angle is 1/256°, then we get:'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果那个角度是1/256°，我们得到：
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
  zh: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
- en: With this you can determine the appropriate epsilon based on how small the angle
    between the planes needs to be for you to consider them parallel. That will depend
    on your use case.
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，您可以根据平面之间的角度多小来确定适当的 epsilon。这将取决于您的使用情况。
- en: Finding a point of intersection
  id: totrans-split-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找交点
- en: Having computed the normal and handled parallel planes, we can move on to finding
    a point <mjx-container classname="MathJax" jax="SVG"></mjx-container>along the
    line of intersection.
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算法向量并处理平行平面后，我们可以继续找到沿交线的点<mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: Since the line describing a plane-plane intersection is infinite, there are
    infinitely many points we could choose as <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于描述平面-平面交点的线是无限的，我们可以选择无限多个点作为<mjx-container classname="MathJax" jax="SVG"></mjx-container>。
- en: We can narrow the problem down by taking the plane parallel to the two plane
    normals <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and observing that it intersects
    the line at a single point.
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过取与两个平面法线平行的平面<mjx-container classname="MathJax" jax="SVG"></mjx-container>来缩小问题范围，并观察它在一点上的交点。
- en: Since the point lies on the plane parallel to the two plane normals, we can
    find it by exclusively traveling along those normals.
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该点位于与两个平面法线平行的平面上，我们可以通过沿着这些法线独占行进来找到它。
- en: 'The simplest case is the one where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are perpendicular.
    In that case, the solution is just <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    Here''s what that looks like visually:'
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是<mjx-container classname="MathJax" jax="SVG"></mjx-container>和<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>垂直的情况。在这种情况下，解决方案就是<mjx-container
    classname="MathJax" jax="SVG"></mjx-container>。以下是其可视化效果：
- en: When dragging the slider, notice how the tip of the parallelogram gets further
    away from the point of intersection as the planes become more parallel.
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当拖动滑块时，请注意随着平面变得更加平行，平行四边形顶点离交点的距离增加。
- en: 'We can also observe that as we get further away from the point of intersection,
    the longer of the two vectors (colored red) pushes us further away from the point
    of intersection than the shorter (blue) vector does. This is easier to observe
    if we draw a line from the origin to the point of intersection:'
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以观察到，随着我们远离交点，较长的两个向量（红色）将我们远离交点，而较短的（蓝色）向量则不会。如果我们从原点到交点画一条线，这更容易观察：
- en: 'Let''s define <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>as the scaling factors
    that we apply to <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>(the result of which
    are the red and blue vectors). Right now we''re using the distance components
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>of the planes as the scaling factors:'
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
- en: To solve this asymmetric pushing effect, we need to travel less in the direction
    of the longer vector as the planes become more parallel. We need some sort of
    "pulling factor" that adjusts the vectors such that their tip stays on the line
    as the planes become parallel.
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
- en: Here our friend the dot product comes in handy yet again. When the planes are
    perpendicular the dot product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>equals 0, but as
    the planes become increasingly parallel, it approaches 1\. We can use this to
    gradually increase our yet-to-be-defined pulling factor.
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give the dot product <mjx-container classname="MathJax" jax="SVG"></mjx-container>the
    name <mjx-container classname="MathJax" jax="SVG"></mjx-container>to make this
    a bit less noisy:'
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
- en: The perfect pulling factors happen to be the distance components <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>used as counterweights against each other!
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
- en: Consider why this might be. When <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are perpendicular,
    their dot product equals 0, which results in
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-169
  prefs: []
  type: TYPE_NORMAL
- en: which we know yields the correct solution.
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are parallel, their
    dot product equals 1, which results in:'
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the absolute values of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are equal, it means
    that the magnitude of the two vectors—defined as <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>—is
    equal:'
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
- en: This means that the magnitude of our vectors will become *more* equal as the
    planes become parallel, which is what we want!
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action:'
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
- en: The vectors stay on the line, but they become increasingly too short as <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>become parallel.
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
- en: Yet again, we can use the dot product. Since we want the length of the vectors
    to increase as the planes become parallel, we can divide our scalars <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>by <mjx-container classname="MathJax" jax="SVG"></mjx-container>where
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the dot product
    of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>is the absolute value of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this looks like so:'
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
- en: Using <mjx-container classname="MathJax" jax="SVG"></mjx-container>as the denominator
    certainly increases the size of the parallelogram, but by too much.
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
- en: 'However, notice what happens when we visualize the quadrants of the parallelogram:'
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
- en: As the planes become more parallel, the point of intersection approaches the
    center of the parallelogram.
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
- en: In understanding why that is, consider the effect that our denominator <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>has on the area of the parallelogram.
    When <mjx-container classname="MathJax" jax="SVG"></mjx-container>, both of the
    vectors forming the parallelogram double in length, which has the effect of quadrupling
    the area of the parallelogram.
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
- en: This means that when we scale the component vectors of the parallelogram by
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-188
  prefs: []
  type: TYPE_NORMAL
- en: 'it has the effect of scaling the area of the parallelogram by:'
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-190
  prefs: []
  type: TYPE_NORMAL
- en: 'To instead scale the *area* of the parallelogram by <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, we need to square <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>in the denominator:'
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
- en: Squaring allows us to remove <mjx-container classname="MathJax" jax="SVG"></mjx-container>because
    the square of a negative number is positive.
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
- en: With this, our scalars <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>become
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-196
  prefs: []
  type: TYPE_NORMAL
- en: 'which scales the parallelogram such that its tip lies at the point of intersection:'
  id: totrans-split-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting all of this into code, we get:'
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Based on code from [Real-Time Collision Detection by Christer Ericson](/blog/planes#further-reading)
  id: totrans-split-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Which through some mathematical magic can be optimized down to:'
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How this optimization works can be found in chapter 5.4.4 of [Real-Time Collision
    Detection by Christer Ericson](/blog/planes#further-reading).
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes our plane-plane intersection implementation:'
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By the way, an interesting property of only traveling along the plane normals
    is that it yields the point on the line of intersection that is closest to the
    origin. Cool stuff!
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
- en: Three plane intersection
  id: totrans-split-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given three planes <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, there are five possible configurations
    in which they intersect or don''t intersect:'
  id: totrans-split-208
  prefs: []
  type: TYPE_NORMAL
- en: All three planes are parallel, with none of them intersecting each other.
  id: totrans-split-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two of the planes are parallel, and the third plane intersects the other two.
  id: totrans-split-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All three planes intersect along a single line.
  id: totrans-split-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The three planes intersect each other in pairs, forming three parallel lines
    of intersection.
  id: totrans-split-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All three planes intersect each other at a single point.
  id: totrans-split-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When finding the point of intersection, we'll first need to determine whether
    all three planes intersect at a single point—which for configurations 1 through
    4, they don't.
  id: totrans-split-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Given <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>as the plane normals for <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can determine
    whether the planes intersect at a single point with the formula:'
  id: totrans-split-215
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-216
  prefs: []
  type: TYPE_NORMAL
- en: When I first saw this, I found it hard to believe this would work for all cases.
    Still, it does! Let's take a deep dive to better understand what's happening.
  id: totrans-split-217
  prefs: []
  type: TYPE_NORMAL
- en: Two or more planes are parallel
  id: totrans-split-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll start with the configurations where two or more planes are parallel:'
  id: totrans-split-219
  prefs: []
  type: TYPE_NORMAL
- en: If <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are parallel then <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is a vector whose magnitude is zero.
  id: totrans-split-220
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-221
  prefs: []
  type: TYPE_NORMAL
- en: 'And since the dot product is a multiple of the magnitudes of its component
    vectors:'
  id: totrans-split-222
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-223
  prefs: []
  type: TYPE_NORMAL
- en: the final result is zero whenever <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are parallel.
  id: totrans-split-224
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-225
  prefs: []
  type: TYPE_NORMAL
- en: This takes care of the "all-planes-parallel" configuration, and the configuration
    where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are parallel
  id: totrans-split-226
  prefs: []
  type: TYPE_NORMAL
- en: With that, let's consider the case where <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>is parallel to either <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>or <mjx-container classname="MathJax" jax="SVG"></mjx-container>but
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are not parallel to each other.
  id: totrans-split-227
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the specific case where <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>but <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is parallel to neither.
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
- en: Here the cross product <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    a vector (colored red) that's perpendicular to both <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Since <mjx-container classname="MathJax" jax="SVG"></mjx-container>is parallel
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>, that means that
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>is also perpendicular
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>. As we''ve learned,
    the dot product of two perpendicular vectors is zero, meaning that:'
  id: totrans-split-230
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-231
  prefs: []
  type: TYPE_NORMAL
- en: This also holds in the case where <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>instead
    of <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-232
  prefs: []
  type: TYPE_NORMAL
- en: Parallel lines of intersection
  id: totrans-split-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've demonstrated that two of the three normals being parallel results in <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>. But what about the configurations
    where the three planes intersect along parallel lines? Those configurations have
    no parallel normals.
  id: totrans-split-234
  prefs: []
  type: TYPE_NORMAL
- en: As we learned when looking at plane-plane intersections, the cross product of
    two plane normals gives us the direction vector of the planes' line of intersection.
  id: totrans-split-235
  prefs: []
  type: TYPE_NORMAL
- en: When all of the lines of intersection are parallel, all of the plane normals
    defining those lines are perpendicular to them.
  id: totrans-split-236
  prefs: []
  type: TYPE_NORMAL
- en: Yet again, because the dot product of perpendicular vectors is 0 we can conclude
    that <mjx-container classname="MathJax" jax="SVG"></mjx-container>for these configurations
    as well.
  id: totrans-split-237
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now begin our implementation. As usual, we''ll use an epsilon to handle
    the *"roughly parallel"* case:'
  id: totrans-split-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Computing the point intersection
  id: totrans-split-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to find the point at which our three planes <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>intersect:'
  id: totrans-split-241
  prefs: []
  type: TYPE_NORMAL
- en: Some of what we learned about two-plane intersections will come into play here.
    Let's start by taking the line of intersection for <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    varying the position of <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    You'll notice that the point of intersection is the point at which <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>intersects the line.
  id: totrans-split-242
  prefs: []
  type: TYPE_NORMAL
- en: When <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s distance
    from the origin is 0, the vector pointing from the origin to the point of intersection
    is parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>(and
    perpendicular to <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s
    normal).
  id: totrans-split-243
  prefs: []
  type: TYPE_NORMAL
- en: This vector—let's call it <mjx-container classname="MathJax" jax="SVG"></mjx-container>—will
    play a large role in computing the point of intersection.
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
- en: We can find <mjx-container classname="MathJax" jax="SVG"></mjx-container>through
    the cross product of two other vectors <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>. The first of those,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, is just <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>'s normal.
  id: totrans-split-245
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-246
  prefs: []
  type: TYPE_NORMAL
- en: The latter vector can be found via the equation
  id: totrans-split-247
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-248
  prefs: []
  type: TYPE_NORMAL
- en: where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are the distances in the constant-normal
    form of planes <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-249
  prefs: []
  type: TYPE_NORMAL
- en: 'With <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>defined, we assign their cross product
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-250
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what it looks like:'
  id: totrans-split-252
  prefs: []
  type: TYPE_NORMAL
- en: Hmm, not quite long enough. <mjx-container classname="MathJax" jax="SVG"></mjx-container>certainly
    points in the right direction, but to make <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>'s tip lie on the line of intersection, we need to compute
    some scaling factor for <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-253
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, we''ve already computed this scaling factor:'
  id: totrans-split-254
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-255
  prefs: []
  type: TYPE_NORMAL
- en: The product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>—let's
    call that <mjx-container classname="MathJax" jax="SVG"></mjx-container>—can be
    thought to represent how parallel <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s
    normal is to the line intersection of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-256
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>approaches <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>as <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>'s normal becomes parallel to the line of intersection
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, and approaches
    0 as they become perpendicular.
  id: totrans-split-257
  prefs: []
  type: TYPE_NORMAL
- en: We want the <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s
    magnitude to increase as <mjx-container classname="MathJax" jax="SVG"></mjx-container>decreases,
    so we'll make <mjx-container classname="MathJax" jax="SVG"></mjx-container>the
    scaling factor for <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-258
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Fully expanded, the equation for <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes:'
  id: totrans-split-260
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-261
  prefs: []
  type: TYPE_NORMAL
- en: Bam! The problem is now reduced to traveling along the direction of the line
    intersection until we intersect with <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-262
  prefs: []
  type: TYPE_NORMAL
- en: We could use our knowledge of line-plane intersections to solve this, but there
    is a more efficient approach I want to demonstrate.
  id: totrans-split-263
  prefs: []
  type: TYPE_NORMAL
- en: It involves finding a scaling factor for the direction vector <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>that scales it such that it's tip
    ends at <mjx-container classname="MathJax" jax="SVG"></mjx-container>. Let's call
    this direction vector <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-264
  prefs: []
  type: TYPE_NORMAL
- en: There's one observation we can make that simplifies that. Since <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is perpendicular to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>'s normal, the distance from <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>'s tip to <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>along the direction vector <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>is the same as the distance from the origin to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>along that same direction.
  id: totrans-split-265
  prefs: []
  type: TYPE_NORMAL
- en: With that, consider the vector <mjx-container classname="MathJax" jax="SVG"></mjx-container>where
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are the normal and distance of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-266
  prefs: []
  type: TYPE_NORMAL
- en: 'If <mjx-container classname="MathJax" jax="SVG"></mjx-container>were parallel
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>, then <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>would be the scaling factor we need,
    but let''s see what happens with <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-267
  prefs: []
  type: TYPE_NORMAL
- en: As <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>become less parallel, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>becomes increasingly too short.
  id: totrans-split-268
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note as well is that even when <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>are
    completely parallel, <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    still too short, which is due to <mjx-container classname="MathJax" jax="SVG"></mjx-container>not
    being a unit vector. If we normalize <mjx-container classname="MathJax" jax="SVG"></mjx-container>prior
    to multiplying with <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    problem goes away.
  id: totrans-split-269
  prefs: []
  type: TYPE_NORMAL
- en: 'But we''re getting ahead of ourselves—we won''t need to normalize <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>. Let''s take a fresh look at how
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>is defined:'
  id: totrans-split-270
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-271
  prefs: []
  type: TYPE_NORMAL
- en: Having defined <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can simplify
    this to
  id: totrans-split-272
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-273
  prefs: []
  type: TYPE_NORMAL
- en: Earlier I mentioned that we could think of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>as a measure of how parallel <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>'s normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>(the line intersection
    of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>). That's correct, but it's not
    the whole truth!
  id: totrans-split-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the dot product is a multiple of the magnitudes of its component vectors,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>also encodes the
    magnitude of <mjx-container classname="MathJax" jax="SVG"></mjx-container>. Hence,
    scaling <mjx-container classname="MathJax" jax="SVG"></mjx-container>by <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>does two things:'
  id: totrans-split-275
  prefs: []
  type: TYPE_NORMAL
- en: it normalizes <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    and
  id: totrans-split-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it increases the length of <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    it becomes less parallel with <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  id: totrans-split-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So <mjx-container classname="MathJax" jax="SVG"></mjx-container>is both the
    scaling factor we need for <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    as well as <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-278
  prefs: []
  type: TYPE_NORMAL
- en: We've got our solution! Let's do a quick overview.
  id: totrans-split-279
  prefs: []
  type: TYPE_NORMAL
- en: 'We define <mjx-container classname="MathJax" jax="SVG"></mjx-container>as:'
  id: totrans-split-280
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-281
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll redefine <mjx-container classname="MathJax" jax="SVG"></mjx-container>to
    include <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-282
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Our denominator, <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    remains defined as :'
  id: totrans-split-284
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-285
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we find our point of intersection <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>by adding <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>together and scaling
    them by <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  id: totrans-split-286
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Which fully expanded becomes:'
  id: totrans-split-288
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  id: totrans-split-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this into code, we get:'
  id: totrans-split-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Parting words
  id: totrans-split-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks for reading!
  id: totrans-split-293
  prefs: []
  type: TYPE_NORMAL
- en: A whole lot of hours went into writing and building the visualizations for this
    post, so I hope it achieved its goal of helping you build an intuitive mental
    model of planes.
  id: totrans-split-294
  prefs: []
  type: TYPE_NORMAL
- en: Massive thanks goes to [Gunnlaugur Þór Briem](https://www.linkedin.com/in/gunnlaugur-briem/)
    and [Eiríkur Fannar Torfason](https://eirikur.dev/) for providing invaluable feedback
    on this post. I worked with them at [GRID](https://grid.is/); they're fantastic
    people to work with and be around.
  id: totrans-split-295
  prefs: []
  type: TYPE_NORMAL
- en: — Alex Harri
  id: totrans-split-296
  prefs: []
  type: TYPE_NORMAL
- en: 'PS: If you''re interested in taking a look at how the visualizations in this
    post were built, this website is [open source on GitHub](https://github.com/alexharri/website).'
  id: totrans-split-297
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-split-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I highly recommend checking out [Real-Time Collision Detection by Christer Ericson](https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323).
    If you're building applications using 3D geometry, it will prove to be an incredibly
    useful resource. This post would not exist were it not for this book—especially
    the two chapters on the intersections of planes.
  id: totrans-split-299
  prefs: []
  type: TYPE_NORMAL
- en: I recently analyzed the edit performance in [Arkio](https://www.arkio.is/) and
    noticed that a method for solving three-plane intersections took around half of
    the total compute time when recalculating geometry. By implementing the more efficient
    method for three-plane intersections described in the book, we made the method
    **~500% faster**, increasing Arkio's edit performance by over **1.6x**. Crazy
    stuff!
  id: totrans-split-300
  prefs: []
  type: TYPE_NORMAL
- en: I started writing this post to understand how the three-plane intersection method
    worked. However, I felt that readers would need a better foundation and understanding
    of planes for this post to be of any value. In building that foundation, this
    post ended up quite a bit longer than I intended.
  id: totrans-split-301
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, it's a great book. [Check it out](https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323)!
  id: totrans-split-302
  prefs: []
  type: TYPE_NORMAL
- en: </main>
  id: totrans-split-303
  prefs: []
  type: TYPE_NORMAL
