- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:35:26'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Planes in 3D space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://alexharri.com/blog/planes](https://alexharri.com/blog/planes)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <main class="css-fkkl8v">
  prefs: []
  type: TYPE_NORMAL
- en: Planes in 3D space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: April 27, 2024
  prefs: []
  type: TYPE_NORMAL
- en: A plane in 3D space can be thought of as a flat surface that stretches infinitely
    far, splitting space into two halves.
  prefs: []
  type: TYPE_NORMAL
- en: Planes have loads of uses in applications that deal with 3D geometry. I've mostly
    been working with them in the context of an [architectural modeler](https://www.arkio.is/),
    where geometry is defined in terms of planes and their intersections.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about planes felt abstract and non-intuitive to me. *“Sure, that's
    a plane equation, but what do I do with it? What does a plane look like?”* It
    took some time for me to build an intuition for how to reason about and work with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In writing this, I want to provide you with an introduction that focuses on
    building a practical, intuitive understanding of planes. I hope to achieve this
    through the use of visual (and interactive!) explanations which will accompany
    us as we work through progressively more complex problems.
  prefs: []
  type: TYPE_NORMAL
- en: With that out of the way, let's get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Describing planes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to describe planes, such as through
  prefs: []
  type: TYPE_NORMAL
- en: a point in 3D space and a normal,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: three points in 3D space, forming a triangle, or
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a normal and a distance from an origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throughout this post, the term *normal* will refer to a *normalized direction
    vector* (unit vector) whose magnitude (length) is equal to 1, typically denoted
    by <mjx-container classname="MathJax" jax="SVG"></mjx-container>where <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the point-and-normal case, here''s an example of a plane described
    by a point in 3D space <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: The normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    the plane's orientation, where the surface of the plane is perpendicular to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, while the point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>describes *a* point on the plane.
  prefs: []
  type: TYPE_NORMAL
- en: We described this plane in terms of a single point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, but keep in mind that this plane—let's call it <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>—contains infinitely many points.
  prefs: []
  type: TYPE_NORMAL
- en: If <mjx-container classname="MathJax" jax="SVG"></mjx-container>were described
    by one of those other points contained by <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    we would be describing the exact same plane. This is a result of the infinite
    nature of planes.
  prefs: []
  type: TYPE_NORMAL
- en: This way of describing planes—in terms of a point and a normal—is the [point-normal
    form](https://en.wikipedia.org/wiki/Euclidean_planes_in_three-dimensional_space#Point%E2%80%93normal_form_and_general_form_of_the_equation_of_a_plane)
    of planes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also describe a plane using three points in 3D space <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, <mjx-container classname="MathJax" jax="SVG"></mjx-container>forming
    a triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: The triangle forms an implicit plane, but for us to be able to do anything useful
    with the plane we'll need to calculate its normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>. Once we've calculated the plane's normal, we can use
    that normal along with one of the triangle's three points to describe the plane
    in point-normal form.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describing
    a plane is a unit vector (<mjx-container classname="MathJax" jax="SVG"></mjx-container>)
    perpendicular to the plane.
  prefs: []
  type: TYPE_NORMAL
- en: We can use <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>as two edge vectors
    that are parallel to the plane's surface.
  prefs: []
  type: TYPE_NORMAL
- en: By virtue of being parallel to the plane's surface, the vectors <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>are perpendicular to the plane's normal. This is where
    the cross product becomes useful to us.
  prefs: []
  type: TYPE_NORMAL
- en: The [cross product](https://en.wikipedia.org/wiki/Cross_product) takes in two
    vectors <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and returns a vector <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>that is perpendicular to both of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given the vectors <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, their cross product
    is the vector <mjx-container classname="MathJax" jax="SVG"></mjx-container>, which
    we''ll label <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: This explanation is simple on purpose. We'll get into more detail about the
    cross product later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the edge vectors of the triangle, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    are both parallel to the triangle''s surface, their cross product will be perpendicular
    to the triangle''s surface. Let''s name the cross product of our two edge vectors
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>has been scaled
    down for illustrative purposes
  prefs: []
  type: TYPE_NORMAL
- en: '<mjx-container classname="MathJax" jax="SVG"></mjx-container>points in the
    right direction, but it''s not a normal. For <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>to be a normal, its magnitude needs to equal 1\. We
    can normalize <mjx-container classname="MathJax" jax="SVG"></mjx-container>by
    dividing it by its magnitude, the result of which we''ll assign to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>where
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: Having found the triangle's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>we
    can use it and any of the points <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>to describe the plane containing
    the three points in point-normal form.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't matter which of <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>we use as the point in the point-normal
    form; we always get the same plane.
  prefs: []
  type: TYPE_NORMAL
- en: Constant-normal form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's one more way to describe a plane that we'll look at, which is through
    a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>and a distance
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: This is the *constant-normal form* of planes. It makes lots of calculations
    using planes much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constant-normal form, the distance <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>denotes how close the plane gets to the origin. Thought
    of another way: multiplying the normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>by
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>yields the point
    on the plane that''s closest to the origin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simplification. More formally, given a point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>on a plane whose normal is <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, we can describe all points <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>on the plane in two forms: the point-normal form <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, and the constant-normal form <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>where <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>. See [further reading](/blog/planes#further-reading).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In getting a feel for the difference between the point-normal and constant-normal
    forms, take this example which describes the same plane in both forms:'
  prefs: []
  type: TYPE_NORMAL
- en: The green arrow represents <mjx-container classname="MathJax" jax="SVG"></mjx-container>from
    the constant-normal form, while the blue point and arrow represent the point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>from the point-normal form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Translating from the point-normal to the constant-normal form is very easy:
    the distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the
    [dot product](https://en.wikipedia.org/wiki/Dot_product) of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>.'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: If you're not familiar with the dot product, don't worry. We'll cover it later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The notation for <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>might seem to indicate
    that they're of different types, but they're both vectors. I'm differentiating
    between points in space (e.g. <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>) and direction vectors
    (e.g. <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>) by using the arrow notation only
    for direction vectors.
  prefs: []
  type: TYPE_NORMAL
- en: The normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>stays
    the same across both forms.
  prefs: []
  type: TYPE_NORMAL
- en: Distance from plane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given an arbitrary point <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    a plane <mjx-container classname="MathJax" jax="SVG"></mjx-container>in constant-normal
    form, we may want to ask how far away the point is from the plane. In other words,
    what is the minimum distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>needs
    to travel to lie on the plane?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can frame this differently if we construct a plane <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>containing <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    is parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    which we can do in point-normal form using <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>as the point and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>''s normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    the normal:'
  prefs: []
  type: TYPE_NORMAL
- en: With two parallel planes, we can frame the problem as finding the distance between
    the two planes. This becomes trivial using their constant-normal form since it
    allows us to take the difference between their distance components <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s find <mjx-container classname="MathJax" jax="SVG"></mjx-container>''s
    distance using the <mjx-container classname="MathJax" jax="SVG"></mjx-container>equation
    we learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With two distances <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>from the planes <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>the solution simply becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to simplify, given a plane <mjx-container classname="MathJax" jax="SVG"></mjx-container>having
    a normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>and distance
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can calculate
    a point <mjx-container classname="MathJax" jax="SVG"></mjx-container>''s distance
    from <mjx-container classname="MathJax" jax="SVG"></mjx-container>like so:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: The distance may be positive or negative depending on which side of the plane
    the point is on.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting a point onto a plane
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A case where calculating a point's distance from a plane becomes useful is,
    for example, if you want to project a point onto a plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a point <mjx-container classname="MathJax" jax="SVG"></mjx-container>which
    we want to project onto plane <mjx-container classname="MathJax" jax="SVG"></mjx-container>whose
    normal is <mjx-container classname="MathJax" jax="SVG"></mjx-container>and distance
    is <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can do that
    fairly easily. First, let''s define <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    the point''s distance from the plane:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying the plane''s normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>by
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>gives us a vector
    which when added to <mjx-container classname="MathJax" jax="SVG"></mjx-container>projects
    it onto the plane. Let''s call the projected point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: The projection occurs along the plane's normal, which is sometimes useful. However,
    it is much more useful to be able to project a point onto a plane along an *arbitrary*
    direction instead. Doing that boils down finding the point of intersection of
    a line and a plane.
  prefs: []
  type: TYPE_NORMAL
- en: Line-plane intersection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can describe lines in 3D space using a point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    The normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    the line's orientation, while the point <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    a point which the line passes through.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the line will be composed of the point <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    while the plane—given in constant-normal form—has a normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and a distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal will be to find a distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>needs to travel along
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>such that it lies
    on the plane.
  prefs: []
  type: TYPE_NORMAL
- en: We can figure out the distance <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    we'd need to travel if <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>were parallel, which
    is what we did when projecting along the plane's normal.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try projecting <mjx-container classname="MathJax" jax="SVG"></mjx-container>along
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>using <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>as a scalar like so:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll visualize <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    a red point:'
  prefs: []
  type: TYPE_NORMAL
- en: As <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>become parallel, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>gets us closer and closer to the
    correct solution. However, as the angle between <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>increases,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes increasingly
    too small.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the dot product comes in handy. For two vectors <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    the dot product is defined as
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: where <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the angle
    between <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the dot product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>. Since both normals
    are unit vectors whose magnitudes are 1
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: we can remove their magnitudes from the equation,
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: making the dot product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>the cosine of the
    angle between them.
  prefs: []
  type: TYPE_NORMAL
- en: For two vectors, the cosine of their angles approaches 1 as the vectors become
    increasingly parallel, and approaches 0 as they become perpendicular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes
    increasingly too small as <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>become more perpendicular,
    we can use <mjx-container classname="MathJax" jax="SVG"></mjx-container>as a denominator
    for <mjx-container classname="MathJax" jax="SVG"></mjx-container>. We''ll assign
    this scaled-up version of <mjx-container classname="MathJax" jax="SVG"></mjx-container>to
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'With <mjx-container classname="MathJax" jax="SVG"></mjx-container>as our scaled-up
    distance, we find the point of intersection <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>via:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now get rid of <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    which was defined as <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    giving us the full equation for <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this into code, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, our code is not completely yet. In the case where the line is parallel
    to the plane's surface, the line and plane do not intersect.
  prefs: []
  type: TYPE_NORMAL
- en: That happens when <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are perpendicular,
    in which case their dot product is zero. So if <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, the line and plane do not intersect. This gives us
    an easy test we can add to our code to yield a result of "no intersection".
  prefs: []
  type: TYPE_NORMAL
- en: However, for many applications we'll want to treat being *almost* parallel as
    actually being parallel. To do that, we can check whether the dot product is smaller
    than some very small number—customarily called epsilon
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See if you can figure out why Mathf.Abs is used here. We'll cover it later,
    so you'll see if you're right.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a look at how to select the value of epsilon in a later chapter on
    two plane intersections.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, our line-plane intersection implementation becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rays and lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've been talking about line-plane intersections, but I've been lying a bit
    by visualizing ray-plane intersections instead for visual clarity.
  prefs: []
  type: TYPE_NORMAL
- en: A ray and a line are very similar; they're both represented through a normal
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and a point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is that a ray (colored red) extends in the direction of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>away from <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, while a line (colored green) extends in the other
    direction as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means for intersections is that a ray will not intersect planes when
    traveling backward along its normal:'
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation for ray-plane intersections will differ from our existing
    line-plane intersection implementation only in that it should yield a result of
    "no intersection" when the ray's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    pointing "away" from the plane's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>at
    an obtuse angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since <mjx-container classname="MathJax" jax="SVG"></mjx-container>represents
    how far to travel along the normal to reach the point of intersection, we could
    yield "no intersection" when <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes
    negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But then we'd have to calculate <mjx-container classname="MathJax" jax="SVG"></mjx-container>first.
    That's not necessary since <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes
    negative as a consequence of the dot product <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>being a negative number when <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>are
    at an obtuse angle between 90° and 180°.
  prefs: []
  type: TYPE_NORMAL
- en: If this feels non-obvious, it helps to remember that the dot product encodes
    the cosine of the angle between its two component vectors, which is why the dot
    product becomes negative for obtuse angles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing that, we can change our initial "parallel normals" test from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The <mjx-container classname="MathJax" jax="SVG"></mjx-container>check covers
    both the *"line parallel to plane"* case *and* the case where the two normal vectors
    are at an obtuse angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the symbol
    for epsilon.'
  prefs: []
  type: TYPE_NORMAL
- en: Plane-plane intersection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The intersection of two planes forms an infinite line.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick refresher: lines in 3D space are represented using a point <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and normal <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>where normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    the line''s orientation, while the point <mjx-container classname="MathJax" jax="SVG"></mjx-container>describes
    a point which the line passes through.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take two planes <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>whose normals are
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the direction vector of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s intersection is
    deceptively simple. Since the line intersection of two planes lies on the surface
    of both planes, the line must be perpendicular to both plane normals, which means
    that the direction of the intersection is the cross product of the two plane normals.
    We'll assign it to <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: The magnitude of the cross product is equal to the [area of the parallelogram](https://en.wikipedia.org/wiki/Cross_product#/media/File:Cross_product_parallelogram.svg)
    formed by the two component vectors. This means that we can't expect the cross
    product to be a unit vector, so we'll normalize <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and assign the normalized direction vector to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: This gives us the intersection's normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    Let's zoom in and see this close up.
  prefs: []
  type: TYPE_NORMAL
- en: But this is only half of the puzzle! We'll also need to find a point in space
    to represent the line of intersection (i.e. a point which the line passes through).
    We'll take a look at how to do just that, right after we discuss the no-intersection
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Handling parallel planes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two planes whose normals are parallel will never intersect, which is a case
    that we'll have to handle.
  prefs: []
  type: TYPE_NORMAL
- en: The cross product of two parallel normals is <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>. So if <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    the planes do not intersect.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, for many applications we'll want to treat planes that
    are *almost* parallel as being parallel. This means that our plane-plane intersection
    procedure should yield a result of "no intersection" when the magnitude of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is less than some very small number
    called epsilon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But what should the value of epsilon be?
  prefs: []
  type: TYPE_NORMAL
- en: 'Given two normals <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>where the angle between
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, we can find a reasonable epsilon by charting <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>for different values of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: Both of the axes are [logarithmic](https://en.wikipedia.org/wiki/Logarithmic_scale).
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship is linear: as the angle between the planes halves, so does
    the magnitude of the cross product of their normals. <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>yields a magnitude of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, and <mjx-container classname="MathJax" jax="SVG"></mjx-container>yields
    half of that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So to determine the epsilon, we can ask: how low does the angle in degrees
    need to become for us to consider two planes parallel? Given an angle <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, we can find the epsilon <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>via:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'If that angle is 1/256°, then we get:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: With this you can determine the appropriate epsilon based on how small the angle
    between the planes needs to be for you to consider them parallel. That will depend
    on your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a point of intersection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having computed the normal and handled parallel planes, we can move on to finding
    a point <mjx-container classname="MathJax" jax="SVG"></mjx-container>along the
    line of intersection.
  prefs: []
  type: TYPE_NORMAL
- en: Since the line describing a plane-plane intersection is infinite, there are
    infinitely many points we could choose as <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: We can narrow the problem down by taking the plane parallel to the two plane
    normals <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and observing that it intersects
    the line at a single point.
  prefs: []
  type: TYPE_NORMAL
- en: Since the point lies on the plane parallel to the two plane normals, we can
    find it by exclusively traveling along those normals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest case is the one where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are perpendicular.
    In that case, the solution is just <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    Here''s what that looks like visually:'
  prefs: []
  type: TYPE_NORMAL
- en: When dragging the slider, notice how the tip of the parallelogram gets further
    away from the point of intersection as the planes become more parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also observe that as we get further away from the point of intersection,
    the longer of the two vectors (colored red) pushes us further away from the point
    of intersection than the shorter (blue) vector does. This is easier to observe
    if we draw a line from the origin to the point of intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>as the scaling factors
    that we apply to <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>(the result of which
    are the red and blue vectors). Right now we''re using the distance components
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>of the planes as the scaling factors:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: To solve this asymmetric pushing effect, we need to travel less in the direction
    of the longer vector as the planes become more parallel. We need some sort of
    "pulling factor" that adjusts the vectors such that their tip stays on the line
    as the planes become parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Here our friend the dot product comes in handy yet again. When the planes are
    perpendicular the dot product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>equals 0, but as
    the planes become increasingly parallel, it approaches 1\. We can use this to
    gradually increase our yet-to-be-defined pulling factor.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give the dot product <mjx-container classname="MathJax" jax="SVG"></mjx-container>the
    name <mjx-container classname="MathJax" jax="SVG"></mjx-container>to make this
    a bit less noisy:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: The perfect pulling factors happen to be the distance components <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>used as counterweights against each other!
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: Consider why this might be. When <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are perpendicular,
    their dot product equals 0, which results in
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: which we know yields the correct solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are parallel, their
    dot product equals 1, which results in:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the absolute values of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are equal, it means
    that the magnitude of the two vectors—defined as <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>—is
    equal:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: This means that the magnitude of our vectors will become *more* equal as the
    planes become parallel, which is what we want!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: The vectors stay on the line, but they become increasingly too short as <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>become parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Yet again, we can use the dot product. Since we want the length of the vectors
    to increase as the planes become parallel, we can divide our scalars <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>by <mjx-container classname="MathJax" jax="SVG"></mjx-container>where
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>is the dot product
    of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>and <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>is the absolute value of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this looks like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Using <mjx-container classname="MathJax" jax="SVG"></mjx-container>as the denominator
    certainly increases the size of the parallelogram, but by too much.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, notice what happens when we visualize the quadrants of the parallelogram:'
  prefs: []
  type: TYPE_NORMAL
- en: As the planes become more parallel, the point of intersection approaches the
    center of the parallelogram.
  prefs: []
  type: TYPE_NORMAL
- en: In understanding why that is, consider the effect that our denominator <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>has on the area of the parallelogram.
    When <mjx-container classname="MathJax" jax="SVG"></mjx-container>, both of the
    vectors forming the parallelogram double in length, which has the effect of quadrupling
    the area of the parallelogram.
  prefs: []
  type: TYPE_NORMAL
- en: This means that when we scale the component vectors of the parallelogram by
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'it has the effect of scaling the area of the parallelogram by:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'To instead scale the *area* of the parallelogram by <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, we need to square <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>in the denominator:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: Squaring allows us to remove <mjx-container classname="MathJax" jax="SVG"></mjx-container>because
    the square of a negative number is positive.
  prefs: []
  type: TYPE_NORMAL
- en: With this, our scalars <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>become
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'which scales the parallelogram such that its tip lies at the point of intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting all of this into code, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Based on code from [Real-Time Collision Detection by Christer Ericson](/blog/planes#further-reading)
  prefs: []
  type: TYPE_NORMAL
- en: 'Which through some mathematical magic can be optimized down to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How this optimization works can be found in chapter 5.4.4 of [Real-Time Collision
    Detection by Christer Ericson](/blog/planes#further-reading).
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes our plane-plane intersection implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By the way, an interesting property of only traveling along the plane normals
    is that it yields the point on the line of intersection that is closest to the
    origin. Cool stuff!
  prefs: []
  type: TYPE_NORMAL
- en: Three plane intersection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given three planes <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, there are five possible configurations
    in which they intersect or don''t intersect:'
  prefs: []
  type: TYPE_NORMAL
- en: All three planes are parallel, with none of them intersecting each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two of the planes are parallel, and the third plane intersects the other two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All three planes intersect along a single line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The three planes intersect each other in pairs, forming three parallel lines
    of intersection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All three planes intersect each other at a single point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When finding the point of intersection, we'll first need to determine whether
    all three planes intersect at a single point—which for configurations 1 through
    4, they don't.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given <mjx-container classname="MathJax" jax="SVG"></mjx-container>, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>, <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>as the plane normals for <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can determine
    whether the planes intersect at a single point with the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: When I first saw this, I found it hard to believe this would work for all cases.
    Still, it does! Let's take a deep dive to better understand what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: Two or more planes are parallel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll start with the configurations where two or more planes are parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: If <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are parallel then <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is a vector whose magnitude is zero.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'And since the dot product is a multiple of the magnitudes of its component
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: the final result is zero whenever <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>are parallel.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: This takes care of the "all-planes-parallel" configuration, and the configuration
    where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are parallel
  prefs: []
  type: TYPE_NORMAL
- en: With that, let's consider the case where <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>is parallel to either <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>or <mjx-container classname="MathJax" jax="SVG"></mjx-container>but
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are not parallel to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the specific case where <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>but <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is parallel to neither.
  prefs: []
  type: TYPE_NORMAL
- en: Here the cross product <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    a vector (colored red) that's perpendicular to both <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since <mjx-container classname="MathJax" jax="SVG"></mjx-container>is parallel
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>, that means that
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>is also perpendicular
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>. As we''ve learned,
    the dot product of two perpendicular vectors is zero, meaning that:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: This also holds in the case where <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>instead
    of <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel lines of intersection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've demonstrated that two of the three normals being parallel results in <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>. But what about the configurations
    where the three planes intersect along parallel lines? Those configurations have
    no parallel normals.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned when looking at plane-plane intersections, the cross product of
    two plane normals gives us the direction vector of the planes' line of intersection.
  prefs: []
  type: TYPE_NORMAL
- en: When all of the lines of intersection are parallel, all of the plane normals
    defining those lines are perpendicular to them.
  prefs: []
  type: TYPE_NORMAL
- en: Yet again, because the dot product of perpendicular vectors is 0 we can conclude
    that <mjx-container classname="MathJax" jax="SVG"></mjx-container>for these configurations
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now begin our implementation. As usual, we''ll use an epsilon to handle
    the *"roughly parallel"* case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Computing the point intersection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to find the point at which our three planes <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>, <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>intersect:'
  prefs: []
  type: TYPE_NORMAL
- en: Some of what we learned about two-plane intersections will come into play here.
    Let's start by taking the line of intersection for <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    varying the position of <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
    You'll notice that the point of intersection is the point at which <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>intersects the line.
  prefs: []
  type: TYPE_NORMAL
- en: When <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s distance
    from the origin is 0, the vector pointing from the origin to the point of intersection
    is parallel to <mjx-container classname="MathJax" jax="SVG"></mjx-container>(and
    perpendicular to <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s
    normal).
  prefs: []
  type: TYPE_NORMAL
- en: This vector—let's call it <mjx-container classname="MathJax" jax="SVG"></mjx-container>—will
    play a large role in computing the point of intersection.
  prefs: []
  type: TYPE_NORMAL
- en: We can find <mjx-container classname="MathJax" jax="SVG"></mjx-container>through
    the cross product of two other vectors <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>. The first of those,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, is just <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>'s normal.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: The latter vector can be found via the equation
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: where <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are the distances in the constant-normal
    form of planes <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: 'With <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>defined, we assign their cross product
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: Hmm, not quite long enough. <mjx-container classname="MathJax" jax="SVG"></mjx-container>certainly
    points in the right direction, but to make <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>'s tip lie on the line of intersection, we need to compute
    some scaling factor for <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, we''ve already computed this scaling factor:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: The product of <mjx-container classname="MathJax" jax="SVG"></mjx-container>—let's
    call that <mjx-container classname="MathJax" jax="SVG"></mjx-container>—can be
    thought to represent how parallel <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s
    normal is to the line intersection of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>approaches <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>as <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>'s normal becomes parallel to the line of intersection
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, and approaches
    0 as they become perpendicular.
  prefs: []
  type: TYPE_NORMAL
- en: We want the <mjx-container classname="MathJax" jax="SVG"></mjx-container>'s
    magnitude to increase as <mjx-container classname="MathJax" jax="SVG"></mjx-container>decreases,
    so we'll make <mjx-container classname="MathJax" jax="SVG"></mjx-container>the
    scaling factor for <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'Fully expanded, the equation for <mjx-container classname="MathJax" jax="SVG"></mjx-container>becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: Bam! The problem is now reduced to traveling along the direction of the line
    intersection until we intersect with <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: We could use our knowledge of line-plane intersections to solve this, but there
    is a more efficient approach I want to demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: It involves finding a scaling factor for the direction vector <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>that scales it such that it's tip
    ends at <mjx-container classname="MathJax" jax="SVG"></mjx-container>. Let's call
    this direction vector <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: There's one observation we can make that simplifies that. Since <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>is perpendicular to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>'s normal, the distance from <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>'s tip to <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>along the direction vector <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>is the same as the distance from the origin to <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>along that same direction.
  prefs: []
  type: TYPE_NORMAL
- en: With that, consider the vector <mjx-container classname="MathJax" jax="SVG"></mjx-container>where
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>are the normal and distance of <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>.
  prefs: []
  type: TYPE_NORMAL
- en: 'If <mjx-container classname="MathJax" jax="SVG"></mjx-container>were parallel
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>, then <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>would be the scaling factor we need,
    but let''s see what happens with <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: As <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>become less parallel, <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>becomes increasingly too short.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note as well is that even when <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>and <mjx-container classname="MathJax" jax="SVG"></mjx-container>are
    completely parallel, <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    still too short, which is due to <mjx-container classname="MathJax" jax="SVG"></mjx-container>not
    being a unit vector. If we normalize <mjx-container classname="MathJax" jax="SVG"></mjx-container>prior
    to multiplying with <mjx-container classname="MathJax" jax="SVG"></mjx-container>that
    problem goes away.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we''re getting ahead of ourselves—we won''t need to normalize <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>. Let''s take a fresh look at how
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: Having defined <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>, we can simplify
    this to
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: Earlier I mentioned that we could think of <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>as a measure of how parallel <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>'s normal <mjx-container classname="MathJax" jax="SVG"></mjx-container>is
    to <mjx-container classname="MathJax" jax="SVG"></mjx-container>(the line intersection
    of <mjx-container classname="MathJax" jax="SVG"></mjx-container>and <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>). That's correct, but it's not
    the whole truth!
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the dot product is a multiple of the magnitudes of its component vectors,
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>also encodes the
    magnitude of <mjx-container classname="MathJax" jax="SVG"></mjx-container>. Hence,
    scaling <mjx-container classname="MathJax" jax="SVG"></mjx-container>by <mjx-container
    classname="MathJax" jax="SVG"></mjx-container>does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: it normalizes <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it increases the length of <mjx-container classname="MathJax" jax="SVG"></mjx-container>as
    it becomes less parallel with <mjx-container classname="MathJax" jax="SVG"></mjx-container>.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So <mjx-container classname="MathJax" jax="SVG"></mjx-container>is both the
    scaling factor we need for <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    as well as <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: We've got our solution! Let's do a quick overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define <mjx-container classname="MathJax" jax="SVG"></mjx-container>as:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll redefine <mjx-container classname="MathJax" jax="SVG"></mjx-container>to
    include <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'Our denominator, <mjx-container classname="MathJax" jax="SVG"></mjx-container>,
    remains defined as :'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we find our point of intersection <mjx-container classname="MathJax"
    jax="SVG"></mjx-container>by adding <mjx-container classname="MathJax" jax="SVG"></mjx-container>and
    <mjx-container classname="MathJax" jax="SVG"></mjx-container>together and scaling
    them by <mjx-container classname="MathJax" jax="SVG"></mjx-container>:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'Which fully expanded becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: <mjx-container classname="MathJax" jax="SVG"></mjx-container>
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this into code, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Parting words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks for reading!
  prefs: []
  type: TYPE_NORMAL
- en: A whole lot of hours went into writing and building the visualizations for this
    post, so I hope it achieved its goal of helping you build an intuitive mental
    model of planes.
  prefs: []
  type: TYPE_NORMAL
- en: Massive thanks goes to [Gunnlaugur Þór Briem](https://www.linkedin.com/in/gunnlaugur-briem/)
    and [Eiríkur Fannar Torfason](https://eirikur.dev/) for providing invaluable feedback
    on this post. I worked with them at [GRID](https://grid.is/); they're fantastic
    people to work with and be around.
  prefs: []
  type: TYPE_NORMAL
- en: — Alex Harri
  prefs: []
  type: TYPE_NORMAL
- en: 'PS: If you''re interested in taking a look at how the visualizations in this
    post were built, this website is [open source on GitHub](https://github.com/alexharri/website).'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I highly recommend checking out [Real-Time Collision Detection by Christer Ericson](https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323).
    If you're building applications using 3D geometry, it will prove to be an incredibly
    useful resource. This post would not exist were it not for this book—especially
    the two chapters on the intersections of planes.
  prefs: []
  type: TYPE_NORMAL
- en: I recently analyzed the edit performance in [Arkio](https://www.arkio.is/) and
    noticed that a method for solving three-plane intersections took around half of
    the total compute time when recalculating geometry. By implementing the more efficient
    method for three-plane intersections described in the book, we made the method
    **~500% faster**, increasing Arkio's edit performance by over **1.6x**. Crazy
    stuff!
  prefs: []
  type: TYPE_NORMAL
- en: I started writing this post to understand how the three-plane intersection method
    worked. However, I felt that readers would need a better foundation and understanding
    of planes for this post to be of any value. In building that foundation, this
    post ended up quite a bit longer than I intended.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, it's a great book. [Check it out](https://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323)!
  prefs: []
  type: TYPE_NORMAL
- en: </main>
  prefs: []
  type: TYPE_NORMAL
