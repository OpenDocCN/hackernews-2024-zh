- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:57:05'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Easy Mode Rust — Llogiq on stuff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://llogiq.github.io/2024/03/28/easy.html](https://llogiq.github.io/2024/03/28/easy.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Easy Mode Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 28 March 2024
  prefs: []
  type: TYPE_NORMAL
- en: This post is based on my [RustNationUK ‘24](https://rustnationuk.com) talk with
    the same title. The [talk video](https://www.youtube.com/watch?v=33FG6O3qejM)
    is on youtube, the slides [are served from here](/talks/easy.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, here’s the lyrics of the song I introduced the talk with (sung to the
    tune of Bob Dylan’s “The times, they are a-changin’”):'
  prefs: []
  type: TYPE_NORMAL
- en: Come gather Rustaceans wherever you roam
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: and admit that our numbers have steadily grown.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The community’s awesomeness ain’t set in stone,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: so if that to you is worth saving
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: then you better start teamin’ up instead of toilin’ alone
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for the times, they are a-changin’.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Come bloggers and writers who tutorize with your pen
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: and teach those new folks, the chance won’t come again!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where there once was one newbie, there soon will be ten
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: and your knowledge is what they are cravin’.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Know that what you share with them is what you will gain
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for the times, they are a-changin’.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Researchers and coders, please heed the call,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Without your efforts Rust would be nothin’ at all
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: and unsafety would rise where it now meets its fall.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: May C++ proponents be ravin’.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What divides them from us is but a rustup install
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for the times, they are a-changin’.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fellow moderators throughout the land,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: don’t you dare censor what is not meant to offend
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: otherwise far too soon helpful people be banned
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: and what’s left will be angry folks ragin’.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Our first order of business is to help understand
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: that the times, they are a-changin’.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The line it is drawn, the type it is cast
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What debug runs slow, release will run fast
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: as the present now will later be past
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: and our values be rapidly fadin’
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: unless we find new people who can make them last
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for the times, they are a-changin’.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rust has an only somewhat deserved reputation for being hard to learn. But that
    is mostly an unavoidable consequence of being a systems language that has to supply
    full control over the myriad of specifics of your code and runtime. But I’d argue
    that our method of teaching Rust is rather more at fault for this reputation.
    So as an antidote to this “the right way to do it” thinking, I offer this set
    of ideas on how to learn as little Rust as possible to become productive in Rust,
    so you can start and have success right away and learn the harder parts later
    when you’re comfortable with the basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the talk I started with the “ground rules” for the exercise: I wanted to
    identify a small subset to learn that will allow people to successfully write
    Rust programs to solve the problems in front of them without being overwhelmed
    by all kinds of new concepts. I am happy to forgo on performance, brevity of the
    code or idiomatic code. In fact, some of the suggestions fly in the face of conventional
    guidelines on how good Rust code should look like. One of the questions after
    the talk was how to deal with new contributors or colleagues pushing “substandard”
    code to a project, and here my suggestion is to just merge it and clean it up
    after the fact. New users will feel unsure about their abilities, and nitpicking
    on details will put them off where we want to encourage them in their growth and
    learning, at least in the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the flipside of this is that I don’t suggest that every Rustacean
    learn only this subset and forever avoid all else. The idea here is to make you
    productive and successful quickly, and you can then build on that. A suggestion
    that also came up after my talk was to create a poster with a “research tree”
    (that is sometimes used in strategy games like e.g. Civilization to give people
    a path to progress without making it too linear). This is still on my list and
    I’ll open a repo for that soon, in the hope of finding people who’ll help me.
  prefs: []
  type: TYPE_NORMAL
- en: 'So without further ado, here are the things we want to avoid learning, and
    how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rust is not a small language. When starting out, for flow control it’s best
    to stick to basic things like `if`, `for` and `while`. If you need to distinguish
    e.g. enum variants, you can also use `match`, but keep it simple: Only match one
    thing, and avoid more complex things like guard clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Avoid other constructs for now (such as `if let` or `let`-`else`). While they
    might make the code more readable, you can learn them later and have your IDE
    refactor your code quickly as you become privy to how they work. Within loops,
    avoid `break` and `continue`, especially with values. Rather introduce a new function
    that `return`s the value from within a loop.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the introduction, this will take more code and thus exacerbate
    both brevity and readability, but the individual moving parts are far simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The ~~S~~Borrow checker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In my talk, I used a classic example that will often come up during search
    algorithms: Extending a collection of items with filtered and modified versions
    of the prior items.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The code here pretty much mirrors what you’d do in e.g. Python. It’s simple
    to read and understand, and there aren’t any needless moving parts. Unfortunately,
    it is also wrong, and the compiler won’t hesitate to point that out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, in almost all of the cases, we can split the immutable from the mutable
    borrows. In this particular case, we can simply iterate over a clone of our item
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'I used to be very wary of cloning in the past, considering it an antipattern,
    but unless that code is on the hot path, it literally won’t show up on your application’s
    profile. so going to the effort of avoiding that clone is premature optimization.
    However, if you have measured and note that the clone *is* in fact showing up
    either on your memory or CPU profile, you can switch to indexing instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this approach is more brittle than the clone based one: While in
    this case the loop itself only uses integers and thus doesn’t borrow anything,
    we might still inadvertently introduce overlapping borrows into the loop body.
    For example, if we replaced the `if` with `if let`, `items` would be borrowed
    from for the duration of the then-clause, thus causing the exact error we were
    trying to avoid in the first place. Also note that we put `modify(..)` into a
    local to avoid having it within the `push`, which might also possibly trip up
    the borrow checker.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we’re not generally aiming for performance, so I would prefer the clone-based
    variant as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Macros come up early in Rust. Literally the first Rust program everyone compiles
    (or even writes) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You’ll have a hard time writing Rust without calling macros, so I would suggest
    you treat them like you’d treat functions, with the caveat that they can have
    a rather variable syntax, but they’ll usually document that. So as long as you
    roughly know how to call the macro and what it does, feel free to call them as
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: '*Writing* macros is something we’ll want to avoid. Rust has a number of macro
    types (declarative macros, declarative macros 2.0, derive macros, annotation macros
    and procedural bang-macros), but we’re not going to look into writing any of those.
    All of those macro variants solve a single problem: Code duplication.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the obvious simple solution to avoiding macros is: Duplicate your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While that sounds very simple, in fact the advice can be split into a hierarchy
    of solutions that depend on the problem at hand:'
  prefs: []
  type: TYPE_NORMAL
- en: 'up to 5 times, less than 10 lines of code, not expected to change: In this
    case I’d just copy & paste the code and edit it to fit your requirements. Of course,
    you still have the risk of introducing errors in one of the instances of the copied
    code, but with the resulting code being reasonably compact, you’ll have a good
    chance to catch those quickly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'more than that, still not expected to change within a certain time: Who is
    better than creating multiple almost-same instances of the same thing than you?
    Your computer of course! So write some Rust code that builds Rust code by building
    strings (using `format!(..)` or `println!(..)`), call it once and copy the output
    into your code. Voilà!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: expected to be up to date with the rest of the code? In that case, put your
    code generation into a unit test that reads and splits out the current version
    of the code, generates the possibly updated version, compares both and if they
    differ writes the updated version of the code, then panic with a message to tell
    whoever ran the test they need to commit the changes. It is helpful to add start
    and end marker comments to the generated code to make splitting it out easier
    and to document the fact that code is generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In code, instead of doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Either 1\. copy & paste instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or 2\. write code to generate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, 3\. use a test to keep code updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Alexey Kladov explains the latter technique better than I could in his blog
    post about [Self-modifying code](https://matklad.github.io/2022/03/26/self-modifying-code.html).
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generics lets us re-use code in various situations by being able to swap out
    types. However, they can also be a great source of complexity, so we’ll of course
    want to avoid them. As Go before version 1.2 has shown, you can get quite far
    without them, so unless it’s for the element type of collections, we’ll want to
    avoid using them.
  prefs: []
  type: TYPE_NORMAL
- en: So instead of writing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'we’d monomorphize by hand (that is build a copy of the code for each set of
    concrete types we need), so for each `A`/`B` combination, we’d write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you might end up with a lot of copies, so use the code generation
    from above to deal with that.
  prefs: []
  type: TYPE_NORMAL
- en: Lifetimes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lifetime annotations are those arcane tick+letter things that sometimes even
    stump intermediate Rust programmers, so you won’t be surprised to find them on
    this list. They look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we don’t want to burden ourselves with those sigil-laden monstrosities
    for now. To get rid of those, we have to avoid borrowing in function signatures.
    So instead of taking a reference, take an owned instance. And yes, this will incur
    more cloning yet. If you need to share an object (e.g. because you want to mutate
    it), wrap it in an `Arc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Arc` is a smart pointer that lets you `.clone()` without cloning the wrapped
    value. Both `Arc`s will lead to the exact same value, and if you mutate one, the
    other will also have changed.'
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get a lot done without ever implementing a trait in Rust. However, there
    are some traits (especially in the standard library, but also in trait-heavy crates
    like [serde](https://serde.rs)) that you might need to get some stuff done. In
    many cases, you can use a `#[derive(..)]`-annotation, such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, Rust lore would tell you to use trait based dispatch, but in
    most of those cases, an `enum` and a `match` or even a bag of `if`-clauses will
    do the trick. Remember, we’re not attempting to have our code win a beauty contest,
    just get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you use a framework that requires you to manually implement a trait,
    write `impl WhateverTrait for SomeType` and use the `insert missing members` code
    action from your IDE if available.
  prefs: []
  type: TYPE_NORMAL
- en: Modules and Imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is something we cannot completely avoid. If we don’t use any imports, our
    code can only use what’s defined in the standard library prelude, and we won’t
    get very far with that. Also even if we did, we’d end up with a 10+k lines of
    code file, and no one wants to navigate that. On the other hand, when using modules,
    we should strive to not go overboard, lest we find ourselves in a maze of twisty
    little `mod.rs` files, all different (pardon the text adventure reference).
  prefs: []
  type: TYPE_NORMAL
- en: 'So we obviously need to import stuff we `use`, but how do we introduce `mod`s?
    The key to keeping this simple is the observation that mods conflate code organization
    with the hierarchy of paths in our crate. So if I have a `mod foo` containing
    a `bar`, people using my code will have to either import or directly specify `foo::bar`.
    But there are two recipes we can follow to untangle those. Given an example `lib.rs`
    where our code has two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in practice, those functions likely won’t be empty, and in most cases we’ll
    have more than two of them, but you want to read this blog post, not wade through
    screens of code, so let’s look at the first recipe we will use to move `b` to
    a new `b.rs` file without changing the path where `b` is visible from the outside.
    The recipe has three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the `b` module in `lib.rs` and `pub use` `b` from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `b.rs`, non-publicly importing everything from above, so that `fn b()`
    won’t fail to compile because of missing paths from `lib.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move `fn b()` into `b.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you just split your code without anyone using it being the
    wiser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second recipe is to move the `b` path into the `b` module. In this case,
    we have to make the `b` module publicly visible and then remove the `pub use`
    from our `lib.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Voilà, your users won’t be able to call `b()` directly anymore unless they import
    it from `b::b`. Now modules are still a messy beast, but at least there are easy
    steps to take to deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: Async
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust async is arcane, powerful and still has a good number of rough edges. So
    unless you’re writing a web service that needs to serve more than fifty thousand
    concurrent users on a single machine, try to avoid it (remember, we’re not after
    performance here). However, some libraries you may want to use *will* require
    async code. In this case, pick an async runtime (most libraries will work with
    [tokio](https://docs.rs/tokio), so that seems a safe choice) and
  prefs: []
  type: TYPE_NORMAL
- en: write your functions as you would write a normal function, prepending `async`
    before the `fn`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add `.await` after every function call, and then remove it again wherever the
    compiler complains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: avoid potentially locking mechanisms such as `Mutex`, `RwLock`, and channels.
    If you absolutely must use one of them, your async runtime will provide replacements
    that won’t deadlock on you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might still run into weird errors. Don’t say I didn’t warn you.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If I had a penny for each internet troll asking me to write a doubly-linked
    list in safe Rust (hint: I can, but I don’t need to, there’s one in the standard
    library), I’d be a very well-off man. So you won’t be surprised to read me suggesting
    you avoid writing your own data structures. In fact I’ll go one step further and
    allow you to put off learning what data structures are already provided, because
    you can get by with only two in the majority of cases: Sequence-like and Lookup-like.'
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whether you call them lists, or arrays, or sequences is of little import. This
    type of structure is usually there to be filled and later iterated over. For example,
    if we want to have three items:'
  prefs: []
  type: TYPE_NORMAL
- en: start
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: more
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: end
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'we can put them in a `Vec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Use `Vec`s everywhere you want to sequentially iterate items.
  prefs: []
  type: TYPE_NORMAL
- en: Lookups
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Those may be called maps, or dictionaries, and allow you to associate a key
    with a value, to later retrieve the value given the key.
  prefs: []
  type: TYPE_NORMAL
- en: '| **KEY** | **VALUE** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| recursion | please look at “recursion” |'
  prefs: []
  type: TYPE_TB
- en: 'we will use `HashMap`s for this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While hashmaps can be iterated, the main use case is to get a value given a
    key.
  prefs: []
  type: TYPE_NORMAL
- en: You will be surprised how many programs you can create by just sticking to those
    two structures.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rust iterators are also very powerful, and being able to call their combinator
    functions (like `filter`, `map` etc.) you can create new iterators. There are
    only two points to be mindful of: First, the combinator functions *won’t* iterate
    anything, they will just wrap the given iterator into a new iterator type that
    will modify the iterator’s behavior, and second, the resulting types are usually
    very hard if not impossible to write out. So you should try avoiding returning
    such a custom iterator from a function, instead `collect`ing into a `Vec` or `HashMap`
    (see above). If however your iterator is infinite (yes, that can happen), you
    obviously cannot collect it. In those rare cases, here’s the magic trick to make
    it work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So now you know what things you can put off learning while you’re being productive
    in Rust. Have fun!
  prefs: []
  type: TYPE_NORMAL
