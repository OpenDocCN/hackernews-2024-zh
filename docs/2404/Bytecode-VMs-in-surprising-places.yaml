- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: æœªåˆ†ç±»'
- en: 'date: 2024-05-27 13:40:55'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 13:40:55'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Bytecode VMs in surprising places
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»¤äººæƒŠè®¶çš„åœ°æ–¹çš„å­—èŠ‚ç è™šæ‹Ÿæœº
- en: æ¥æºï¼š[https://dubroy.com/blog/bytecode-vms-in-surprising-places/](https://dubroy.com/blog/bytecode-vms-in-surprising-places/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://dubroy.com/blog/bytecode-vms-in-surprising-places/](https://dubroy.com/blog/bytecode-vms-in-surprising-places/)
- en: April 30, 2024
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 2024å¹´4æœˆ30æ—¥
- en: In response to a question on Twitter^(, Richard Hipp wrote about [why SQLite
    uses a bytecode VM](https://sqlite.org/draft/whybytecode.html) for executing SQL
    statements.)
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Twitterä¸Šå›ç­”ä¸€ä¸ªé—®é¢˜æ—¶^(ï¼ŒRichard Hippå†™åˆ°[ä¸ºä»€ä¹ˆSQLiteä½¿ç”¨å­—èŠ‚ç è™šæ‹Ÿæœº](https://sqlite.org/draft/whybytecode.html)æ¥æ‰§è¡ŒSQLè¯­å¥ã€‚)
- en: Most people probably associate bytecode VMs with general-purpose programming
    languages, like JavaScript or Python. But sometimes they appear in surprising
    places! Here are a few that I know about.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§å¤šæ•°äººå¯èƒ½å°†å­—èŠ‚ç è™šæ‹Ÿæœºä¸é€šç”¨ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚JavaScriptæˆ–Pythonï¼‰è”ç³»èµ·æ¥ã€‚ä½†æœ‰æ—¶å®ƒä»¬å‡ºç°åœ¨ä»¤äººæƒŠè®¶çš„åœ°æ–¹ï¼è¿™é‡Œæ˜¯æˆ‘çŸ¥é“çš„ä¸€äº›ä¾‹å­ã€‚
- en: eBPF
  id: totrans-split-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: eBPF
- en: Did you know that inside the Linux kernel, thereâ€™s an extension mechanism that
    includes a bytecode interpreter and a JIT compiler?
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çŸ¥é“åœ¨Linuxå†…æ ¸å†…éƒ¨æœ‰ä¸€ä¸ªåŒ…æ‹¬å­—èŠ‚ç è§£é‡Šå™¨å’ŒJITç¼–è¯‘å™¨çš„æ‰©å±•æœºåˆ¶å—ï¼Ÿ
- en: 'I had no idea. Well, itâ€™s called [eBPF](https://en.wikipedia.org/wiki/EBPF),
    and itâ€™s pretty interesting: a register-based VM with ten general-purpose registers
    and over a hundred different opcodes.'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¸çŸ¥é“ã€‚å¥½å§ï¼Œå®ƒè¢«ç§°ä¸º[eBPF](https://en.wikipedia.org/wiki/EBPF)ï¼Œå®ƒç›¸å½“æœ‰è¶£ï¼šä¸€ä¸ªå…·æœ‰åä¸ªé€šç”¨å¯„å­˜å™¨å’Œè¶…è¿‡ä¸€ç™¾ç§ä¸åŒæ“ä½œç çš„å¯„å­˜å™¨å¼è™šæ‹Ÿæœºã€‚
- en: 'The â€œBPFâ€ in eBPF stands for *Berkeley packet filter*, and the basic idea is
    described in [a 1993 USENIX paper](https://www.tcpdump.org/papers/bpf-usenix93.pdf):'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: eBPFä¸­çš„â€œBPFâ€ä»£è¡¨*Berkeley packet filter*ï¼Œå…¶åŸºæœ¬æ€æƒ³åœ¨[1993å¹´çš„USENIXè®ºæ–‡](https://www.tcpdump.org/papers/bpf-usenix93.pdf)ä¸­æè¿°ï¼š
- en: Many versions of Unix provide facilities for user-level packet capture, making
    possible the use of general purpose workstations for network monitoring. Because
    network monitors run as user-level processes, packets must be copied across the
    kernel/user-space protection boundary. This copying can be minimized by deploying
    a kernel agent called a packet filter, which discards unwanted packets as early
    as possible. The original Unix packet filter was designed around a stack-based
    filter evaluator that performs sub-optimally on current RISC CPUs. The BSD Packet
    Filter (BPF) uses a new, register-based filter evaluator that is up to 20 times
    faster than the original design.
  id: totrans-split-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®¸å¤šç‰ˆæœ¬çš„Unixæä¾›ç”¨æˆ·çº§åˆ«çš„æ•°æ®åŒ…æ•è·åŠŸèƒ½ï¼Œä½¿å¾—å¯ä»¥ä½¿ç”¨é€šç”¨å·¥ä½œç«™è¿›è¡Œç½‘ç»œç›‘æ§ã€‚å› ä¸ºç½‘ç»œç›‘è§†å™¨ä½œä¸ºç”¨æˆ·çº§åˆ«è¿›ç¨‹è¿è¡Œï¼Œæ•°æ®åŒ…å¿…é¡»é€šè¿‡å†…æ ¸/ç”¨æˆ·ç©ºé—´ä¿æŠ¤è¾¹ç•Œè¿›è¡Œå¤åˆ¶ã€‚é€šè¿‡éƒ¨ç½²ç§°ä¸ºæ•°æ®åŒ…è¿‡æ»¤å™¨çš„å†…æ ¸ä»£ç†ï¼Œå¯ä»¥å°†æ­¤å¤åˆ¶æœ€å°åŒ–ï¼Œå¹¶å°½æ—©ä¸¢å¼ƒä¸éœ€è¦çš„æ•°æ®åŒ…ã€‚åŸå§‹çš„Unixæ•°æ®åŒ…è¿‡æ»¤å™¨è®¾è®¡å›´ç»•ä¸€ä¸ªæ ˆå¼è¿‡æ»¤å™¨è¯„ä¼°å™¨ï¼Œè¯¥è¯„ä¼°å™¨åœ¨å½“å‰çš„RISC
    CPUä¸Šæ‰§è¡Œæ•ˆæœä¸ä½³ã€‚BSDæ•°æ®åŒ…è¿‡æ»¤å™¨ï¼ˆBPFï¼‰ä½¿ç”¨äº†ä¸€ä¸ªæ–°çš„ã€åŸºäºå¯„å­˜å™¨çš„è¿‡æ»¤å™¨è¯„ä¼°å™¨ï¼Œæ¯”åŸå§‹è®¾è®¡å¿«äº†å¤šè¾¾20å€ã€‚
- en: 'So it was originally designed for a pretty restricted use case: a directed,
    acyclic control flow graph representing a filter function for network packets.
    And for a long time, the Linux implementation was equally simple: two general-purpose
    registers, a switch-style interpreter, and no backwards branches.'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæœ€åˆå®ƒè¢«è®¾è®¡ç”¨äºä¸€ä¸ªç›¸å½“å—é™åˆ¶çš„ç”¨ä¾‹ï¼šè¡¨ç¤ºç½‘ç»œæ•°æ®åŒ…çš„ä¸€ä¸ªæœ‰å‘æ— ç¯æ§åˆ¶æµå›¾çš„è¿‡æ»¤å‡½æ•°ã€‚å¾ˆé•¿ä¸€æ®µæ—¶é—´ä»¥æ¥ï¼ŒLinuxçš„å®ç°åŒæ ·ç®€å•ï¼šä¸¤ä¸ªé€šç”¨å¯„å­˜å™¨ï¼Œä¸€ä¸ªå¼€å…³å¼è§£é‡Šå™¨ï¼Œæ²¡æœ‰åå‘åˆ†æ”¯ã€‚
- en: 'A patch in 2011 added [a JIT compiler for x86-64](https://lwn.net/Articles/437981/).
    In 2012, [the first non-networking use case appeared](https://lwn.net/Articles/475043/).
    Then, in 2014, the BPF implementation was substantially extended on its way to
    becoming [the universal in-kernel virtual machine](https://lwn.net/Articles/599755/):'
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2011å¹´çš„ä¸€ä¸ªè¡¥ä¸ä¸º[x86-64çš„JITç¼–è¯‘å™¨](https://lwn.net/Articles/437981/)ã€‚2012å¹´ï¼Œ[é¦–ä¸ªéç½‘ç»œä½¿ç”¨æ¡ˆä¾‹å‡ºç°](https://lwn.net/Articles/475043/)ã€‚ç„¶åï¼Œ2014å¹´ï¼Œåœ¨æˆä¸º[å†…æ ¸é€šç”¨è™šæ‹Ÿæœº](https://lwn.net/Articles/599755/)çš„è·¯ä¸Šï¼ŒBPFå®ç°å¾—åˆ°äº†å¤§å¹…æ‰©å±•ï¼š
- en: It expands the set of available registers from two to ten, adds a number of
    instructions that closely match real hardware instructions, implements 64-bit
    registers, makes it possible for BPF programs to call a (rigidly controlled) set
    of kernel functions, and more. Internal BPF is more readily compiled into fast
    machine code and makes it easier to hook BPF into other subsystems.
  id: totrans-split-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®ƒæ‰©å±•äº†å¯ç”¨å¯„å­˜å™¨é›†ï¼Œä»ä¸¤ä¸ªæ‰©å±•åˆ°åä¸ªï¼Œå¢åŠ äº†è®¸å¤šä¸çœŸå®ç¡¬ä»¶æŒ‡ä»¤ç´§å¯†åŒ¹é…çš„æŒ‡ä»¤ï¼Œå®ç°äº†64ä½å¯„å­˜å™¨ï¼Œä½¿å¾—BPFç¨‹åºå¯ä»¥è°ƒç”¨ï¼ˆä¸¥æ ¼æ§åˆ¶çš„ï¼‰ä¸€ç»„å†…æ ¸å‡½æ•°ï¼Œç­‰ç­‰ã€‚å†…éƒ¨BPFæ›´å®¹æ˜“ç¼–è¯‘æˆå¿«é€Ÿçš„æœºå™¨ç ï¼Œå¹¶ä½¿å¾—å°†BPFæŒ‚æ¥åˆ°å…¶ä»–å­ç³»ç»Ÿå˜å¾—æ›´å®¹æ˜“ã€‚
- en: DWARF expressions
  id: totrans-split-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DWARFè¡¨è¾¾å¼
- en: 'DWARF is a file format used by compilers like GCC and LLVM to include debug
    information in compiled binaries. Say youâ€™re trying to debug the following C++
    code:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: DWARFæ˜¯ç”±åƒGCCå’ŒLLVMè¿™æ ·çš„ç¼–è¯‘å™¨ä½¿ç”¨çš„æ–‡ä»¶æ ¼å¼ï¼Œç”¨äºåœ¨ç¼–è¯‘åçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­åŒ…å«è°ƒè¯•ä¿¡æ¯ã€‚å‡è®¾ä½ æ­£åœ¨å°è¯•è°ƒè¯•ä»¥ä¸‹C++ä»£ç ï¼š
- en: '[PRE0]'
  id: totrans-split-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In a debugger, you might want to print the value of the `ans` variable. But
    depending on the compiler and the code, this could be surprisingly difficult!
    It could be in a register, on the stack, or it might have been optimized away
    (to name just a few possibilities).
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è°ƒè¯•å™¨ä¸­ï¼Œæ‚¨å¯èƒ½æƒ³è¦æ‰“å°`ans`å˜é‡çš„å€¼ã€‚ä½†æ ¹æ®ç¼–è¯‘å™¨å’Œä»£ç çš„ä¸åŒï¼Œè¿™å¯èƒ½ä¼šå‡ºä¹æ„æ–™åœ°å›°éš¾ï¼å®ƒå¯èƒ½åœ¨å¯„å­˜å™¨ä¸­ï¼Œå †æ ˆä¸Šï¼Œæˆ–è€…å¯èƒ½å·²ç»è¢«ä¼˜åŒ–æ‰ï¼ˆåªæ˜¯å‡ ç§å¯èƒ½æ€§ä¹‹ä¸€ï¼‰ã€‚
- en: 'The solution is allow the compiler to specify an *expression* that will compute
    the value of the local variable. So the [DWARF spec](https://dwarfstd.org/doc/DWARF5.pdf)
    includes an expression language:'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆæ˜¯å…è®¸ç¼–è¯‘å™¨æŒ‡å®šä¸€ä¸ª*è¡¨è¾¾å¼*æ¥è®¡ç®—æœ¬åœ°å˜é‡çš„å€¼ã€‚å› æ­¤ï¼Œ[DWARFè§„èŒƒ](https://dwarfstd.org/doc/DWARF5.pdf)åŒ…æ‹¬ä¸€ä¸ªè¡¨è¾¾å¼è¯­è¨€ï¼š
- en: '**2.5 DWARF Expressions**'
  id: totrans-split-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2.5 DWARFè¡¨è¾¾å¼**'
- en: DWARF expressions describe how to compute a value or specify a location. They
    are expressed in terms of DWARF operations that operate on a stack of values.
  id: totrans-split-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DWARFè¡¨è¾¾å¼æè¿°å¦‚ä½•è®¡ç®—å€¼æˆ–æŒ‡å®šä½ç½®ã€‚å®ƒä»¬ä»¥æ“ä½œDWARFæ“ä½œæ ˆä¸ºåŸºç¡€è¡¨è¾¾ã€‚
- en: A DWARF expression is encoded as a stream of operations, each consisting of
    an opcode followed by zero or more literal operands. The number of operands is
    implied by the opcode.
  id: totrans-split-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DWARFè¡¨è¾¾å¼è¢«ç¼–ç ä¸ºä¸€ç³»åˆ—æ“ä½œæµï¼Œæ¯ä¸ªæ“ä½œç”±æ“ä½œç å’Œé›¶ä¸ªæˆ–å¤šä¸ªæ–‡å­—æ“ä½œæ•°ç»„æˆã€‚æ“ä½œæ•°çš„æ•°é‡ç”±æ“ä½œç éšå«ç¡®å®šã€‚
- en: Itâ€™s up to the debugger to evaluate the expressions. GDB and LLDB both have
    a switch-based interpreter for DWARF expressions.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±è°ƒè¯•å™¨æ¥è¯„ä¼°è¡¨è¾¾å¼ã€‚GDBå’ŒLLDBéƒ½æœ‰åŸºäºå¼€å…³çš„DWARFè¡¨è¾¾å¼è§£é‡Šå™¨ã€‚
- en: GDB agent expressions
  id: totrans-split-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GDBä»£ç†è¡¨è¾¾å¼
- en: But it turns out that GDB has another bytecode interpreter!
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†äº‹å®è¯æ˜ï¼ŒGDBè¿˜æœ‰å¦ä¸€ä¸ªå­—èŠ‚ç è§£é‡Šå™¨ï¼
- en: Using GDBâ€™s `trace` and `collect` commands, the user can specify locations in
    the program, and arbitrary expressions to evaluate when those locations are reached.
  id: totrans-split-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨GDBçš„`trace`å’Œ`collect`å‘½ä»¤ï¼Œç”¨æˆ·å¯ä»¥æŒ‡å®šç¨‹åºä¸­çš„ä½ç½®ï¼Œå¹¶åœ¨è¾¾åˆ°è¿™äº›ä½ç½®æ—¶è¯„ä¼°ä»»æ„è¡¨è¾¾å¼ã€‚
- en: When GDB is debugging a remote target, the GDB agent code running on the target
    computes the values of the expressions itself. To avoid having a full symbolic
    expression evaluator on the agent, GDB translates expressions in the source language
    into a simpler bytecode language, and then sends the bytecode to the agent; the
    agent then executes the bytecode, and records the values for GDB to retrieve later.
  id: totrans-split-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å½“GDBè°ƒè¯•è¿œç¨‹ç›®æ ‡æ—¶ï¼Œè¿è¡Œåœ¨ç›®æ ‡ä¸Šçš„GDBä»£ç†ä»£ç è‡ªå·±è®¡ç®—è¡¨è¾¾å¼çš„å€¼ã€‚ä¸ºäº†é¿å…åœ¨ä»£ç†ä¸Šå…·æœ‰å®Œæ•´çš„ç¬¦å·è¡¨è¾¾å¼æ±‚å€¼å™¨ï¼ŒGDBå°†æºè¯­è¨€ä¸­çš„è¡¨è¾¾å¼è½¬æ¢ä¸ºä¸€ä¸ªæ›´ç®€å•çš„å­—èŠ‚ç è¯­è¨€ï¼Œç„¶åå°†å­—èŠ‚ç å‘é€åˆ°ä»£ç†ï¼›ä»£ç†ç„¶åæ‰§è¡Œå­—èŠ‚ç ï¼Œå¹¶è®°å½•å€¼ä¾›GDBç¨åæ£€ç´¢ã€‚
- en: The bytecode language is simple; there are forty-odd opcodes, the bulk of which
    are the usual vocabulary of C operands (addition, subtraction, shifts, and so
    on) and various sizes of literals and memory reference operations. The bytecode
    interpreter operates strictly on machine-level values â€” various sizes of integers
    and floating point numbers â€” and requires no information about types or symbols;
    thus, the interpreterâ€™s internal data structures are simple, and each bytecode
    requires only a few native machine instructions to implement it. The interpreter
    is small, and strict limits on the memory and time required to evaluate an expression
    are easy to determine, making it suitable for use by the debugging agent in real-time
    applications.
  id: totrans-split-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å­—èŠ‚ç è¯­è¨€å¾ˆç®€å•ï¼›æœ‰å››åå¤šä¸ªæ“ä½œç ï¼Œå…¶ä¸­å¤§éƒ¨åˆ†æ˜¯Cæ“ä½œçš„å¸¸è§è¯æ±‡ï¼ˆåŠ æ³•ã€å‡æ³•ã€ç§»ä½ç­‰ï¼‰ä»¥åŠå„ç§å¤§å°çš„æ–‡å­—å’Œå†…å­˜å¼•ç”¨æ“ä½œã€‚å­—èŠ‚ç è§£é‡Šå™¨ä¸¥æ ¼æ“ä½œåœ¨æœºå™¨çº§åˆ«çš„å€¼ä¸Š
    â€”â€” å„ç§å¤§å°çš„æ•´æ•°å’Œæµ®ç‚¹æ•° â€”â€” å¹¶ä¸”ä¸éœ€è¦ç±»å‹æˆ–ç¬¦å·ä¿¡æ¯ï¼›å› æ­¤ï¼Œè§£é‡Šå™¨çš„å†…éƒ¨æ•°æ®ç»“æ„ç®€å•ï¼Œå¹¶ä¸”æ¯ä¸ªå­—èŠ‚ç åªéœ€è¦å‡ ä¸ªæœ¬æœºæœºå™¨æŒ‡ä»¤æ¥å®ç°ã€‚è§£é‡Šå™¨ä½“ç§¯å°ï¼Œæ˜“äºç¡®å®šè¯„ä¼°è¡¨è¾¾å¼æ‰€éœ€çš„å†…å­˜å’Œæ—¶é—´é™åˆ¶ï¼Œé€‚åˆç”¨äºå®æ—¶åº”ç”¨ç¨‹åºä¸­çš„è°ƒè¯•ä»£ç†ã€‚
- en: '*(From [Debugging with GDB, Appendix F: The GDB Agent Expression Mechanism](https://sourceware.org/gdb/current/onlinedocs/gdb.html/Agent-Expressions.html))*'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*(æ¥æºè‡ª[ä½¿ç”¨GDBè°ƒè¯•ï¼Œé™„å½•Fï¼šGDBä»£ç†è¡¨è¾¾å¼æœºåˆ¶](https://sourceware.org/gdb/current/onlinedocs/gdb.html/Agent-Expressions.html))*'
- en: WinRAR
  id: totrans-split-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinRAR
- en: WinRAR ^(is a file compression utility for Windows with a proprietary file format.
    Tavis Ormandy, a vulnerability researcher at Google, [discovered that the RAR
    format includes a bytecode encoding for data transformation](https://blog.cmpxchg8b.com/2012/09/fun-with-constrained-programming.html):)
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: WinRAR ^(æ˜¯Windowsçš„æ–‡ä»¶å‹ç¼©å®ç”¨ç¨‹åºï¼Œå…·æœ‰ä¸“æœ‰æ–‡ä»¶æ ¼å¼ã€‚Googleçš„æ¼æ´ç ”ç©¶å‘˜Tavis Ormandy [å‘ç°RARæ ¼å¼åŒ…å«ç”¨äºæ•°æ®è½¬æ¢çš„å­—èŠ‚ç ç¼–ç ](https://blog.cmpxchg8b.com/2012/09/fun-with-constrained-programming.html)ï¼š)
- en: Believe it or not, RAR files can contain bytecode for a simple x86-like virtual
    machine called the RarVM. This is designed to provide filters (preprocessors)
    to perform some reversible transformation on input data to increase redundancy,
    and thus improve compression.
  id: totrans-split-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¿¡ä¸ä¿¡ç”±ä½ ï¼ŒRARæ–‡ä»¶å¯ä»¥åŒ…å«ä¸€ä¸ªåä¸ºRarVMçš„ç®€å•ç±»ä¼¼x86çš„è™šæ‹Ÿæœºçš„å­—èŠ‚ç ã€‚è¿™è®¾è®¡ä¸ºæä¾›è¿‡æ»¤å™¨ï¼ˆé¢„å¤„ç†å™¨ï¼‰ï¼Œä»¥å¯¹è¾“å…¥æ•°æ®æ‰§è¡Œä¸€äº›å¯é€†è½¬æ¢ï¼Œå¢åŠ å†—ä½™æ€§ï¼Œä»è€Œæé«˜å‹ç¼©æ•ˆæœã€‚
- en: 'His [rarvmtools repo](https://github.com/taviso/rarvmtools) includes some details
    on the architecture:'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: ä»–çš„[rarvmtoolsä»“åº“](https://github.com/taviso/rarvmtools)åŒ…å«äº†ä¸€äº›å…³äºæ¶æ„çš„ç»†èŠ‚ï¼š
- en: Familiarity with x86 (and preferably intel assembly syntax) would be an advantage.
  id: totrans-split-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç†Ÿæ‚‰x86ï¼ˆæœ€å¥½æ˜¯è‹±ç‰¹å°”æ±‡ç¼–è¯­æ³•ï¼‰å°†æ˜¯ä¸€ä¸ªä¼˜åŠ¿ã€‚
- en: RarVM has 8 named registers, called r0 to r7\. r7 is used as a stack pointer
    for stack related operations (such as push, call, pop, etc). However, as on x86,
    there are no restrictions on setting r7 to whatever you like, although if you
    do something stack related it will be masked to fit within the address space for
    the duration of that operation.
  id: totrans-split-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RarVMæœ‰8ä¸ªå‘½åå¯„å­˜å™¨ï¼Œç§°ä¸ºr0åˆ°r7ã€‚r7ç”¨ä½œä¸å †æ ˆç›¸å…³æ“ä½œï¼ˆå¦‚æ¨é€ã€è°ƒç”¨ã€å¼¹å‡ºç­‰ï¼‰çš„å †æ ˆæŒ‡é’ˆã€‚ç„¶è€Œï¼Œä¸x86ä¸€æ ·ï¼Œå¯¹äºr7æ²¡æœ‰è®¾ç½®é™åˆ¶ï¼Œå°½ç®¡å¦‚æœæ‰§è¡Œå †æ ˆç›¸å…³æ“ä½œï¼Œå®ƒå°†è¢«å±è”½ä»¥é€‚åº”åœ°å€ç©ºé—´ï¼Œåœ¨è¯¥æ“ä½œçš„æŒç»­æ—¶é—´å†…ã€‚
- en: 'Some others:'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰ä¸€äº›å…¶ä»–ä¿¡æ¯ï¼š
- en: The [TrueType](https://developer.apple.com/fonts/TrueType-Reference-Manual/)
    font specification includes a set of over 200 instructions used for glyph rendering
    and hinting.
  id: totrans-split-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TrueType](https://developer.apple.com/fonts/TrueType-Reference-Manual/)å­—ä½“è§„èŒƒåŒ…æ‹¬ä¸€ç»„è¶…è¿‡200æ¡æŒ‡ä»¤ï¼Œç”¨äºå­—å½¢çš„æ¸²æŸ“å’Œæç¤ºã€‚'
- en: '[PostScript](https://en.wikipedia.org/wiki/PostScript) is not only a page description
    language, but a relatively powerful stack-based programming language. PostScript
    files are plain text, so a PostScript renderer doesnâ€™t necessarily use bytecode,
    but the spec also includes a binary encoding.'
  id: totrans-split-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PostScript](https://en.wikipedia.org/wiki/PostScript)ä¸ä»…æ˜¯ä¸€ç§é¡µé¢æè¿°è¯­è¨€ï¼Œè€Œä¸”æ˜¯ä¸€ç§ç›¸å¯¹å¼ºå¤§çš„åŸºäºå †æ ˆçš„ç¼–ç¨‹è¯­è¨€ã€‚PostScriptæ–‡ä»¶æ˜¯çº¯æ–‡æœ¬ï¼Œå› æ­¤PostScriptæ¸²æŸ“å™¨ä¸ä¸€å®šä½¿ç”¨å­—èŠ‚ç ï¼Œä½†è§„èŒƒä¹ŸåŒ…æ‹¬äº†äºŒè¿›åˆ¶ç¼–ç ã€‚'
- en: ğŸ‘‰ *[Discuss on Hacker News](https://news.ycombinator.com/item?id=40211205).*
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ‘‰ *[åœ¨Hacker Newsä¸Šè®¨è®º](https://news.ycombinator.com/item?id=40211205)*ã€‚
