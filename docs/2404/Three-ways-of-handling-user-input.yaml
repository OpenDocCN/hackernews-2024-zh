- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: æœªåˆ†ç±»'
- en: 'date: 2024-05-27 13:38:51'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 13:38:51'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Three ways of handling user input
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä¸‰ç§å¤„ç†ç”¨æˆ·è¾“å…¥çš„æ–¹å¼
- en: æ¥æºï¼š[https://dubroy.com/blog/three-ways-of-handling-user-input/](https://dubroy.com/blog/three-ways-of-handling-user-input/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://dubroy.com/blog/three-ways-of-handling-user-input/](https://dubroy.com/blog/three-ways-of-handling-user-input/)
- en: January 5, 2022
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 2022å¹´1æœˆ5æ—¥
- en: Although there has been important progress in models and packages for the output
    of graphics to computer screens, there has been little change in the way that
    input from the mouse, keyboard, and other input devices is handled. New graphics
    standards are still using a fifteen-year-old model even though it is widely accepted
    as inadequate.
  id: totrans-split-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°½ç®¡åœ¨å°†å›¾å½¢è¾“å‡ºåˆ°è®¡ç®—æœºå±å¹•çš„æ¨¡å‹å’ŒåŒ…æ–¹é¢å–å¾—äº†é‡è¦è¿›å±•ï¼Œä½†ä»é¼ æ ‡ã€é”®ç›˜å’Œå…¶ä»–è¾“å…¥è®¾å¤‡æ¥æ”¶è¾“å…¥çš„æ–¹å¼å‡ ä¹æ²¡æœ‰å˜åŒ–ã€‚å³ä½¿è¢«å¹¿æ³›è®¤ä¸ºä¸è¶³ä»¥æ»¡è¶³éœ€æ±‚ï¼Œæ–°çš„å›¾å½¢æ ‡å‡†ä»åœ¨ä½¿ç”¨ä¸€ä¸ªåäº”å¹´å‰çš„æ¨¡å‹ã€‚
- en: â€” *Brad Myers, [A New Model for Handling Input](https://www.cs.cmu.edu/~amulet/papers/p289-myers-TOIS-new-model.pdf),
    1990.*
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: â€” *å¸ƒæ‹‰å¾·Â·è¿ˆå°”æ–¯ï¼Œ[å¤„ç†è¾“å…¥çš„æ–°æ¨¡å‹](https://www.cs.cmu.edu/~amulet/papers/p289-myers-TOIS-new-model.pdf)ï¼Œ1990å¹´ã€‚*
- en: 'Itâ€™s 2022 and things are pretty much the same: the dominant way of handling
    user input is still based on events and â€” in some form or another â€” callbacks.
    They come in slightly different forms ([addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener),
    [responder](https://developer.apple.com/documentation/appkit/nsresponder) [objects](https://developer.apple.com/documentation/uikit/uiresponder),
    etc.) but the core idea is the same.'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å·²ç»æ˜¯2022å¹´ï¼Œæƒ…å†µä¾æ—§å¦‚æ­¤ï¼šå¤„ç†ç”¨æˆ·è¾“å…¥çš„ä¸»è¦æ–¹å¼ä»ç„¶æ˜¯åŸºäºäº‹ä»¶å’Œ â€”Â ä»¥æŸç§å½¢å¼ â€”Â å›è°ƒã€‚å®ƒä»¬ä»¥ç¨å¾®ä¸åŒçš„å½¢å¼å‡ºç°ï¼ˆ[addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)ï¼Œ[responder](https://developer.apple.com/documentation/appkit/nsresponder)
    [å¯¹è±¡](https://developer.apple.com/documentation/uikit/uiresponder)ï¼Œç­‰ç­‰ï¼‰ï¼Œä½†æ ¸å¿ƒæ€æƒ³æ˜¯ç›¸åŒçš„ã€‚
- en: Itâ€™s still going strong more than 40 years later, so the event-and-callback-based
    approach clearly has something going for it. But in nearly every code base Iâ€™ve
    worked in, the hairiest, most difficult-to-modify logic is in the event handling
    code. Handling user input is â€”Â to borrow [a phrase from Laurence Tratt](https://tratt.net/laurie/blog/entries/parsing_the_solved_problem_that_isnt.html)
    â€” a solved problem that *isnâ€™t*.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 40å¤šå¹´åå®ƒä»ç„¶å¼ºå¤§ï¼Œå› æ­¤åŸºäºäº‹ä»¶å’Œå›è°ƒçš„æ–¹æ³•æ˜¾ç„¶æœ‰å…¶ä¼˜ç‚¹ã€‚ä½†åœ¨æˆ‘å·¥ä½œè¿‡çš„å‡ ä¹æ¯ä¸ªä»£ç åº“ä¸­ï¼Œæœ€å¤æ‚ã€æœ€éš¾ä¿®æ”¹çš„é€»è¾‘éƒ½åœ¨äº‹ä»¶å¤„ç†ä»£ç ä¸­ã€‚å¤„ç†ç”¨æˆ·è¾“å…¥ â€”Â å€Ÿç”¨[åŠ³ä¼¦æ–¯Â·ç‰¹æ‹‰ç‰¹çš„ä¸€å¥è¯](https://tratt.net/laurie/blog/entries/parsing_the_solved_problem_that_isnt.html)
    â€”Â æ˜¯ä¸€ä¸ªè§£å†³äº†ä½†*å¹¶æœª*è§£å†³çš„é—®é¢˜ã€‚
- en: To help me understand the pros and cons of the events-and-callbacks model and
    to experiment with some other approaches, I decided to write up a simple example
    in a three different styles.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å¸®åŠ©æˆ‘ç†è§£äº‹ä»¶å’Œå›è°ƒæ¨¡å‹çš„åˆ©å¼Šï¼Œå¹¶å°è¯•ä¸€äº›å…¶ä»–æ–¹æ³•ï¼Œæˆ‘å†³å®šç”¨ä¸‰ç§ä¸åŒçš„é£æ ¼å†™ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ã€‚
- en: A toy problem
  id: totrans-split-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç©å…·é—®é¢˜
- en: 'The goal is to implement a square that you can either drag and drop, or click.
    The code should distinguish between the two gestures: a click shouldnâ€™t just be
    treated as a drop with no drag. Finally, when youâ€™re dragging, pressing escape
    should abort the drag and reset the object back to its original position.'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®æ ‡æ˜¯å®ç°ä¸€ä¸ªæ­£æ–¹å½¢ï¼Œä½ å¯ä»¥æ‹–æ”¾æˆ–ç‚¹å‡»ã€‚ä»£ç åº”è¯¥åŒºåˆ†è¿™ä¸¤ç§æ‰‹åŠ¿ï¼šç‚¹å‡»ä¸åº”ä»…è¢«è§†ä¸ºä¸€ä¸ªæ²¡æœ‰æ‹–åŠ¨çš„æ”¾ç½®ã€‚æœ€åï¼Œåœ¨æ‹–åŠ¨æ—¶ï¼ŒæŒ‰ä¸‹Escapeé”®åº”è¯¥ä¸­æ­¢æ‹–åŠ¨å¹¶å°†å¯¹è±¡é‡ç½®å›å…¶åŸå§‹ä½ç½®ã€‚
- en: Hereâ€™s an interactive demo. There are at least two bugs here â€”Â see if you can
    find them! ğŸ˜
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªäº¤äº’å¼æ¼”ç¤ºã€‚è¿™é‡Œè‡³å°‘æœ‰ä¸¤ä¸ªbug â€”Â çœ‹çœ‹ä½ èƒ½æ‰¾åˆ°å®ƒä»¬å—ï¼ ğŸ˜
- en: 'Approach #1: Event listeners'
  id: totrans-split-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ç§æ–¹æ³•ï¼šäº‹ä»¶ä¾¦å¬å™¨
- en: As a baseline, letâ€™s start with the standard approach based on event listeners.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºåŸºçº¿ï¼Œè®©æˆ‘ä»¬ä»åŸºäºäº‹ä»¶ä¾¦å¬å™¨çš„æ ‡å‡†æ–¹æ³•å¼€å§‹ã€‚
- en: '[PRE0]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are slightly nicer/cleaner ways to implement this, but I think this is
    pretty good as a representative example. Note that Iâ€™m using the `pointerdown`
    rather than `mousedown` so that I can take advantage of [pointer capture](https://developer.mozilla.org/en-US/docs/Web/API/Element/setPointerCapture#overview_of_pointer_capture).
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ›´å¥½/æ›´æ¸…æ™°çš„å®ç°æ–¹å¼ï¼Œä½†æˆ‘è®¤ä¸ºè¿™ä¸ªä½œä¸ºä¸€ä¸ªä»£è¡¨æ€§ç¤ºä¾‹å·²ç»å¾ˆä¸é”™äº†ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä½¿ç”¨`pointerdown`è€Œä¸æ˜¯`mousedown`ï¼Œä»¥ä¾¿æˆ‘å¯ä»¥åˆ©ç”¨[æŒ‡é’ˆæ•è·](https://developer.mozilla.org/en-US/docs/Web/API/Element/setPointerCapture#overview_of_pointer_capture)ã€‚
- en: 'Taking a look at it with a critical eye, the first thing that sticks out is
    the shared state thatâ€™s used by all of the event handlers:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: ä»”ç»†å®¡è§†å®ƒï¼Œé¦–å…ˆæ˜¾çœ¼çš„æ˜¯æ‰€æœ‰äº‹ä»¶å¤„ç†ç¨‹åºéƒ½ä½¿ç”¨çš„å…±äº«çŠ¶æ€ï¼š
- en: '`didDrag` keeps track of whether any *pointermove* event occurred, so we can
    distinguish between a drag and a click'
  id: totrans-split-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`didDrag` ç”¨äºè·Ÿè¸ªæ˜¯å¦å‘ç”Ÿäº†ä»»ä½•*pointermove*äº‹ä»¶ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åŒºåˆ†æ‹–åŠ¨å’Œç‚¹å‡»'
- en: '`dragOrigin` records the position where the drag gesture started, and doubles
    as a way of checking whether the mouse is currently down.'
  id: totrans-split-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dragOrigin` è®°å½•äº†æ‹–æ‹½æ‰‹åŠ¿å¼€å§‹çš„ä½ç½®ï¼Œå¹¶ä¸”ä¹Ÿå……å½“äº†æ£€æŸ¥é¼ æ ‡å½“å‰æ˜¯å¦æŒ‰ä¸‹çš„ä¸€ç§æ–¹å¼ã€‚'
- en: '`origPos` holds the original position of the target object, so we can reset
    it if the drag is canceled.'
  id: totrans-split-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`origPos` ä¿å­˜äº†ç›®æ ‡å¯¹è±¡çš„åŸå§‹ä½ç½®ï¼Œè¿™æ ·å¦‚æœæ‹–æ‹½è¢«å–æ¶ˆï¼Œæˆ‘ä»¬å°±å¯ä»¥é‡ç½®å®ƒã€‚'
- en: One thing I dislike a bit about the callback-based approach is how the control
    flow is mostly implicit. You can â€œjump intoâ€ control at many parts of the code,
    and the order of the handlers is purely determined by the order that the events
    arrive.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å¯¹åŸºäºå›è°ƒçš„æ–¹æ³•æœ‰ä¸€ç‚¹ä¸å–œæ¬¢çš„åœ°æ–¹æ˜¯æ§åˆ¶æµå¤§å¤šæ˜¯éšå¼çš„ã€‚ä½ å¯ä»¥åœ¨ä»£ç çš„è®¸å¤šéƒ¨åˆ†â€œè·³å…¥â€æ§åˆ¶ï¼Œå¹¶ä¸”å¤„ç†ç¨‹åºçš„é¡ºåºçº¯ç²¹ç”±äº‹ä»¶åˆ°è¾¾çš„é¡ºåºå†³å®šã€‚
- en: Can you spot the problem with the `pointerup` handler, that causes the bugs
    that I mentioned above?
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ èƒ½æ‰¾å‡º `pointerup` å¤„ç†ç¨‹åºä¸­å¯¼è‡´æˆ‘ä¸Šé¢æåˆ°çš„é—®é¢˜çš„é—®é¢˜å—ï¼Ÿ
- en: <details><summary>*Show me the answer!*</summary> The body of `pointerup` handler
    should be guarded with `if (dragOrigin) { ... }`, just like the `pointermove`
    handler. Otherwise (1) a drag that starts *outside* the square, but ends over
    it, is treated as a click; and (2) after cancelling a drag, the next `pointerup`
    event sets the status to *dropped*.</details>
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: <details><summary>*ç»™æˆ‘çœ‹ç­”æ¡ˆï¼*</summary> `pointerup` å¤„ç†ç¨‹åºçš„ä¸»ä½“åº”è¯¥é€šè¿‡ `if (dragOrigin)
    { ... }` è¿›è¡Œä¿æŠ¤ï¼Œå°±åƒ `pointermove` å¤„ç†ç¨‹åºä¸€æ ·ã€‚å¦åˆ™ (1) ä»æ­£æ–¹å½¢å¤–å¼€å§‹ä½†åœ¨å…¶ä¸Šç»“æŸçš„æ‹–æ‹½ä¼šè¢«è§†ä¸ºç‚¹å‡»ï¼›(2) åœ¨å–æ¶ˆæ‹–åŠ¨åï¼Œä¸‹ä¸€ä¸ª
    `pointerup` äº‹ä»¶å°†çŠ¶æ€è®¾ç½®ä¸º *dropped*ã€‚</details>
- en: 'Approach #2: Polling'
  id: totrans-split-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'æ–¹æ³• #2ï¼šè½®è¯¢'
- en: Another way to handle user input is *polling*, or periodically checking the
    state of the hardware. The original Smalltalk MVC used this approach, and itâ€™s
    still used in game programming. ^(I donâ€™t think Iâ€™ve ever written any code that
    used polling for handling user input, so I wanted to at least give it a try.)
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: å¤„ç†ç”¨æˆ·è¾“å…¥çš„å¦ä¸€ç§æ–¹æ³•æ˜¯ *è½®è¯¢*ï¼Œå³å®šæœŸæ£€æŸ¥ç¡¬ä»¶çŠ¶æ€ã€‚æœ€åˆçš„Smalltalk MVCå°±ä½¿ç”¨äº†è¿™ç§æ–¹æ³•ï¼Œåœ¨æ¸¸æˆç¼–ç¨‹ä¸­ä»ç„¶è¢«å¹¿æ³›ä½¿ç”¨ã€‚^(æˆ‘æƒ³æˆ‘ä»æ¥æ²¡æœ‰ç¼–å†™è¿‡ä½¿ç”¨è½®è¯¢å¤„ç†ç”¨æˆ·è¾“å…¥çš„ä»£ç ï¼Œæ‰€ä»¥æˆ‘è‡³å°‘æƒ³è¯•è¯•ã€‚)
- en: Below is a polling-based version of the same example from above. Iâ€™ve left out
    the helper code that takes care of updating the `mouse` and `keyboard` variables
    using the standard DOM events.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯ä¸ä¸Šè¿°ç›¸åŒç¤ºä¾‹çš„åŸºäºè½®è¯¢çš„ç‰ˆæœ¬ã€‚æˆ‘çœç•¥äº†å¤„ç†æ›´æ–° `mouse` å’Œ `keyboard` å˜é‡çš„å¸®åŠ©ä»£ç ã€‚
- en: '[PRE1]'
  id: totrans-split-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Conceptually, polling is a pretty simple approach, but it imposes a fair bit
    of extra complexity on the handling code. For one thing, I needed `didHandlePointerDown`
    so that it only reacts once when the mouse button is pressed, rather than on every
    frame. I also needed to do my own hit testing with `rectContains`. This is one
    downside of polling â€” you need to implement extra bookkeeping for some things
    that you get for free in an event-based model.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¦‚å¿µä¸Šï¼Œè½®è¯¢æ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„æ–¹æ³•ï¼Œä½†å®ƒä¼šç»™å¤„ç†ä»£ç å¢åŠ ç›¸å½“å¤šçš„é¢å¤–å¤æ‚æ€§ã€‚é¦–å…ˆï¼Œæˆ‘éœ€è¦ `didHandlePointerDown`ï¼Œè¿™æ ·å®ƒåªåœ¨æŒ‰ä¸‹é¼ æ ‡æŒ‰é’®æ—¶æ‰ä¼šååº”ä¸€æ¬¡ï¼Œè€Œä¸æ˜¯æ¯å¸§éƒ½ä¼šååº”ã€‚æˆ‘è¿˜éœ€è¦ä½¿ç”¨
    `rectContains` æ¥è¿›è¡Œè‡ªå·±çš„å‘½ä¸­æµ‹è¯•ã€‚è¿™æ˜¯è½®è¯¢çš„ä¸€ä¸ªç¼ºç‚¹ â€”â€” ä½ éœ€è¦ä¸ºä¸€äº›ä¸œè¥¿å®ç°é¢å¤–çš„è®°å½•ï¼Œè€Œåœ¨äº‹ä»¶é©±åŠ¨æ¨¡å‹ä¸­ä½ æ˜¯å…è´¹è·å¾—è¿™äº›çš„ã€‚
- en: Of course, the major drawback of polling is that you always need to be checking
    for state changes. This consumes CPU cycles, and if itâ€™s not frequent enough,
    you can miss some user input. Thatâ€™s why itâ€™s not seen much anymore outside game
    programming, where you typically have an active rendering loop anyways.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè½®è¯¢çš„ä¸»è¦ç¼ºç‚¹æ˜¯ä½ æ€»æ˜¯éœ€è¦æ£€æŸ¥çŠ¶æ€å˜åŒ–ã€‚è¿™ä¼šæ¶ˆè€—CPUå‘¨æœŸï¼Œå¦‚æœæ£€æŸ¥é¢‘ç‡ä¸å¤Ÿé«˜ï¼Œå¯èƒ½ä¼šé”™è¿‡ä¸€äº›ç”¨æˆ·è¾“å…¥ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨æ¸¸æˆç¼–ç¨‹ä¹‹å¤–å®ƒä¸å†å¸¸è§çš„åŸå› ï¼Œå› ä¸ºé€šå¸¸ä½ å·²ç»æœ‰ä¸€ä¸ªæ´»è·ƒçš„æ¸²æŸ“å¾ªç¯ã€‚
- en: On the plus side, the control flow is more explicit when compared to the event
    listener approach. For example, the code that handles cancellation will always
    run after any other other handler *in the same frame*. We do still need to be
    careful not process a `pointerup` without a corresponding `pointerdown`, as those
    would always be handled in separate frames.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£é¢çœ‹ï¼Œä¸äº‹ä»¶ç›‘å¬å™¨æ–¹æ³•ç›¸æ¯”ï¼Œæ§åˆ¶æµæ›´ä¸ºæ˜¾å¼ã€‚ä¾‹å¦‚ï¼Œå¤„ç†å–æ¶ˆçš„ä»£ç æ€»æ˜¯ä¼šåœ¨åŒä¸€å¸§ä¸­çš„ä»»ä½•å…¶ä»–å¤„ç†ç¨‹åºä¹‹åè¿è¡Œã€‚æˆ‘ä»¬ä»ç„¶éœ€è¦æ³¨æ„ï¼Œä¸è¦åœ¨æ²¡æœ‰å¯¹åº”çš„ `pointerdown`
    çš„æƒ…å†µä¸‹å¤„ç† `pointerup`ï¼Œå› ä¸ºå®ƒä»¬æ€»æ˜¯åœ¨ä¸åŒçš„å¸§ä¸­å¤„ç†ã€‚
- en: Another thing thatâ€™s nice here is that you basically have unrestricted access
    to the current state of the input devices, whereas in the callback-based model,
    itâ€™s less convenient to do something like looking at the current mouse position
    inside the `keydown` handler. DOM events hack around this limitation by including
    some keyboard state in the MouseEvent instances ([`altKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/altKey),[`ctrlKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/ctrlKey),
    etc.), but that only addresses the most common cases.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œè¿˜æœ‰ä¸€ç‚¹å¾ˆå¥½çš„åœ°æ–¹ï¼Œä½ åŸºæœ¬ä¸Šå¯ä»¥æ— é™åˆ¶åœ°è®¿é—®å½“å‰è¾“å…¥è®¾å¤‡çš„çŠ¶æ€ï¼Œè€Œåœ¨åŸºäºå›è°ƒçš„æ¨¡å‹ä¸­ï¼Œè¦åšåƒåœ¨`keydown`å¤„ç†ç¨‹åºä¸­æŸ¥çœ‹å½“å‰é¼ æ ‡ä½ç½®è¿™æ ·çš„äº‹æƒ…å°±ä¸é‚£ä¹ˆæ–¹ä¾¿äº†ã€‚DOMäº‹ä»¶é€šè¿‡åœ¨MouseEventå®ä¾‹ä¸­åŒ…å«ä¸€äº›é”®ç›˜çŠ¶æ€ï¼ˆä¾‹å¦‚[`altKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/altKey)ï¼Œ[`ctrlKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/ctrlKey)ç­‰ï¼‰æ¥è§£å†³è¿™ä¸€é™åˆ¶ï¼Œä½†è¿™åªè§£å†³äº†æœ€å¸¸è§çš„æƒ…å†µã€‚
- en: 'With polling, not only do you have more flexibility in *where* you examine
    the input state, but also *when* you examine it. With events, thereâ€™s an inversion
    of control: the event dispatch mechanism determines when (and if) each component
    observes the state change. This can be limiting, but itâ€™s also a huge benefit
    for composability, as it enables loosely-coupled coordination between parent and
    child components (e.g. event delegation). I donâ€™t know how you could achieve the
    something similar in polling-based model.'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è½®è¯¢ï¼Œä¸ä»…å¯ä»¥æ›´çµæ´»åœ°*æ£€æŸ¥è¾“å…¥çŠ¶æ€çš„ä½ç½®*ï¼Œè¿˜å¯ä»¥*æ£€æŸ¥å…¶å‘ç”Ÿçš„æ—¶é—´*ã€‚ä½¿ç”¨äº‹ä»¶æ—¶ï¼Œæ§åˆ¶æƒæœ‰æ‰€å€’ç½®ï¼šäº‹ä»¶åˆ†å‘æœºåˆ¶å†³å®šæ¯ä¸ªç»„ä»¶ä½•æ—¶ï¼ˆä»¥åŠæ˜¯å¦ï¼‰è§‚å¯ŸçŠ¶æ€æ›´æ”¹ã€‚è¿™å¯èƒ½æœ‰æ‰€é™åˆ¶ï¼Œä½†å¯¹äºç»„åˆæ€§è€Œè¨€ï¼Œå´æ˜¯ä¸€ä¸ªå·¨å¤§çš„ä¼˜åŠ¿ï¼Œå› ä¸ºå®ƒæ”¯æŒçˆ¶å­ç»„ä»¶ä¹‹é—´çš„æ¾è€¦åˆåè°ƒï¼ˆä¾‹å¦‚äº‹ä»¶å§”æ‰˜ï¼‰ã€‚æˆ‘ä¸çŸ¥é“å¦‚ä½•åœ¨åŸºäºè½®è¯¢çš„æ¨¡å‹ä¸­å®ç°ç±»ä¼¼çš„ä¸œè¥¿ã€‚
- en: Hybrid models
  id: totrans-split-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ··åˆæ¨¡å‹
- en: After reading the first draft of this post, a few people mentioned event-based
    approaches that feel somewhat similar to the polling approach. For example, you
    could have a single callback that handles all the events, rather than a separate
    callback for each event.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨é˜…è¯»æœ¬æ–‡åˆç¨¿åï¼Œæœ‰å‡ ä¸ªäººæåˆ°åŸºäºäº‹ä»¶çš„æ–¹æ³•ï¼Œæ„Ÿè§‰ä¸è½®è¯¢æ–¹æ³•æœ‰äº›ç±»ä¼¼ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥æœ‰ä¸€ä¸ªå•ä¸€çš„å›è°ƒå‡½æ•°æ¥å¤„ç†æ‰€æœ‰äº‹ä»¶ï¼Œè€Œä¸æ˜¯æ¯ä¸ªäº‹ä»¶éƒ½æœ‰ä¸€ä¸ªå•ç‹¬çš„å›è°ƒå‡½æ•°ã€‚
- en: This gives you all the advantages of events, while making the control flow a
    bit more explicit (as with the polling approach), and making it easier to share
    state and code between the different paths.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä½¿ä½ å¯ä»¥äº«å—äº‹ä»¶çš„æ‰€æœ‰ä¼˜åŠ¿ï¼ŒåŒæ—¶ä½¿æ§åˆ¶æµç¨‹æ›´åŠ æ˜ç¡®ï¼ˆå°±åƒè½®è¯¢æ–¹æ³•ä¸€æ ·ï¼‰ï¼Œå¹¶ä¸”æ›´å®¹æ˜“åœ¨ä¸åŒè·¯å¾„ä¹‹é—´å…±äº«çŠ¶æ€å’Œä»£ç ã€‚
- en: 'Approach #3: Process-oriented'
  id: totrans-split-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ–¹æ³•ä¸‰ï¼šé¢å‘è¿›ç¨‹
- en: 'The third approach I wanted to try is inspired by [Squeak: a Language for Communicating
    with Mice](https://swtch.com/~rsc/thread/squeak.pdf), by Luca Cardelli and Rob
    Pike. The core idea is that concurrent, communicating processes are a good way
    to model user interaction. Note that *process* here doesnâ€™t mean an OS-level process;
    it means a lightweight, sequential thread of control, like a [goroutine](https://go.dev/tour/concurrency/1)
    or a [Ruby fiber](https://ruby-doc.org/core-2.5.0/Fiber.html).'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æƒ³å°è¯•çš„ç¬¬ä¸‰ç§æ–¹æ³•çµæ„Ÿæ¥è‡ª[Squeakï¼šä¸é¼ æ ‡äº¤æµçš„è¯­è¨€](https://swtch.com/~rsc/thread/squeak.pdf)ï¼Œä½œè€…æ˜¯Luca
    Cardelliå’ŒRob Pikeã€‚æ ¸å¿ƒæ€æƒ³æ˜¯å¹¶å‘çš„ã€é€šä¿¡çš„è¿›ç¨‹æ˜¯æ¨¡æ‹Ÿç”¨æˆ·äº¤äº’çš„ä¸€ä¸ªå¾ˆå¥½çš„æ–¹æ³•ã€‚è¯·æ³¨æ„ï¼Œè¿™é‡Œçš„*è¿›ç¨‹*å¹¶ä¸æ˜¯æŒ‡æ“ä½œç³»ç»Ÿçº§åˆ«çš„è¿›ç¨‹ï¼›å®ƒæŒ‡çš„æ˜¯è½»é‡çº§çš„ã€é¡ºåºæ§åˆ¶çš„çº¿ç¨‹ï¼Œç±»ä¼¼äº[goroutine](https://go.dev/tour/concurrency/1)æˆ–[Ruby
    fiber](https://ruby-doc.org/core-2.5.0/Fiber.html)ã€‚
- en: To experiment with these ideas in JS, I built a tiny library called Abro.js
    ^(which provides some slightly higher-level abstractions on top of `async` and
    `await`. The result looks a lot more like the [Esterel language](http://www-sop.inria.fr/meije/esterel/esterel-eng.html)
    than Squeak. (Esterel was also an inspiration for Cardelli and Pike.))
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: è¦åœ¨JSä¸­å°è¯•è¿™äº›æƒ³æ³•ï¼Œæˆ‘æ„å»ºäº†ä¸€ä¸ªåä¸ºAbro.jsçš„å°å‹åº“ï¼Œ^(å®ƒåœ¨`async`å’Œ`await`ä¹‹ä¸Šæä¾›äº†ä¸€äº›ç¨é«˜çº§çš„æŠ½è±¡ã€‚ç»“æœçœ‹èµ·æ¥æ›´åƒ[Esterelè¯­è¨€](http://www-sop.inria.fr/meije/esterel/esterel-eng.html)ï¼Œè€Œä¸æ˜¯Squeakã€‚ï¼ˆEsterelä¹Ÿæ˜¯Cardelliå’ŒPikeçš„çµæ„Ÿæ¥æºã€‚))
- en: 'Hereâ€™s a working implementation based on Abro:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªåŸºäºAbroçš„å·¥ä½œå®ç°ï¼š
- en: '[PRE2]'
  id: totrans-split-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also try this version out:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ä¹Ÿå¯ä»¥å°è¯•è¿™ä¸ªç‰ˆæœ¬ï¼š
- en: 'Before getting into the details, let me explain the basics of Abro:'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ·±å…¥è®¨è®ºä¹‹å‰ï¼Œè®©æˆ‘è§£é‡Šä¸€ä¸‹Abroçš„åŸºç¡€ï¼š
- en: Each process (or *fiber*) is an async function that can block until an event
    arrives from an *EventSource*. For example, control will block at 1ï¸âƒ£ [â†©](#code-pointerdown)
    until a `pointerdown` occurs.
  id: totrans-split-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ä¸ªè¿›ç¨‹ï¼ˆæˆ–*çº¤ç¨‹*ï¼‰æ˜¯ä¸€ä¸ªå¼‚æ­¥å‡½æ•°ï¼Œå¯ä»¥é˜»å¡ï¼Œç›´åˆ°ä»*EventSource*æ¥æ”¶åˆ°äº‹ä»¶ä¸ºæ­¢ã€‚ä¾‹å¦‚ï¼Œæ§åˆ¶å°†åœ¨1ï¸âƒ£ [â†©](#code-pointerdown)å¤„é˜»å¡ï¼Œç›´åˆ°å‘ç”Ÿ`pointerdown`äº‹ä»¶ã€‚
- en: Unlike regular async functions, Abro fibers can be cleanly terminated from the
    outside. I do this by keeping track of the promise that each fiber is blocked
    on, so it can be terminated by rejecting that promise.
  id: totrans-split-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸æ™®é€šçš„å¼‚æ­¥å‡½æ•°ä¸åŒï¼ŒAbroçº¤ç¨‹å¯ä»¥ä»å¤–éƒ¨æ¸…æ™°åœ°ç»ˆæ­¢ã€‚æˆ‘é€šè¿‡è·Ÿè¸ªæ¯ä¸ªçº¤ç¨‹æ‰€é˜»å¡çš„Promiseæ¥å®ç°è¿™ä¸€ç‚¹ï¼Œå› æ­¤å¯ä»¥é€šè¿‡æ‹’ç»è¯¥Promiseæ¥ç»ˆæ­¢å®ƒã€‚
- en: '`abro.or` (see 2ï¸âƒ£ [â†©](#code-abro-or)) starts multiple fibers, and as soon
    as one of them completes, the others are terminated. Itâ€™s based on the `par/or`
    construct in [CÃ©u](http://www.ceu-lang.org/), another Esterel-inspired language.'
  id: totrans-split-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abro.or`ï¼ˆè§ 2ï¸âƒ£ [â†©](#code-abro-or)ï¼‰å¯åŠ¨å¤šä¸ªçº¤ç¨‹ï¼Œä¸€æ—¦å…¶ä¸­ä¸€ä¸ªå®Œæˆï¼Œå…¶ä»–çº¤ç¨‹å°±ä¼šç»ˆæ­¢ã€‚å®ƒåŸºäº[CÃ©u](http://www.ceu-lang.org/)ä¸­çš„`par/or`ç»“æ„ï¼Œè¿™æ˜¯å—Esterelå¯å‘çš„å¦ä¸€ç§è¯­è¨€ã€‚'
- en: The ability to terminate fibers from the outside makes it possible to write
    loops with no explicit exit condition (see 3ï¸âƒ£ [â†©](#code-infinite-loop)), as long
    as they block somewhere within the loop.
  id: totrans-split-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»å¤–éƒ¨ç»ˆæ­¢çº¤ç¨‹çš„èƒ½åŠ›ä½¿å¾—ç¼–å†™æ²¡æœ‰æ˜¾å¼é€€å‡ºæ¡ä»¶çš„å¾ªç¯æˆä¸ºå¯èƒ½ï¼ˆè§ 3ï¸âƒ£ [â†©](#code-infinite-loop)ï¼‰ï¼Œåªè¦å®ƒä»¬åœ¨å¾ªç¯å†…çš„æŸä¸ªåœ°æ–¹é˜»å¡å³å¯ã€‚
- en: If youâ€™re interested, you can take a look at [Abro on GitHub](https://github.com/pdubroy/handling-user-input/blob/main/abro.js),
    but be warned â€”Â itâ€™s very much a work in progress.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æ„Ÿå…´è¶£ï¼Œä½ å¯ä»¥æŸ¥çœ‹[GitHubä¸Šçš„Abro](https://github.com/pdubroy/handling-user-input/blob/main/abro.js)ï¼Œä½†è¯·æ³¨æ„â€”â€”å®ƒç›®å‰ä»åœ¨ç§¯æå¼€å‘ä¸­ã€‚
- en: This first thing to notice with this approach is the clear, explicit sequencing
    between the different states. The first line of the loop blocks on a `pointerdown`
    event; the other handlers arenâ€™t even active until control proceeds past that
    point^.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æ–¹æ³•çš„ç¬¬ä¸€ä»¶éœ€è¦æ³¨æ„çš„äº‹æƒ…æ˜¯ä¸åŒçŠ¶æ€ä¹‹é—´çš„æ¸…æ™°ã€æ˜ç¡®çš„åºåˆ—ã€‚å¾ªç¯çš„ç¬¬ä¸€è¡Œåœ¨`pointerdown`äº‹ä»¶ä¸Šé˜»å¡ï¼›ç›´åˆ°æ§åˆ¶æµè¿‡è¯¥ç‚¹åï¼Œå…¶ä»–å¤„ç†ç¨‹åºç”šè‡³éƒ½ä¸æ´»è·ƒ^ã€‚
- en: The other thing I really like is the separation of concerns thatâ€™s enabled by
    the `or` construct along with the ability to abort individual threads of control.
    Take a close look at `handleDrag` â€” itâ€™s just an infinite loop that processes
    `pointermove` events. It doesnâ€™t need to be concerned with cancellation, that
    happens automatically when the `handleEscape` task completes. Also, since this
    is built on top of events, we can still take advantage of event bubbling and other
    forms of coordination between a container and its descendants.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘çœŸæ­£å–œæ¬¢çš„å¦ä¸€ä»¶äº‹æ˜¯ç”±`or`ç»“æ„å’Œä¸­æ­¢å•ä¸ªæ§åˆ¶çº¿ç¨‹çš„èƒ½åŠ›å¯ç”¨çš„å…³æ³¨ç‚¹åˆ†ç¦»ã€‚ä»”ç»†çœ‹çœ‹`handleDrag` â€”â€” å®ƒåªæ˜¯å¤„ç†`pointermove`äº‹ä»¶çš„æ— é™å¾ªç¯ã€‚å®ƒä¸éœ€è¦å…³æ³¨å–æ¶ˆæ“ä½œï¼Œå½“`handleEscape`ä»»åŠ¡å®Œæˆæ—¶ï¼Œå–æ¶ˆæ“ä½œä¼šè‡ªåŠ¨å‘ç”Ÿã€‚æ­¤å¤–ï¼Œç”±äºè¿™æ˜¯åŸºäºäº‹ä»¶çš„ï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥åˆ©ç”¨äº‹ä»¶å†’æ³¡å’Œå®¹å™¨åŠå…¶åä»£ä¹‹é—´çš„å…¶ä»–å½¢å¼åè°ƒã€‚
- en: Overall, I find the process-oriented approach to be pretty compelling. It seems
    to retain all the advantages of the event-driven model (e.g., in comparison to
    polling), while improving on some of the issues that callbacks have. Iâ€™m definitely
    interested to try it out in some more realistic use cases.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»çš„æ¥è¯´ï¼Œæˆ‘å‘ç°é¢å‘è¿‡ç¨‹çš„æ–¹æ³•ç›¸å½“å¼•äººå…¥èƒœã€‚å®ƒä¼¼ä¹ä¿ç•™äº†äº‹ä»¶é©±åŠ¨æ¨¡å‹çš„æ‰€æœ‰ä¼˜åŠ¿ï¼ˆä¾‹å¦‚ä¸è½®è¯¢ç›¸æ¯”ï¼‰ï¼ŒåŒæ—¶æ”¹è¿›äº†å›è°ƒå‡½æ•°å­˜åœ¨çš„ä¸€äº›é—®é¢˜ã€‚æˆ‘ç»å¯¹æœ‰å…´è¶£åœ¨ä¸€äº›æ›´ç°å®çš„ç”¨ä¾‹ä¸­å°è¯•å®ƒã€‚
- en: I found it really useful to work through a toy problem with a few different
    approaches. Comparing event listeners to polling made it much easier for me to
    see the pros and cons of each style. The advantages of events (and event dispatch)
    are much more obvious to me now, and I realized that polling isnâ€™t really as simple
    as it sounds.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å‘ç°é€šè¿‡å‡ ç§ä¸åŒçš„æ–¹æ³•è§£å†³ä¸€ä¸ªç©å…·é—®é¢˜éå¸¸æœ‰ç”¨ã€‚æ¯”è¾ƒäº‹ä»¶ç›‘å¬å™¨å’Œè½®è¯¢ä½¿æˆ‘æ›´å®¹æ˜“çœ‹åˆ°æ¯ç§é£æ ¼çš„åˆ©å¼Šã€‚äº‹ä»¶ï¼ˆå’Œäº‹ä»¶åˆ†å‘ï¼‰çš„ä¼˜åŠ¿å¯¹æˆ‘æ¥è¯´ç°åœ¨æ˜æ˜¾å¤šäº†ï¼Œæˆ‘æ„è¯†åˆ°è½®è¯¢å¹¶ä¸åƒå¬èµ·æ¥é‚£ä¹ˆç®€å•ã€‚
- en: 'Of course, the three styles Iâ€™ve presented here are just a starting point,
    and there are many other approaches that I havenâ€™t touched on. There are two in
    particular that I want to briefly mention:'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘åœ¨è¿™é‡Œå±•ç¤ºçš„ä¸‰ç§é£æ ¼åªæ˜¯ä¸€ä¸ªèµ·ç‚¹ï¼Œè¿˜æœ‰è®¸å¤šå…¶ä»–æ–¹æ³•æˆ‘æ²¡æœ‰æ¶‰åŠåˆ°ã€‚æœ‰ä¸¤ç§æ–¹æ³•ç‰¹åˆ«å€¼å¾—ä¸€æï¼š
- en: '[Statecharts](https://statecharts.dev/) are closely related to the process-oriented
    model Iâ€™ve explored here. The [original statecharts paper](https://dubroy.com/refs/Statecharts_a_visual_formalism_for_complex_systems.pdf)
    references Esterel, saying: *â€œIt is motivated by concerns very similar to our
    own, and many of the resulting decisions taken there are strikingly similar to
    those present in statecharts.â€* Thereâ€™s enough to unpack there that I decided
    to leave it for a follow-up post.'
  id: totrans-split-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[çŠ¶æ€å›¾](https://statecharts.dev/)ä¸æˆ‘åœ¨è¿™é‡Œæ¢è®¨è¿‡çš„é¢å‘è¿‡ç¨‹æ¨¡å‹å¯†åˆ‡ç›¸å…³ã€‚[åŸå§‹çŠ¶æ€å›¾è®ºæ–‡](https://dubroy.com/refs/Statecharts_a_visual_formalism_for_complex_systems.pdf)å¼•ç”¨äº†Esterelï¼Œç§°ï¼šâ€œå®ƒçš„åŠ¨æœºä¸æˆ‘ä»¬è‡ªå·±çš„å…³æ³¨éå¸¸ç›¸ä¼¼ï¼Œè€Œä¸”å…¶ä¸­è®¸å¤šç»“æœå†³ç­–ä¸çŠ¶æ€å›¾ä¸­çš„é‚£äº›å†³ç­–éå¸¸ç›¸ä¼¼ã€‚â€
    é‚£é‡Œæœ‰è¶³å¤Ÿçš„å†…å®¹éœ€è¦è§£è¯»ï¼Œæ‰€ä»¥æˆ‘å†³å®šå°†å…¶ç•™ç»™åç»­æ–‡ç« ã€‚'
- en: '[Functional reactive programming](https://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming)
    (FRP), and related approaches like RxJS. I donâ€™t have much experience with FRP,
    but I really should give it a try. Maybe another topic for a future post!'
  id: totrans-split-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[å‡½æ•°å¼å“åº”å¼ç¼–ç¨‹](https://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming)ï¼ˆFRPï¼‰åŠå…¶ç›¸å…³æ–¹æ³•ï¼Œå¦‚
    RxJSã€‚æˆ‘å¯¹FRPçš„ç»éªŒä¸å¤šï¼Œä½†ç¡®å®åº”è¯¥è¯•ä¸€è¯•ã€‚ä¹Ÿè®¸æ˜¯æœªæ¥æ–‡ç« çš„å¦ä¸€ä¸ªè¯é¢˜ï¼'
- en: Check out [Part II](https://dubroy.com/blog/handling-user-input-with-structured-concurrency/),
    where I dig into the implementation details of Abro.js, and explore the process-oriented
    approach a bit more deeply.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥çœ‹ [ç¬¬äºŒéƒ¨åˆ†](https://dubroy.com/blog/handling-user-input-with-structured-concurrency/)ï¼Œåœ¨é‚£é‡Œæˆ‘æ·±å…¥æ¢è®¨äº†
    Abro.js çš„å®ç°ç»†èŠ‚ï¼Œå¹¶æ›´æ·±å…¥åœ°æ¢ç´¢äº†é¢å‘è¿‡ç¨‹çš„æ–¹æ³•ã€‚
- en: ğŸ’¬ *Want to leave feedback? [Send me an email](https://dubroy.com/blog/about/#contact)
    or [respond on on Twitter](https://twitter.com/dubroy/status/1478728490807611393).*
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¬ *æƒ³è¦ç•™ä¸‹åé¦ˆï¼Ÿ[ç»™æˆ‘å‘ç”µå­é‚®ä»¶](https://dubroy.com/blog/about/#contact) æˆ–è€… [åœ¨ Twitter ä¸Šå›å¤](https://twitter.com/dubroy/status/1478728490807611393)ã€‚*
- en: '*Thanks to Mariano Guerra, Sarah GHP, and Kevin Lynagh for providing feedback
    on my drafts.*'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ„Ÿè°¢ Mariano Guerraã€Sarah GHP å’Œ Kevin Lynagh å¯¹æˆ‘çš„è‰ç¨¿æä¾›åé¦ˆã€‚*'
