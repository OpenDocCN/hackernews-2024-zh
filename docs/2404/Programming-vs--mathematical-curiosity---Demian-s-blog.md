<!--yml

category: 未分类

date: 2024-05-27 13:22:03

-->

# 编程与数学好奇心 | Demian's blog

> 来源：[https://demian.ferrei.ro/blog/programmer-vs-mathematician](https://demian.ferrei.ro/blog/programmer-vs-mathematician)

最近我发现了一个关于数字的令人费解的性质，让我反思了作为程序员的心理活动。程序员和数学家虽然有许多共同点——都兼具游戏性和严谨性，以及解决逻辑问题的嗜好——但可能受到非常不同的动机驱使。当然，这只是非常笼统的描述。每个人都是独特的。

考虑这个简单的问题：如果我们选一个数字，将其数字按降序和升序排列以获得两个不同的数字，然后相减会发生什么？

例如，我们选择数字1988。将其数字按降序和升序排列得到9881和1889，相减得到7992。引人入胜，是吧。但如果我们从7992开始重复这个过程，然后继续呢？

请花点时间思考一下会发生什么。不一定要用笔和纸验证，但你的直觉怎么说？

好吧，让我们看看。从1988开始，序列会是：

旁注：如果我们从2023开始——我开始写这篇博客并拖延的那一年——序列会看起来几乎相同。第一步将是3220 − 0223 = 2997，之后将继续同样的方式进行。这并不像看上去那么巧合；这些序列中的数字往往会重复。

> 1998 → 9881 − 1889 = 7992
> 
> 7992 → 9972 − 2799 = 7173
> 
> 7173 → 7731 − 1377 = 6354
> 
> 6354 → 6543 − 3456 = 3087
> 
> 3087 → 8730 − 0378 = 8352
> 
> 8352 → 8532 − 2358 = 6174
> 
> 6174 → 7641 − 1467 = 6174
> 
> 6174 → 7641 − 1467 = 6174
> 
> …

一旦我们达到6174，序列就开始重复，因为将这种“最大数字排列减去最小数字排列”操作应用于6174的结果就是6174本身。或者用数学术语说：6174是这个操作的一个[不动点](https://en.wikipedia.org/wiki/Fixed_point_(mathematics))。

现在的关键是：只要起始数字不是单一重复的数字，**我们可以从任何4位数开始，序列总能达到6174**。

当然，这并不是一个新发现。6174以数学家发现这一奇特性而闻名，被称为[Kaprekar常数](https://en.wikipedia.org/wiki/6174_(number))。

我不知道你是怎么想的，但当我第一次听说时，我感到很惊讶。所有数字都收敛到一个数字？而不是可能收敛到不同的数字或陷入循环？谁会预料到这个！？

但我也没有数学工具 —— 或者说实际上也没有好奇心 —— 深入研究这个问题的数学原理。幸运的是，四位数并不多，而计算机速度很快，这是我听说的。因此，与其用数学方式证明这个“正确”的方法，不如让我们玩得开心点，写一个简单的Ruby程序来检查每个四位数的这个性质。实际上我们可以用任何语言。我喜欢用Ruby来进行这种探索，因为它不会阻碍表达事物的自由。

### 一个简单的子问题

让我们做一些自底向上的开发，从最简单的部分开始：检查一个数字是否由单个重复的数字组成。这些数字在娱乐数学中被称为[repdigit](https://en.wikipedia.org/wiki/Repdigit)。

```
def repdigit?(n) = n.digits.uniq.size == 1 
```

如果你不习惯Ruby，这一行确实有点复杂，所以我们来分解一下。`n.digits`方法为我们提供了一个包含数字十进制位的数组。然后我们使用`uniq`来过滤重复的数字。所以我们基本上是在说：如果一个数字只有一个不同的数字，那么它就是一个repdigit。这段代码几乎可以看作是其英文解释的压缩版本。

顺便说一句，如果你对这个`def name(args) = expr`的怪异性感到疑惑，那是Ruby的[“无尽”方法](https://bugs.ruby-lang.org/issues/16746)语法，它在3.0版本中首次亮相。老实说，我对此还有些犹豫。一方面，它似乎是那种不必要的语法糖，往往会使语言臃肿并复杂化回答基本问题，比如“我怎么定义一个方法？”。但同时，它可以用来区分一种情况，即某些情况可以用一个表达式简洁表达，而其他情况需要多个语句。

哦，是的，方法名可以以`?`结尾，这实际上是Ruby中布尔谓词的约定。

无论如何，回到我们的程序吧！这个`repdigit?`的定义是正确的，适用于任意长度的数字。但我们只关心四位数。而且如果我们在较小的数字上加上前导零，Kaprekar的性质也适用。例如，777是一个repdigit，但如果我们将其视为四位数并写为0777，那么我们可以从7770 - 0777 = 6993开始这个序列，并在3个步骤后达到Kaprekar的常数。

因此，我们只关心四位数的repdigit，如1111，2222等。换句话说，1111的倍数：

```
def repdigit?(n) = n % 1111 == 0 
```

### Kaprekar的例程

在抽象层次上跳得更高一点，将一个数字的数字重复地重新排列为升序和降序，并减去这两个数字，直到结果开始重复 —— 即Kaprekar的例程 —— 可以编码为：

```
def kap(n)
  d = descending_digits(n) - ascending_digits(n)
  n == d ? n : kap(d)
end 
```

我们取该数字的两个重新排列的数字的差（我们尚未定义）。如果该差等于输入数字，则我们已找到序列开始重复的位置，并返回该数字。如果是不同的数字，则我们递归并再次执行相同的操作，这次是使用差。

注意，这个递归函数仅在操作在某一点达到相同数字时才终止。但是我们*知道*这是真实的；这就是编写这个程序的全部意义！我们只是想通过程序验证这一点。防止我们知道不会发生的无限递归毫无意义。更甚者：[已知](https://en.wikipedia.org/wiki/Kaprekar%27s_routine#Kaprekar's_constants_in_base_10)，对于4位数，该操作实际上在7步或更少的步骤内收敛，因此如果我们更喜欢迭代而不是递归，我们可以这样写：

```
def kap(n)
  7.times do
    n = descending_digits(n) - ascending_digits(n)
  end
  n
end 
```

对于我们的目的，两个版本都将正常工作。如果某些数字因某种原因不符合Kaprekar的特性，则迭代版本将给出错误结果，而递归版本将永远挂起或溢出堆栈。这两者之间？那是一个有趣的问题！无论哪种方式，我们都会知道我们在某处搞砸了我们的“证明”。*没问题*。

### 重新排列数字

现在，为了按升序重新排列数字的方法，现在我们已经了解了`digits`方法，这是直截了当的：

```
def ascending_digits(n) = n.digits.sort.join.to_i 
```

我们取该数字的数字，对其进行排序，然后用`join`将它们连接成一个字符串，然后用`to_i`将该字符串转换为整数。对于某些口味来说，这可能会有点过多的不必要分配，但对于这样一个小型的证明程序来说，这完全没问题。

我们可以快速在Ruby的交互式控制台`irb`上进行测试：

REPL非常适合这种探索性编程。与在源文件上编写程序，运行它，调整它，再次运行等等更“经典”的方法不同，REPL允许更紧密，几乎是即时的反馈循环。一旦你在控制台上写好并测试了你的小程序片段，你就可以将它们复制到程序文件中。

```
$ irb irb(main):001>  def ascending_digits(n) = n.digits.sort.join.to_i
=> :ascending_digits
irb(main):002>  ascending_digits(3713)
=> 1337 
```

现在，对于按*降序*重新排列数字，一个简单的解决方案可能是在排序后添加`reverse`调用：

```
def descending_digits(n) = n.digits.sort.reverse.join.to_i 
```

但是这个逻辑隐藏了一个隐秘的错误。你能发现它吗？

我们可以在控制台上测试`descending_digits`，这似乎工作正常，甚至使得`kap(n)`针对我们开始的示例数字返回Kaprekar常数：

```
irb(main):007>  descending_digits(1988)
=> 9881
irb(main):008>  kap(1988)
=> 6174 
```

但是当调用4位数中的第一个数字1000时，我们得到：

```
irb(main):009>  kap(1000)
=> 0 
```

这是不正确的。1000不是一个重复数字。它不应该收敛到0。

这里发生的情况是，在第一次迭代中，`ascending_digits(1000) == 1`和`descending_digits(1000) == 1000`，这两者都是正确的。它们的差异是999，当我们尝试在第二次迭代中获取其数字重新排列时，我们得到了升序和降序变体的999，这当然导致减法的结果为0，然后重复。

我们需要让`descending_digits`将其输入视为4位数，以便将999视为0999，然后其降序数字重新排列将是9990而不是999。以下是实现此目的的一种方法：

```
def descending_digits(n) = n.digits.sort.reverse.join.ljust(4, '0').to_i 
```

将数字排序并连接成字符串后，我们使用`ljust(4, '0')`在右侧用零填充字符串，使其长度为4个字符。有点巧妙，是的，但它完成了任务。至少它相当简洁，足够可读。如果你能想到更好的替代方案，请告诉我！

加入了这个热修复后，`kap(n)`现在似乎按预期工作：

```
irb(main):011> kap(1988)
=> 6174
irb(main):012> kap(1000)
=> 6174 
```

### 最终的“证明”

现在在这个自底向上的过程的顶部，我们可以定义程序的主逻辑：

```
1.upto(9999) do |n|
  repdigit?(n) or kap(n) == 6174 or
    fail "#{n} is not a repdigit nor does it converge to 6174"
end 
```

再次注意，Ruby代码如何作为其英文翻译的简化版本阅读：对于从1到9999的每个数字，该数字要么是重复数字，要么其Kaprekar序列收敛到6174。如果这两者都不成立，则“证明”失败。

你可能想知道为什么我使用冗长的`or`布尔运算符，而不是更常见的符号`||`替代方案。嗯，这实际上是一种风格选择。首先，如果我使用了`||`，那么`fail`方法调用就需要括号括住它的参数，我宁愿避免这样做，因为我认为`fail`是控制流，我喜欢在视觉上将控制流方法与其他“正常”方法调用区分开来，比如在这种情况下的`kap(n)`或`repdigit?(n)`。其次，使用`and`和`or`作为控制流运算符——作为`if`和`unless`的替代方案——是一个[很棒的主意](https://avdi.codes/using-and-and-or-in-ruby/)，可以帮助用我们构思的“自然”方式表达事物。尽管如此，我承认这可能是一种斯德哥尔摩综合症的表现；对Ruby的[多种方式](https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it)做同一件事的一种合理化。通常情况下，我更喜欢语言有一个明显的做事方式。所以我会认为我的选择在这里是我通常结构化方式的一个罕见例外 :)

将所有这些片段组合起来，完整的“证明”程序是：

```
def kap(n)
  d = descending_digits(n) - ascending_digits(n)
  n == d ? n : kap(d)
end

def ascending_digits(n) = n.digits.sort.join.to_i
def descending_digits(n) = n.digits.sort.reverse.join.ljust(4, '0').to_i
def repdigit?(n) = n % 1111 == 0

1.upto(9999) do |n|
  repdigit?(n) or kap(n) == 6174 or
    fail "#{n} is not a repdigit nor does it converge to 6174"
end 
```

运行结果证实，对所有不是单个重复数字的4位数，Kaprekar的例程确实收敛于6174。

### 等等，这不是关于数学或其他什么的吗？

嗯，是的。也不是。这个故事从一个数学谜题开始，但实际上讲述的是之后的旅程。

至少在我个人的情况下，当我了解卡普雷卡的结果时，我的脑海立刻从“那不可能！”跳到“我 *必须* 写一个程序来检查所有数字！”。而你可以看到，在写程序的过程中，我的好奇心漫游到了哪里：

+   对表达同一思想的不同方式以及努力找出我最喜欢的方式

+   对递归与迭代

+   对编程语言的可疑语法选择

+   对编程语言的哲学

+   对自顶向下与自底向上编写软件

当然，这些都是我感兴趣的事情，因此我的思绪自然而然地走向了这些方向。一旦我编写并运行了程序，我最初的那点数学好奇心就消失了。

我怀疑一个更数学导向的人会完全不同地处理这个问题。也许他们会试图找到一个优雅的分析证明，而不是依赖一个愚蠢的数值计算机器粗暴地穷举。或者他们会试图将问题推广到不同位数的数字，或者不同进制的数字。我真的不知道。

但我很欣赏玩弄这个问题。看来我并不像我曾经想象的那样喜欢数学。而我热爱编程，这倒是出乎意料。

那么你呢？当你的眼睛读到这些内容时，你的思绪是什么？假设你确实看了，那么：非常感谢你的陪伴。
