<!--yml

category: 未分类

date: 2024-05-27 13:28:33

-->

# C并不是一种宿醉；Rust也不是宿醉的解药 | 作者 John Viega | 2024年4月 | Medium

> 来源：[https://medium.com/@john_25313/c-isnt-a-hangover-rust-isnt-a-hangover-cure-580c9b35b5ce](https://medium.com/@john_25313/c-isnt-a-hangover-rust-isnt-a-hangover-cure-580c9b35b5ce)

# C并不是宿醉；Rust也不是宿醉的解药

几周前，我因为又读到一篇对内存安全过于轻率的文章而有些恼火，基本上是对变革的需求过于轻率。随后的周末，我开始看到安全专家的轻率回应，本质上是说，除非你像我大学第一年放弃早上8点课一样快速放弃C和C++，否则你是不负责任和危险的。

我将从tl;dr开始，然后详细讨论问题。我将尝试在大多数软件行业人士能够理解的水平上呈现各方观点。

这意味着，我肯定会（有意地）过度简化一些更技术性的内容。这篇文章已经太长了，论点也不是关于技术本身，而是关于各方面经济上的极度复杂性，我们需要找到一种方法来接受其他人做出我们不喜欢的决定，同时帮助世界走向更好的方向。

有很多事情需要考虑，所以希望你能跟着我，并且仔细思考其中的细微差别。

# tl;dr版本

1.  *确实*，安全问题比许多人所认为的要严重得多，许多人完全可以立即放弃使用C/C++来进行新项目开发，而不仅仅是出于安全考虑。但是！

1.  摆脱我们应用程序中现有的所有C将是更昂贵和风险更高的，这一点很多人可能没有意识到；替换一些关键软件的过程将需要十年甚至更长时间才能有效替代，并且没有明确的总体利益。

1.  当我们考虑安全性时，隐藏的复杂性很多，这使得情况变得非常复杂，“Rust比C更安全”这样的说法可能是正确的，但实际上并不是完全正确的解决方案。

1.  选择编程语言的经济学实际上非常复杂。安全性不仅仅是唯一的非功能性考虑因素，无论你做什么，总会有一些内存不安全的代码存在（只要底层架构本身是不安全的），试图迅速摆脱C将会带来许多负面后果。

1.  系统语言被过度使用；C与Rust是一个虚假的选择，因为像Go这样的编译语言经常是更好的经济全能答案。尤其是Go的性能足够良好，对于绝大多数用例来说已经足够安全，并且可以良好地访问低级系统API。

## 一些安全专家已经开始不满

凭借经验，仅仅建议安全可能不是比其他任何事情都重要的绝对优先事项，对于某些领域的人来说可能会感觉像是一种人身攻击，仿佛我在反对安全行业的存在本身。

相反，我认为如果我们更全面地理解并在领域之外更好地理解权衡，安全行业可能会比现在更加兴旺。有些人可能不得不被迫关注安全问题，但非安全人员占多数，其中许多人持有一个平衡的观点，他们关心安全，但不想把过多时间和金钱投入其中。

很久以前，我曾看到一位安全专家与业务人员争论，当安全专家坚持己见时，我有点明白了，并问道：

> 如果你认为安全是首要问题，那你为什么还要使用电脑呢？

人们每天都愿意接受风险。我们知道每次出门在外，都可能“感染”病毒。我们知道每次上车都可能发生事故而丧命。

但众所周知，人类在现代风险评估方面表现得非常糟糕。我们有过高或者过低估计我们风险水平的倾向。

通常，安全行业可能认为普通人严重低估了风险。在某种程度上，这是真的。当我首次在'98年进行安全代码审计时，工程师显然低估了内存问题的风险。那时，如果你给我一段不是由Dan J. Bernstein（通常简称为djb）编写的C或C++代码，可以肯定地认为会存在可利用的内存错误。我甚至在我敬重的安全领域人士的代码中见过这些问题。

但现在世界已经不同了。那时，大多数行业严重低估了风险，并且乐于接受网络连接和易于利用的代码，因为他们根本没有考虑这些问题，或者认为这不会成为一个重要因素。

没有补丁星期二，也没有广泛的隔离措施或其他有效的补偿控制措施。

技术界的其他人最终愿意承认他们错了，这要归功于整个安全行业的辛勤工作。正如Greg Hoglund过去经常说的那样，连接性、可扩展性和复杂性的结合造成了一场完美的风暴。没人能否认这一点，因此安全行业从硬件架构到网络协议，再到编程语言设计都产生了巨大影响。

但这并不像应有的那么简单，因为我们（作为一个行业）经常无法真正理解行业外人士的观点。

如果我们能记住这一点，行业可以提高其可信度，甚至更快地取得进展。我们需要这样做，因为正如我们将看到的，我们不仅有很多尚未完成的工作，而且有许多重要的变化*根本无法快速实现*。

# 内存安全到底是多大的问题？

我百分之百将从承认问题开始。早期认真对待这个问题对我的职业发展非常有利——将近25年前，我与人合著了第一本面向开发人员的安全书籍，甚至在像跨站脚本（XSS）这样的基本Web安全问题出现之前。不久之后，我还共同编写了*C和C++安全编程手册*。

那些书做得很好，帮助我打开了局面，我之所以在那些书上工作，是因为我非常重视内存安全。当时，与今天相比，更多的软件是用C/C++编写的，几乎普遍存在更多的内存安全问题，而且更容易被利用。

多年来，我开发了研究工具和库以帮助减轻这个问题，也看到其他许多人也在这方面做同样的事情。但是！一般来说，开发人员对安全性的关注远不及安全人员。尽管有大量工具，C程序员通常不倾向于使用它们。

内存安全通常被认为是最严重的漏洞类型，因为当这些问题能够被利用时，它们通常会导致完全执行权。通常情况下，这些问题可以远程利用，有时甚至不需要任何身份验证。

但是，当前内存安全问题容易被认为是普遍存在且对于复杂攻击者来说是易于发现和利用的声誉是*错误的*。

在千禧年之交肯定是真的，但现在不再是这样了。从安全角度看，内存不安全代码的影响仍然非常严重，但考虑到你可能由于强有力的经济原因而不采用内存安全语言，这可能是一个合理的决定，即使考虑了风险调整。

## 风险已经发生了变化。

我将专注于解释为什么在C和C++代码中的内存安全性可能并不像许多人认为的那么危险。本节中的任何内容都不应被解释为选择这些语言的理由——我们将在本文的后面探讨可能使得权衡成立的情况。在这里，我会坚定地承认其他语言在本质上更安全；我只是在质疑“有了正确的控制和警惕性后，它们有多安全？”

世界发生了许多直接影响风险水平的变化（双向），包括：

1.  我们所有人使用的硬件架构和操作系统在防止利用方面做得非常出色，而又不会在性能上牺牲太多，从1998年的StackGuard开始，一直到英特尔最近在控制流强制执行和ARM的内存标记方面的工作。

1.  C++在其标准库周围专注于用户界面，试图确保普通C++用户不太可能使用存在内存安全问题的API。另一方面，虽然C语言作为一种语言已经发展，但在这方面却更加保守。

1.  全面披露运动发生了，漏洞研究成为一个职业领域，导致最常见的C组件受到了相当大的关注，并帮助显著提高了这些问题在C程序员中的意识。

1.  学术界停止教授C++，转向Java，然后转向Python。

1.  出现了新一代适当的系统语言，但注意到了内存安全性，尤其是Rust，但也包括Zig、Nim和其他几种语言。

1.  转向云和现代技术堆栈的其他便利是很好的抽象，但它们确实增加了攻击面。另一方面，它们促进了可以限制影响的分区化，并且令人意外的是，因为我们不再将可逆的二进制代码放入人们的手中，专有代码往往受益于本质上的*安全性通过混淆*，尽管这让我很痛苦承认（尽管容错设计确实经常帮助攻击者能够自动化他们希望的许多“机会”）。

以上是需要考虑的一些后果：

1.  许多C和C++代码中的内存问题被报告为可能被利用，即使有些问题在实践中可能是不可能被利用的。很久以前，当我进行漏洞研究时，如果我看到一个明显的内存错误，不仅有很大的可能性它是可以被利用的，而且我能够很容易地构建一个可工作的利用程序。我同意作为行业，我们最好假设任何发现的内存问题都是可利用的，因为通常可以找到其他缺陷进行链式连接使其成为可能。然而，构建可工作的利用程序已经变得非常**困难**，从一个容易开发的技能变成了相当罕见的技能。因此，真正的零日漏洞利用倾向于被战略性地使用，最常见的是由政府使用。

1.  漏洞研究领域的经济学倾向于扭曲风险感知。这是因为这些错误在经济中是最*有价值*的，我将在下文讨论。然而，这意味着跨语言比较CVE存在怀疑。但这也意味着，有价值的利用程序要么位于不太可能被攻击的地方，要么通过“负责任披露”周期，这使得人们得出结论，一个良好的修补程序可以减轻风险。

1.  有时，写C语言的人有很好的理由选择这样做。理解这些理由很重要。很少有新手认为他们必须学习C语言才能成为有效的程序员，但在嵌入式系统等地方，C语言仍然是更为实际的选择。

举例来说，通常通过语言比较CVE编号是具有误导性的——Linux内核最近正式获得了为其自身代码库发布CVE的能力。但从他们的观点来看，太阳下的任何一个漏洞可能都具有安全问题，因此现在Linux内核中发现的每一个bug都会获得自己的CVE编号，尽管大多数情况下它们不会是可利用的内存问题。

## 理解降低的漏洞利用能力

在这里，理解内存错误演变可以帮助理解漏洞利用能力。我将尽量避免深入的技术解释，因为我认为最需要理解这一点的人是那些（完全正确地）永远不会在需要理解这些细节的低级别工作上工作的人。这将再次简化问题。

在某种程度上，这可能是多余的细节。一方面，即使在寻找良好的漏洞利用方面变得更加困难时，这并不重要，因为如果您放弃C语言，这一类问题就不再是问题。

另一方面，漏洞研究人员比20年前工作得更加艰苦，却找到的漏洞更少，这表明实际风险比过去要低（特别是在有良好的补偿控制措施的情况下）。20年前，我本来以为任何用C编写的程序都可能在某处存在容易被利用的漏洞，而且这可能是正确的。

今天，我倾向于认为许多C程序中存在问题的几率很高，但是，如果您正确设计并支付合适的人员来审查您的代码，找到下一个bug的经济成本已经高到我不再认为任何C代码都会导致您被拥有的程度。

当我刚开始进入这个领域时，通常情况很简单。如果您能找到一个本地变量是数组，那么您很可能会欺骗程序写入数组之外的位置。而且，内存布局是如此可预测，相对容易找出如何利用这种情况。

具体来说，局部变量通常保存在*程序栈*上。当您进入函数时，数据被推送到堆栈上，退出时从堆栈上弹出数据（有点像）。这与在函数调用之间保留的长期内存分配（堆存储）不同。

例如，看到这样的代码并不少见：

```
void
open_tmp_file(char *filename)
{
    char full_path[PATH_MAX] = {0,};

    strcpy(full_path, base_path);
    strcat(full_path, filename);

    // Do something with the file.
}
```

对于未接触过编程的人来说，上述代码可能看起来无害。它创建了一个数组，其大小为操作系统支持的最大路径大小，初始化为零。然后，将一些基本目录名称复制到该数组中，最后将文件名附加到数组末尾。

但即使在今天的系统中，如果攻击者可以控制此函数的输入或`base_path`的输入，这个程序很容易崩溃。

其中一部分原因是 C 不跟踪事物的长度。在 C 中，`strcpy` 逐字节复制，直到遇到值为 0 的字节（所谓的 `NULL` 字节）。类似地，`strcat` 通过向前扫描 `full_path` 直到第一个空字节，并从 `filename` 复制，直到找到 `NULL`。在任何情况下，这两个函数都不会检查它们所做的事情与 `fullpath` 的长度。因此，如果你可以传入超过 `PATH_MAX - len(base_path)` 字符，你将写入缓冲区末端之外。

在“不好的旧日子”中，这是一个绝佳的机会，利用这种漏洞将变得非常简单。

传统上，程序堆栈将自己的运行时数据与用户数据混合在一起，这就是传统*堆栈溢出*如此容易被利用的原因。

每次调用新函数时，堆栈将获取程序应返回的代码位置的内存地址。因此，一旦找到这些条件之一，你只需确保精心设计一个攻击*负载*（发送到任意点的恶意数据），以便覆盖该返回地址，并替换为指向自己负载的指针……通常也包括可执行指令，将执行任何操作。负载的可执行部分通常称为 shell code，尽管获取交互式登录（即 shell）不一定是目标。无论如何，当利用成功时，攻击者通常能够从那时起运行任何所需的代码。

从技术角度看，那时最复杂的东西是 shell code 本身，因为它通常需要至少汇编级别的知识。

然而，你并不需要编写自己的 shell code，总是有很多现成的有效载荷。

## 为什么不总是进行边界检查？

很好的问题。有人可能会认为我们可以让编程语言始终生成代码以检查任何访问的边界，并完成工作。

我个人深有同感。我会指出 Python 的巨大成功，以表明在大多数情况下，性能甚至比安全性更不重要。因此，毫不奇怪，所有编程语言（尝试）通常会使用动态代码来保证无越界写入。

但是，如果在每个地方都进行检查，那么检查代码肯定会对性能产生显著影响，而且确实存在性能至关重要的领域。

例如，如果你是 CDN，并且试图以成本效益的方式处理大规模连接量，很容易相信额外的硬件成本可能使业务不值得从事，除非运行软件成功跳过低风险的边界检查。

而且，通常在 Python 编写的个别应用程序中，“足够快”（即使许多人可能不同意，正如官方 Python 中的多次重写和新的实验性 JIT 编译器所证明的那样），但如果 Python 运行的每一段可能的代码都进行了完全的边界检查，Python 是否足够快呢？

我们使用的大多数软件都大量使用用C或C++编写的低级系统代码，即使是间接的。操作系统不仅会用这种语言编写，许多典型编程语言在运行时使用的库也是低级的。

当然，你*可以*“用Rust重写它”。但是，即使我们应该这样做（见下文），显然这将是一个漫长而艰难的旅程才能到达那里。

注意，Rust能够接近C的速度部分原因在于编译器可以在编译时‘证明’可以跳过大多数边界检查。

但实际上，在C的顶层设计API以便在严格使用时避免内存错误，同时最大限度地减少运行时代码的生成，这并不是什么难事。例如，在上面的示例中，为字符串提供一个不断跟踪长度并进行完全检查的不同C API并不难。我们可以为数组和其他数据类型提供类似的API。我们甚至可以为指针提供这样的节俭。

这实际上就是C++已经相当成功地做到的事情，这也是为什么Bjarne Stroustrup似乎对政府因内存安全问题告诉人们不要使用他的语言感到非常愤怒的原因。我不写现代C++，但从API文档来看，要远离内存问题似乎相当容易。

但是，回答上面的问题，我们越扩展，小事情就越重要。如果整个操作系统和Python使用的每个库都经过充分检查，Python可能会变得过于缓慢是可以想象的。

但实际上，这可能会使很多软件甚至更不划算。而实际上，经济通常是涉及软件时最**重要**的考虑因素，这些经济必须在很大程度上围绕使用软件的人的体验（例如，通常只关心性能是否低于预期）展开。

因此，如果你在编写低级系统代码，并希望它被使用，它必须具有广泛适用性，并且在CDN或任何其他大型科技公司的规模上都需要具有成本效益。

几乎没有什么理由真正希望他们的编译器在*不必要*的情况下生成边界检查。理想情况下，我们希望能够证明何时可以安全跳过，并确保在安全跳过检查时生成机器代码（无论是手动还是通过编译器）。

不幸的是，在大多数情况下，要获得绝对保证几乎是不可能的。我们需要决定哪种程度的利用风险我们认为是可以接受的。

正如我将要讨论的那样，任何声称风险应该完全为0的人都太不现实了...即使忽略经济论证。

## 内存越界错误：缓解历史

我们愿意承担多少风险的问题，导致我们要问：“我们目前承担了多少风险？”

因为如果答案是“不多”，那么我们需要思考是否值得付出成本来添加边界检查。

实际风险的水平很难准确量化。真正做到这一点的最好方法是与那些在他们的职业生涯中真正证明了利用的漏洞研究人员交流。

任何有资格的人如果在场，肯定会同意在千禧年之交周围的C/C++程序绝对是一个利用性的丰富来源。我在那里；如果你有基本的低级技能集，这是很容易的。

但是，已经有了四分之一世纪的缓解措施，我们生活在一个完全不同的世界中。证明可利用性是如此困难，以至于每当我们看到一个内存错误时，我们就接受可能有利用的可能性，没有任何证据。而我大部分仍在从事此类工作的朋友绝对会承认，它不再像“轻而易举”，而是困难得多。

或许很难量化提升了多少，但这已经相当高了。

要开始理解今天的风险，我们应该回到起点。在这种情况下，让我们回到上面讨论的简单栈溢出。

实际上，虽然我展示的代码**明显**是内存错误，我在四分之一世纪前肯定可以利用它，但确定我是否实际上能够构建一个实用的利用程序，这个想法是如此艰巨，以至于我不愿意尝试。

这段代码仍然是错误的，因为它没有进行边界检查。它仍然可以用来崩溃程序（从某种意义上说这是一个安全问题）。如果你想看看，这里有我现场编码的例子，并且显示它仍然会崩溃（对于我打字慢和愚蠢错误，没有额外费用）。

但是，仅仅因为它是内存错误，并不意味着它易于利用，甚至可能无法利用。

尽管上述代码很糟糕，但StackGuard在1998年就比较好地解决了这个问题。基本的想法是，当程序启动时，选择一个至少64位的随机数。每次调用函数时将其推送到栈上。

然后，每次从函数返回时，请检查随机的 canary 是否完整。如果不完整，就崩溃而不是返回。

曾经可以确定性地找出写什么来使程序在执行你的shell代码之前保持运行的点，一个天真的利用现在不再有效，除非程序在某种情况下泄露其 canary。

尽管在某些情况下你可以绕过上述问题（特别是当你能够链出另一个漏洞时），但StackGuard完全消除了某些问题，并显然提高了漏洞研究人员的工作水平。

软件利用社区（无论是“坏人”还是漏洞研究社区）不断努力寻找绕过技术，但往往至少能找到一些情况可以绕过某些缓解措施，如果情况合适的话。例如，上述缓解措施在内存动态分配时不起作用，因为该内存被单独保存在堆中。

当然，程序不会在堆中保存函数返回地址。然而，许多真实程序，特别是在使用C++动态分派的情况下，会将函数指针保存在堆中，并使用它们来动态选择要调用的函数。

其中一种更有效且著名的防御方法是*地址空间布局随机化*（ASLR），这是在操作系统层面实现的。基本上，每次程序启动时，操作系统会尽可能随机化数据存放的位置。通过ASLR，如果注入了足够的随机性，攻击的成功概率会非常低，可能需要尝试的次数与宇宙中的原子数量一样多才能成功。

实际上，它并不*完全*如此好 —— 有时对攻击者有价值的特定位之间的距离可能不可随机化，因为可能存在它们需要是可知的（或者在小范围内）。而且，如果操作系统过于积极地随机化，可能会破坏程序。这在操作系统内核中尤为真实 —— 在内核内部获得有意义的随机化量是困难的。

尽管如此，这是一种非常有效的技术，突然使得利用变得非常困难。

如果你从未深入了解过这里的内部机制，但技术水平足够，你可能会问两个重要的问题：

1.  系统不应该将用户的程序数据与其内部状态分开吗？

1.  如果有效负载必须存储在堆或者栈中（通常情况下其他内存是不可写的），难道我们不能防止这些区域执行代码吗？？

对于问题1，单个线程每个栈的实现不仅更容易，而且通常更快，因为硬件通常会直接支持程序栈。而且最终，虽然进程具有提供对其他进程保护的虚拟地址空间，但在一个进程内部，该进程中的任何代码都可以访问该进程中的任何内存单元。

尽管如此，调整事物位置仍然很有价值。例如，在堆溢出中，函数指针是很有吸引力的目标。将所有函数指针存储在静态分配的表中或者单独的堆内存中，绝对比典型的随处存放函数指针的方法更好。

对于第二个问题，防止代码在系统级别的栈或堆之外执行是完全可能的，这是一种完全值得采用的缓解措施。然而，一些环境，包括一些整个编程语言，使用其中一种或两种来实现它们自己的动态能力（例如闭包的`lambda`函数）。尽管如此，对于大多数程序而言，这种缓解措施基本上是免费的，并且进一步提高了安全防护水平。

今天，当存在内存问题时，攻击者通常不能期望直接运行代码。但是，想象一下你正在攻击一个用Python编写的程序，并且你可以以某种方式利用Python底层C实现中的内存错误，写入内存中的任意位置。

在幕后，Python实现了一个虚拟机。有些“指令”可以存在于堆或栈中，Python的内置代码会检查这些指令，并根据指令执行不同的操作。

事实证明，当我们谈论内存“不可执行”时，实际上只是指直接在底层系统处理器上执行的内容，而不是应用级别虚拟机中发生的情况。

因此，即使你正在攻击的程序具有其可执行代码段为不可写，你可以写入的所有数据也是不可执行的，你仍然可以更改控制可执行代码行为的数据。

作为攻击者，如果没有虚拟机，你可以通过一种称为*返回导向编程*（即ROP）的技术来创建一个虚拟机。基本上，利用内存错误，你试图调整程序的数据，使其在程序内存中跳转，执行你希望它执行的操作（通常目的是生成登录Shell，在那里你可以合法地再次运行任何你想要的东西）。

ROP本质上很困难，因为通常需要攻击者同时调整堆栈上的数据和堆上的数据，这本身就很困难。再加上地址布局随机化，你会发现大多数涉及越界写入的内存错误实际上是难以利用的，并且通常需要连接多个漏洞，并且大多数情况下还要应用ROP。

最近，英特尔引入了*控制流完整性*（CFI）作为一种选项，专门用于防范ROP。

记得我们曾经说过将返回地址从栈上移出通常没有意义吗？英特尔认为在实践中让世界停止这样做太困难了，但是相反，它**复制**了返回地址到*影子栈*。然后，当函数返回时，它确保返回位置是一致的。

显然，这对栈溢出非常有效，但是如果攻击者直接跳过了写入栈的步骤呢？例如，使用ROP时，通常只需操纵数据，使其导致某处跳转错误，这将运行他们喜欢的代码。当该代码遇到‘return’语句时，它可能会返回到CFI预期的位置。

除了CFI还能验证调用位置。通常，ROP会涉及跳转到函数中间，而CFI可以阻止这种情况发生。而且，它可以确保函数只能从应该被调用的地方调用。

CFI对Python虚拟机的攻击无法阻止。但对于没有嵌入虚拟机的程序而言，CFI很可能会使ROP风格的攻击变得更加困难（因此不太实际），尤其是对于使用CFI的程序来说。

总之，虽然我们可能无法准确量化现代缓解措施对内存漏洞的有效性能阻挡多少，但是当所有易于获取的系统缓解措施都被应用时（大多数应用程序默认启用，但CFI还不普及，并且在某些地方这些缓解措施并未应用），许多此类错误很可能是无法被利用的。

但这个领域很复杂，我长久以来对桌上所有人的创造力都感到惊叹。虽然大多数漏洞早已不是模板式的，也不可能单个漏洞就能被利用，但是漏洞开发社区在创新方面也有了相似的进步，所以最好始终假设内存问题可能被利用。是的，具备适当技能集的人数比20年前极少，但我们不应假设这个数字会降到零。

因此，有人可能会正确地得出结论：“为什么要冒这个风险呢？毕竟最好是消除这一类问题。”从某种意义上说，我会同意，因为难度很高，但最优秀的人通常能找到并串联多个漏洞，这正是他们所需要的。是的，在Rust和其他语言中可能会出现这些问题，但只要C语言存在，这些问题就会一直存在。

但话又说回来，大多数从事此类工作的合格人员要么向政府提供漏洞利用工具，要么进行负责任的披露，这通常意味着只要及时打补丁，风险可以得到相当有效的缓解。

如果你成为政府的攻击目标，他们可能会愿意冒险暴露一个0-day来拥有你，他们可能还有其他更可靠的方法。坦白说，`xz`并不是我们见过的唯一长期游戏；政府在能获取所需信息的地方布置间谍，这当然也包括安全公司内部。

大多数偏执的安全人员讨厌庞大的单体安全产品，因为不管意图多好，你最终都会面对更大的攻击面，而且很可能面临更高的风险，特别是如果你担心国家层面的问题。

我预计随着时间的推移，硬件平台将继续提高安全标准。如果我们幸运的话，再过十年，这些缓解措施可能会变得几乎和完全的边界检查一样有效，但成本要低得多（至少在有这些措施的环境中）。

但在此之前，人们认为，虽然这些问题确实是一个真正的问题，但是他们在补偿控制方面已经投入了足够的投资，因此不会招致与其他选项相关的所有成本。

## 其他内存错误

在 C 和 C++ 中，“内存错误”并不仅限于越界访问。

这些语言以用户手动承担分配和释放内存的责任而闻名。虽然这些语言确实带有帮助内存管理的库，但与许多其他语言不同，您仍需决定何时以及如何释放堆内存。

除了纯数组边界错误外，还存在许多其他问题：

1.  如果释放了其他对象仍在使用的内存，可能会泄露敏感信息（例如指向 ROP 目标的指针），部分是因为 C 没有清零内存或确保在使用之前写入的内容。这种 *使用后释放* 漏洞也很容易导致任意数据写入。

1.  如果程序释放了已经释放的内存，可以破坏内部内存管理数据结构，这也可能造成严重后果。在分配之前两次调用 `free()` 可能会导致游戏结束。

1.  如果程序执行数学运算以确定需要分配多少内存，并且攻击者可以强制使数学运算得出足够大的结果，那么数字可能会“溢出”，导致分配比所需少的内存，并强制缓冲区溢出（*整数溢出*问题）。

这些问题在代码中相当普遍，因为很难确定何时释放内存，C 程序员经常手动操作时会出错。自动内存管理（例如垃圾回收）通常可以解决大多数问题…… 除非你能利用这些内存管理中的问题。

垃圾回收语言中的内存管理器往往非常复杂，多个垃圾收集器（包括大多数浏览器 JavaScript 引擎）都存在严重漏洞。

## 现代化的缓解措施

如上所述，C++ 已经做了很多工作，帮助程序员避开上述问题：

1.  标准库编写方式使得在函数返回时，大多数资源（特别是栈分配的内存）会自动释放，用户无需进行任何操作。

1.  同样，C++ 的库完全避免使用原始指针，而是使用通过“引用计数”提供自动内存管理的包装器。

1.  C++ 的标准数据结构的 API 可以防止数组边界错误。

1.  C++ 拥有深层次的类型系统，通常可以相当自信地确保程序的安全性与这些类型相关。也就是说，如果遵循它们的保护栏，可以确保类型错误（数据类型不符预期）总是会被捕捉到。

1.  长期以来，C++也一直有垃圾收集器可用。Boehm收集器于1988年推出，至今仍在维护。

1.  对于C++，有大量静态分析工具可以识别代码是否符合C++核心指南。

以上的好处之一是，许多C++程序员正在从上述大多数项目中受益。

另一方面，C程序员往往不会享受到任何相同的好处。虽然像C++一样，C标准经常更新，但不同于C++，C在变化上保守得多，不像C++那样添加细微之处。

C程序员也可以获得一些相同的好处：

1.  对于C，有垃圾收集器。事实上，Boehm垃圾收集器也适用于C++，并且表现同样出色。

1.  对于C来说，有相当好的静态分析工具，主要集中在CLang编译器生态系统周围。

但总的来说，C在世界上的地位更像是一种可移植的汇编语言。我们马上就会回到这一点。

## 为什么观点如此偏颇？

对于外行来说，到目前为止的讨论可能与您听到的“证据”背道而驰。例如，我听到许多人声称，“大多数CVE是由于内存安全问题引起的”。我最近阅读了另一篇引用这一说法的文章，该文章还提供了一个有趣的统计数据：到2024年3月为止，在C/C++代码中有61个CVE，但在Rust代码中只有6个CVE。

当然，所有这些都是真的。但这些数据都不是风险的良好代理：

1.  我们已经确定，计算内存错误与计算*可利用的*内存错误不同。后者更为重要，至少有充分的理由质疑这一点。

1.  C/C++就像是蟑螂侵扰，你可能每天都看不到它，但如果你知道在哪里找，你会发现它**无处不在**。尽管C/C++在任何度量标准上很长一段时间以来都不是最受欢迎的语言，但旧的构建块仍然被广泛使用和维护。对于我们使用的大多数软件，无论它是用哪种语言编写的，底层可能都会存在关键的隐藏依赖关系，这些依赖关系是用C/C++编写的。*因此，说Rust的CVE总数只占C/C++的10%实际上感觉要么对Rust来说是令人震惊的高比例，要么对C/C++来说是惊人地低*，因为与C和C++相比，实际上几乎没有生产级别的Rust代码。

1.  即使所有带有CVE的C/C++错误恰好都很容易被利用，由于围绕利用的经济因素，数据绝对偏向于突出显示内存漏洞。

正如我之前提到的，政府（以及一些公司）确实会支付用于其操作中可以使用的漏洞“战术性”利用。在许多情况下，双方已知每个漏洞支付六位数的金额，有时甚至支付七位数的金额。

漏洞研究人员通常通过发现一个漏洞就能赚到普通技术工作者一年收入以上。而且确实有人每年能够成功出售多个这样的漏洞。

一般来说，如果我是一个购买漏洞利用的政府，我在决定购买什么时，最重要的考虑因素之一是：

1.  **可靠性**。由于各种因素（包括随机性），许多漏洞利用只有一次成功的机会。然而，有些漏洞利用确实非常成功，每次都能奏效。

1.  **普及性**。特别是，我会关心我的目标软件在各种情况下的普及性。也就是说，如果你想瞄准特定的外国行为者，你可能会找到什么软件？

1.  **隐秘性**。通常情况下，我希望任务不被发现，尽量减少失去工具的风险。我曾看到的漏洞利用可以远程攻击常见的Web服务器软件，然后利用另一个漏洞提升权限（从容器中逃逸），然后禁用SE Linux，而且完全没有写入磁盘的痕迹，仅有一个简单的日志消息——只是说SE Linux已停止运行。在“隐秘性”方面表现非常出色。

1.  **执行能力**。一般来说，我希望能够带来有助于我的活动的工具。因此，全面执行是必须的。尽管如今在低级利用中数据驱动攻击也很重要，但我认为许多“大角色”在高级云利用中也喜欢数据驱动攻击，因为这样可以通过凭证或用户数据实现很多目标。不过，如果我有全面执行能力，我可以做这些事情，以及更多。

1.  **持久性**。理想情况下，这个漏洞不太可能被发现和修复。

有些类型的漏洞，比如命令注入攻击，可以影响大多数编程语言，在多个方面都能取得相当好的分数。但是一个真正好的内存错误通常会得分更高。

由于内存错误的固有价值以及实际发现和利用此类漏洞所涉及的技术挑战，内存错误是漏洞研究社区中最负盛名的漏洞类型。

结果是，它们比更普通的问题更受关注和报道。这意味着代码中可能存在许多相对简单的低 hanging fruit，但也意味着您更有可能在使用的代码中看到这种类型的漏洞，从而增加您的风险。

另一方面，随着时间的推移，利用变得更加困难和不可靠，因此看到国家行为者正在采取其他方法进行多样化，这并不奇怪，我们稍后会讨论。

# 为什么人们不会转换？

到目前为止，我们已经看到，相比任何高级语言，C语言确实更容易出现内存错误。

虽然应对措施相对有效，但它们并不足以成为人们不转换的唯一原因（嗯，在 C 语言的情况下。在 C++ 的情况下，情况就不同了）。

那么，是什么关键因素阻止了人们的转换？

为了讨论的方便，我们将表现得像经济学家一样，假设人们是理性的（表现得非理性会倾向于支持 C 语言）。

首先，即使所有人都同意 C 语言应该被淘汰，也不应该让人感到惊讶，考虑到我不认识一个认为 COBOL 不再是常见语言是个悲剧的人。不过，仍然有许多 COBOL 应用程序，它们还不会很快消失。

那些 COBOL 应用程序仍然存在，因为它们无法被彻底剔除。对于我听说过的每一个这样的应用程序（它们大多数是金融领域的长期服务），拥有该应用程序的公司在多个时间点都试图迁移到其他语言，但最终都失败了。

这些应用程序总是非常重要于企业核心经济的大型应用程序，并且非常复杂。但它们长期以来一直表现出色。

多年来，大多数人都尝试过从头开始构建全新的东西，但后来意识到要达到功能的平等，以及达到同样的鲁棒性将会花费更多的金钱。五十年的见解和错误修复已被编码，但通常缺乏足够的文档。

接下来，你如何确信可以替换掉这些东西？例如，假设你的系统每天清算超过 1 万亿美元的交易，就像它已经做了几十年一样。在你愿意将其中一小部分切换到新系统之前，你需要做什么准备？要知道，如果搞砸了，整个业务很可能会倒闭。

单块式的搬移和转移太不现实了。但即便是在那些老旧的 COBOL 系统上，人们也尝试过逐步替换小部分。这样最终可能有效，但也可能导致相当灾难性的失败，有几家公司认为这样做不值得成本和风险。因此，尽管他们付出了保留在 COBOL 代码基础上进行维护的人才的代价，但经济因素仍然支持着这种语言的存在。

C 语言（以及 C++）比 COBOL 要普及得多，几乎已经成为了几乎所有重要软件技术的基础，持续了将近 50 年。

你可能会认为这是言过其实，但这绝对不是。目前，Python 已经成为世界上最流行的编程语言数年。主要实现始终是用 C 语言编写的，核心库的大部分也是由 C 语言支持的。

JavaScript 是另一种流行的高级语言。是的，它通常在浏览器中运行，而这些浏览器本身通常是极其庞大的 C++ 项目。

即使是那些有意不使用类似C的编程语言编写的编程语言，通常也会依赖C代码。通常像DNS这样的低级服务会被委托给C代码，通常是在“标准”库中。

但归根结底，*每个主要操作系统*主要是用C编写的，还有一些汇编。我们每天使用的大多数网络服务主要是用C或C++实现的。在嵌入式系统中，几乎没有人会使用除C或C++之外的语言。即使在Rust领域，你也会发现一些C。

*这其中有原因*。以下是一个非全面的列表：

1.  多年来，许多C代码已经被广泛使用和信任，世界将不得不承担很多痛苦才能迁移。

1.  许多低级任务在更安全的语言中需要比必要的更多的技巧，特别是因为它们更具防御性。

1.  许多嵌入式环境受到限制，以至于在这些环境中引入更多依赖项的编译系统语言是不可行的。与Rust相比，C非常紧凑和简单。

1.  当谈到市场上合格的低级编程开发人员时，你会发现比其他任何替代品更多的是C和C++程序员。

1.  Rust既不易阅读也不易编写，实际上没有其他值得一提的选择...尽管（Zig正在逐步接近）。这尤其使得要求那些在C或C++上磨练了20-30年的人们基本上抛弃那些机构知识成为了一个巨大的挑战。没有人希望经历穿过糖浆游泳的感觉。更多内容请见下文。

几周前，我谈论了这个话题，并提到了运行核心服务的公司将从设计良好的C代码迁移到Rust所需的巨大努力。我谈话的对象表示这很容易，因为像SMTP和IMAP这样的所有部件都有IETF RFCs。

我希望那是足够好的。RFCs留下了很多“应该”和“可能”，并且通常需要时间来赶上技术的进步，而不总是在建造之前定义事物。大约30年前，我写了Mailman的第一个版本，它绝对不需要实现一个完整的SMTP服务器，但我仍然记得由于新的不符合使用案例导致的互操作性周围的微妙错误。

人们已经围绕这些核心协议写了邮件客户端和邮件服务器超过50年了，世界上充斥着真正应该支持但未定义或不符合规范的问题。而且其中一些问题极少发生，很难重现。

如果你是Google或Microsoft（如今运行着非常大比例的电子邮件），你有多愿意抛弃几十年来一直可靠的代码，而且被信任覆盖了这些几十年中所有边缘案例，尤其是知道周围没有一个良好的知识库？

现在考虑一下，我们今天运行的软件已经积累了一些信任。当然，在过去，Sendmail很流行，而且充满了漏洞，因为它没有进行防御性编写。

在Unix方面，Postfix已经处于活跃开发状态25年，用C语言编写。虽然其安全记录并非完美，但非常良好，并且从一开始就大量利用最小权限原则设计。

即使Postfix从一开始就更注重安全性，而且坦率地说，配置和使用起来更容易，但至少花了一个甚至更长时间，才基本上取代了Sendmail，主要是因为互操作性。不仅需要时间重新发现可能会扰乱业务的重要异常，还需要向担心业务中断的人证明，它已经足够成熟，不会在这个维度上构成风险。

同一时期，还有第二个新兴的SMTP服务器qmail，来自丹·伯恩斯坦，它甚至更防御性地编写（但仍然是用C语言）。它唯一已知的问题是2005年的整数溢出，当时这是一种新的漏洞类别（丹认为在任何实际场景中，它甚至不可利用）。

但是，qmail不仅比Postfix和sendmail更难使用，而且无法达到必要的互操作性水平，无法让人们大规模采用。因此，qmail的开发在25年前停止了（尽管仍有活跃的后继版本；它们仍然没有广泛使用，并且我无法想象它们在任何一个可能经济上有意义的地方被使用）。

因此，“用Rust重写它”，并使其成功地推翻Postfix（更不用说Exchange了），一个人必须：

1.  从零开始构建符合所有标准的东西。

1.  获得足够的实际使用情况，以找到并实施大多数“坑”，这些坑已经由成熟的软件处理。

1.  构建足够的**可用性**，以至于人们会考虑大规模使用它。

1.  跟上邮件界的所有新工作（多年来在安全领域尤其是有很多新增加，没有人应该期望这种情况停止）。

1.  缓慢地说服世界过渡。

在最佳情况下，这个过程不会很快完成；我们将在未来十年看到结果。虽然一方面我希望看到这一点，但另一方面，*对于一个需要花费十年时间来取代一个并非普遍被认为是巨大风险的东西，很难感到兴奋*。

当然，上述论点也适用于大量使用 C 写的遗留基础设施。例如，看到 Linux 社区开始在代码库中尝试 Rust 是很好的。但目前只是一个实验阶段，如果超过这个阶段，它肯定不会是一个快速的迁移。

# C 的长期定位

依我看，Rust 能够进入内核是一项令人印象深刻的成就。多年来，很多人都争取让 C++ 被允许进入内核，但从未成功。反对的理由很简单——C++ 的抽象层次太高了。内核基本上生存在软件栈的最底层，不应该承担任何不必要的成本，因此内核团队需要能够理解性能问题，这意味着他们需要了解 C 代码如何映射到生成的汇编代码。

根据我的经验，Rust 在这方面确实比较接近 C。然而，在这一点上，Rust 肯定不比 C 更好，并且在某些任务中，Rust 实际上会成为阻碍。

许多这些任务都是足够低级的，以至于它们是真正的系统级任务，比如内存管理、设备驱动程序、暴露新的硬件功能等等。

是的，你可以用 Rust 做这些事情，但与之相比工作量大，并且通常会导致利用 Rust 的 'unsafe' 能力，这种情况下，你会承担相同的风险，那么为什么**不**用 C 来写呢？

此外，就像 Linux 内核不包括标准的 C API（因为它们在那个上下文中没有意义；在必要时提供自己的内部 API ），Rust 也不能使用自己的 API；它们必须使用内核的 API。

我们使用的硬件架构在指令级别上提供的安全性非常有限。当然，即使是 C 这种可怕的基本类型系统，也比直接编写到架构的好处要多得多。

在任何现实的软件系统中，如果你深入到最底层，总会有需要编写以针对这些不安全平台为目标的代码。

此外，正如我们上面提到的，绝大多数嵌入式系统专门使用 C。这不仅仅是因为在某些弱CPU的环境中每一个周期都很重要。这还因为其他资源是有限的：

1.  内存可能非常紧张，包括堆栈空间、磁盘空间、缓存、寄存器等等。编译后的可执行文件大小可能是一个问题，任何不必要的运行时废料或肥大的抽象在存在时也可能成为问题。

1.  这种环境的工具通常对其他任何语言都不太适用。仅仅为平台获取一个能够生成代码的编译器可能就是一个巨大的挑战，更不用说提供专门针对该平台的工具了。

1.  由于多种因素的影响，包括空间限制和测试周期可能涉及的困难，这些环境通常几乎没有外部依赖。即使是这些环境的标准库，可能也完全缺乏如线程等基本功能。当今的新型系统语言一直在努力保持其标准库相当小，但它们仍然过于庞大（特别是使用 Rust 时，构建时间通常过长），难以在嵌入式领域达到“足够好”的水平。

C 语言在这个世界中得到了发展，这也是C 标准极力减少必须提供的 API 的众多原因之一，远远超出其他任何系统语言所做的范围。

不幸的是，嵌入式世界往往不支持许多（或任何）使C语言更安全的常见缓解措施。从安全角度来看，它们也有其他劣势，例如难以找到进行基本加密所需的熵。它们也没有使升级损坏的软件更容易的投资。

然而，这些限制更多地是对成本通过供应链的重大考虑所做的商业取舍。许多处理此类限制的软件正因为某种原因运行在低端硬件上，并且所涉及的产品如果承载了与更高级平台相关的所有负担，很可能就不具备可行性了。

这也不总是仅仅“成本”考量。更强大的硬件需要更多的电力，如果您考虑到可能需要长时间依靠电池供电的可穿戴设备或其他设备，这些问题可能比安全风险更为重要。

这些都是商业取舍，C 语言确实是唯一愿意在这些环境中适当提供服务的非汇编语言（嗯，C++ 也算，但在嵌入式空间中它是唯一具有真正影响力的其他语言）。

人们喜欢称C语言为“可移植的汇编语言”。这不完全正确；在我看来，C语言比汇编语言*高得多*。当我在处理编译器任务和其他系统级任务时，如果要求我不使用C而使用汇编语言，那似乎绝对是疯狂的。我只在无法正确使用C语言（或者不能轻松地正确使用）时才转向汇编语言，而这通常仅仅是几条指令。当我不得不转向汇编语言时，我也会浪费大量时间，因为这种情况如此罕见（而每种现代体系结构又如此复杂），我必须花费更多时间在文档上。

C语言处于一个独特的空间中，比汇编语言更高级，但比任何其他系统编程语言（当然包括C++和Rust）更低级。它基本上是它们之间的半步，抽象了许多平台可移植性问题，但仍然足够基本，如果您了解体系结构和编译器，只需查看C源代码就可以可靠预测将生成的代码。

有很多任务在这个层次上做最好。对于这些任务而言，转到Rust并不需要像降到汇编语言那样多的额外工作，但仍然需要进行大量额外的操作，仅仅是为了编写“不安全”代码块。虽然这将有助于界定安全漏洞可能存在的区域，但是需要这种“不安全”代码块的越多，我就越可能期待到负面净效益。

有人对我说，“这是否意味着你不认为C语言是一种真正的编程语言？” 远非如此。我认为*汇编*构成了一种真正的编程语言。然而，我认为我们最好是用有意义的轴来分类语言，尽我们所能来定义它们。通常情况下，选择Rust或者C的人们非常关心性能（不管他们是否应该这样）。更少见的情况是（但仍然很常见），资源消耗是一个重要问题。在我看来，这个轴上一端是*性能*，另一端是*用户体验*，因为这是沿着这个轴移动时的主要权衡。

我把事物相对于这个轴进行了如下分组：

+   *汇编语言*，它们固有地低级且缺乏有用的抽象，我认为人们只应在少数特殊情况下直接处理它（包括构建自动以其为目标的编译器、解锁功能和非常明确的优化工作，这些工作有大量数据表明应当完成，而编译器无法接近最优状态时）。

+   *预汇编语言*，试图尽可能靠近硬件，同时使程序员对性能拥有尽可能多的控制权。在这里，我们可能会牺牲一点平均性能，以使可移植性和可维护性大幅提升。但是，我们仍然应该在提供基础的代码水平上编写代码，这些代码在作者甚至没有考虑的情况下，通过软件规模化利用。操作系统内核肯定属于这一类别，也许一些基础的低级库设施也应该如此，但大多数任务可能不需要在这个层次上处理。实际上，C语言是这个类别中唯一的语言。Rust可能有朝一日会达到这一点，但我觉得今天离这个目标还很远。好吧，这个名字太可怕了，但我没有更好的建议。

+   *系统语言.* 对我来说，这些语言侧重于在大多数情况下提供尽可能多的性能，同时仍然提供安全性（允许对不安全机制进行受保护的访问）。 通常，这些语言会尽量避免传统的垃圾回收（或者有选择地选择退出）。*这意味着你可能需要在内存管理周围做一些手动工作。* 这已经成为语言开发的“热门”类别，并包括C++、Rust、Zig、D和Nim等许多其他不太知名的语言。 目前，手动内存管理通常比C中的典型操作要少得多，错误也少得多。尽管，我会说Rust使内存管理比C中的最佳实践更加困难，但具有更好的安全性保证。Go的性能现在已经足够好，甚至可能达到某些人对系统语言的要求，尽管由于缺乏对手动内存管理的一流支持，我会将它排除在这一类之外。

+   *编译语言。* 在这些语言中，性能仍然是一个问题，但整体开发者体验也同样重要。 到这个时候，没有人应该太担心内存管理了。 并且，应该有一个相当丰富的生态系统。 也基本上非常强调类型安全，具有相当不错的类型系统。 Go，Java和C#长期以来一直是这一类别的坚固支柱，我会将Typescript放在这里，因为它通常是完全编译的，并且非常注重安全性。 我可能更倾向于将Javascript更多地放在后一个桶里（尽管它经常被编译；这里的命名肯定不完美；只是相关性大多适用）。

+   *脚本语言.* 在这些语言中，性能并不是首要任务。 快速开发是非常重要的，导致了非常丰富的语言。 通常人们不想要等待编译结果，并且甚至可能希望在不必重新运行程序的情况下看到更改。 在这里，动态特性传统上比类型安全更受重视，尽管情况已经开始改变（正如一些令人震惊的补充系统的普遍流行所证明的那样）。

在这个轴上，*安全性* 实际上并没有变化那么大。 是的，适当的编译语言倾向于给予它很多关注，并且系统语言比C更好。 显然，脚本语言牺牲了一些安全性，但如今它们通常和编译语言一样愿意考虑安全性。

在这里，相对于内存安全，C和汇编显然处于不利地位，但正如我们一直在讨论的那样，这个差距并没有人们想象的那么大，因为：

1.  在桌面/服务器领域，安全性往往是一个高优先级的问题，通常有非常有效的缓解措施来降低风险。如果明确开发者充分利用这些缓解措施，并在设计和实现中深思熟虑，我们可能会非常有信心（例如，使用Postfix）。

1.  其他系统级语言仍然暴露出不安全的特性，并且在那里出现问题。

1.  大多数语言都有依赖项（通常包括编译器），这些依赖项将用内存不安全的语言编写。

1.  此外，正如我们将在最后讨论的，其他语言通常比C语言更不安全的一种非常重要的方式。

再次强调，这并不是试图争论C语言不具有明显和独特的风险性。我们始终看到主要的C语言目标被攻破：浏览器、内核、网络服务。虽然这比过去更为罕见和更难，但是攻击代码仍然不乏。快速向这些应用程序添加新代码有助于增加攻击面。并且，必须依赖大量的缓解措施同时存在并不是一个好的选择，特别是当它们不在最令人担忧的地方，比如几乎不更新的嵌入式系统。

不过，从事操作系统、浏览器等工作的人往往是聪明的人，他们想要做正确的事情。他们显然对更好的安全性感兴趣，我们需要理解通常有很多考虑我们通常没有考虑到。

换句话说，很难想象在接下来的几年内完全使用Rust编写你选择的操作系统和浏览器而不使用不安全块，但可以合理地期望大量的工作将逐步朝这个方向进行。我们已经可以看到这种趋势，不仅体现在Linux对Rust的接受上，还体现在非常认真对待Rust的Microsoft身上，并且在重要部分中使用它。但我在那里与人交谈时，他们也理解其中的缺点，并且采取了实用主义的态度。

## 早期优化作为一种语言

我一直在争论，不管你喜欢与否（并且明确地说，我不喜欢），C语言在生态系统中占据重要地位的论据是非常强有力的，并且它不会很快消失，因为没有任何适当的替代品。

我认为更令人担忧的是，许多程序员系统性地高估了性能的重要性。我的观察是：

1.  尽管Python在很长一段时间内比C语言慢50-80倍，它仍然如此受欢迎（当系统和编译类别的语言通常在2-5倍范围内，并且很少超过10倍时）。

1.  大多数语言决策是在有任何相关性能数据指导决策之前做出的。

1.  实际上，收集性能数据本身就非常罕见，尽管以性能为名做出的决策却很频繁。

1.  尽管有人经常重复说代码与编译器和/或架构的交互的常规智慧通常是陈旧且错误的。你经常听到“相信编译器通常是更好的”，然后我们这些给出这个建议的人又转过身来无视它。

我认为任何诚实的系统程序员都会说，过早优化是一个巨大的陷阱，他们自己也多次陷入其中。

我自己也经常陷入其中。当然，我确实尝试过进行测量，特别是当性能是明确目标时。例如，当我在研究无锁、无等待哈希表（和其他数据结构）时，我进行了大量的比较测试，例如至少产生了15种不同的实现方式，这些方式在非常微妙的地方经常变化，以便我可以在许多不同的工作负载下进行控制测试。

另一方面，几十年来我已经养成了一些习惯，我无法完全改掉。有时候我还是会被迫将按引用传递的函数参数复制到本地变量中，当该值在函数中频繁使用时，以确保它在寄存器中，即使：

1.  如果我进行测量，几乎肯定在任何情况下都是无关紧要的，从用户角度来看，并不会导致显著的性能问题。

1.  我经常使用可以利用链接时优化（LTO）的语言，在确定进入可执行文件的每个单独模块后进行额外的优化。对我来说，30年前不存在LTO（模块都是根据可能链接到任何未来内容单独编译的假设进行编译的），而且没有编译器愿意在模块之间复制指针后面的东西，以防有线程。我没有深入挖掘过我使用的编译器是否会这样做，但他们肯定*可以*这样做，如果它有影响，它们可能确实会这样做。当然，这在实践中可能并不重要，甚至在我当时所做的任何事情中也可能不重要。不，这只是我吸收的“常规智慧”。

人们在估算*性能*（和*风险*）方面往往表现不佳，对于那些会高估的人来说，他们最终会选择系统语言（或者是C语言，尤其是如果他们对风险方面漫不经心的话），而不是选择普通的编译语言可能就足够了。实际上，在许多情况下，即使是Python也可以胜任。例如，Dropbox 就是在大多数关键任务中使用Python表现非常出色。

就个人而言，我认为我们作为一个行业，应该更关心人们在*性能*方面做出不良选择，而不是安全性，因为：

1.  如果你督促人们不要过分高估性能的需求，那么作为自然结果，安全性确实会有显著的改善。

1.  从性能高估所带来的间接经济损失可能远远超过对安全性低估成本的影响。例如，无论是C还是Rust程序员往往会在内存管理上花费大量时间，并发现在低级问题出现时花费更多时间，与编译语言甚至我们最高级别的语言相比。你真的需要放弃垃圾回收吗？因为这往往会显著影响开发时间，更不用说在标准库中拥有更丰富的抽象可以降低成本的好处了。

这意味着，我会像劝退人们远离Rust并转向Go一样，也会推动他们远离C并走向Go。如果我摘下“安全专家”的帽子，尽可能客观地形成一个观点，我认为这比从C到Rust的好处要有意义得多，*即使我忽略了我们讨论过的使用Rust时的所有隐藏成本*。

这并不是说没有大量的情况适合使用系统语言，甚至是预装配器也不适合。我只是认为我们应该经常对这个问题提出异议，并尝试让人们客观地检查他们做出决定的所有方面的原因：

1.  我们真的需要展示性能上的需求吗？如果是这样，请证明。

1.  否则，考虑“转换成本”可能是有效的，特别是当我们从一种语言开始获取经验丰富的资源时等等。

1.  如果不是，那么对于其他目标，最有帮助的可能是加快功能构建速度吗？或者质量更为重要（这将推动我选择Go或其他编译语言，因为脚本语言往往由于动态性质更难提高质量，即使在像Rust这样具有非常强类型系统的系统语言中，底层代码似乎也会自然地产生更多隐藏的“陷阱”）。

## 我们仍然需要人们学习C语言。

在大多数选择系统语言的情况下，我们应该鼓励他们选择更高级别的东西，而不是在没有数据的情况下过早进行优化。

多数情况下，这将是个体产品和公司的正确经济决策。然而，整个行业确实需要继续培养C程序员。

只要COBOL存在的时间足够长，C的生命力也会更加持久。如今，几乎没有多少人拥有实际的COBOL经验，但如果50年后实际使用C的人数依旧很少，情况就不容乐观了，因为：

1.  令人难以置信的是，尽管COBOL年龄较长，但比起C，它的抽象层次更高，更易于理解，所以在未来50年内，要想培养能够维护关键系统的合格人员将会更加困难。

1.  毫无疑问，仍然会有更多至关重要的C语言在广泛使用中（很可能包括操作系统内核）。

1.  它有助于保持系统级创新的进行。

我所说的最后一点是，50年后，我们仍然需要人们成为基础架构的专家，并帮助实现任何硬件改进的软件开发人员。

在过去的30多年里，我们作为一个行业因为大量人员涌入编程而受益良多，其中一些人已经走上了这条路。但是：

1.  在语言层面上，我们也为人们提供了比30年前更高级的抽象。Javascript、Python、Go和Java在抽象硬件细节方面做得非常出色，以至于只有那些对学习系统内容非常感兴趣的人才会这样做。

1.  如果AI辅助开发变得非常有效，大多数开发人员从当前水平到掌握系统编程的差距可能会显著增大（这并不全是坏事）。

1.  如果我们不知何故停止大多数C语言的开发，并且没有任何合适的替代品（我向您保证，Rust并不是），我们将极大地扩大系统语言和实际硬件之间的差距。

C，尽管它很可怕，相对于当前的任何其他编程语言，绝对是理解低级架构的更好的跳板。

如果没有这个跳板，那么愿意一直往下到硬件层面促进软件硬件改进的人数会显著减少，因为学习基础知识和完成简单任务所需的努力将足够大，以至于更多对此感兴趣的人要么认为自己无法做到，要么不愿意经历痛苦，从而放弃。人们是非常以目标为导向的生物，我们倾向于不追求我们认为不可实现的目标，这是为了我们自己的心理健康。

如果有一种预汇编语言，可以纠正C语言中的一些最严重的错误（在我看来最大的错误是C语言对数组的处理，但我列出的问题非常多），并且在开发过程中尽可能多地进行分析（不仅仅是通过clang项目提供的消毒器，还包括像Valgrind这样的运行时安全工具）。

Rust目前是最接近替代的语言，但我认为，当前过度强调功能性编程范式会削弱对冯·诺伊曼架构的阐释。

# 为什么有人可能不选择Rust

我们已经涵盖了其中一些，但总体而言，我听说人们引用过：

1.  “我们的应用程序不需要用系统级语言编写；我们可以接受垃圾回收。”

1.  “我们对已知的语言和生态系统感到满意，不想花费太多时间学习一个新的生态系统。”

1.  “我们觉得Rust的学习曲线很陡，写起来很困难。”

1.  “我们没有足够熟练的人使用它（所有人一起学习似乎是一种资源浪费）。”

1.  “其他人用 Rust 写的代码往往难以理解。”

1.  “构建时间往往非常长，通常存在过多的外部依赖。”

我意识到 Rust 在非常短的时间内已经在技术界变得非常流行，并且理由非常充分。就我个人而言，我非常欣赏 Rust 的一些成就；我也享受与借用检查器的早期斗争，因为我能够欣赏到这种原始技术成就，并且这让我觉得自己很聪明，能够有效地使用 Rust。

尽管如此，我亲身经历了上述许多情况。大约三年前，我在阅读一篇写得很糟糕的学术论文时，决定看看是否有人已经实现了它。我发现了两个不同的实现，但只有两个，并且它们都碰巧是用 Rust 写的。我之前在 Rust 中做了一些事情，所以我以为没问题。但是，这两个实现都非常简洁且具有挑战性，自身也很难理解。如果我不知道它们实现了相同的算法，我永远也不会猜到，因为它们使用了完全不同的习语，看起来一点都不像。

它让我想起了上世纪 90 年代中期阅读其他人的 Perl 代码的情形：Rust 有时感觉像是一种“只可写不可读”的语言。

此外，我已经写了足够多的 Rust，并与足够多的 Rust 开发人员交流，可以自信地说，很多人会发现采用 Rust 很困难，并且需要很长时间才能在它上面感到像在他们当前选择的语言中一样高效。

我说过，即使已经阅读了 Google 的博文，他们试图驳斥 Rust“难学”的说法。我看过了，但除了他们没有分享任何真实数据外，这项工作还存在问题：

1.  那些发现自己“在 Rust 中很高效”的人的情绪，受到了习惯于构建其内部 C++ 工具堆栈的谷歌员工的极大偏见影响，这些工具堆栈经过多年积累已经足够复杂和控制，仅仅摆脱这些约束就会让他们感到高效。

1.  对代码本身周围的度量进行用户情感调查带有难以纠正的隐性偏见（看看政治民意调查中用于纠正此类事物的工作量，仍然存在巨大的失误）。Google 员工希望不想在被调查他们关于 Rust 的人面前显得软弱。

1.  即使数据稍有用处，也没有直接与其他语言进行比较。博文声称他们的结果与任何其他语言相同，但他们明确使用了“据说”的词语。

1.  Google 的员工群体通常也是最为熟练的。说“我们觉得在 Google 很容易”根本不能概括。

事实上，从我看到的情况来看，Rust主要只在技术精英中流行起来。我认为，任何既有Python又有显著工作经验的人都应该有直觉，Python可能更容易被大众接受。

就我个人而言，Rust专门面向“技术精英”，那些对数学函数和递归有直观掌握的人，这一事实让我无法接受它。

我希望编程更加平等。我认为世界上有很多聪明而有能力的人，在我们行业之外，在科学之外，如果能更轻松地将想法转化为计算机执行，他们将能够为世界做出惊人的贡献。就像我不喜欢看到人们学习系统编程的门槛太高一样，我非常关心降低编程总体入门门槛（在我看来，Python在这方面为世界做了最多的事情）。

但从根本上讲，Rust是一种很棒的语言，那些熟悉它的人应该在适合的地方使用它。然而，我认为人们应该更加诚实地考虑经济因素：

1.  我们应该推动更深入地考虑围绕他们的选择的经济学问题，特别是在可能的情况下，推动更倾向于编译语言而不是系统语言，因为总体经济学可能大部分时间都会更好。

1.  当需要预先汇编时，我们不应该强迫人们避免使用C/C++。挑战选择是可以的，但世界的需求永远不会被单一的编程语言满足，即使在系统领域也是如此。

1.  我们应该推动发展，并成功推广像Zig这样的其他系统语言，甚至是一些实际上*可能*在其领域取代C的东西，以便有朝一日我们可以以一种我们甚至在千禧年前的时候都没能做到的方式，将C的命运尘埃落定。

目前，Zig及其生态系统在准备好应对许多系统编程需求方面远远落后于Rust，但它对问题采取了更加平等主义的方法。在Zig和Rust之间，Zig将是对许多曾经使用过编译语言甚至脚本语言的人们更加可访问的语言。

Rust的部分基础牢固地扎根于函数式编程世界，其中的第一原则是数学上纯粹的函数。世界上有些人本能地理解这些东西，但往往是那些具有显著数学背景的人。

另一方面，Zig仍然是一种常规的命令式语言。基本原则实质上是“给某人详细的指示”。即使孩子们也理解这些东西（即使他们通常不愿意遵循）。事实上，我所见过的每一个成功的预编程项目（如Scratch）都是命令式的。

函数式编程被广泛认为不易接触，并且在过去65年中难以采用的事实告诉我，每一类编程语言都应该有一个强大的过程化语言。

我记得 MIT 曾经吹嘘过从 Scheme 开始作为第一门语言，当其他人都在教授 C++，宣扬函数式范式。但他们最终也放弃了函数式语言作为入门语言。

不过，我大多数时间都对函数式编程范式和函数式语言持积极态度，因为它们确实有自己的巨大优势，特别是更有利于鼓励编写更可靠、更易分析的代码（而且，我30年前由西蒙·佩顿·琼斯签名的《函数式语言实现》仍然是我最珍贵的藏品之一）。

我想说函数式范式有很多价值，我相信每个抽象级别下都值得有一个良好的、流行的函数式语言，甚至可以到汇编前（我不确定在短期内会有多少用途在函数式汇编语言中。但我很乐意被证明是错误的！）

另一方面，我认为面向对象编程范式的实用性要大大有限，最好要么完全消失，要么至多只是一个不再强调的特性。

# Rust 目前可能比 C 更大的安全风险

当著名的安全思想领袖发表像“在非内存安全语言中构建关键应用是不负责任的”这样的言论时，我感到失望，不仅仅是因为他们忽视了经济上的复杂性，淡化了一个复杂的决策，而且，即使我们仅仅考虑安全性，尽管 C 中的内存安全问题很糟糕，但并不清楚这些风险是否比其他语言更糟糕。

具体来说，C 程序通常具有少量外部依赖项，其中经常使用的依赖项是最常用的软件之一（例如 C 标准库）。

大多数其他语言更适合支持程序员利用其他程序员的工作。从某种意义上说，这对商业来说是件好事。但从安全的角度来看，更多的依赖不仅会增加我们的攻击面，还会使我们更容易受到供应链攻击。

去年左右，我读到的一件让我印象深刻的事情是在 Hacker News 上的一条关于 Rust 的评论，但是在 Swift 的一个讨论中：

> 我目前对 Rust 的问题是依赖地狱。每个顶级依赖项都有数百个子依赖项。是的，其中一些非常常见，比如 serde 或 rand，或者奇怪的是，似乎只是用来在文件系统上创建目录的某个 crate？！我曾指望一组受保护的 crate 子集来拯救局面，但是当像 tonic 这样的东西带来约 100 个精细化的一次性子依赖项时，我觉得那不可能奏效。现在我只是插上耳朵说：“我的代码是内存安全的，我无所畏惧地并发！”但我在想：“我的依赖树深处潜藏着什么可怕的东西，是哪个国家的黑客把它放在那里？”如果这听起来有些偏执，看看最近 pypi 恶意包的问题。我知道我可以自己动手，但这需要花费金钱，如果没有 tokio 或 tonic，以及 crates 使用起来不那么方便，也许 Google 会制作一个单体的 grpc crate？

`xz` 事件是最近和最引人注目的供应链攻击示例，但这只是行业幸运找到的一个案例。

Rust 让引入外部依赖变得容易，与 JavaScript 生态系统类似，它似乎鼓励大量微小的依赖项。这使得监控和管理问题变得更加困难。

但 Rust 的情况甚至比大多数语言都要糟糕，因为核心 Rust 库（由 Rust 项目官方维护的重要库）大量使用第三方依赖。项目需要对其库进行所有权和监督。

对我来说，这长久以来一直是软件中最大的风险之一。我可以编写相对防御性强的 C 代码，但我很难信任我使用的任何单个依赖项，更不用说扩展了。

正确地保护您的依赖供应链比编写安全的 C 代码*要困难得多*。就我个人而言，只有在我必须做的工作足以可信地替换功能时，才会引入超出标准库的依赖项，如果我不引入依赖项，我会选择不做这项工作。

在这方面，C 比 Rust 好得多，但并不特别出色。部分原因是 C 标准库（我总是愿意使用的；核心语言实现和运行时是一定的）并不是特别广泛。写大量 C 代码的人最终会自己构建东西，并在数十年中保留它们并使其适应，包括像哈希表这样的基本数据结构。

我个人始终更关心最小化依赖项而不是缓冲区溢出。有几种直接的方法来最小化内存安全问题（稍后讨论），在大多数应用程序中应用它们并不太难。

但是挖掘每一个依赖关系？即使是迄今为止供应链安全的最佳努力也不能很好地帮助应对像最近的`xz`事件这样的攻击（注释给我的拼写检查器，这不是历史书中的*xyz事件*，但我确实想召唤它）。国家会愿意玩长期游戏，一旦开发者对你的某个下游依赖建立了信任，就不太可能通过意外的漏洞被发现来引入后门。

对于`xz`来说，后门并没有直接进入源代码树，因此它更明显是一个后门。但是，我们很久以来就知道隐蔽的后门与错误是无法区分的。

我还记得软件安全行业早期（大约25年前），与Steve Bellovin讨论后门的时候，他讲述了他在贝尔实验室的日子的一个故事，他发现了一个相当微妙的内存错误，这个错误在前员工的代码中持续存在，他的直觉告诉他这是一个有意的后门。它似乎是故意放置的，如果我记得正确的话，当时有一些恶意。但是既然无法与错误区分开来，他怎么能证明呢？

当然，那是在许多内存错误通常会导致可靠利用的日子里。但即使我们现在有比以前更多的同行审查文化，仍有大量“审查”的代码并没有被那些寻找正确事物的人彻底审查。

而且，代码审查远比编写代码更难做好，这也是我不指望在不久的将来使用基于LLM的代码生成的部分原因——它将程序员变成了既是编写需求的“产品经理”，又是代码审查员。目前，我觉得“只是”做一名工程师更容易。

无论如何，您拥有的依赖项越多，您的隐含信任圈就越大，攻击面也越大，您承担的供应链风险就越大。

这使得 Rust 特别在供应链安全方面存在相当大的风险，而 C 的得分则相当不错。就现代风险而言，这对于任何可能最终被纳入可能成为国家攻击目标的组织中使用的代码而言，似乎是一个极其实际且重要的风险。

在没有依赖项（通常情况下可以减少攻击面）的情况下，C 的优势很大，但这并不能使其成为第一选择的正确经济选择。考虑到所有经济因素，选择 Rust 可能仍然更明智，但安全性的论点并不足以说服我。

总的来说，我认为 Rust（以及几乎所有编程语言）都应该控制其标准库。拉入所有依赖项，并愿意承担责任。

此外，我通常会主张语言将*更多功能*纳入它们的标准库中，尽管最近的趋势是减少功能。是的，从安全的角度来看，这确实增加了攻击面。但实际上并非如此：

1.  如果人们觉得可能需要从外部获取特定的常见功能，他们很可能会这样做，无论标准库是否导出它。

1.  特别是在链接时优化，不太难删掉语言标准库中实际上没有被使用的部分，这将使攻击面降低到几乎相同的程度（尽管许多非系统语言不担心链接时优化）。

1.  通过承担责任，语言维护者不仅可以更好地专注于适当审查人们可能会使用的解决方案中的安全风险，他们也更有可能寻找有助于减少攻击面的架构效率。

你可能会减少或增加触及代码的人数，但是语言应愿意对人们可能需要的功能负责，特别是像Rust这样，安全性被列为使用它的主要动机之一时。

在我看来，像Go和Python这样具有广泛标准库的语言，并由语言维护者负责的情况实际上是最理想的情况。是的，更多人触及代码，但自行动手的经济学通常不是正确的选择，而愿意承担责任，并为人们提供一个可以**集中**减少依赖性的环境是件好事。

是的，Python已经变得如此流行，以至于许多人使用外部依赖，并且有几个流行的包管理器。然而，从供应链的角度来看，它仍然比JavaScript处于一个远远更好的位置，后者因其对微不足道的小包的隐藏依赖而在开发者中声名远扬。

# 推荐事项

坦率地说，虽然我认为如今供应链问题可能会使C在严格考虑安全性时具有优势，但这是Rust可以轻易消除的优势。而且一旦发生，C将面临内存管理方面的问题。我在这里的意图不是为了支持C而不是Rust，而是要表明关于语言选择的决策要复杂得多，远不止人们随意扔出的声音片段。

我已经涵盖了很多内容（并且已经删除了很多内容，包括大量示例代码），但让我试着聚焦于可操作的内容。

## 对于团队来说

1.  **探索选择的整体经济学。** 在选择技术时，彼此挑战考虑更广泛的经济影响，并尝试获得支持你的假设的数字。这有很多方面，但在这次讨论的背景下，这通常会推动你选择像 Go 这样的语言，而避免选择 Rust 或者 C，因为人们往往会凭直觉做出选择，这通常会高估性能的重要性。

1.  **如果你不想提前分析，请不要从事系统语言。** 反而，可以选择开始使用 Go、Swift、Java、C# 或者其他任何真正优秀的编译语言。记住，如果你的直觉强调性能，Python 对各种事情都有可接受的性能（还记得 Dropbox 吗？），而编译语言的效率要远远高于它。

1.  **务必考虑安全性。** 仅仅因为你选择了 Rust 并不意味着安全性会自动得到保证。坏事仍然可能发生在你身上。请深入了解超越“思想领袖”声音的实际情况。

1.  **避免不必要的依赖关系。** 我在这里留下“不必要”的定义比较模糊；你需要进行教育并评估所有经济因素。但请注意，减少依赖通常还有其他好处，从缩短构建时间到减少测试表面，再到减少来自下游依赖项的 API 更改或错误的风险。

1.  **注意你所拥有的依赖关系。** 不仅要试图了解依赖扫描工具提供的传递图，还值得深入挖掘了解那些工具未能找到的东西。你的运行时可能会链接一些 C 库，当下一个 *xz affair* 浮出水面时，能够更容易、更真实地评估你面临的风险就非常有帮助。

1.  **尽量确保外部安全审查。** 对于企业软件来说，这几乎是一种常态，因为大型购买者会要求有相关证据。但每个人都应该考虑如何定期促进这样的审查，并将其视为一个机会，而不仅仅是一个要勾选的框。

1.  **如果选择 C 语言，请提供围绕你决策的文档。** 我之所以这么说是因为安全问题绝对是真正的问题，人们有权知道你已经做了出色的工作。在我看来，如果你坚持官方建议，C++ 并不属于同一类别，但是很多人实际上并未遵守，所以我会偏向谨慎行事，并在使用 C++ 时采取同样的做法。

1.  **如果选择 C 语言，请积极有效地解决内存安全问题。** 例如，如果可能的话，使用 Boehm 收集器。否则，在不可能时使用最佳的技术。

注意，许多 C 开发者回归到不安全的原语的主要原因并不是因为他们缺乏对安全风险的了解，而是因为他们通常有一些大型依赖项（如 OpenSSL 或其他一些加密库），不清楚如何例如在易于、可移植的方式下应用 Boehm 垃圾收集器到这些第三方库中（尽管在许多情况下，如果自行编译源代码，实际上可以轻松地重新定义 `malloc()` 等来调用 Boehm API，并且在其他情况下，有一些低级技术可以解决这个问题，但它们过于低级而不推荐）。

即使是那些正在构建自己的轻量级内存管理（*arena allocation* 正变得流行，可以考虑为非常轻量级的垃圾收集形式），但许多最常见的依赖项如 OpenSSL 提供了直接的方法来向库提供内存分配器，如果你寻找它们。

如果有足够的兴趣，我可以详细介绍这一点（尽管我更希望您采用其他语言）。

## 对于安全行业

在这里，我当然是指思想领袖，但任何关心安全并且愿意基于安全做出决策，并且愿意和他人讨论这些问题的人。

1.  **最重要的是，请记住，仅仅因为您认为这是一个糟糕的安全决策，并不意味着它在整体上是一个糟糕的决策。** 尽量听取非安全人员的意见，并了解他们的优先事项。您可能会反对“FUD”（恐惧、不确定性和疑虑），但是简化非平凡问题以推动以牺牲一切成本来追求安全性基本上就是在传播 FUD。在这里只是举了 C 语言的一个例子。但请记住，即使安全影响要比我们目前考虑的更加复杂和微妙。

1.  **确保行业考虑更广泛的经济因素。** 当然，在行业外部，安全性远不及在行业内部重要。但我认为问题要深入得多 —— 如果安全行业试图把太多工作推给其他行业，我们至少会破坏更多的信誉，但也可能造成大量经济损失，例如通过推高小企业和个人的成本和责任风险，以至于他们根本不愿意去做。

1.  **为解决我们的遗留软件问题做出贡献。** 我很想摆脱 C 语言，但现实情况是，对于很好的理由，C 语言会比 COBOL 更具有顽固性。说“用一种安全语言重写所有代码，并尽快迁移”并不是真正的解决方案。这只是一个理想的愿景，从风险管理的角度来看完全不切实际。就像用 Postifx 替换 Sendmail 一样，我们可以取得进展，但必须是渐进式的，并且我们必须更加务实。

简而言之，是的，让我们100%放弃C和C++，但我们在实践中要实际一些，并与行业的其他部分进行良好的合作。我们的目标应该是完全使自己失业（或者，因为我们没有这种风险，努力朝着一个行业非常小的世界迈进……即使在遥远的未来）。

## 对于其余的行业

总体而言，其余的软件行业应该与安全行业合作，以可视化解决风险的必要措施。

1.  帮助找出我们如何能够保持一支新鲜的人才队伍，他们能够理解软件和硬件的边界。这意味着，我们最终需要有效地让熟练的人员执行预组装任务，比如以比当前在C语言中执行这些任务风险小得多的方式（不是为了避免这些任务）。如果答案不是“另一种编程语言”，那太好了，但如果需要另一种语言，双方都需要认真对待，以确保成功，因为世界上有很多没有影响力的语言。

1.  请推动其他人展示他们在更广泛经济决策上的工作，不要假设世界就像传下来的“常识”那样简单。这是一个快速变化的目标。

1.  语言设计者们，在考虑安全性的方式之外，请更多地思考和关注第三方依赖的影响，意识到在贡献与安全性之间保持平衡是困难的。我们需要更好的实用解决方案。

1.  而且在所有情况下，试着假设我们在系统性地错误估计的事情上是错误的，比如性能和安全性。也要假设你在任何方向上都可能错！现在，试着收集一些硬数据，以便更好地了解现实的实际情况。

# 反馈

我很乐意讨论这个话题或接受任何反馈。正如我所说的，我很乐意不断学习和重新评估我的观点。然而，这篇报道将在我长假期间发布，所以请联系我，但我可能不会及时回复。
