["```\nstruct X { const int n; };\nunion U { X x; float f; };\nvoid tong() {\n  U u = {{ 1 }};\n  u.f = 5.f;               // OK, creates new subobject of 'u'\n  X *p = new (&u.x) X {2}; // OK, creates new subobject of 'u'\n  assert(p->n == 2);       // OK\n  assert(*std::launder(&u.x.n) == 2); // OK \n  // undefined behavior, 'u.x' does not name new subobject\n  assert(u.x.n == 2);\n}\n```", "```\n template<typename _Tp>\n   constexpr _Tp*\n   launder(_Tp* __p) noexcept\n   {\n     return __p;\n   }\n```", "```\nvoid *operator new(size_t, void *p) { return p; }\n\nstruct A {\n  virtual int f();\n};\n\nstruct B : A {\n  virtual int f() { new (this) A; return 1; }\n};\n\nint A::f() { new (this) B; return 2; }\n\nint h() {\n  A a;\n  int n = a.f();\n  int m = std::launder(&a)->f();\n  return n + m;\n}\n```", "```\nint h() {\n  return 4;\n}\n```"]