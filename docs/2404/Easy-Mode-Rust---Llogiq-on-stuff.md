<!--yml

类别：未分类

date: 2024-05-27 12:57:05

-->

# 简易模式Rust — Llogiq对事物的见解

> 来源：[https://llogiq.github.io/2024/03/28/easy.html](https://llogiq.github.io/2024/03/28/easy.html)

# 简易模式Rust

2024年3月28日

本文基于我的[RustNationUK ‘24](https://rustnationuk.com)演讲，主题相同。[演讲视频](https://www.youtube.com/watch?v=33FG6O3qejM)在YouTube上，幻灯片[从这里提供](/talks/easy.html)。

此外，这是我在演讲中介绍的歌曲歌词（以Bob Dylan的“The times, they are a-changin’”的曲调演唱）：

> 招聚Rust爱好者们，无论你们在何处漂泊
> 
> 并承认我们的人数已经稳步增长。
> 
> 社区的令人敬畏并不是一成不变的，
> 
> 所以如果这对你值得保存
> 
> 那么你最好开始联合起来而不是独自劳作
> 
> 时光变迁。
> 
> 来博客作者和作者们，用你的笔教导
> 
> 并教那些新手，这次机会不会再来！
> 
> 曾经只有一个新手，很快就会变成十个
> 
> 你的知识是他们渴望的。
> 
> 知道你与他们分享的将是你所获得的
> 
> 时光变迁。
> 
> 研究人员和编码人员，请听从呼唤，
> 
> 没有你们的努力，Rust将一无所有
> 
> 而不安全性将在它现在遇到失败的地方上升。
> 
> 愿C++支持者狂欢。
> 
> 它们与我们之间的分歧仅仅是一个rustup安装
> 
> 时光变迁。
> 
> 全国各地的同行管理员们
> 
> 你不敢审查那些不是为了冒犯而写的东西
> 
> 否则很快乐于助人的人将被禁止
> 
> 剩下的将是愤怒的人们在愤怒。
> 
> 我们的首要任务是帮助理解
> 
> 时光在变迁。
> 
> 界线已经划定，类型已经铸成
> 
> 调试慢，发布会快
> 
> 因为现在的现在将来会成为过去
> 
> 我们的价值观正在迅速消失
> 
> 除非我们找到新的人才能让它们持续下去
> 
> 时光在变迁。

Rust有一个并不完全理所当然的声誉，即学习起来很难。但这在很大程度上是作为系统语言的必然结果，必须提供对代码和运行时细节的完全控制。但我认为我们教授Rust的方法更多地导致了这种声誉。因此，作为对“正确方法”的反毒药，我提出了这一组关于如何尽可能少地学习Rust以在Rust中变得高效的想法，这样你可以立即开始并取得成功，等你对基础知识感到舒适后再学习更难的部分。

在演讲中，我从练习的“基本规则”开始：我想确定一个小的子集供学习，使人们能够成功地编写 Rust 程序来解决面前的问题，而不会被各种新概念所淹没。我乐意牺牲性能、代码简洁性或成语化的代码。事实上，一些建议与关于良好 Rust 代码应该是什么样的传统指南背道而驰。演讲之后的一个问题是如何处理新的贡献者或同事向项目推送“次标准”代码，我的建议是先合并再清理。新用户会对自己的能力感到不安，对细节挑剔会让他们望而却步，而我们希望在他们刚开始学习和成长的阶段鼓励他们。

当然，这种方法的反面是我并不建议每个 Rust 爱好者只学习这一小部分，并永远避免其他所有内容。这里的想法是让您快速地变得高效和成功，然后您可以在此基础上进行扩展。演讲之后还提出了一个建议，即创建一张“研究树”海报（有时在像 Civilization 这样的策略游戏中使用，给人们提供一条不那么线性的进展路径）。这还在我的计划清单上，我很快会为此开一个仓库，希望能找到愿意帮助我的人。

因此，我们要避免学习的事物，就是这些：

### 语法

Rust 不是一种小语言。刚开始时，对于流程控制，最好只使用基本的东西如 `if`、`for` 和 `while`。如果需要区分例如枚举变体，还可以使用 `match`，但保持简单：只匹配一件事，避免使用更复杂的东西如守卫条件：

```
// Don't nest patterns in match arms
match err_opt_val {
  Some(Err(e)) => panic!("{e}"),
  _ => (),
}

// instead, nest `match` expressions
match err_opt_val {
  Some(err_val) => match err_val {
    Err(e) => panic!("{e}"),
    _ => (),
  },
  _ => (),
}

// Don't use guards
match w {
  Some(x) if x > 3 => { one(x) },
  Some(x) => { other(x) },
  None => (),
}

// instead, nest with `if`
// (that might require you to copy code)
match w {
  Some(x) => {
    if x > 3 {
      one(x)
    } else {
      other(x)
    }
  },
  None => (),
} 
```

现在先避免使用其他结构（例如 `if let` 或 `let`-`else`）。尽管它们可能使代码更易读，但您可以稍后学习它们，并在了解它们的工作原理后让您的 IDE 快速重构代码。在循环中，避免使用 `break` 和 `continue`，特别是与值相关的情况。最好是引入一个新函数，在循环内部返回该值。

如介绍中所讨论的，这将需要更多的代码，因此会加剧代码的简洁性和可读性，但单独的移动部分要简单得多。

### ~~借用检查器~~

在我的演讲中，我使用了一个经典的例子，搜索算法经常会遇到：扩展一组项的集合，使用之前项的过滤和修改版本。

```
for item in items.iter() {
  if predicate(item) {
    items.push(modify(item));
  }
} 
```

此处的代码几乎与例如 Python 中的操作相同。它易于阅读和理解，没有不必要的移动部分。不幸的是，它也是错误的，编译器会毫不犹豫地指出这一点：

```
 Compiling unfortunate v0.0.1
error[E0502]: cannot borrow `items` as mutable because it is also borrowed as immutable
  --> src/main.rs:16:13
   |
13 |     for item in items.iter() {
   |                 ------------
   |                 |
   |                 immutable borrow occurs here
   |                 immutable borrow later used here
...
16 |             items.push(new_item);
   |             ^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here

For more information about this error, try `rustc --explain E0502`. 
```

幸运的是，在几乎所有情况下，我们可以将不可变借用与可变借用分开。在这种特殊情况下，我们可以简单地遍历我们项列表的克隆：

```
//               vvvvvvvv
for item in items.clone().iter() {
  if predicate(item) {
    items.push(modify(item));
  }
} 
```

我过去对克隆非常谨慎，认为它是一种反模式，但除非该代码在热路径上，否则它实际上不会在您应用的性能分析中显示出来。因此，避免那个克隆是过早的优化。但是，如果您已经测量并注意到克隆实际上显示在您的内存或 CPU 分析中，您可以切换到索引：

```
for i in 0..items.len() {
  if predicate(&items[i]) {
    let new_item = modify(&items[i]);
    items.push(new_item);
  }
} 
```

请注意，这种方法比基于克隆的方法更脆弱：虽然在这种情况下，循环本身仅使用整数，因此不会借用任何内容，但我们仍然可能会在循环体中无意中引入重叠借用。例如，如果我们用 `if let` 替换 `if`，则 `items` 将在 then 子句的持续时间内被借用，从而导致我们试图在第一次避免时遇到的确切错误。还请注意，我们将 `modify(..)` 放入本地变量以避免将其放在 `push` 内部，这也可能会让借用检查器产生问题。

再次强调，我们通常不追求性能，所以我尽可能地偏向基于克隆的变体。

### 宏

宏在 Rust 中早早就出现了。事实上，每个人编译（甚至编写）的第一个 Rust 程序是：

```
fn main() {
  println!("Hello, World!");
} 
```

您在 Rust 中将很难避免调用宏，所以我建议您将它们视为函数一样对待，但要注意它们可能具有相当可变的语法，但它们通常会有文档说明。因此，只要大致知道如何调用宏以及它们的功能，随时可以自由调用它们。

*编写* 宏是我们将要避免的事情。Rust 有许多宏类型（声明宏、声明宏 2.0、派生宏、注解宏和过程宏），但我们不打算编写任何这些宏。所有这些宏变体解决了一个问题：代码重复。

现在，避免宏的明显简单解决方案是：复制您的代码。

尽管听起来非常简单，但事实上，建议可以分为依赖于手头问题的一系列解决方案的层次结构：

1.  最多五次，少于10行代码，不预计改变：在这种情况下，我会直接复制并粘贴代码，然后根据您的需求进行编辑。当然，您仍然面临将复制的代码中的一个实例引入错误的风险，但由于生成的代码相对紧凑，您有很好的机会快速捕捉到这些错误。

1.  多于此数量，但在一定时间内不预计更改：谁比你更擅长创建多个几乎相同的实例？当然是你的计算机！因此，编写一些 Rust 代码来通过构建字符串（使用 `format!(..)` 或 `println!(..)`）构建 Rust 代码，调用它一次，然后将输出复制到您的代码中。就这样！

1.  期望与其余代码保持更新？在这种情况下，把你的代码生成放入一个单元测试中，读取和分割当前版本的代码，生成可能更新的版本，比较两者，如果它们不同，则写入更新的代码，然后用一条消息告诉运行测试的人他们需要提交更改。为了使分割更容易，并记录代码是生成的事实，向生成代码添加开始和结束标记注释是有帮助的。

在代码中，而不是这样做：

```
macro_rules! make_foo {
  { $($a:ident),* } => { $(let $a = { "foo" };)* };
}
make_foo!(a, b); 
```

或者 1\. 复制并粘贴：

```
let a = { "foo" };
let b = { "foo" }; 
```

或者 2\. 编写代码来生成代码：

```
fn format_code(names: &[&str]) -> String {
  let mut result = String::new();
  for name in names {
    result += format!("\nlet {name} = \"foo\";");
  }
  result
} 
```

此外，3\. 使用测试来保持代码更新：

```
#[test]
fn update_code() {
  let (prefix, actual, suffix) = read_code();
  let expected = format_code(&["a", "b"]);
  if expected == actual { return; }
  write_code(prefix, expected, suffix);
  panic!("updated generated code, please commit");
} 
```

Alexey Kladov 在他关于 [自修改代码](https://matklad.github.io/2022/03/26/self-modifying-code.html) 的博客文章中更好地解释了后一种技术。

### 泛型

通过泛型，我们可以在各种情况下重用代码，通过能够替换类型。然而，它们也可能是复杂性的主要来源，因此我们当然希望避免它们。正如 Go 在 1.2 版本之前展示的那样，你可以在很大程度上做到这一点，所以除非是用于集合的元素类型，否则我们将避免使用它们。

因此，而不是编写

```
struct Foo<A, B> { .. }
fn foo<A, B>(a: A, b: B) { .. } 
```

我们将手动单态化（也就是为我们需要的每组具体类型构建代码的副本），因此对于每个 `A`/`B` 组合，我们将编写：

```
// given `struct X; struct Y`
struct FooXY { .. }
fn foo_x_y(a: X, b: Y) { .. } 
```

当然，你可能会遇到很多副本，所以使用上面的代码生成来处理这些副本。

### 生命周期

生命周期注解是那些神秘的标记+字母组合，有时甚至会让中级 Rust 程序员感到困惑，所以你不会对在这个列表上找到它们感到惊讶。它们看起来像这样：

```
struct Borrowed<'a>(&'a u32);
fn borrowing<'a, 'b>(a: &'a str, b: &'b str) -> &'a str { .. } 
```

当然，我们现在不想为自己背负这些带有符号的怪物。要摆脱这些东西，我们必须避免在函数签名中借用。因此，不要取一个引用，而是取一个拥有的实例。是的，这会导致更多的克隆。如果你需要共享一个对象（例如因为你想要改变它），把它包装在一个 `Arc` 中：

```
struct Arced(Arc<u32>);
fn cloned(a: String, b: String) -> String { .. }
fn arced(a: Arc<String>, b: Arc<String>) -> String { .. } 
```

`Arc` 是一个智能指针，让你可以不克隆包装的值就调用 `.clone()`。两个 `Arc` 将指向完全相同的值，如果你改变一个，另一个也会改变。

### 特性

在 Rust 中，你可以完成很多工作，而不必实现一个 trait。然而，在某些 trait （尤其是在标准库中，也在像 [serde](https://serde.rs) 这样 trait-heavy 的 crate 中）中，你可能需要完成一些任务。在许多情况下，你可以使用 `#[derive(..)]` 注解，比如：

```
#[derive(Copy, Clone, Default, Eq, PartialEq, Hash)]
struct MyVeryBadExampleIAmSoSorry {
  size: usize,
  makes_sense: bool,
} 
```

在某些情况下，Rust 的传统可能会建议你使用基于 trait 的分发，但在大多数情况下，一个 `enum` 和一个 `match` 或者一组 `if`-clauses 就能解决问题。记住，我们并不打算让我们的代码参加美丽大赛，只是想完成工作而已。

最后，如果你使用一个需要手动实现 trait 的框架，请写 `impl WhateverTrait for SomeType`，并在你的 IDE 中使用 `insert missing members` 代码操作（如果可用）。

### 模块和导入

这是我们无法完全避免的事情。如果我们不使用任何导入，我们的代码只能使用标准库预导入定义的内容，而我们不能做很多事情。即使我们这样做了，我们也会得到一个10+k行代码的文件，没有人想要导航到那里。另一方面，当使用模块时，我们应该努力避免过度使用，以免发现自己身处一个迷宫般的`mod.rs`文件中，所有文件都不同（原谅我这个文字冒险的引用）。

所以我们显然需要导入我们使用的东西，但是如何引入`mod`呢？保持简单的关键在于，模块将代码组织与我们的 crate 中路径的层次结构混为一谈。因此，如果我有一个包含`bar`的`mod foo`，那么使用我的代码的人将不得不导入或直接指定`foo::bar`。但是有两种方法可以解开这些混乱的方法。给出一个示例`lib.rs`，我们的代码有两个函数：

```
pub fn a() {}
pub fn b() {} 
```

现在在实践中，这些函数可能不会是空的，在大多数情况下我们会有更多的函数，但是你想要阅读这篇博客文章，而不是在大量代码中浏览，所以让我们看看我们将用来将`b`移动到新的`b.rs`文件的第一个方法，而不改变外部可见的`b`路径。这个方法有三个步骤：

1.  在`lib.rs`中声明`b`模块并从中`pub use` `b`：

```
mod b;
pub use b::b;

pub fn a() {}
pub fn b() {} 
```

1.  创建`b.rs`，从上面导入所有内容，这样`fn b()`就不会因为来自`lib.rs`的路径丢失而无法编译：

1.  将`fn b()`移动到`b.rs`：

```
use super::*;

// moved from `lib.rs`:
pub fn b() {} 
```

恭喜，你刚刚将你的代码拆分开来，而没有任何人使用它时会觉得愚蠢。

第二种方法是将`b`路径移动到`b`模块中。在这种情况下，我们必须使`b`模块对外可见，然后从我们的`lib.rs`中移除`pub use`：

```
pub mod b; // added `pub` here
//pub use b::b; <-- no longer needed

pub fn a() {} 
```

哇，你的用户将无法直接调用`b()`了，除非他们从`b::b`导入它。现在模块仍然是一个混乱的野兽，但至少有简单的步骤可以解决它们。

### 异步

Rust 的异步是神秘的、强大的，但仍然存在许多棘手的问题。因此，除非你正在编写一个需要在单台机器上为五万个并发用户提供服务的网络服务（记住，我们这里不是为了性能），否则尽量避免使用它。然而，你可能想要使用的一些库*将*需要异步代码。在这种情况下，选择一个异步运行时（大多数库都可以与[tokio](https://docs.rs/tokio)一起使用，所以这似乎是一个安全的选择）并且

+   编写函数时，像写普通函数一样，在`fn`之前加上`async`

+   在每个函数调用后添加`.await`，然后在编译器抱怨的地方再次删除它

+   避免使用像`Mutex`、`RwLock`和通道这样的潜在锁机制。如果你确实需要使用它们之一，你的异步运行时将提供替代方案，这些方案不会让你陷入死锁。

你可能仍然会遇到奇怪的错误。不要说我没有警告过你。

### 数据结构

如果我每次有人要求我在安全的Rust中编写双向链表，我就能得到一分钱（提示：我可以，但我不需要，在标准库中已经有了一个），那我会成为一个非常富有的人。所以你不会惊讶于我建议你避免编写自己的数据结构。事实上，我会更进一步，让你推迟学习已提供的数据结构是什么，因为在大多数情况下，你只需要两种：类似序列和类似查找。

#### 序列

无论你把它们称为列表、数组还是序列都无关紧要。这种类型的结构通常用于填充和后续迭代。例如，如果我们想要三个项目：

1.  开始

1.  更多

1.  结束

我们可以把它们放在 `Vec` 中：

```
vec!["start", "more", "end"] 
```

在任何需要顺序迭代项目的地方使用 `Vec`。

#### 查找

可能称为映射或字典，并允许你将键与值关联起来，以便稍后根据键检索值。

| **键** | **值** |
| --- | --- |
| 递归 | 请查看“递归” |

我们将在此案例中使用 `HashMap`：

```
HashMap::from([
  ("recursion", "please look at recursion"),
]) 
```

虽然哈希映射可以进行迭代，但主要用途是根据键获取值。

你会惊讶地发现，只要坚持使用这两种结构，你可以创建多少程序。

### 自定义迭代器

Rust 迭代器也非常强大，可以调用它们的组合函数（如 `filter`、`map` 等）来创建新的迭代器。只需注意两点：首先，组合函数 *不会* 迭代任何内容，它们只会将给定的迭代器包装成一个新的迭代器类型，修改迭代器的行为；其次，生成的类型通常非常难以，甚至不可能写出。因此，你应该尽量避免从函数返回这样的自定义迭代器，而是将其 `collect` 到 `Vec` 或 `HashMap` 中（见上文）。然而，如果你的迭代器是无限的（是的，这种情况确实会发生），那么你显然无法将其收集起来。在这些罕见的情况下，这是使其工作的魔法技巧：

```
fn return_custom_iterator() -> Box<dyn Iterator<Item = MyItemType>> {
  // let's say we filter and map an effectively infinite range of integers
  let iter = (0_usize..).filter(predicate).map(modify);
  Box::new(iter) as Box<dyn Iterator<Item = MyItemType>>
} 
```

现在你知道在你在 Rust 中保持高效生产的同时可以推迟学习哪些事情。玩得开心！
