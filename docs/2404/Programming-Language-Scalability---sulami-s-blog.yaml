- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:10:43'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Programming Language Scalability - sulami's blog
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.sulami.xyz/posts/programming-language-scalability/](https://blog.sulami.xyz/posts/programming-language-scalability/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I have been thinking about programming language scalability. I am not talking
    about performance here, but organizational scalability. Let us start with a bit
    of background.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons I originally joined CircleCI was because they were using
    Clojure, and I had been dabbling in Clojure at the time. I believe their choice
    of language caused a self-selection effect for many of the early engineers, probably
    for the better. Regardless, some time before I left the company, we got the mandate
    to move everything to Go. The company was going through an intense growth phase,
    and it was becoming increasingly difficult to hire Clojure engineers. We had a
    reasonable amount of Go code already, so the choice was obvious. Another factor
    that played into this decision was the fact that most Clojure engineers could
    drop into a Go service and make some changes relatively easily, while the reverse
    was not quite as true. This is not because the Clojure engineers were better,
    but because it is more difficult to be effective in an unfamiliar Clojure codebase
    than in a Go one.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: There were also some technical growth pains we experienced on the Clojure side.
    Clojure being a highly dynamic language, we had a decent number of runtime errors,
    which we could only counter with additional testing and observability. The lack
    of static types also made development more difficult for anyone not directly familiar
    with the code, as almost everything tended to be a bag of values in the form of
    a map. The macro system and a culture that emphasized expressiveness led to a
    variety of different design patterns, each optimized for their respective author's
    preferences, and inscrutable to everyone else. It also did not help that Clojure
    has no standard approach to structure a service, so everyone rolled their own.
    One could not freely jump between different Clojure services without having to
    learn the different idioms.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: In my current day job, we are running a Ruby on Rails monolith. The engineering
    department is much smaller at around 30 people, but the monolith has been around
    for about a decade. While Rails engineers are easier to hire than Clojure ones,
    especially here in Japan, we are experiencing some of the same pain points as
    we did at CircleCI. Ruby is also dynamically typed, and has a culture of domain-specific
    languages that read almost like plain English. "Automagical" abstractions are
    seen as a virtue. As a result, we have a variety of competing patterns for almost
    every situation, each of which requires some learning. Within the monolithic architecture,
    no boundaries are defined or enforced, and it is difficult to reason about the
    impact of any given change. What personally gets me is the meta-programming and
    module system which together make it difficult to track down where methods come
    from, even for LSP servers.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In both of these cases, the problems maybe could have been alleviated with
    better technical leadership or otherwise different practices, but I believe in
    setting yourself up for success despite yourself. As organizations grow, one cannot
    depend on everyone being good at their job, or even average, if statistics are
    to be believed. With this I would like to talk about the scalability of a programming
    language, which I will define it as:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: A programming language is more scalable if an engineer unfamiliar with a code
    base written in it produces correct code more quickly.
  id: totrans-split-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Scalability is often at odds with *peak effectiveness*, the maximum effectiveness
    of an engineer who is intimately familiar with the codebase, because the features
    driving peak effectiveness are often enabling abstractions tailored towards the
    specific use case at hand, like macros and support for domain-specific languages.
    These abstractions can make domain experts more effective, but present an additional
    barrier to entry to everyone else. At the extreme end of this spectrum sit code
    golf languages.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: There are many factors that contribute to scalability. Prevalence determines
    how easy it is to hire for, and to some extent also the support from the ecosystem
    in the shape of libraries, tooling and available knowledge. Guardrails help prevent
    mistakes, the biggest ones being memory safety and static type checking. The latter
    also enables better support for editor integrations such as LSP which enhances
    discoverability. Standardized tooling for the build process, formatting, testing,
    and so on further reduce the potential need to learn multiple approaches. Support
    for, and a culture of heavily using language extension features on the other hand
    reduce scalability, as detailed in the [Lisp Curse](http://www.winestockwebdesign.com/Essays/Lisp_Curse.html).
    Languages that deviate a lot from the mainstream are on average more difficult
    to learn, whether it is quirky syntax with a lot of parentheses, or a weird execution
    model that involves monads.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, language scalability is not just something managers want to optimize
    for in order to ensure engineers are fungible. While independent teams are a worthy
    goal to aspire to, in reality cross-team dependencies are common, and being able
    to submit a change to another team's code can reduce the overhead incurred. And
    of course some code goes untouched for many months or years, to the point where
    even the original authors cannot claim familiarity anymore.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: As an example, I have collected some subjective thoughts on the scalability
    of programming languages I am familiar with, ordered roughly from most scalable
    to least scalable, in the context of web service backend systems. In other contexts
    the list would of course look different.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: <details><summary>A non-exhaustive list of programming languages</summary>
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  id: totrans-split-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevalent enough and backed by several corporate sponsors to be considered mainstream
  id: totrans-split-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fantastic support through a strong type system and LSP integration
  id: totrans-split-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Great build tooling through cargo
  id: totrans-split-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Concise but not obtuse
  id: totrans-split-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Steepest learning curve among mainstream languages
  id: totrans-split-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Go
  id: totrans-split-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubiquitous, backed especially by Google
  id: totrans-split-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Very easy to pick up
  id: totrans-split-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Statically typed and emphasis on explicit code
  id: totrans-split-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushes a lot of complexity onto the programmer under the guise of simplicity,
    in my opinion overdoing it
  id: totrans-split-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some questionable design decisions, like `nil` and error handling ergonomics,
    but also the module system and [lots of small things](https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride)
  id: totrans-split-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Java/Kotlin
  id: totrans-split-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubiquitous with many corporate sponsors
  id: totrans-split-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the best library ecosystems
  id: totrans-split-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Great tooling available, especially IDEs and profilers
  id: totrans-split-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prone to overly complex design patterns
  id: totrans-split-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Build tooling is aged
  id: totrans-split-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  id: totrans-split-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby
  id: totrans-split-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevalent enough to be considered mainstream (though waning), backed by several
    corporate sponsors, such as Stripe and Shopify
  id: totrans-split-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically typed, and even worse boundary enforcement than Python
  id: totrans-split-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Culture of meta-programming and domain-specific languages
  id: totrans-split-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript/TypeScript
  id: totrans-split-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubiquitous
  id: totrans-split-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript has one of the better type systems
  id: totrans-split-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Quite well optimised, with different runtime options available
  id: totrans-split-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Designed as a scripting language for web browsers, with shortcomings arising
    from that
  id: totrans-split-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many layers of abstractions built up over time, especially conventions
  id: totrans-split-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prone to paradigm shifts every few years
  id: totrans-split-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Erlang/Elixir
  id: totrans-split-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quite niche for the general purpose, although used in some selected contexts
  id: totrans-split-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically typed
  id: totrans-split-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ecosystem somewhat limited for general purpose use
  id: totrans-split-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Actor-model and servers take some learning
  id: totrans-split-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure
  id: totrans-split-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Haskell
  id: totrans-split-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statically typed
  id: totrans-split-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Very niche
  id: totrans-split-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard to learn, even harder to master
  id: totrans-split-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Complexity scales badly with program size
  id: totrans-split-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost requires domain-specific languages with custom operators</details>
  id: totrans-split-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If I wanted to select viable candidates from that list, I would probably pick
    between Rust, Go, or Java/Kotlin. C# would probably also work, but I have not
    written any in close to a decade. I arrive there with a simple heuristic, as all
    of these languages are statically typed and considered mainstream, almost boring.
    I am excluding C and C++ for the lack of guardrails, and Python and Ruby for the
    lack of static typing. Typescript as a language might be fine, but I personally
    have doubts about the stability of the tooling, which might be unfounded. It is
    certainly popular, even on the backend.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: Programming language scalability is only interesting for organizations, and
    only beyond a certain size. If your engineering team can fit in a single room
    for the next five years, it probably does not matter. Conventional wisdom is that
    the best technology to start a new project is the one you know well. And sometimes
    there will be technical requirements that trump organizational ones. In any case,
    you should take care to spend your [innovation tokens](https://mcfunley.com/choose-boring-technology)
    wisely.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
