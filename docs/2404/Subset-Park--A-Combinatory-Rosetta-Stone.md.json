["```\nconst maybeAbs = n => shouldNormalizeNegatives ? Math.abs(n) : n\nreturn nums.map(maybeAbs) \n```", "```\nconst maybeAbs = shouldNormalizeNegatives ? Math.abs : identity \n```", "```\n(def maybe-abs (if should-normalize-negatives math/abs identity))\n(map mayb-abs nums) \n```", "```\n is_between_negative_3_and_0 =: (<&0)*.(>&_4)\n    maybe_abs =: [`| @. is_between_negative_3_and_0\n    maybe_abs _5 _4 _3 _2 _1 0 1 2 3\n_5 _4 3 2 1 0 1 2 3 \n```", "```\nfunction agenda(p, f, g) {\n    return x => {\n        if (p(x)) {\n            return f(x)\n        } else {\n            return g(x)\n        }\n} \n```", "```\nconst cleanData = datum => removeUndefineds(coalesceNaNs(datum))\nconst cleanedData = dirtyData.map(cleanData) \n```", "```\nconst cleanData = compose(removeUndefineds, coalesceNaNs) \n```", "```\n(def clean-data (comp remove-undefineds coalesce-nans)) \n```", "```\nclean_data =: remove_undefineds @ coalesce_nans \n```", "```\nconst absoluteDifference = (x, y) => Math.abs(x - y)\nreturn absoluteDifference(9, 13) // => 4 \n```", "```\nconst absoluteDifference = compose(Math.abs, _.subtract) \n```", "```\n(def absolute-difference (comp math/abs -))\n(absolute-difference 11 24) # => 13 \n```", "```\nabsolute_difference =: |@:- \n```", "```\n(-> dirty-data (coalesce-nans) (remove-undefineds)) \n```", "```\nconst basesAndExponents = [[0, 1], [1, 2], [3, 5], [8, 13]]\nreturn basesAndExponents.map(([base, exponent]) => base ** exponent) // => [ 0, 1, 243, 549755813888 ] \n```", "```\nargs => {\n    const base = args[0]\n    const exponent = args[1]\n    return base ** exponent\n} \n```", "```\nreturn basesAndExponents.map(apply(Math.pow)) \n```", "```\n(def bases-and-exponents [[0 1] [1 2] [3 5] [8 13]])\n(map (apply math/pow) bases-and-exponents) \n```", "```\n exponentsAndBases: (0 1;1 2;3 5;8 13)\n  pow: */# \n  pow .' exponentsAndBases\n1 2 125 815730721 \n```", "```\nconst exponentsAndBases = [[0, 1], [1, 2], [3, 5], [8, 13]]\nreturn exponentsAndBases.map(([exponent, base]) => base ** exponent) // => [ 1, 2, 125, 815730721 ] \n```", "```\nreturn exponentsAndBases.map(apply(flip(Math.pow))) // => [ 1, 2, 125, 815730721 ] \n```", "```\n(def exponents-and-bases [[0 1] [1 2] [3 5] [8 13]])\n(map (apply (flip math/pow)) exponents-and-bases) \n```", "```\nfunction explicit(x, y) {\n    return [x ** y, y / x]\n}\nreturn explicit(2, 3) // => [ 8, 1.5 ] \n```", "```\nconst tacit = recombine(Array.of, Math.pow, flip(_.divide)) \n```", "```\n(def double (partial * 2)) \n```", "```\n(defn square [n] (math/pow n 2)) \n```", "```\n(def square (partial (flip math/pow) 2)) \n```", "```\n(defn attr-sorter\n  [key &opt descending?]\n  (defn by [x y] ((if descending? > <) (x key) (y key)))\n  (fn [items] (sort items by))) \n```", "```\n(defn attr-sorter\n  ...\n  (partial (flip sort) by)) \n```", "```\nconst mean = xs => _.sum(xs) / xs.length\nreturn mean([0, 1, 1, 2, 3, 5, 8, 13]) // => 4.125 \n```", "```\nconst mean = recombine(_.divide, _.sum, _.size) \n```", "```\n(def mean (recombine / sum length)) \n```", "```\nmean =: +/ % # \n```", "```\nconst minMax = xs => [_.min(xs), _.max(xs)]\nreturn minMax([1, 1, 2, 3, 5, 8, 13]) // => [ 1, 13 ] \n```", "```\nconst minMax = recombine(Array.of, _.min, _.max) \n```", "```\n(def min-max (recombine array min-of max-of)) \n```", "```\n min_max =: <./ , >./\n   min_max 0 1 1 2 3 5 8 13\n0 13 \n```", "```\nconst plusOrMinus = (x, y) => [x + y, x - y]\nreturn plusOrMinus(13, 8) // => [ 21, 5 ] \n```", "```\nconst plusOrMinus = recombine(Array.of, _.add, _.subtract) \n```", "```\n(def plus-or-minus (recombine array + -))\n(plus-or-minus 13 8) \n```", "```\n plus_minus =: - , +\n   1 plus_minus 2\n_1 3 \n```", "```\n(deftest item-getter\n  (let [item {:foo {:bar :baz}}\n        getter (bagatto/item-getter [:foo :bar])]\n    (is (== :baz (getter {} item))))) \n```", "```\n(defn item-getter\n  [path]\n  (fn [site item] (get-in item path))) \n```", "```\n(defn item-getter\n  [path]\n  (recombine get-in right (constant path))) \n```", "```\nfunction sum(xs) {\n    return xs.reduce((n, m) => n + m) \n}\nfunction std(xs) {\n    const mean = sum(xs) / xs.length\n    const squaredDifferences = xs.map((x - mean) ** 2)\n    const meanSquares = sum(squaredDifferences) / xs.length\n    return Math.sqrt(meanSquares)\n}\nreturn std([0, 1, 1, 2, 3, 5, 8, 13]) // => 4.136348026943574 \n```", "```\npow: {*/y#x}\nmean: %/ (+/;#:) @\\:\nstd: % mean @ pow[;2]' -/ 1 mean\\ \n```", "```\nconst eachValueIsUnique = xs => xs === _.uniq(xs)\nreturn eachValueIsUnique([0, 1, 1, 2, 3, 5, 8, 13]) // => false\nreturn eachValueIsUnique([0, 1, 2, 3, 5, 8, 13]) // => true \n```", "```\nconst eachValueIsUnique = recombine(_.isEqual, identity, _.uniq) \n```", "```\n(def each-value-is-unique (recombine deep= identity distinct))\n(each-value-is-unique [0 1 2 3 5 8 13]) \n```", "```\n each_value_is_unique =: -: ~.\n   each_value_is_unique 0 1 1 2 3 5 8 13\n0\n   each_value_is_unique 0 1 2 3 5 8 13\n1 \n```", "```\n eachValueIsUnique: ~/ 1 ?:\\\n    eachValueIsUnique 0 1 1 2 3 5 8 13\n0\n    eachValueIsUnique 0 1 2 3 5 8 13\n1 \n```", "```\n ~/ (?:;::) @\\: 0 1 1 2 3 5 8 13\n0\n    ~/ (?:;::) @\\: 0 1 2 3 5 8 13\n1 \n```", "```\nconst isAnagram = (x, y) => _.sortBy(x) === _.sortBy(y)\nreturn isAnagram(\"live\", \"evil\") \n```", "```\nconst isAnagram = under(_.isEqual, _.sortBy) \n```", "```\n(def is-anagram (under deep= sort))\n(is-anagram @\"live\" @\"evil\") \n```", "```\nsort =: /:~\n    is_anagram =: -:&:sort\n    is_anagram =: -:&:sort\n   'evil' is_anagram 'live'\n1 \n```"]