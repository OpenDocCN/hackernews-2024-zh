- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:04:46'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: ETag and HTTP caching | Redowan's Reflections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://rednafi.com/misc/etag_and_http_caching/](https://rednafi.com/misc/etag_and_http_caching/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One neat use case for the HTTP `ETag` header is client-side HTTP caching for
    `GET` requests. Along with the `ETag` header, the caching workflow requires you
    to fiddle with other conditional HTTP headers like `If-Match` or `If-None-Match`.
    However, their interaction can feel a bit confusing at times.
  prefs: []
  type: TYPE_NORMAL
- en: Every time I need to tackle this, I end up spending some time browsing through
    the relevant MDN docs ^(^(^(to jog my memory. At this point, I’ve done it enough
    times to justify spending the time to write this.)))
  prefs: []
  type: TYPE_NORMAL
- en: Caching the response of a `GET` endpoint[#](#caching-the-response-of-a-get-endpoint)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic workflow goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client makes a `GET` request to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server responds with a `200 OK` status, including the content requested
    and an `ETag` header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client caches the response and the `ETag` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For subsequent requests to the same resource, the client includes the `If-None-Match`
    header with the `ETag` value it has cached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server regenerates the `ETag` independently and checks if the `ETag` value
    sent by the client matches the generated one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they match, the server responds with a `304 Not Modified` status, indicating
    that the client’s cached version is still valid, and the client serves the resource
    from the cache.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If they don’t match, the server responds with a `200 OK` status, including the
    new content and a new `ETag` header, prompting the client to update its cache.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can test this workflow with GitHub’s REST API suite via the GitHub CLI^(.
    If you’ve installed the CLI and authenticated yourself, you can make a request
    like this:)
  prefs: []
  type: TYPE_NORMAL
- en: 'This asks for the data associated with the user `rednafi`. The response looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: I’ve truncated the response body and omitted the headers that aren’t relevant
    to this discussion. You can see that the HTTP status code is `200 OK` and the
    server has included an `ETag` header.
  prefs: []
  type: TYPE_NORMAL
- en: The `W/` prefix indicates that a weak validator ^(is used to validate the content
    of the cache. Using a weak validator means when the server compares the response
    payload to generate the hash, it doesn’t do it bit-by-bit. So, if your response
    is JSON, then changing the format of the JSON won’t change the value of the `ETag`
    header since two JSON payloads with the same content but with different formatting
    are semantically the same thing.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we make the same request again while passing the value
    of the `ETag` in the `If-None-Match` header.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means that the cached response in the client is still valid and it doesn’t
    need to refetch that from the server. So, the client can be coded to serve the
    previously cached data to the users when asked for.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few key points to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Always wrap your `ETag` values in double quotes when sending them with the `If-None-Match`
    header, just as the spec says^.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `If-None-Match` header to pass the `ETag` value means that the client
    request is considered successful when the `ETag` value from the client doesn’t
    match that of the server. When the values match, the server will return `304 Not
    Modified` with no body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we’re writing a compliant server, when it comes to `If-None-Match`, the spec
    tells us ^(to use a weak comparison for ETags. This means that the client will
    still be able to validate the cache with weak ETags, even if there have been slight
    changes to the representation of the data.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the client is a browser, it’ll automatically manage the cache and send conditional
    requests without any extra work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a server that enables client-side caching[#](#writing-a-server-that-enables-client-side-caching)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re serving static content, you can configure your load balancer to enable
    this caching workflow. But for dynamic `GET` requests, the server needs to do
    a bit more work to allow client-side caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple server in Go that enables the above workflow for a dynamic
    `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The server generates a weak `ETag` for its content by creating a SHA-256 hash
    and adding `W/` to the front, indicating it’s meant for weak comparison.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could make the `calculateETag` function format-agnostic, so the hash stays
    the same if the JSON format changes but the content does not. The current `calculateETag`
    implementation is susceptible to format changes, and I kept it that way to keep
    the code shorter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When delivering content, the server includes this weak `ETag` in the response
    headers, allowing clients to cache the content along with the `ETag`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For subsequent requests, the server checks if the client has sent an `ETag`
    in the `If-None-Match` header and weakly compares it with the current content’s
    `ETag` by independently generating the hash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the ETags match, indicating no significant content change, the server replies
    with a `304 Not Modified` status. Otherwise, it sends the content again with a
    `200 OK` status and updates the `ETag`. When this happens, the client knows that
    the existing cache is still warm and can be served without any changes to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can spin up the server by running `go run main.go` and from a different
    console, start making requests to it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the `ETag` header along with the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can make another request with the value of
  prefs: []
  type: TYPE_NORMAL
- en: 'the `ETag` in the `If-None-Match` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a `304 Not Modified` response with no body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In a real-life scenario, you’ll probably factor out the caching part in middleware
    so that all of your HTTP `GET` requests can be cached from the client-side without
    repetition.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to look out for[#](#one-thing-to-look-out-for)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While writing a cache-enabled server, make sure the system is set up so that
    the server always sends back the same `ETag` for the same content, even when there
    are multiple servers working behind a load balancer. If these servers give out
    different ETags for the same content, it can mess up how clients cache that content.
  prefs: []
  type: TYPE_NORMAL
- en: Clients use ETags to decide if content has changed. If the `ETag` value hasn’t
    changed, they know the content is the same and don’t download it again, saving
    bandwidth and speeding up access. But if ETags are inconsistent across servers,
    clients might download content they already have, wasting bandwidth and slowing
    things down.
  prefs: []
  type: TYPE_NORMAL
- en: This inconsistency also means servers end up dealing with more requests for
    content that clients could have just used from their cache if ETags were consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Recent posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Protobuffed contracts](https://rednafi.com/misc/protobuffed_contracts/)*   [TypeIs
    does what I thought TypeGuard would do in Python](https://rednafi.com/python/typeguard_vs_typeis/)*   [Crossing
    the CORS crossroad](https://rednafi.com/misc/crossing_the_cors_crossroad/)*   [Dysfunctional
    options pattern in Go](https://rednafi.com/go/dysfunctional_options_pattern/)*   [Einstellung
    effect](https://rednafi.com/zephyr/einstellung_effect/)*   [Strategy pattern in
    Go](https://rednafi.com/go/strategy_pattern/)*   [Anemic stack traces in Go](https://rednafi.com/go/anemic_stack_traces/)*   [Retry
    function in Go](https://rednafi.com/go/retry_function/)*   [Type assertion vs
    type switches in Go](https://rednafi.com/go/type_assertion_vs_type_switches/)*   [Patching
    pydantic settings in pytest](https://rednafi.com/python/patch_pydantic_settings_in_pytest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
