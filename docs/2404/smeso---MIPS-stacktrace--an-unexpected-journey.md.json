["```\n`#include  <link.h>\n#include  <sys/ucontext.h>\n\nstatic  inline  void  my_backtrace(ucontext_t*  c)\n{\n  unsigned  long  *ra;\n  unsigned  long  *fp;\n  unsigned  long  *sp;\n  size_t  ra_offset;\n  size_t  stack_size;\n  int  reached_start  =  0;\n  int  first_time  =  1;\n\n  pc  =  (unsigned  long*)(unsigned  long)c->uc_mcontext.pc;\n  ra  =  (unsigned  long*)(unsigned  long)c->uc_mcontext.gregs[31];\n  fp  =  (unsigned  long*)(unsigned  long)c->uc_mcontext.gregs[30];\n  sp  =  (unsigned  long*)(unsigned  long)c->uc_mcontext.gregs[29];\n  print(pc  -  1);\n  print(ra  -  1);\n\n  while  (!reached_start)  {\n  int  using_fp  =  0;\n  ra_offset  =  0;\n  stack_size  =  0;\n  for  (unsigned  long*  addr  =  ra;\n  (ra_offset  ==  0  ||  stack_size  ==  0)  &&  !reached_start;\n  --addr)  {\n  switch  (*addr  &  0xffff0000)  {\n  case  0x27bd0000:\n  // found addiu sp, sp, stack_size\n  stack_size  =  abs((short)(*addr  &  0xffff));\n  break;\n  case  0xafbf0000:\n  // found sw ra, ra_offset(sp)\n  ra_offset  =  (short)(*addr  &  0xffff);\n  break;\n  case  0x03a00000:\n  if  (0x03a0f000  ==  (*addr  &  0xffffff00))  {\n  // found pseudo instruction move fp, sp\n  using_fp  =  1;\n  }\n  break;\n  case  0x03e00000:\n  if  (0x03e00025  ==  *addr)  {\n  // found move zero,ra\n  // so we found the start\n  reached_start  =  1;\n  }\n  break;\n  default:\n  break;\n  }\n  }\n\n  if  (!ra_offset)  {\n  break;\n  }\n\n  if  (using_fp  &&  first_time)  {\n  sp  =  fp;\n  }\n  first_time  =  0;\n\n  ra  =  *(unsigned  long**)((unsigned  long)sp  +  ra_offset);\n  if  (using_fp)  {\n  sp  =  *(unsigned  long**)((unsigned  long)sp  +  ra_offset  -  4);\n  }  else  {\n  sp  =  (unsigned  long*)((unsigned  long)sp  +  stack_size);\n  }\n\n  print(ra  -  1);\n  }\n\n}` \n```", "```\n`struct  file_match  {\n  const  char  *file;\n  void  *address;\n  void  *base;\n};\n\nstatic  int\nfind_matching_file(struct  dl_phdr_info  *info,\n  size_t  size,\n  void  *data)\n{\n  struct  file_match  *match  =  data;\n  long  n;\n  const  ElfW(Phdr)  *phdr;\n  /*  This  code  is  modeled  from  Gfind_proc_info-lsb.c:callback()  from  libunwind  */\n  ElfW(Addr)  load_base  =  info->dlpi_addr;\n  phdr  =  info->dlpi_phdr;\n  for  (n  =  info->dlpi_phnum;  --n  >=  0;  phdr++)  {\n  if  (phdr->p_type  ==  PT_LOAD)  {\n  ElfW(Addr)  vaddr  =  phdr->p_vaddr  +  load_base;\n  if  (match->address  >=  vaddr  &&  match->address  <  vaddr  +  phdr->p_memsz)  {\n  match->file  =  info->dlpi_name;\n  match->base  =  info->dlpi_addr;\n  }\n  }\n  }\n  return  0;\n}\n\nstatic  inline  void\nsymbolize(const  char*  progname,  void*  addr)\n{\n  struct  file_match  match  =  {  .address  =  addr  };\n  dl_iterate_phdr(find_matching_file,  &match);\n  if  (match.file  &&  strlen(match.file))  {\n  fprintf(stderr,  \" %s(+%p)\\n\",  match.file,  addr  -  match.base);\n  }  else  {\n  fprintf(stderr,  \" %s\\n\",  progname);\n  }\n  fflush(stderr);\n}` \n```"]