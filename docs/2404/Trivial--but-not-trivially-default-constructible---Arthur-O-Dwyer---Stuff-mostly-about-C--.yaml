- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:02:07'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Trivial, but not trivially default constructible – Arthur O'Dwyer – Stuff mostly
    about C++
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://quuxplusone.github.io/blog/2024/04/02/trivial-but-not-default-constructible/](https://quuxplusone.github.io/blog/2024/04/02/trivial-but-not-default-constructible/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I just watched Jason Turner’s CppCon 2023 talk [“Great C++ `is_trivial`.”](https://www.youtube.com/watch?v=bpF1LKQBgBQ)
    Circa [41m00s](https://www.youtube.com/watch?v=bpF1LKQBgBQ&t=41m) he picks on
    the wording of [[class.prop]/2](https://eel.is/c++draft/class.prop#def:class,trivial):'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: A **trivial class** is a class that is trivially copyable and has one or more
    eligible default constructors, all of which are trivial.
  id: totrans-split-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “That phrasing’s always bothered me. How can you have more than one default
    constructor? They could be constrained by `requires`-clauses… but then not more
    than one of them is [eligible](https://eel.is/c++draft/special#def:special_member_function,eligible).”
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the trick: Jason, you were wrongly assuming that a trivial class must
    be default-constructible at all! [Godbolt](https://godbolt.org/z/EGjb17of3):'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-10
  prefs: []
  type: TYPE_PRE
- en: Here `S<int>` is trivial, but, because it has *two* eligible default constructors,
    any attempt to default-construct an `S<int>` will fail due to overload resolution
    ambiguity. Thus `S<int>` is not default-constructible at all (and certainly not
    *trivially* default-constructible); but it still satisfies all the requirements
    of a *trivial class*.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, it seems to me that Jason buries the lede when it comes to actually
    explaining triviality. The rule is: A type `T` is *trivially fooable* if and only
    if its *foo* operation is (known to the compiler to be) equivalent to the same
    *foo* operation on `T`’s object representation (i.e., an array of `unsigned char`).
    `T` is trivially copy-constructible if its copy constructor merely copies its
    bytes; it’s trivially default-constructible if its default constructor merely
    default-initializes its bytes (recall that default-initializing an array of `unsigned
    char` is a no-op); it’s trivially value-initializable (see [“PSA: Value-initialization
    is not merely default-construction”](/blog/2023/06/22/psa-value-initialization/)
    (2023-06-22)) if its value initialization merely value-initializes its bytes (to
    zero); and so on. *That’s* the big thing to remember about the adverb “trivially”
    — it means “as if on the object representation.”'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
