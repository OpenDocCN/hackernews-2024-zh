<!--yml

category: 未分类

date: 2024-05-27 12:48:44

-->

# 不要那么快，傅立叶先生！ - lcamtuf 的观点

> 来源：[https://lcamtuf.substack.com/p/not-so-fast-mr-fourier](https://lcamtuf.substack.com/p/not-so-fast-mr-fourier)

离散傅立叶变换（DFT）是现代计算中最重要的算法之一：在通信、图像和音频处理、机器学习、数据压缩等领域中起着关键作用。有趣的是，它也是计算机科学中解释最差的主题之一。例如，维基百科上的相关文章用大约三十多个神秘的公式攻击读者，却没有提供可访问的解释说明这个算法如何工作或为何工作。

我今天的目标是改变这一点。让我们从基础知识开始：DFT将时域波形（例如音频轨道）转换为频域数据：一系列描述基础信号的正弦波强度。如果将这些不同频率、相位和幅度的正弦波再次相加，应该可以忠实地重新创建原始波形。

为了说明DFT的实用性，让我们来看看传统波形表示的[🔈 警笛声](https://lcamtuf.coredump.cx/police.mp3)与其频域处理的对比。在两个图中，水平轴表示时间。在底部图像中，垂直轴表示频率，像素颜色表示强度。顶部视图告诉我们关于录音的信息很少；在底部图中，警笛的音调变化很容易看到，以其基频和[一些谐波](https://lcamtuf.substack.com/p/square-waves-or-non-elephant-biology)为特征：

*警笛声：时域与频域的对比*

严格来说，底图——称为频谱图——不是单一DFT操作的结果；变换不显示频率随时间的变化。相反，频谱图是通过将音频分成多个短时段，并为每个短时段计算单独的频域表示来创建的，每个短时段在绘图中形成一列。有时这被称为*短时傅立叶变换*（STFT）；尽管如此，这种不同的术语对结果没有实质性影响，因为其基础数学是相同的。

无论哪种方式，信号的频域表示允许我们执行各种有趣的技巧。例如，对于音乐，我们可以轻松地分离特定乐器，去除不需要的交流嗡嗡声，或者改变人声的音高。完成编辑后，我们可以将数据转换回时域波形。确实，某些流行歌手利用的臭名昭著的Auto-Tune音高修正器，是DFT的众多应用之一。

为了把这个问题摆平，让我们从官方公式开始——对于外行来说，这相当晦涩：

\(F_k = \sum\limits_{n=0}^{N-1} s_n \cdot e^{-i 2 \pi k\frac{n}{N} }\)

在这个方程中，*F[k]*是特定频率箱的DFT值（“系数”）。箱号是与输入采样率对应的整数。继续向前，*s[0]*到*s[N-1]*是构成DFT输入窗口的时域样本；其余的是……一些巫术？

为了理解这种巫术，让我们进行一个简单的思想实验。想象一个以恒定角速度旋转的机械臂。臂上握着一支笔，笔与一张绘画纸接触。笔根据输入波形沿臂的长度上下移动。

假设臂每秒完成一次旋转，输入信号是运行三倍速（3 Hz）的正弦波。在这种设置下，笔将每次转动都画出一个整齐居中的三叶形状：

*角速度为1转每秒的3 Hz信号的极坐标图。*

如果您愿意，您可以在下面观看动画版本：

在某些情况下——例如，如果信号的频率低于旋转臂的旋转频率——可能需要多次旋转才能产生一个闭合形状。但结果应该是类似的；例如，这是一个绘制于0.9 Hz信号的漂亮的九叶图案：

*角速度为1转每秒的0.9 Hz极坐标图（多次转动）。*

再次，您可以在下面观看动画：

这种径向对称性在除了一个特殊情况外的每次出现：当旋转臂的速度与正弦波形的周期匹配时。在这种情况下，波形的峰始终在图的一侧，而谷始终在另一侧。

*1 Hz信号@ 1转/秒。*

根据输入波形的相位，形状可能会旋转，但一侧始终突出。

奇迹般地，这也适用于由叠加正弦波组成的复合信号。例如，如果我们取一个1 + 5 Hz信号，当以1 Hz或5 Hz旋转的臂绘制时会偏离中心，但在2 Hz处会显得居中：

*解构复合信号。*

换句话说，我们有一个相当巧妙的*频率检测器：*我们设置旋转臂的速度，绘制样本——如果结果在（0,0）周围不均匀分布，我们知道输入信号中存在匹配的正弦频率分量。通过测量形状偏离旋转中心的偏差，我们甚至可以量化该分量的幅度。

离散傅里叶变换归结为这个确切的操作。它接受输入窗口中的 *N* 个值的序列，并在给定速度下将它们径向分布在二维空间中，完成 *k* 次旋转。然后对生成的坐标（∑ 部分）求和。从旋转中心到计算中点的距离是计算频率分量的幅度；向量的角度是波形的（有时被忽略的）相位。请注意，一些在线资源，包括一个极其流行的YouTube视频，错误地声明 *x* 轴分量是幅度；这是不正确的。

这种算法可以用极坐标 — 角度和距离 — 实现，模仿我们上面所做的。它可以用笛卡尔 *x,y* 坐标对和简单的三角法完成。在本节开始引用的定义中，它用一种最晦涩的方式实现 — 通过一个称为 [欧拉公式](https://en.wikipedia.org/wiki/Euler%27s_formula) 的奇特设备 — 但所有方法都是等效的。*e^(-i2πkn/N)* 部分仅仅是通过利用这个惊人的相等性在复平面中旋转事物的装置：

\(e^{it} = cos \ t + i \cdot sin \ t\)

如果你对复数不熟悉，*i* 部分（*i = √-1*）本质上是一个数学技巧，用于在单个方程中保持两个值的距离。为了避免它，DFT公式可以使用一对分离的笛卡尔坐标 — （*x, y*）进行重写：

\(F_k =\Biggl ( { \sum\limits_{n=0}^{N-1} s_n \cdot cos ( 2 \pi k \frac{n}{N} )}, \ - { \sum\limits_{n=0}^{N-1} s_n \cdot sin( 2 \pi k \frac{n}{N} )} \Biggl )\)

这种表示法应该更容易解析：*2π* 部分等同于以弧度表示的360°；*k* 是我们想要在样本中使用的转数；而 *n/N* 确定了每个样本在这些 *k* 转中的位置。同时，*x = cos(t)* 和 *y = sin(t)* 只是绘制圆的方法。

DFT的基本实现很简单；例如，在C中，你只需以下代码：

> ```
> void dft(complex* out_buf, complex* in_buf, uint32_t len) {
> 
>   for (uint32_t bin_no = 0; bin_no < len; bin_no++) {
>     complex sum = 0;
>     for (uint32_t s_no = 0; s_no < len; s_no++)
>       sum += in_buf[s_no] * cexp(-2 * I * M_PI * bin_no * s_no / len);
>     out_buf[bin_no] = sum;
>   }
> 
> }
> ```

代码接受和输出复数；对于实数输入，*in_buf* 可以改为 *double**。要将结果的复数系数转换为幅度，调用 *cabs()*。要获取相位信息（以弧度表示），使用 *carg()*。

以最大频率范围开始。如果输入数据由实数组成，DFT仅在所谓的奈奎斯特频率上产生有用的输出 — 即采样率的一半。此频率成分可在*k = N/2*的箱中找到。那些系数可以计算，有时需要计算 — 但或许有些令人惊讶，它们只包含从较低频率箱中镜像的数据。

要理解为什么会发生这种情况，请考虑我们旋转臂的以下动画。在视频中，臂的旋转速度相对于输入采样率非常快，以至于连续的样本间隔超过了180°。实际上，角距离为330°，这表明我们以接近输入采样率的约92%运行DFT：

观看视频后，应该清楚，最终结果与由一个转速较慢的臂在相反方向旋转所产生的结果相同。

系数镜像行为是DFT算法的一个副作用，但是奈奎斯特频率本身并不是。这是信号采样技术的基本带宽限制：在其上方，没有足够的样本可靠地分辨频率。奈奎斯特限制是音乐通常以约44千赫录制的原因，即使我们的听觉只能达到大约20千赫（而且只是在好的情况下）。

DFT的另一个限制与频率分离有关。一个能够使用无限长样本窗口的离散傅里叶变换将具有完美的选择性 — 也就是说，它将能够精确地区分所选择的频率，同时排斥其他一切。实际上，DFT在有限的样本窗口上运行，导致每个频段捕捉到额外的东西。

要理解原因，让我们假设我们正在进行DFT，每隔三赫兹一个频段 — 即，*F[0]* 是直流分量，*F[1]* 是3赫兹，*F[2]* 是6赫兹。 *F[1]* 频段总是通过完成单个转动计算得出（时间表达式为 *k × 2π*，*k = 1*）。但是，对于输入信号频率为2赫兹，我们需要三次转动才能形成一个闭合形状。然而，我们时间不够 — 并且在绘制了一个偏离中心的波形后，我们的输入样本也不够用：

*DFT的限制：一个靠近F[1]频段的附近频率渗入。*

实际上，只有两个频率非常接近时，绘图才会严重偏离中心。为了说明这一点，这是我们在一系列输入信号中的3赫兹 *F[1]* 频段的动画。观察计算出的蓝点，它跟踪形状的“重心” — 因此镜像了结果的DFT系数。

事实证明，在大约每个频段步长的正负75%内，偏差非常显著。在较低频率下，部分形状非常接近圆形；在更高的信号率下，它具有足够对称的波瓣，缺失部分不会对平衡产生太大影响。

我们可以更严格地测量这一点。以下图显示了几个1赫兹间隔频段所有可能信号相位的平均频率响应：

*真实世界的DFT频段响应。*

重叠意味着标准的 DFT bin 集合最终占据了从 DC 到 Nyquist 的整个频谱。没有什么能阻止我们为任何非整数*k*计算特定的 ad-hoc DFT 系数，但这些“部分旋转” bin 并不从系统中提取任何新的、更精细的信息。如果需要更好的频率区分能力，必须增加窗口大小。

这将带我们到时间分辨率。单个 DFT 操作为整个输入波形输出频率系数 —— 仅此而已。在它所覆盖的时间段内，我们不再容易确定特定音调的起始或结束时间，或者它的强度是上升还是下降。确实，在波形中的尖锐信号不连续性会产生难以解释为任何特定频率的广谱“光晕”。时间域信号越局部化，其频域图像就越模糊。

这就是为什么声谱图将信号分成短时间片段，并为每个片段计算单独的变换，而不是为整个缓冲区执行一个 DFT。但是这些片段不能任意短：至少，您必须使用足够大的窗口，使得底部频率*F[1]*与您希望分辨的最低频率对齐。举例说明，如果您有一个 44.1 kHz 的音频流，并且想要测量到 20 Hz，那么您需要每个 DFT 使用 2,205 个样本的窗口，即 50 毫秒的跨度。

在 50 毫秒内发生了很多事情；因此，为了在某些应用程序中获得可接受的时间分辨率，可能需要采取各种变通方法，如使用重叠窗口、加权采样或专门的混淆方法。音频处理往往是其中之一。

离散傅里叶逆变换在概念上很简单。它归结为为以前计算过的每个频率 bin 生成波形，根据 DFT 产生的*F[k]*系数调整它们的幅度和相位，然后将结果相加以重新创建时间域样本窗口(*s[0]* 到 *s[N-1]*)的内容。

这里是执行此操作的 IDFT 公式：

\(s_n = \frac{1}{N} { \sum\limits_{k=0}^{N-1} F_k \cdot e^{i{{2 \pi n \frac{k}{N} }}} } \)

请注意，这个方程与前向 DFT 公式非常相似。在算法的核心，输入和输出之间存在重要的对称性；这被称为*正交性*。在某种略带令人费解的意义上，频域只是时间域被“里外颠倒”。

这里是 C 语言中简单的 IDFT 实现：

> ```
> void idft(complex* out_buf, complex* in_buf, uint32_t len) {
> 
>   for (uint32_t s_no = 0; s_no < len; s_no++) {
>     complex sum = 0;
>     for (uint32_t bin_no = 0; bin_no < len; bin_no++)
>       sum += in_buf[bin_no] * cexp(2 * I * M_PI * s_no * bin_no / len);
>     out_buf[s_no] = sum / len;
>   }
> 
> }
> ```

就像之前一样，如果处理实数信号，*out_buf* 可以声明为*double**。

值得注意的是，前向 DFT 后接 IDFT 是无损的 — 即，它会得到与开始时相同的时间域数据。在实践中，需要注意浮点运算的精度，以避免累积误差，但这通常不是一个大问题。

DFT是完全适合的，除了一个微小的问题：即使我们预先计算了指数部分，算法仍然涉及*K × N*复数乘法。因为计算的箱数*K*通常与窗口大小*N*相同，一些对计算复杂度的迷恋的计算机科学爱好者将DFT的计算复杂度描述为*O(n²)*。

这就是快速傅里叶变换（FFT）发挥作用的地方；FFT仍然是离散傅里叶变换，它产生相同的结果，但计算被巧妙地优化，适用于大输入窗口和*K = N*用例（该算法不能选择性地计算仅一些频率分箱）。

性能提升归功于一种称为[radix-2 Cooley-Tukey算法](https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm)的技术。这种优化的推导有点复杂，但在高层次上，它涉及将完整的DFT计算迭代地拆分成更小的子和，然后利用*e^(-i2)*^π*^(kn/N)*表达式的周期性 —— 它确实是圆形的！ —— 来因式分解许多冗余的乘法。对于更大的窗口，FFT的结果复杂度接近*O(n ⋅ log₂ n)*，这是一个相当大的改进。

几乎每种编程语言都存在多种参考FFT实现，[Fast Fourier Transform](https://rosettacode.org/wiki/Fast_Fourier_transform)；对于二的幂窗口大小，一种特别简洁、极简的C语言实现如下所示：

> ```
> void __fft_int(complex* buf, complex* tmp, 
>                const uint32_t len, const uint32_t step) {
> 
>   if (step >= len) return;
>   __fft_int(tmp, buf, len, step * 2);
>   __fft_int(tmp + step, buf + step, len, step * 2);
> 
>   for (uint32_t pos = 0; pos < len; pos += 2 * step) {
>     complex t = cexp(-I * M_PI * pos / len) * tmp[pos + step];
>     buf[pos / 2] = tmp[pos] + t;
>     buf[(pos + len) / 2] = tmp[pos] - t;
>   }
> 
> }
> 
> void in_place_fft(complex* buf, const uint32_t len) {
>   complex tmp[len];
>   memcpy(tmp, buf, sizeof(tmp));
>   __fft_int(buf, tmp, len, 1);
> }
> ```

将这段代码转换为反FFT（IFFT）可以简化为移除*cexp(...)*表达式中的负号，并将最终值除以*len*。

同样，在实际应用中，预计算复数指数部分的结果是明智的；该值仅取决于*pos*索引和选择的窗口大小。

离散余弦变换可以被看作是离散傅里叶变换的一个部分、仅限于实数版本。就像离散傅里叶变换一样，它将时域样本转换为频谱。而且与离散傅里叶变换一样，它通过乘以余弦波形的输入数据然后将结果求和来获得一堆分箱系数。

尽管如此，这种描述还有些不足；这个算法与离散傅里叶变换在一些有趣的方面有所不同。首先，让我们来看看DCT-II的常见公式，这是DCT的最常见变体：

\(F_k = \sum\limits_{n=0}^{N-1} s_n \cdot cos ( \pi k { n + \frac12 \over N} )\)

如果你回到DFT方程，你可能会注意到在上面的公式中，*k* 被π（180°）而不是2π（360°）相乘。实际上，波形生成部分使用交替模式的完整转向和部分转向频率区间，运行在DFT频率的一半，并将F[N-1]放在奈奎斯特极限处。这种变化不仅仅是为了更高效：如果你尝试将时间表达式切换回 *2π*，整个算法就会偏离轨道，许多频率区间开始读取零。接下来，我们将讨论原因。

另一个新元素是时间表达式中的 *+½* 偏移量。请记住，样本编号从 *n = 0* 到 *N - 1*，因此将 *n* 除以 *N* 留下范围上端的间隙。+*½* 的偏移将波形置于中心位置；这种对称性对于使逆函数工作非常重要。离散傅里叶变换不使用这种方式，因为它的对称性来自于复平面中余弦和正弦的更基本关系。

常见的逆DCT-II（IDCT-II）公式为：

\(s_n = \frac{1}{N} \sum\limits_{k=0}^{N-1} F_k \cdot w_k \cdot cos [ \pi (n + \frac12) {k \over N} ]\)

*w[k]* 值为DC频率区间（*k = 0*）为 *1*，而所有后续的部分转向频率区间（*k > 0*）为 *2*。你可能会遇到变体，将 *w[k]* 和缩放因子（*1/N*）放在正向DCT公式中；一些作者在DCT和IDCT之间分割因子。这些变化导致了不同比例的系数，但整体操作是相同的。

现在，让我们来检验离散余弦变换的基本机制。假设我们正在处理以2 kHz采样的一秒数据。使用DFT，我们在达到奈奎斯特极限（1 kHz）之前得到N / 2 = 1,000个可用的频率区间；频率区间间隔为1 Hz。使用余弦变换，我们得到N = 2,000个频率区间，表示从DC到奈奎斯特的0.5 Hz增量。

让我们选取4 Hz频率区间（*F[8]*）。首先，考虑一下如果我们分析的输入信号运行在8 Hz时会发生什么。图像显示了频率区间4 Hz的参考波形（蓝色），接着是输入频率（绿色），然后是两者的乘积（红色）。乘积以*x*轴为中心，所以DCT系数为零：

*DCT：不匹配的频率。*

但是如果频率（和相位）匹配会怎么样？在下面的图中，我们仍然在看*F[8]*频率区间，但是输入信号现在与4 Hz对齐。乘积总是涉及两个正值或两个负值，所以乘积波形现在有一个正的总和：

*匹配频率和相位时的DCT行为。*

如果信号的相位偏移半个周期（180°），离散余弦变换仍然有效 —— 只是读数是负数。

鉴于这里观察到的行为，人们可能会想知道为什么我们要参与所有与真实 DFT 相关的复数手法。如果我们考虑 90° 或 270° 的相位偏移（波长的四分之一或四分之三），答案显而易见。在这种情况下，任何可检测到的乘积波形偏移都会简单消失，*F[8]* 系数尽管存在匹配的信号频率却为零：

*DCT 第 8 个频段的相位错位问题。*

原始傅里叶变换在处理这种情况时没有问题；在 90° 时，DFT 向量指向上，信号的大小仅由虚部（即 *y* 坐标）表示。相比之下，在离散余弦变换中，虚部不存在，我们在预期的频段中没有任何注册。

此时，你可能会想知道是否可以简单地丢失不对齐的信号。答案是否定的 — DCT 的妙处在于，不相位的数据最终会出现在附近的“部分转动”频段中，这在正常的 DFT 中是不计算的。继续我们的相位偏移为 4 Hz 的问题信号特征，让我们看看下一个频段 — *F[9]* 在 4.5 Hz：

*DCT 部分转动频段正在发挥作用。*

如果你从局部视角来看，信号在开始时出现了 90° 的相位偏移；在中间似乎突然恢复了相位；然后在结尾处又出现了 -90° 的相位偏移。在这个“部分转动”频段的测量窗口内，平均乘积为正。如果我们进入下一个“完整转动”频段（5 Hz），波形的乘积再次变为零。

换句话说，DCT 频段编码了幅度 **和** 相位信息，只是不总是在我们期望的地方。这解释了为什么变换需要两倍的频段 — 以及为什么试图增加它们的间距以匹配 DFT 会破坏算法。

这种混乱的编码方案使得离散余弦变换对于大多数信号分析任务而言是一个相当差的工具。尽管如此，它对于快速、空间高效的压缩算法非常有用，在频域表示的美学不那么重要的情况下尤为如此。一个经典的例子就是 JPEG 图像格式，它对 8×8 像素块进行 DCT，然后对计算出的系数进行量化（即降低精度），以便使用传统的无损压缩（哈夫曼编码）更容易地压缩。

哦，如果你希望尝试 DCT-II，下面包含了一个简单的实现：

> ```
> `void dct(double* out_buf, double* in_buf, uint32_t len) {
> 
>   for (uint32_t bin_no = 0; bin_no < len; bin_no++) {
>     double sum = 0;
>     for (uint32_t s_no = 0; s_no < len; s_no++)
>       sum += in_buf[s_no] * cos(M_PI * bin_no * (s_no + 0.5) / len);
>     out_buf[bin_no] = sum;
>   }
> 
> }
> 
> void idct(double* out_buf, double* in_buf, uint32_t len) {
> 
>   for (uint32_t s_no = 0; s_no < len; s_no++) {
>     double sum = 0;
>     for (uint32_t bin_no = 0; bin_no < len; bin_no++)
>       sum += in_buf[bin_no] * cos(M_PI * (s_no + 0.5) * bin_no / len) *
>              (bin_no ? 2 : 1);
>     out_buf[s_no] = sum / len;
>   }
> 
> }`
> ```

想看一个荒谬但有趣的演示？看看 [这篇文章](https://lcamtuf.substack.com/p/afternoon-project-jpeg-dct-text-lossifizer)，让你了解如果将文本应用 JPEG 风格的有损压缩会发生什么。

*
