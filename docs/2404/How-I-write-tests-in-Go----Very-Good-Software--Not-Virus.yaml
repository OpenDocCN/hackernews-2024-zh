- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:04:55'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'How I write tests in Go :: Very Good Software, Not Virus'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://blog.verygoodsoftwarenotvirus.ru/posts/testing-in-go/](https://blog.verygoodsoftwarenotvirus.ru/posts/testing-in-go/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How I write unit tests in Go[‚åó](#how-i-write-unit-tests-in-go)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of my favorite features of Go is that unlike many popular languages, it
    comes with it‚Äôs own testing framework, the [testing](https://pkg.go.dev/testing)
    package. Let‚Äôs say we have this trivial function in a file called `numbers.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The idiomatic way to test this function is to create a second file called `numbers_test.go`
    and test it using the aforementioned `testing` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then I can run `go test` and see the output of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if the test fails (i.e. if I expect the result to be 11 instead),
    I get an appropriate error report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This works pretty well, overall. When I need to find the tests for a given file,
    I can usually assume they‚Äôre in its corresponding `_test.go` file. The `testing`
    framework is built into the standard library, and does exactly what you‚Äôd expect
    with this code.
  prefs: []
  type: TYPE_NORMAL
- en: We have the technology[‚åó](#we-have-the-technology)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This isn‚Äôt how I actually like to write Go unit tests, however. There are techniques
    and libraries I use to make unit testing in Go more effective to write and understand
    when things go (heh) awry.
  prefs: []
  type: TYPE_NORMAL
- en: The test command[‚åó](#the-test-command)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can run `go test` in a given directory and see the output of your test,
    but that leaves a lot of functionality on the table that can and will be useful.
    The full command I typically use is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go test -cover -shuffle=on -race -vet=all -failfast <$RELEVANT_PACKAGE(S)>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs what each of these flags do:'
  prefs: []
  type: TYPE_NORMAL
- en: Table-driven tests[‚åó](#table-driven-tests)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I‚Äôm going to say something sort of controversial in the Go zeitgeist: I find
    table tests very rarely useful. For something like our `addNumbers` function,
    I might actually do it, because the inputs and outputs are simple. Here‚Äôs what
    that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That said, it‚Äôs pretty easy to end up in a situation where your table tests
    need to be quite complicated and gnarly to get full coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Goland lets you generate tests for functions using a default template that
    attempts to adhere to the tradition of table-driven tests. Here‚Äôs what the generated
    test function looks like for a method in a side project. This method fetches a
    webhook object from the database, and accepts 3 total parameters ‚Äî a context,
    a webhook ID, and an accountID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I think this is kind of a mess, and it doesn‚Äôt even include test cases yet.
    I‚Äôd rather have the querier built by an only-available-to-tests constructor that
    puts sensible defaults for all these values.
  prefs: []
  type: TYPE_NORMAL
- en: The point of this is not to dunk on Goland (I am a happily paying customer and
    have been for many years), it‚Äôs just to illustrate how even a non-trivial function
    can really blow up the readability of a table-driven test.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel[‚åó](#parallel)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go tests can be run in parallel, by declaring the test as parallel in the top
    level. This behavior is on by default, and can only be disabled by setting the
    `-parallel=1` flag when invoking `go test` (which can be useful when debugging
    flaky tests).
  prefs: []
  type: TYPE_NORMAL
- en: I‚Äôm of the opinion that tests should be parallel unless they absolutely cannot
    be, and even then, I‚Äôd rather fix the flaw behind why they can‚Äôt be run in parallel
    than force them to be run sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running your tests in parallel generally allows you to suss out concurrency
    bugs earlier, even if you‚Äôre not using the race detector (which you should), and
    will eventually lead to you developing concurrency-safe habits when writing code
    in the first place. So generally, when I write a test, the very first line is
    the parallel declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Subtests[‚åó](#subtests)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subtests are a feature of Go‚Äôs testing library that allow you to have smaller
    tests for specific circumstances. These allow you to get some of the benefits
    of a behavior-driven testing style, without having to invoke an external dependency.
    I usually write subtests even when there‚Äôs only one test case I care about, because
    it incurs no real overhead to do so, and allows you to easily test a new case
    in the event the tested function gets more complex.
  prefs: []
  type: TYPE_NORMAL
- en: When I write subtests, I usually name the top-level `*testing.T` object a capitalized
    `T`, and use the conventional lower-cased `t` for subtests only. This way, the
    subtest logic always looks like an idiomatic Go test, and there‚Äôs no confusion
    of what variable is which or what shadows what. Calls to `.Parallel()` will have
    to be made for both the big and little `*T` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs a demonstration that adapts our earlier example for the `addNumbers`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if I decide to add another test case, it‚Äôs simply a matter of copying the
    subtest block, changing the name, and then making the test match that description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, if there are test fixtures or constants that are relevant to all
    subtests, they can live in the space between the big-T call to `.Parallel()` and
    the first declared subtest.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries[‚åó](#libraries)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the standard library testing package is pretty great, there have been
    some great contributions by the community to the ecosystem that make testing in
    Go even better.
  prefs: []
  type: TYPE_NORMAL
- en: Fake Values[‚åó](#fake-values)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, when I need to interact with an object in a test, I want to have
    unpredictable values to the extent possible for that object, so that I‚Äôm discouraged
    from relying on those conventions when writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: So for instance, if I need a `*User` object for a test, I want to have no idea
    what it‚Äôs username might be, as opposed to a common static value that I might
    copy/paste from place to place, which would make many tests fail if it was inadvertently
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'I like to use [brianvoe/gofakeit](https://pkg.go.dev/github.com/brianvoe/gofakeit/v7)
    for this. It comes with a ton of sensible functions with which to build fake instances
    of different types, and I‚Äôve never had a problem with it. Here‚Äôs what that fake
    user builder might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Testify[‚åó](#testify)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I‚Äôm a huge fan of the `(assert|require|mock)` libraries in [testify](https://github.com/stretchr/testify).
    In our example test, using testify would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I think `assert.Equal` is fairly obvious in its function for users who are new
    to a code base. `testify` is probably the only library I can think of that I would
    wholeheartedly support being absorbed into the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `require` instead if you want the test to stop in the event of
    a failure. This is usually good for dependencies of a test, i.e. if I need to
    create a file and pass it to a function, I should probably `require` that no errors
    happen when creating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`mock` is also useful for defining mock implementations of structures. Say
    I have the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing a mock for this interface becomes a matter of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the above mock in a test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I won‚Äôt lie, I‚Äôm not deeply impressed with the way that `mock.Mock` determines
    which variables to return in what order, and when things go wrong (i.e. you copy
    and paste something in the wrong order or have the wrong indices on your return
    values) it‚Äôs VERY hard to suss out, but by and large, `testify/mock` does an incredible
    job of what it needs to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can avoid having to put `mock.Anything` in an expectation call by writing
    a type matcher. For `context.Context`, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There‚Äôs also `testify/suite`, which I *have* used, but wouldn‚Äôt recommend. It‚Äôs
    useful when you have a ton of common prerequisites for tests that need to be spun
    up ahead of time, but I still think it makes more sense to just make those prerequisites
    the product of a common function, instead of writing non-standard test code.
  prefs: []
  type: TYPE_NORMAL
- en: Testcontainers[‚åó](#testcontainers)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a neat tool I‚Äôve only recently started using, but to great effect. It‚Äôs
    very common to have to write code that interfaces with a database, or a k/v store,
    or an in-memory cache, but before [testcontainers](https://testcontainers.com/),
    you either had to write a suite of integration tests that used that code to verify
    it did what you wanted, or otherwise fly blind in production. With testcontainers,
    I can spin up ephemeral containers that run a given piece of software and have
    my code interact with that to verify functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it‚Äôs not perfect. These tests generally run great on my machine,
    and in Github Actions, but you must remember that you‚Äôre asking your computer
    to make a fake computer within itself, spin up a piece of software on that fake
    computer, and handle all the networking shenanigans that go along with interfacing
    with it, so there‚Äôs plenty of opportunity for mishaps and errors to occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes a testcontainer invocation will just fail, and the reason behind
    it can be summarized up as: computers are hard. Since they can be a big more error
    prone than standard tests, I don‚Äôt typically write subtests for these. Instead,
    I tend to write one big function that uses a single instance of the container
    to test a bunch of related functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs an example of the test for that aforementioned webhook retrieval function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: (I acknowledge that this code is missing some function definitions, but it‚Äôs
    meant for you to get an idea, not copy/paste)
  prefs: []
  type: TYPE_NORMAL
- en: Failure Cases[‚åó](#failure-cases)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some functions in the Go standard library return errors that you might surface
    to higher-level call sites, but in order to test that those errors are caught
    and returned, Here are some ways I manage to achieve failures for very specific
    circumstances in Go.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Encoding[‚åó](#json-encoding)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It‚Äôs a pretty common operation in Go code to take an instance of a given struct
    and render it as JSON. This function is capable of returning an error in the event
    the source struct is unrepresentable, but it‚Äôs actually pretty hard to make a
    struct unrepresentable in Go. You basically have to do it on purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way I achieve this is by using [`json.Number`](https://pkg.go.dev/encoding/json#Number),
    a string alias meant to represent numbers, and giving it a non-numerical value.
    Here‚Äôs what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: URL Parsing[‚åó](#url-parsing)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Parsing a URL in Go [returns an error](https://pkg.go.dev/net/url#Parse), but
    trying to force this error to occur was very confusing to me. I had to dive into
    the actual test cases in the standard library for [`net/url`](https://pkg.go.dev/net/url).
    Here are some inputs you might think return an error from `url.Parse`, but actually
    don‚Äôt:'
  prefs: []
  type: TYPE_NORMAL
- en: an empty string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a URL with double dots in the path (i.e. `https://google.com/../../var/data`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: just a scheme (i.e. `https://`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a URL with emojis in it (i.e. `https://üòò.üî•`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a URL with an invalid scheme (i.e. `farts://`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these actually don‚Äôt return an error. The only way I was able to force
    it to occur by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For whatever reason, this causes `url.Parse` to fail.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion[‚åó](#conclusion)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many other languages, you have to not only evaluate testing libraries, but
    also write your tests in a style that complies with that library‚Äôs expectations.
    Gophers are blessed to have a thoroughly adequate solution out-of-the-box, and
    even further blessed to have an active ecosystem where folks are making in-depth
    testing a walk in the park.
  prefs: []
  type: TYPE_NORMAL
