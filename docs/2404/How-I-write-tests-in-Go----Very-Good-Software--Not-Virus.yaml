- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ç±»ï¼šæœªåˆ†ç±»
- en: 'date: 2024-05-27 13:04:55'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024-05-27 13:04:55
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'How I write tests in Go :: Very Good Software, Not Virus'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'å¦‚ä½•åœ¨Goä¸­ç¼–å†™æµ‹è¯• :: éå¸¸å¥½çš„è½¯ä»¶ï¼Œä¸æ˜¯ç—…æ¯’'
- en: æ¥æºï¼š[https://blog.verygoodsoftwarenotvirus.ru/posts/testing-in-go/](https://blog.verygoodsoftwarenotvirus.ru/posts/testing-in-go/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://blog.verygoodsoftwarenotvirus.ru/posts/testing-in-go/](https://blog.verygoodsoftwarenotvirus.ru/posts/testing-in-go/)
- en: How I write unit tests in Go[âŒ—](#how-i-write-unit-tests-in-go)
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å¦‚ä½•åœ¨Goä¸­ç¼–å†™å•å…ƒæµ‹è¯•[âŒ—](#how-i-write-unit-tests-in-go)
- en: 'One of my favorite features of Go is that unlike many popular languages, it
    comes with itâ€™s own testing framework, the [testing](https://pkg.go.dev/testing)
    package. Letâ€™s say we have this trivial function in a file called `numbers.go`:'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Goä¸­ï¼Œæˆ‘æœ€å–œæ¬¢çš„åŠŸèƒ½ä¹‹ä¸€æ˜¯ï¼Œä¸è®¸å¤šæµè¡Œè¯­è¨€ä¸åŒï¼Œå®ƒè‡ªå¸¦äº†è‡ªå·±çš„æµ‹è¯•æ¡†æ¶ï¼Œå³[testing](https://pkg.go.dev/testing)åŒ…ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåœ¨åä¸º`numbers.go`çš„æ–‡ä»¶ä¸­çš„å¾®ä¸è¶³é“çš„å‡½æ•°ï¼š
- en: '[PRE0]'
  id: totrans-split-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The idiomatic way to test this function is to create a second file called `numbers_test.go`
    and test it using the aforementioned `testing` package:'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: æµ‹è¯•æ­¤å‡½æ•°çš„æƒ¯ç”¨æ–¹æ³•æ˜¯åˆ›å»ºä¸€ä¸ªåä¸º`numbers_test.go`çš„ç¬¬äºŒä¸ªæ–‡ä»¶ï¼Œå¹¶ä½¿ç”¨ä¸Šè¿°`testing`åŒ…å¯¹å…¶è¿›è¡Œæµ‹è¯•ï¼š
- en: '[PRE1]'
  id: totrans-split-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then I can run `go test` and see the output of the test:'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘å¯ä»¥è¿è¡Œ`go test`å¹¶æŸ¥çœ‹æµ‹è¯•çš„è¾“å‡ºï¼š
- en: '[PRE2]'
  id: totrans-split-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, if the test fails (i.e. if I expect the result to be 11 instead),
    I get an appropriate error report:'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œå¦‚æœæµ‹è¯•å¤±è´¥ï¼ˆå³æˆ‘æœŸæœ›çš„ç»“æœæ˜¯11ï¼‰ï¼Œæˆ‘ä¼šå¾—åˆ°ä¸€ä¸ªåˆé€‚çš„é”™è¯¯æŠ¥å‘Šï¼š
- en: '[PRE3]'
  id: totrans-split-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This works pretty well, overall. When I need to find the tests for a given file,
    I can usually assume theyâ€™re in its corresponding `_test.go` file. The `testing`
    framework is built into the standard library, and does exactly what youâ€™d expect
    with this code.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ä½“è€Œè¨€ï¼Œè¿™æ–¹æ³•è¿è¡Œå¾—ç›¸å½“ä¸é”™ã€‚å½“æˆ‘éœ€è¦æ‰¾åˆ°ç‰¹å®šæ–‡ä»¶çš„æµ‹è¯•æ—¶ï¼Œé€šå¸¸å¯ä»¥å‡è®¾å®ƒä»¬ä½äºç›¸åº”çš„ `_test.go` æ–‡ä»¶ä¸­ã€‚`testing` æ¡†æ¶å†…ç½®äºæ ‡å‡†åº“ä¸­ï¼Œå¯¹è¿™æ®µä»£ç çš„å¤„ç†æ­£æ˜¯ä½ æ‰€æœŸå¾…çš„ã€‚
- en: We have the technology[âŒ—](#we-have-the-technology)
  id: totrans-split-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ‹¥æœ‰æŠ€æœ¯[âŒ—](#we-have-the-technology)
- en: This isnâ€™t how I actually like to write Go unit tests, however. There are techniques
    and libraries I use to make unit testing in Go more effective to write and understand
    when things go (heh) awry.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¿™å¹¶ä¸æ˜¯æˆ‘å®é™…å–œæ¬¢ç¼–å†™Goå•å…ƒæµ‹è¯•çš„æ–¹å¼ã€‚å½“äº‹æƒ…å‡ºé”™æ—¶ï¼Œæˆ‘ä½¿ç”¨çš„æŠ€æœ¯å’Œåº“å¯ä»¥ä½¿Goä¸­çš„å•å…ƒæµ‹è¯•æ›´æœ‰æ•ˆç‡å’Œæ˜“äºç†è§£ã€‚
- en: The test command[âŒ—](#the-test-command)
  id: totrans-split-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æµ‹è¯•å‘½ä»¤[âŒ—](#the-test-command)
- en: 'You can run `go test` in a given directory and see the output of your test,
    but that leaves a lot of functionality on the table that can and will be useful.
    The full command I typically use is:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¯ä»¥åœ¨ç»™å®šç›®å½•ä¸­è¿è¡Œ`go test`å¹¶æŸ¥çœ‹æµ‹è¯•çš„è¾“å‡ºï¼Œä½†è¿™ä¼šç•™ä¸‹è®¸å¤šåŠŸèƒ½æœªä½¿ç”¨çš„å¯èƒ½æ€§ã€‚æˆ‘é€šå¸¸ä½¿ç”¨çš„å®Œæ•´å‘½ä»¤æ˜¯ï¼š
- en: '`go test -cover -shuffle=on -race -vet=all -failfast <$RELEVANT_PACKAGE(S)>`'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`go test -cover -shuffle=on -race -vet=all -failfast <$RELEVANT_PACKAGE(S)>`'
- en: 'Hereâ€™s what each of these flags do:'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ ‡å¿—å„è‡ªçš„ä½œç”¨ï¼š
- en: Table-driven tests[âŒ—](#table-driven-tests)
  id: totrans-split-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è¡¨é©±åŠ¨æµ‹è¯•[âŒ—](#table-driven-tests)
- en: 'Iâ€™m going to say something sort of controversial in the Go zeitgeist: I find
    table tests very rarely useful. For something like our `addNumbers` function,
    I might actually do it, because the inputs and outputs are simple. Hereâ€™s what
    that might look like:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Goçš„æ½®æµä¸­ï¼Œæˆ‘è¦è¯´ä¸€äº›å¯èƒ½æœ‰äº‰è®®çš„è¯ï¼šæˆ‘å‘ç°è¡¨é©±åŠ¨æµ‹è¯•å¾ˆå°‘æœ‰ç”¨ã€‚å¯¹äºåƒæˆ‘ä»¬çš„`addNumbers`å‡½æ•°è¿™æ ·çš„ç®€å•è¾“å…¥è¾“å‡ºï¼Œæˆ‘å¯èƒ½ä¼šçœŸçš„å»åšï¼Œå› ä¸ºè¿™æ ·åšèµ·æ¥å¾ˆç®€å•ã€‚è¿™å¯èƒ½æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE4]'
  id: totrans-split-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That said, itâ€™s pretty easy to end up in a situation where your table tests
    need to be quite complicated and gnarly to get full coverage.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡å¦‚æ­¤ï¼Œå¾ˆå®¹æ˜“é™·å…¥ä¸€ç§æƒ…å†µï¼Œå³ä½ çš„è¡¨é©±åŠ¨æµ‹è¯•éœ€è¦å˜å¾—éå¸¸å¤æ‚å’Œæ£˜æ‰‹æ‰èƒ½è¾¾åˆ°å®Œå…¨è¦†ç›–ã€‚
- en: 'Goland lets you generate tests for functions using a default template that
    attempts to adhere to the tradition of table-driven tests. Hereâ€™s what the generated
    test function looks like for a method in a side project. This method fetches a
    webhook object from the database, and accepts 3 total parameters â€” a context,
    a webhook ID, and an accountID:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: Golandå…è®¸æ‚¨ä½¿ç”¨é»˜è®¤æ¨¡æ¿ä¸ºå‡½æ•°ç”Ÿæˆæµ‹è¯•ï¼Œè¯¥æ¨¡æ¿è¯•å›¾éµå¾ªè¡¨é©±åŠ¨æµ‹è¯•çš„ä¼ ç»Ÿã€‚è¿™æ˜¯ä¸€ä¸ªåœ¨æ—è¾¹é¡¹ç›®ä¸­ç”Ÿæˆçš„æµ‹è¯•å‡½æ•°ç¤ºä¾‹ã€‚è¯¥æ–¹æ³•ä»æ•°æ®åº“è·å–ä¸€ä¸ªwebhookå¯¹è±¡ï¼Œå¹¶æ¥å—3ä¸ªå‚æ•°
    - ä¸Šä¸‹æ–‡ã€webhook ID å’Œ accountIDï¼š
- en: '[PRE5]'
  id: totrans-split-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I think this is kind of a mess, and it doesnâ€™t even include test cases yet.
    Iâ€™d rather have the querier built by an only-available-to-tests constructor that
    puts sensible defaults for all these values.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è§‰å¾—è¿™æœ‰ç‚¹æ··ä¹±ï¼Œç”šè‡³è¿˜æ²¡æœ‰åŒ…æ‹¬æµ‹è¯•ç”¨ä¾‹ã€‚æˆ‘æ›´æ„¿æ„å°†æŸ¥è¯¢å™¨æ„å»ºä¸ºä»…åœ¨æµ‹è¯•ä¸­å¯ç”¨çš„æ„é€ å‡½æ•°ï¼Œè¯¥æ„é€ å‡½æ•°ä¸ºæ‰€æœ‰è¿™äº›å€¼è®¾ç½®åˆç†çš„é»˜è®¤å€¼ã€‚
- en: The point of this is not to dunk on Goland (I am a happily paying customer and
    have been for many years), itâ€™s just to illustrate how even a non-trivial function
    can really blow up the readability of a table-driven test.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¹¶ä¸æ˜¯ä¸ºäº†è´¬ä½Golandï¼ˆæˆ‘æ˜¯ä¸€ä¸ªå¿«ä¹çš„ä»˜è´¹ç”¨æˆ·ï¼Œå·²ç»å¤šå¹´äº†ï¼‰ï¼Œè€Œæ˜¯ä¸ºäº†è¯´æ˜å³ä½¿æ˜¯ä¸€ä¸ªéå¸¸å¤æ‚çš„å‡½æ•°ï¼Œä¹Ÿå¯èƒ½ä¼šæ˜¾è‘—é™ä½è¡¨é©±åŠ¨æµ‹è¯•çš„å¯è¯»æ€§ã€‚
- en: Parallel[âŒ—](#parallel)
  id: totrans-split-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¹¶è¡Œ[âŒ—](#parallel)
- en: Go tests can be run in parallel, by declaring the test as parallel in the top
    level. This behavior is on by default, and can only be disabled by setting the
    `-parallel=1` flag when invoking `go test` (which can be useful when debugging
    flaky tests).
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: Iâ€™m of the opinion that tests should be parallel unless they absolutely cannot
    be, and even then, Iâ€™d rather fix the flaw behind why they canâ€™t be run in parallel
    than force them to be run sequentially.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Running your tests in parallel generally allows you to suss out concurrency
    bugs earlier, even if youâ€™re not using the race detector (which you should), and
    will eventually lead to you developing concurrency-safe habits when writing code
    in the first place. So generally, when I write a test, the very first line is
    the parallel declaration:'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Subtests[âŒ—](#subtests)
  id: totrans-split-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subtests are a feature of Goâ€™s testing library that allow you to have smaller
    tests for specific circumstances. These allow you to get some of the benefits
    of a behavior-driven testing style, without having to invoke an external dependency.
    I usually write subtests even when thereâ€™s only one test case I care about, because
    it incurs no real overhead to do so, and allows you to easily test a new case
    in the event the tested function gets more complex.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: When I write subtests, I usually name the top-level `*testing.T` object a capitalized
    `T`, and use the conventional lower-cased `t` for subtests only. This way, the
    subtest logic always looks like an idiomatic Go test, and thereâ€™s no confusion
    of what variable is which or what shadows what. Calls to `.Parallel()` will have
    to be made for both the big and little `*T` variables.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s a demonstration that adapts our earlier example for the `addNumbers`
    function:'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now if I decide to add another test case, itâ€™s simply a matter of copying the
    subtest block, changing the name, and then making the test match that description:'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Additionally, if there are test fixtures or constants that are relevant to all
    subtests, they can live in the space between the big-T call to `.Parallel()` and
    the first declared subtest.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: Libraries[âŒ—](#libraries)
  id: totrans-split-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the standard library testing package is pretty great, there have been
    some great contributions by the community to the ecosystem that make testing in
    Go even better.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: Fake Values[âŒ—](#fake-values)
  id: totrans-split-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, when I need to interact with an object in a test, I want to have
    unpredictable values to the extent possible for that object, so that Iâ€™m discouraged
    from relying on those conventions when writing tests.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: So for instance, if I need a `*User` object for a test, I want to have no idea
    what itâ€™s username might be, as opposed to a common static value that I might
    copy/paste from place to place, which would make many tests fail if it was inadvertently
    changed.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: 'I like to use [brianvoe/gofakeit](https://pkg.go.dev/github.com/brianvoe/gofakeit/v7)
    for this. It comes with a ton of sensible functions with which to build fake instances
    of different types, and Iâ€™ve never had a problem with it. Hereâ€™s what that fake
    user builder might look like:'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å–œæ¬¢ä½¿ç”¨ [brianvoe/gofakeit](https://pkg.go.dev/github.com/brianvoe/gofakeit/v7)ã€‚å®ƒæä¾›äº†å¤§é‡åˆç†çš„å‡½æ•°æ¥æ„å»ºä¸åŒç±»å‹çš„è™šå‡å®ä¾‹ï¼Œæˆ‘ä»æœªé‡åˆ°è¿‡é—®é¢˜ã€‚è¿™æ˜¯ä¸€ä¸ªæ„å»ºè™šå‡ç”¨æˆ·çš„ç¤ºä¾‹ï¼š
- en: '[PRE9]'
  id: totrans-split-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Testify[âŒ—](#testify)
  id: totrans-split-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Testify[âŒ—](#testify)
- en: 'Iâ€™m a huge fan of the `(assert|require|mock)` libraries in [testify](https://github.com/stretchr/testify).
    In our example test, using testify would look like:'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘éå¸¸å–œæ¬¢ [testify](https://github.com/stretchr/testify) ä¸­çš„`(assert|require|mock)`åº“ã€‚åœ¨æˆ‘ä»¬çš„ç¤ºä¾‹æµ‹è¯•ä¸­ï¼Œä½¿ç”¨
    testify çœ‹èµ·æ¥åƒè¿™æ ·ï¼š
- en: '[PRE10]'
  id: totrans-split-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I think `assert.Equal` is fairly obvious in its function for users who are new
    to a code base. `testify` is probably the only library I can think of that I would
    wholeheartedly support being absorbed into the standard library.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è®¤ä¸º`assert.Equal`å¯¹äºæ–°æ¥è§¦ä»£ç åº“çš„ç”¨æˆ·æ¥è¯´ï¼Œå…¶åŠŸèƒ½æ˜¯ç›¸å½“æ˜æ˜¾çš„ã€‚`testify`å¯èƒ½æ˜¯æˆ‘å”¯ä¸€å…¨åŠ›æ”¯æŒå¹¶å…¥æ ‡å‡†åº“çš„åº“ã€‚
- en: 'You can use `require` instead if you want the test to stop in the event of
    a failure. This is usually good for dependencies of a test, i.e. if I need to
    create a file and pass it to a function, I should probably `require` that no errors
    happen when creating it:'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å¸Œæœ›æµ‹è¯•åœ¨å¤±è´¥æ—¶åœæ­¢ä½¿ç”¨ `require` ä¹Ÿå¯ä»¥ã€‚è¿™é€šå¸¸é€‚ç”¨äºæµ‹è¯•çš„ä¾èµ–é¡¹ï¼Œä¾‹å¦‚ï¼Œå¦‚æœæˆ‘éœ€è¦åˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¹¶å°†å…¶ä¼ é€’ç»™ä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘å¯èƒ½åº”è¯¥`require`åœ¨åˆ›å»ºæ—¶æ²¡æœ‰é”™è¯¯å‘ç”Ÿï¼š
- en: '[PRE11]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`mock` is also useful for defining mock implementations of structures. Say
    I have the following interface:'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock`ä¹Ÿå¯ä»¥ç”¨äºå®šä¹‰ç»“æ„çš„æ¨¡æ‹Ÿå®ç°ã€‚å‡è®¾æˆ‘æœ‰ä»¥ä¸‹æ¥å£ï¼š'
- en: '[PRE12]'
  id: totrans-split-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implementing a mock for this interface becomes a matter of:'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºè¿™ä¸ªæ¥å£å®ç°ä¸€ä¸ªæ¨¡æ‹Ÿåªæ˜¯ä¸€ä¸ªç®€å•çš„äº‹æƒ…ï¼š
- en: '[PRE13]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using the above mock in a test looks like this:'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æµ‹è¯•ä¸­ä½¿ç”¨ä¸Šè¿°æ¨¡æ‹Ÿçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE14]'
  id: totrans-split-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I wonâ€™t lie, Iâ€™m not deeply impressed with the way that `mock.Mock` determines
    which variables to return in what order, and when things go wrong (i.e. you copy
    and paste something in the wrong order or have the wrong indices on your return
    values) itâ€™s VERY hard to suss out, but by and large, `testify/mock` does an incredible
    job of what it needs to do.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¸ä¼šæ’’è°ï¼Œæˆ‘å¯¹`mock.Mock`ç¡®å®šå“ªäº›å˜é‡ä»¥åŠä½•æ—¶ä»¥ä½•ç§é¡ºåºè¿”å›å¹¶ä¸æ·±æ„Ÿå°è±¡æ·±åˆ»ï¼Œå½“äº‹æƒ…å‡ºé”™æ—¶ï¼ˆä¾‹å¦‚ï¼Œä½ å¤åˆ¶å¹¶ç²˜è´´äº†é¡ºåºé”™è¯¯æˆ–è€…è¿”å›å€¼çš„ç´¢å¼•é”™è¯¯æ—¶ï¼‰ï¼Œå®ƒéå¸¸éš¾ä»¥ç†æ¸…ï¼Œä½†æ€»ä½“è€Œè¨€ï¼Œ`testify/mock`åšäº†å®ƒéœ€è¦åšçš„äº‹æƒ…ã€‚
- en: 'You can avoid having to put `mock.Anything` in an expectation call by writing
    a type matcher. For `context.Context`, it would look like this:'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡ç¼–å†™ç±»å‹åŒ¹é…å™¨ï¼Œä½ å¯ä»¥é¿å…åœ¨æœŸæœ›è°ƒç”¨ä¸­æ”¾ç½®`mock.Anything`ã€‚å¯¹äº`context.Context`ï¼Œå®ƒçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE15]'
  id: totrans-split-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Thereâ€™s also `testify/suite`, which I *have* used, but wouldnâ€™t recommend. Itâ€™s
    useful when you have a ton of common prerequisites for tests that need to be spun
    up ahead of time, but I still think it makes more sense to just make those prerequisites
    the product of a common function, instead of writing non-standard test code.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰`testify/suite`ï¼Œæˆ‘*æ›¾ç»*ä½¿ç”¨è¿‡ï¼Œä½†ä¸æ¨èã€‚å½“ä½ éœ€è¦å¤§é‡å…¬å…±å‰ææ¡ä»¶ç”¨äºé¢„å…ˆè®¾ç½®æµ‹è¯•æ—¶ï¼Œå®ƒå¾ˆæœ‰ç”¨ï¼Œä½†æˆ‘ä»ç„¶è®¤ä¸ºæ›´åˆç†çš„åšæ³•æ˜¯å°†è¿™äº›å‰ææ¡ä»¶ä½œä¸ºä¸€ä¸ªé€šç”¨å‡½æ•°çš„äº§ç‰©ï¼Œè€Œä¸æ˜¯ç¼–å†™éæ ‡å‡†çš„æµ‹è¯•ä»£ç ã€‚
- en: Testcontainers[âŒ—](#testcontainers)
  id: totrans-split-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Testcontainers[âŒ—](#testcontainers)
- en: This is a neat tool Iâ€™ve only recently started using, but to great effect. Itâ€™s
    very common to have to write code that interfaces with a database, or a k/v store,
    or an in-memory cache, but before [testcontainers](https://testcontainers.com/),
    you either had to write a suite of integration tests that used that code to verify
    it did what you wanted, or otherwise fly blind in production. With testcontainers,
    I can spin up ephemeral containers that run a given piece of software and have
    my code interact with that to verify functionality.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæˆ‘æœ€è¿‘æ‰å¼€å§‹ä½¿ç”¨çš„å¾ˆå¥½çš„å·¥å…·ï¼Œæ•ˆæœéå¸¸å¥½ã€‚é€šå¸¸éœ€è¦ç¼–å†™ä¸æ•°æ®åº“ã€k/v å­˜å‚¨æˆ–å†…å­˜ä¸­ç¼“å­˜è¿›è¡Œäº¤äº’çš„ä»£ç ï¼Œä½†åœ¨æœ‰äº† [testcontainers](https://testcontainers.com/)
    ä¹‹å‰ï¼Œä½ è¦ä¹ˆå¿…é¡»ç¼–å†™ä¸€å¥—é›†æˆæµ‹è¯•æ¥ä½¿ç”¨è¯¥ä»£ç æ¥éªŒè¯å…¶æ˜¯å¦æŒ‰é¢„æœŸå·¥ä½œï¼Œè¦ä¹ˆåœ¨ç”Ÿäº§ç¯å¢ƒä¸­è¿›è¡Œç›²ç›®æµ‹è¯•ã€‚ä½¿ç”¨ testcontainersï¼Œæˆ‘å¯ä»¥å¯åŠ¨ä¸´æ—¶å®¹å™¨æ¥è¿è¡ŒæŒ‡å®šçš„è½¯ä»¶ï¼Œå¹¶è®©æˆ‘çš„ä»£ç ä¸ä¹‹äº¤äº’ä»¥éªŒè¯åŠŸèƒ½ã€‚
- en: In practice, itâ€™s not perfect. These tests generally run great on my machine,
    and in Github Actions, but you must remember that youâ€™re asking your computer
    to make a fake computer within itself, spin up a piece of software on that fake
    computer, and handle all the networking shenanigans that go along with interfacing
    with it, so thereâ€™s plenty of opportunity for mishaps and errors to occur.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­ï¼Œå®ƒå¹¶ä¸å®Œç¾ã€‚è¿™äº›æµ‹è¯•é€šå¸¸åœ¨æˆ‘çš„æœºå™¨ä¸Šè¿è¡Œå¾—å¾ˆå¥½ï¼Œå¹¶ä¸”åœ¨ Github Actions ä¸­ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œä½†ä½ å¿…é¡»è®°ä½ï¼Œä½ è¦æ±‚ä½ çš„è®¡ç®—æœºåœ¨è‡ªèº«å†…éƒ¨åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿè®¡ç®—æœºï¼Œåœ¨è¯¥è™šæ‹Ÿè®¡ç®—æœºä¸Šè¿è¡Œä¸€ä¸ªè½¯ä»¶ï¼Œå¹¶å¤„ç†æ‰€æœ‰ä¸å…¶æ¥å£ç›¸å…³çš„ç½‘ç»œèŠ±çµ®ï¼Œå› æ­¤å­˜åœ¨å¤§é‡æœºä¼šå‡ºç°é—®é¢˜å’Œé”™è¯¯ã€‚
- en: 'Sometimes a testcontainer invocation will just fail, and the reason behind
    it can be summarized up as: computers are hard. Since they can be a big more error
    prone than standard tests, I donâ€™t typically write subtests for these. Instead,
    I tend to write one big function that uses a single instance of the container
    to test a bunch of related functions.'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™æµ‹è¯•å®¹å™¨çš„è°ƒç”¨ä¼šå¤±è´¥ï¼Œå…¶åŸå› å¯ä»¥æ€»ç»“ä¸ºï¼šè®¡ç®—æœºå¾ˆéš¾ã€‚ç”±äºå®ƒä»¬å¯èƒ½æ¯”æ ‡å‡†æµ‹è¯•æ›´å®¹æ˜“å‡ºé”™ï¼Œæˆ‘é€šå¸¸ä¸ä¸ºè¿™äº›å†™å­æµ‹è¯•ã€‚ç›¸åï¼Œæˆ‘å€¾å‘äºç¼–å†™ä¸€ä¸ªä½¿ç”¨å®¹å™¨çš„å•ä¸ªå®ä¾‹æ¥æµ‹è¯•ä¸€å †ç›¸å…³å‡½æ•°çš„å¤§å‡½æ•°ã€‚
- en: 'Hereâ€™s an example of the test for that aforementioned webhook retrieval function:'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæµ‹è¯•å‰è¿° Webhook æ£€ç´¢å‡½æ•°çš„ç¤ºä¾‹ï¼š
- en: '[PRE16]'
  id: totrans-split-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (I acknowledge that this code is missing some function definitions, but itâ€™s
    meant for you to get an idea, not copy/paste)
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: (æˆ‘æ‰¿è®¤è¿™æ®µä»£ç ç¼ºå°‘ä¸€äº›å‡½æ•°å®šä¹‰ï¼Œä½†å®ƒæ˜¯ä¸ºäº†è®©ä½ æœ‰ä¸ªæ¦‚å¿µï¼Œè€Œä¸æ˜¯å¤åˆ¶/ç²˜è´´)
- en: Failure Cases[âŒ—](#failure-cases)
  id: totrans-split-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¤±è´¥æ¡ˆä¾‹[âŒ—](#failure-cases)
- en: Some functions in the Go standard library return errors that you might surface
    to higher-level call sites, but in order to test that those errors are caught
    and returned, Here are some ways I manage to achieve failures for very specific
    circumstances in Go.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: Go æ ‡å‡†åº“ä¸­çš„ä¸€äº›å‡½æ•°ä¼šè¿”å›é”™è¯¯ï¼Œä½ å¯èƒ½ä¼šå°†è¿™äº›é”™è¯¯æš´éœ²ç»™æ›´é«˜çº§åˆ«çš„è°ƒç”¨ç«™ç‚¹ï¼Œä½†ä¸ºäº†æµ‹è¯•è¿™äº›é”™è¯¯æ˜¯å¦è¢«æ•è·å¹¶è¿”å›ï¼Œè¿™é‡Œæœ‰ä¸€äº›æˆ‘è®¾æ³•åœ¨ç‰¹å®šæƒ…å†µä¸‹é€ æˆå¤±è´¥çš„æ–¹å¼ã€‚
- en: JSON Encoding[âŒ—](#json-encoding)
  id: totrans-split-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON ç¼–ç [âŒ—](#json-encoding)
- en: Itâ€™s a pretty common operation in Go code to take an instance of a given struct
    and render it as JSON. This function is capable of returning an error in the event
    the source struct is unrepresentable, but itâ€™s actually pretty hard to make a
    struct unrepresentable in Go. You basically have to do it on purpose.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Go ä»£ç ä¸­ï¼Œå°†ç»™å®šç»“æ„çš„å®ä¾‹è½¬æ¢ä¸º JSON æ˜¯ä¸€ç§éå¸¸å¸¸è§çš„æ“ä½œã€‚å¦‚æœæºç»“æ„ä¸å¯è¡¨ç¤ºï¼Œæ­¤å‡½æ•°å¯ä»¥è¿”å›é”™è¯¯ï¼Œä½†å®é™…ä¸Šåœ¨ Go ä¸­å¾ˆéš¾ä½¿ç»“æ„ä¸å¯è¡¨ç¤ºã€‚ä½ åŸºæœ¬ä¸Šå¿…é¡»æ˜¯æ•…æ„çš„ã€‚
- en: 'The way I achieve this is by using [`json.Number`](https://pkg.go.dev/encoding/json#Number),
    a string alias meant to represent numbers, and giving it a non-numerical value.
    Hereâ€™s what that looks like:'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å®ç°è¿™ä¸€ç‚¹çš„æ–¹å¼æ˜¯ä½¿ç”¨ [`json.Number`](https://pkg.go.dev/encoding/json#Number)ï¼Œè¿™æ˜¯ä¸€ä¸ªä»£è¡¨æ•°å­—çš„å­—ç¬¦ä¸²åˆ«åï¼Œå¹¶ç»™å®ƒä¸€ä¸ªéæ•°å­—å€¼ã€‚è¿™æ˜¯å®ƒçš„æ ·å­ï¼š
- en: '[PRE17]'
  id: totrans-split-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: URL Parsing[âŒ—](#url-parsing)
  id: totrans-split-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL è§£æ[âŒ—](#url-parsing)
- en: 'Parsing a URL in Go [returns an error](https://pkg.go.dev/net/url#Parse), but
    trying to force this error to occur was very confusing to me. I had to dive into
    the actual test cases in the standard library for [`net/url`](https://pkg.go.dev/net/url).
    Here are some inputs you might think return an error from `url.Parse`, but actually
    donâ€™t:'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Go ä¸­è§£æ URL [ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯](https://pkg.go.dev/net/url#Parse)ï¼Œä½†è¯•å›¾å¼ºåˆ¶è¿™ä¸ªé”™è¯¯å‘ç”Ÿå¯¹æˆ‘æ¥è¯´éå¸¸ä»¤äººå›°æƒ‘ã€‚æˆ‘ä¸å¾—ä¸æ·±å…¥åˆ°[`net/url`](https://pkg.go.dev/net/url)
    æ ‡å‡†åº“çš„å®é™…æµ‹è¯•æ¡ˆä¾‹ä¸­ã€‚è¿™é‡Œæœ‰ä¸€äº›ä½ å¯èƒ½è®¤ä¸ºä¼šä» `url.Parse` è¿”å›é”™è¯¯çš„è¾“å…¥ï¼Œä½†å®é™…ä¸Šå¹¶ä¸ä¼šï¼š
- en: an empty string
  id: totrans-split-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç©ºå­—ç¬¦ä¸²
- en: a URL with double dots in the path (i.e. `https://google.com/../../var/data`)
  id: totrans-split-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªè·¯å¾„ä¸­å¸¦æœ‰åŒç‚¹çš„ç½‘å€ï¼ˆå³`https://google.com/../../var/data`ï¼‰
- en: just a scheme (i.e. `https://`)
  id: totrans-split-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åªæ˜¯ä¸€ä¸ªæ–¹æ¡ˆï¼ˆå³`https://`ï¼‰
- en: a URL with emojis in it (i.e. `https://ğŸ˜˜.ğŸ”¥`)
  id: totrans-split-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªå¸¦æœ‰è¡¨æƒ…ç¬¦å·çš„ç½‘å€ï¼ˆå³`https://ğŸ˜˜.ğŸ”¥`ï¼‰
- en: a URL with an invalid scheme (i.e. `farts://`)
  id: totrans-split-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªå¸¦æœ‰æ— æ•ˆæ–¹æ¡ˆçš„ç½‘å€ï¼ˆå³`farts://`ï¼‰
- en: 'All of these actually donâ€™t return an error. The only way I was able to force
    it to occur by using:'
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰è¿™äº›å®é™…ä¸Šéƒ½æ²¡æœ‰è¿”å›é”™è¯¯ã€‚æˆ‘èƒ½å¤Ÿå¼ºåˆ¶å®ƒå‘ç”Ÿçš„å”¯ä¸€æ–¹æ³•æ˜¯ä½¿ç”¨ï¼š
- en: '[PRE18]'
  id: totrans-split-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For whatever reason, this causes `url.Parse` to fail.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæŸç§åŸå› ï¼Œè¿™ä¼šå¯¼è‡´ `url.Parse` å¤±è´¥ã€‚
- en: Conclusion[âŒ—](#conclusion)
  id: totrans-split-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ç»“è®º[âŒ—](#conclusion)
- en: In many other languages, you have to not only evaluate testing libraries, but
    also write your tests in a style that complies with that libraryâ€™s expectations.
    Gophers are blessed to have a thoroughly adequate solution out-of-the-box, and
    even further blessed to have an active ecosystem where folks are making in-depth
    testing a walk in the park.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¸å¤šå…¶ä»–è¯­è¨€ä¸­ï¼Œä½ ä¸ä»…éœ€è¦è¯„ä¼°æµ‹è¯•åº“ï¼Œè¿˜éœ€è¦ä»¥ç¬¦åˆè¯¥åº“æœŸæœ›çš„æ–¹å¼ç¼–å†™ä½ çš„æµ‹è¯•ã€‚Gophers å¹¸è¿åœ°æ‹¥æœ‰ä¸€ä¸ªå½»åº•åˆé€‚çš„è§£å†³æ–¹æ¡ˆï¼Œç”šè‡³è¿˜æœ‰ä¸€ä¸ªç§¯æçš„ç”Ÿæ€ç³»ç»Ÿï¼Œè®©æ·±å…¥æµ‹è¯•å˜å¾—è½»è€Œæ˜“ä¸¾ã€‚
