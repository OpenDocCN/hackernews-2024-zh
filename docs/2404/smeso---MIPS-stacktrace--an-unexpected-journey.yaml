- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:02:52'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: 'smeso - MIPS stacktrace: an unexpected journey'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://smeso.it/2024/03/02/mips-stacktrace-an-unexpected-journey.html](https://smeso.it/2024/03/02/mips-stacktrace-an-unexpected-journey.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Automatically receiving a stacktrace when your C program crashes isn't rocket
    science. But this time it was more difficult than I expected. This is a short
    recollection of the things I found out few years ago. This post assumes that the
    reader has some basic knowledge about functions' calling conventions, CPU registers,
    and assembly.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Some context
  id: totrans-split-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A C program running on Linux was randomly crashing on one specific embedded
    device deployed on the other side of the world. The device architecture was MIPS32\.
    We needed a system to asynchronously receive reports with as much details as possible
    (i.e. a stacktrace). The device was using *glibc*, ideally we wanted a solution
    that could also work with other standard libraries (e.g. *musl* and *uClibc*)
    but even a non-portable solution was okay, at least to fix this one problem. Using
    external dependencies, especially if they were large, wasn't an option.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: The simple solution
  id: totrans-split-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*glibc* already has [`backtrace(3)`](https://www.gnu.org/software/libc/manual/html_node/Backtraces.html#index-backtrace-1)
    and [`backtrace_symbols_fd(3)`](https://gnu.org/software/libc/manual/html_node/Backtraces.html#index-backtrace_005fsymbols_005ffd).
    They are easy to use and they will certainly work very well! *glibc* simply calls
    *libgcc*. Any code I’ll ever write will never understand the code generated by
    *GCC* better than *libgcc*!'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Well, this may be true when you are on x86_64, but on some other architectures
    like MIPS32 those functions *don't work at all*.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Some notes on MIPS
  id: totrans-split-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just in case you are not too familiar with MIPS, I wanted to add some notes
    about how it works with gcc on Linux.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: The return address of the current function is stored in the *$ra* register
  id: totrans-split-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When entering a new function the "old" return address is pushed onto the stack
    and is the last thing just before the start of the stack frame of the new function.
  id: totrans-split-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reconstruct the stack trace we need to recover all the return addresses in
    sequence. We can start from *$ra* and then go backwards, pulling the return addresses
    from the end of each stack frame.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: The problem
  id: totrans-split-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It turns out that `backtrace(3)` does the same thing that too many blog posts
    on the Internet recommend to do: unwind the stack using the `frame pointer` register
    to figure out the position of the previous function''s return address. This makes
    perfect sense, the *frame pointer* (aka `$fp` or `$30` on MIPS) is *usually* a
    register designed to help debuggers to refer to local variables and other information
    stored on the stack (e.g. the previous function return address) using constant
    offsets. In theory, while the *stack pointer* (aka `$sp`) always points at the
    top of the stack, the *$fp* should point at the beginning of the current *stack
    frame* and should not move from there. If you want to retrieve the return address
    using the *$sp*, you need to know how much stuff you put on your stack since you
    entered the current stack frame, this depends on: what function you are in, how
    many automatic variables this functions is using, what type are those functions,
    and how many bytes do those types use. It would be very inconvenient to work with
    the *$sp* during debug, so we are very lucky to have the *$fp*! Using the *$fp*
    we can always retrieve the return address of the previous function without any
    complex operation! The offset between the *$fp* and the return address is the
    same constant for all functions in all programs!'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: '... Or is it?'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: Well... it turns out it isn't.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, when using GCC on Linux on MIPS32, the *frame pointer* just works
    *exactly* like another *stack pointer*: it''s completely useless! I''m not 100%
    sure about the reason behind this choice, but I think it could be related to the
    fact that, on architectures with (relatively) small registers, it would be difficult
    to reference the top of the stack using a real *$fp*, but still it sounds like
    the wrong thing to do.'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: The funniest thing is that, `backtrace(3)` implementation from libgcc seems
    to ignore how gcc works in this context and it just returns random values.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: The real solution
  id: totrans-split-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can get rid of the *$fp* completely and just work with *$sp*, but how can
    we figure out the correct offset to use with *$sp* for *any* function?
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: You may not like the answer (or maybe you will) but the only way to know where
    the beginning of the stack frame is... is to jump into the actual code of the
    function and *parse the opcodes* to figure out how much *$sp* was decremented
    by the compiler.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one way to do it:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-27
  prefs: []
  type: TYPE_PRE
- en: Symbolizing the addresses
  id: totrans-split-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be nice to be able to translate the addresses, that we just found,
    to actual function names. This isn't usually the funniest thing to do, but after
    what we just did, it seems trivial. We can use `dl_iterate_phdr(3)` to look into
    every loaded shared object. Once we found the shared object that contains our
    address, we can walk through its ELF sections and look at its *.symtab* to find
    the function name.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to do it:'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
- en: Wouldn't it be cool if we also retrieved the source file name and the line?
    To do that we need to use the information provided in the *.debug_line* section
    using the *DWARF* format. To use as little space as possible *DWARF* doesn’t simply
    store a list of address-to-line mappings. It stores a *line number program*, which
    is a serialized finite state machine that can be used to find out line numbers
    and more. Parsing *DWARF* is left as an exercise for the reader. Alternatively
    we can manually invoke *addr2line*.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-split-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the end the bug was found and fixed and everyone lived happily ever after.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: I learned, once again, that features/bugs can sometime happen in your most trusted
    dependency and one should never refrain from doubting the correctness of the most
    respected software.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: I also learned, once again, that the Internet is full of misleading information
    and blog posts written with authority by people that never *actually tried* to
    do the things that they talk about. As of today if you try to lookup information
    about the frame pointer on MIPS32 it will be very hard to find any mention at
    all of the issues outlined in this post. So, never trust a blog post! Not even
    this one! Your combination of compiler and libc might behave differently and have
    different, new, exciting issues that will ruin your day!
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: P.S.
  id: totrans-split-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post made HN's front page and received a few comments! You can add your
    comments [here](https://news.ycombinator.com/item?id=39967864) as well.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
