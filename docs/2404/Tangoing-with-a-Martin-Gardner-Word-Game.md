<!--yml

category: 未分类

date: 2024-05-27 13:38:59

-->

# 与 Martin Gardner 的文字游戏共舞

> 来源：[https://pncnmnp.github.io/blogs/martin-gardner-game.html](https://pncnmnp.github.io/blogs/martin-gardner-game.html)

# 与 Martin Gardner 的文字游戏共舞

## 首次发布日期：24年1月28日

> *一旦超越 Z 开始四处探索，你会感到有点惊讶，你会找到什么！*
> 
> - 《超越 Zebra！》, Dr. Seuss

令人着迷的是，我们有时会突然发现一些边缘但有趣的东西，以至于停下手头的工作去追求这个想法。

昨天，在研究位数组时，我偶然发现了 [《ACM通讯》中1961年的一篇文章](https://dl.acm.org/doi/10.1145/366786.366795)，作者是 Anatol W. Holt。因为从未听说过 Holt，我自然决定在 Google 学术和 Google 图书中探索他的作品。就在那时，我偶然发现了 [Martin Gardner 1969 年的专栏文章“数学游戏”](https://archive.org/details/sim_scientific-american_1969-04_220_4/page/124/mode/2up)，刊登在《科学美国人》上。

这是四月份的版面，Gardner 在其中提出了八个基于逻辑和概率的问题。其中许多问题的中心主题是某种游戏，例如象棋、名片和文字游戏。*称这些问题有趣几乎是一种轻描淡写* - 有一个未解的骑士周游问题，一种变体的象棋，第一个将对手国王将死的人赢，一个乌尔纳问题的变体，当然，这个博客的主题 - 一个文字游戏。

这是一个词语游戏：

> Anatol W. Holt，应用数据研究公司高级系统主管，是一位喜欢发明游戏的数学家。他的棋盘游戏 MEM，使用了 11 种颜色的 32 颗石子，是一款基于全新思路的策略游戏，涉及模式识别。（目前在商店有售，也可以通过 Holt 自己的公司 Stelledar, Inc., 1700 Walnut Street, Philadelphia, Pa. 19103，邮寄购买，价格为 $6.50。）
> 
> 几年前，Holt 设计了以下的文字游戏。两个人各自想一个“目标词”，字母数相同。初学者应从三个字母的单词开始，随着技能的提高逐渐转向更长的单词。玩家轮流报出同意长度的“探测词”。对手必须回答“击中”（正确的字母在正确的位置）的数量是奇数还是偶数。第一个猜到对手的单词的人获胜。为了展示如何通过逻辑分析而非猜测来确定单词，Holt 提供了一个玩家提供的六个探测词的示例：
> 
> Even: Day, May, Buy
> 
> Odd: Say, Due, Ten
> 
> 如果你知道目标词并将其逐字与任何偶数列表中的词进行比较，你会发现每个探测中的偶数（零也算偶数）的字母与目标词中相同位置的字母匹配；奇数列表中的词将与目标词在奇数位置上匹配。找到目标词。

*我们不要充当哑剧演员！拿起你的铅笔，开始脑力激荡吧。*

在这个过去的圣诞节，我与家人玩了大量的纽约时报单词游戏，虽然我承认，我甚至尝试构建我自己的Wordle变体，但我没能想出像这个那么有趣和简单的东西。

通过检查奇数和偶数探测词之间的相似性和差异可以得出一个自然的解决方案。例如，“Day”是偶数，“Say”是奇数。由于后缀“-ay”是一致的，这表明“S”是目标词的第一个字母。进一步考虑“Due”，“Day”和“Buy”，我们推断出“u”不能在中间，“D”不能在开头，正如先前观察到的。这留下了奇数词“Due”中的“e”，表明“e”是目标词的最后一个字母。确定了第一个和最后一个字母后，我们再看“Ten”。由于它是一个奇数词，且“e”是中间字母，我们可以得出“e”也是目标词的中心字母。*因此，目标词是“See”。*

*这可以很容易地变成一款类似纽约时报的文字游戏，计算机随机选择一个三个字母的词（或四个，以增加难度），我们的任务是猜测这个词，而计算机给出奇偶提示。猜测次数越少，找到目标词的效果越好。* 这是一个令人惊讶地有趣的游戏！

这是一个用于玩游戏的简短的Python程序：

```
import random
from nltk.corpus import words

def get_word(length=3):
    return random.choice([w for w in words.words() if len(w) == length]).lower()

def check(guess, answer):
    return "Even" if sum(g == a for g, a in zip(guess, answer)) % 2 == 0 else "Odd"

def play():
    answer = get_word()
    try:
        while (guess := input("Guess: ")) != answer:
            print(f"It's {check(guess, answer)}")
    except KeyboardInterrupt:
        pass
    finally:
        print(f"The word was {answer}")

if __name__ == "__main__":
    play() 
```

现在，这里有一个有趣的问题：*我们如何计算地解决它呢？*

对于一个三个字母的目标词，算法可以如下：

1.  从字典中随机选择三个字母的猜测开始。

    1.  继续猜测，直到你收到表明所猜测的词是一个“奇探测词”的反馈（即它与目标词匹配的字母数为一或三）。如果三个字母都匹配，问题就解决了。

1.  从步骤1的奇数探测词中取一个并生成这个词的变体，每次改变一个字母，同时保持其他两个字母不变。例如，如果“nay”是一个奇数探测词，生成诸如“say”，“nap”和“noy”的变体。

    1.  对于每一个变体，做一个猜测并观察反馈。

    1.  确定一个字母的变化，导致一个“偶探测词”反馈。这个字母是目标词中第一个匹配的字母。

1.  接下来，在保持步骤2中确定的匹配字母（及其位置）不变的情况下进行猜测，同时改变其他两个字母。

    1.  继续，直到你收到表明这是一个“偶探测词”的反馈。

    1.  应用与步骤2相同的过程来识别第二个匹配的字母。

1.  有了两个已经确定的字母后，使用字典来进行最后一个字母的猜测，直到找到目标单词。

当我们将第二步限制为仅允许在字典中找到的单词时，问题变得令人惊讶地复杂起来。这种限制意味着我们不能在保持其他字母不变的情况下总是能够生成变体。这种复杂性在三个字母的版本中并不立即显现；然而，当我们移至四个或更多字母时，它变得更加困难。敢问，*这个问题甚至变成了NP*。

想一想！我们得到的奇偶反馈并不直接指示哪些字母是正确的或它们的位置。这种不确定性导致了随着单词长度增加而出现的组合爆炸。每次猜测，我们只能部分地限制解空间，在最坏的情况下，可能需要许多猜测才能收敛于正确的单词。我打算对此进一步思考。

最后，*每个世界构建者都有权为他们的城镇命名*。由于原始作者可能已不在，我想为它提议一个名字 - **Yinique**！

[←](../blog.html)
