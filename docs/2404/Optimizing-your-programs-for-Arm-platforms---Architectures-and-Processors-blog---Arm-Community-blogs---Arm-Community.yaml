- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:33:10'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your programs for Arm platforms - Architectures and Processors blog
    - Arm Community blogs - Arm Community
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/optimizing-your-programs-for-arm-platforms](https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/optimizing-your-programs-for-arm-platforms)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Today’s compilers are quite good at producing highly optimized code on their
    own. However, there are several cases where you as the programmer can help compilers
    generate better code. This blog post covers techniques and tips that are useful
    to create better performing programs whether you are creating Android, Desktop
    or Server applications.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Memory aliasing and the ‘restrict’ keyword
  id: totrans-split-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever a compiler auto-vectorizes code, it needs to first be sure that this
    is safe to do. One of the performed safety checks is for pointer aliasing. This
    check is used to see if the pointers the compiler is reading and writing can be
    pointing to the same data. When the compiler cannot determine this statically,
    it has to insert a runtime check.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: These checks can slow your program down significantly or, even worse, fail to
    vectorize entirely if it can not insert the runtime checks. However, there is
    a way for you as the programmer to tell the compiler to go ahead and assume the
    pointers do not alias. Read the following Learning Path in the URL that explains
    the importance of using the ‘restrict’ keyword in C correctly.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: '[CTAToken URL = "https://learn.arm.com/learning-paths/cross-platform/restrict-keyword-c99/"
    target="_blank" text="Learn about the restrict keyword" class ="green"]'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Memory latency
  id: totrans-split-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loading and storing data to memory is an activity that takes time for the CPU
    to complete. How much time depends on several factors, but there are various things
    that you as the programmer can do to improve this access time. Often compilers
    cannot do these for you and so knowing these techniques can give your program
    the edge it needs. Read the Memory Latency Learning Path in the following URL
    to gain a better understanding of caches, prefetching and data alignment on Arm
    platforms.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: '[CTAToken URL = "https://learn.arm.com/learning-paths/cross-platform/memory-latency/"
    target="_blank" text="Learn about memory latency" class ="green"]'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging integer vs floating point
  id: totrans-split-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performing operations using integer arithmetic instead of floating-point arithmetic
    can often result in significantly faster programs, as CPUs tend to have more bandwidth
    to perform integer arithmetic. However, there are cases where, due to the semantics
    of the programming language, you inadvertently end up with floating point operations.
    One common pitfall is implicit conversions to floating-point. Read the Speed benefit
    of integer vs float Learning Path in the following URL to find out how to avoid
    these pitfalls and leverage the power of integer performance for faster programs.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: '[CTAToken URL = "https://learn.arm.com/learning-paths/cross-platform/integer-vs-floats/"
    target="_blank" text="Learn about integer vs floating point performance" class
    ="green"]'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging auto-vectorization in compilers
  id: totrans-split-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern compilers are often referred to as optimizing compilers, because they
    perform various optimizations and transformations on your input program to get
    better performance. One such optimization is the transformation of your program
    from scalar to vector. The act of vectorization refers to transforming your program
    from handling one value at a time into one that can handle multiple values at
    a time in each operation.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: While compilers are very good at this and constantly improving, there are still
    various ways you can structure the flow of your program to make it easier for
    the compiler to perform auto-vectorization and leverage the power of Advanced
    SIMD and SVE instructions.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Intrigued? Read more in the following URL:'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: '[CTAToken URL = "https://learn.arm.com/learning-paths/cross-platform/loop-reflowing/"
    target="_blank" text="Learn how to leverage auto-vectorization" class ="green"]'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: Modifying loop layout to be auto-vectorization friendly
  id: totrans-split-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of equal importance when writing auto-vectorization friendly programs is the
    data layout. When the compiler is transforming loops during auto-vectorization
    It makes a significant difference whether it can be load data sequentially, or
    whether it needs to skip some elements, for instance loading every other element.
    Even accesses like reading a field of a struct inside an array, such as data[i].x,
    can result in strided accesses.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: An efficient data layout can be the difference between a slow and very fast
    program. This is one area where the compiler often does not have enough context
    to be able to help and where it is important for the programmer to understand
    how they can help the compiler. Interested in taking your program’s performance
    to the next level? Read more in the link below.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '[CTAToken URL = "https://learn.arm.com/learning-paths/cross-platform/vectorization-friendly-data-layout/data-layout-basics/"
    target="_blank" text="Learn about data layout" class ="green"]'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-split-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Arm architecture has plenty of great features that when used properly can
    significantly improve your program's performance. It is easy to take advantage
    of them if you keep the tips and background knowledge in mind.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to read the other Learning Paths here: [https://learn.arm.com](https://learn.arm.com) for
    other helpful and informative tips on how to best leverage all that the Arm platform
    provides.'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: '[CTAToken URL = "https://learn.arm.com/" target="_blank" text="Read more Arm
    Learning Paths" class ="green"]'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
