<!--yml

category: 未分类

date: 2024-05-27 13:29:05

-->

# 理解并避免ID中的视觉歧义字符

> 来源：[https://gajus.com/blog/avoiding-visually-ambiguous-characters-in-ids](https://gajus.com/blog/avoiding-visually-ambiguous-characters-in-ids)

当与系统交互时，例如报告错误，输入折扣代码或跟踪包裹时，我通常需要书写或传达ID。当经验因易于避免的错误而受损时，这非常令人沮丧 - 视觉上的歧义字符。

+   `O` / `0` - 字母 `O` 和数字 `0` 在某些字体中看起来非常相似，尤其是在没有斜线或点的数字零的字体中。

+   `I` / `l` / `1` / `7` - 字母 `I`（大写 `i`），小写 `l`（`L`），数字 `1` 和数字 `7` ^([1](#user-content-fn-1)) 在许多印刷和手写形式中难以区分。

+   `5` / `S` - 在某些字体中，数字 `5` 和字母 `S` 可能非常相似。

+   `2` / `Z` - 在手写形式中特别容易混淆。

+   `8` / `B` - 这些字符在书写不清或某些风格化字体中可能会混淆。

+   `6` / `G` - 在某些字体中这些字符可能会混淆。

+   `9` / `q` / `g` - 在某些字体中这些字符可能会混淆。

它们在数据输入时引起混淆和错误，特别是在手写或字体不清晰的情况下。例如，如果用户试图输入包含字母 'O' 和数字 '0' 的代码，他们可能无法确定哪个字符是哪个。这导致令人沮丧的用户体验。

使用不同系统字体的几个示例：

+   9qg6G8B2Z5SIl170O (arial)

+   9qg6G8B2Z5SIl170O (helvetica)

+   9qg6G8B2Z5SIl170O (courier)

+   9qg6G8B2Z5SIl170O (times)

+   9qg6G8B2Z5SIl170O (verdana)

+   9qg6G8B2Z5SIl170O (georgia)

+   9qg6G8B2Z5SIl170O (tahoma)

+   9qg6G8B2Z5SIl170O (impact)

+   9qg6G8B2Z5SIl170O (comic sans)

有些字符对在所有字体中都视觉上有歧义（例如 `I` 和 `l`），而其他字符在手写形式中更难以区分，例如试着自己手写 `9qg`。

每当需要口头或书面传达ID时，例如

+   客户支持

+   折扣码

+   追踪代码

+   错误ID

+   产品ID

+   等等。

您还可以考虑您的ID是否应区分大小写。`abc` 是否等同于 `ABC`？

假设您选择区分大小写，您有53个字符可供选择（考虑到视觉上的歧义字符）。另一方面，如果您决定使您的ID不区分大小写，您只有22个字符可供选择。

假设ID长度为5个字符，您有以下可能的ID数量：

+   区分大小写：53^5 = 418,195,493

+   不区分大小写：22^5 = 5,153,632

然而，随着集合中成员数量的增加，可能的ID数量呈指数增长。

+   区分大小写：53^8 = 62,259,690,411,361

+   不区分大小写：22^8 = 54,875,873,536

因此，真正的问题是，是更短的 ID，但视觉上的混淆可能性更高，还是更长的 ID，但视觉上的混淆可能性更低，更为可取。

正如一个 Hacker News 评论 ^([2](#user-content-fn-2)) 指出的，如果同时使用大小写，你可能最终会被一些大小写不敏感的第三方系统或协议所惊讶。

> 我甚至发现了一个商业系统，允许用户选择区分大小写的 ID（例如 iD 和 id 是不同的），但如果查询不存在的 ID，则会执行大小写不敏感匹配并返回错误的数据。
> 
> 当我报告这个错误时，他们说这是为了方便！

出于可读性的考虑，这是我在项目中生成 ID 时使用的字符集：

```
[
 "a",
 "b",
 "c",
 "d",
 "e",
 "f",
 "h",
 "i",
 "j",
 "k",
 "m",
 "n",
 "o",
 "p",
 "r",
 "s",
 "t",
 "w",
 "x",
 "y",
 "3",
 "4"
]
```

+   `rn`（看起来像 `m`） ^([3](#user-content-fn-3))

+   `vv`（看起来像 `w`） ^([4](#user-content-fn-4))

就个人偏好而言，我会谨慎地排除某些看起来像其他字符组合的字符。在生成 ID 的级别上避免这些特定组合可能是个好主意。

在某些情况下，您可能还希望避免在口头沟通时听起来相似的字符。例如，`b` 和 `p` 在口语中可能听起来相似。这在口头传达 ID 的情况下尤为重要。

Crockford 的 [Base32](https://www.crockford.com/base32.html)（与 [IETF Base32](https://www.rfc-editor.org/rfc/rfc4648#page-8) 不同）

> 这采用的方法允许通过将其解码为相同值来处理模棱两可的字符，并且还考虑了意外的不雅用语问题。

[开放地理编码（Open Location Code）](https://github.com/google/open-location-code)

> 我喜欢在需要类似字符集时使用的是 Open Location Code 使用的字符集，其中包括 23456789CFGHJMPQRVWX。显然，这些字符不仅避免视觉上的混淆，还避免了在 [常见语言中拼写单词](https://github.com/google/open-location-code/wiki/Evaluation-of-Location-Encoding-Systems#open-location-code)。然而，它确实包含了 6 和 G，以及 9 和 Q。
