<!--yml

category: 未分类

date: 2024-05-27 13:41:38

-->

# 为什么 SQLite 使用字节码

> 来源：[https://sqlite.org/draft/whybytecode.html](https://sqlite.org/draft/whybytecode.html)

# 1\. 引言

每个 SQL 数据库引擎的工作方式大致相同：它首先将输入的 SQL 文本转换成一个“准备好的语句”。然后执行准备好的语句以生成结果。

准备好的语句是一个对象，表示完成输入 SQL 所需的步骤。或者，换一种方式来思考，准备好的语句是将 SQL 语句翻译成计算机更易理解的形式。

在 SQLite 中，准备好的语句是 [sqlite3_stmt 对象](c3ref/stmt.html)的一个实例。在其他系统中，准备好的语句通常是一个内部数据结构，不直接对应应用程序员可见。其他 SQL 数据库引擎的开发者未必称这些对象为“准备好的语句”。但无论它们如何被称呼，这些对象都是存在的。本文将使用术语“准备好的语句”。

有无数种实现准备好的语句的方法。本文将讨论两种最常见的方法：

1.  **字节码** → 输入的 SQL 被翻译成一个虚拟机语言，然后由虚拟机解释器运行。这是 SQLite 使用的技术。

1.  **对象树** → 输入的 SQL 被翻译成一个对象树，表示要执行的处理过程。SQL 通过遍历这棵树来执行。这是 MySQL 和 PostgreSQL 使用的技术。

每种准备好的语句表示方法都有其优势和劣势。本文的目的是阐述其中一些优势和劣势。

## 1.1\. 如何提供反馈

本文是从 SQLite 的原始作者的角度编写的。如果您对本文提出的任何观点持不同意见，欢迎在 [SQLite 论坛](https://sqlite.org/forum) 提出更正和/或相反的观点。或者您也可以直接邮件联系作者。

## 1.2\. "字节码" 的定义

由 SQLite 生成的 [字节码](opcode.html) 可能与许多读者所认知的字节码有些许不同。例如，[Java 虚拟机](https://en.wikipedia.org/wiki/Java_virtual_machine) 或 [WebAssembly](https://en.wikipedia.org/wiki/WebAssembly) 使用的字节码几乎完全由低级操作组成，类似于物理 CPU 实现的基本数学运算符、比较、条件跳转以及在不同内存位置之间移动内容的指令。SQLite 的字节码也包含一些高级操作，这些操作特定于数据库引擎的需求。以下仅列举了一些示例：

+   **OP_Column** → 从特定游标当前指向的数据库行中提取第 N 列的值。

+   **OP_CreateBtree** → 在数据库文件中为新的B-Tree分配空间。

+   **OP_ParseSchema** → 重新读取并重新解析全部或部分[sqlite_schema表](schematab.html)，并相应地刷新内部符号表。

+   **OP_SeekGE** → 将光标移动到特定B-Tree上第一个大于或等于给定键的条目。

+   **OP_Next** → 将特定B-Tree上的光标移动到B-Tree中的下一个条目，并跳转，如果该B-Tree中没有更多条目，则跳过。

换句话说，SQLite使用的“字节码”更像是一组要按特定顺序运行的数据库原语，而不是一组CPU指令。

## 1.3\. "抽象语法树"或"AST"的定义

"[抽象语法树](https://en.wikipedia.org/wiki/Abstract_syntax_tree)"或AST是描述某种形式语言中程序或语句的数据结构。在我们的上下文中，形式语言是SQL。AST通常实现为对象树，其中每个对象代表整体SQL语句的一个小部分。AST是形式语言解析器的自然产物。通常的技术是使用[LALR(1)解析器](https://en.wikipedia.org/wiki/LALR_parser)。使用这样的解析器，每个终结符号保存将成为AST叶子的元数据，每个非终结符号保存将成为整体AST子分支的元数据。随着解析器“减少”语法规则，AST的新节点被分配并连接到子节点。解析完成后，语法的起始符号将保留AST的根。

AST是一组对象的树。但AST不是预处理语句的合适形式。生成AST后，首先需要以各种方式对其进行转换，然后才能执行。需要解析符号、检查语义规则，并应用能够将输入SQL语句转换为更快执行的不同形式的优化。最后，AST需要转换为更适合执行的另一种表示形式。

有些人将MySQL和PostgreSQL中用作可执行形式的对象树称为AST。这可能是对术语"AST"的误用，因为在准备好执行的对象树被修改多次后，它与原始SQL文本几乎没有相似之处。混淆的部分在于最终的准备好的语句对象和原始AST都是对象树。通常的技术是原始AST直接从解析器中出来后，逐渐进行多次转换，直到最后完全转换为一个对象树，它不再严格是AST，但可以评估生成结果。在此过程中，并没有明确的时刻标明对象树何时不再是AST，而成为一个准备好的语句。因为AST和准备好的语句之间没有明确的边界，所以人们经常将表示为对象树的准备好的语句称为"AST"，即使这种描述并不精确。

## 1.4\. 数据流编程

[数据流编程](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BC%96%E7%A8%8B)是一种编程风格，其中各个节点专门负责整体计算中的一个小部分。每个节点从其他节点接收输入并将其输出发送到其他节点。因此，节点形成一个有向图，将输入转换为输出。

"数据流程序"或许比"AST"更好地描述了SQL数据库引擎作为准备好的语句使用的对象树。

# 2\. 将编译为字节码的优势

SQLite编译为字节码，SQLite开发人员对这种方法非常满意。以下是原因：

## 2.1\. 字节码更易于理解

一系列操作码可以轻松打印，以准确查看SQL语句的实现方式。在SQLite中，当您在SQL语句前加上"EXPLAIN"关键字时，就会发生这种情况：不实际运行SQL，而是得到一个显示将用于实现该SQL的字节码列表。

字节码很适合这样做，因为字节码程序很容易表示为一张表格。在SQLite的字节码中，每个指令有一个操作码和五个操作数。因此，一个准备好的语句可以被呈现为针对一个六列表的查询。

将对象树表示为表格形式更难以以人类可读的形式发布。构成对象树的对象往往非常不同，因此很难想出一种一致和简单的表格表示方法来显示这些对象。无论您想出的任何这样的表格表示方法几乎肯定会有超过六列，可能会更多。将对象树渲染为表格的问题足够困难，以至于据我所知没有人这样做。因此，没有对象树数据库引擎提供SQLite提供的"EXPLAIN"输出中的详细级别。

## 2.2\. 字节码更容易调试

字节码提供了前端解析和分析与后端评估 SQL 语句之间的清晰分离。当出现问题（答案不正确和/或性能差）时，开发人员可以检查字节码，快速确定问题的根源是产品的前端分析还是后端数据存储部分。

在 SQLite 的调试版本中，执行 [PRAGMA vdbe_trace=ON;](pragma.html#pragma_vdbe_trace) 命令将导致在控制台上显示字节码执行的跟踪信息。

## 2.3\. 字节码可以逐步运行

使用字节码编写的 SQL 语句可以逐步评估。例如，可以运行语句直到仅生成其第一行输出。然后语句暂停，直到再次步进。在检查第一行输出之前，无需运行语句完成。

在对象树设计中，这更难以实现。当准备好的语句是对象树时，执行通常通过遍历树来完成。要在计算过程中暂停语句意味着将堆栈展开回调用者，同时保存足够的状态以便在上次停止的地方恢复评估。这并不是不可能做到的，但足够困难，我从未见过实际完成。

大多数 SQL 数据库引擎实际上不需要对准备好的语句进行增量执行，因为大多数 SQL 数据库引擎是客户端/服务器模式。在客户端/服务器引擎中，单个 SQL 语句被发送到服务器，然后完整的回复一次性通过网络返回。因此，每个语句都在一次执行中完成。但 SQLite 不是客户端/服务器。SQLite 是在同一个地址空间和使用同一堆栈的应用程序中运行的库。能够轻松和可靠地执行 SQL 语句的增量执行对于 SQLite 非常重要。

## 2.4\. 字节码更小

SQLite 生成的字节码通常比解析器输出的相应 AST 小。在 SQL 文本的初始处理过程中（在调用 [sqlite3_prepare()](c3ref/prepare.html) 和类似函数时），AST 和字节码同时存在于内存中，因此会使用更多内存。但这是短暂的状态。AST 很快被丢弃并回收其内存，甚至在 [sqlite3_prepare()](c3ref/prepare.html) 返回之前，因此生成的 [prepared statement](c3ref/stmt.html) 以其字节码表示消耗的内存比作为 AST 时少。这很重要，因为对 [sqlite3_prepare()](c3ref/prepare.html) 的调用是短暂的，但准备好的语句通常会被缓存以便可能的重用，并且在内存中长时间存在。

## 2.5\. 字节码更快

我*相信*，准备语句的字节码表示运行速度更快，因为每个计算步骤需要做出的决策更少。在上一句中强调“相信” → 实验上很难验证这一说法，因为没有人愿意投入多年的努力来生成等效的字节码和对象树表示的准备语句，以查看到底哪种运行速度更快。我们知道[SQLite 非常快](fasterthanfs.html)，但是我们没有与其他 SQL 数据库进行过良好的并行比较，因为其他数据库花费大量时间在客户端/服务器消息处理上，很难将消息往返开销与实际处理时间分开。

# 3\. 将编译为对象树的优势

SQLite 的开发人员认为字节码方法最佳，至少对于 SQLite 尝试填补的用例来说是如此，但对象树方法在处理 SQL 时确实具有一些优势。总是存在权衡。

## 3.1\. 查询计划决策可以推迟到运行时

当准备语句是字节码时，一旦生成了字节码，算法就固定了，不能在完全重写字节码的情况下进行后续更改。而对象树准备语句则不同。对象树易于即时修改。查询计划是可变的，并且可以根据查询的进展进行调整。因此，查询可以动态自我调整。

## 3.2\. 数据流程序易于并行化

在数据流程序中，每个处理节点可以分配给不同的线程。需要某种线程安全的队列机制来传输从一个节点到下一个节点的中间结果。但通常在程序的每个节点内部不需要同步原语。节点调度是简单的：当节点有可用数据并且其输出队列有空间时，节点就有资格运行。

对于设计用于在大型多核服务器上运行大型分析查询（[OLAP](https://en.wikipedia.org/wiki/Online_analytical_processing)）的数据库引擎，这是一个重要考虑因素。SQLite 的主要重点是在物联网上进行事务处理（[OLTP](https://en.wikipedia.org/wiki/Online_transaction_processing)），因此在 SQLite 中不需要将准备语句表示为数据流程序。
