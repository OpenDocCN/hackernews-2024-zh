- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: æœªåˆ†ç±»'
- en: 'date: 2024-05-27 13:39:13'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 13:39:13'
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: A brief history of web development. And why your framework doesn't matter.
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç½‘é¡µå‘å±•ç®€å²åŠä¸ºä½•ä½ çš„æ¡†æ¶å¹¶ä¸é‡è¦ã€‚
- en: æ¥æºï¼š[https://gebna.gg/blog/brief-history-of-web-development](https://gebna.gg/blog/brief-history-of-web-development)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://gebna.gg/blog/brief-history-of-web-development](https://gebna.gg/blog/brief-history-of-web-development)
- en: A brief history of web development. And why your framework doesn't matter.
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç½‘é¡µå‘å±•ç®€å²åŠä¸ºä½•ä½ çš„æ¡†æ¶å¹¶ä¸é‡è¦ã€‚
- en: '2024-04-25'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '2024-04-25'
- en: History is very important. It helps keep our perspectives in check. This is
    how I remember the crazy journey that web development has gone through in the
    past few years. This is my telling of it. So I will omit events. I may mess up
    the timeline. This whole article may not be of any use to you. But for me, putting
    all of it into writing helped me appreciate how much things stay the same no matter
    how much they change. So if youâ€™re curious and undeterred, allow me to start with
    â€¦
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: å†å²éå¸¸é‡è¦ã€‚å®ƒæœ‰åŠ©äºä¿æŒæˆ‘ä»¬çš„è§†è§’ã€‚è¿™æ˜¯æˆ‘è®°å¾— Web å¼€å‘åœ¨è¿‡å»å‡ å¹´ä¸­æ‰€ç»å†çš„ç–¯ç‹‚æ—…ç¨‹çš„æ–¹å¼ã€‚è¿™æ˜¯æˆ‘çš„è®²è¿°ã€‚æ‰€ä»¥æˆ‘ä¼šçœç•¥äº‹ä»¶ã€‚æˆ‘å¯èƒ½å¼„ä¹±æ—¶é—´çº¿ã€‚æ•´ç¯‡æ–‡ç« å¯èƒ½å¯¹ä½ æ²¡æœ‰ä»»ä½•ç”¨å¤„ã€‚ä½†å¯¹æˆ‘æ¥è¯´ï¼ŒæŠŠæ‰€æœ‰è¿™äº›éƒ½å†™ä¸‹æ¥å¸®åŠ©æˆ‘æ¬£èµåˆ°äº‹ç‰©æ— è®ºå¦‚ä½•éƒ½ä¼šä¿æŒä¸å˜çš„ç¨‹åº¦ã€‚æ‰€ä»¥ï¼Œå¦‚æœä½ å¥½å¥‡è€Œä¸”æ¯«ä¸ç•æƒ§ï¼Œè®©æˆ‘ä»â€¦å¼€å§‹å§ã€‚
- en: The good olâ€™ days
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è¿‡å»çš„ç¾å¥½æ—¶å…‰
- en: The simplest architecture to build a website would be to have one server to
    handle everything. That means that thereâ€™s no frontend router, no hydration, no
    AJAX, and definitely no cache/store like [Apollo](https://www.apollographql.com/)
    or [Redux](https://redux.js.org/). Itâ€™s very simple, the user requests an HTML
    page, the user gets an HTML page back. Oh and mutations will all be handled by
    native HTML forms. This used to be how everything worked. Not much JavaScript
    was written. Just whatever language you picked for backend and HTML/CSS. This
    worked because the web was made to be a decentralized space for sharing information.
    The websites made in those days were very static in nature and very little mutations
    happened so it was fine for the page to refresh after each form submission. It
    was also fine to load an entirely new HTML document every time the user navigated
    to another page.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: æ­å»ºç½‘ç«™æœ€ç®€å•çš„æ¶æ„å°±æ˜¯åªæœ‰ä¸€ä¸ªæœåŠ¡å™¨å¤„ç†ä¸€åˆ‡ã€‚è¿™æ„å‘³ç€æ²¡æœ‰å‰ç«¯è·¯ç”±å™¨ï¼Œæ²¡æœ‰æ°´åˆï¼Œæ²¡æœ‰ AJAXï¼Œå½“ç„¶ä¹Ÿæ²¡æœ‰åƒ[Apollo](https://www.apollographql.com/)æˆ–[Redux](https://redux.js.org/)è¿™æ ·çš„ç¼“å­˜/å­˜å‚¨ã€‚éå¸¸ç®€å•ï¼Œç”¨æˆ·è¯·æ±‚ä¸€ä¸ª
    HTML é¡µé¢ï¼Œç”¨æˆ·å¾—åˆ°ä¸€ä¸ª HTML é¡µé¢ã€‚å“¦ï¼Œè€Œä¸”æ‰€æœ‰çš„å˜æ›´éƒ½å°†ç”±åŸç”Ÿ HTML è¡¨å•å¤„ç†ã€‚è¿™æ›¾ç»æ˜¯ä¸€åˆ‡è¿ä½œçš„æ–¹å¼ã€‚å‡ ä¹æ²¡æœ‰å†™ JavaScriptã€‚åªéœ€é€‰æ‹©åç«¯è¯­è¨€å’Œ
    HTML/CSSã€‚è¿™æ˜¯å› ä¸º Web è¢«è®¾è®¡ä¸ºä¸€ä¸ªå»ä¸­å¿ƒåŒ–çš„ä¿¡æ¯å…±äº«ç©ºé—´ã€‚é‚£äº›å¹´åˆ¶ä½œçš„ç½‘ç«™åœ¨æ€§è´¨ä¸Šéå¸¸é™æ€ï¼Œå¾ˆå°‘å‘ç”Ÿå˜æ›´ï¼Œæ‰€ä»¥åœ¨æ¯æ¬¡è¡¨å•æäº¤ååˆ·æ–°é¡µé¢æ˜¯å¯ä»¥æ¥å—çš„ã€‚æ¯æ¬¡ç”¨æˆ·å¯¼èˆªåˆ°å¦ä¸€ä¸ªé¡µé¢æ—¶åŠ è½½å®Œå…¨æ–°çš„
    HTML æ–‡æ¡£ä¹Ÿæ˜¯å¯ä»¥æ¥å—çš„ã€‚
- en: But then the web started to change. Websites started becoming more and more
    like apps. More functionality was needed on the client side. So more JavaScript
    was written. Browser APIs were not enough so [jQuery](https://jquery.com/) was
    made. And before we knew it, the language that was made to display sparkles and
    counters on websites took over everything and we started writing single page applications
    or SPAs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯éšç€Webçš„å˜åŒ–ï¼Œç½‘ç«™å¼€å§‹å˜å¾—è¶Šæ¥è¶Šåƒåº”ç”¨ç¨‹åºã€‚å®¢æˆ·ç«¯éœ€è¦æ›´å¤šåŠŸèƒ½ã€‚å› æ­¤ï¼Œå†™äº†æ›´å¤šJavaScriptä»£ç ã€‚æµè§ˆå™¨APIå·²ç»ä¸å¤Ÿç”¨äº†ï¼Œæ‰€ä»¥è¯ç”Ÿäº†[jQuery](https://jquery.com/)ã€‚ç„¶åæˆ‘ä»¬æ„è¯†åˆ°ï¼Œæœ¬æ¥æ˜¯ä¸ºç½‘ç«™ä¸Šçš„é—ªå…‰å’Œè®¡æ•°å™¨è®¾è®¡çš„è¯­è¨€å´æ¨ªæ‰«äº†ä¸€åˆ‡ï¼Œæˆ‘ä»¬å¼€å§‹ç¼–å†™å•é¡µåº”ç”¨ç¨‹åºæˆ–SPAã€‚
- en: Not the SPA youâ€™re thinking of
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ä¸æ˜¯ä½ æƒ³è±¡ä¸­çš„SPA
- en: A SPA basically absolves the backend of itsâ€™ HTML/CSS duties. Servers donâ€™t
    return HTML anymore. They expose REST endpoints. Each one returns JSON in response.
    In SPAs, when the user requests `yourdomain.com/any-thing`, the server responds
    with an empty HTML document that has a JavaScript that then takes over. The frontend
    handles fetching data, rendering html pages, and routing between them. This is
    when frameworks like [Knockout.js](https://knockoutjs.com/), [Backbone.js](https://backbonejs.org/),
    and [Angular.js](https://angularjs.org/) were released (late 2010). Three years
    later, React was released with itsâ€™ JSX syntax and one way data-binding. And it
    made writing web apps easier than ever. Or so we thought.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SPAåŸºæœ¬ä¸Šè§£é™¤äº†åç«¯å¯¹HTML/CSSçš„èŒè´£ã€‚æœåŠ¡å™¨ä¸å†è¿”å›HTMLã€‚å®ƒä»¬æš´éœ²RESTç«¯ç‚¹ã€‚æ¯ä¸ªç«¯ç‚¹è¿”å›JSONä½œä¸ºå“åº”ã€‚åœ¨SPAä¸­ï¼Œå½“ç”¨æˆ·è¯·æ±‚`yourdomain.com/any-thing`æ—¶ï¼ŒæœåŠ¡å™¨ä¼šè¿”å›ä¸€ä¸ªç©ºçš„HTMLæ–‡æ¡£ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªæ¥ç®¡æ§åˆ¶æƒçš„JavaScriptã€‚å‰ç«¯è´Ÿè´£è·å–æ•°æ®ã€æ¸²æŸ“HTMLé¡µé¢å’Œé¡µé¢é—´çš„è·¯ç”±ã€‚è¿™å°±æ˜¯åƒ[Knockout.js](https://knockoutjs.com/)ã€[Backbone.js](https://backbonejs.org/)å’Œ[Angular.js](https://angularjs.org/)è¿™æ ·çš„æ¡†æ¶é—®ä¸–çš„æ—¶å€™ï¼ˆ2010å¹´æœ«ï¼‰ã€‚ä¸‰å¹´åï¼Œå¸¦æœ‰JSXè¯­æ³•å’Œå•å‘æ•°æ®ç»‘å®šçš„Reacté—®ä¸–äº†ã€‚å®ƒä½¿å¾—ç¼–å†™Webåº”ç”¨æ¯”ä»¥å¾€ä»»ä½•æ—¶å€™éƒ½æ›´å®¹æ˜“ã€‚æˆ–è€…æˆ‘ä»¬æ›¾ç»è¿™æ ·è®¤ä¸ºã€‚
- en: If a user submits a form, they donâ€™t expect the page to refresh anymore. Since
    itâ€™s an *app*, it should behave like one. If the data mutates, new data should
    just appear. Meaning developers had to write code to maintain *state* and *react*
    to any change in the state by *re-rendering* parts of the HTML accordingly. Imagine
    the poor frontend devs doing that in a large scale app like **Facebook** with
    so many moving parts to take care of. Imagine the poor backend devs needing to
    create numerous REST endpoints to accommodate all that functionality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœç”¨æˆ·æäº¤è¡¨å•ï¼Œä»–ä»¬ä¸å†å¸Œæœ›é¡µé¢åˆ·æ–°ã€‚å› ä¸ºè¿™æ˜¯ä¸€ä¸ª*åº”ç”¨ç¨‹åº*ï¼Œå®ƒåº”è¯¥åƒä¸€ä¸ªåº”ç”¨ç¨‹åºä¸€æ ·è¿è¡Œã€‚å¦‚æœæ•°æ®å‘ç”Ÿå˜åŒ–ï¼Œæ–°æ•°æ®åº”è¯¥è‡ªåŠ¨æ˜¾ç¤ºã€‚è¿™æ„å‘³ç€å¼€å‘äººå‘˜å¿…é¡»ç¼–å†™ä»£ç æ¥ç»´æŠ¤*çŠ¶æ€*ï¼Œå¹¶å¯¹çŠ¶æ€çš„ä»»ä½•æ›´æ”¹åšå‡º*é‡æ–°æ¸²æŸ“*ç›¸åº”HTMLéƒ¨åˆ†çš„ååº”ã€‚æƒ³è±¡ä¸€ä¸‹åœ¨åƒ**Facebook**è¿™æ ·å¤§è§„æ¨¡åº”ç”¨ä¸­è´Ÿè´£è¿™äº›åŠ¨æ€éƒ¨åˆ†çš„å‰ç«¯å¼€å‘äººå‘˜ã€‚æƒ³è±¡ä¸€ä¸‹éœ€è¦åˆ›å»ºå¤§é‡RESTç«¯ç‚¹ä»¥é€‚åº”æ‰€æœ‰åŠŸèƒ½çš„åç«¯å¼€å‘äººå‘˜çš„å¤„å¢ƒã€‚
- en: Facebook
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Facebook
- en: Say youâ€™re a frontend dev in the ads team at Facebook. A new feature is proposed
    by the product manager, you go through the requirements they wrote and you start
    implementing. You know the feature is going to need access to some data from the
    backend but youâ€™re at ease because your backend REST endpoints are well documented.
    You search the API docs, and you find a couple APIs that seem to fit what you
    need. You start writing your frontend code to find out that the docs are outdated
    and one of endpoints has been removed because itâ€™s no longer in use. You let your
    project manager know and they assign a backend dev to work with you. After a couple
    days of waiting, they message you saying they added the endpoint you needed. You
    thank them and continue implementing the feature only to run into another problem.
    The *other* endpoint returns way too much data and is way too slow to be used
    within the context of the new feature youâ€™re implementing. Oh and the product
    manager messaged you saying that requirements changed. So you repeat the previous
    cycle all over again.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ æ˜¯ Facebook å¹¿å‘Šå›¢é˜Ÿçš„å‰ç«¯å¼€å‘å·¥ç¨‹å¸ˆã€‚äº§å“ç»ç†æå‡ºäº†ä¸€ä¸ªæ–°åŠŸèƒ½ï¼Œä½ æŸ¥é˜…ä»–ä»¬æ’°å†™çš„éœ€æ±‚å¹¶å¼€å§‹å®ç°ã€‚ä½ çŸ¥é“è¯¥åŠŸèƒ½éœ€è¦è®¿é—®åç«¯çš„ä¸€äº›æ•°æ®ï¼Œä½†ä½ æ”¾å¿ƒï¼Œå› ä¸ºä½ çš„åç«¯
    REST ç«¯ç‚¹æœ‰å¾ˆå¥½çš„æ–‡æ¡£ã€‚ä½ æœç´¢ API æ–‡æ¡£ï¼Œæ‰¾åˆ°äº†å‡ ä¸ªçœ‹ä¼¼ç¬¦åˆä½ éœ€æ±‚çš„ APIã€‚ä½ å¼€å§‹ç¼–å†™å‰ç«¯ä»£ç ï¼Œç»“æœå‘ç°æ–‡æ¡£å·²ç»è¿‡æ—¶ï¼Œå¹¶ä¸”å…¶ä¸­ä¸€ä¸ªç«¯ç‚¹å·²è¢«ç§»é™¤ï¼Œå› ä¸ºä¸å†ä½¿ç”¨ã€‚ä½ é€šçŸ¥é¡¹ç›®ç»ç†ï¼Œå¹¶ä»–ä»¬æŒ‡æ´¾ä¸€ä¸ªåç«¯å¼€å‘ä¸ä½ åˆä½œã€‚å‡ å¤©åï¼Œä»–ä»¬é€šçŸ¥ä½ è¯´ä»–ä»¬æ·»åŠ äº†ä½ æ‰€éœ€çš„ç«¯ç‚¹ã€‚ä½ æ„Ÿè°¢ä»–ä»¬ï¼Œç»§ç»­å®ç°åŠŸèƒ½ï¼Œä½†åˆé‡åˆ°äº†å¦ä¸€ä¸ªé—®é¢˜ã€‚*å¦ä¸€ä¸ª*ç«¯ç‚¹è¿”å›çš„æ•°æ®é‡è¿‡å¤§ï¼Œåœ¨æ–°åŠŸèƒ½çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨èµ·æ¥å¤ªæ…¢äº†ã€‚è€Œä¸”äº§å“ç»ç†å‘æ¶ˆæ¯è¯´éœ€æ±‚å˜äº†ã€‚æ‰€ä»¥ä½ é‡æ–°å¼€å§‹ä¹‹å‰çš„å¾ªç¯ã€‚
- en: 'What went wrong there ? a few things, but Iâ€™ll focus on two:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£é‡Œå‡ºäº†ä»€ä¹ˆé—®é¢˜ï¼Ÿæœ‰å‡ ä¸ªé—®é¢˜ï¼Œä½†æˆ‘å°†é‡ç‚¹å…³æ³¨ä¸¤ä¸ªï¼š
- en: The API endpoints and there documentation are two separate things and so they
    can go out of sync.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API ç«¯ç‚¹å’Œå®ƒä»¬çš„æ–‡æ¡£æ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„äº‹ç‰©ï¼Œå› æ­¤å®ƒä»¬å¯èƒ½ä¸åŒæ­¥ã€‚
- en: Thereâ€™s no runtime guarantee that the API returns what it should. Essentially
    thereâ€™s no strict contract between the server and the client. It can return any
    JSON and the response will still be 200 OK.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¹¶æ²¡æœ‰è¿è¡Œæ—¶ä¿è¯ API è¿”å›å…¶åº”è¯¥è¿”å›çš„å†…å®¹ã€‚å®è´¨ä¸Šï¼ŒæœåŠ¡å™¨ä¸å®¢æˆ·ç«¯ä¹‹é—´æ²¡æœ‰ä¸¥æ ¼çš„å¥‘çº¦ã€‚å®ƒå¯ä»¥è¿”å›ä»»ä½• JSON æ•°æ®ï¼Œå“åº”ä»å°†æ˜¯ 200 OKã€‚
- en: Now you can probably solve the problems above by writing more automated tests
    and/or investing in doc-gen tools like [Swagger](https://swagger.io/). But these
    things treat the symptoms (bugs) while not curing the disease (lack of contract).
    So in 2012, Facebook engineers thought of something better.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä½ å¯ä»¥é€šè¿‡ç¼–å†™æ›´å¤šè‡ªåŠ¨åŒ–æµ‹è¯•å’Œ/æˆ–æŠ•èµ„äºç±»ä¼¼ [Swagger](https://swagger.io/) çš„æ–‡æ¡£ç”Ÿæˆå·¥å…·æ¥è§£å†³ä¸Šè¿°é—®é¢˜ã€‚ä½†è¿™äº›æ–¹æ³•åªèƒ½æ²»æ ‡ï¼ˆä¿®å¤
    bugï¼‰ï¼Œè€Œä¸èƒ½æ²»æœ¬ï¼ˆç¼ºä¹çº¦å®šï¼‰ã€‚å› æ­¤åœ¨ 2012 å¹´ï¼ŒFacebook çš„å·¥ç¨‹å¸ˆä»¬æƒ³å‡ºäº†æ›´å¥½çš„æ–¹æ³•ã€‚
- en: GraphQL
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL
- en: '[GraphQL](https://graphql.org/) fixes the above problems by changing APIs from
    a set of untyped REST endpoints like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[GraphQL](https://graphql.org/) é€šè¿‡å°† API ä»ä¸€ç»„ä¸å¸¦ç±»å‹çš„ REST ç«¯ç‚¹æ”¹ä¸ºä¸¥æ ¼ç±»å‹åŒ–çš„å¯æŸ¥è¯¢æ¨¡å¼æ¥è§£å†³ä¸Šè¿°é—®é¢˜ï¼š'
- en: '`GET /posts`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /posts`'
- en: '`POST /posts`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /posts`'
- en: '`GET /posts/:id`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /posts/:id`'
- en: '`DELETE /posts/:id`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /posts/:id`'
- en: 'To a strictly typed, queryable schema like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: è½¬å˜ä¸ºä¸¥æ ¼ç±»å‹åŒ–ã€å¯æŸ¥è¯¢çš„æ¨¡å¼ï¼š
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now because the GraphQL server always checks coming requests and outgoing responses
    against the schema we define, we now have our contract, our runtime guarantee
    that the frontend is only requesting fields that exist and the backend will either
    respond with them or with an error. A few positive side effects of this design
    are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å› ä¸º GraphQL æœåŠ¡å™¨å§‹ç»ˆæ ¹æ®æˆ‘ä»¬å®šä¹‰çš„æ¨¡å¼æ£€æŸ¥ä¼ å…¥è¯·æ±‚å’Œä¼ å‡ºå“åº”ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰äº†æˆ‘ä»¬çš„åˆåŒï¼Œæˆ‘ä»¬çš„è¿è¡Œæ—¶ä¿è¯ï¼šå‰ç«¯åªè¯·æ±‚å­˜åœ¨çš„å­—æ®µï¼Œåç«¯å°†ç”¨è¿™äº›å­—æ®µå›åº”æˆ–è€…è¿”å›é”™è¯¯ã€‚è¿™ç§è®¾è®¡çš„ä¸€äº›ç§¯æå‰¯ä½œç”¨åŒ…æ‹¬ï¼š
- en: No need for explicit documentation anymore. The schema is most of the documentation
    you need. And itâ€™s always up to date.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸å†éœ€è¦æ˜¾å¼æ–‡æ¡£ã€‚æ¨¡å¼å°±æ˜¯ä½ æ‰€éœ€çš„å¤§éƒ¨åˆ†æ–‡æ¡£ã€‚è€Œä¸”å®ƒå§‹ç»ˆä¿æŒæœ€æ–°ã€‚
- en: The client can pick precisely the fields they need. No need to request the entire
    `User` object if you just need `id` and a `username`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®¢æˆ·ç«¯å¯ä»¥ç²¾ç¡®é€‰æ‹©ä»–ä»¬æ‰€éœ€çš„å­—æ®µã€‚å¦‚æœä½ åªéœ€è¦ `id` å’Œ `username`ï¼Œå°±æ— éœ€è¯·æ±‚æ•´ä¸ª`User`å¯¹è±¡ã€‚
- en: Frontend state management becomes way simpler thanks to GraphQL clients like
    [Relay](https://relay.dev/), [Urql](https://commerce.nearform.com/open-source/urql/docs/),
    And [Apollo](https://www.apollographql.com/).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‰ç«¯çŠ¶æ€ç®¡ç†å›  GraphQL å®¢æˆ·ç«¯ï¼ˆä¾‹å¦‚ [Relay](https://relay.dev/)ï¼Œ[Urql](https://commerce.nearform.com/open-source/urql/docs/)
    å’Œ [Apollo](https://www.apollographql.com/)ï¼‰å˜å¾—æ›´ç®€å•ã€‚
- en: So thatâ€™s it. A SPA frontend that is powered by a GraphQL server. Thatâ€™s the
    *ideal* architecture for **every** web app. I mean, Facebook uses it so it must
    be the best option right ? â€¦ right ?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: å°±æ˜¯è¿™æ ·ã€‚ä¸€ä¸ªç”± GraphQL æœåŠ¡å™¨é©±åŠ¨çš„å•é¡µåº”ç”¨å‰ç«¯ã€‚è¿™æ˜¯æ¯ä¸ª Web åº”ç”¨çš„*ç†æƒ³*æ¶æ„ã€‚æˆ‘çš„æ„æ€æ˜¯ï¼ŒFacebook ä½¿ç”¨å®ƒï¼Œæ‰€ä»¥è¿™ä¸€å®šæ˜¯æœ€ä½³é€‰æ‹©ï¼Œå¯¹å§ï¼Ÿâ€¦â€¦å¯¹å§ï¼Ÿ
- en: Remember websites ?
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è¿˜è®°å¾—ç½‘ç«™å—ï¼Ÿ
- en: What if one needs to create a blog ? Typically, all a blog has to do is show
    some markdown and be SEO friendly. SPAs were notoriously difficult for SEO crawlers
    to index because it takes a few more hundred milliseconds for JavaScript to render
    on the client. So what then ? Does one have to go back to [Wordpress](https://wordpress.org/)
    ?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæœ‰äººéœ€è¦åˆ›å»ºåšå®¢æ€ä¹ˆåŠï¼Ÿé€šå¸¸ï¼Œåšå®¢åªéœ€æ˜¾ç¤ºä¸€äº› Markdown å¹¶ä¸”å‹å¥½äº SEOã€‚å•é¡µåº”ç”¨åœ¨è¿‡å»å› ä¸ºéœ€è¦ JavaScript åœ¨å®¢æˆ·ç«¯æ¸²æŸ“ï¼Œæ‰€ä»¥è¢«
    SEO çˆ¬è™«éš¾ä»¥ç´¢å¼•ã€‚é‚£ä¹ˆç°åœ¨å‘¢ï¼Ÿéš¾é“ä¸€å®šè¦å›åˆ° [Wordpress](https://wordpress.org/) å—ï¼Ÿ
- en: '[**Atwoodâ€™s Law**](https://blog.codinghorror.com/the-principle-of-least-power/):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[**é˜¿ç‰¹ä¼å¾·æ³•åˆ™**](https://blog.codinghorror.com/the-principle-of-least-power/)ï¼š'
- en: Any application that *can* be written in JavaScript, *will* eventually be written
    in JavaScript.
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä»»ä½•å¯ä»¥ç”¨ JavaScript ç¼–å†™çš„åº”ç”¨ï¼Œæœ€ç»ˆéƒ½å°†ä¼šç”¨ JavaScript ç¼–å†™ã€‚
- en: By that point [Node.js](https://nodejs.org/) had picked up enough steam. We
    were beginning to see a new generation of tooling that was birthed from the idea
    that JavaScript is going to run **everywhere**. Not just the browser. Among these
    tools was [Gatsby](https://www.gatsbyjs.com/). It allowed you to write â€œwebsitesâ€
    in React. It came riding on a wave of â€œheadlessâ€ CMS startups that were trying
    to compete in this new market. All of a sudden we saw terms like â€[JAM stack](https://jamstack.org/)â€
    thrown around. All it meant is decoupling presentation from data. Which was not
    a new idea. It turned out to be a very short lived trend for JAM stack. Gatsby
    couldnâ€™t catch a break. Just as it was about to gain some traction as the defacto
    Node.js/React website generator, a new challenger approached.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°äº†é‚£ä¸ªæ—¶å€™ï¼Œ[Node.js](https://nodejs.org/) å·²ç»è¶³å¤Ÿç«çƒ­ã€‚æˆ‘ä»¬å¼€å§‹çœ‹åˆ°ä¸€ä¸ªæ–°ä¸€ä»£çš„å·¥å…·ï¼Œè¿™äº›å·¥å…·éƒ½æ˜¯åŸºäºâ€œJavaScriptå°†æ— å¤„ä¸åœ¨â€çš„ç†å¿µè¯ç”Ÿçš„ã€‚ä¸ä»…ä»…æ˜¯æµè§ˆå™¨ã€‚åœ¨è¿™äº›å·¥å…·ä¸­ï¼Œ[Gatsby](https://www.gatsbyjs.com/)
    å°±æ˜¯å…¶ä¸­ä¹‹ä¸€ã€‚å®ƒè®©ä½ å¯ä»¥ç”¨Reactæ¥å†™â€œç½‘ç«™â€ã€‚å®ƒéšç€ä¸€æ³¢â€œæ— å¤´â€CMSåˆåˆ›å…¬å¸çš„å…´èµ·è€Œæ¥ã€‚çªç„¶ä¹‹é—´ï¼Œæˆ‘ä»¬å¼€å§‹å¬åˆ°åƒâ€œ[JAM stack](https://jamstack.org/)â€è¿™æ ·çš„æœ¯è¯­ã€‚æ‰€æœ‰å®ƒæ‰€ä»£è¡¨çš„å°±æ˜¯å°†å±•ç¤ºä¸æ•°æ®è§£è€¦ã€‚è¿™å¹¶ä¸æ˜¯ä¸€ä¸ªæ–°æ¦‚å¿µã€‚å¯¹äºJAM
    stackæ¥è¯´ï¼Œè¿™å¾ˆå¿«å°±å˜æˆäº†ä¸€ä¸ªéå¸¸çŸ­æš‚çš„æ½®æµã€‚Gatsbyå§‹ç»ˆéš¾ä»¥çªå›´ã€‚æ­£å½“å®ƒå¿«è¦æˆä¸ºäº‹å®ä¸Šçš„Node.js/Reactç½‘ç«™ç”Ÿæˆå™¨æ—¶ï¼Œä¸€ä¸ªæ–°çš„ç«äº‰è€…å‡ºç°äº†ã€‚
- en: Next.js
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Next.js
- en: Back then (around 2016), React was not opinionated. It was a library that only
    concerned itself with rendering and state. While other frameworks like Angular.js
    came bundled with everything you may need to get up and running, React opted to
    allow the community to figure things out. And figure out they did. We had a new
    JavaScript bundler every other Tuesday, a new router every Sunday, a new CSS-in-JS
    solution every Friday, and a new state management library every f***ken day.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ—¶ï¼ˆå¤§çº¦åœ¨2016å¹´ï¼‰ï¼ŒReactå¹¶ä¸æŒæœ‰ä»»ä½•ç‰¹å®šçš„è§‚ç‚¹ã€‚å®ƒåªæ˜¯ä¸€ä¸ªä¸“æ³¨äºæ¸²æŸ“å’ŒçŠ¶æ€çš„åº“ã€‚è€ŒåƒAngular.jsè¿™æ ·çš„å…¶ä»–æ¡†æ¶åˆ™æ†ç»‘äº†ä½ å¯èƒ½éœ€è¦çš„ä¸€åˆ‡ï¼Œå¯ä»¥è®©ä½ å¿«é€Ÿå¯åŠ¨ã€‚Reacté€‰æ‹©è®©ç¤¾åŒºè‡ªå·±è§£å†³é—®é¢˜ã€‚ä»–ä»¬ç¡®å®è§£å†³äº†é—®é¢˜ã€‚æˆ‘ä»¬æ¯éš”ä¸€å‘¨å°±ä¼šæœ‰ä¸€ä¸ªæ–°çš„JavaScriptæ‰“åŒ…å·¥å…·ï¼Œæ¯ä¸ªæ˜ŸæœŸå¤©éƒ½ä¼šæœ‰ä¸€ä¸ªæ–°çš„è·¯ç”±å™¨ï¼Œæ¯ä¸ªæ˜ŸæœŸäº”éƒ½ä¼šæœ‰ä¸€ä¸ªæ–°çš„CSS-in-JSè§£å†³æ–¹æ¡ˆï¼Œæ¯ä¸€å¤©éƒ½ä¼šæœ‰ä¸€ä¸ªæ–°çš„çŠ¶æ€ç®¡ç†åº“ã€‚
- en: Enters Next.js. Your very own open-source / blazingly-fast (not really) / batteries-included
    React framework. While things like Gatsby offered a choice between a dynamic SPA
    or a static pre-rendered website, Next.js supported multiple rendering modes.
    By default it pre-rendered pages which made site generators like Gatsby obsolete.
    In addition to pre-rendering, it supported server-side rendering for cases when
    page content canâ€™t be known at build time and must be rendered depending on request
    params. It also came with client-side rendering support which also made it a viable
    option for SPAs. Furthermore, you could mix and match between all these rendering
    modes. The way it works is once the user requests a certain page from the server,
    the server renders an HTML document with all the elements needed to view the page.
    The JavaScript would take over and hydrate all the elements with the necessary
    event listeners for the page to be interactive. A client side router would also
    take over. This meant that we donâ€™t need to choose between websites and apps anymore.
    As Next gave us the SEO/performance benefits of server-side-rendering while maintaining
    the app-like user experience. It meant the death of the website/web app dichotomy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¿›å…¥ Next.jsã€‚ä½ è‡ªå·±çš„å¼€æº/æé€Ÿï¼ˆå…¶å®ä¸æ˜¯ï¼‰/ä¸€åº”ä¿±å…¨çš„ React æ¡†æ¶ã€‚è™½ç„¶åƒ Gatsby è¿™æ ·çš„å·¥å…·åœ¨åŠ¨æ€å•é¡µåº”ç”¨æˆ–é™æ€é¢„æ¸²æŸ“ç½‘ç«™ä¹‹é—´æä¾›äº†é€‰æ‹©ï¼ŒNext.js
    æ”¯æŒå¤šç§æ¸²æŸ“æ¨¡å¼ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒé¢„æ¸²æŸ“é¡µé¢ï¼Œä½¿å¾—åƒ Gatsby è¿™æ ·çš„ç«™ç‚¹ç”Ÿæˆå™¨è¿‡æ—¶äº†ã€‚é™¤äº†é¢„æ¸²æŸ“ï¼Œå®ƒè¿˜æ”¯æŒæœåŠ¡å™¨ç«¯æ¸²æŸ“ï¼Œç”¨äºå¤„ç†åœ¨æ„å»ºæ—¶æ— æ³•çŸ¥é“é¡µé¢å†…å®¹ï¼Œå¿…é¡»æ ¹æ®è¯·æ±‚å‚æ•°è¿›è¡Œæ¸²æŸ“çš„æƒ…å†µã€‚å®ƒè¿˜æ”¯æŒå®¢æˆ·ç«¯æ¸²æŸ“ï¼Œè¿™ä½¿å¾—å®ƒæˆä¸ºå•é¡µåº”ç”¨çš„ä¸€ä¸ªå¯è¡Œé€‰æ‹©ã€‚æ­¤å¤–ï¼Œä½ å¯ä»¥æ··åˆåŒ¹é…æ‰€æœ‰è¿™äº›æ¸²æŸ“æ¨¡å¼ã€‚å®ƒçš„å·¥ä½œæ–¹å¼æ˜¯ä¸€æ—¦ç”¨æˆ·ä»æœåŠ¡å™¨è¯·æ±‚æŸä¸ªé¡µé¢ï¼ŒæœåŠ¡å™¨å°±ä¼šæ¸²æŸ“ä¸€ä¸ªå¸¦æœ‰æ‰€æœ‰é¡µé¢æŸ¥çœ‹æ‰€éœ€å…ƒç´ çš„
    HTML æ–‡æ¡£ã€‚ç„¶å JavaScript æ¥ç®¡å¹¶ä¸ºé¡µé¢äº¤äº’æ€§æ·»åŠ å¿…è¦çš„äº‹ä»¶ç›‘å¬å™¨ã€‚å®¢æˆ·ç«¯è·¯ç”±å™¨ä¹Ÿä¼šæ¥ç®¡ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬ä¸å†éœ€è¦åœ¨ç½‘ç«™å’Œåº”ç”¨ä¹‹é—´åšé€‰æ‹©ã€‚å› ä¸º
    Next.js æä¾›äº†æœåŠ¡å™¨ç«¯æ¸²æŸ“çš„ SEO/æ€§èƒ½ä¼˜åŠ¿ï¼ŒåŒæ—¶ä¿æŒäº†åº”ç”¨èˆ¬çš„ç”¨æˆ·ä½“éªŒã€‚è¿™æ„å‘³ç€ç½‘ç«™/ç½‘ç»œåº”ç”¨äºŒå…ƒå¯¹ç«‹çš„ç»ˆç»“ã€‚
- en: The Cloudâ„¢
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: äº‘â„¢
- en: 'Letâ€™s take the timeline back a few years. At around 2006, another change brewing
    in parallel was the rise of â€œThe Cloudâ€. In simple terms, it means you donâ€™t have
    to use your bare metal servers anymore. You can use Amazonâ€™s. Yes, Amazon had
    a few servers they did not need and decided to start [AWS](https://aws.amazon.com/).
    Amazonâ€™s approach was unique compared the OGs that existed at that time. Companies
    like IBM and Oracle went for big/exclusive enterprise contracts that aimed to
    take over the IT department of a company using their proprietary tools. AWS offered
    a number of independent services that anyone could buy. Make no mistake, the end
    goal for AWS was the exact same: take over the IT department of your company.
    They just had you (the developer) work for it yourself. Genius if you ask me.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æŠŠæ—¶é—´çº¿æ¨å›å‡ å¹´ã€‚å¤§çº¦åœ¨2006å¹´å·¦å³ï¼Œå¦ä¸€ä¸ªå¹¶è¡Œå‘å±•çš„å˜åŒ–æ˜¯â€œäº‘â€çš„å…´èµ·ã€‚ç®€å•æ¥è¯´ï¼Œè¿™æ„å‘³ç€æ‚¨ä¸å†éœ€è¦ä½¿ç”¨è£¸é‡‘å±æœåŠ¡å™¨ã€‚æ‚¨å¯ä»¥ä½¿ç”¨äºšé©¬é€Šçš„ã€‚æ˜¯çš„ï¼Œäºšé©¬é€Šæœ‰ä¸€äº›é—²ç½®çš„æœåŠ¡å™¨ï¼Œä»–ä»¬å†³å®šå¼€å§‹[AWS](https://aws.amazon.com/)ã€‚äºšé©¬é€Šçš„æ–¹æ³•ä¸å½“æ—¶çš„è€ç‰Œå…¬å¸æœ‰æ‰€ä¸åŒã€‚åƒIBMå’ŒOracleè¿™æ ·çš„å…¬å¸é€‰æ‹©äº†å¤§å‹/ç‹¬å®¶ä¼ä¸šåˆåŒï¼Œæ—¨åœ¨é€šè¿‡ä½¿ç”¨å…¶ä¸“æœ‰å·¥å…·æ¥ç®¡å…¬å¸çš„ITéƒ¨é—¨ã€‚AWSæä¾›äº†è®¸å¤šä»»ä½•äººéƒ½å¯ä»¥è´­ä¹°çš„ç‹¬ç«‹æœåŠ¡ã€‚ä¸è¦è¯¯ä¼šï¼ŒAWSçš„æœ€ç»ˆç›®æ ‡ä¸ä¹‹å‰å®Œå…¨ç›¸åŒï¼šæ¥ç®¡æ‚¨å…¬å¸çš„ITéƒ¨é—¨ã€‚ä»–ä»¬åªæ˜¯è®©æ‚¨ï¼ˆå¼€å‘è€…ï¼‰è‡ªå·±æ¥å®Œæˆè¿™äº›å·¥ä½œã€‚å¦‚æœæ‚¨é—®æˆ‘ï¼Œè¿™æ˜¯ä¸€ä¸ªå¤©æ‰çš„æƒ³æ³•ã€‚
- en: In practice, AWSâ€™s approach of offering a large number of independent services
    that you can stitch together to architect your app worked well for large companies
    with dedicated sys-admin/ops teams. It didnâ€™t work quite well for the new wave
    of JavaScript developers that just graduated bootcamps. Why do I have to fiddle
    with 15 services and an abhorrent dashboard to deploy my twitter clone ? And so
    a new generation of cloud companies was birthed from the marketâ€™s need for simpler
    cloud platforms. To my knowledge most of which were built on top of AWS. They
    just made the most common use cases easier than ever. Coming with things like
    CI/CD, scaling, analytics, and CDN out of the box and packaged in a beautiful
    dashboard. Among these companies was a company named [Vercel](https://vercel.com/).
    The company that made Next.js.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­ï¼ŒAWSæä¾›äº†å¤§é‡ç‹¬ç«‹çš„æœåŠ¡ï¼Œæ‚¨å¯ä»¥å°†å®ƒä»¬æ‹¼å‡‘åœ¨ä¸€èµ·æ¥è®¾è®¡æ‚¨çš„åº”ç”¨ç¨‹åºï¼Œè¿™åœ¨æ‹¥æœ‰ä¸“é—¨çš„ç³»ç»Ÿç®¡ç†å‘˜/è¿ç»´å›¢é˜Ÿçš„å¤§å‹å…¬å¸ä¸­æ•ˆæœå¾ˆå¥½ã€‚ä½†å¯¹åˆšä»bootcampæ¯•ä¸šçš„æ–°ä¸€æ³¢JavaScriptå¼€å‘è€…æ¥è¯´ï¼Œè¿™ç§æ–¹æ³•å¹¶ä¸æ˜¯å¾ˆé€‚åˆã€‚ä¸ºä»€ä¹ˆæˆ‘è¦è´¹å¿ƒå»æ‘†å¼„15ä¸ªæœåŠ¡å’Œä¸€ä¸ªéš¾ä»¥å¿å—çš„ä»ªè¡¨æ¿æ¥éƒ¨ç½²æˆ‘çš„Twitterå…‹éš†ï¼Ÿå› æ­¤ï¼Œå¸‚åœºå¯¹æ›´ç®€å•çš„äº‘å¹³å°çš„éœ€æ±‚å‚¬ç”Ÿäº†ä¸€ä»£æ–°çš„äº‘å…¬å¸ã€‚æ®æˆ‘æ‰€çŸ¥ï¼Œå…¶ä¸­å¤§å¤šæ•°éƒ½æ˜¯å»ºç«‹åœ¨AWSä¹‹ä¸Šçš„ã€‚å®ƒä»¬åªæ˜¯è®©æœ€å¸¸è§çš„ç”¨ä¾‹æ¯”ä»¥å¾€æ›´å®¹æ˜“å®ç°ã€‚åƒCI/CDã€æ‰©å±•ã€åˆ†æå’ŒCDNç­‰åŠŸèƒ½éƒ½å·²å†…ç½®ï¼Œå¹¶åŒ…è£…åœ¨ç¾è§‚çš„ä»ªè¡¨æ¿ä¸­ã€‚åœ¨è¿™äº›å…¬å¸ä¸­ï¼Œæœ‰ä¸€å®¶åå«[Vercel](https://vercel.com/)çš„å…¬å¸ã€‚å®ƒæ˜¯è®©Next.jsæµè¡Œèµ·æ¥çš„å…¬å¸ã€‚
- en: JavaScript thatâ€™s a lot more like C#
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScriptæ›´åƒC#äº†ã€‚
- en: The more JavaScript took over, the more people started to realize that it was
    inadequate for itsâ€™ new role as the one language to rule them all. Among itsâ€™
    many inadequacies is being a dynamically typed language. Which meant that building
    libraries and big applications using JavaScript was a tedious process of `console.log`ing
    everything and hoping you get what you need. So a statically typed JavaScript
    was needed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: éšç€JavaScriptçš„æ™®åŠï¼Œè¶Šæ¥è¶Šå¤šçš„äººå¼€å§‹æ„è¯†åˆ°å®ƒåœ¨å…¶æ–°è§’è‰²ä½œä¸ºç»Ÿæ²»æ‰€æœ‰è¯­è¨€çš„ä¸€ç§è¯­è¨€æ–¹é¢æ˜¯ä¸è¶³çš„ã€‚åœ¨å…¶è®¸å¤šä¸è¶³ä¹‹å¤„ä¹‹ä¸€æ˜¯ä½œä¸ºä¸€ç§åŠ¨æ€ç±»å‹è¯­è¨€ã€‚è¿™æ„å‘³ç€ä½¿ç”¨JavaScriptæ„å»ºåº“å’Œå¤§å‹åº”ç”¨ç¨‹åºæ˜¯ä¸€ä¸ªç¹ççš„è¿‡ç¨‹ï¼Œéœ€è¦ä¸æ–­åœ°ä½¿ç”¨`console.log`å¹¶å¸Œæœ›å¾—åˆ°æ‰€éœ€çš„ç»“æœã€‚å› æ­¤ï¼Œéœ€è¦ä¸€ç§é™æ€ç±»å‹çš„JavaScriptã€‚
- en: Meanwhile, a team at Google was building Angular 2 (because the first one wasnâ€™t
    enough). They needed a typed JavaScript with support for decorator syntax. They
    were about to create their own language when they discovered that Microsoft had
    beat them to it and created [TypeScript](https://www.typescriptlang.org/).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸æ­¤åŒæ—¶ï¼ŒGoogleçš„ä¸€ä¸ªå›¢é˜Ÿæ­£åœ¨æ„å»ºAngular 2ï¼ˆå› ä¸ºç¬¬ä¸€ä¸ªè¿˜ä¸å¤Ÿï¼‰ã€‚ä»–ä»¬éœ€è¦ä¸€ç§æ”¯æŒè£…é¥°å™¨è¯­æ³•çš„ç±»å‹åŒ–JavaScriptã€‚å½“ä»–ä»¬å‘ç°å¾®è½¯å·²ç»è¶…è¶Šä»–ä»¬å¹¶åˆ›å»ºäº†[TypeScript](https://www.typescriptlang.org/)æ—¶ï¼Œä»–ä»¬æ­£è¦åˆ›å»ºè‡ªå·±çš„è¯­è¨€ã€‚
- en: TypeScript is simply a compiler that offers static type analysis to your JavaScript
    code. Itsâ€™ syntax was very close to JavaScript so adopting it was very simple.
    Facebook tried to compete with [Flow](https://flow.org/). But TypeScriptâ€™s familiarity
    ended up winning and Flow â€¦ flew into the mist (sorry). But why stop at static
    type analysis and syntactic sugar ? Why not make the most out of our build step
    ?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScriptåªæ˜¯ä¸€ä¸ªä¸ºæ‚¨çš„JavaScriptä»£ç æä¾›é™æ€ç±»å‹åˆ†æçš„ç¼–è¯‘å™¨ã€‚å®ƒçš„è¯­æ³•éå¸¸æ¥è¿‘JavaScriptï¼Œå› æ­¤é‡‡ç”¨å®ƒéå¸¸ç®€å•ã€‚Facebookè¯•å›¾ä¸[Flow](https://flow.org/)ç«äº‰ã€‚ä½†æ˜¯TypeScriptçš„ç†Ÿæ‚‰åº¦æœ€ç»ˆèµ¢å¾—äº†èƒœåˆ©ï¼Œè€ŒFlowâ€¦æ¶ˆå¤±åœ¨è¿·é›¾ä¸­ï¼ˆæŠ±æ­‰ï¼‰ã€‚ä½†ä¸ºä»€ä¹ˆè¦æ­¢æ­¥äºé™æ€ç±»å‹åˆ†æå’Œè¯­æ³•ç³–ï¼Ÿä¸ºä»€ä¹ˆä¸å……åˆ†åˆ©ç”¨æˆ‘ä»¬çš„æ„å»ºæ­¥éª¤å‘¢ï¼Ÿ
- en: Svelte
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Svelte
- en: Driven by the belief that frameworks should only augment/enhance the web platform
    not replace it or change it, [Svelte](https://svelte.dev/) was made. While most
    frameworks at the time of itsâ€™ release had to ship a large JavaScript bundle to
    handle rendering and reactivity, Svelte was just a compiler. Thereâ€™s no Svelte
    script that gets shipped to the browser. The Svelte compiler generates some highly
    optimized reactivity code thatâ€™s much much smaller and faster than the rest.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºä¸€ç§ä¿¡å¿µï¼Œå³æ¡†æ¶åº”è¯¥åªæ˜¯å¢å¼º/å¢å¼ºç½‘ç»œå¹³å°ï¼Œè€Œä¸æ˜¯å–ä»£å®ƒæˆ–æ”¹å˜å®ƒï¼Œ[Svelte](https://svelte.dev/)è¯ç”Ÿäº†ã€‚åœ¨å…¶å‘å¸ƒæ—¶ï¼Œå¤§å¤šæ•°æ¡†æ¶éƒ½å¿…é¡»å‘é€ä¸€ä¸ªå¤§å‹JavaScriptåŒ…æ¥å¤„ç†æ¸²æŸ“å’Œååº”æ€§ï¼Œè€ŒSvelteåªæ˜¯ä¸€ä¸ªç¼–è¯‘å™¨ã€‚æ²¡æœ‰Svelteè„šæœ¬è¢«å‘é€åˆ°æµè§ˆå™¨ã€‚Svelteç¼–è¯‘å™¨ç”Ÿæˆäº†ä¸€äº›é«˜åº¦ä¼˜åŒ–çš„ååº”æ€§ä»£ç ï¼Œæ¯”å…¶ä»–æ¡†æ¶è¦å°å¾—å¤šï¼Œé€Ÿåº¦æ›´å¿«ã€‚
- en: The team behind it also made [SvelteKit](https://kit.svelte.dev/). A framework
    on top of Svelte that handles bundling, routing, and pretty much everything you
    may need in a web framework. Itsâ€™ very mature routing and data-loading patterns
    have made me give up on using GraphQL in most of my projects. Why spend time and
    effort securing and optimizing a GraphQL schema when I can throw a database call
    in a `load` function and have everything be typed server to client ? Itâ€™s an absolute
    win when it comes to app development. Similar techniques are also available in
    other frameworks like [Nuxt](https://nuxt.com/), [Next](https://nextjs.org/),
    and [SolidStart](https://start.solidjs.com/getting-started/what-is-solidstart).
    This makes the overhead cost of GraphQL development very hard to justify in *most*
    cases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: èƒŒåçš„å›¢é˜Ÿè¿˜å¼€å‘äº†[SvelteKit](https://kit.svelte.dev/)ã€‚è¿™æ˜¯å»ºç«‹åœ¨Svelteä¹‹ä¸Šçš„ä¸€ä¸ªæ¡†æ¶ï¼Œå¤„ç†æ†ç»‘ã€è·¯ç”±å’Œå‡ ä¹æ‰€æœ‰ä½ åœ¨Webæ¡†æ¶ä¸­å¯èƒ½éœ€è¦çš„ä¸œè¥¿ã€‚å®ƒéå¸¸æˆç†Ÿçš„è·¯ç”±å’Œæ•°æ®åŠ è½½æ¨¡å¼ä½¿æˆ‘æ”¾å¼ƒäº†åœ¨å¤§å¤šæ•°é¡¹ç›®ä¸­ä½¿ç”¨GraphQLã€‚ä¸ºä»€ä¹ˆè¦èŠ±æ—¶é—´å’Œç²¾åŠ›å»ä¿æŠ¤å’Œä¼˜åŒ–ä¸€ä¸ªGraphQLæ¨¡å¼ï¼Œå½“æˆ‘å¯ä»¥åœ¨`load`å‡½æ•°ä¸­è°ƒç”¨æ•°æ®åº“æŸ¥è¯¢ï¼Œå¹¶ä¸”æ‰€æœ‰çš„å†…å®¹ä»æœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯éƒ½æ˜¯æœ‰ç±»å‹çš„å‘¢ï¼Ÿåœ¨åº”ç”¨ç¨‹åºå¼€å‘ä¸­ï¼Œè¿™ç»å¯¹æ˜¯ä¸€ç§èƒœåˆ©ã€‚ç±»ä¼¼çš„æŠ€æœ¯ä¹Ÿé€‚ç”¨äºå…¶ä»–æ¡†æ¶ï¼Œå¦‚[Nuxt](https://nuxt.com/)ã€[Next](https://nextjs.org/)å’Œ[SolidStart](https://start.solidjs.com/getting-started/what-is-solidstart)ã€‚è¿™ä½¿å¾—åœ¨*å¤§å¤šæ•°*æƒ…å†µä¸‹å¾ˆéš¾è¯æ˜GraphQLå¼€å‘çš„é¢å¤–æˆæœ¬æ˜¯åˆç†çš„ã€‚
- en: 'HTMX: there and back again'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTMXï¼šä»é‚£é‡Œå†æ¬¡å›æ¥
- en: Remember the good olâ€™ days ? When the server sent HTML instead of JSON ? [HTMX](https://htmx.org/)
    gives all the power *back* to the server. You include an HTMX script tag on all
    your pages. Any mutation that happens to the state will result in HTMX swapping
    an element on the screen with whatever the backend sent. This is not a particularly
    new idea. For example, [GitHub](https://github.com/) is already built that way
    using [Ruby](https://www.ruby-lang.org/en/). But HTMX revitalized it by [posting
    memes](https://twitter.com/htmx_org/status/1306234341056344065) on twitter. And
    I love it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: è®°å¾—é‚£äº›ç¾å¥½çš„æ—§æ—¥å—ï¼ŸæœåŠ¡å™¨å‘é€HTMLè€Œä¸æ˜¯JSONï¼Ÿ[HTMX](https://htmx.org/)å°†æ‰€æœ‰æƒåŠ›*è¿˜ç»™*äº†æœåŠ¡å™¨ã€‚ä½ åœ¨æ‰€æœ‰é¡µé¢ä¸ŠåŒ…å«äº†ä¸€ä¸ªHTMXè„šæœ¬æ ‡ç­¾ã€‚ä»»ä½•å¯¹çŠ¶æ€çš„å˜æ›´éƒ½ä¼šå¯¼è‡´HTMXå°†å±å¹•ä¸Šçš„ä¸€ä¸ªå…ƒç´ ä¸åç«¯å‘é€çš„å†…å®¹è¿›è¡Œäº¤æ¢ã€‚è¿™å¹¶ä¸æ˜¯ä¸€ä¸ªç‰¹åˆ«æ–°çš„æƒ³æ³•ã€‚ä¾‹å¦‚ï¼Œ[GitHub](https://github.com/)å·²ç»æ˜¯ç”¨[Ruby](https://www.ruby-lang.org/en/)æ„å»ºçš„ã€‚ä½†HTMXé€šè¿‡[åœ¨Twitterä¸Šå‘å¸ƒæ¢—](https://twitter.com/htmx_org/status/1306234341056344065)ä½¿å…¶å¤å…´ã€‚æˆ‘å–œæ¬¢å®ƒã€‚
- en: We must also appreciate the appeal it has to programmers who are not in the
    JavaScript bubble. Imagine youâ€™ve been writing Go, Java, or anything thatâ€™s proper,
    and you went to make a website. People started telling you to use JavaScript.
    But why include JavaScript to begin with ? Why not do the whole thing in the one
    language you like? HTMX offers that to people without coupling it with a complete
    backend framework like [Rails](https://rubyonrails.org/) does it. You pick whatever
    backend language you like and as long as youâ€™re returning HTML in response, youâ€™re
    good to go. And speaking of Rails, why is that framework not dead yet ? Why is
    PHP still a thing ? And most importantly, why on earth is React still alive ?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¿…é¡»æ¬£èµå®ƒå¯¹é‚£äº›ä¸å±€é™äº JavaScript çš„ç¨‹åºå‘˜çš„å¸å¼•åŠ›ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œä½ ä¸€ç›´åœ¨å†™ Goã€Java æˆ–å…¶ä»–åˆé€‚çš„è¯­è¨€ï¼Œç„¶åä½ æƒ³åšä¸€ä¸ªç½‘ç«™ã€‚äººä»¬å¼€å§‹å‘Šè¯‰ä½ è¦ç”¨
    JavaScriptã€‚ä½†æ˜¯ä¸ºä»€ä¹ˆè¦ä¸€å¼€å§‹å°±ç”¨ JavaScript å‘¢ï¼Ÿä¸ºä»€ä¹ˆä¸å®Œå…¨ç”¨ä½ å–œæ¬¢çš„é‚£ä¸€ç§è¯­è¨€å‘¢ï¼ŸHTMX ç»™é‚£äº›äººæä¾›äº†è¿™æ ·çš„æœºä¼šï¼Œè€Œä¸ä¼šåƒ[Rails](https://rubyonrails.org/)é‚£æ ·ä¸å®Œæ•´çš„åç«¯æ¡†æ¶æ†ç»‘åœ¨ä¸€èµ·ã€‚ä½ å¯ä»¥é€‰æ‹©ä»»ä½•ä½ å–œæ¬¢çš„åç«¯è¯­è¨€ï¼Œåªè¦è¿”å›
    HTML å°±å¯ä»¥äº†ã€‚è€Œä¸”è¯´åˆ° Railsï¼Œä¸ºä»€ä¹ˆè¿™ä¸ªæ¡†æ¶è¿˜æ²¡æ­»å‘¢ï¼Ÿä¸ºä»€ä¹ˆ PHP ä»ç„¶å­˜åœ¨ï¼Ÿæœ€é‡è¦çš„æ˜¯ï¼Œä¸ºä»€ä¹ˆ React è¿˜åœ¨ç»§ç»­å­˜åœ¨å‘¢ï¼Ÿ
- en: React is not going to die
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React ä¸ä¼šæ­»
- en: I know itâ€™s very hard. But letâ€™s look at this objectively. As of the time of
    writing (early 2024), is React *better* at any particular thing compared to all
    the other mainstream UI frameworks ? **No, it is not**. Even Angular, the framework
    everyone loves to hate has been getting updates that objectively improve performance,
    maintainability, and developer experience.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘çŸ¥é“è¿™å¾ˆéš¾ã€‚ä½†è®©æˆ‘ä»¬å®¢è§‚åœ°çœ‹å¾…è¿™ä¸ªé—®é¢˜ã€‚æˆªè‡³æ’°å†™æœ¬æ–‡ï¼ˆ2024å¹´åˆï¼‰ï¼ŒReact åœ¨ä»»ä½•ç‰¹å®šäº‹æƒ…ä¸Šæ˜¯å¦æ¯”æ‰€æœ‰å…¶ä»–ä¸»æµ UI æ¡†æ¶*æ›´å¥½*ï¼Ÿ**ä¸ï¼Œå®ƒæ²¡æœ‰**ã€‚å³ä½¿æ˜¯
    Angularï¼Œè¿™ä¸ªäººäººéƒ½çˆ±è®¨åŒçš„æ¡†æ¶ï¼Œä¹Ÿåœ¨ä¸æ–­æ›´æ–°ï¼Œä»å®¢è§‚ä¸Šæ”¹è¿›äº†æ€§èƒ½ã€å¯ç»´æŠ¤æ€§å’Œå¼€å‘è€…ä½“éªŒã€‚
- en: Meanwhile React seems to be wandering aimlessly. We started with class components,
    then we changed some life cycle hooks, then everything became â€œfunctionalâ€. Everyone
    was praising the new â€œfunctionalâ€ API with `useState` and `useEffect`. But people
    quickly realized that `useEffect` was a very bad abstraction given the way React
    works. It was a foot gun. And for a while React devs didnâ€™t know what was the
    alternative ? It was at this time that Vercel started hiring a few of Reactâ€™s
    core maintainers. It was at this time when Next.js and React essentially became
    one and the same. And [server components](https://www.joshwcomeau.com/react/server-components/)
    became the new ~~foot-gun~~ API the React team is recommending. All that and people
    are yet to figure out the â€œReactâ€ way of doing things.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸æ­¤åŒæ—¶ï¼ŒReact ä¼¼ä¹åœ¨æ¼«æ— ç›®çš„åœ°å¾˜å¾Šã€‚æˆ‘ä»¬ä»ç±»ç»„ä»¶å¼€å§‹ï¼Œç„¶åæ”¹å˜äº†ä¸€äº›ç”Ÿå‘½å‘¨æœŸé’©å­ï¼Œç„¶åä¸€åˆ‡éƒ½å˜æˆäº†â€œå‡½æ•°å¼â€ã€‚æ¯ä¸ªäººéƒ½åœ¨èµæ‰¬æ–°çš„â€œå‡½æ•°å¼â€APIï¼Œæ¯”å¦‚
    `useState` å’Œ `useEffect`ã€‚ä½†å¾ˆå¿«äººä»¬æ„è¯†åˆ°ï¼Œè€ƒè™‘åˆ° React çš„å·¥ä½œæ–¹å¼ï¼Œ`useEffect` æ˜¯ä¸€ä¸ªéå¸¸ç³Ÿç³•çš„æŠ½è±¡ã€‚è¿™æ˜¯ä¸€ä¸ªè¯¯å¯¼ã€‚æœ‰ä¸€æ®µæ—¶é—´ï¼ŒReact
    å¼€å‘è€…ä¸çŸ¥é“æœ‰ä»€ä¹ˆæ›¿ä»£æ–¹æ¡ˆï¼Ÿå°±åœ¨è¿™ä¸ªæ—¶å€™ï¼ŒVercel å¼€å§‹é›‡ä½£äº†ä¸€äº› React çš„æ ¸å¿ƒç»´æŠ¤è€…ã€‚å°±åœ¨è¿™ä¸ªæ—¶å€™ï¼ŒNext.js å’Œ React æœ¬è´¨ä¸Šå˜æˆäº†ä¸€ä¸ªæ•´ä½“ã€‚[æœåŠ¡å™¨ç»„ä»¶](https://www.joshwcomeau.com/react/server-components/)æˆä¸ºäº†
    React å›¢é˜Ÿæ¨èçš„æ–°~~è¯¯å¯¼~~ APIã€‚æ‰€æœ‰è¿™äº›ï¼Œäººä»¬ä»ç„¶æ²¡æœ‰æ‰¾å‡ºâ€œReactâ€çš„æ­£ç¡®åšæ³•ã€‚
- en: Regardless of all that pain, React is still [the most downloaded framework on
    NPM](https://npmtrends.com/@angular/core-vs-react-vs-solid-js-vs-svelte-vs-vue)
    compared to other frameworks. Itâ€™s not even close. But why ?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡æ‰€æœ‰è¿™äº›ç—›è‹¦ï¼Œä¸å…¶ä»–æ¡†æ¶ç›¸æ¯”ï¼ŒReact ä»ç„¶æ˜¯ [NPM ä¸Šä¸‹è½½é‡æœ€å¤šçš„æ¡†æ¶](https://npmtrends.com/@angular/core-vs-react-vs-solid-js-vs-svelte-vs-vue)ã€‚æ²¡æœ‰ä»»ä½•æ¡†æ¶èƒ½ä¸å®ƒç›¸æå¹¶è®ºã€‚ä½†ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ
- en: Look around you. No technology that was once mainstream ever dies. People rarely
    pick â€œthe best tool for the jobâ€. They say that. But what they mean is â€œthe tool
    Iâ€™m familiar with the mostâ€. Thatâ€™s it. Thatâ€™s why React is probably not dying
    anytime soon. But it doesnâ€™t matter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹ä½ å‘¨å›´ã€‚æ›¾ç»ä¸»æµçš„æŠ€æœ¯ä»ä¸ä¼šæ¶ˆå¤±ã€‚äººä»¬å¾ˆå°‘ä¼šé€‰æ‹©â€œæœ€é€‚åˆå·¥ä½œçš„å·¥å…·â€ã€‚ä»–ä»¬ä¼šè¿™ä¹ˆè¯´ã€‚ä½†ä»–ä»¬çš„æ„æ€æ˜¯â€œæˆ‘æœ€ç†Ÿæ‚‰çš„å·¥å…·â€ã€‚å°±è¿™æ ·ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆ React
    å¯èƒ½ä¸ä¼šå¾ˆå¿«æ¶ˆäº¡çš„åŸå› ã€‚ä½†è¿™å¹¶ä¸é‡è¦ã€‚
- en: Really, it does not.
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: çœŸçš„ï¼Œæ²¡æœ‰ã€‚
- en: Wanna keep using React ? Wanna switch to something better like Svelte ? Wanna
    avoid JavaScript like the plague and use HTMX ? It doesnâ€™t matter to the end user.
    As long as youâ€™re providing value to people and/or having fun doing it, youâ€™re
    good. Donâ€™t feel bad about your technical choices because someone on the internet
    wants you to. Programming is a craft. Thereâ€™s way more leeway than the person
    whoâ€™s selling you a course about â€œframework Xâ€, â€œlanguage Yâ€, or a book about
    â€œclean code/design/architectureâ€ wants you to believe. And putting all this history
    into writing only serves to enforce this sentiment. **Things will change**. And
    no matter how much they do, weâ€™ll still be programmers. Our primary function is
    to write useful programs. Have fun ğŸ‰
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³ç»§ç»­ä½¿ç”¨ React å—ï¼Ÿæƒ³è½¬å‘åƒ Svelte è¿™æ ·æ›´å¥½çš„ä¸œè¥¿å—ï¼Ÿæƒ³åƒé¿å¼€ JavaScript ä¸€æ ·é¿å¼€ç˜Ÿç–«ï¼Œç”¨ HTMX å—ï¼Ÿå¯¹äºæœ€ç»ˆç”¨æˆ·æ¥è¯´å¹¶ä¸é‡è¦ã€‚åªè¦ä½ ä¸ºäººä»¬æä¾›ä»·å€¼å’Œ/æˆ–ä¹åœ¨å…¶ä¸­ï¼Œå°±æ²¡é—®é¢˜ã€‚ä¸è¦å› ä¸ºç½‘ä¸Šçš„æŸä¸ªäººæƒ³è®©ä½ æ”¹å˜æŠ€æœ¯é€‰æ‹©è€Œæ„Ÿåˆ°éš¾è¿‡ã€‚ç¼–ç¨‹æ˜¯ä¸€é—¨æ‰‹è‰ºã€‚æ¯”èµ·é‚£äº›æƒ³è¦å‘ä½ æ¨é”€â€œæ¡†æ¶
    Xâ€ã€â€œè¯­è¨€ Yâ€çš„äººï¼Œæˆ–è€…é‚£äº›å…³äºâ€œæ¸…æ´ä»£ç /è®¾è®¡/æ¶æ„â€çš„ä¹¦ç±æ‰€è¯´çš„è¦è‡ªç”±å¾—å¤šã€‚å°†æ‰€æœ‰è¿™äº›å†å²å†™ä¸‹æ¥åªä¼šå¼ºåŒ–è¿™ç§æƒ…æ„Ÿã€‚**äº‹æƒ…ä¼šå˜çš„**ã€‚æ— è®ºå®ƒä»¬å¦‚ä½•å˜åŒ–ï¼Œæˆ‘ä»¬ä»å°†æ˜¯ç¨‹åºå‘˜ã€‚æˆ‘ä»¬çš„ä¸»è¦åŠŸèƒ½æ˜¯ç¼–å†™æœ‰ç”¨çš„ç¨‹åºã€‚ç©å¾—å¼€å¿ƒ
    ğŸ‰
