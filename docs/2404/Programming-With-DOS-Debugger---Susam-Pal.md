<!--yml

category: 未分类

date: 2024-05-27 12:58:56

-->

# 使用 DOS 调试器进行编程 - Susam Pal

> 来源：[https://susam.net/programming-with-dos-debugger.html](https://susam.net/programming-with-dos-debugger.html)

<main>

# 使用 DOS 调试器进行编程

作者：**Susam Pal**，2003 年 2 月 11 日

## 介绍

MS-DOS 和 Windows 98 都配备了名为 `DEBUG.EXE` 的调试器程序，可用于处理汇编语言指令和机器码。在 MS-DOS 6.22 版本中，此程序名为 `DEBUG.EXE`，通常位于 `C:\DOS\DEBUG.EXE`。在 Windows 98 中，此程序通常位于 `C:\Windows\Command\Debug.exe`。它是一款行定向调试器，支持各种有用的功能，用于处理和调试由机器码组成的二进制可执行程序。

在本文中，我们将看到如何使用这个调试器程序来组装一些打印字符到标准输出的最小程序。我们首先创建一个打印单个字符的 7 字节程序。然后，我们创建一个打印 "hello, world" 字符串的 23 字节程序。本文提供的所有步骤在 Windows 98 中也能正常工作。

## 内容

## 打印字符

让我们首先看看如何创建一个只打印字符 `A` 的小型 7 字节程序。以下是 `DEBUG.EXE` 会话演示了如何实现。

```
C:\>`DEBUG`
-`A`
1165:0100 `MOV AH, 2`
1165:0102 `MOV DL, 41`
1165:0104 `INT 21`
1165:0106 `RET`
1165:0107
-`G`
A
Program terminated normally
-`N A.COM`
-`R CX`
CX 0000
:`7`
-`W`
Writing 00007 bytes
-`Q`

C:\>

```

现在我们可以按如下方式执行此程序：

```
C:\>`A`
A
C:\>

```

命令 `A` 通过汇编语言指令创建可执行的机器码。创建的机器码默认写入主存储器地址 CS:0100 处。前三条指令生成软件中断 0x21（十进制 33），其中 AH 设置为 2，DL 设置为 0x41（十进制 65），这恰好是字符 `A` 的 ASCII 码。中断 0x21 提供各种 DOS 服务。将 AH 设置为 2 告诉此中断调用打印单个字符到标准输出的函数。此函数期望 DL 设置为我们想要打印的字符的 ASCII 码。

命令 `G` 在当前位置执行内存中的程序。当前位置由默认值 CS:0100 确定，我们使用此命令确认程序按预期运行。

接下来，我们准备将机器码写入二进制可执行文件。命令 `N` 用于指定文件名。命令 `W` 用于将机器码写入文件。此命令要求寄存器 BX 和 CX 包含要写入文件的字节数。当 DOS 调试器启动时，BX 已初始化为 0，因此我们只需用命令 `R CX` 将寄存器 CX 设置为 7。最后，我们使用命令 `Q` 退出调试器并返回 MS-DOS。

## Hello, World

以下 `DEBUG.EXE` 会话展示了如何创建打印字符串的程序。

```
C:\>`DEBUG`
-`A`
1165:0100 `MOV AH, 9`
1165:0102 `MOV DX, 108`
1165:0105 `INT 21`
1165:0107 `RET`
1165:0108 `DB 'hello, world', D, A, '/main>`
1165:0117
-`G`
hello, world

Program terminated normally
-`N HELLO.COM`
-`R CX`
CX 0000
:`17`
-`W`
Writing 00017 bytes
-`Q`

C:\>

```

现在我们可以像这样执行这个 23 字节的程序：

```
C:\>`HELLO`
hello, world

C:\>

```

在上面的程序中，我们使用伪指令 `DB` 来定义我们要打印的字符串的字节。我们添加尾随字节 0xD 和 0xA 来打印回车（CR）和换行（LF）字符，以便字符串以换行符终止。最后，字符串以美元符号（`'/main>`）的字节结束，因为接下来生成的软中断期望字符串以此符号的字节值终止。

我们再次使用软中断 0x21。然而，这次我们将 AH 设置为 9，以调用打印字符串的函数。该函数期望 DS:DX 指向以`'/main>`字节值结尾的字符串的地址。寄存器 `DS` 的值与 `CS` 相同，因此我们只需将 `DX` 设置为字符串开始的偏移量。

## 调试器脚本

在前一节中，我们已经了解了如何组装一个 "hello, world" 程序。我们启动了调试器程序，输入了一些命令，并输入了汇编语言指令来创建我们的程序。还可以准备一个单独的输入文件，其中包含所有调试器命令和汇编语言指令。然后，我们将此文件提供给调试器程序。在编写更复杂的程序时，如果我们因执行非法指令而意外崩溃调试器，不能丢失我们的汇编语言源代码，这将非常有用。

要创建一个可以提供给调试器的单独输入文件，我们可以使用 DOS 命令 `EDIT HELLO.TXT` 打开一个新文件，使用 MS-DOS 编辑器，然后输入以下调试器命令，保存并退出编辑器。

```
A
MOV AH, 9
MOV DX, 108
INT 21
RET
DB 'hello, world', D, A, '/main>

N HELLO.COM
R CX
17
W
Q

```

这与我们在前一节中在调试器中输入的内容几乎相同。与前一节的唯一区别是，我们这里省略了 `G` 命令，因为在组装程序时我们实际上不需要运行程序，尽管如果真的想要，我们也可以这样做。

然后，我们可以运行 DOS 命令 `DEBUG < HELLO.TXT` 来组装程序并创建二进制可执行文件。下面是一个显示此命令输出的 DOS 会话示例：

```
C:\>`DEBUG < HELLO.TXT`
-A
1165:0100 MOV AH, 9
1165:0102 MOV DX, 108
1165:0105 INT 21
1165:0107 RET
1165:0108 DB 'hello, world', D, A, '/main>
1165:0117
-N HELLO.COM
-R CX
CX 0000
:17
-W
Writing 00017 bytes
-Q

C:\>

```

实际上，输出与前一节中的调试器会话非常相似。

## 反汇编

现在我们已经看到了如何使用调试器将简单程序组装成二进制可执行文件，接下来我们将简要介绍如何反汇编二进制可执行文件。当我们需要调试现有程序时，这将非常有用。

```
C:\>`DEBUG A.COM`
-`U 100 106`
117C:0100 B402          MOV     AH,02
117C:0102 B241          MOV     DL,41
117C:0104 CD21          INT     21
117C:0106 C3            RET

```

调试器命令 `U`（反汇编）用于将二进制机器码翻译成汇编语言助记符。

```
C:\>`DEBUG HELLO.COM`
-`U 100 116`
117C:0100 B409          MOV     AH,09
117C:0102 BA0801        MOV     DX,0108
117C:0105 CD21          INT     21
117C:0107 C3            RET
117C:0108 68            DB      68
117C:0109 65            DB      65
117C:010A 6C            DB      6C
117C:010B 6C            DB      6C
117C:010C 6F            DB      6F
117C:010D 2C20          SUB     AL,20
117C:010F 776F          JA      0180
117C:0111 726C          JB      017F
117C:0113 64            DB      64
117C:0114 0D0A24        OR      AX,240A
-`D 100 116`
117C:0100  B4 09 BA 08 01 CD 21 C3-68 65 6C 6C 6F 2C 20 77   ......!.hello, w
117C:0110  6F 72 6C 64 0D 0A 24                              orld..$

```

## INT 20 vs RET

终止.COM程序的另一种方式是直接使用指令`INT 20`。这在机器代码中消耗两个字节：`CD 20`。虽然本篇文章的真正目标不是创建最小可执行文件，但通过使用`RET`指令示例中的终止程序， 我们在游戏中获得了些许的大小减少。它仅消耗一个字节：`C3`。这是因为当.COM文件开始时，寄存器SP包含FFEFE。栈内存位置在FFEFE处和FFFF处分别包含00和00。进一步地说，内存地址偏移F000包含指令`INT 20`。通过调试工具的演示，我们可以展现这些事实：

```
C:\>`DEBUG HELLO.COM`
-`R SP`
SP FFFE
:
-`D FFFE`
117C:FFF0                                            00 00
-`U 0 1`
117C:0000 CD20          INT     20

```

结果是`RET`指令在FFEFE位置弹出0000并将其加载到IP中。这导致偏移0000处的指令`INT 20`被执行，导致程序终止。

尽管`INT 20`和`RET`在DOS和使用`DEBUG.EXE`进行调试时都成功地终止了程序，但它们之间存在某些差异，这一点影响了调试体验。使用`INT 20`终止程序允许我们在调试器中通过多次应用`G`调试器命令反复运行程序。但当我们将程序终止方式改为使用`RET`时，我们不能使用类似的方式反复运行程序。程序第一次在调试器中运行并成功终止，但栈不会重新初始化为零准备在另一个调试器中的程序执行。因此，当我们尝试第二次使用`G`命令运行程序时，程序不会成功终止，仅挂起。我们可以通过在再次运行`G`命令前通过调试器命令`E FFFE 0 0`重新初始化栈来解决这个问题。

## 结论

虽然DOS调试器在功能上与NASM、MASM等复杂汇编器相比十分有限，但这个笨拙的程序可以执行与汇编语言和机器代码相关的一些基本操作。它可以读取和写入二进制可执行文件，检查内存，执行内存中的机器指令，修改寄存器，编辑二进制文件等。DOS或Windows 98系统总是随附这个调试程序的事实意味着，这些系统为一些基础的汇编语言编程做好了准备，无需额外的工具。

</main>
