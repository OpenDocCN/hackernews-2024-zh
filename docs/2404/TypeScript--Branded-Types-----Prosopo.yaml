- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: æœªåˆ†ç±»'
- en: 'date: 2024-05-27 13:29:40'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 13:29:40'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'TypeScript: Branded Types ğŸ”§ - Prosopo'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'TypeScript: å“ç‰ŒåŒ–ç±»å‹ ğŸ”§ - Prosopo'
- en: æ¥æºï¼š[https://prosopo.io/articles/typescript-branding/](https://prosopo.io/articles/typescript-branding/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://prosopo.io/articles/typescript-branding/](https://prosopo.io/articles/typescript-branding/)
- en: '**[PART 1: TypeScript Mapped Type Magic](/articles/typescript-mapped-type-magic/)**'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**[ç¬¬1éƒ¨åˆ†ï¼šTypeScriptæ˜ å°„ç±»å‹é­”æ³•](/articles/typescript-mapped-type-magic/)**'
- en: Ahoy there TypeScript warriors! ğŸ‘‹ Today we're extending our work in the [TypeScript
    mapped types article](/articles/typescript-mapped-type-magic/) to provide *branding*.
    The previous article discussed how to use TypeScript mapped types in a nominal
    rather than structural nature.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript æˆ˜å£«ä»¬ï¼Œä½ ä»¬å¥½ï¼ğŸ‘‹ ä»Šå¤©æˆ‘ä»¬åœ¨[TypeScriptæ˜ å°„ç±»å‹æ–‡ç« ](/articles/typescript-mapped-type-magic/)çš„åŸºç¡€ä¸Šæ‰©å±•äº†æˆ‘ä»¬çš„å·¥ä½œï¼Œå¼•å…¥*å“ç‰ŒåŒ–*ã€‚ä¸Šä¸€ç¯‡æ–‡ç« è®¨è®ºäº†å¦‚ä½•åœ¨TypeScriptæ˜ å°„ç±»å‹ä¸­ä»¥åä¹‰æ–¹å¼è€Œä¸æ˜¯ç»“æ„æ–¹å¼ä½¿ç”¨ã€‚
- en: '[PRE0]'
  id: totrans-split-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a fancy way of saying TypeScript is structural by default, i.e. it will
    see type `A` and `B` as equal when dealing with types. Making type `A` and `B`
    nominal would make TypeScript differentiate them apart, even though their structure
    is the same.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ç§é«˜çº§çš„è¯´æ³•ï¼Œå³TypeScripté»˜è®¤æ˜¯ç»“æ„åŒ–çš„ï¼Œå³åœ¨å¤„ç†ç±»å‹æ—¶ä¼šå°†ç±»å‹`A`å’Œ`B`è§†ä¸ºç›¸ç­‰ã€‚ä½¿ç±»å‹`A`å’Œ`B`ç§°ä¸ºåä¹‰ä¸Šçš„ä¼šä½¿TypeScriptåŒºåˆ†å®ƒä»¬ï¼Œå³ä½¿å®ƒä»¬çš„ç»“æ„ç›¸åŒã€‚
- en: In this post, we're building on that work to produce a way to *brand* a type,
    providing an automated and easy-to-use way of making a type nominal. Branding
    focuses on the type system only, rather than introducing runtime fields like in
    the previous post, which is a major benefit over the previous approach.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬åŸºäºä¸Šè¿°å·¥ä½œæå‡ºä¸€ç§æ–¹æ³•æ¥*å“ç‰ŒåŒ–*ç±»å‹ï¼Œæä¾›ä¸€ç§è‡ªåŠ¨åŒ–ä¸”æ˜“äºä½¿ç”¨çš„æ–¹å¼ä½¿ç±»å‹æˆä¸ºåä¹‰åŒ–ã€‚å“ç‰ŒåŒ–ä¸“æ³¨äºä»…åœ¨ç±»å‹ç³»ç»Ÿä¸­è€Œä¸æ˜¯åƒä¹‹å‰æ–‡ç« ä¸­ä»‹ç»çš„å¼•å…¥è¿è¡Œæ—¶å­—æ®µï¼Œè¿™æ˜¯ä¸ä¹‹å‰æ–¹æ³•ç›¸æ¯”çš„ä¸€ä¸ªé‡å¤§ä¼˜åŠ¿ã€‚
- en: What's the problem?
  id: totrans-split-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é—®é¢˜å‡ºåœ¨å“ªé‡Œï¼Ÿ
- en: Branding, also known as opaque types, enable differentiation of types in TypeScript
    which otherwise would be classified as the same type. For example
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: å“ç‰ŒåŒ–ï¼Œä¹Ÿç§°ä¸ºä¸é€æ˜ç±»å‹ï¼Œåœ¨TypeScriptä¸­å…è®¸åŒºåˆ†ç±»å‹ï¼Œå¦åˆ™è¿™äº›ç±»å‹å°†è¢«åˆ†ç±»ä¸ºç›¸åŒç±»å‹ã€‚ä¾‹å¦‚ï¼Œ
- en: '[PRE1]'
  id: totrans-split-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`A` and `B` are structurally the same, ergo TypeScript accepts any instance
    of `A` or `B` in place of each other:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`A`å’Œ`B`åœ¨ç»“æ„ä¸Šæ˜¯å®Œå…¨ç›¸åŒçš„ï¼Œå› æ­¤TypeScriptæ¥å—`A`æˆ–`B`çš„ä»»ä½•å®ä¾‹æ¥æ›¿ä»£å½¼æ­¤ï¼š'
- en: '[PRE2]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function is looking for a value of type `A` as input, whereas we're passing
    it a value of type `B`. TypeScript compares the types structurally, and because
    they have exactly the same structure it deems this operation to be fine.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: å‡½æ•°æœŸæœ›è¾“å…¥ç±»å‹ä¸º`A`çš„å€¼ï¼Œè€Œæˆ‘ä»¬ä¼ é€’çš„æ˜¯ç±»å‹ä¸º`B`çš„å€¼ã€‚TypeScripté€šè¿‡ç»“æ„æ¯”è¾ƒè¿™ä¸¤ç§ç±»å‹ï¼Œå› ä¸ºå®ƒä»¬å…·æœ‰å®Œå…¨ç›¸åŒçš„ç»“æ„ï¼Œæ‰€ä»¥è®¤ä¸ºè¿™ä¸ªæ“ä½œæ˜¯å¯ä»¥æ¥å—çš„ã€‚
- en: But what if we need to tell `A` and `B` apart? What if, conceptually speaking,
    they must be different? What if we're doing something fancy with `A` and `B` which
    TypeScript is unaware of but we require the types to be different? That's exactly
    the situation we found ourselves in lately!
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬éœ€è¦åŒºåˆ†`A`å’Œ`B`æ€ä¹ˆåŠï¼Ÿæ¦‚å¿µä¸Šè®²ï¼Œå®ƒä»¬å¿…é¡»ä¸åŒå—ï¼Ÿå¦‚æœæˆ‘ä»¬åœ¨`A`å’Œ`B`ä¸Šåšä¸€äº›TypeScriptä¸çŸ¥é“ä½†æˆ‘ä»¬éœ€è¦è¿™äº›ç±»å‹ä¸åŒçš„èŠ±å“¨äº‹æƒ…ï¼Œé‚£å°±æ˜¯æˆ‘ä»¬æœ€è¿‘é‡åˆ°çš„æƒ…å†µï¼
- en: We need branding to do exactly that.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦å“ç‰ŒåŒ–æ¥æ­£å¥½åšåˆ°è¿™ä¸€ç‚¹ã€‚
- en: The solution
  id: totrans-split-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆ
- en: Much like in the [TypeScript mapped types article](/articles/typescript-mapped-type-magic/),
    the key lies in creating a field with the name of a symbol to act as our *id*.
    However, with branding we only need this field at a type-level rather than the
    runtime-level. Since types are erased after compilation, we need to add this field
    to a type without altering the runtime data whatsoever. Casting, anyone?
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: å°±åƒåœ¨[TypeScriptæ˜ å°„ç±»å‹æ–‡ç« ](/articles/typescript-mapped-type-magic/)ä¸­ä¸€æ ·ï¼Œå…³é”®åœ¨äºåˆ›å»ºä¸€ä¸ªå¸¦æœ‰ç¬¦å·åç§°çš„å­—æ®µä½œä¸ºæˆ‘ä»¬çš„*id*ã€‚ç„¶è€Œï¼Œä½¿ç”¨å“ç‰ŒåŒ–æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨ç±»å‹çº§åˆ«æ·»åŠ è¿™ä¸ªå­—æ®µï¼Œè€Œä¸æ˜¯åœ¨è¿è¡Œæ—¶çº§åˆ«ã€‚ç”±äºç±»å‹åœ¨ç¼–è¯‘åè¢«æŠ¹é™¤ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ä¸æ”¹å˜è¿è¡Œæ—¶æ•°æ®çš„æƒ…å†µä¸‹å‘ç±»å‹æ·»åŠ è¿™ä¸ªå­—æ®µã€‚éœ€è¦ç±»å‹è½¬æ¢ï¼Œå¯¹å§ï¼Ÿ
- en: First, lets introduce the `brand` field.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè®©æˆ‘ä»¬ä»‹ç»`brand`å­—æ®µã€‚
- en: '[PRE3]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we''re adding the `brand` field to type `A`. The brand field name is a
    symbol, akin to a UUID. We use a symbol to ensure the `brand` field never clashes
    with any other field for `A`, because we''d be overwriting a field otherwise and
    introducing the worse kind of bugs: type bugs ğŸ› . We''ve set the brand to `''A''`
    at the moment, though this could be anything you desire. It''s akin to the type
    name. Now let''s compare `A` and `B` again:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æ­£åœ¨ä¸ºç±»å‹`A`æ·»åŠ `brand`å­—æ®µã€‚å“ç‰Œå­—æ®µåç§°æ˜¯ä¸€ä¸ªç¬¦å·ï¼Œç±»ä¼¼äºUUIDã€‚æˆ‘ä»¬ä½¿ç”¨ç¬¦å·æ¥ç¡®ä¿`A`çš„å“ç‰Œå­—æ®µæ°¸è¿œä¸ä¼šä¸`A`çš„ä»»ä½•å…¶ä»–å­—æ®µå†²çªï¼Œå¦åˆ™æˆ‘ä»¬å°†è¦†ç›–ä¸€ä¸ªå­—æ®µå¹¶å¼•å…¥æ›´ç³Ÿç³•çš„é”™è¯¯ï¼šç±»å‹é”™è¯¯
    ğŸ› ã€‚ç›®å‰æˆ‘ä»¬å°†å“ç‰Œè®¾ç½®ä¸º`'A'`ï¼Œä½†è¿™å¯ä»¥æ˜¯ä½ æƒ³è¦çš„ä»»ä½•å†…å®¹ã€‚è¿™ç±»ä¼¼äºç±»å‹åç§°ã€‚ç°åœ¨è®©æˆ‘ä»¬å†æ¬¡æ¯”è¾ƒ`A`å’Œ`B`ï¼š
- en: '[PRE4]'
  id: totrans-split-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s the error:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯é”™è¯¯çš„æ‰€åœ¨ï¼š
- en: '[PRE5]'
  id: totrans-split-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: TypeScript won't let us pass an instance of `B` to the function accepting `A`
    because it's missing the `brand` field - brilliant! `A` and `B` are now different
    types. But what about if `B` had its own brand?
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript ä¸å…è®¸æˆ‘ä»¬å°† `B` çš„å®ä¾‹ä¼ é€’ç»™æ¥å— `A` çš„å‡½æ•°ï¼Œå› ä¸ºå®ƒç¼ºå°‘ `brand` å­—æ®µ - å¤ªæ£’äº†ï¼`A` å’Œ `B` ç°åœ¨æ˜¯ä¸åŒçš„ç±»å‹äº†ã€‚ä½†æ˜¯å¦‚æœ
    `B` æœ‰è‡ªå·±çš„å“ç‰Œå‘¢ï¼Ÿ
- en: '[PRE6]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that we're using the same `brand` variable from before. It's important
    to keep this constant, otherwise we're declaring fields with different names!
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä»ç„¶ä½¿ç”¨ä¹‹å‰çš„ç›¸åŒ `brand` å˜é‡ã€‚ä¿æŒè¿™ä¸ªå¸¸é‡éå¸¸é‡è¦ï¼Œå¦åˆ™æˆ‘ä»¬å°†å£°æ˜å…·æœ‰ä¸åŒåç§°çš„å­—æ®µï¼
- en: 'Now lets try the function again:'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å†è¯•è¯•è¿™ä¸ªå‡½æ•°ï¼š
- en: '[PRE7]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And here's the error
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯é”™è¯¯
- en: '[PRE8]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There we go! The error is saying that though both types have a `brand` field,
    the value for the brand is different for the two types, i.e. `'A' != 'B'`!
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: å°±è¿™æ ·äº†ï¼é”™è¯¯è¡¨æ˜ï¼Œå°½ç®¡ä¸¤ç§ç±»å‹éƒ½æœ‰ä¸€ä¸ª `brand` å­—æ®µï¼Œä½†è¿™ä¸¤ç§ç±»å‹çš„å“ç‰Œå€¼ä¸åŒï¼Œå³ `'A' != 'B'`ï¼
- en: 'Let''s see what happens if the `brand` is the same:'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹å¦‚æœ `brand` æ˜¯ç›¸åŒçš„ä¼šå‘ç”Ÿä»€ä¹ˆï¼š
- en: '[PRE9]'
  id: totrans-split-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: No error! `A` and `B` are seen as interchangeable types because they're structurally
    the same, having the same fields *and* same brand value of `'foobar'`. Excellent!
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰é”™è¯¯ï¼`A` å’Œ `B` è¢«è§†ä¸ºå¯äº’æ¢çš„ç±»å‹ï¼Œå› ä¸ºå®ƒä»¬åœ¨ç»“æ„ä¸Šæ˜¯ç›¸åŒçš„ï¼Œå…·æœ‰ç›¸åŒçš„å­—æ®µ *å’Œ* `'foobar'` çš„å“ç‰Œå€¼ã€‚å¤ªæ£’äº†ï¼
- en: Make it generic!
  id: totrans-split-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®©å®ƒæˆä¸ºæ³›å‹ï¼
- en: 'Awesome, so that works. But it''s a toy example, not fit for production. Let''s
    create a `Brand` type which can brand any type you wish:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: å¤ªæ£’äº†ï¼Œè¿™æ ·å°±è¡Œäº†ã€‚ä½†è¿™åªæ˜¯ä¸€ä¸ªç©å…·ç¤ºä¾‹ï¼Œä¸é€‚åˆç”Ÿäº§ã€‚è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå¯ä»¥ä¸ºä»»ä½•æ‚¨å¸Œæœ›çš„ç±»å‹æ·»åŠ å“ç‰Œçš„ `Brand` ç±»å‹ï¼š
- en: '[PRE10]'
  id: totrans-split-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This type is very simple, it takes your type `T` and adds a `brand` field with
    `U` being the brand value. Here''s how to use it:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ç±»å‹éå¸¸ç®€å•ï¼Œå®ƒæ¥å—æ‚¨çš„ç±»å‹ `T` å¹¶æ·»åŠ ä¸€ä¸ªå¸¦æœ‰ `U` å“ç‰Œå€¼çš„ `brand` å­—æ®µã€‚è¿™é‡Œæ˜¯å¦‚ä½•ä½¿ç”¨å®ƒçš„ï¼š
- en: '[PRE11]'
  id: totrans-split-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So now we can brand any type. For completeness, here''s the same kind of thing
    to *remove* the brand and go back to plain ol'' TypeScript types:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ç»™ä»»ä½•ç±»å‹æ·»åŠ å“ç‰Œäº†ã€‚ä¸ºäº†å®Œæ•´èµ·è§ï¼Œè¿™é‡Œæ˜¯åŒæ ·ç±»å‹çš„å†…å®¹ï¼Œç”¨äº *ç§»é™¤* å“ç‰Œå¹¶å›åˆ°æ™®é€šçš„ TypeScript ç±»å‹ï¼š
- en: '[PRE12]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And this will remove the `brand` field from any branded type. Also note that
    if the type is not branded, it will not be touched!
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†ä»ä»»ä½•å¸¦å“ç‰Œçš„ç±»å‹ä¸­ç§»é™¤ `brand` å­—æ®µã€‚è¿˜è¦æ³¨æ„ï¼Œå¦‚æœç±»å‹æ²¡æœ‰å“ç‰Œï¼Œå®ƒå°†ä¸ä¼šå—åˆ°å½±å“ï¼
- en: Real world usage
  id: totrans-split-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç°å®ä¸–ç•Œçš„ç”¨æ³•
- en: Let's put this into practice. We've got a class which needs branding to identify
    its type when dealing with [mapped types](/articles/typescript-mapped-type-magic/).
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æŠŠè¿™ä¸ªåº”ç”¨åˆ°å®è·µä¸­ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªéœ€è¦é€šè¿‡[æ˜ å°„ç±»å‹](/articles/typescript-mapped-type-magic/)æ¥è¯†åˆ«å…¶ç±»å‹çš„ç±»ã€‚
- en: 'For simplicity, lets boil the class down to a `Dog` class:'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç®€å•èµ·è§ï¼Œè®©æˆ‘ä»¬å°†è¿™ä¸ªç±»ç®€åŒ–ä¸ºä¸€ä¸ª `Dog` ç±»ï¼š
- en: '[PRE13]'
  id: totrans-split-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: TypeScript won't let us construct a branded dog ğŸ˜¢ . We're going to need to do
    some casting using the constructor to brand the *constructor* rather than the
    *class* itself.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript ä¸å…è®¸æˆ‘ä»¬æ„é€ ä¸€ä¸ªå¸¦æœ‰å“ç‰Œçš„ç‹— ğŸ˜¢ ã€‚æˆ‘ä»¬éœ€è¦ä½¿ç”¨æ„é€ å‡½æ•°è¿›è¡Œä¸€äº›ç±»å‹è½¬æ¢ï¼Œè¿™æ ·å¯ä»¥ç»™ *æ„é€ å‡½æ•°* è€Œä¸æ˜¯ *ç±»* è‡ªèº«æ·»åŠ å“ç‰Œã€‚
- en: '[PRE14]'
  id: totrans-split-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `addBrand` function takes a constructor of a class and casts it to a branded
    type. This essentially makes an alias for the `Dog` class which can be used in
    exactly the same way as the `Dog` class, e.g. calling `new` on it.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`addBrand` å‡½æ•°æ¥å—ä¸€ä¸ªç±»çš„æ„é€ å‡½æ•°å¹¶å°†å…¶è½¬æ¢ä¸ºå¸¦æœ‰å“ç‰Œçš„ç±»å‹ã€‚è¿™æœ¬è´¨ä¸Šæ˜¯ä¸º `Dog` ç±»åˆ›å»ºä¸€ä¸ªåˆ«åï¼Œå®ƒå¯ä»¥ä¸ `Dog` ç±»å®Œå…¨ç›¸åŒçš„æ–¹å¼ä½¿ç”¨ï¼Œä¾‹å¦‚åœ¨å…¶ä¸Šè°ƒç”¨
    `new`ã€‚'
- en: 'We can `export` the `DogBranded` type to allow the outer world to use our class
    whilst ensuring it''s always branded:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ `export` `DogBranded` ç±»å‹ä»¥å…è®¸å¤–éƒ¨ä¸–ç•Œä½¿ç”¨æˆ‘ä»¬çš„ç±»ï¼ŒåŒæ—¶ç¡®ä¿å®ƒå§‹ç»ˆæ˜¯å¸¦å“ç‰Œçš„ï¼š
- en: '[PRE15]'
  id: totrans-split-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Likewise, we can do the same for brand removal:'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹å»é™¤å“ç‰Œçš„æ“ä½œåšåŒæ ·çš„å¤„ç†ï¼š
- en: '[PRE16]'
  id: totrans-split-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This simply removes the brand by casting the type to a type mapped without the
    brand field.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åªæ˜¯é€šè¿‡å°†ç±»å‹è½¬æ¢ä¸ºæ²¡æœ‰ `brand` å­—æ®µçš„ç±»å‹æ˜ å°„æ¥åˆ é™¤å“ç‰Œã€‚
- en: 'And there we go: a sure-fire way to brand and un-brand your types in TypeScript
    ğŸ˜ƒ'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬æ¥äº†ï¼šåœ¨ TypeScript ä¸­åˆ›å»ºå’Œç§»é™¤ç±»å‹å“ç‰Œçš„ç»ä½³æ–¹æ³• ğŸ˜ƒ
- en: We've published this work as a library which you can access via [NPM](https://www.npmjs.com/package/@prosopo/ts-brand)!
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²å°†æ­¤å·¥ä½œå‘å¸ƒä¸ºä¸€ä¸ªåº“ï¼Œæ‚¨å¯ä»¥é€šè¿‡[NPM](https://www.npmjs.com/package/@prosopo/ts-brand)è®¿é—®ï¼
- en: At Prosopo, we're using TypeScript branding to fortify our types and do clever
    type mapping for our soon-to-be-released runtime type validator. Stay tuned for
    updates!
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Prosopoï¼Œæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨ TypeScript çš„å“ç‰ŒæŠ€æœ¯æ¥å¼ºåŒ–æˆ‘ä»¬çš„ç±»å‹ï¼Œå¹¶ä¸ºå³å°†å‘å¸ƒçš„è¿è¡Œæ—¶ç±»å‹éªŒè¯å™¨è¿›è¡Œæ™ºèƒ½ç±»å‹æ˜ å°„ã€‚æ•¬è¯·æœŸå¾…æ›´æ–°ï¼
- en: '**[PART 1: TypeScript Mapped Type Magic](/articles/typescript-mapped-type-magic/)**'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**[ç¬¬ä¸€éƒ¨åˆ†ï¼šTypeScript æ˜ å°„ç±»å‹çš„é­”æ³•](/articles/typescript-mapped-type-magic/)**'
- en: '* * *'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
