- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:29:40'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript: Branded Types ğŸ”§ - Prosopo'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: æ¥æºï¼š[https://prosopo.io/articles/typescript-branding/](https://prosopo.io/articles/typescript-branding/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**[PART 1: TypeScript Mapped Type Magic](/articles/typescript-mapped-type-magic/)**'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Ahoy there TypeScript warriors! ğŸ‘‹ Today we're extending our work in the [TypeScript
    mapped types article](/articles/typescript-mapped-type-magic/) to provide *branding*.
    The previous article discussed how to use TypeScript mapped types in a nominal
    rather than structural nature.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a fancy way of saying TypeScript is structural by default, i.e. it will
    see type `A` and `B` as equal when dealing with types. Making type `A` and `B`
    nominal would make TypeScript differentiate them apart, even though their structure
    is the same.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we're building on that work to produce a way to *brand* a type,
    providing an automated and easy-to-use way of making a type nominal. Branding
    focuses on the type system only, rather than introducing runtime fields like in
    the previous post, which is a major benefit over the previous approach.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: What's the problem?
  id: totrans-split-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Branding, also known as opaque types, enable differentiation of types in TypeScript
    which otherwise would be classified as the same type. For example
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`A` and `B` are structurally the same, ergo TypeScript accepts any instance
    of `A` or `B` in place of each other:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function is looking for a value of type `A` as input, whereas we're passing
    it a value of type `B`. TypeScript compares the types structurally, and because
    they have exactly the same structure it deems this operation to be fine.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: But what if we need to tell `A` and `B` apart? What if, conceptually speaking,
    they must be different? What if we're doing something fancy with `A` and `B` which
    TypeScript is unaware of but we require the types to be different? That's exactly
    the situation we found ourselves in lately!
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: We need branding to do exactly that.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: The solution
  id: totrans-split-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like in the [TypeScript mapped types article](/articles/typescript-mapped-type-magic/),
    the key lies in creating a field with the name of a symbol to act as our *id*.
    However, with branding we only need this field at a type-level rather than the
    runtime-level. Since types are erased after compilation, we need to add this field
    to a type without altering the runtime data whatsoever. Casting, anyone?
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: First, lets introduce the `brand` field.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we''re adding the `brand` field to type `A`. The brand field name is a
    symbol, akin to a UUID. We use a symbol to ensure the `brand` field never clashes
    with any other field for `A`, because we''d be overwriting a field otherwise and
    introducing the worse kind of bugs: type bugs ğŸ› . We''ve set the brand to `''A''`
    at the moment, though this could be anything you desire. It''s akin to the type
    name. Now let''s compare `A` and `B` again:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s the error:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: TypeScript won't let us pass an instance of `B` to the function accepting `A`
    because it's missing the `brand` field - brilliant! `A` and `B` are now different
    types. But what about if `B` had its own brand?
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript ä¸å…è®¸æˆ‘ä»¬å°† `B` çš„å®ä¾‹ä¼ é€’ç»™æ¥å— `A` çš„å‡½æ•°ï¼Œå› ä¸ºå®ƒç¼ºå°‘ `brand` å­—æ®µ - å¤ªæ£’äº†ï¼`A` å’Œ `B` ç°åœ¨æ˜¯ä¸åŒçš„ç±»å‹äº†ã€‚ä½†æ˜¯å¦‚æœ
    `B` æœ‰è‡ªå·±çš„å“ç‰Œå‘¢ï¼Ÿ
- en: '[PRE6]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that we're using the same `brand` variable from before. It's important
    to keep this constant, otherwise we're declaring fields with different names!
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä»ç„¶ä½¿ç”¨ä¹‹å‰çš„ç›¸åŒ `brand` å˜é‡ã€‚ä¿æŒè¿™ä¸ªå¸¸é‡éå¸¸é‡è¦ï¼Œå¦åˆ™æˆ‘ä»¬å°†å£°æ˜å…·æœ‰ä¸åŒåç§°çš„å­—æ®µï¼
- en: 'Now lets try the function again:'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å†è¯•è¯•è¿™ä¸ªå‡½æ•°ï¼š
- en: '[PRE7]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And here's the error
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯é”™è¯¯
- en: '[PRE8]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There we go! The error is saying that though both types have a `brand` field,
    the value for the brand is different for the two types, i.e. `'A' != 'B'`!
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: å°±è¿™æ ·äº†ï¼é”™è¯¯è¡¨æ˜ï¼Œå°½ç®¡ä¸¤ç§ç±»å‹éƒ½æœ‰ä¸€ä¸ª `brand` å­—æ®µï¼Œä½†è¿™ä¸¤ç§ç±»å‹çš„å“ç‰Œå€¼ä¸åŒï¼Œå³ `'A' != 'B'`ï¼
- en: 'Let''s see what happens if the `brand` is the same:'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹å¦‚æœ `brand` æ˜¯ç›¸åŒçš„ä¼šå‘ç”Ÿä»€ä¹ˆï¼š
- en: '[PRE9]'
  id: totrans-split-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: No error! `A` and `B` are seen as interchangeable types because they're structurally
    the same, having the same fields *and* same brand value of `'foobar'`. Excellent!
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰é”™è¯¯ï¼`A` å’Œ `B` è¢«è§†ä¸ºå¯äº’æ¢çš„ç±»å‹ï¼Œå› ä¸ºå®ƒä»¬åœ¨ç»“æ„ä¸Šæ˜¯ç›¸åŒçš„ï¼Œå…·æœ‰ç›¸åŒçš„å­—æ®µ *å’Œ* `'foobar'` çš„å“ç‰Œå€¼ã€‚å¤ªæ£’äº†ï¼
- en: Make it generic!
  id: totrans-split-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®©å®ƒæˆä¸ºæ³›å‹ï¼
- en: 'Awesome, so that works. But it''s a toy example, not fit for production. Let''s
    create a `Brand` type which can brand any type you wish:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: å¤ªæ£’äº†ï¼Œè¿™æ ·å°±è¡Œäº†ã€‚ä½†è¿™åªæ˜¯ä¸€ä¸ªç©å…·ç¤ºä¾‹ï¼Œä¸é€‚åˆç”Ÿäº§ã€‚è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå¯ä»¥ä¸ºä»»ä½•æ‚¨å¸Œæœ›çš„ç±»å‹æ·»åŠ å“ç‰Œçš„ `Brand` ç±»å‹ï¼š
- en: '[PRE10]'
  id: totrans-split-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This type is very simple, it takes your type `T` and adds a `brand` field with
    `U` being the brand value. Here''s how to use it:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ç±»å‹éå¸¸ç®€å•ï¼Œå®ƒæ¥å—æ‚¨çš„ç±»å‹ `T` å¹¶æ·»åŠ ä¸€ä¸ªå¸¦æœ‰ `U` å“ç‰Œå€¼çš„ `brand` å­—æ®µã€‚è¿™é‡Œæ˜¯å¦‚ä½•ä½¿ç”¨å®ƒçš„ï¼š
- en: '[PRE11]'
  id: totrans-split-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So now we can brand any type. For completeness, here''s the same kind of thing
    to *remove* the brand and go back to plain ol'' TypeScript types:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ç»™ä»»ä½•ç±»å‹æ·»åŠ å“ç‰Œäº†ã€‚ä¸ºäº†å®Œæ•´èµ·è§ï¼Œè¿™é‡Œæ˜¯åŒæ ·ç±»å‹çš„å†…å®¹ï¼Œç”¨äº *ç§»é™¤* å“ç‰Œå¹¶å›åˆ°æ™®é€šçš„ TypeScript ç±»å‹ï¼š
- en: '[PRE12]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And this will remove the `brand` field from any branded type. Also note that
    if the type is not branded, it will not be touched!
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†ä»ä»»ä½•å¸¦å“ç‰Œçš„ç±»å‹ä¸­ç§»é™¤ `brand` å­—æ®µã€‚è¿˜è¦æ³¨æ„ï¼Œå¦‚æœç±»å‹æ²¡æœ‰å“ç‰Œï¼Œå®ƒå°†ä¸ä¼šå—åˆ°å½±å“ï¼
- en: Real world usage
  id: totrans-split-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç°å®ä¸–ç•Œçš„ç”¨æ³•
- en: Let's put this into practice. We've got a class which needs branding to identify
    its type when dealing with [mapped types](/articles/typescript-mapped-type-magic/).
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æŠŠè¿™ä¸ªåº”ç”¨åˆ°å®è·µä¸­ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªéœ€è¦é€šè¿‡[æ˜ å°„ç±»å‹](/articles/typescript-mapped-type-magic/)æ¥è¯†åˆ«å…¶ç±»å‹çš„ç±»ã€‚
- en: 'For simplicity, lets boil the class down to a `Dog` class:'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç®€å•èµ·è§ï¼Œè®©æˆ‘ä»¬å°†è¿™ä¸ªç±»ç®€åŒ–ä¸ºä¸€ä¸ª `Dog` ç±»ï¼š
- en: '[PRE13]'
  id: totrans-split-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: TypeScript won't let us construct a branded dog ğŸ˜¢ . We're going to need to do
    some casting using the constructor to brand the *constructor* rather than the
    *class* itself.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript ä¸å…è®¸æˆ‘ä»¬æ„é€ ä¸€ä¸ªå¸¦æœ‰å“ç‰Œçš„ç‹— ğŸ˜¢ ã€‚æˆ‘ä»¬éœ€è¦ä½¿ç”¨æ„é€ å‡½æ•°è¿›è¡Œä¸€äº›ç±»å‹è½¬æ¢ï¼Œè¿™æ ·å¯ä»¥ç»™ *æ„é€ å‡½æ•°* è€Œä¸æ˜¯ *ç±»* è‡ªèº«æ·»åŠ å“ç‰Œã€‚
- en: '[PRE14]'
  id: totrans-split-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `addBrand` function takes a constructor of a class and casts it to a branded
    type. This essentially makes an alias for the `Dog` class which can be used in
    exactly the same way as the `Dog` class, e.g. calling `new` on it.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`addBrand` å‡½æ•°æ¥å—ä¸€ä¸ªç±»çš„æ„é€ å‡½æ•°å¹¶å°†å…¶è½¬æ¢ä¸ºå¸¦æœ‰å“ç‰Œçš„ç±»å‹ã€‚è¿™æœ¬è´¨ä¸Šæ˜¯ä¸º `Dog` ç±»åˆ›å»ºä¸€ä¸ªåˆ«åï¼Œå®ƒå¯ä»¥ä¸ `Dog` ç±»å®Œå…¨ç›¸åŒçš„æ–¹å¼ä½¿ç”¨ï¼Œä¾‹å¦‚åœ¨å…¶ä¸Šè°ƒç”¨
    `new`ã€‚'
- en: 'We can `export` the `DogBranded` type to allow the outer world to use our class
    whilst ensuring it''s always branded:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ `export` `DogBranded` ç±»å‹ä»¥å…è®¸å¤–éƒ¨ä¸–ç•Œä½¿ç”¨æˆ‘ä»¬çš„ç±»ï¼ŒåŒæ—¶ç¡®ä¿å®ƒå§‹ç»ˆæ˜¯å¸¦å“ç‰Œçš„ï¼š
- en: '[PRE15]'
  id: totrans-split-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Likewise, we can do the same for brand removal:'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹å»é™¤å“ç‰Œçš„æ“ä½œåšåŒæ ·çš„å¤„ç†ï¼š
- en: '[PRE16]'
  id: totrans-split-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This simply removes the brand by casting the type to a type mapped without the
    brand field.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åªæ˜¯é€šè¿‡å°†ç±»å‹è½¬æ¢ä¸ºæ²¡æœ‰ `brand` å­—æ®µçš„ç±»å‹æ˜ å°„æ¥åˆ é™¤å“ç‰Œã€‚
- en: 'And there we go: a sure-fire way to brand and un-brand your types in TypeScript
    ğŸ˜ƒ'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬æ¥äº†ï¼šåœ¨ TypeScript ä¸­åˆ›å»ºå’Œç§»é™¤ç±»å‹å“ç‰Œçš„ç»ä½³æ–¹æ³• ğŸ˜ƒ
- en: We've published this work as a library which you can access via [NPM](https://www.npmjs.com/package/@prosopo/ts-brand)!
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²å°†æ­¤å·¥ä½œå‘å¸ƒä¸ºä¸€ä¸ªåº“ï¼Œæ‚¨å¯ä»¥é€šè¿‡[NPM](https://www.npmjs.com/package/@prosopo/ts-brand)è®¿é—®ï¼
- en: At Prosopo, we're using TypeScript branding to fortify our types and do clever
    type mapping for our soon-to-be-released runtime type validator. Stay tuned for
    updates!
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Prosopoï¼Œæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨ TypeScript çš„å“ç‰ŒæŠ€æœ¯æ¥å¼ºåŒ–æˆ‘ä»¬çš„ç±»å‹ï¼Œå¹¶ä¸ºå³å°†å‘å¸ƒçš„è¿è¡Œæ—¶ç±»å‹éªŒè¯å™¨è¿›è¡Œæ™ºèƒ½ç±»å‹æ˜ å°„ã€‚æ•¬è¯·æœŸå¾…æ›´æ–°ï¼
- en: '**[PART 1: TypeScript Mapped Type Magic](/articles/typescript-mapped-type-magic/)**'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**[ç¬¬ä¸€éƒ¨åˆ†ï¼šTypeScript æ˜ å°„ç±»å‹çš„é­”æ³•](/articles/typescript-mapped-type-magic/)**'
- en: '* * *'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
