- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:29:40'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript: Branded Types 🔧 - Prosopo'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://prosopo.io/articles/typescript-branding/](https://prosopo.io/articles/typescript-branding/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**[PART 1: TypeScript Mapped Type Magic](/articles/typescript-mapped-type-magic/)**'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Ahoy there TypeScript warriors! 👋 Today we're extending our work in the [TypeScript
    mapped types article](/articles/typescript-mapped-type-magic/) to provide *branding*.
    The previous article discussed how to use TypeScript mapped types in a nominal
    rather than structural nature.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a fancy way of saying TypeScript is structural by default, i.e. it will
    see type `A` and `B` as equal when dealing with types. Making type `A` and `B`
    nominal would make TypeScript differentiate them apart, even though their structure
    is the same.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we're building on that work to produce a way to *brand* a type,
    providing an automated and easy-to-use way of making a type nominal. Branding
    focuses on the type system only, rather than introducing runtime fields like in
    the previous post, which is a major benefit over the previous approach.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: What's the problem?
  id: totrans-split-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Branding, also known as opaque types, enable differentiation of types in TypeScript
    which otherwise would be classified as the same type. For example
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`A` and `B` are structurally the same, ergo TypeScript accepts any instance
    of `A` or `B` in place of each other:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function is looking for a value of type `A` as input, whereas we're passing
    it a value of type `B`. TypeScript compares the types structurally, and because
    they have exactly the same structure it deems this operation to be fine.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: But what if we need to tell `A` and `B` apart? What if, conceptually speaking,
    they must be different? What if we're doing something fancy with `A` and `B` which
    TypeScript is unaware of but we require the types to be different? That's exactly
    the situation we found ourselves in lately!
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: We need branding to do exactly that.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: The solution
  id: totrans-split-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like in the [TypeScript mapped types article](/articles/typescript-mapped-type-magic/),
    the key lies in creating a field with the name of a symbol to act as our *id*.
    However, with branding we only need this field at a type-level rather than the
    runtime-level. Since types are erased after compilation, we need to add this field
    to a type without altering the runtime data whatsoever. Casting, anyone?
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: First, lets introduce the `brand` field.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we''re adding the `brand` field to type `A`. The brand field name is a
    symbol, akin to a UUID. We use a symbol to ensure the `brand` field never clashes
    with any other field for `A`, because we''d be overwriting a field otherwise and
    introducing the worse kind of bugs: type bugs 🐛 . We''ve set the brand to `''A''`
    at the moment, though this could be anything you desire. It''s akin to the type
    name. Now let''s compare `A` and `B` again:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s the error:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: TypeScript won't let us pass an instance of `B` to the function accepting `A`
    because it's missing the `brand` field - brilliant! `A` and `B` are now different
    types. But what about if `B` had its own brand?
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 不允许我们将 `B` 的实例传递给接受 `A` 的函数，因为它缺少 `brand` 字段 - 太棒了！`A` 和 `B` 现在是不同的类型了。但是如果
    `B` 有自己的品牌呢？
- en: '[PRE6]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that we're using the same `brand` variable from before. It's important
    to keep this constant, otherwise we're declaring fields with different names!
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们仍然使用之前的相同 `brand` 变量。保持这个常量非常重要，否则我们将声明具有不同名称的字段！
- en: 'Now lets try the function again:'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再试试这个函数：
- en: '[PRE7]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And here's the error
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是错误
- en: '[PRE8]'
  id: totrans-split-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There we go! The error is saying that though both types have a `brand` field,
    the value for the brand is different for the two types, i.e. `'A' != 'B'`!
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样了！错误表明，尽管两种类型都有一个 `brand` 字段，但这两种类型的品牌值不同，即 `'A' != 'B'`！
- en: 'Let''s see what happens if the `brand` is the same:'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果 `brand` 是相同的会发生什么：
- en: '[PRE9]'
  id: totrans-split-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: No error! `A` and `B` are seen as interchangeable types because they're structurally
    the same, having the same fields *and* same brand value of `'foobar'`. Excellent!
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 没有错误！`A` 和 `B` 被视为可互换的类型，因为它们在结构上是相同的，具有相同的字段 *和* `'foobar'` 的品牌值。太棒了！
- en: Make it generic!
  id: totrans-split-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让它成为泛型！
- en: 'Awesome, so that works. But it''s a toy example, not fit for production. Let''s
    create a `Brand` type which can brand any type you wish:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，这样就行了。但这只是一个玩具示例，不适合生产。让我们创建一个可以为任何您希望的类型添加品牌的 `Brand` 类型：
- en: '[PRE10]'
  id: totrans-split-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This type is very simple, it takes your type `T` and adds a `brand` field with
    `U` being the brand value. Here''s how to use it:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型非常简单，它接受您的类型 `T` 并添加一个带有 `U` 品牌值的 `brand` 字段。这里是如何使用它的：
- en: '[PRE11]'
  id: totrans-split-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So now we can brand any type. For completeness, here''s the same kind of thing
    to *remove* the brand and go back to plain ol'' TypeScript types:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以给任何类型添加品牌了。为了完整起见，这里是同样类型的内容，用于 *移除* 品牌并回到普通的 TypeScript 类型：
- en: '[PRE12]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And this will remove the `brand` field from any branded type. Also note that
    if the type is not branded, it will not be touched!
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从任何带品牌的类型中移除 `brand` 字段。还要注意，如果类型没有品牌，它将不会受到影响！
- en: Real world usage
  id: totrans-split-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界的用法
- en: Let's put this into practice. We've got a class which needs branding to identify
    its type when dealing with [mapped types](/articles/typescript-mapped-type-magic/).
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个应用到实践中。我们有一个需要通过[映射类型](/articles/typescript-mapped-type-magic/)来识别其类型的类。
- en: 'For simplicity, lets boil the class down to a `Dog` class:'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们将这个类简化为一个 `Dog` 类：
- en: '[PRE13]'
  id: totrans-split-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: TypeScript won't let us construct a branded dog 😢 . We're going to need to do
    some casting using the constructor to brand the *constructor* rather than the
    *class* itself.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 不允许我们构造一个带有品牌的狗 😢 。我们需要使用构造函数进行一些类型转换，这样可以给 *构造函数* 而不是 *类* 自身添加品牌。
- en: '[PRE14]'
  id: totrans-split-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `addBrand` function takes a constructor of a class and casts it to a branded
    type. This essentially makes an alias for the `Dog` class which can be used in
    exactly the same way as the `Dog` class, e.g. calling `new` on it.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`addBrand` 函数接受一个类的构造函数并将其转换为带有品牌的类型。这本质上是为 `Dog` 类创建一个别名，它可以与 `Dog` 类完全相同的方式使用，例如在其上调用
    `new`。'
- en: 'We can `export` the `DogBranded` type to allow the outer world to use our class
    whilst ensuring it''s always branded:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以 `export` `DogBranded` 类型以允许外部世界使用我们的类，同时确保它始终是带品牌的：
- en: '[PRE15]'
  id: totrans-split-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Likewise, we can do the same for brand removal:'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以对去除品牌的操作做同样的处理：
- en: '[PRE16]'
  id: totrans-split-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This simply removes the brand by casting the type to a type mapped without the
    brand field.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是通过将类型转换为没有 `brand` 字段的类型映射来删除品牌。
- en: 'And there we go: a sure-fire way to brand and un-brand your types in TypeScript
    😃'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们来了：在 TypeScript 中创建和移除类型品牌的绝佳方法 😃
- en: We've published this work as a library which you can access via [NPM](https://www.npmjs.com/package/@prosopo/ts-brand)!
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将此工作发布为一个库，您可以通过[NPM](https://www.npmjs.com/package/@prosopo/ts-brand)访问！
- en: At Prosopo, we're using TypeScript branding to fortify our types and do clever
    type mapping for our soon-to-be-released runtime type validator. Stay tuned for
    updates!
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Prosopo，我们正在使用 TypeScript 的品牌技术来强化我们的类型，并为即将发布的运行时类型验证器进行智能类型映射。敬请期待更新！
- en: '**[PART 1: TypeScript Mapped Type Magic](/articles/typescript-mapped-type-magic/)**'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第一部分：TypeScript 映射类型的魔法](/articles/typescript-mapped-type-magic/)**'
- en: '* * *'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
