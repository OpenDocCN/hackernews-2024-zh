<!--yml

category: 未分类

date: 2024-05-27 13:11:10

-->

# 神秘的指针移动问题 - blomqu.ist

> 来源：[https://blomqu.ist/posts/2024/move/](https://blomqu.ist/posts/2024/move/)

在工作中，我们已经开始了现代化我们的代码库的过程。我们目前使用的是 Visual Studio 2013，并计划升级到 Visual Studio 2022。像任何现代化的努力一样，语言的变化可能会破坏现有的软件，因为某些功能被弃用并添加了新功能。有一款软件是专门为 Windows 构建的，在升级项目后，一个重要的类始终导致分段错误。

下面是描述问题代码的最小示例：

```
struct Node {
 std::vector<Connection> connections; };   struct Connection {
 Node *from, *to; };   struct Graph {
 std::vector<std::list<Node>> nodes; }; 
```

在这个图中，一个节点存储其与其他节点的连接。当建立连接时，指针被认为是有效的。并且在`std::list`中的节点是稳定的，只要列表和节点本身存在，指向它的指针应该保持有效。但在某些时候，该指针失效，并且尝试访问它会导致分段错误。

第一个问题：为什么这会出错？

第二个问题：这在第一次如何工作？

对第一个问题的答案是一个经典的 C++ 陷阱。当`std::vector`增长超过其容量时，它重新分配其后备存储，并必须将现有元素放入该存储中。最好的方法是*移动*这些元素，最好的情况下实际上是一个`memcpy`。不幸的是，`std::vector`只会移动元素，如果类具有特性`is_nothrow_move_constructible`，通常通过声明移动构造函数为`noexcept`来表示。在 MSVC 中，`std::list`没有标记为这样，因此当向量重新分配时，列表被*复制*而不是移动。当列表被复制时，它的元素被复制，我们的指针失效了。

现在我们知道了它为什么会出错，我们问它在第一次能够工作的时候是如何工作的。如果`std::vector`不能移动它的元素，指针是如何保持有效的呢？

尽管截至2022年，MSVC被认为是标准的最完整实现之一，但这并非总是如此。直到2015年，微软才有了几乎完整的 C++11 实现。C++11 对语言产生了巨大的变化，引入了lambda、移动构造和`noexcept`等功能。2013年的 MSVC 具有移动构造，但没有`noexcept`。由于没有`noexcept`，`std::vector`的重新分配行为无法根据元素类型的特性而改变。它将无条件地使用元素的移动构造函数。

因此，第二个谜团得以解开。由于微软在2015年之前部分实现标准，我们可以依赖于我们的节点保持在原处，因为我们的向量会移动其中包含的列表。当我们升级时，“正确”的行为破坏了我们的代码。在我们的情况下，最简单的解决方案是将`std::vector`更改为`std::list`，以保持一切稳定。

就我个人而言，我觉得这是一个相当有趣的难题。话虽如此，要找到 bug 的源头并不需要详细了解标准及其各种实现的历史。大多数编程语言都是为编写软件而设计的。显然，C++ 是为解决谜题而设计的。
