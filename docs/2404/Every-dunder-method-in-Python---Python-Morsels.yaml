- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:53:16'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Every dunder method in Python - Python Morsels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://www.pythonmorsels.com/every-dunder-method/](https://www.pythonmorsels.com/every-dunder-method/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You've just made a class. You made a `__init__` method. Now what?
  prefs: []
  type: TYPE_NORMAL
- en: Python includes *tons* of [dunder methods](https://www.pythonmorsels.com/what-are-dunder-methods/)
    ("double underscore" methods) which allow us to deeply customize how our custom
    classes interact with Python's many features. What dunder methods could you add
    to your class to make it friendly for other Python programmers who use it?
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at **every dunder method in Python**, with a focus on when
    each method is useful.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Python documentation refers to these as [special methods](https://docs.python.org/3/glossary.html#term-special-method)
    and notes the synonym "magic method" but *very* [rarely](https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers)
    uses the term "dunder method". However, "dunder method" is a fairly common Python
    colloquialism, as noted in my [unofficial Python glossary](https://www.pythonmorsels.com/terms/).
  prefs: []
  type: TYPE_NORMAL
- en: You can use the links scattered throughout this page for more details on any
    particular dunder method. For a list of all of them, see the cheat sheet in the
    final section.
  prefs: []
  type: TYPE_NORMAL
- en: The 3 essential dunder methods üîë
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are 3 dunder methods that *most* classes should have: [`__init__`](https://www.pythonmorsels.com/what-is-init/),
    [`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/),
    and [`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/).'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| `repr(x)` | `x.__repr__()` | `str` |'
  prefs: []
  type: TYPE_TB
- en: '| `x == y` | `x.__eq__(y)` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: The [`__init__`](https://www.pythonmorsels.com/what-is-init/) method is the
    **initializer** (not to be confused with the [constructor](#construction-and-finalizing)),
    the [`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/)
    method customizes an object's string representation, and the [`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/)
    method customizes what it means for objects to be *equal* to one another.
  prefs: []
  type: TYPE_NORMAL
- en: The `__repr__` method is particularly helpful at the [the Python REPL](https://www.pythonmorsels.com/using-the-python-repl/)
    and when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Equality and hashability üü∞
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the `__eq__` method, Python has 2 other dunder methods for determining
    the "value" of an object in relation to other objects.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x == y` | `x.__eq__(y)` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `x != y` | `x.__ne__(y)` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `hash(x)` | `x.__hash__()` | `int` |'
  prefs: []
  type: TYPE_TB
- en: Python's `__eq__` method typically returns `True`, `False`, or [`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/)
    (if objects can't be compared). The default `__eq__` implementation relies on
    the `is` operator, which checks for **[identity](https://www.pythonmorsels.com/equality-vs-identity/)**.
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation of `__ne__` calls `__eq__` and negates any boolean
    return value given (or returns `NotImplemented` if `__eq__` did). This default
    behavior is usually "good enough", so **you'll almost never see `__ne__` implemented**.
  prefs: []
  type: TYPE_NORMAL
- en: Hashable objects can be used as keys in dictionaries or values in sets. All
    objects in Python are [hashable](https://www.pythonmorsels.com/what-are-hashable-objects/)
    by default, but if you've written a custom `__eq__` method then your objects *won't*
    be hashable without a custom `__hash__` method. But **the hash value of an object
    must never change** or [bad things will happen](https://pym.dev/p/2ysgz/) so **typically
    only *immutable* objects implement `__hash__`**.
  prefs: []
  type: TYPE_NORMAL
- en: For implementing equality checks, see [`__eq__` in Python](https://www.pythonmorsels.com/overloading-equality-in-python/).
    For implementing hashability, see [making hashable objects in Python](https://www.pythonmorsels.com/making-hashable-objects/).
  prefs: []
  type: TYPE_NORMAL
- en: Orderability ‚öñÔ∏è
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python's comparison operators (`<`, `>`, `<=`, `>=`) can all be overloaded with
    dunder methods as well. The comparison operators also power functions that rely
    on the relative ordering of objects, like `sorted`, `min`, and `max`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | `__lt__` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | `__gt__` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | `__le__` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | `__ge__` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: If you plan to implement all of these operators in the *typical* way (where
    `x < y` would be the same as asking `y > x`) then the [`total_ordering` decorator](https://docs.python.org/3/library/functools.html#functools.total_ordering)
    from Python's `functools` module will come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions and string formatting ‚öóÔ∏è
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a number of dunder methods for converting objects to a different
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `str(x)` | `x.__str__()` | `str` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool(x)` | `x.__bool__()` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `int(x)` | `x.__int__()` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| `float(x)` | `x.__float__()` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes(x)` | `x.__bytes__()` | [`bytes`](https://pym.dev/p/2ysgz/) |'
  prefs: []
  type: TYPE_TB
- en: '| `complex(x)` | `x.__complex__()` | [`complex`](https://docs.python.org/3/glossary.html#term-complex-number)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `f"{x:s}"` | `x.__format__(s)` | `str` |'
  prefs: []
  type: TYPE_TB
- en: '| `repr(x)` | `x.__repr__()` | `str` |'
  prefs: []
  type: TYPE_TB
- en: The `__bool__` function is used for [truthiness](https://www.pythonmorsels.com/truthiness/)
    checks, though `__len__` is used as a fallback.
  prefs: []
  type: TYPE_NORMAL
- en: If you needed to make an object that acts like a number (like [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html)
    or [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html)),
    you'll want to implement `__int__`, `__float__`, and `__complex__` so your objects
    can be converted to other numbers. If you wanted to make an object that could
    be used in a `memoryview` or could otherwise be converted to `bytes`, you'll want
    a `__bytes__` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `__format__` and `__repr__` methods are different string conversion flavors.
    Most string conversions rely the `__str__` method, but the default `__str__` implementation
    simply calls `__repr__`.
  prefs: []
  type: TYPE_NORMAL
- en: The `__format__` method is used by all [f-string conversions](https://www.pythonmorsels.com/string-formatting/),
    by the `str` class's `format` method, and by the (rarely used) built-in `format`
    function. This method allows `datetime` objects to [support custom format specifiers](https://www.pythonmorsels.com/string-formatting/#formatting-datetime-objects).
  prefs: []
  type: TYPE_NORMAL
- en: Context managers üö™
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A context manager is an object that can be used in a `with` block.
  prefs: []
  type: TYPE_NORMAL
- en: '| Use | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `with` block enter | `x.__enter__()` | A value given to `as` |'
  prefs: []
  type: TYPE_TB
- en: '| `with` block exit | `x.__exit__(exc_type, exc, traceback)` | Truthy/falsey
    value |'
  prefs: []
  type: TYPE_TB
- en: For more on context managers see, [what is a context manager](https://www.pythonmorsels.com/what-is-a-context-manager/)
    and [creating a context manager](https://www.pythonmorsels.com/creating-a-context-manager/).
  prefs: []
  type: TYPE_NORMAL
- en: Containers and collections üóÉÔ∏è
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Collections (a.k.a. containers) are essentially data structures or objects that
    act like data stuctures. Lists, dictionaries, sets, strings, and tuples are all
    examples of collections.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Return Type | Implemented |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `len(x)` | `x.__len__()` | integer | Very common |'
  prefs: []
  type: TYPE_TB
- en: '| `iter(x)` | `x.__iter__()` | iterator | Very common |'
  prefs: []
  type: TYPE_TB
- en: '| `for item in x: ...` | `x.__iter__()` | iterator | Very common |'
  prefs: []
  type: TYPE_TB
- en: '| `x[a]` | `x.__getitem__(a)` | any object | Common |'
  prefs: []
  type: TYPE_TB
- en: '| `x[a] = b` | `x.__setitem__(a, b)` | None | Common |'
  prefs: []
  type: TYPE_TB
- en: '| `del x[a]` | `x.__delitem__(a)` | None | Common |'
  prefs: []
  type: TYPE_TB
- en: '| `a in x` | `x.__contains__(a)` | bool | Common |'
  prefs: []
  type: TYPE_TB
- en: '| `reversed(x)` | `x.__reversed__()` | iterator | Common |'
  prefs: []
  type: TYPE_TB
- en: '| `next(x)` | `x.__next__()` | any object | Uncommon |'
  prefs: []
  type: TYPE_TB
- en: '| `x[a]` | `x.__missing__(a)` | any object | Uncommon |'
  prefs: []
  type: TYPE_TB
- en: '| `operator.length_hint(x)` | `x.__length_hint__()` | integer | Uncommon |'
  prefs: []
  type: TYPE_TB
- en: 'The `__iter__` method is used by the `iter` function *and* for all forms of
    iteration: [`for` loops](https://www.pythonmorsels.com/writing-a-for-loop/), [comprehensions](https://www.pythonmorsels.com/what-are-list-comprehensions/),
    [tuple unpacking](https://www.pythonmorsels.com/tuple-unpacking/), and [using
    `*` for iterable unpacking](https://www.pythonmorsels.com/unpacking-iterables-iterables/).'
  prefs: []
  type: TYPE_NORMAL
- en: While the `__iter__` method is necessary for creating a custom iterable, the
    `__next__` method is necessary for creating a custom iterator (which is much less
    common). The `__missing__` method is only ever called by the `dict` class on itself,
    unless another class decides to implement `__missing__`. The `__length_hint__`
    method supplies a length guess for structures which do not support `__len__` so
    that lists or other structures can be pre-sized more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also see: [the iterator protocol](https://www.pythonmorsels.com/iterator-protocol/),
    [implementing `__len__`](https://www.pythonmorsels.com/making-the-len-function-work-on-your-python-objects/),
    and [implementing `__getitem__`](https://www.pythonmorsels.com/supporting-index-and-key-lookups/).'
  prefs: []
  type: TYPE_NORMAL
- en: Callability ‚òéÔ∏è
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions, classes, and all other [callable objects](https://www.pythonmorsels.com/callables/)
    rely on the `__call__` method.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Return Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x(a, b=c)` | `x.__call__(a, b=c)` | any object |'
  prefs: []
  type: TYPE_TB
- en: When a class is called, its [metaclass](https://docs.python.org/3/glossary.html#term-metaclass)'s
    `__call__` method is used. When a class *instance* is called, the class's `__call__`
    method is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on callability, see [Callables: Python''s "functions" are sometimes
    classes](https://www.pythonmorsels.com/class-function-and-callable/).'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators ‚ûó
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python's dunder methods are often described as a tool for "operator overloading".
    Most of this "operator overloading" comes in the form of Python's various arithmetic
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to break down the arithmetic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical (e.g. `+`, `-`, `*`, `/`, `%`) versus bitwise (e.g. `&`, `|`, `^`,
    `>>`, `~`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary (between 2 values, like `x + y`) versus unary (before 1 value, like `+x`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mathematical operators are much more common than the bitwise ones and the
    binary ones are a bit more common than the unary ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the binary mathematical arithmetic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Left-Hand Method | Right-Hand Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x + y` | `__add__` | `__radd__` | Add / Concatenate |'
  prefs: []
  type: TYPE_TB
- en: '| `x - y` | `__sub__` | `__rsub__` | Subtract |'
  prefs: []
  type: TYPE_TB
- en: '| `x * y` | `__mul__` | `__rmul__` | Multiply |'
  prefs: []
  type: TYPE_TB
- en: '| `x / y` | `__truediv__` | `__rtruediv__` | Divide |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | `__mod__` | `__rmod__` | Modulo |'
  prefs: []
  type: TYPE_TB
- en: '| `x // y` | `__floordiv__` | `__rfloordiv__` | [Integer division](https://www.pythonmorsels.com/integer-division/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | `__pow__` | `__rpow__` | Exponentiate |'
  prefs: []
  type: TYPE_TB
- en: '| `x @ y` | `__matmul__` | `__rmatmul__` | Matrix multiply |'
  prefs: []
  type: TYPE_TB
- en: Each of these operators includes left-hand and right-hand methods. If `x.__add__(y)`
    returns [`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/),
    then `y.__radd__(x)` will be attempted. See [arithmetic dunder methods](https://www.pythonmorsels.com/arithmetic-dunder-methods/)
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the binary bitwise arithmetic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Left-Hand Method | Right-Hand Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x & y` | `__and__` | `__rand__` | AND |'
  prefs: []
  type: TYPE_TB
- en: '| `x &#124; y` | `__or__` | `__ror__` | OR |'
  prefs: []
  type: TYPE_TB
- en: '| `x ^ y` | `__xor__` | `__rxor__` | XOR |'
  prefs: []
  type: TYPE_TB
- en: '| `x >> y` | `__rshift__` | `__rrshift__` | Right-shift |'
  prefs: []
  type: TYPE_TB
- en: '| `x << y` | `__lshift__` | `__rlshift__` | Left-shift |'
  prefs: []
  type: TYPE_TB
- en: 'These are Python''s unary arithmetic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method | Variety | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-x` | `__neg__` | Mathematical | Negate |'
  prefs: []
  type: TYPE_TB
- en: '| `+x` | `__pos__` | Bitwise | Affirm |'
  prefs: []
  type: TYPE_TB
- en: '| `~x` | `__invert__` | Bitwise | Invert |'
  prefs: []
  type: TYPE_TB
- en: The unary `+` operator typically [has no effect](https://stackoverflow.com/questions/16819023/whats-the-purpose-of-the-pos-unary-operator-in-python),
    though some objects use it for a specific operation. For example [using `+` on
    `collections.Counter` objects](https://www.pythonmorsels.com/using-counter/#removing-negative-counts)
    will remove non-positive values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s arithmetic operators are often used for non-arithmetic ends: [sequences](https://www.pythonmorsels.com/sequence/)
    use `+` to concatenate and `*` to self-concatenate and [sets](https://www.pythonmorsels.com/practical-uses-of-sets/)
    use `&` for intersection, `|` for union, `-` for asymmetric difference, and `^`
    for symmetric difference. Arithmetic operators are sometimes overloaded for more
    creative uses too. For example, `pathlib.Path` objects [use `/` to create child
    paths](https://docs.python.org/3/library/pathlib.html#operators).'
  prefs: []
  type: TYPE_NORMAL
- en: In-place arithmetic operations ‚ôªÔ∏è
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python includes many dunder methods for **in-place** operations. If you're making
    a [mutable](https://www.pythonmorsels.com/terms/#mutable) object that supports
    any of the arithmetic operations, you'll want to implement the related in-place
    dunder method(s) as well.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x += y` | `x.__iadd__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x -= y` | `x.__isub__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x *= y` | `x.__imul__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x /= y` | `x.__itruediv__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x %= y` | `x.__imod__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x //= y` | `x.__ifloordiv__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x **= y` | `x.__ipow__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x @= y` | `x.__imatmul__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x &= y` | `x.__iand__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x &#124;= y` | `x.__ior__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x ^= y` | `x.__ixor__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x >>= y` | `x.__irshift__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| `x <<= y` | `x.__ilshift__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: All of Python's binary arithmetic operators work in **augmented assignment statements**,
    which involve using an operator followed by the `=` sign to assign to an object
    while performing an operation on it.
  prefs: []
  type: TYPE_NORMAL
- en: Augmented assignments on **mutable objects** are [expected to mutate the original
    object](https://www.pythonmorsels.com/augmented-assignments-mutate/), thanks to
    the mutable object implementing the appropriate dunder method for in-place arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: When no dunder method is found for an in-place operation, Python performs the
    operation followed by an assignment. **Immutable objects typically do *not* implement
    dunder methods for in-place operations**, since they should return a new object
    instead of changing the original.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in math functions üßÆ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python also includes dunder methods for many math-related functions, both [built-in
    functions](https://www.pythonmorsels.com/built-in-functions-in-python/#type) and
    some functions in the `math` library.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `divmod(x, y)` | `x.__divmod__(y)` | 2-item tuple |'
  prefs: []
  type: TYPE_TB
- en: '| `divmod(x, y)` | `y.__rdivmod__(x)` | 2-item tuple |'
  prefs: []
  type: TYPE_TB
- en: '| `abs(x)` | `x.__abs__()` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `sequence[x]` | `x.__index__()` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| `round(x)` | `x.__round__()` | Number |'
  prefs: []
  type: TYPE_TB
- en: '| `math.trunc(x)` | `x.__trunc__()` | Number |'
  prefs: []
  type: TYPE_TB
- en: '| `math.floor(x)` | `x.__floor__()` | Number |'
  prefs: []
  type: TYPE_TB
- en: '| `math.ceil(x)` | `x.__ceil__()` | Number |'
  prefs: []
  type: TYPE_TB
- en: Python's `divmod` function performs [integer division](https://www.pythonmorsels.com/integer-division/)
    (`//`) and a modulo operation (`%`) at the same time. Note that, just like the
    many binary arithmetic operators, `divmod` will also check for an `__rvidmod__`
    method if it needs to ask the *second* argument to handle the operation.
  prefs: []
  type: TYPE_NORMAL
- en: The `__index__` method is for making integer-like objects. This method losslessly
    converts to an integer, unlike `__int__` which may perform a "lossy" integer conversion
    (e.g. from `float` to `int`). It's used by operations that require *true* integers,
    such as [slicing](https://www.pythonmorsels.com/slicing/), indexing, and `bin`,
    `hex`, and `oct` functions ([example](https://pym.dev/p/2k9zt/)).
  prefs: []
  type: TYPE_NORMAL
- en: Attribute access üìú
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python even includes dunder methods for controlling what happens when you access,
    delete, or assign any attribute on an object!
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x.missing` | `x.__getattr__("missing")` | Attribute value |'
  prefs: []
  type: TYPE_TB
- en: '| `x.anything` | `x.__getattribute__("anything")` | Attribute value |'
  prefs: []
  type: TYPE_TB
- en: '| `x.thing = value` | `x.__setattr__("thing", value)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| `del x.thing` | `x.__delattr__("thing")` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| `dir(x)` | `x.__dir__()` | List of strings |'
  prefs: []
  type: TYPE_TB
- en: The `__getattribute__` method is called for *every* attribute access, while
    the `__getattr__` method is only called after Python *fails* to find a given attribute.
    All method calls and attribute accesses call `__getattribute__` so implementing
    it correctly is challenging (due to accidental [recursion](https://www.pythonmorsels.com/what-is-recursion/)).
    See [`__getattr__` versus `__getattribute__`](https://www.pythonmorsels.com/getattr-vs-getattribute/)
    for examples demonstrating the difference between these two methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `__dir__` method should return an iterable of attribute names (as strings).
    When [the `dir` function](https://www.pythonmorsels.com/built-in-functions-in-python/#dir)
    calls `__dir__`, it converts the returned iterable into a sorted list (like [`sorted`](https://www.pythonmorsels.com/sorting-in-python/)
    does).
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `getattr`, [`setattr`](https://www.pythonmorsels.com/python-setattr/),
    and `delattr` functions correspond to the dunder methods of the same name, but
    they're only intended for dynamic attribute access (not *all* attribute accesses).
  prefs: []
  type: TYPE_NORMAL
- en: Now we're getting into the really unusual dunder methods. Python includes many
    dunder methods for metaprogramming-related features.
  prefs: []
  type: TYPE_NORMAL
- en: '| Implemented on | Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `class T: ...` | `type(base).__prepare__()` | mapping |'
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Any class | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Any class | (Called manually) | `T.__subclasses__()` | `list` |'
  prefs: []
  type: TYPE_TB
- en: '| Any class | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
  prefs: []
  type: TYPE_TB
- en: '| Any class | `T[y]` | `T.__class_getitem__(y)` | an item |'
  prefs: []
  type: TYPE_TB
- en: The `__prepare__` method customizes the dictionary that's used for a class's
    initial namespace. This is used to pre-populate dictionary values or customize
    the dictionary type ([silly example](https://pym.dev/p/23wfv/)).
  prefs: []
  type: TYPE_NORMAL
- en: The `__instancecheck__` and `__subclasscheck__` methods override the functionality
    of `isinstance` and `issubclass`. Python's ABCs use these to practice [goose typing](https://www.pythonmorsels.com/goose-typing/)
    ([duck typing](https://www.pythonmorsels.com/duck-typing/) *while* type checking).
  prefs: []
  type: TYPE_NORMAL
- en: The `__init_subclass__` method allows classes to hook into subclass initialization
    ([example](https://pym.dev/p/246z6/)). Classes *also* have a `__subclasses__`
    method (on their [metaclass](https://docs.python.org/3/glossary.html#term-metaclass))
    but it's not typically overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Python calls `__mro_entries__` during [class inheritance](https://www.pythonmorsels.com/inheriting-one-class-another/)
    for any base classes that are not *actually* classes. The [`typing.NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple)
    function uses this to pretend it's a class ([see here](https://pym.dev/p/2qgzd/)).
  prefs: []
  type: TYPE_NORMAL
- en: The `__class_getitem__` method allows a class to be subscriptable (*without*
    its metaclass needing a `__getitem__` method). This is typically used for enabling
    fancy type annotations (e.g. `list[int]`).
  prefs: []
  type: TYPE_NORMAL
- en: Descriptors üè∑Ô∏è
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Descriptors](https://docs.python.org/3/glossary.html#term-descriptor) are
    objects that, when attached to a class, can hook into the access of the attribute
    name they''re attached to on that class.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| `t.x` | `T.x.__get__(t, T)` | The value |'
  prefs: []
  type: TYPE_TB
- en: '| `t.x = y` | `T.x.__set__(t, y)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| `del t.x` | `T.x.__delete__(t)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: The descriptor protocol is *mostly* a feature that exists to make Python's `property`
    decorator work, though it is also used by a number of third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers üíæ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing a low-level memory array? You need Python's [buffer protocol](https://docs.python.org/3/reference/datamodel.html#emulating-buffer-types).
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
  prefs: []
  type: TYPE_TB
- en: '| `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: The `__release_buffer__` method is called when the buffer that's returned from
    `__buffer__` is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Python's buffer protocol is typically implemented in C, since it's meant for
    low level objects.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous operations ü§π
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Want to implement an asynchronous context manager? You need these dunder methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__aenter__`: just like `__enter__`, but it returns an awaitable object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__aexit__`: just like `__exit__`, but it returns an awaitable object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Need to support asynchronous iteration? You need these dunder methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__aiter__`: must return an asynchronous iterator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__anext__`: like `__next__` or non-async iterators, but this must return an
    awaitable object and this should raise `StopAsyncIteration` instead of `StopIteration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Need to make your own awaitable object? You need this dunder method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__await__`: returns an iterator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have little experience with custom asynchronous objects, so look elsewhere
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Construction and finalizing üè≠
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last few dunder methods are related to object creation and destruction.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `T(a, b=3)` | `T.__new__(T, a, b=3)` | New instance (`x`) |'
  prefs: []
  type: TYPE_TB
- en: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| `del x` | `x.__del__()` | `None` |'
  prefs: []
  type: TYPE_TB
- en: Calling a class returns a new class instance thanks to the `__new__` method.
    The `__new__` method is Python's **constructor method**, though unlike constructors
    in many programming languages, you should almost *never* define your own `__new__`
    method. To control object creation, prefer the initializer (`__init__`), not the
    constructor (`__new__`). [Here's an odd `__new__` example](https://pym.dev/p/28r9m/).
  prefs: []
  type: TYPE_NORMAL
- en: You could think of `__del__` as a "destructor" method, though it's actually
    called the **finalizer method**. Just before an object is deleted, its `__del__`
    method is called ([example](https://pym.dev/p/2hexg/)). Files implement a `__del__`
    method that closes the file and any binary file buffer that it may be linked to.
  prefs: []
  type: TYPE_NORMAL
- en: Library-specific dunder methods üß∞
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some standard library modules define custom dunder methods that aren''t used
    anywhere else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[dataclasses](https://www.pythonmorsels.com/dataclasses/) support a `__post_init__`
    method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.ABC` classes have a `__subclasshook__` method which `abc.ABCMeta` calls
    in its `__subclasscheck__` method (more in [goose typing](https://www.pythonmorsels.com/goose-typing/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path-like objects have a `__fspath__` method, which returns the file path as
    a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python's `copy` module will use the `__copy__` and `__deepcopy__` methods if
    present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pickling relies on `__getnewargs_ex__` or `__getargs__`, though `__getstate__`
    and `__setstate__` can customize further and `__reduce__` or `__reduce_ex__` are
    even lower-level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys.getsizeof` relies on the `__sizeof__` method to get an object''s size
    (in bytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dunder attributes üìá
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to dunder methods, Python has many non-method **dunder attributes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the more common dunder attributes you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__name__`: name of a function, classes, or module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__module__`: module name for a function or class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__doc__`: [docstring](https://www.pythonmorsels.com/docstrings/) for a function,
    class, or module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__class__`: an object''s class (call [Python''s `type` function](https://www.pythonmorsels.com/built-in-functions-in-python/#type)
    instead)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__dict__`: most objects store their attributes here (see [where are attributes
    stored?](https://www.pythonmorsels.com/where-are-attributes-stored/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__slots__`: classes using this are more memory efficient than classes using
    `__dict__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__match_args__`: classes can define a tuple noting the significance of positional
    attributes when the class is used in structural pattern matching (`match`-`case`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__mro__`: a class''s method resolution order used when for attribute lookups
    and `super()` calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__bases__`: the direct parent classes of a class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__file__`: the file that defined the module object (though not always present!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__wrapped__`: functions decorated with [`functools.wraps`](https://docs.python.org/3/library/functools.html#functools.wraps)
    use this to point to the original function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__version__`: commonly used for noting the version of a package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__all__`: modules can use this to customize the behavior of `from my_module
    import *`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__debug__`: running Python with `-O` sets this to `False` and disables Python''s
    `assert` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those are only the more commonly seen dunder attributes. Here are some more:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions have `__defaults__`, `__kwdefaults__`, `__code__`, `__globals__`,
    and `__closure__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both functions and classes have `__qualname__`, `__annotations__`, and `__type_params__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance methods have `__func__` and `__self__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules may also have `__loader__`, `__package__`, `__spec__`, and `__cached__`
    attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages have a `__path__` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions have `__traceback__`, `__notes__`, `__context__`, `__cause__`, and
    `__suppress_context__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Descriptors use `__objclass__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclasses use `__classcell__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python's `weakref` module uses `__weakref__`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Generic aliases](https://docs.python.org/3/library/stdtypes.html#type-annotation-types-generic-alias-union)
    have `__origin__`, `__args__`, `__parameters__`, and `__unpacked__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sys` module has `__stdout__` and `__stderr__` which point to the original
    `stdout` and `stderr` versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, these dunder attributes are used by various standard library
    modules: `__covariant__`, `__contravariant__`, `__infer_variance__`, `__bound__`,
    `__constraints__`. And Python includes a built-in `__import__` function which
    you''re not supposed to use (`importlib.import_module` is preferred) and CPython
    has a `__builtins__` variable that points to the `builtins` module (but this is
    an implementation detail and `builtins` should be explicitly imported when needed
    instead). Also importing from the `__future__` module can enable specific Python
    feature flags and Python will look for a `__main__` module within packages to
    make them runnable as CLI scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: And that's just *most* of the dunder attribute names you'll find floating around
    in Python. üòµ
  prefs: []
  type: TYPE_NORMAL
- en: 'Every dunder method: a cheat sheet ‚≠ê'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is every Python dunder method organized in categories and ordered very
    roughly by the **most commonly seen** methods first. Some caveats are noted below.
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Object Creation | `x = T(a, b)` | `x.__init__(a, b)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Object Creation | `x = T(a, b)` | `T.__new__(T, a, b)` | New instance (`x`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Finalizer | `del x` (ish) | `x.__del__()` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x == y` | `x.__eq__(y)` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x != y` | `x.__ne__(y)` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x < y` | `x.__lt__(y)` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x > y` | `x.__rt__(y)` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x <= y` | `x.__le__(y)` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x >= y` | `x.__ge__(y)` | Typically `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Hashability | `hash(x)` | `x.__hash__()` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `repr(x)` | `x.__repr__()` | Always `str` |'
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `str(x)` | `x.__str__()` | Always `str` |'
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `bool(x)` | `x.__bool__()` | Always `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `int(x)` | `x.__int__()` | Always `int` |'
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `float(x)` | `x.__float__()` | Always `float` |'
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `bytes(x)` | `x.__bytes__()` | Always `bytes` |'
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `complex(x)` | `x.__complex__()` | Always `complex` |'
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `format(x, s)` | `x.__format__(s)` | Always `str` |'
  prefs: []
  type: TYPE_TB
- en: '| Context Managers | `with x as c:` | `x.__enter__()` | The `c` object |'
  prefs: []
  type: TYPE_TB
- en: '| Context Managers | `with x as c:` | `x.__exit__()` | Truthy/falsey value
    |'
  prefs: []
  type: TYPE_TB
- en: '| Collections | `len(x)` | `x.__len__()` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| Collections | `iter(x)` | `x.__iter__()` | An iterator |'
  prefs: []
  type: TYPE_TB
- en: '| Collections | `x[a]` | `x.__getitem__(a)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Collections | `x[a] = b` | `x.__setitem__(a, b)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Collections | `del x[a]` | `x.__delitem__(a)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Collections | `a in x` | `x.__contains__(a)` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Collections | `reversed(x)` | `x.__reversed__()` | An iterator |'
  prefs: []
  type: TYPE_TB
- en: '| Collections | `next(x)` | `x.__next__()` | Next iterator item |'
  prefs: []
  type: TYPE_TB
- en: '| Collections | `x[a]` | `x.__missing__(a)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Collections |  | `x.__length_hint__()` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x + y` | `x.__add__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x + y` | `y.__radd__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x - y` | `x.__sub__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x - y` | `y.__rsub__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x * y` | `x.__mul__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x * y` | `y.__rmul__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x / y` | `x.__truediv__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x / y` | `y.__rtruediv__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x % y` | `x.__mod__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x % y` | `y.__rmod__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x // y` | `x.__floordiv__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x // y` | `y.__rfloordiv__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x ** y` | `x.__pow__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x ** y` | `y.__rpow__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x @ y` | `x.__matmul__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x @ y` | `y.__rmatmul__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x & y` | `x.__and__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x & y` | `y.__rand__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x &#124; y` | `x.__or__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x &#124; y` | `y.__ror__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x ^ y` | `x.__xor__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x ^ y` | `y.__rxor__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x >> y` | `x.__rshift__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x >> y` | `y.__rrshift__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x << y` | `x.__lshift__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x << y` | `y.__rlshift__(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `-x` | `x.__neg__()` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `+x` | `x.__pos__()` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `~x` | `x.__invert__()` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `divmod(x, y)` | `x.__divmod__(y)` | 2-item tuple |'
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `abs(x)` | `x.__abs__()` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| Math functions |  | `x.__index__()` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `round(x)` | `x.__round__()` | Number |'
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `math.trunc(x)` | `x.__trunc__()` | Number |'
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `math.floor(x)` | `x.__floor__()` | Number |'
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `math.ceil(x)` | `x.__ceil__()` | Number |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x += y` | `x.__iadd__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x -= y` | `x.__isub__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x *= y` | `x.__imul__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x /= y` | `x.__itruediv__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x %= y` | `x.__imod__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x //= y` | `x.__ifloordiv__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x **= y` | `x.__ipow__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x @= y` | `x.__imatmul__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x &= y` | `x.__iand__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x &#124;= y` | `x.__ior__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x ^= y` | `x.__ixor__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x >>= y` | `x.__irshift__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x <<= y` | `x.__ilshift__(y)` | Typically `self` |'
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `x.y` | `x.__getattribute__(''y'')` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `x.y` | `x.__getattr__(''y'')` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `x.y = z` | `x.__setattr__(''y'', z)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `del x.y` | `x.__delattr__(''y'')` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `dir(x)` | `x.__dir__()` | An iterable |'
  prefs: []
  type: TYPE_TB
- en: '| Descriptors | `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Descriptors | `t.x` | `T.x.__get__(t, T)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Descriptors | `t.x = y` | `T.x.__set__(t, y)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Descriptors | `del t.x` | `T.x.__delete__(t)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Class stuff | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Class stuff | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
  prefs: []
  type: TYPE_TB
- en: '| Class stuff | `T[y]` | `T.__class_getitem__(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `class T: ...` | `type(base).__prepare__()` | `dict`/mapping
    |'
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Async | `await x` (ish) | `x.__await__()` | An iterator |'
  prefs: []
  type: TYPE_TB
- en: '| Async | `async with x:` | `x.__aenter__()` | An awaitable |'
  prefs: []
  type: TYPE_TB
- en: '| Async | `async with x:` | `x.__aexit__()` | An awaitable |'
  prefs: []
  type: TYPE_TB
- en: '| Async | `async for a in x:` | `x.__aiter__()` | An awaitable |'
  prefs: []
  type: TYPE_TB
- en: '| Async | `async for a in x:` | `x.__anext__()` | An awaitable |'
  prefs: []
  type: TYPE_TB
- en: '| Buffers | `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
  prefs: []
  type: TYPE_TB
- en: '| Buffers | `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: 'The above table has a slight but consistent *untruth*. Most of these dunder
    methods are not *actually* called on an object directly but are instead called
    on the *type* of that object: `type(x).__add__(x, y)` instead of `x.__add__(y)`.
    This distinction mostly matters with metaclass methods.'
  prefs: []
  type: TYPE_NORMAL
- en: I've also purposely excluded library-specific dunder methods (like `__post_init__`)
    and dunder methods you're unlikely to ever define (like `__subclasses__`). See
    those below.
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Operation | Dunder Method Call | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Dataclasses | `x = T(a, b)` | `T.__post_init__(a, b)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| Copying | `copy.copy(x)` | `x.__copy__()` | New object |'
  prefs: []
  type: TYPE_TB
- en: '| Copying | `copy.deepcopy(x)` | `x.__deepcopy__(memo)` | New object |'
  prefs: []
  type: TYPE_TB
- en: '| [Pickling](https://docs.python.org/3/library/pickle.html#pickling-class-instances)
    | `pickle.dumps(x)` | `x.__getnewargs__()` | A 2-item tuple |'
  prefs: []
  type: TYPE_TB
- en: '| Pickling | `pickle.dumps(x)` | `x.__getnewargs_ex__()` | A 2-item tuple |'
  prefs: []
  type: TYPE_TB
- en: '| Pickling | `pickle.dumps(x)` | `x.__getstate__()` | A meaningful state |'
  prefs: []
  type: TYPE_TB
- en: '| Pickling | `pickle.dumps(x)` | `x.__reduce__()` | A 2-6 item tuple |'
  prefs: []
  type: TYPE_TB
- en: '| Pickling | `pickle.dumps(x)` | `x.__reduce_ex__(4)` | A 2-6 item tuple |'
  prefs: []
  type: TYPE_TB
- en: '| Pickling | `pickle.loads(b)` | `x.__setstate__(state)` | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| pathlib | [`os.fspath(x)`](https://docs.python.org/3/library/os.html#os.fspath)
    | `p.__fspath__()` | `str` or `bytes` |'
  prefs: []
  type: TYPE_TB
- en: '| sys | `sys.getsizeof(x)` | `x.__sizeof__()` | `int` (size in bytes) |'
  prefs: []
  type: TYPE_TB
- en: '| Class stuff | None? | `x.__subclasses__()` | Subclasses iterable |'
  prefs: []
  type: TYPE_TB
- en: '| ABCs | `issubclass(U, T)` | `T.__subclasshook__(U)` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: 'So, Python includes 103 "normal" dunder methods, 12 library-specific dunder
    methods, and at least 52 other dunder attributes of various types. That''s over
    150 unique `__dunder__` names! I **do not recommend** memorizing these: let Python
    do its job and look up the dunder method or attribute that you need to implement/find
    whenever you need it.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that **you're not meant to invent your own dunder methods**. Sometimes
    you'll see third-party libraries that *do* invent their own dunder method, but
    this isn't encouraged and it can be quite confusing for users who run across such
    methods and assume they're "*real*" dunder methods.
  prefs: []
  type: TYPE_NORMAL
