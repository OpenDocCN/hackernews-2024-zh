- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 12:53:16'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 12:53:16'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Every dunder method in Python - Python Morsels
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 中的每个 dunder 方法 - Python Morsels
- en: 来源：[https://www.pythonmorsels.com/every-dunder-method/](https://www.pythonmorsels.com/every-dunder-method/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://www.pythonmorsels.com/every-dunder-method/](https://www.pythonmorsels.com/every-dunder-method/)
- en: You've just made a class. You made a `__init__` method. Now what?
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建了一个类。您编写了一个 `__init__` 方法。接下来该做什么？
- en: Python includes *tons* of [dunder methods](https://www.pythonmorsels.com/what-are-dunder-methods/)
    ("double underscore" methods) which allow us to deeply customize how our custom
    classes interact with Python's many features. What dunder methods could you add
    to your class to make it friendly for other Python programmers who use it?
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包括*大量*[dunder methods](https://www.pythonmorsels.com/what-are-dunder-methods/)（双下划线方法），这些方法允许我们深度定制我们的自定义类与
    Python 的许多功能交互的方式。您可以添加哪些 dunder 方法到您的类中，以使其对其他使用它的 Python 程序员更友好？
- en: Let's take a look at **every dunder method in Python**, with a focus on when
    each method is useful.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解 **Python 中的每个 dunder 方法**，重点介绍每种方法何时特别有用。
- en: Note that the Python documentation refers to these as [special methods](https://docs.python.org/3/glossary.html#term-special-method)
    and notes the synonym "magic method" but *very* [rarely](https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers)
    uses the term "dunder method". However, "dunder method" is a fairly common Python
    colloquialism, as noted in my [unofficial Python glossary](https://www.pythonmorsels.com/terms/).
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python 文档将这些方法称为[special methods](https://docs.python.org/3/glossary.html#term-special-method)，并指出了“magic
    method”的同义词，但*很少*使用“dunder method”一词。然而，“dunder method”是 Python 中相当常见的口头用语，如我在[非官方
    Python 术语表](https://www.pythonmorsels.com/terms/)中所述。
- en: You can use the links scattered throughout this page for more details on any
    particular dunder method. For a list of all of them, see the cheat sheet in the
    final section.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用本页面上散布的链接获取有关任何特定 dunder 方法的更多详细信息。要查看所有方法的列表，请参见最后一节的速查表。
- en: The 3 essential dunder methods 🔑
  id: totrans-split-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 个必要的 dunder 方法 🔑
- en: 'There are 3 dunder methods that *most* classes should have: [`__init__`](https://www.pythonmorsels.com/what-is-init/),
    [`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/),
    and [`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/).'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类应具有 3 个 dunder 方法：[`__init__`](https://www.pythonmorsels.com/what-is-init/)、[`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/)
    和 [`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/)。
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-13
  prefs: []
  type: TYPE_TB
  zh: '| Operation | Dunder Method Call | Returns |'
- en: '| --- | --- | --- |'
  id: totrans-split-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
  id: totrans-split-15
  prefs: []
  type: TYPE_TB
  zh: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
- en: '| `repr(x)` | `x.__repr__()` | `str` |'
  id: totrans-split-16
  prefs: []
  type: TYPE_TB
  zh: '| `repr(x)` | `x.__repr__()` | `str` |'
- en: '| `x == y` | `x.__eq__(y)` | Typically `bool` |'
  id: totrans-split-17
  prefs: []
  type: TYPE_TB
  zh: '| `x == y` | `x.__eq__(y)` | 通常为 `bool` |'
- en: The [`__init__`](https://www.pythonmorsels.com/what-is-init/) method is the
    **initializer** (not to be confused with the [constructor](#construction-and-finalizing)),
    the [`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/)
    method customizes an object's string representation, and the [`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/)
    method customizes what it means for objects to be *equal* to one another.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[`__init__`](https://www.pythonmorsels.com/what-is-init/) 方法是**初始化器**（不要与[构造函数](#construction-and-finalizing)混淆），[`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/)
    方法自定义了对象的字符串表示形式，[`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/)
    方法自定义了对象之间的*相等*关系。'
- en: The `__repr__` method is particularly helpful at the [the Python REPL](https://www.pythonmorsels.com/using-the-python-repl/)
    and when debugging.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`__repr__` 方法在[Python REPL](https://www.pythonmorsels.com/using-the-python-repl/)和调试时特别有帮助。'
- en: Equality and hashability 🟰
  id: totrans-split-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等性和可哈希性 🟰
- en: In addition to the `__eq__` method, Python has 2 other dunder methods for determining
    the "value" of an object in relation to other objects.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `__eq__` 方法外，Python 还有其他 2 个 dunder 方法，用于确定对象在与其他对象的关系中的“值”。
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-22
  prefs: []
  type: TYPE_TB
  zh: '| Operation | Dunder Method Call | Returns |'
- en: '| --- | --- | --- |'
  id: totrans-split-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `x == y` | `x.__eq__(y)` | Typically `bool` |'
  id: totrans-split-24
  prefs: []
  type: TYPE_TB
  zh: '| `x == y` | `x.__eq__(y)` | 通常为 `bool` |'
- en: '| `x != y` | `x.__ne__(y)` | Typically `bool` |'
  id: totrans-split-25
  prefs: []
  type: TYPE_TB
  zh: '| `x != y` | `x.__ne__(y)` | 通常为 `bool` |'
- en: '| `hash(x)` | `x.__hash__()` | `int` |'
  id: totrans-split-26
  prefs: []
  type: TYPE_TB
  zh: '| `hash(x)` | `x.__hash__()` | `int` |'
- en: Python's `__eq__` method typically returns `True`, `False`, or [`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/)
    (if objects can't be compared). The default `__eq__` implementation relies on
    the `is` operator, which checks for **[identity](https://www.pythonmorsels.com/equality-vs-identity/)**.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `__eq__` 方法通常返回 `True`、`False` 或 [`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/)（如果对象无法比较）。
    默认的 `__eq__` 实现依赖于 `is` 操作符，用于检查**[身份](https://www.pythonmorsels.com/equality-vs-identity/)**。
- en: The default implementation of `__ne__` calls `__eq__` and negates any boolean
    return value given (or returns `NotImplemented` if `__eq__` did). This default
    behavior is usually "good enough", so **you'll almost never see `__ne__` implemented**.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `__ne__` 实现调用 `__eq__` 并对给定的布尔返回值取反（或者如果 `__eq__` 返回 `NotImplemented` 则返回
    `NotImplemented`）。 这种默认行为通常是“足够好的”，因此**你几乎永远不会看到实现 `__ne__`**。
- en: Hashable objects can be used as keys in dictionaries or values in sets. All
    objects in Python are [hashable](https://www.pythonmorsels.com/what-are-hashable-objects/)
    by default, but if you've written a custom `__eq__` method then your objects *won't*
    be hashable without a custom `__hash__` method. But **the hash value of an object
    must never change** or [bad things will happen](https://pym.dev/p/2ysgz/) so **typically
    only *immutable* objects implement `__hash__`**.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可哈希对象可以用作字典的键或集合中的值。Python 中的所有对象默认都是[可哈希的](https://www.pythonmorsels.com/what-are-hashable-objects/)，但如果你编写了自定义的
    `__eq__` 方法，则你的对象在没有自定义的 `__hash__` 方法时是*不可哈希的*。但是，**对象的哈希值绝对不能改变**，否则将会发生[不好的事情](https://pym.dev/p/2ysgz/)，因此**通常只有*不可变*对象实现
    `__hash__`**。
- en: For implementing equality checks, see [`__eq__` in Python](https://www.pythonmorsels.com/overloading-equality-in-python/).
    For implementing hashability, see [making hashable objects in Python](https://www.pythonmorsels.com/making-hashable-objects/).
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 若要实现相等性检查，请参阅[Python 中的 `__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/)。
    若要实现可哈希性，请参阅[在 Python 中创建可哈希对象](https://www.pythonmorsels.com/making-hashable-objects/)。
- en: Orderability ⚖️
  id: totrans-split-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可排序性 ⚖️
- en: Python's comparison operators (`<`, `>`, `<=`, `>=`) can all be overloaded with
    dunder methods as well. The comparison operators also power functions that rely
    on the relative ordering of objects, like `sorted`, `min`, and `max`.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的比较运算符（`<`、`>`、`<=`、`>=`）也可以通过魔术方法进行重载。 比较运算符还为依赖对象相对顺序的函数提供支持，如 `sorted`、`min`
    和 `max`。
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-33
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 魔术方法调用 | 返回值 |'
- en: '| --- | --- | --- |'
  id: totrans-split-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `<` | `__lt__` | Typically `bool` |'
  id: totrans-split-35
  prefs: []
  type: TYPE_TB
  zh: '| `<` | `__lt__` | 通常是 `bool` |'
- en: '| `>` | `__gt__` | Typically `bool` |'
  id: totrans-split-36
  prefs: []
  type: TYPE_TB
  zh: '| `>` | `__gt__` | 通常是 `bool` |'
- en: '| `<=` | `__le__` | Typically `bool` |'
  id: totrans-split-37
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | `__le__` | 通常是 `bool` |'
- en: '| `>=` | `__ge__` | Typically `bool` |'
  id: totrans-split-38
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | `__ge__` | 通常是 `bool` |'
- en: If you plan to implement all of these operators in the *typical* way (where
    `x < y` would be the same as asking `y > x`) then the [`total_ordering` decorator](https://docs.python.org/3/library/functools.html#functools.total_ordering)
    from Python's `functools` module will come in handy.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划按照*典型*方式实现所有这些运算符（其中 `x < y` 等同于询问 `y > x`），那么 Python 的 `functools` 模块中的
    [`total_ordering` 装饰器](https://docs.python.org/3/library/functools.html#functools.total_ordering)
    会很有帮助。
- en: Type conversions and string formatting ⚗️
  id: totrans-split-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换和字符串格式化 ⚗️
- en: Python has a number of dunder methods for converting objects to a different
    type.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多魔术方法用于将对象转换为不同的类型。
- en: '| Function | Dunder Method Call | Returns |'
  id: totrans-split-42
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 魔术方法调用 | 返回值 |'
- en: '| --- | --- | --- |'
  id: totrans-split-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `str(x)` | `x.__str__()` | `str` |'
  id: totrans-split-44
  prefs: []
  type: TYPE_TB
  zh: '| `str(x)` | `x.__str__()` | `str` |'
- en: '| `bool(x)` | `x.__bool__()` | `bool` |'
  id: totrans-split-45
  prefs: []
  type: TYPE_TB
  zh: '| `bool(x)` | `x.__bool__()` | `bool` |'
- en: '| `int(x)` | `x.__int__()` | `int` |'
  id: totrans-split-46
  prefs: []
  type: TYPE_TB
  zh: '| `int(x)` | `x.__int__()` | `int` |'
- en: '| `float(x)` | `x.__float__()` | `float` |'
  id: totrans-split-47
  prefs: []
  type: TYPE_TB
  zh: '| `float(x)` | `x.__float__()` | `float` |'
- en: '| `bytes(x)` | `x.__bytes__()` | [`bytes`](https://pym.dev/p/2ysgz/) |'
  id: totrans-split-48
  prefs: []
  type: TYPE_TB
  zh: '| `bytes(x)` | `x.__bytes__()` | [`字节`](https://pym.dev/p/2ysgz/) |'
- en: '| `complex(x)` | `x.__complex__()` | [`complex`](https://docs.python.org/3/glossary.html#term-complex-number)
    |'
  id: totrans-split-49
  prefs: []
  type: TYPE_TB
  zh: '| `complex(x)` | `x.__complex__()` | [`复数`](https://docs.python.org/3/glossary.html#term-complex-number)
    |'
- en: '| `f"{x:s}"` | `x.__format__(s)` | `str` |'
  id: totrans-split-50
  prefs: []
  type: TYPE_TB
  zh: '| `f"{x:s}"` | `x.__format__(s)` | `str` |'
- en: '| `repr(x)` | `x.__repr__()` | `str` |'
  id: totrans-split-51
  prefs: []
  type: TYPE_TB
  zh: '| `repr(x)` | `x.__repr__()` | `str` |'
- en: The `__bool__` function is used for [truthiness](https://www.pythonmorsels.com/truthiness/)
    checks, though `__len__` is used as a fallback.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`__bool__` 函数用于进行[真值检查](https://www.pythonmorsels.com/truthiness/)，尽管 `__len__`
    作为后备。'
- en: If you needed to make an object that acts like a number (like [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html)
    or [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html)),
    you'll want to implement `__int__`, `__float__`, and `__complex__` so your objects
    can be converted to other numbers. If you wanted to make an object that could
    be used in a `memoryview` or could otherwise be converted to `bytes`, you'll want
    a `__bytes__` method.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要创建一个像 [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html)
    或 [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html) 这样的对象，该对象能像数值一样使用，您需要实现
    `__int__`、`__float__` 和 `__complex__` 方法，以便能将您的对象转换为其他数值。如果您需要创建一个可以在 `memoryview`
    中使用或能以其他方式转换为 `bytes` 的对象，您需要实现 `__bytes__` 方法。
- en: The `__format__` and `__repr__` methods are different string conversion flavors.
    Most string conversions rely the `__str__` method, but the default `__str__` implementation
    simply calls `__repr__`.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`__format__` 和 `__repr__` 方法是不同的字符串转换方式。大多数字符串转换依赖于 `__str__` 方法，但默认的 `__str__`
    实现只是简单地调用 `__repr__`。'
- en: The `__format__` method is used by all [f-string conversions](https://www.pythonmorsels.com/string-formatting/),
    by the `str` class's `format` method, and by the (rarely used) built-in `format`
    function. This method allows `datetime` objects to [support custom format specifiers](https://www.pythonmorsels.com/string-formatting/#formatting-datetime-objects).
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`__format__` 方法被所有 [f-string 转换](https://www.pythonmorsels.com/string-formatting/)、`str`
    类的 `format` 方法以及（很少使用的）内置 `format` 函数使用。该方法允许 `datetime` 对象支持自定义的格式说明符，详情参见 [支持自定义格式说明符](https://www.pythonmorsels.com/string-formatting/#formatting-datetime-objects)。'
- en: Context managers 🚪
  id: totrans-split-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文管理器 🚪
- en: A context manager is an object that can be used in a `with` block.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器是一个可以在 `with` 块中使用的对象。
- en: '| Use | Dunder Method Call | Returns |'
  id: totrans-split-58
  prefs: []
  type: TYPE_TB
  zh: '| 使用 | 双下划线方法调用 | 返回值 |'
- en: '| --- | --- | --- |'
  id: totrans-split-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `with` block enter | `x.__enter__()` | A value given to `as` |'
  id: totrans-split-60
  prefs: []
  type: TYPE_TB
  zh: '| `with` 块进入 | `x.__enter__()` | 作为给定的值 |'
- en: '| `with` block exit | `x.__exit__(exc_type, exc, traceback)` | Truthy/falsey
    value |'
  id: totrans-split-61
  prefs: []
  type: TYPE_TB
  zh: '| `with` 块退出 | `x.__exit__(exc_type, exc, traceback)` | 真值/假值 |'
- en: For more on context managers see, [what is a context manager](https://www.pythonmorsels.com/what-is-a-context-manager/)
    and [creating a context manager](https://www.pythonmorsels.com/creating-a-context-manager/).
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上下文管理器的更多信息，请参见，[什么是上下文管理器](https://www.pythonmorsels.com/what-is-a-context-manager/)和[创建上下文管理器](https://www.pythonmorsels.com/creating-a-context-manager/)。
- en: Containers and collections 🗃️
  id: totrans-split-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和集合 🗃️
- en: Collections (a.k.a. containers) are essentially data structures or objects that
    act like data stuctures. Lists, dictionaries, sets, strings, and tuples are all
    examples of collections.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 集合（即容器）本质上是充当数据结构或者像数据结构一样的对象。列表、字典、集合、字符串和元组都是集合的例子。
- en: '| Operation | Dunder Method Call | Return Type | Implemented |'
  id: totrans-split-65
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 双下划线方法调用 | 返回类型 | 已实现 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `len(x)` | `x.__len__()` | integer | Very common |'
  id: totrans-split-67
  prefs: []
  type: TYPE_TB
  zh: '| `len(x)` | `x.__len__()` | 整数 | 非常常见 |'
- en: '| `iter(x)` | `x.__iter__()` | iterator | Very common |'
  id: totrans-split-68
  prefs: []
  type: TYPE_TB
  zh: '| `iter(x)` | `x.__iter__()` | 迭代器 | 非常常见 |'
- en: '| `for item in x: ...` | `x.__iter__()` | iterator | Very common |'
  id: totrans-split-69
  prefs: []
  type: TYPE_TB
  zh: '| `for item in x: ...` | `x.__iter__()` | 迭代器 | 非常常见 |'
- en: '| `x[a]` | `x.__getitem__(a)` | any object | Common |'
  id: totrans-split-70
  prefs: []
  type: TYPE_TB
  zh: '| `x[a]` | `x.__getitem__(a)` | 任何对象 | 常见 |'
- en: '| `x[a] = b` | `x.__setitem__(a, b)` | None | Common |'
  id: totrans-split-71
  prefs: []
  type: TYPE_TB
  zh: '| `x[a] = b` | `x.__setitem__(a, b)` | 无 | 常见 |'
- en: '| `del x[a]` | `x.__delitem__(a)` | None | Common |'
  id: totrans-split-72
  prefs: []
  type: TYPE_TB
  zh: '| `del x[a]` | `x.__delitem__(a)` | 无 | 常见 |'
- en: '| `a in x` | `x.__contains__(a)` | bool | Common |'
  id: totrans-split-73
  prefs: []
  type: TYPE_TB
  zh: '| `a in x` | `x.__contains__(a)` | 布尔值 | 常见 |'
- en: '| `reversed(x)` | `x.__reversed__()` | iterator | Common |'
  id: totrans-split-74
  prefs: []
  type: TYPE_TB
  zh: '| `reversed(x)` | `x.__reversed__()` | 迭代器 | 常见 |'
- en: '| `next(x)` | `x.__next__()` | any object | Uncommon |'
  id: totrans-split-75
  prefs: []
  type: TYPE_TB
  zh: '| `next(x)` | `x.__next__()` | 任何对象 | 不常见 |'
- en: '| `x[a]` | `x.__missing__(a)` | any object | Uncommon |'
  id: totrans-split-76
  prefs: []
  type: TYPE_TB
  zh: '| `x[a]` | `x.__missing__(a)` | 任何对象 | 不常见 |'
- en: '| `operator.length_hint(x)` | `x.__length_hint__()` | integer | Uncommon |'
  id: totrans-split-77
  prefs: []
  type: TYPE_TB
  zh: '| `operator.length_hint(x)` | `x.__length_hint__()` | 整数 | 不常见 |'
- en: 'The `__iter__` method is used by the `iter` function *and* for all forms of
    iteration: [`for` loops](https://www.pythonmorsels.com/writing-a-for-loop/), [comprehensions](https://www.pythonmorsels.com/what-are-list-comprehensions/),
    [tuple unpacking](https://www.pythonmorsels.com/tuple-unpacking/), and [using
    `*` for iterable unpacking](https://www.pythonmorsels.com/unpacking-iterables-iterables/).'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`__iter__` 方法被 `iter` 函数使用 *以及* 所有形式的迭代：[`for` 循环](https://www.pythonmorsels.com/writing-a-for-loop/)、[推导式](https://www.pythonmorsels.com/what-are-list-comprehensions/)、[元组解包](https://www.pythonmorsels.com/tuple-unpacking/)
    和 [使用 `*` 进行可迭代解包](https://www.pythonmorsels.com/unpacking-iterables-iterables/)。'
- en: While the `__iter__` method is necessary for creating a custom iterable, the
    `__next__` method is necessary for creating a custom iterator (which is much less
    common). The `__missing__` method is only ever called by the `dict` class on itself,
    unless another class decides to implement `__missing__`. The `__length_hint__`
    method supplies a length guess for structures which do not support `__len__` so
    that lists or other structures can be pre-sized more efficiently.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`__iter__`方法对于创建自定义可迭代对象是必需的，但`__next__`方法对于创建自定义迭代器（这种情况较少见）是必需的。`__missing__`方法仅在`dict`类自身调用时才会被调用，除非其他类决定实现`__missing__`。`__length_hint__`方法为不支持`__len__`的结构提供长度猜测，以便更高效地预分配列表或其他结构。
- en: 'Also see: [the iterator protocol](https://www.pythonmorsels.com/iterator-protocol/),
    [implementing `__len__`](https://www.pythonmorsels.com/making-the-len-function-work-on-your-python-objects/),
    and [implementing `__getitem__`](https://www.pythonmorsels.com/supporting-index-and-key-lookups/).'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅：[迭代器协议](https://www.pythonmorsels.com/iterator-protocol/)，[实现`__len__`](https://www.pythonmorsels.com/making-the-len-function-work-on-your-python-objects/)，以及[实现`__getitem__`](https://www.pythonmorsels.com/supporting-index-and-key-lookups/)。
- en: Callability ☎️
  id: totrans-split-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可调用性 ☎️
- en: Functions, classes, and all other [callable objects](https://www.pythonmorsels.com/callables/)
    rely on the `__call__` method.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、类以及所有其他[可调用对象](https://www.pythonmorsels.com/callables/)依赖于`__call__`方法。
- en: '| Operation | Dunder Method Call | Return Type |'
  id: totrans-split-83
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 双下划线方法调用 | 返回类型 |'
- en: '| --- | --- | --- |'
  id: totrans-split-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `x(a, b=c)` | `x.__call__(a, b=c)` | any object |'
  id: totrans-split-85
  prefs: []
  type: TYPE_TB
  zh: '| `x(a, b=c)` | `x.__call__(a, b=c)` | 任何对象 |'
- en: When a class is called, its [metaclass](https://docs.python.org/3/glossary.html#term-metaclass)'s
    `__call__` method is used. When a class *instance* is called, the class's `__call__`
    method is used.
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类被调用时，它的[元类](https://docs.python.org/3/glossary.html#term-metaclass)的`__call__`方法会被使用。当一个类的*实例*被调用时，则使用该类的`__call__`方法。
- en: 'For more on callability, see [Callables: Python''s "functions" are sometimes
    classes](https://www.pythonmorsels.com/class-function-and-callable/).'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于可调用性的内容，请参见[可调用对象：Python的“函数”有时是类](https://www.pythonmorsels.com/class-function-and-callable/)。
- en: Arithmetic operators ➗
  id: totrans-split-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符 ➗
- en: Python's dunder methods are often described as a tool for "operator overloading".
    Most of this "operator overloading" comes in the form of Python's various arithmetic
    operators.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python的双下划线方法通常被描述为"运算符重载"的工具。大部分这种"运算符重载"是通过Python的各种算术运算符来实现的。
- en: 'There are two ways to break down the arithmetic operators:'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以分解算术运算符：
- en: Mathematical (e.g. `+`, `-`, `*`, `/`, `%`) versus bitwise (e.g. `&`, `|`, `^`,
    `>>`, `~`)
  id: totrans-split-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学运算符（如`+`、`-`、`*`、`/`、`%`）与位运算符（如`&`、`|`、`^`、`>>`、`~`）之间的区别。
- en: Binary (between 2 values, like `x + y`) versus unary (before 1 value, like `+x`)
  id: totrans-split-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制运算符（作用于两个值，如`x + y`）与一元运算符（作用于一个值之前，如`+x`）。
- en: The mathematical operators are much more common than the bitwise ones and the
    binary ones are a bit more common than the unary ones.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 数学运算符比位运算符更常见，而二进制运算符比一元运算符稍常见一些。
- en: 'These are the binary mathematical arithmetic operators:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是二进制数学算术运算符：
- en: '| Operation | Left-Hand Method | Right-Hand Method | Description |'
  id: totrans-split-95
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 左操作数方法 | 右操作数方法 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `x + y` | `__add__` | `__radd__` | Add / Concatenate |'
  id: totrans-split-97
  prefs: []
  type: TYPE_TB
  zh: '| `x + y` | `__add__` | `__radd__` | 加法 / 连接 |'
- en: '| `x - y` | `__sub__` | `__rsub__` | Subtract |'
  id: totrans-split-98
  prefs: []
  type: TYPE_TB
  zh: '| `x - y` | `__sub__` | `__rsub__` | 减法 |'
- en: '| `x * y` | `__mul__` | `__rmul__` | Multiply |'
  id: totrans-split-99
  prefs: []
  type: TYPE_TB
  zh: '| `x * y` | `__mul__` | `__rmul__` | 乘法 |'
- en: '| `x / y` | `__truediv__` | `__rtruediv__` | Divide |'
  id: totrans-split-100
  prefs: []
  type: TYPE_TB
  zh: '| `x / y` | `__truediv__` | `__rtruediv__` | 除法 |'
- en: '| `%` | `__mod__` | `__rmod__` | Modulo |'
  id: totrans-split-101
  prefs: []
  type: TYPE_TB
  zh: '| `%` | `__mod__` | `__rmod__` | 取模 |'
- en: '| `x // y` | `__floordiv__` | `__rfloordiv__` | [Integer division](https://www.pythonmorsels.com/integer-division/)
    |'
  id: totrans-split-102
  prefs: []
  type: TYPE_TB
  zh: '| `x // y` | `__floordiv__` | `__rfloordiv__` | [整数除法](https://www.pythonmorsels.com/integer-division/)
    |'
- en: '| `**` | `__pow__` | `__rpow__` | Exponentiate |'
  id: totrans-split-103
  prefs: []
  type: TYPE_TB
  zh: '| `**` | `__pow__` | `__rpow__` | 指数运算 |'
- en: '| `x @ y` | `__matmul__` | `__rmatmul__` | Matrix multiply |'
  id: totrans-split-104
  prefs: []
  type: TYPE_TB
  zh: '| `x @ y` | `__matmul__` | `__rmatmul__` | 矩阵乘法 |'
- en: Each of these operators includes left-hand and right-hand methods. If `x.__add__(y)`
    returns [`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/),
    then `y.__radd__(x)` will be attempted. See [arithmetic dunder methods](https://www.pythonmorsels.com/arithmetic-dunder-methods/)
    for more.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些运算符都包括左操作数和右操作数方法。如果`x.__add__(y)`返回[`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/)，则将尝试`y.__radd__(x)`。更多内容请参见[算术双下划线方法](https://www.pythonmorsels.com/arithmetic-dunder-methods/)。
- en: 'These are the binary bitwise arithmetic operators:'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是二进制位运算的算术运算符：
- en: '| Operation | Left-Hand Method | Right-Hand Method | Description |'
  id: totrans-split-107
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 左操作数方法 | 右操作数方法 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `x & y` | `__and__` | `__rand__` | AND |'
  id: totrans-split-109
  prefs: []
  type: TYPE_TB
  zh: '| `x & y` | `__and__` | `__rand__` | 与 |'
- en: '| `x &#124; y` | `__or__` | `__ror__` | OR |'
  id: totrans-split-110
  prefs: []
  type: TYPE_TB
  zh: '| `x &#124; y` | `__or__` | `__ror__` | 或 |'
- en: '| `x ^ y` | `__xor__` | `__rxor__` | XOR |'
  id: totrans-split-111
  prefs: []
  type: TYPE_TB
  zh: '| `x ^ y` | `__xor__` | `__rxor__` | 异或 |'
- en: '| `x >> y` | `__rshift__` | `__rrshift__` | Right-shift |'
  id: totrans-split-112
  prefs: []
  type: TYPE_TB
  zh: '| `x >> y` | `__rshift__` | `__rrshift__` | 右移 |'
- en: '| `x << y` | `__lshift__` | `__rlshift__` | Left-shift |'
  id: totrans-split-113
  prefs: []
  type: TYPE_TB
  zh: '| `x << y` | `__lshift__` | `__rlshift__` | 左移 |'
- en: 'These are Python''s unary arithmetic operators:'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Python 的一元算术运算符：
- en: '| Operation | Dunder Method | Variety | Description |'
  id: totrans-split-115
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | Dunder 方法 | 种类 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `-x` | `__neg__` | Mathematical | Negate |'
  id: totrans-split-117
  prefs: []
  type: TYPE_TB
  zh: '| `-x` | `__neg__` | 数学 | 取反 |'
- en: '| `+x` | `__pos__` | Bitwise | Affirm |'
  id: totrans-split-118
  prefs: []
  type: TYPE_TB
  zh: '| `+x` | `__pos__` | 位运算 | 肯定 |'
- en: '| `~x` | `__invert__` | Bitwise | Invert |'
  id: totrans-split-119
  prefs: []
  type: TYPE_TB
  zh: '| `~x` | `__invert__` | 位运算 | 取反 |'
- en: The unary `+` operator typically [has no effect](https://stackoverflow.com/questions/16819023/whats-the-purpose-of-the-pos-unary-operator-in-python),
    though some objects use it for a specific operation. For example [using `+` on
    `collections.Counter` objects](https://www.pythonmorsels.com/using-counter/#removing-negative-counts)
    will remove non-positive values.
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一元 `+` 运算符通常[没有效果](https://stackoverflow.com/questions/16819023/whats-the-purpose-of-the-pos-unary-operator-in-python)，尽管某些对象使用它进行特定操作。例如，在[collections.Counter
    对象上使用 `+`](https://www.pythonmorsels.com/using-counter/#removing-negative-counts)会移除非正值。
- en: 'Python''s arithmetic operators are often used for non-arithmetic ends: [sequences](https://www.pythonmorsels.com/sequence/)
    use `+` to concatenate and `*` to self-concatenate and [sets](https://www.pythonmorsels.com/practical-uses-of-sets/)
    use `&` for intersection, `|` for union, `-` for asymmetric difference, and `^`
    for symmetric difference. Arithmetic operators are sometimes overloaded for more
    creative uses too. For example, `pathlib.Path` objects [use `/` to create child
    paths](https://docs.python.org/3/library/pathlib.html#operators).'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的算术运算符经常用于非算术的目的：[序列](https://www.pythonmorsels.com/sequence/)使用 `+`
    进行连接和 `*` 进行自连接，而[集合](https://www.pythonmorsels.com/practical-uses-of-sets/)使用
    `&` 进行交集，`|` 进行并集，`-` 进行非对称差异，`^` 进行对称差异。算术运算符有时也被重载以实现更有创意的用途。例如，`pathlib.Path`
    对象使用 `/` 来创建子路径。
- en: In-place arithmetic operations ♻️
  id: totrans-split-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原地算术运算 ♻️
- en: Python includes many dunder methods for **in-place** operations. If you're making
    a [mutable](https://www.pythonmorsels.com/terms/#mutable) object that supports
    any of the arithmetic operations, you'll want to implement the related in-place
    dunder method(s) as well.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包含许多用于**原地**操作的双下划线方法。如果你正在创建一个支持任何算术操作的[可变对象](https://www.pythonmorsels.com/terms/#mutable)，你将需要实现相关的原地双下划线方法。
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-124
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | Dunder 方法调用 | 返回 |'
- en: '| --- | --- | --- |'
  id: totrans-split-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `x += y` | `x.__iadd__(y)` | Typically `self` |'
  id: totrans-split-126
  prefs: []
  type: TYPE_TB
  zh: '| `x += y` | `x.__iadd__(y)` | 通常是 `self` |'
- en: '| `x -= y` | `x.__isub__(y)` | Typically `self` |'
  id: totrans-split-127
  prefs: []
  type: TYPE_TB
  zh: '| `x -= y` | `x.__isub__(y)` | 通常是 `self` |'
- en: '| `x *= y` | `x.__imul__(y)` | Typically `self` |'
  id: totrans-split-128
  prefs: []
  type: TYPE_TB
  zh: '| `x *= y` | `x.__imul__(y)` | 通常是 `self` |'
- en: '| `x /= y` | `x.__itruediv__(y)` | Typically `self` |'
  id: totrans-split-129
  prefs: []
  type: TYPE_TB
  zh: '| `x /= y` | `x.__itruediv__(y)` | 通常是 `self` |'
- en: '| `x %= y` | `x.__imod__(y)` | Typically `self` |'
  id: totrans-split-130
  prefs: []
  type: TYPE_TB
  zh: '| `x %= y` | `x.__imod__(y)` | 通常是 `self` |'
- en: '| `x //= y` | `x.__ifloordiv__(y)` | Typically `self` |'
  id: totrans-split-131
  prefs: []
  type: TYPE_TB
  zh: '| `x //= y` | `x.__ifloordiv__(y)` | 通常是 `self` |'
- en: '| `x **= y` | `x.__ipow__(y)` | Typically `self` |'
  id: totrans-split-132
  prefs: []
  type: TYPE_TB
  zh: '| `x **= y` | `x.__ipow__(y)` | 通常是 `self` |'
- en: '| `x @= y` | `x.__imatmul__(y)` | Typically `self` |'
  id: totrans-split-133
  prefs: []
  type: TYPE_TB
  zh: '| `x @= y` | `x.__imatmul__(y)` | 通常是 `self` |'
- en: '| `x &= y` | `x.__iand__(y)` | Typically `self` |'
  id: totrans-split-134
  prefs: []
  type: TYPE_TB
  zh: '| `x &= y` | `x.__iand__(y)` | 通常是 `self` |'
- en: '| `x &#124;= y` | `x.__ior__(y)` | Typically `self` |'
  id: totrans-split-135
  prefs: []
  type: TYPE_TB
  zh: '| `x &#124;= y` | `x.__ior__(y)` | 通常是 `self` |'
- en: '| `x ^= y` | `x.__ixor__(y)` | Typically `self` |'
  id: totrans-split-136
  prefs: []
  type: TYPE_TB
  zh: '| `x ^= y` | `x.__ixor__(y)` | 通常是 `self` |'
- en: '| `x >>= y` | `x.__irshift__(y)` | Typically `self` |'
  id: totrans-split-137
  prefs: []
  type: TYPE_TB
  zh: '| `x >>= y` | `x.__irshift__(y)` | 通常是 `self` |'
- en: '| `x <<= y` | `x.__ilshift__(y)` | Typically `self` |'
  id: totrans-split-138
  prefs: []
  type: TYPE_TB
  zh: '| `x <<= y` | `x.__ilshift__(y)` | 通常是 `self` |'
- en: All of Python's binary arithmetic operators work in **augmented assignment statements**,
    which involve using an operator followed by the `=` sign to assign to an object
    while performing an operation on it.
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 Python 二进制算术运算符都适用于**增强赋值语句**，这涉及使用操作符后跟 `=` 符号来对对象赋值同时进行操作。
- en: Augmented assignments on **mutable objects** are [expected to mutate the original
    object](https://www.pythonmorsels.com/augmented-assignments-mutate/), thanks to
    the mutable object implementing the appropriate dunder method for in-place arithmetic.
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象上的**增强赋值**预期会[改变原始对象](https://www.pythonmorsels.com/augmented-assignments-mutate/)，这要归功于可变对象实现了适当的原地算术双下划线方法。
- en: When no dunder method is found for an in-place operation, Python performs the
    operation followed by an assignment. **Immutable objects typically do *not* implement
    dunder methods for in-place operations**, since they should return a new object
    instead of changing the original.
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当找不到就地操作的双下划线方法时，Python 执行操作，然后进行赋值。**不可变对象通常不实现就地操作的双下划线方法**，因为它们应该返回一个新对象而不是修改原始对象。
- en: Built-in math functions 🧮
  id: totrans-split-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置数学函数 🧮
- en: Python also includes dunder methods for many math-related functions, both [built-in
    functions](https://www.pythonmorsels.com/built-in-functions-in-python/#type) and
    some functions in the `math` library.
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还包括了许多与数学相关的双下划线方法，包括[内置函数](https://www.pythonmorsels.com/built-in-functions-in-python/#type)和
    `math` 库中的一些函数。
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-144
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 双下划线方法调用 | 返回值 |'
- en: '| --- | --- | --- |'
  id: totrans-split-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `divmod(x, y)` | `x.__divmod__(y)` | 2-item tuple |'
  id: totrans-split-146
  prefs: []
  type: TYPE_TB
  zh: '| `divmod(x, y)` | `x.__divmod__(y)` | 2-项元组 |'
- en: '| `divmod(x, y)` | `y.__rdivmod__(x)` | 2-item tuple |'
  id: totrans-split-147
  prefs: []
  type: TYPE_TB
  zh: '| `divmod(x, y)` | `y.__rdivmod__(x)` | 2-项元组 |'
- en: '| `abs(x)` | `x.__abs__()` | `float` |'
  id: totrans-split-148
  prefs: []
  type: TYPE_TB
  zh: '| `abs(x)` | `x.__abs__()` | `float` |'
- en: '| `sequence[x]` | `x.__index__()` | `int` |'
  id: totrans-split-149
  prefs: []
  type: TYPE_TB
  zh: '| `sequence[x]` | `x.__index__()` | `int` |'
- en: '| `round(x)` | `x.__round__()` | Number |'
  id: totrans-split-150
  prefs: []
  type: TYPE_TB
  zh: '| `round(x)` | `x.__round__()` | 数字 |'
- en: '| `math.trunc(x)` | `x.__trunc__()` | Number |'
  id: totrans-split-151
  prefs: []
  type: TYPE_TB
  zh: '| `math.trunc(x)` | `x.__trunc__()` | 数字 |'
- en: '| `math.floor(x)` | `x.__floor__()` | Number |'
  id: totrans-split-152
  prefs: []
  type: TYPE_TB
  zh: '| `math.floor(x)` | `x.__floor__()` | 数字 |'
- en: '| `math.ceil(x)` | `x.__ceil__()` | Number |'
  id: totrans-split-153
  prefs: []
  type: TYPE_TB
  zh: '| `math.ceil(x)` | `x.__ceil__()` | 数字 |'
- en: Python's `divmod` function performs [integer division](https://www.pythonmorsels.com/integer-division/)
    (`//`) and a modulo operation (`%`) at the same time. Note that, just like the
    many binary arithmetic operators, `divmod` will also check for an `__rvidmod__`
    method if it needs to ask the *second* argument to handle the operation.
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `divmod` 函数同时执行[整数除法](https://www.pythonmorsels.com/integer-division/)（`//`）和取模运算（`%`）。请注意，与许多二元算术运算符一样，`divmod`
    如果需要请求第二个参数处理操作，则也会检查 `__rvidmod__` 方法。
- en: The `__index__` method is for making integer-like objects. This method losslessly
    converts to an integer, unlike `__int__` which may perform a "lossy" integer conversion
    (e.g. from `float` to `int`). It's used by operations that require *true* integers,
    such as [slicing](https://www.pythonmorsels.com/slicing/), indexing, and `bin`,
    `hex`, and `oct` functions ([example](https://pym.dev/p/2k9zt/)).
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`__index__` 方法用于创建类似整数的对象。该方法将对象无损转换为整数，与 `__int__` 方法不同，后者可能会执行“有损”的整数转换（例如从
    `float` 到 `int`）。它被要求需要*真正*整数的操作使用，例如[切片](https://www.pythonmorsels.com/slicing/)、索引和
    `bin`、`hex`、`oct` 函数（[示例](https://pym.dev/p/2k9zt/)）。'
- en: Attribute access 📜
  id: totrans-split-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性访问 📜
- en: Python even includes dunder methods for controlling what happens when you access,
    delete, or assign any attribute on an object!
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: Python 甚至包括了双下划线方法，用于控制访问、删除或赋值对象的任何属性！
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-158
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 双下划线方法调用 | 返回值 |'
- en: '| --- | --- | --- |'
  id: totrans-split-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `x.missing` | `x.__getattr__("missing")` | Attribute value |'
  id: totrans-split-160
  prefs: []
  type: TYPE_TB
  zh: '| `x.missing` | `x.__getattr__("missing")` | 属性值 |'
- en: '| `x.anything` | `x.__getattribute__("anything")` | Attribute value |'
  id: totrans-split-161
  prefs: []
  type: TYPE_TB
  zh: '| `x.anything` | `x.__getattribute__("anything")` | 属性值 |'
- en: '| `x.thing = value` | `x.__setattr__("thing", value)` | `None` |'
  id: totrans-split-162
  prefs: []
  type: TYPE_TB
  zh: '| `x.thing = value` | `x.__setattr__("thing", value)` | `None` |'
- en: '| `del x.thing` | `x.__delattr__("thing")` | `None` |'
  id: totrans-split-163
  prefs: []
  type: TYPE_TB
  zh: '| `del x.thing` | `x.__delattr__("thing")` | `None` |'
- en: '| `dir(x)` | `x.__dir__()` | List of strings |'
  id: totrans-split-164
  prefs: []
  type: TYPE_TB
  zh: '| `dir(x)` | `x.__dir__()` | 字符串列表 |'
- en: The `__getattribute__` method is called for *every* attribute access, while
    the `__getattr__` method is only called after Python *fails* to find a given attribute.
    All method calls and attribute accesses call `__getattribute__` so implementing
    it correctly is challenging (due to accidental [recursion](https://www.pythonmorsels.com/what-is-recursion/)).
    See [`__getattr__` versus `__getattribute__`](https://www.pythonmorsels.com/getattr-vs-getattribute/)
    for examples demonstrating the difference between these two methods.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattribute__` 方法在*每次*属性访问时被调用，而 `__getattr__` 方法仅在 Python 未能找到特定属性时才被调用。所有方法调用和属性访问都调用
    `__getattribute__`，因此正确实现它具有挑战性（由于意外的[递归](https://www.pythonmorsels.com/what-is-recursion/)）。查看[`__getattr__`
    versus `__getattribute__`](https://www.pythonmorsels.com/getattr-vs-getattribute/)，了解演示这两种方法之间差异的示例。'
- en: The `__dir__` method should return an iterable of attribute names (as strings).
    When [the `dir` function](https://www.pythonmorsels.com/built-in-functions-in-python/#dir)
    calls `__dir__`, it converts the returned iterable into a sorted list (like [`sorted`](https://www.pythonmorsels.com/sorting-in-python/)
    does).
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`__dir__` 方法应返回一个属性名称的可迭代字符串集合。当[ `dir` 函数](https://www.pythonmorsels.com/built-in-functions-in-python/#dir)调用
    `__dir__` 时，它将返回的可迭代对象转换为排序列表（类似于[`sorted`](https://www.pythonmorsels.com/sorting-in-python/)
    的操作）。'
- en: The built-in `getattr`, [`setattr`](https://www.pythonmorsels.com/python-setattr/),
    and `delattr` functions correspond to the dunder methods of the same name, but
    they're only intended for dynamic attribute access (not *all* attribute accesses).
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `getattr`、[`setattr`](https://www.pythonmorsels.com/python-setattr/) 和 `delattr`
    函数对应于同名的 Dunder 方法，但它们仅用于动态属性访问（不是 *所有* 属性访问）。
- en: Now we're getting into the really unusual dunder methods. Python includes many
    dunder methods for metaprogramming-related features.
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入了真正不寻常的 Dunder 方法。Python 包含许多用于元编程相关功能的 Dunder 方法。
- en: '| Implemented on | Operation | Dunder Method Call | Returns |'
  id: totrans-split-169
  prefs: []
  type: TYPE_TB
  zh: '| 实现于 | 操作 | Dunder 方法调用 | 返回 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Metaclasses | `class T: ...` | `type(base).__prepare__()` | mapping |'
  id: totrans-split-171
  prefs: []
  type: TYPE_TB
  zh: '| 元类 | `class T: ...` | `type(base).__prepare__()` | 映射 |'
- en: '| Metaclasses | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
  id: totrans-split-172
  prefs: []
  type: TYPE_TB
  zh: '| 元类 | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
- en: '| Metaclasses | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
  id: totrans-split-173
  prefs: []
  type: TYPE_TB
  zh: '| 元类 | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
- en: '| Any class | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
  id: totrans-split-174
  prefs: []
  type: TYPE_TB
  zh: '| 任意类 | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
- en: '| Any class | (Called manually) | `T.__subclasses__()` | `list` |'
  id: totrans-split-175
  prefs: []
  type: TYPE_TB
  zh: '| 任意类 | （手动调用） | `T.__subclasses__()` | `list` |'
- en: '| Any class | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
  id: totrans-split-176
  prefs: []
  type: TYPE_TB
  zh: '| 任意类 | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
- en: '| Any class | `T[y]` | `T.__class_getitem__(y)` | an item |'
  id: totrans-split-177
  prefs: []
  type: TYPE_TB
  zh: '| 任意类 | `T[y]` | `T.__class_getitem__(y)` | 一个项目 |'
- en: The `__prepare__` method customizes the dictionary that's used for a class's
    initial namespace. This is used to pre-populate dictionary values or customize
    the dictionary type ([silly example](https://pym.dev/p/23wfv/)).
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`__prepare__` 方法自定义了用于类初始命名空间的字典。它用于预先填充字典值或自定义字典类型（[愚蠢的例子](https://pym.dev/p/23wfv/)）。'
- en: The `__instancecheck__` and `__subclasscheck__` methods override the functionality
    of `isinstance` and `issubclass`. Python's ABCs use these to practice [goose typing](https://www.pythonmorsels.com/goose-typing/)
    ([duck typing](https://www.pythonmorsels.com/duck-typing/) *while* type checking).
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`__instancecheck__` 和 `__subclasscheck__` 方法覆盖了 `isinstance` 和 `issubclass`
    的功能。Python 的 ABCs 使用这些方法来实现[鹅类型](https://www.pythonmorsels.com/goose-typing/)（[鸭子类型](https://www.pythonmorsels.com/duck-typing/)在类型检查时的应用）。'
- en: The `__init_subclass__` method allows classes to hook into subclass initialization
    ([example](https://pym.dev/p/246z6/)). Classes *also* have a `__subclasses__`
    method (on their [metaclass](https://docs.python.org/3/glossary.html#term-metaclass))
    but it's not typically overridden.
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init_subclass__` 方法允许类挂钩子类初始化（[示例](https://pym.dev/p/246z6/)）。类还有一个 `__subclasses__`
    方法（在它们的[元类](https://docs.python.org/3/glossary.html#term-metaclass)上），但通常不会被覆盖。'
- en: Python calls `__mro_entries__` during [class inheritance](https://www.pythonmorsels.com/inheriting-one-class-another/)
    for any base classes that are not *actually* classes. The [`typing.NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple)
    function uses this to pretend it's a class ([see here](https://pym.dev/p/2qgzd/)).
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在[类继承](https://www.pythonmorsels.com/inheriting-one-class-another/)期间调用
    `__mro_entries__` 处理任何实际上不是类的基类。[`typing.NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple)
    函数使用此功能来假装它是一个类（[请见此处](https://pym.dev/p/2qgzd/)）。
- en: The `__class_getitem__` method allows a class to be subscriptable (*without*
    its metaclass needing a `__getitem__` method). This is typically used for enabling
    fancy type annotations (e.g. `list[int]`).
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`__class_getitem__` 方法允许类成为可索引的（*无需*其元类需要一个 `__getitem__` 方法）。这通常用于启用花式类型注释（例如
    `list[int]`）。'
- en: Descriptors 🏷️
  id: totrans-split-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符 🏷️
- en: '[Descriptors](https://docs.python.org/3/glossary.html#term-descriptor) are
    objects that, when attached to a class, can hook into the access of the attribute
    name they''re attached to on that class.'
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[描述符](https://docs.python.org/3/glossary.html#term-descriptor)是附加到类时可以挂钩到该类上的属性名称访问的对象。'
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-185
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | Dunder 方法调用 | 返回 |'
- en: '| --- | --- | --- |'
  id: totrans-split-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None` |'
  id: totrans-split-187
  prefs: []
  type: TYPE_TB
  zh: '| `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None` |'
- en: '| `t.x` | `T.x.__get__(t, T)` | The value |'
  id: totrans-split-188
  prefs: []
  type: TYPE_TB
  zh: '| `t.x` | `T.x.__get__(t, T)` | 该值 |'
- en: '| `t.x = y` | `T.x.__set__(t, y)` | `None` |'
  id: totrans-split-189
  prefs: []
  type: TYPE_TB
  zh: '| `t.x = y` | `T.x.__set__(t, y)` | `None` |'
- en: '| `del t.x` | `T.x.__delete__(t)` | `None` |'
  id: totrans-split-190
  prefs: []
  type: TYPE_TB
  zh: '| `del t.x` | `T.x.__delete__(t)` | `None` |'
- en: The descriptor protocol is *mostly* a feature that exists to make Python's `property`
    decorator work, though it is also used by a number of third-party libraries.
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符协议主要用于使 Python 的 `property` 装饰器工作，虽然也被许多第三方库使用。
- en: Buffers 💾
  id: totrans-split-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲区 💾
- en: Implementing a low-level memory array? You need Python's [buffer protocol](https://docs.python.org/3/reference/datamodel.html#emulating-buffer-types).
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实现低级内存数组？你需要 Python 的 [缓冲区协议](https://docs.python.org/3/reference/datamodel.html#emulating-buffer-types)。
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-194
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 双下划线方法调用 | 返回值 |'
- en: '| --- | --- | --- |'
  id: totrans-split-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
  id: totrans-split-196
  prefs: []
  type: TYPE_TB
  zh: '| `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
- en: '| `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
  id: totrans-split-197
  prefs: []
  type: TYPE_TB
  zh: '| `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
- en: The `__release_buffer__` method is called when the buffer that's returned from
    `__buffer__` is deleted.
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `__buffer__` 返回的缓冲区被删除时，会调用 `__release_buffer__` 方法。
- en: Python's buffer protocol is typically implemented in C, since it's meant for
    low level objects.
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的缓冲区协议通常由 C 实现，因为它适用于低级对象。
- en: Asynchronous operations 🤹
  id: totrans-split-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步操作 🤹
- en: 'Want to implement an asynchronous context manager? You need these dunder methods:'
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: 想要实现异步上下文管理器？你需要这些双下划线方法：
- en: '`__aenter__`: just like `__enter__`, but it returns an awaitable object'
  id: totrans-split-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__aenter__`: 就像 `__enter__` 一样，但它返回一个可等待对象'
- en: '`__aexit__`: just like `__exit__`, but it returns an awaitable object'
  id: totrans-split-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__aexit__`: 就像`__exit__`一样，但它返回一个可等待对象。'
- en: 'Need to support asynchronous iteration? You need these dunder methods:'
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
  zh: 需要支持异步迭代？你需要这些双下划线方法：
- en: '`__aiter__`: must return an asynchronous iterator'
  id: totrans-split-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__aiter__`: 必须返回一个异步迭代器'
- en: '`__anext__`: like `__next__` or non-async iterators, but this must return an
    awaitable object and this should raise `StopAsyncIteration` instead of `StopIteration`'
  id: totrans-split-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__anext__`: 像`__next__`或非异步迭代器一样，但它必须返回一个可等待对象，且应该引发`StopAsyncIteration`而不是`StopIteration`。'
- en: 'Need to make your own awaitable object? You need this dunder method:'
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
  zh: 需要制作自己的可等待对象？你需要这个双下划线方法：
- en: '`__await__`: returns an iterator'
  id: totrans-split-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__await__`: 返回一个迭代器'
- en: I have little experience with custom asynchronous objects, so look elsewhere
    for more details.
  id: totrans-split-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我在自定义异步对象方面经验有限，请查找其他地方获取更多详情。
- en: Construction and finalizing 🏭
  id: totrans-split-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造和结束 🏭
- en: The last few dunder methods are related to object creation and destruction.
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几个双下划线方法与对象的创建和销毁有关。
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-212
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 双下划线方法调用 | 返回值 |'
- en: '| --- | --- | --- |'
  id: totrans-split-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `T(a, b=3)` | `T.__new__(T, a, b=3)` | New instance (`x`) |'
  id: totrans-split-214
  prefs: []
  type: TYPE_TB
  zh: '| `T(a, b=3)` | `T.__new__(T, a, b=3)` | 新实例 (`x`) |'
- en: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
  id: totrans-split-215
  prefs: []
  type: TYPE_TB
  zh: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
- en: '| `del x` | `x.__del__()` | `None` |'
  id: totrans-split-216
  prefs: []
  type: TYPE_TB
  zh: '| `del x` | `x.__del__()` | `None` |'
- en: Calling a class returns a new class instance thanks to the `__new__` method.
    The `__new__` method is Python's **constructor method**, though unlike constructors
    in many programming languages, you should almost *never* define your own `__new__`
    method. To control object creation, prefer the initializer (`__init__`), not the
    constructor (`__new__`). [Here's an odd `__new__` example](https://pym.dev/p/28r9m/).
  id: totrans-split-217
  prefs: []
  type: TYPE_NORMAL
  zh: 调用类返回一个新的类实例，这要归功于 `__new__` 方法。`__new__` 方法是 Python 的 **构造方法**，尽管与许多编程语言中的构造方法不同，你几乎*永远不应该*定义自己的
    `__new__` 方法。要控制对象创建，请优先使用初始化方法 (`__init__`)，而不是构造方法 (`__new__`)。[这里有一个奇怪的 `__new__`
    示例](https://pym.dev/p/28r9m/)。
- en: You could think of `__del__` as a "destructor" method, though it's actually
    called the **finalizer method**. Just before an object is deleted, its `__del__`
    method is called ([example](https://pym.dev/p/2hexg/)). Files implement a `__del__`
    method that closes the file and any binary file buffer that it may be linked to.
  id: totrans-split-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把 `__del__` 视为一个 "析构" 方法，尽管它实际上被称为 **终结器方法**。在对象被删除之前，其 `__del__` 方法会被调用（[示例](https://pym.dev/p/2hexg/)）。文件实现了一个
    `__del__` 方法，用于关闭文件及其可能链接到的任何二进制文件缓冲区。
- en: Library-specific dunder methods 🧰
  id: totrans-split-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定于库的双下划线方法 🧰
- en: 'Some standard library modules define custom dunder methods that aren''t used
    anywhere else:'
  id: totrans-split-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准库模块定义了不在其他地方使用的自定义双下划线方法：
- en: '[dataclasses](https://www.pythonmorsels.com/dataclasses/) support a `__post_init__`
    method'
  id: totrans-split-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[dataclasses](https://www.pythonmorsels.com/dataclasses/) 支持 `__post_init__`
    方法'
- en: '`abc.ABC` classes have a `__subclasshook__` method which `abc.ABCMeta` calls
    in its `__subclasscheck__` method (more in [goose typing](https://www.pythonmorsels.com/goose-typing/))'
  id: totrans-split-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.ABC` 类具有 `__subclasshook__` 方法，`abc.ABCMeta` 在其 `__subclasscheck__` 方法中调用它（更多内容请参见
    [goose typing](https://www.pythonmorsels.com/goose-typing/)）'
- en: Path-like objects have a `__fspath__` method, which returns the file path as
    a string
  id: totrans-split-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似路径的对象具有 `__fspath__` 方法，返回文件路径字符串
- en: Python's `copy` module will use the `__copy__` and `__deepcopy__` methods if
    present
  id: totrans-split-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 `copy` 模块将使用 `__copy__` 和 `__deepcopy__` 方法（如果存在）
- en: Pickling relies on `__getnewargs_ex__` or `__getargs__`, though `__getstate__`
    and `__setstate__` can customize further and `__reduce__` or `__reduce_ex__` are
    even lower-level
  id: totrans-split-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pickling 依赖 `__getnewargs_ex__` 或 `__getargs__`，尽管 `__getstate__` 和 `__setstate__`
    可进一步自定义，而 `__reduce__` 或 `__reduce_ex__` 则更低级
- en: '`sys.getsizeof` relies on the `__sizeof__` method to get an object''s size
    (in bytes)'
  id: totrans-split-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys.getsizeof` 依赖于 `__sizeof__` 方法来获取对象的大小（以字节为单位）'
- en: Dunder attributes 📇
  id: totrans-split-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 魔术属性 📇
- en: In addition to dunder methods, Python has many non-method **dunder attributes**.
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了魔术方法之外，Python 还有许多非方法的 **魔术属性**。
- en: 'Here are some of the more common dunder attributes you''ll see:'
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常见的魔术属性：
- en: '`__name__`: name of a function, classes, or module'
  id: totrans-split-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__name__`: 函数、类或模块的名称'
- en: '`__module__`: module name for a function or class'
  id: totrans-split-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__module__`: 函数或类所在的模块名'
- en: '`__doc__`: [docstring](https://www.pythonmorsels.com/docstrings/) for a function,
    class, or module'
  id: totrans-split-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__doc__`: 函数、类或模块的 [文档字符串](https://www.pythonmorsels.com/docstrings/)'
- en: '`__class__`: an object''s class (call [Python''s `type` function](https://www.pythonmorsels.com/built-in-functions-in-python/#type)
    instead)'
  id: totrans-split-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__class__`: 对象的类（使用 [Python 的 `type` 函数](https://www.pythonmorsels.com/built-in-functions-in-python/#type)
    代替）'
- en: '`__dict__`: most objects store their attributes here (see [where are attributes
    stored?](https://www.pythonmorsels.com/where-are-attributes-stored/))'
  id: totrans-split-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__dict__`: 大多数对象将其属性存储在此处（参见 [属性存储在哪里？](https://www.pythonmorsels.com/where-are-attributes-stored/)）'
- en: '`__slots__`: classes using this are more memory efficient than classes using
    `__dict__`'
  id: totrans-split-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__slots__`: 使用此特性的类比使用`__dict__`的类更节省内存'
- en: '`__match_args__`: classes can define a tuple noting the significance of positional
    attributes when the class is used in structural pattern matching (`match`-`case`)'
  id: totrans-split-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__match_args__`: 类可以定义一个元组，记录类在结构化模式匹配 (`match-case`) 中使用时位置属性的重要性'
- en: '`__mro__`: a class''s method resolution order used when for attribute lookups
    and `super()` calls'
  id: totrans-split-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__mro__`: 类的方法解析顺序，用于属性查找和 `super()` 调用'
- en: '`__bases__`: the direct parent classes of a class'
  id: totrans-split-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__bases__`: 类的直接父类'
- en: '`__file__`: the file that defined the module object (though not always present!)'
  id: totrans-split-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__file__`: 定义模块对象的文件（尽管并非总是存在！）'
- en: '`__wrapped__`: functions decorated with [`functools.wraps`](https://docs.python.org/3/library/functools.html#functools.wraps)
    use this to point to the original function'
  id: totrans-split-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__wrapped__`: 使用 [`functools.wraps`](https://docs.python.org/3/library/functools.html#functools.wraps)
    装饰的函数使用此特性指向原始函数'
- en: '`__version__`: commonly used for noting the version of a package'
  id: totrans-split-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__version__`: 常用于指定包的版本'
- en: '`__all__`: modules can use this to customize the behavior of `from my_module
    import *`'
  id: totrans-split-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__all__`: 模块可以使用此特性自定义`from my_module import *`的行为'
- en: '`__debug__`: running Python with `-O` sets this to `False` and disables Python''s
    `assert` statements'
  id: totrans-split-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__debug__`: 使用 `-O` 运行 Python 将其设置为 `False`，并禁用 Python 的 `assert` 语句'
- en: 'Those are only the more commonly seen dunder attributes. Here are some more:'
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仅是更常见的魔术方法。以下是一些更多的例子：
- en: Functions have `__defaults__`, `__kwdefaults__`, `__code__`, `__globals__`,
    and `__closure__`
  id: totrans-split-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数具有 `__defaults__`、`__kwdefaults__`、`__code__`、`__globals__` 和 `__closure__`
- en: Both functions and classes have `__qualname__`, `__annotations__`, and `__type_params__`
  id: totrans-split-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和类均具有 `__qualname__`、`__annotations__` 和 `__type_params__`
- en: Instance methods have `__func__` and `__self__`
  id: totrans-split-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法具有 `__func__` 和 `__self__`
- en: Modules may also have `__loader__`, `__package__`, `__spec__`, and `__cached__`
    attributes
  id: totrans-split-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块还可以具有 `__loader__`、`__package__`、`__spec__` 和 `__cached__` 属性
- en: Packages have a `__path__` attribute
  id: totrans-split-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包具有 `__path__` 属性
- en: Exceptions have `__traceback__`, `__notes__`, `__context__`, `__cause__`, and
    `__suppress_context__`
  id: totrans-split-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常具有 `__traceback__`、`__notes__`、`__context__`、`__cause__` 和 `__suppress_context__`
- en: Descriptors use `__objclass__`
  id: totrans-split-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述符使用 `__objclass__`
- en: Metaclasses use `__classcell__`
  id: totrans-split-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元类使用 `__classcell__`
- en: Python's `weakref` module uses `__weakref__`
  id: totrans-split-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 `weakref` 模块使用 `__weakref__`
- en: '[Generic aliases](https://docs.python.org/3/library/stdtypes.html#type-annotation-types-generic-alias-union)
    have `__origin__`, `__args__`, `__parameters__`, and `__unpacked__`'
  id: totrans-split-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通用别名](https://docs.python.org/3/library/stdtypes.html#type-annotation-types-generic-alias-union)具有
    `__origin__`、`__args__`、`__parameters__` 和 `__unpacked__`'
- en: The `sys` module has `__stdout__` and `__stderr__` which point to the original
    `stdout` and `stderr` versions
  id: totrans-split-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys` 模块具有指向原始 `stdout` 和 `stderr` 版本的 `__stdout__` 和 `__stderr__`'
- en: 'Additionally, these dunder attributes are used by various standard library
    modules: `__covariant__`, `__contravariant__`, `__infer_variance__`, `__bound__`,
    `__constraints__`. And Python includes a built-in `__import__` function which
    you''re not supposed to use (`importlib.import_module` is preferred) and CPython
    has a `__builtins__` variable that points to the `builtins` module (but this is
    an implementation detail and `builtins` should be explicitly imported when needed
    instead). Also importing from the `__future__` module can enable specific Python
    feature flags and Python will look for a `__main__` module within packages to
    make them runnable as CLI scripts.'
  id: totrans-split-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，各种标准库模块使用这些双下划线属性：`__covariant__`、`__contravariant__`、`__infer_variance__`、`__bound__`、`__constraints__`。Python
    还包含一个内置的 `__import__` 函数，不建议使用（推荐使用 `importlib.import_module`），而 CPython 有一个 `__builtins__`
    变量指向 `builtins` 模块（但这是一个实现细节，应在需要时显式导入 `builtins`）。此外，从 `__future__` 模块导入可以启用特定的
    Python 功能标志，Python 还会在包中寻找 `__main__` 模块以使其作为 CLI 脚本运行。
- en: And that's just *most* of the dunder attribute names you'll find floating around
    in Python. 😵
  id: totrans-split-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 Python 中 *大多数* 双下划线属性名称的速查表。 😵
- en: 'Every dunder method: a cheat sheet ⭐'
  id: totrans-split-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个双下划线方法：速查表 ⭐
- en: This is every Python dunder method organized in categories and ordered very
    roughly by the **most commonly seen** methods first. Some caveats are noted below.
  id: totrans-split-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是按类别组织的每个 Python 双下划线方法，并且非常粗略地按照 **最常见** 方法排序。以下是一些注意事项。
- en: '| Category | Operation | Dunder Method Call | Returns |'
  id: totrans-split-260
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 操作 | 双下划线方法调用 | 返回值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-261
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Object Creation | `x = T(a, b)` | `x.__init__(a, b)` | `None` |'
  id: totrans-split-262
  prefs: []
  type: TYPE_TB
  zh: '| 对象创建 | `x = T(a, b)` | `x.__init__(a, b)` | `None` |'
- en: '| Object Creation | `x = T(a, b)` | `T.__new__(T, a, b)` | New instance (`x`)
    |'
  id: totrans-split-263
  prefs: []
  type: TYPE_TB
  zh: '| 对象创建 | `x = T(a, b)` | `T.__new__(T, a, b)` | 新实例 (`x`) |'
- en: '| Finalizer | `del x` (ish) | `x.__del__()` | `None` |'
  id: totrans-split-264
  prefs: []
  type: TYPE_TB
  zh: '| 终结器 | `del x`（类似） | `x.__del__()` | `None` |'
- en: '| Comparisons | `x == y` | `x.__eq__(y)` | Typically `bool` |'
  id: totrans-split-265
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `x == y` | `x.__eq__(y)` | 通常是 `bool` |'
- en: '| Comparisons | `x != y` | `x.__ne__(y)` | Typically `bool` |'
  id: totrans-split-266
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `x != y` | `x.__ne__(y)` | 通常是 `bool` |'
- en: '| Comparisons | `x < y` | `x.__lt__(y)` | Typically `bool` |'
  id: totrans-split-267
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `x < y` | `x.__lt__(y)` | 通常是 `bool` |'
- en: '| Comparisons | `x > y` | `x.__rt__(y)` | Typically `bool` |'
  id: totrans-split-268
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `x > y` | `x.__rt__(y)` | 通常是 `bool` |'
- en: '| Comparisons | `x <= y` | `x.__le__(y)` | Typically `bool` |'
  id: totrans-split-269
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `x <= y` | `x.__le__(y)` | 通常是 `bool` |'
- en: '| Comparisons | `x >= y` | `x.__ge__(y)` | Typically `bool` |'
  id: totrans-split-270
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `x >= y` | `x.__ge__(y)` | 通常是 `bool` |'
- en: '| Hashability | `hash(x)` | `x.__hash__()` | `int` |'
  id: totrans-split-271
  prefs: []
  type: TYPE_TB
  zh: '| 可哈希性 | `hash(x)` | `x.__hash__()` | `int` |'
- en: '| Conversions | `repr(x)` | `x.__repr__()` | Always `str` |'
  id: totrans-split-272
  prefs: []
  type: TYPE_TB
  zh: '| 转换 | `repr(x)` | `x.__repr__()` | 总是 `str` |'
- en: '| Conversions | `str(x)` | `x.__str__()` | Always `str` |'
  id: totrans-split-273
  prefs: []
  type: TYPE_TB
  zh: '| 转换 | `str(x)` | `x.__str__()` | 总是 `str` |'
- en: '| Conversions | `bool(x)` | `x.__bool__()` | Always `bool` |'
  id: totrans-split-274
  prefs: []
  type: TYPE_TB
  zh: '| 转换 | `bool(x)` | `x.__bool__()` | 总是 `bool` |'
- en: '| Conversions | `int(x)` | `x.__int__()` | Always `int` |'
  id: totrans-split-275
  prefs: []
  type: TYPE_TB
  zh: '| 转换 | `int(x)` | `x.__int__()` | 总是 `int` |'
- en: '| Conversions | `float(x)` | `x.__float__()` | Always `float` |'
  id: totrans-split-276
  prefs: []
  type: TYPE_TB
  zh: '| 转换 | `float(x)` | `x.__float__()` | 总是 `float` |'
- en: '| Conversions | `bytes(x)` | `x.__bytes__()` | Always `bytes` |'
  id: totrans-split-277
  prefs: []
  type: TYPE_TB
  zh: '| 转换 | `bytes(x)` | `x.__bytes__()` | 总是 `bytes` |'
- en: '| Conversions | `complex(x)` | `x.__complex__()` | Always `complex` |'
  id: totrans-split-278
  prefs: []
  type: TYPE_TB
  zh: '| 转换 | `complex(x)` | `x.__complex__()` | 总是 `complex` |'
- en: '| Conversions | `format(x, s)` | `x.__format__(s)` | Always `str` |'
  id: totrans-split-279
  prefs: []
  type: TYPE_TB
  zh: '| 转换 | `format(x, s)` | `x.__format__(s)` | 总是 `str` |'
- en: '| Context Managers | `with x as c:` | `x.__enter__()` | The `c` object |'
  id: totrans-split-280
  prefs: []
  type: TYPE_TB
  zh: '| 上下文管理器 | `with x as c:` | `x.__enter__()` | 对象 `c` |'
- en: '| Context Managers | `with x as c:` | `x.__exit__()` | Truthy/falsey value
    |'
  id: totrans-split-281
  prefs: []
  type: TYPE_TB
  zh: '| 上下文管理器 | `with x as c:` | `x.__exit__()` | 真值/假值 |'
- en: '| Collections | `len(x)` | `x.__len__()` | `int` |'
  id: totrans-split-282
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `len(x)` | `x.__len__()` | `int` |'
- en: '| Collections | `iter(x)` | `x.__iter__()` | An iterator |'
  id: totrans-split-283
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `iter(x)` | `x.__iter__()` | 一个迭代器 |'
- en: '| Collections | `x[a]` | `x.__getitem__(a)` |  |'
  id: totrans-split-284
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `x[a]` | `x.__getitem__(a)` |  |'
- en: '| Collections | `x[a] = b` | `x.__setitem__(a, b)` | `None` |'
  id: totrans-split-285
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `x[a] = b` | `x.__setitem__(a, b)` | `None` |'
- en: '| Collections | `del x[a]` | `x.__delitem__(a)` | `None` |'
  id: totrans-split-286
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `del x[a]` | `x.__delitem__(a)` | `None` |'
- en: '| Collections | `a in x` | `x.__contains__(a)` | `bool` |'
  id: totrans-split-287
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `a in x` | `x.__contains__(a)` | `bool` |'
- en: '| Collections | `reversed(x)` | `x.__reversed__()` | An iterator |'
  id: totrans-split-288
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `reversed(x)` | `x.__reversed__()` | 一个迭代器 |'
- en: '| Collections | `next(x)` | `x.__next__()` | Next iterator item |'
  id: totrans-split-289
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `next(x)` | `x.__next__()` | 下一个迭代器项 |'
- en: '| Collections | `x[a]` | `x.__missing__(a)` |  |'
  id: totrans-split-290
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `x[a]` | `x.__missing__(a)` |  |'
- en: '| Collections |  | `x.__length_hint__()` | `int` |'
  id: totrans-split-291
  prefs: []
  type: TYPE_TB
  zh: '| 集合 |  | `x.__length_hint__()` | `int` |'
- en: '| Arithmetic | `x + y` | `x.__add__(y)` |  |'
  id: totrans-split-292
  prefs: []
  type: TYPE_TB
  zh: '| 算术运算 | `x + y` | `x.__add__(y)` |  |'
- en: '| Arithmetic | `x + y` | `y.__radd__(x)` |  |'
  id: totrans-split-293
  prefs: []
  type: TYPE_TB
  zh: '| 算术运算 | `x + y` | `y.__radd__(x)` |  |'
- en: '| Arithmetic | `x - y` | `x.__sub__(y)` |  |'
  id: totrans-split-294
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x - y` | `x.__sub__(y)` |  |'
- en: '| Arithmetic | `x - y` | `y.__rsub__(x)` |  |'
  id: totrans-split-295
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x - y` | `y.__rsub__(x)` |  |'
- en: '| Arithmetic | `x * y` | `x.__mul__(y)` |  |'
  id: totrans-split-296
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x * y` | `x.__mul__(y)` |  |'
- en: '| Arithmetic | `x * y` | `y.__rmul__(x)` |  |'
  id: totrans-split-297
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x * y` | `y.__rmul__(x)` |  |'
- en: '| Arithmetic | `x / y` | `x.__truediv__(y)` |  |'
  id: totrans-split-298
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x / y` | `x.__truediv__(y)` |  |'
- en: '| Arithmetic | `x / y` | `y.__rtruediv__(x)` |  |'
  id: totrans-split-299
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x / y` | `y.__rtruediv__(x)` |  |'
- en: '| Arithmetic | `x % y` | `x.__mod__(y)` |  |'
  id: totrans-split-300
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x % y` | `x.__mod__(y)` |  |'
- en: '| Arithmetic | `x % y` | `y.__rmod__(x)` |  |'
  id: totrans-split-301
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x % y` | `y.__rmod__(x)` |  |'
- en: '| Arithmetic | `x // y` | `x.__floordiv__(y)` |  |'
  id: totrans-split-302
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x // y` | `x.__floordiv__(y)` |  |'
- en: '| Arithmetic | `x // y` | `y.__rfloordiv__(x)` |  |'
  id: totrans-split-303
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x // y` | `y.__rfloordiv__(x)` |  |'
- en: '| Arithmetic | `x ** y` | `x.__pow__(y)` |  |'
  id: totrans-split-304
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x ** y` | `x.__pow__(y)` |  |'
- en: '| Arithmetic | `x ** y` | `y.__rpow__(x)` |  |'
  id: totrans-split-305
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x ** y` | `y.__rpow__(x)` |  |'
- en: '| Arithmetic | `x @ y` | `x.__matmul__(y)` |  |'
  id: totrans-split-306
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x @ y` | `x.__matmul__(y)` |  |'
- en: '| Arithmetic | `x @ y` | `y.__rmatmul__(x)` |  |'
  id: totrans-split-307
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x @ y` | `y.__rmatmul__(x)` |  |'
- en: '| Arithmetic | `x & y` | `x.__and__(y)` |  |'
  id: totrans-split-308
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x & y` | `x.__and__(y)` |  |'
- en: '| Arithmetic | `x & y` | `y.__rand__(x)` |  |'
  id: totrans-split-309
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x & y` | `y.__rand__(x)` |  |'
- en: '| Arithmetic | `x &#124; y` | `x.__or__(y)` |  |'
  id: totrans-split-310
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x &#124; y` | `x.__or__(y)` |  |'
- en: '| Arithmetic | `x &#124; y` | `y.__ror__(x)` |  |'
  id: totrans-split-311
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x &#124; y` | `y.__ror__(x)` |  |'
- en: '| Arithmetic | `x ^ y` | `x.__xor__(y)` |  |'
  id: totrans-split-312
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x ^ y` | `x.__xor__(y)` |  |'
- en: '| Arithmetic | `x ^ y` | `y.__rxor__(x)` |  |'
  id: totrans-split-313
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x ^ y` | `y.__rxor__(x)` |  |'
- en: '| Arithmetic | `x >> y` | `x.__rshift__(y)` |  |'
  id: totrans-split-314
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x >> y` | `x.__rshift__(y)` |  |'
- en: '| Arithmetic | `x >> y` | `y.__rrshift__(x)` |  |'
  id: totrans-split-315
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x >> y` | `y.__rrshift__(x)` |  |'
- en: '| Arithmetic | `x << y` | `x.__lshift__(y)` |  |'
  id: totrans-split-316
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x << y` | `x.__lshift__(y)` |  |'
- en: '| Arithmetic | `x << y` | `y.__rlshift__(x)` |  |'
  id: totrans-split-317
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x << y` | `y.__rlshift__(x)` |  |'
- en: '| Arithmetic | `-x` | `x.__neg__()` |  |'
  id: totrans-split-318
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `-x` | `x.__neg__()` |  |'
- en: '| Arithmetic | `+x` | `x.__pos__()` |  |'
  id: totrans-split-319
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `+x` | `x.__pos__()` |  |'
- en: '| Arithmetic | `~x` | `x.__invert__()` |  |'
  id: totrans-split-320
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `~x` | `x.__invert__()` |  |'
- en: '| Math functions | `divmod(x, y)` | `x.__divmod__(y)` | 2-item tuple |'
  id: totrans-split-321
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `divmod(x, y)` | `x.__divmod__(y)` | 二元组 |'
- en: '| Math functions | `abs(x)` | `x.__abs__()` | `float` |'
  id: totrans-split-322
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `abs(x)` | `x.__abs__()` | `浮点数` |'
- en: '| Math functions |  | `x.__index__()` | `int` |'
  id: totrans-split-323
  prefs: []
  type: TYPE_TB
  zh: '| Math functions |  | `x.__index__()` | 整数 |'
- en: '| Math functions | `round(x)` | `x.__round__()` | Number |'
  id: totrans-split-324
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `round(x)` | `x.__round__()` | 数字 |'
- en: '| Math functions | `math.trunc(x)` | `x.__trunc__()` | Number |'
  id: totrans-split-325
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `math.trunc(x)` | `x.__trunc__()` | 数字 |'
- en: '| Math functions | `math.floor(x)` | `x.__floor__()` | Number |'
  id: totrans-split-326
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `math.floor(x)` | `x.__floor__()` | 数字 |'
- en: '| Math functions | `math.ceil(x)` | `x.__ceil__()` | Number |'
  id: totrans-split-327
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `math.ceil(x)` | `x.__ceil__()` | 数字 |'
- en: '| Assignment | `x += y` | `x.__iadd__(y)` | Typically `self` |'
  id: totrans-split-328
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x += y` | `x.__iadd__(y)` | 通常为`self` |'
- en: '| Assignment | `x -= y` | `x.__isub__(y)` | Typically `self` |'
  id: totrans-split-329
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x -= y` | `x.__isub__(y)` | 通常为`self` |'
- en: '| Assignment | `x *= y` | `x.__imul__(y)` | Typically `self` |'
  id: totrans-split-330
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x *= y` | `x.__imul__(y)` | 通常为`self` |'
- en: '| Assignment | `x /= y` | `x.__itruediv__(y)` | Typically `self` |'
  id: totrans-split-331
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x /= y` | `x.__itruediv__(y)` | 通常为`self` |'
- en: '| Assignment | `x %= y` | `x.__imod__(y)` | Typically `self` |'
  id: totrans-split-332
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x %= y` | `x.__imod__(y)` | 通常为`self` |'
- en: '| Assignment | `x //= y` | `x.__ifloordiv__(y)` | Typically `self` |'
  id: totrans-split-333
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x //= y` | `x.__ifloordiv__(y)` | 通常为`self` |'
- en: '| Assignment | `x **= y` | `x.__ipow__(y)` | Typically `self` |'
  id: totrans-split-334
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x **= y` | `x.__ipow__(y)` | 通常为`self` |'
- en: '| Assignment | `x @= y` | `x.__imatmul__(y)` | Typically `self` |'
  id: totrans-split-335
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x @= y` | `x.__imatmul__(y)` | 通常为`self` |'
- en: '| Assignment | `x &= y` | `x.__iand__(y)` | Typically `self` |'
  id: totrans-split-336
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x &= y` | `x.__iand__(y)` | 通常为`self` |'
- en: '| Assignment | `x &#124;= y` | `x.__ior__(y)` | Typically `self` |'
  id: totrans-split-337
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x &#124;= y` | `x.__ior__(y)` | 通常为`self` |'
- en: '| Assignment | `x ^= y` | `x.__ixor__(y)` | Typically `self` |'
  id: totrans-split-338
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x ^= y` | `x.__ixor__(y)` | 通常为`self` |'
- en: '| Assignment | `x >>= y` | `x.__irshift__(y)` | Typically `self` |'
  id: totrans-split-339
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x >>= y` | `x.__irshift__(y)` | 通常为`self` |'
- en: '| Assignment | `x <<= y` | `x.__ilshift__(y)` | Typically `self` |'
  id: totrans-split-340
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x <<= y` | `x.__ilshift__(y)` | 通常为`self` |'
- en: '| Attributes | `x.y` | `x.__getattribute__(''y'')` |  |'
  id: totrans-split-341
  prefs: []
  type: TYPE_TB
  zh: '| Attributes | `x.y` | `x.__getattribute__(''y'')` |  |'
- en: '| Attributes | `x.y` | `x.__getattr__(''y'')` |  |'
  id: totrans-split-342
  prefs: []
  type: TYPE_TB
  zh: '| Attributes | `x.y` | `x.__getattr__(''y'')` |  |'
- en: '| Attributes | `x.y = z` | `x.__setattr__(''y'', z)` | `None` |'
  id: totrans-split-343
  prefs: []
  type: TYPE_TB
  zh: '| Attributes | `x.y = z` | `x.__setattr__(''y'', z)` | `None` |'
- en: '| Attributes | `del x.y` | `x.__delattr__(''y'')` | `None` |'
  id: totrans-split-344
  prefs: []
  type: TYPE_TB
  zh: '| Attributes | `del x.y` | `x.__delattr__(''y'')` | `None` |'
- en: '| Attributes | `dir(x)` | `x.__dir__()` | An iterable |'
  id: totrans-split-345
  prefs: []
  type: TYPE_TB
  zh: '| Attributes | `dir(x)` | `x.__dir__()` | 可迭代对象 |'
- en: '| Descriptors | `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None`
    |'
  id: totrans-split-346
  prefs: []
  type: TYPE_TB
  zh: '| Descriptors | `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None`
    |'
- en: '| Descriptors | `t.x` | `T.x.__get__(t, T)` |  |'
  id: totrans-split-347
  prefs: []
  type: TYPE_TB
  zh: '| Descriptors | `t.x` | `T.x.__get__(t, T)` |  |'
- en: '| Descriptors | `t.x = y` | `T.x.__set__(t, y)` | `None` |'
  id: totrans-split-348
  prefs: []
  type: TYPE_TB
  zh: '| Descriptors | `t.x = y` | `T.x.__set__(t, y)` | `None` |'
- en: '| Descriptors | `del t.x` | `T.x.__delete__(t)` | `None` |'
  id: totrans-split-349
  prefs: []
  type: TYPE_TB
  zh: '| 描述符 | `del t.x` | `T.x.__delete__(t)` | `None` |'
- en: '| Class stuff | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
  id: totrans-split-350
  prefs: []
  type: TYPE_TB
  zh: '| 类的相关内容 | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
- en: '| Class stuff | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
  id: totrans-split-351
  prefs: []
  type: TYPE_TB
  zh: '| 类的相关内容 | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
- en: '| Class stuff | `T[y]` | `T.__class_getitem__(y)` |  |'
  id: totrans-split-352
  prefs: []
  type: TYPE_TB
  zh: '| 类的相关内容 | `T[y]` | `T.__class_getitem__(y)` |  |'
- en: '| Metaclasses | `class T: ...` | `type(base).__prepare__()` | `dict`/mapping
    |'
  id: totrans-split-353
  prefs: []
  type: TYPE_TB
  zh: '| 元类 | `class T: ...` | `type(base).__prepare__()` | `dict`/映射 |'
- en: '| Metaclasses | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
  id: totrans-split-354
  prefs: []
  type: TYPE_TB
  zh: '| 元类 | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
- en: '| Metaclasses | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
  id: totrans-split-355
  prefs: []
  type: TYPE_TB
  zh: '| 元类 | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
- en: '| Async | `await x` (ish) | `x.__await__()` | An iterator |'
  id: totrans-split-356
  prefs: []
  type: TYPE_TB
  zh: '| 异步 | `await x`（近似） | `x.__await__()` | 一个迭代器 |'
- en: '| Async | `async with x:` | `x.__aenter__()` | An awaitable |'
  id: totrans-split-357
  prefs: []
  type: TYPE_TB
  zh: '| 异步 | `async with x:` | `x.__aenter__()` | 一个可等待对象 |'
- en: '| Async | `async with x:` | `x.__aexit__()` | An awaitable |'
  id: totrans-split-358
  prefs: []
  type: TYPE_TB
  zh: '| 异步 | `async with x:` | `x.__aexit__()` | 一个可等待对象 |'
- en: '| Async | `async for a in x:` | `x.__aiter__()` | An awaitable |'
  id: totrans-split-359
  prefs: []
  type: TYPE_TB
  zh: '| 异步 | `async for a in x:` | `x.__aiter__()` | 一个可等待对象 |'
- en: '| Async | `async for a in x:` | `x.__anext__()` | An awaitable |'
  id: totrans-split-360
  prefs: []
  type: TYPE_TB
  zh: '| 异步 | `async for a in x:` | `x.__anext__()` | 一个可等待对象 |'
- en: '| Buffers | `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
  id: totrans-split-361
  prefs: []
  type: TYPE_TB
  zh: '| 缓冲区 | `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
- en: '| Buffers | `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
  id: totrans-split-362
  prefs: []
  type: TYPE_TB
  zh: '| 缓冲区 | `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
- en: 'The above table has a slight but consistent *untruth*. Most of these dunder
    methods are not *actually* called on an object directly but are instead called
    on the *type* of that object: `type(x).__add__(x, y)` instead of `x.__add__(y)`.
    This distinction mostly matters with metaclass methods.'
  id: totrans-split-363
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表格略微但是一致地*不真实*。 这些双下划线方法大多数情况下不是直接在对象上调用，而是在该对象的*类型*上调用：`type(x).__add__(x,
    y)`而不是`x.__add__(y)`。 这种区别在元类方法中非常重要。
- en: I've also purposely excluded library-specific dunder methods (like `__post_init__`)
    and dunder methods you're unlikely to ever define (like `__subclasses__`). See
    those below.
  id: totrans-split-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我还特意排除了特定于库的双下划线方法（如`__post_init__`）和您不太可能定义的双下划线方法（如`__subclasses__`）。 请参阅下文。
- en: '| Category | Operation | Dunder Method Call | Returns |'
  id: totrans-split-365
  prefs: []
  type: TYPE_TB
  zh: '| 分类 | 操作 | 双下划线方法调用 | 返回值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-366
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Dataclasses | `x = T(a, b)` | `T.__post_init__(a, b)` | `None` |'
  id: totrans-split-367
  prefs: []
  type: TYPE_TB
  zh: '| 数据类 | `x = T(a, b)` | `T.__post_init__(a, b)` | `None` |'
- en: '| Copying | `copy.copy(x)` | `x.__copy__()` | New object |'
  id: totrans-split-368
  prefs: []
  type: TYPE_TB
  zh: '| 复制 | `copy.copy(x)` | `x.__copy__()` | 新对象 |'
- en: '| Copying | `copy.deepcopy(x)` | `x.__deepcopy__(memo)` | New object |'
  id: totrans-split-369
  prefs: []
  type: TYPE_TB
  zh: '| 复制 | `copy.deepcopy(x)` | `x.__deepcopy__(memo)` | 新对象 |'
- en: '| [Pickling](https://docs.python.org/3/library/pickle.html#pickling-class-instances)
    | `pickle.dumps(x)` | `x.__getnewargs__()` | A 2-item tuple |'
  id: totrans-split-370
  prefs: []
  type: TYPE_TB
  zh: '| [Pickling](https://docs.python.org/3/library/pickle.html#pickling-class-instances)
    | `pickle.dumps(x)` | `x.__getnewargs__()` | 一个2项元组 |'
- en: '| Pickling | `pickle.dumps(x)` | `x.__getnewargs_ex__()` | A 2-item tuple |'
  id: totrans-split-371
  prefs: []
  type: TYPE_TB
  zh: '| Pickling | `pickle.dumps(x)` | `x.__getnewargs_ex__()` | 一个2项元组 |'
- en: '| Pickling | `pickle.dumps(x)` | `x.__getstate__()` | A meaningful state |'
  id: totrans-split-372
  prefs: []
  type: TYPE_TB
  zh: '| Pickling | `pickle.dumps(x)` | `x.__getstate__()` | 一个有意义的状态 |'
- en: '| Pickling | `pickle.dumps(x)` | `x.__reduce__()` | A 2-6 item tuple |'
  id: totrans-split-373
  prefs: []
  type: TYPE_TB
  zh: '| Pickling | `pickle.dumps(x)` | `x.__reduce__()` | 一个2-6项元组 |'
- en: '| Pickling | `pickle.dumps(x)` | `x.__reduce_ex__(4)` | A 2-6 item tuple |'
  id: totrans-split-374
  prefs: []
  type: TYPE_TB
  zh: '| Pickling | `pickle.dumps(x)` | `x.__reduce_ex__(4)` | 一个2-6项元组 |'
- en: '| Pickling | `pickle.loads(b)` | `x.__setstate__(state)` | `None` |'
  id: totrans-split-375
  prefs: []
  type: TYPE_TB
  zh: '| Pickling | `pickle.loads(b)` | `x.__setstate__(state)` | `None` |'
- en: '| pathlib | [`os.fspath(x)`](https://docs.python.org/3/library/os.html#os.fspath)
    | `p.__fspath__()` | `str` or `bytes` |'
  id: totrans-split-376
  prefs: []
  type: TYPE_TB
  zh: '| pathlib | [`os.fspath(x)`](https://docs.python.org/3/library/os.html#os.fspath)
    | `p.__fspath__()` | `str`或`bytes` |'
- en: '| sys | `sys.getsizeof(x)` | `x.__sizeof__()` | `int` (size in bytes) |'
  id: totrans-split-377
  prefs: []
  type: TYPE_TB
  zh: '| sys | `sys.getsizeof(x)` | `x.__sizeof__()` | `int`（字节大小） |'
- en: '| Class stuff | None? | `x.__subclasses__()` | Subclasses iterable |'
  id: totrans-split-378
  prefs: []
  type: TYPE_TB
  zh: '| 类的相关内容 | None？ | `x.__subclasses__()` | 子类的可迭代对象 |'
- en: '| ABCs | `issubclass(U, T)` | `T.__subclasshook__(U)` | `bool` |'
  id: totrans-split-379
  prefs: []
  type: TYPE_TB
  zh: '| ABCs | `issubclass(U, T)` | `T.__subclasshook__(U)` | `bool` |'
- en: 'So, Python includes 103 "normal" dunder methods, 12 library-specific dunder
    methods, and at least 52 other dunder attributes of various types. That''s over
    150 unique `__dunder__` names! I **do not recommend** memorizing these: let Python
    do its job and look up the dunder method or attribute that you need to implement/find
    whenever you need it.'
  id: totrans-split-380
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python包括了103个“普通”的双下划线方法，12个特定于库的双下划线方法，以及至少52个其他各种类型的双下划线属性。 这超过了150个独特的`__dunder__`名称！我**不建议**记忆这些：让Python完成其工作，并在需要实现/查找的双下划线方法或属性时查阅它。
- en: Keep in mind that **you're not meant to invent your own dunder methods**. Sometimes
    you'll see third-party libraries that *do* invent their own dunder method, but
    this isn't encouraged and it can be quite confusing for users who run across such
    methods and assume they're "*real*" dunder methods.
  id: totrans-split-381
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，**不要自己发明双下划线方法**。有时你会看到一些第三方库确实发明了他们自己的双下划线方法，但这并不被鼓励，而且对那些偶然遇到这些方法并认为它们是“*真正*”双下划线方法的用户来说，可能会相当困惑。
