- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: æœªåˆ†ç±»'
- en: 'date: 2024-05-27 12:53:16'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 12:53:16'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Every dunder method in Python - Python Morsels
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python ä¸­çš„æ¯ä¸ª dunder æ–¹æ³• - Python Morsels
- en: æ¥æºï¼š[https://www.pythonmorsels.com/every-dunder-method/](https://www.pythonmorsels.com/every-dunder-method/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://www.pythonmorsels.com/every-dunder-method/](https://www.pythonmorsels.com/every-dunder-method/)
- en: You've just made a class. You made a `__init__` method. Now what?
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨åˆšåˆšåˆ›å»ºäº†ä¸€ä¸ªç±»ã€‚æ‚¨ç¼–å†™äº†ä¸€ä¸ª `__init__` æ–¹æ³•ã€‚æ¥ä¸‹æ¥è¯¥åšä»€ä¹ˆï¼Ÿ
- en: Python includes *tons* of [dunder methods](https://www.pythonmorsels.com/what-are-dunder-methods/)
    ("double underscore" methods) which allow us to deeply customize how our custom
    classes interact with Python's many features. What dunder methods could you add
    to your class to make it friendly for other Python programmers who use it?
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python åŒ…æ‹¬*å¤§é‡*[dunder methods](https://www.pythonmorsels.com/what-are-dunder-methods/)ï¼ˆåŒä¸‹åˆ’çº¿æ–¹æ³•ï¼‰ï¼Œè¿™äº›æ–¹æ³•å…è®¸æˆ‘ä»¬æ·±åº¦å®šåˆ¶æˆ‘ä»¬çš„è‡ªå®šä¹‰ç±»ä¸
    Python çš„è®¸å¤šåŠŸèƒ½äº¤äº’çš„æ–¹å¼ã€‚æ‚¨å¯ä»¥æ·»åŠ å“ªäº› dunder æ–¹æ³•åˆ°æ‚¨çš„ç±»ä¸­ï¼Œä»¥ä½¿å…¶å¯¹å…¶ä»–ä½¿ç”¨å®ƒçš„ Python ç¨‹åºå‘˜æ›´å‹å¥½ï¼Ÿ
- en: Let's take a look at **every dunder method in Python**, with a focus on when
    each method is useful.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è¯¦ç»†äº†è§£ **Python ä¸­çš„æ¯ä¸ª dunder æ–¹æ³•**ï¼Œé‡ç‚¹ä»‹ç»æ¯ç§æ–¹æ³•ä½•æ—¶ç‰¹åˆ«æœ‰ç”¨ã€‚
- en: Note that the Python documentation refers to these as [special methods](https://docs.python.org/3/glossary.html#term-special-method)
    and notes the synonym "magic method" but *very* [rarely](https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers)
    uses the term "dunder method". However, "dunder method" is a fairly common Python
    colloquialism, as noted in my [unofficial Python glossary](https://www.pythonmorsels.com/terms/).
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼ŒPython æ–‡æ¡£å°†è¿™äº›æ–¹æ³•ç§°ä¸º[special methods](https://docs.python.org/3/glossary.html#term-special-method)ï¼Œå¹¶æŒ‡å‡ºäº†â€œmagic
    methodâ€çš„åŒä¹‰è¯ï¼Œä½†*å¾ˆå°‘*ä½¿ç”¨â€œdunder methodâ€ä¸€è¯ã€‚ç„¶è€Œï¼Œâ€œdunder methodâ€æ˜¯ Python ä¸­ç›¸å½“å¸¸è§çš„å£å¤´ç”¨è¯­ï¼Œå¦‚æˆ‘åœ¨[éå®˜æ–¹
    Python æœ¯è¯­è¡¨](https://www.pythonmorsels.com/terms/)ä¸­æ‰€è¿°ã€‚
- en: You can use the links scattered throughout this page for more details on any
    particular dunder method. For a list of all of them, see the cheat sheet in the
    final section.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¯ä»¥ä½¿ç”¨æœ¬é¡µé¢ä¸Šæ•£å¸ƒçš„é“¾æ¥è·å–æœ‰å…³ä»»ä½•ç‰¹å®š dunder æ–¹æ³•çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ã€‚è¦æŸ¥çœ‹æ‰€æœ‰æ–¹æ³•çš„åˆ—è¡¨ï¼Œè¯·å‚è§æœ€åä¸€èŠ‚çš„é€ŸæŸ¥è¡¨ã€‚
- en: The 3 essential dunder methods ğŸ”‘
  id: totrans-split-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 ä¸ªå¿…è¦çš„ dunder æ–¹æ³• ğŸ”‘
- en: 'There are 3 dunder methods that *most* classes should have: [`__init__`](https://www.pythonmorsels.com/what-is-init/),
    [`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/),
    and [`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/).'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§å¤šæ•°ç±»åº”å…·æœ‰ 3 ä¸ª dunder æ–¹æ³•ï¼š[`__init__`](https://www.pythonmorsels.com/what-is-init/)ã€[`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/)
    å’Œ [`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/)ã€‚
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-13
  prefs: []
  type: TYPE_TB
  zh: '| Operation | Dunder Method Call | Returns |'
- en: '| --- | --- | --- |'
  id: totrans-split-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
  id: totrans-split-15
  prefs: []
  type: TYPE_TB
  zh: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
- en: '| `repr(x)` | `x.__repr__()` | `str` |'
  id: totrans-split-16
  prefs: []
  type: TYPE_TB
  zh: '| `repr(x)` | `x.__repr__()` | `str` |'
- en: '| `x == y` | `x.__eq__(y)` | Typically `bool` |'
  id: totrans-split-17
  prefs: []
  type: TYPE_TB
  zh: '| `x == y` | `x.__eq__(y)` | é€šå¸¸ä¸º `bool` |'
- en: The [`__init__`](https://www.pythonmorsels.com/what-is-init/) method is the
    **initializer** (not to be confused with the [constructor](#construction-and-finalizing)),
    the [`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/)
    method customizes an object's string representation, and the [`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/)
    method customizes what it means for objects to be *equal* to one another.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[`__init__`](https://www.pythonmorsels.com/what-is-init/) æ–¹æ³•æ˜¯**åˆå§‹åŒ–å™¨**ï¼ˆä¸è¦ä¸[æ„é€ å‡½æ•°](#construction-and-finalizing)æ··æ·†ï¼‰ï¼Œ[`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/)
    æ–¹æ³•è‡ªå®šä¹‰äº†å¯¹è±¡çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ï¼Œ[`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/)
    æ–¹æ³•è‡ªå®šä¹‰äº†å¯¹è±¡ä¹‹é—´çš„*ç›¸ç­‰*å…³ç³»ã€‚'
- en: The `__repr__` method is particularly helpful at the [the Python REPL](https://www.pythonmorsels.com/using-the-python-repl/)
    and when debugging.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`__repr__` æ–¹æ³•åœ¨[Python REPL](https://www.pythonmorsels.com/using-the-python-repl/)å’Œè°ƒè¯•æ—¶ç‰¹åˆ«æœ‰å¸®åŠ©ã€‚'
- en: Equality and hashability ğŸŸ°
  id: totrans-split-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç›¸ç­‰æ€§å’Œå¯å“ˆå¸Œæ€§ ğŸŸ°
- en: In addition to the `__eq__` method, Python has 2 other dunder methods for determining
    the "value" of an object in relation to other objects.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº† `__eq__` æ–¹æ³•å¤–ï¼ŒPython è¿˜æœ‰å…¶ä»– 2 ä¸ª dunder æ–¹æ³•ï¼Œç”¨äºç¡®å®šå¯¹è±¡åœ¨ä¸å…¶ä»–å¯¹è±¡çš„å…³ç³»ä¸­çš„â€œå€¼â€ã€‚
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-22
  prefs: []
  type: TYPE_TB
  zh: '| Operation | Dunder Method Call | Returns |'
- en: '| --- | --- | --- |'
  id: totrans-split-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `x == y` | `x.__eq__(y)` | Typically `bool` |'
  id: totrans-split-24
  prefs: []
  type: TYPE_TB
  zh: '| `x == y` | `x.__eq__(y)` | é€šå¸¸ä¸º `bool` |'
- en: '| `x != y` | `x.__ne__(y)` | Typically `bool` |'
  id: totrans-split-25
  prefs: []
  type: TYPE_TB
  zh: '| `x != y` | `x.__ne__(y)` | é€šå¸¸ä¸º `bool` |'
- en: '| `hash(x)` | `x.__hash__()` | `int` |'
  id: totrans-split-26
  prefs: []
  type: TYPE_TB
  zh: '| `hash(x)` | `x.__hash__()` | `int` |'
- en: Python's `__eq__` method typically returns `True`, `False`, or [`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/)
    (if objects can't be compared). The default `__eq__` implementation relies on
    the `is` operator, which checks for **[identity](https://www.pythonmorsels.com/equality-vs-identity/)**.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python çš„ `__eq__` æ–¹æ³•é€šå¸¸è¿”å› `True`ã€`False` æˆ– [`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/)ï¼ˆå¦‚æœå¯¹è±¡æ— æ³•æ¯”è¾ƒï¼‰ã€‚
    é»˜è®¤çš„ `__eq__` å®ç°ä¾èµ–äº `is` æ“ä½œç¬¦ï¼Œç”¨äºæ£€æŸ¥**[èº«ä»½](https://www.pythonmorsels.com/equality-vs-identity/)**ã€‚
- en: The default implementation of `__ne__` calls `__eq__` and negates any boolean
    return value given (or returns `NotImplemented` if `__eq__` did). This default
    behavior is usually "good enough", so **you'll almost never see `__ne__` implemented**.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤çš„ `__ne__` å®ç°è°ƒç”¨ `__eq__` å¹¶å¯¹ç»™å®šçš„å¸ƒå°”è¿”å›å€¼å–åï¼ˆæˆ–è€…å¦‚æœ `__eq__` è¿”å› `NotImplemented` åˆ™è¿”å›
    `NotImplemented`ï¼‰ã€‚ è¿™ç§é»˜è®¤è¡Œä¸ºé€šå¸¸æ˜¯â€œè¶³å¤Ÿå¥½çš„â€ï¼Œå› æ­¤**ä½ å‡ ä¹æ°¸è¿œä¸ä¼šçœ‹åˆ°å®ç° `__ne__`**ã€‚
- en: Hashable objects can be used as keys in dictionaries or values in sets. All
    objects in Python are [hashable](https://www.pythonmorsels.com/what-are-hashable-objects/)
    by default, but if you've written a custom `__eq__` method then your objects *won't*
    be hashable without a custom `__hash__` method. But **the hash value of an object
    must never change** or [bad things will happen](https://pym.dev/p/2ysgz/) so **typically
    only *immutable* objects implement `__hash__`**.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: å¯å“ˆå¸Œå¯¹è±¡å¯ä»¥ç”¨ä½œå­—å…¸çš„é”®æˆ–é›†åˆä¸­çš„å€¼ã€‚Python ä¸­çš„æ‰€æœ‰å¯¹è±¡é»˜è®¤éƒ½æ˜¯[å¯å“ˆå¸Œçš„](https://www.pythonmorsels.com/what-are-hashable-objects/)ï¼Œä½†å¦‚æœä½ ç¼–å†™äº†è‡ªå®šä¹‰çš„
    `__eq__` æ–¹æ³•ï¼Œåˆ™ä½ çš„å¯¹è±¡åœ¨æ²¡æœ‰è‡ªå®šä¹‰çš„ `__hash__` æ–¹æ³•æ—¶æ˜¯*ä¸å¯å“ˆå¸Œçš„*ã€‚ä½†æ˜¯ï¼Œ**å¯¹è±¡çš„å“ˆå¸Œå€¼ç»å¯¹ä¸èƒ½æ”¹å˜**ï¼Œå¦åˆ™å°†ä¼šå‘ç”Ÿ[ä¸å¥½çš„äº‹æƒ…](https://pym.dev/p/2ysgz/)ï¼Œå› æ­¤**é€šå¸¸åªæœ‰*ä¸å¯å˜*å¯¹è±¡å®ç°
    `__hash__`**ã€‚
- en: For implementing equality checks, see [`__eq__` in Python](https://www.pythonmorsels.com/overloading-equality-in-python/).
    For implementing hashability, see [making hashable objects in Python](https://www.pythonmorsels.com/making-hashable-objects/).
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: è‹¥è¦å®ç°ç›¸ç­‰æ€§æ£€æŸ¥ï¼Œè¯·å‚é˜…[Python ä¸­çš„ `__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/)ã€‚
    è‹¥è¦å®ç°å¯å“ˆå¸Œæ€§ï¼Œè¯·å‚é˜…[åœ¨ Python ä¸­åˆ›å»ºå¯å“ˆå¸Œå¯¹è±¡](https://www.pythonmorsels.com/making-hashable-objects/)ã€‚
- en: Orderability âš–ï¸
  id: totrans-split-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¯æ’åºæ€§ âš–ï¸
- en: Python's comparison operators (`<`, `>`, `<=`, `>=`) can all be overloaded with
    dunder methods as well. The comparison operators also power functions that rely
    on the relative ordering of objects, like `sorted`, `min`, and `max`.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python çš„æ¯”è¾ƒè¿ç®—ç¬¦ï¼ˆ`<`ã€`>`ã€`<=`ã€`>=`ï¼‰ä¹Ÿå¯ä»¥é€šè¿‡é­”æœ¯æ–¹æ³•è¿›è¡Œé‡è½½ã€‚ æ¯”è¾ƒè¿ç®—ç¬¦è¿˜ä¸ºä¾èµ–å¯¹è±¡ç›¸å¯¹é¡ºåºçš„å‡½æ•°æä¾›æ”¯æŒï¼Œå¦‚ `sorted`ã€`min`
    å’Œ `max`ã€‚
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-33
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | é­”æœ¯æ–¹æ³•è°ƒç”¨ | è¿”å›å€¼ |'
- en: '| --- | --- | --- |'
  id: totrans-split-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `<` | `__lt__` | Typically `bool` |'
  id: totrans-split-35
  prefs: []
  type: TYPE_TB
  zh: '| `<` | `__lt__` | é€šå¸¸æ˜¯ `bool` |'
- en: '| `>` | `__gt__` | Typically `bool` |'
  id: totrans-split-36
  prefs: []
  type: TYPE_TB
  zh: '| `>` | `__gt__` | é€šå¸¸æ˜¯ `bool` |'
- en: '| `<=` | `__le__` | Typically `bool` |'
  id: totrans-split-37
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | `__le__` | é€šå¸¸æ˜¯ `bool` |'
- en: '| `>=` | `__ge__` | Typically `bool` |'
  id: totrans-split-38
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | `__ge__` | é€šå¸¸æ˜¯ `bool` |'
- en: If you plan to implement all of these operators in the *typical* way (where
    `x < y` would be the same as asking `y > x`) then the [`total_ordering` decorator](https://docs.python.org/3/library/functools.html#functools.total_ordering)
    from Python's `functools` module will come in handy.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è®¡åˆ’æŒ‰ç…§*å…¸å‹*æ–¹å¼å®ç°æ‰€æœ‰è¿™äº›è¿ç®—ç¬¦ï¼ˆå…¶ä¸­ `x < y` ç­‰åŒäºè¯¢é—® `y > x`ï¼‰ï¼Œé‚£ä¹ˆ Python çš„ `functools` æ¨¡å—ä¸­çš„
    [`total_ordering` è£…é¥°å™¨](https://docs.python.org/3/library/functools.html#functools.total_ordering)
    ä¼šå¾ˆæœ‰å¸®åŠ©ã€‚
- en: Type conversions and string formatting âš—ï¸
  id: totrans-split-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç±»å‹è½¬æ¢å’Œå­—ç¬¦ä¸²æ ¼å¼åŒ– âš—ï¸
- en: Python has a number of dunder methods for converting objects to a different
    type.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python æœ‰è®¸å¤šé­”æœ¯æ–¹æ³•ç”¨äºå°†å¯¹è±¡è½¬æ¢ä¸ºä¸åŒçš„ç±»å‹ã€‚
- en: '| Function | Dunder Method Call | Returns |'
  id: totrans-split-42
  prefs: []
  type: TYPE_TB
  zh: '| å‡½æ•° | é­”æœ¯æ–¹æ³•è°ƒç”¨ | è¿”å›å€¼ |'
- en: '| --- | --- | --- |'
  id: totrans-split-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `str(x)` | `x.__str__()` | `str` |'
  id: totrans-split-44
  prefs: []
  type: TYPE_TB
  zh: '| `str(x)` | `x.__str__()` | `str` |'
- en: '| `bool(x)` | `x.__bool__()` | `bool` |'
  id: totrans-split-45
  prefs: []
  type: TYPE_TB
  zh: '| `bool(x)` | `x.__bool__()` | `bool` |'
- en: '| `int(x)` | `x.__int__()` | `int` |'
  id: totrans-split-46
  prefs: []
  type: TYPE_TB
  zh: '| `int(x)` | `x.__int__()` | `int` |'
- en: '| `float(x)` | `x.__float__()` | `float` |'
  id: totrans-split-47
  prefs: []
  type: TYPE_TB
  zh: '| `float(x)` | `x.__float__()` | `float` |'
- en: '| `bytes(x)` | `x.__bytes__()` | [`bytes`](https://pym.dev/p/2ysgz/) |'
  id: totrans-split-48
  prefs: []
  type: TYPE_TB
  zh: '| `bytes(x)` | `x.__bytes__()` | [`å­—èŠ‚`](https://pym.dev/p/2ysgz/) |'
- en: '| `complex(x)` | `x.__complex__()` | [`complex`](https://docs.python.org/3/glossary.html#term-complex-number)
    |'
  id: totrans-split-49
  prefs: []
  type: TYPE_TB
  zh: '| `complex(x)` | `x.__complex__()` | [`å¤æ•°`](https://docs.python.org/3/glossary.html#term-complex-number)
    |'
- en: '| `f"{x:s}"` | `x.__format__(s)` | `str` |'
  id: totrans-split-50
  prefs: []
  type: TYPE_TB
  zh: '| `f"{x:s}"` | `x.__format__(s)` | `str` |'
- en: '| `repr(x)` | `x.__repr__()` | `str` |'
  id: totrans-split-51
  prefs: []
  type: TYPE_TB
  zh: '| `repr(x)` | `x.__repr__()` | `str` |'
- en: The `__bool__` function is used for [truthiness](https://www.pythonmorsels.com/truthiness/)
    checks, though `__len__` is used as a fallback.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`__bool__` å‡½æ•°ç”¨äºè¿›è¡Œ[çœŸå€¼æ£€æŸ¥](https://www.pythonmorsels.com/truthiness/)ï¼Œå°½ç®¡ `__len__`
    ä½œä¸ºåå¤‡ã€‚'
- en: If you needed to make an object that acts like a number (like [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html)
    or [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html)),
    you'll want to implement `__int__`, `__float__`, and `__complex__` so your objects
    can be converted to other numbers. If you wanted to make an object that could
    be used in a `memoryview` or could otherwise be converted to `bytes`, you'll want
    a `__bytes__` method.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨éœ€è¦åˆ›å»ºä¸€ä¸ªåƒ [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html)
    æˆ– [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html) è¿™æ ·çš„å¯¹è±¡ï¼Œè¯¥å¯¹è±¡èƒ½åƒæ•°å€¼ä¸€æ ·ä½¿ç”¨ï¼Œæ‚¨éœ€è¦å®ç°
    `__int__`ã€`__float__` å’Œ `__complex__` æ–¹æ³•ï¼Œä»¥ä¾¿èƒ½å°†æ‚¨çš„å¯¹è±¡è½¬æ¢ä¸ºå…¶ä»–æ•°å€¼ã€‚å¦‚æœæ‚¨éœ€è¦åˆ›å»ºä¸€ä¸ªå¯ä»¥åœ¨ `memoryview`
    ä¸­ä½¿ç”¨æˆ–èƒ½ä»¥å…¶ä»–æ–¹å¼è½¬æ¢ä¸º `bytes` çš„å¯¹è±¡ï¼Œæ‚¨éœ€è¦å®ç° `__bytes__` æ–¹æ³•ã€‚
- en: The `__format__` and `__repr__` methods are different string conversion flavors.
    Most string conversions rely the `__str__` method, but the default `__str__` implementation
    simply calls `__repr__`.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`__format__` å’Œ `__repr__` æ–¹æ³•æ˜¯ä¸åŒçš„å­—ç¬¦ä¸²è½¬æ¢æ–¹å¼ã€‚å¤§å¤šæ•°å­—ç¬¦ä¸²è½¬æ¢ä¾èµ–äº `__str__` æ–¹æ³•ï¼Œä½†é»˜è®¤çš„ `__str__`
    å®ç°åªæ˜¯ç®€å•åœ°è°ƒç”¨ `__repr__`ã€‚'
- en: The `__format__` method is used by all [f-string conversions](https://www.pythonmorsels.com/string-formatting/),
    by the `str` class's `format` method, and by the (rarely used) built-in `format`
    function. This method allows `datetime` objects to [support custom format specifiers](https://www.pythonmorsels.com/string-formatting/#formatting-datetime-objects).
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`__format__` æ–¹æ³•è¢«æ‰€æœ‰ [f-string è½¬æ¢](https://www.pythonmorsels.com/string-formatting/)ã€`str`
    ç±»çš„ `format` æ–¹æ³•ä»¥åŠï¼ˆå¾ˆå°‘ä½¿ç”¨çš„ï¼‰å†…ç½® `format` å‡½æ•°ä½¿ç”¨ã€‚è¯¥æ–¹æ³•å…è®¸ `datetime` å¯¹è±¡æ”¯æŒè‡ªå®šä¹‰çš„æ ¼å¼è¯´æ˜ç¬¦ï¼Œè¯¦æƒ…å‚è§ [æ”¯æŒè‡ªå®šä¹‰æ ¼å¼è¯´æ˜ç¬¦](https://www.pythonmorsels.com/string-formatting/#formatting-datetime-objects)ã€‚'
- en: Context managers ğŸšª
  id: totrans-split-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸Šä¸‹æ–‡ç®¡ç†å™¨ ğŸšª
- en: A context manager is an object that can be used in a `with` block.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ˜¯ä¸€ä¸ªå¯ä»¥åœ¨ `with` å—ä¸­ä½¿ç”¨çš„å¯¹è±¡ã€‚
- en: '| Use | Dunder Method Call | Returns |'
  id: totrans-split-58
  prefs: []
  type: TYPE_TB
  zh: '| ä½¿ç”¨ | åŒä¸‹åˆ’çº¿æ–¹æ³•è°ƒç”¨ | è¿”å›å€¼ |'
- en: '| --- | --- | --- |'
  id: totrans-split-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `with` block enter | `x.__enter__()` | A value given to `as` |'
  id: totrans-split-60
  prefs: []
  type: TYPE_TB
  zh: '| `with` å—è¿›å…¥ | `x.__enter__()` | ä½œä¸ºç»™å®šçš„å€¼ |'
- en: '| `with` block exit | `x.__exit__(exc_type, exc, traceback)` | Truthy/falsey
    value |'
  id: totrans-split-61
  prefs: []
  type: TYPE_TB
  zh: '| `with` å—é€€å‡º | `x.__exit__(exc_type, exc, traceback)` | çœŸå€¼/å‡å€¼ |'
- en: For more on context managers see, [what is a context manager](https://www.pythonmorsels.com/what-is-a-context-manager/)
    and [creating a context manager](https://www.pythonmorsels.com/creating-a-context-manager/).
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ï¼Œ[ä»€ä¹ˆæ˜¯ä¸Šä¸‹æ–‡ç®¡ç†å™¨](https://www.pythonmorsels.com/what-is-a-context-manager/)å’Œ[åˆ›å»ºä¸Šä¸‹æ–‡ç®¡ç†å™¨](https://www.pythonmorsels.com/creating-a-context-manager/)ã€‚
- en: Containers and collections ğŸ—ƒï¸
  id: totrans-split-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å®¹å™¨å’Œé›†åˆ ğŸ—ƒï¸
- en: Collections (a.k.a. containers) are essentially data structures or objects that
    act like data stuctures. Lists, dictionaries, sets, strings, and tuples are all
    examples of collections.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: é›†åˆï¼ˆå³å®¹å™¨ï¼‰æœ¬è´¨ä¸Šæ˜¯å……å½“æ•°æ®ç»“æ„æˆ–è€…åƒæ•°æ®ç»“æ„ä¸€æ ·çš„å¯¹è±¡ã€‚åˆ—è¡¨ã€å­—å…¸ã€é›†åˆã€å­—ç¬¦ä¸²å’Œå…ƒç»„éƒ½æ˜¯é›†åˆçš„ä¾‹å­ã€‚
- en: '| Operation | Dunder Method Call | Return Type | Implemented |'
  id: totrans-split-65
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | åŒä¸‹åˆ’çº¿æ–¹æ³•è°ƒç”¨ | è¿”å›ç±»å‹ | å·²å®ç° |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `len(x)` | `x.__len__()` | integer | Very common |'
  id: totrans-split-67
  prefs: []
  type: TYPE_TB
  zh: '| `len(x)` | `x.__len__()` | æ•´æ•° | éå¸¸å¸¸è§ |'
- en: '| `iter(x)` | `x.__iter__()` | iterator | Very common |'
  id: totrans-split-68
  prefs: []
  type: TYPE_TB
  zh: '| `iter(x)` | `x.__iter__()` | è¿­ä»£å™¨ | éå¸¸å¸¸è§ |'
- en: '| `for item in x: ...` | `x.__iter__()` | iterator | Very common |'
  id: totrans-split-69
  prefs: []
  type: TYPE_TB
  zh: '| `for item in x: ...` | `x.__iter__()` | è¿­ä»£å™¨ | éå¸¸å¸¸è§ |'
- en: '| `x[a]` | `x.__getitem__(a)` | any object | Common |'
  id: totrans-split-70
  prefs: []
  type: TYPE_TB
  zh: '| `x[a]` | `x.__getitem__(a)` | ä»»ä½•å¯¹è±¡ | å¸¸è§ |'
- en: '| `x[a] = b` | `x.__setitem__(a, b)` | None | Common |'
  id: totrans-split-71
  prefs: []
  type: TYPE_TB
  zh: '| `x[a] = b` | `x.__setitem__(a, b)` | æ—  | å¸¸è§ |'
- en: '| `del x[a]` | `x.__delitem__(a)` | None | Common |'
  id: totrans-split-72
  prefs: []
  type: TYPE_TB
  zh: '| `del x[a]` | `x.__delitem__(a)` | æ—  | å¸¸è§ |'
- en: '| `a in x` | `x.__contains__(a)` | bool | Common |'
  id: totrans-split-73
  prefs: []
  type: TYPE_TB
  zh: '| `a in x` | `x.__contains__(a)` | å¸ƒå°”å€¼ | å¸¸è§ |'
- en: '| `reversed(x)` | `x.__reversed__()` | iterator | Common |'
  id: totrans-split-74
  prefs: []
  type: TYPE_TB
  zh: '| `reversed(x)` | `x.__reversed__()` | è¿­ä»£å™¨ | å¸¸è§ |'
- en: '| `next(x)` | `x.__next__()` | any object | Uncommon |'
  id: totrans-split-75
  prefs: []
  type: TYPE_TB
  zh: '| `next(x)` | `x.__next__()` | ä»»ä½•å¯¹è±¡ | ä¸å¸¸è§ |'
- en: '| `x[a]` | `x.__missing__(a)` | any object | Uncommon |'
  id: totrans-split-76
  prefs: []
  type: TYPE_TB
  zh: '| `x[a]` | `x.__missing__(a)` | ä»»ä½•å¯¹è±¡ | ä¸å¸¸è§ |'
- en: '| `operator.length_hint(x)` | `x.__length_hint__()` | integer | Uncommon |'
  id: totrans-split-77
  prefs: []
  type: TYPE_TB
  zh: '| `operator.length_hint(x)` | `x.__length_hint__()` | æ•´æ•° | ä¸å¸¸è§ |'
- en: 'The `__iter__` method is used by the `iter` function *and* for all forms of
    iteration: [`for` loops](https://www.pythonmorsels.com/writing-a-for-loop/), [comprehensions](https://www.pythonmorsels.com/what-are-list-comprehensions/),
    [tuple unpacking](https://www.pythonmorsels.com/tuple-unpacking/), and [using
    `*` for iterable unpacking](https://www.pythonmorsels.com/unpacking-iterables-iterables/).'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`__iter__` æ–¹æ³•è¢« `iter` å‡½æ•°ä½¿ç”¨ *ä»¥åŠ* æ‰€æœ‰å½¢å¼çš„è¿­ä»£ï¼š[`for` å¾ªç¯](https://www.pythonmorsels.com/writing-a-for-loop/)ã€[æ¨å¯¼å¼](https://www.pythonmorsels.com/what-are-list-comprehensions/)ã€[å…ƒç»„è§£åŒ…](https://www.pythonmorsels.com/tuple-unpacking/)
    å’Œ [ä½¿ç”¨ `*` è¿›è¡Œå¯è¿­ä»£è§£åŒ…](https://www.pythonmorsels.com/unpacking-iterables-iterables/)ã€‚'
- en: While the `__iter__` method is necessary for creating a custom iterable, the
    `__next__` method is necessary for creating a custom iterator (which is much less
    common). The `__missing__` method is only ever called by the `dict` class on itself,
    unless another class decides to implement `__missing__`. The `__length_hint__`
    method supplies a length guess for structures which do not support `__len__` so
    that lists or other structures can be pre-sized more efficiently.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶`__iter__`æ–¹æ³•å¯¹äºåˆ›å»ºè‡ªå®šä¹‰å¯è¿­ä»£å¯¹è±¡æ˜¯å¿…éœ€çš„ï¼Œä½†`__next__`æ–¹æ³•å¯¹äºåˆ›å»ºè‡ªå®šä¹‰è¿­ä»£å™¨ï¼ˆè¿™ç§æƒ…å†µè¾ƒå°‘è§ï¼‰æ˜¯å¿…éœ€çš„ã€‚`__missing__`æ–¹æ³•ä»…åœ¨`dict`ç±»è‡ªèº«è°ƒç”¨æ—¶æ‰ä¼šè¢«è°ƒç”¨ï¼Œé™¤éå…¶ä»–ç±»å†³å®šå®ç°`__missing__`ã€‚`__length_hint__`æ–¹æ³•ä¸ºä¸æ”¯æŒ`__len__`çš„ç»“æ„æä¾›é•¿åº¦çŒœæµ‹ï¼Œä»¥ä¾¿æ›´é«˜æ•ˆåœ°é¢„åˆ†é…åˆ—è¡¨æˆ–å…¶ä»–ç»“æ„ã€‚
- en: 'Also see: [the iterator protocol](https://www.pythonmorsels.com/iterator-protocol/),
    [implementing `__len__`](https://www.pythonmorsels.com/making-the-len-function-work-on-your-python-objects/),
    and [implementing `__getitem__`](https://www.pythonmorsels.com/supporting-index-and-key-lookups/).'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: å¦è¯·å‚é˜…ï¼š[è¿­ä»£å™¨åè®®](https://www.pythonmorsels.com/iterator-protocol/)ï¼Œ[å®ç°`__len__`](https://www.pythonmorsels.com/making-the-len-function-work-on-your-python-objects/)ï¼Œä»¥åŠ[å®ç°`__getitem__`](https://www.pythonmorsels.com/supporting-index-and-key-lookups/)ã€‚
- en: Callability â˜ï¸
  id: totrans-split-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¯è°ƒç”¨æ€§ â˜ï¸
- en: Functions, classes, and all other [callable objects](https://www.pythonmorsels.com/callables/)
    rely on the `__call__` method.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: å‡½æ•°ã€ç±»ä»¥åŠæ‰€æœ‰å…¶ä»–[å¯è°ƒç”¨å¯¹è±¡](https://www.pythonmorsels.com/callables/)ä¾èµ–äº`__call__`æ–¹æ³•ã€‚
- en: '| Operation | Dunder Method Call | Return Type |'
  id: totrans-split-83
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | åŒä¸‹åˆ’çº¿æ–¹æ³•è°ƒç”¨ | è¿”å›ç±»å‹ |'
- en: '| --- | --- | --- |'
  id: totrans-split-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `x(a, b=c)` | `x.__call__(a, b=c)` | any object |'
  id: totrans-split-85
  prefs: []
  type: TYPE_TB
  zh: '| `x(a, b=c)` | `x.__call__(a, b=c)` | ä»»ä½•å¯¹è±¡ |'
- en: When a class is called, its [metaclass](https://docs.python.org/3/glossary.html#term-metaclass)'s
    `__call__` method is used. When a class *instance* is called, the class's `__call__`
    method is used.
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä¸€ä¸ªç±»è¢«è°ƒç”¨æ—¶ï¼Œå®ƒçš„[å…ƒç±»](https://docs.python.org/3/glossary.html#term-metaclass)çš„`__call__`æ–¹æ³•ä¼šè¢«ä½¿ç”¨ã€‚å½“ä¸€ä¸ªç±»çš„*å®ä¾‹*è¢«è°ƒç”¨æ—¶ï¼Œåˆ™ä½¿ç”¨è¯¥ç±»çš„`__call__`æ–¹æ³•ã€‚
- en: 'For more on callability, see [Callables: Python''s "functions" are sometimes
    classes](https://www.pythonmorsels.com/class-function-and-callable/).'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: æ¬²äº†è§£æ›´å¤šå…³äºå¯è°ƒç”¨æ€§çš„å†…å®¹ï¼Œè¯·å‚è§[å¯è°ƒç”¨å¯¹è±¡ï¼šPythonçš„â€œå‡½æ•°â€æœ‰æ—¶æ˜¯ç±»](https://www.pythonmorsels.com/class-function-and-callable/)ã€‚
- en: Arithmetic operators â—
  id: totrans-split-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç®—æœ¯è¿ç®—ç¬¦ â—
- en: Python's dunder methods are often described as a tool for "operator overloading".
    Most of this "operator overloading" comes in the form of Python's various arithmetic
    operators.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonçš„åŒä¸‹åˆ’çº¿æ–¹æ³•é€šå¸¸è¢«æè¿°ä¸º"è¿ç®—ç¬¦é‡è½½"çš„å·¥å…·ã€‚å¤§éƒ¨åˆ†è¿™ç§"è¿ç®—ç¬¦é‡è½½"æ˜¯é€šè¿‡Pythonçš„å„ç§ç®—æœ¯è¿ç®—ç¬¦æ¥å®ç°çš„ã€‚
- en: 'There are two ways to break down the arithmetic operators:'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥åˆ†è§£ç®—æœ¯è¿ç®—ç¬¦ï¼š
- en: Mathematical (e.g. `+`, `-`, `*`, `/`, `%`) versus bitwise (e.g. `&`, `|`, `^`,
    `>>`, `~`)
  id: totrans-split-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ•°å­¦è¿ç®—ç¬¦ï¼ˆå¦‚`+`ã€`-`ã€`*`ã€`/`ã€`%`ï¼‰ä¸ä½è¿ç®—ç¬¦ï¼ˆå¦‚`&`ã€`|`ã€`^`ã€`>>`ã€`~`ï¼‰ä¹‹é—´çš„åŒºåˆ«ã€‚
- en: Binary (between 2 values, like `x + y`) versus unary (before 1 value, like `+x`)
  id: totrans-split-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: äºŒè¿›åˆ¶è¿ç®—ç¬¦ï¼ˆä½œç”¨äºä¸¤ä¸ªå€¼ï¼Œå¦‚`x + y`ï¼‰ä¸ä¸€å…ƒè¿ç®—ç¬¦ï¼ˆä½œç”¨äºä¸€ä¸ªå€¼ä¹‹å‰ï¼Œå¦‚`+x`ï¼‰ã€‚
- en: The mathematical operators are much more common than the bitwise ones and the
    binary ones are a bit more common than the unary ones.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°å­¦è¿ç®—ç¬¦æ¯”ä½è¿ç®—ç¬¦æ›´å¸¸è§ï¼Œè€ŒäºŒè¿›åˆ¶è¿ç®—ç¬¦æ¯”ä¸€å…ƒè¿ç®—ç¬¦ç¨å¸¸è§ä¸€äº›ã€‚
- en: 'These are the binary mathematical arithmetic operators:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯äºŒè¿›åˆ¶æ•°å­¦ç®—æœ¯è¿ç®—ç¬¦ï¼š
- en: '| Operation | Left-Hand Method | Right-Hand Method | Description |'
  id: totrans-split-95
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | å·¦æ“ä½œæ•°æ–¹æ³• | å³æ“ä½œæ•°æ–¹æ³• | æè¿° |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `x + y` | `__add__` | `__radd__` | Add / Concatenate |'
  id: totrans-split-97
  prefs: []
  type: TYPE_TB
  zh: '| `x + y` | `__add__` | `__radd__` | åŠ æ³• / è¿æ¥ |'
- en: '| `x - y` | `__sub__` | `__rsub__` | Subtract |'
  id: totrans-split-98
  prefs: []
  type: TYPE_TB
  zh: '| `x - y` | `__sub__` | `__rsub__` | å‡æ³• |'
- en: '| `x * y` | `__mul__` | `__rmul__` | Multiply |'
  id: totrans-split-99
  prefs: []
  type: TYPE_TB
  zh: '| `x * y` | `__mul__` | `__rmul__` | ä¹˜æ³• |'
- en: '| `x / y` | `__truediv__` | `__rtruediv__` | Divide |'
  id: totrans-split-100
  prefs: []
  type: TYPE_TB
  zh: '| `x / y` | `__truediv__` | `__rtruediv__` | é™¤æ³• |'
- en: '| `%` | `__mod__` | `__rmod__` | Modulo |'
  id: totrans-split-101
  prefs: []
  type: TYPE_TB
  zh: '| `%` | `__mod__` | `__rmod__` | å–æ¨¡ |'
- en: '| `x // y` | `__floordiv__` | `__rfloordiv__` | [Integer division](https://www.pythonmorsels.com/integer-division/)
    |'
  id: totrans-split-102
  prefs: []
  type: TYPE_TB
  zh: '| `x // y` | `__floordiv__` | `__rfloordiv__` | [æ•´æ•°é™¤æ³•](https://www.pythonmorsels.com/integer-division/)
    |'
- en: '| `**` | `__pow__` | `__rpow__` | Exponentiate |'
  id: totrans-split-103
  prefs: []
  type: TYPE_TB
  zh: '| `**` | `__pow__` | `__rpow__` | æŒ‡æ•°è¿ç®— |'
- en: '| `x @ y` | `__matmul__` | `__rmatmul__` | Matrix multiply |'
  id: totrans-split-104
  prefs: []
  type: TYPE_TB
  zh: '| `x @ y` | `__matmul__` | `__rmatmul__` | çŸ©é˜µä¹˜æ³• |'
- en: Each of these operators includes left-hand and right-hand methods. If `x.__add__(y)`
    returns [`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/),
    then `y.__radd__(x)` will be attempted. See [arithmetic dunder methods](https://www.pythonmorsels.com/arithmetic-dunder-methods/)
    for more.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªè¿™äº›è¿ç®—ç¬¦éƒ½åŒ…æ‹¬å·¦æ“ä½œæ•°å’Œå³æ“ä½œæ•°æ–¹æ³•ã€‚å¦‚æœ`x.__add__(y)`è¿”å›[`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/)ï¼Œåˆ™å°†å°è¯•`y.__radd__(x)`ã€‚æ›´å¤šå†…å®¹è¯·å‚è§[ç®—æœ¯åŒä¸‹åˆ’çº¿æ–¹æ³•](https://www.pythonmorsels.com/arithmetic-dunder-methods/)ã€‚
- en: 'These are the binary bitwise arithmetic operators:'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯äºŒè¿›åˆ¶ä½è¿ç®—çš„ç®—æœ¯è¿ç®—ç¬¦ï¼š
- en: '| Operation | Left-Hand Method | Right-Hand Method | Description |'
  id: totrans-split-107
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | å·¦æ“ä½œæ•°æ–¹æ³• | å³æ“ä½œæ•°æ–¹æ³• | æè¿° |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `x & y` | `__and__` | `__rand__` | AND |'
  id: totrans-split-109
  prefs: []
  type: TYPE_TB
  zh: '| `x & y` | `__and__` | `__rand__` | ä¸ |'
- en: '| `x &#124; y` | `__or__` | `__ror__` | OR |'
  id: totrans-split-110
  prefs: []
  type: TYPE_TB
  zh: '| `x &#124; y` | `__or__` | `__ror__` | æˆ– |'
- en: '| `x ^ y` | `__xor__` | `__rxor__` | XOR |'
  id: totrans-split-111
  prefs: []
  type: TYPE_TB
  zh: '| `x ^ y` | `__xor__` | `__rxor__` | å¼‚æˆ– |'
- en: '| `x >> y` | `__rshift__` | `__rrshift__` | Right-shift |'
  id: totrans-split-112
  prefs: []
  type: TYPE_TB
  zh: '| `x >> y` | `__rshift__` | `__rrshift__` | å³ç§» |'
- en: '| `x << y` | `__lshift__` | `__rlshift__` | Left-shift |'
  id: totrans-split-113
  prefs: []
  type: TYPE_TB
  zh: '| `x << y` | `__lshift__` | `__rlshift__` | å·¦ç§» |'
- en: 'These are Python''s unary arithmetic operators:'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯ Python çš„ä¸€å…ƒç®—æœ¯è¿ç®—ç¬¦ï¼š
- en: '| Operation | Dunder Method | Variety | Description |'
  id: totrans-split-115
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | Dunder æ–¹æ³• | ç§ç±» | æè¿° |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `-x` | `__neg__` | Mathematical | Negate |'
  id: totrans-split-117
  prefs: []
  type: TYPE_TB
  zh: '| `-x` | `__neg__` | æ•°å­¦ | å–å |'
- en: '| `+x` | `__pos__` | Bitwise | Affirm |'
  id: totrans-split-118
  prefs: []
  type: TYPE_TB
  zh: '| `+x` | `__pos__` | ä½è¿ç®— | è‚¯å®š |'
- en: '| `~x` | `__invert__` | Bitwise | Invert |'
  id: totrans-split-119
  prefs: []
  type: TYPE_TB
  zh: '| `~x` | `__invert__` | ä½è¿ç®— | å–å |'
- en: The unary `+` operator typically [has no effect](https://stackoverflow.com/questions/16819023/whats-the-purpose-of-the-pos-unary-operator-in-python),
    though some objects use it for a specific operation. For example [using `+` on
    `collections.Counter` objects](https://www.pythonmorsels.com/using-counter/#removing-negative-counts)
    will remove non-positive values.
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€å…ƒ `+` è¿ç®—ç¬¦é€šå¸¸[æ²¡æœ‰æ•ˆæœ](https://stackoverflow.com/questions/16819023/whats-the-purpose-of-the-pos-unary-operator-in-python)ï¼Œå°½ç®¡æŸäº›å¯¹è±¡ä½¿ç”¨å®ƒè¿›è¡Œç‰¹å®šæ“ä½œã€‚ä¾‹å¦‚ï¼Œåœ¨[collections.Counter
    å¯¹è±¡ä¸Šä½¿ç”¨ `+`](https://www.pythonmorsels.com/using-counter/#removing-negative-counts)ä¼šç§»é™¤éæ­£å€¼ã€‚
- en: 'Python''s arithmetic operators are often used for non-arithmetic ends: [sequences](https://www.pythonmorsels.com/sequence/)
    use `+` to concatenate and `*` to self-concatenate and [sets](https://www.pythonmorsels.com/practical-uses-of-sets/)
    use `&` for intersection, `|` for union, `-` for asymmetric difference, and `^`
    for symmetric difference. Arithmetic operators are sometimes overloaded for more
    creative uses too. For example, `pathlib.Path` objects [use `/` to create child
    paths](https://docs.python.org/3/library/pathlib.html#operators).'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: Python çš„ç®—æœ¯è¿ç®—ç¬¦ç»å¸¸ç”¨äºéç®—æœ¯çš„ç›®çš„ï¼š[åºåˆ—](https://www.pythonmorsels.com/sequence/)ä½¿ç”¨ `+`
    è¿›è¡Œè¿æ¥å’Œ `*` è¿›è¡Œè‡ªè¿æ¥ï¼Œè€Œ[é›†åˆ](https://www.pythonmorsels.com/practical-uses-of-sets/)ä½¿ç”¨
    `&` è¿›è¡Œäº¤é›†ï¼Œ`|` è¿›è¡Œå¹¶é›†ï¼Œ`-` è¿›è¡Œéå¯¹ç§°å·®å¼‚ï¼Œ`^` è¿›è¡Œå¯¹ç§°å·®å¼‚ã€‚ç®—æœ¯è¿ç®—ç¬¦æœ‰æ—¶ä¹Ÿè¢«é‡è½½ä»¥å®ç°æ›´æœ‰åˆ›æ„çš„ç”¨é€”ã€‚ä¾‹å¦‚ï¼Œ`pathlib.Path`
    å¯¹è±¡ä½¿ç”¨ `/` æ¥åˆ›å»ºå­è·¯å¾„ã€‚
- en: In-place arithmetic operations â™»ï¸
  id: totrans-split-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åŸåœ°ç®—æœ¯è¿ç®— â™»ï¸
- en: Python includes many dunder methods for **in-place** operations. If you're making
    a [mutable](https://www.pythonmorsels.com/terms/#mutable) object that supports
    any of the arithmetic operations, you'll want to implement the related in-place
    dunder method(s) as well.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python åŒ…å«è®¸å¤šç”¨äº**åŸåœ°**æ“ä½œçš„åŒä¸‹åˆ’çº¿æ–¹æ³•ã€‚å¦‚æœä½ æ­£åœ¨åˆ›å»ºä¸€ä¸ªæ”¯æŒä»»ä½•ç®—æœ¯æ“ä½œçš„[å¯å˜å¯¹è±¡](https://www.pythonmorsels.com/terms/#mutable)ï¼Œä½ å°†éœ€è¦å®ç°ç›¸å…³çš„åŸåœ°åŒä¸‹åˆ’çº¿æ–¹æ³•ã€‚
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-124
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | Dunder æ–¹æ³•è°ƒç”¨ | è¿”å› |'
- en: '| --- | --- | --- |'
  id: totrans-split-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `x += y` | `x.__iadd__(y)` | Typically `self` |'
  id: totrans-split-126
  prefs: []
  type: TYPE_TB
  zh: '| `x += y` | `x.__iadd__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x -= y` | `x.__isub__(y)` | Typically `self` |'
  id: totrans-split-127
  prefs: []
  type: TYPE_TB
  zh: '| `x -= y` | `x.__isub__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x *= y` | `x.__imul__(y)` | Typically `self` |'
  id: totrans-split-128
  prefs: []
  type: TYPE_TB
  zh: '| `x *= y` | `x.__imul__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x /= y` | `x.__itruediv__(y)` | Typically `self` |'
  id: totrans-split-129
  prefs: []
  type: TYPE_TB
  zh: '| `x /= y` | `x.__itruediv__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x %= y` | `x.__imod__(y)` | Typically `self` |'
  id: totrans-split-130
  prefs: []
  type: TYPE_TB
  zh: '| `x %= y` | `x.__imod__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x //= y` | `x.__ifloordiv__(y)` | Typically `self` |'
  id: totrans-split-131
  prefs: []
  type: TYPE_TB
  zh: '| `x //= y` | `x.__ifloordiv__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x **= y` | `x.__ipow__(y)` | Typically `self` |'
  id: totrans-split-132
  prefs: []
  type: TYPE_TB
  zh: '| `x **= y` | `x.__ipow__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x @= y` | `x.__imatmul__(y)` | Typically `self` |'
  id: totrans-split-133
  prefs: []
  type: TYPE_TB
  zh: '| `x @= y` | `x.__imatmul__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x &= y` | `x.__iand__(y)` | Typically `self` |'
  id: totrans-split-134
  prefs: []
  type: TYPE_TB
  zh: '| `x &= y` | `x.__iand__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x &#124;= y` | `x.__ior__(y)` | Typically `self` |'
  id: totrans-split-135
  prefs: []
  type: TYPE_TB
  zh: '| `x &#124;= y` | `x.__ior__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x ^= y` | `x.__ixor__(y)` | Typically `self` |'
  id: totrans-split-136
  prefs: []
  type: TYPE_TB
  zh: '| `x ^= y` | `x.__ixor__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x >>= y` | `x.__irshift__(y)` | Typically `self` |'
  id: totrans-split-137
  prefs: []
  type: TYPE_TB
  zh: '| `x >>= y` | `x.__irshift__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: '| `x <<= y` | `x.__ilshift__(y)` | Typically `self` |'
  id: totrans-split-138
  prefs: []
  type: TYPE_TB
  zh: '| `x <<= y` | `x.__ilshift__(y)` | é€šå¸¸æ˜¯ `self` |'
- en: All of Python's binary arithmetic operators work in **augmented assignment statements**,
    which involve using an operator followed by the `=` sign to assign to an object
    while performing an operation on it.
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰çš„ Python äºŒè¿›åˆ¶ç®—æœ¯è¿ç®—ç¬¦éƒ½é€‚ç”¨äº**å¢å¼ºèµ‹å€¼è¯­å¥**ï¼Œè¿™æ¶‰åŠä½¿ç”¨æ“ä½œç¬¦åè·Ÿ `=` ç¬¦å·æ¥å¯¹å¯¹è±¡èµ‹å€¼åŒæ—¶è¿›è¡Œæ“ä½œã€‚
- en: Augmented assignments on **mutable objects** are [expected to mutate the original
    object](https://www.pythonmorsels.com/augmented-assignments-mutate/), thanks to
    the mutable object implementing the appropriate dunder method for in-place arithmetic.
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: å¯å˜å¯¹è±¡ä¸Šçš„**å¢å¼ºèµ‹å€¼**é¢„æœŸä¼š[æ”¹å˜åŸå§‹å¯¹è±¡](https://www.pythonmorsels.com/augmented-assignments-mutate/)ï¼Œè¿™è¦å½’åŠŸäºå¯å˜å¯¹è±¡å®ç°äº†é€‚å½“çš„åŸåœ°ç®—æœ¯åŒä¸‹åˆ’çº¿æ–¹æ³•ã€‚
- en: When no dunder method is found for an in-place operation, Python performs the
    operation followed by an assignment. **Immutable objects typically do *not* implement
    dunder methods for in-place operations**, since they should return a new object
    instead of changing the original.
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ‰¾ä¸åˆ°å°±åœ°æ“ä½œçš„åŒä¸‹åˆ’çº¿æ–¹æ³•æ—¶ï¼ŒPython æ‰§è¡Œæ“ä½œï¼Œç„¶åè¿›è¡Œèµ‹å€¼ã€‚**ä¸å¯å˜å¯¹è±¡é€šå¸¸ä¸å®ç°å°±åœ°æ“ä½œçš„åŒä¸‹åˆ’çº¿æ–¹æ³•**ï¼Œå› ä¸ºå®ƒä»¬åº”è¯¥è¿”å›ä¸€ä¸ªæ–°å¯¹è±¡è€Œä¸æ˜¯ä¿®æ”¹åŸå§‹å¯¹è±¡ã€‚
- en: Built-in math functions ğŸ§®
  id: totrans-split-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å†…ç½®æ•°å­¦å‡½æ•° ğŸ§®
- en: Python also includes dunder methods for many math-related functions, both [built-in
    functions](https://www.pythonmorsels.com/built-in-functions-in-python/#type) and
    some functions in the `math` library.
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: Python è¿˜åŒ…æ‹¬äº†è®¸å¤šä¸æ•°å­¦ç›¸å…³çš„åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼ŒåŒ…æ‹¬[å†…ç½®å‡½æ•°](https://www.pythonmorsels.com/built-in-functions-in-python/#type)å’Œ
    `math` åº“ä¸­çš„ä¸€äº›å‡½æ•°ã€‚
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-144
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | åŒä¸‹åˆ’çº¿æ–¹æ³•è°ƒç”¨ | è¿”å›å€¼ |'
- en: '| --- | --- | --- |'
  id: totrans-split-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `divmod(x, y)` | `x.__divmod__(y)` | 2-item tuple |'
  id: totrans-split-146
  prefs: []
  type: TYPE_TB
  zh: '| `divmod(x, y)` | `x.__divmod__(y)` | 2-é¡¹å…ƒç»„ |'
- en: '| `divmod(x, y)` | `y.__rdivmod__(x)` | 2-item tuple |'
  id: totrans-split-147
  prefs: []
  type: TYPE_TB
  zh: '| `divmod(x, y)` | `y.__rdivmod__(x)` | 2-é¡¹å…ƒç»„ |'
- en: '| `abs(x)` | `x.__abs__()` | `float` |'
  id: totrans-split-148
  prefs: []
  type: TYPE_TB
  zh: '| `abs(x)` | `x.__abs__()` | `float` |'
- en: '| `sequence[x]` | `x.__index__()` | `int` |'
  id: totrans-split-149
  prefs: []
  type: TYPE_TB
  zh: '| `sequence[x]` | `x.__index__()` | `int` |'
- en: '| `round(x)` | `x.__round__()` | Number |'
  id: totrans-split-150
  prefs: []
  type: TYPE_TB
  zh: '| `round(x)` | `x.__round__()` | æ•°å­— |'
- en: '| `math.trunc(x)` | `x.__trunc__()` | Number |'
  id: totrans-split-151
  prefs: []
  type: TYPE_TB
  zh: '| `math.trunc(x)` | `x.__trunc__()` | æ•°å­— |'
- en: '| `math.floor(x)` | `x.__floor__()` | Number |'
  id: totrans-split-152
  prefs: []
  type: TYPE_TB
  zh: '| `math.floor(x)` | `x.__floor__()` | æ•°å­— |'
- en: '| `math.ceil(x)` | `x.__ceil__()` | Number |'
  id: totrans-split-153
  prefs: []
  type: TYPE_TB
  zh: '| `math.ceil(x)` | `x.__ceil__()` | æ•°å­— |'
- en: Python's `divmod` function performs [integer division](https://www.pythonmorsels.com/integer-division/)
    (`//`) and a modulo operation (`%`) at the same time. Note that, just like the
    many binary arithmetic operators, `divmod` will also check for an `__rvidmod__`
    method if it needs to ask the *second* argument to handle the operation.
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: Python çš„ `divmod` å‡½æ•°åŒæ—¶æ‰§è¡Œ[æ•´æ•°é™¤æ³•](https://www.pythonmorsels.com/integer-division/)ï¼ˆ`//`ï¼‰å’Œå–æ¨¡è¿ç®—ï¼ˆ`%`ï¼‰ã€‚è¯·æ³¨æ„ï¼Œä¸è®¸å¤šäºŒå…ƒç®—æœ¯è¿ç®—ç¬¦ä¸€æ ·ï¼Œ`divmod`
    å¦‚æœéœ€è¦è¯·æ±‚ç¬¬äºŒä¸ªå‚æ•°å¤„ç†æ“ä½œï¼Œåˆ™ä¹Ÿä¼šæ£€æŸ¥ `__rvidmod__` æ–¹æ³•ã€‚
- en: The `__index__` method is for making integer-like objects. This method losslessly
    converts to an integer, unlike `__int__` which may perform a "lossy" integer conversion
    (e.g. from `float` to `int`). It's used by operations that require *true* integers,
    such as [slicing](https://www.pythonmorsels.com/slicing/), indexing, and `bin`,
    `hex`, and `oct` functions ([example](https://pym.dev/p/2k9zt/)).
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`__index__` æ–¹æ³•ç”¨äºåˆ›å»ºç±»ä¼¼æ•´æ•°çš„å¯¹è±¡ã€‚è¯¥æ–¹æ³•å°†å¯¹è±¡æ— æŸè½¬æ¢ä¸ºæ•´æ•°ï¼Œä¸ `__int__` æ–¹æ³•ä¸åŒï¼Œåè€…å¯èƒ½ä¼šæ‰§è¡Œâ€œæœ‰æŸâ€çš„æ•´æ•°è½¬æ¢ï¼ˆä¾‹å¦‚ä»
    `float` åˆ° `int`ï¼‰ã€‚å®ƒè¢«è¦æ±‚éœ€è¦*çœŸæ­£*æ•´æ•°çš„æ“ä½œä½¿ç”¨ï¼Œä¾‹å¦‚[åˆ‡ç‰‡](https://www.pythonmorsels.com/slicing/)ã€ç´¢å¼•å’Œ
    `bin`ã€`hex`ã€`oct` å‡½æ•°ï¼ˆ[ç¤ºä¾‹](https://pym.dev/p/2k9zt/)ï¼‰ã€‚'
- en: Attribute access ğŸ“œ
  id: totrans-split-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å±æ€§è®¿é—® ğŸ“œ
- en: Python even includes dunder methods for controlling what happens when you access,
    delete, or assign any attribute on an object!
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: Python ç”šè‡³åŒ…æ‹¬äº†åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼Œç”¨äºæ§åˆ¶è®¿é—®ã€åˆ é™¤æˆ–èµ‹å€¼å¯¹è±¡çš„ä»»ä½•å±æ€§ï¼
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-158
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | åŒä¸‹åˆ’çº¿æ–¹æ³•è°ƒç”¨ | è¿”å›å€¼ |'
- en: '| --- | --- | --- |'
  id: totrans-split-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `x.missing` | `x.__getattr__("missing")` | Attribute value |'
  id: totrans-split-160
  prefs: []
  type: TYPE_TB
  zh: '| `x.missing` | `x.__getattr__("missing")` | å±æ€§å€¼ |'
- en: '| `x.anything` | `x.__getattribute__("anything")` | Attribute value |'
  id: totrans-split-161
  prefs: []
  type: TYPE_TB
  zh: '| `x.anything` | `x.__getattribute__("anything")` | å±æ€§å€¼ |'
- en: '| `x.thing = value` | `x.__setattr__("thing", value)` | `None` |'
  id: totrans-split-162
  prefs: []
  type: TYPE_TB
  zh: '| `x.thing = value` | `x.__setattr__("thing", value)` | `None` |'
- en: '| `del x.thing` | `x.__delattr__("thing")` | `None` |'
  id: totrans-split-163
  prefs: []
  type: TYPE_TB
  zh: '| `del x.thing` | `x.__delattr__("thing")` | `None` |'
- en: '| `dir(x)` | `x.__dir__()` | List of strings |'
  id: totrans-split-164
  prefs: []
  type: TYPE_TB
  zh: '| `dir(x)` | `x.__dir__()` | å­—ç¬¦ä¸²åˆ—è¡¨ |'
- en: The `__getattribute__` method is called for *every* attribute access, while
    the `__getattr__` method is only called after Python *fails* to find a given attribute.
    All method calls and attribute accesses call `__getattribute__` so implementing
    it correctly is challenging (due to accidental [recursion](https://www.pythonmorsels.com/what-is-recursion/)).
    See [`__getattr__` versus `__getattribute__`](https://www.pythonmorsels.com/getattr-vs-getattribute/)
    for examples demonstrating the difference between these two methods.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattribute__` æ–¹æ³•åœ¨*æ¯æ¬¡*å±æ€§è®¿é—®æ—¶è¢«è°ƒç”¨ï¼Œè€Œ `__getattr__` æ–¹æ³•ä»…åœ¨ Python æœªèƒ½æ‰¾åˆ°ç‰¹å®šå±æ€§æ—¶æ‰è¢«è°ƒç”¨ã€‚æ‰€æœ‰æ–¹æ³•è°ƒç”¨å’Œå±æ€§è®¿é—®éƒ½è°ƒç”¨
    `__getattribute__`ï¼Œå› æ­¤æ­£ç¡®å®ç°å®ƒå…·æœ‰æŒ‘æˆ˜æ€§ï¼ˆç”±äºæ„å¤–çš„[é€’å½’](https://www.pythonmorsels.com/what-is-recursion/)ï¼‰ã€‚æŸ¥çœ‹[`__getattr__`
    versus `__getattribute__`](https://www.pythonmorsels.com/getattr-vs-getattribute/)ï¼Œäº†è§£æ¼”ç¤ºè¿™ä¸¤ç§æ–¹æ³•ä¹‹é—´å·®å¼‚çš„ç¤ºä¾‹ã€‚'
- en: The `__dir__` method should return an iterable of attribute names (as strings).
    When [the `dir` function](https://www.pythonmorsels.com/built-in-functions-in-python/#dir)
    calls `__dir__`, it converts the returned iterable into a sorted list (like [`sorted`](https://www.pythonmorsels.com/sorting-in-python/)
    does).
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`__dir__` æ–¹æ³•åº”è¿”å›ä¸€ä¸ªå±æ€§åç§°çš„å¯è¿­ä»£å­—ç¬¦ä¸²é›†åˆã€‚å½“[ `dir` å‡½æ•°](https://www.pythonmorsels.com/built-in-functions-in-python/#dir)è°ƒç”¨
    `__dir__` æ—¶ï¼Œå®ƒå°†è¿”å›çš„å¯è¿­ä»£å¯¹è±¡è½¬æ¢ä¸ºæ’åºåˆ—è¡¨ï¼ˆç±»ä¼¼äº[`sorted`](https://www.pythonmorsels.com/sorting-in-python/)
    çš„æ“ä½œï¼‰ã€‚'
- en: The built-in `getattr`, [`setattr`](https://www.pythonmorsels.com/python-setattr/),
    and `delattr` functions correspond to the dunder methods of the same name, but
    they're only intended for dynamic attribute access (not *all* attribute accesses).
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
  zh: å†…ç½®çš„ `getattr`ã€[`setattr`](https://www.pythonmorsels.com/python-setattr/) å’Œ `delattr`
    å‡½æ•°å¯¹åº”äºåŒåçš„ Dunder æ–¹æ³•ï¼Œä½†å®ƒä»¬ä»…ç”¨äºåŠ¨æ€å±æ€§è®¿é—®ï¼ˆä¸æ˜¯ *æ‰€æœ‰* å±æ€§è®¿é—®ï¼‰ã€‚
- en: Now we're getting into the really unusual dunder methods. Python includes many
    dunder methods for metaprogramming-related features.
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è¿›å…¥äº†çœŸæ­£ä¸å¯»å¸¸çš„ Dunder æ–¹æ³•ã€‚Python åŒ…å«è®¸å¤šç”¨äºå…ƒç¼–ç¨‹ç›¸å…³åŠŸèƒ½çš„ Dunder æ–¹æ³•ã€‚
- en: '| Implemented on | Operation | Dunder Method Call | Returns |'
  id: totrans-split-169
  prefs: []
  type: TYPE_TB
  zh: '| å®ç°äº | æ“ä½œ | Dunder æ–¹æ³•è°ƒç”¨ | è¿”å› |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Metaclasses | `class T: ...` | `type(base).__prepare__()` | mapping |'
  id: totrans-split-171
  prefs: []
  type: TYPE_TB
  zh: '| å…ƒç±» | `class T: ...` | `type(base).__prepare__()` | æ˜ å°„ |'
- en: '| Metaclasses | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
  id: totrans-split-172
  prefs: []
  type: TYPE_TB
  zh: '| å…ƒç±» | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
- en: '| Metaclasses | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
  id: totrans-split-173
  prefs: []
  type: TYPE_TB
  zh: '| å…ƒç±» | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
- en: '| Any class | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
  id: totrans-split-174
  prefs: []
  type: TYPE_TB
  zh: '| ä»»æ„ç±» | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
- en: '| Any class | (Called manually) | `T.__subclasses__()` | `list` |'
  id: totrans-split-175
  prefs: []
  type: TYPE_TB
  zh: '| ä»»æ„ç±» | ï¼ˆæ‰‹åŠ¨è°ƒç”¨ï¼‰ | `T.__subclasses__()` | `list` |'
- en: '| Any class | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
  id: totrans-split-176
  prefs: []
  type: TYPE_TB
  zh: '| ä»»æ„ç±» | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
- en: '| Any class | `T[y]` | `T.__class_getitem__(y)` | an item |'
  id: totrans-split-177
  prefs: []
  type: TYPE_TB
  zh: '| ä»»æ„ç±» | `T[y]` | `T.__class_getitem__(y)` | ä¸€ä¸ªé¡¹ç›® |'
- en: The `__prepare__` method customizes the dictionary that's used for a class's
    initial namespace. This is used to pre-populate dictionary values or customize
    the dictionary type ([silly example](https://pym.dev/p/23wfv/)).
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`__prepare__` æ–¹æ³•è‡ªå®šä¹‰äº†ç”¨äºç±»åˆå§‹å‘½åç©ºé—´çš„å­—å…¸ã€‚å®ƒç”¨äºé¢„å…ˆå¡«å……å­—å…¸å€¼æˆ–è‡ªå®šä¹‰å­—å…¸ç±»å‹ï¼ˆ[æ„šè ¢çš„ä¾‹å­](https://pym.dev/p/23wfv/)ï¼‰ã€‚'
- en: The `__instancecheck__` and `__subclasscheck__` methods override the functionality
    of `isinstance` and `issubclass`. Python's ABCs use these to practice [goose typing](https://www.pythonmorsels.com/goose-typing/)
    ([duck typing](https://www.pythonmorsels.com/duck-typing/) *while* type checking).
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`__instancecheck__` å’Œ `__subclasscheck__` æ–¹æ³•è¦†ç›–äº† `isinstance` å’Œ `issubclass`
    çš„åŠŸèƒ½ã€‚Python çš„ ABCs ä½¿ç”¨è¿™äº›æ–¹æ³•æ¥å®ç°[é¹…ç±»å‹](https://www.pythonmorsels.com/goose-typing/)ï¼ˆ[é¸­å­ç±»å‹](https://www.pythonmorsels.com/duck-typing/)åœ¨ç±»å‹æ£€æŸ¥æ—¶çš„åº”ç”¨ï¼‰ã€‚'
- en: The `__init_subclass__` method allows classes to hook into subclass initialization
    ([example](https://pym.dev/p/246z6/)). Classes *also* have a `__subclasses__`
    method (on their [metaclass](https://docs.python.org/3/glossary.html#term-metaclass))
    but it's not typically overridden.
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init_subclass__` æ–¹æ³•å…è®¸ç±»æŒ‚é’©å­ç±»åˆå§‹åŒ–ï¼ˆ[ç¤ºä¾‹](https://pym.dev/p/246z6/)ï¼‰ã€‚ç±»è¿˜æœ‰ä¸€ä¸ª `__subclasses__`
    æ–¹æ³•ï¼ˆåœ¨å®ƒä»¬çš„[å…ƒç±»](https://docs.python.org/3/glossary.html#term-metaclass)ä¸Šï¼‰ï¼Œä½†é€šå¸¸ä¸ä¼šè¢«è¦†ç›–ã€‚'
- en: Python calls `__mro_entries__` during [class inheritance](https://www.pythonmorsels.com/inheriting-one-class-another/)
    for any base classes that are not *actually* classes. The [`typing.NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple)
    function uses this to pretend it's a class ([see here](https://pym.dev/p/2qgzd/)).
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: Python åœ¨[ç±»ç»§æ‰¿](https://www.pythonmorsels.com/inheriting-one-class-another/)æœŸé—´è°ƒç”¨
    `__mro_entries__` å¤„ç†ä»»ä½•å®é™…ä¸Šä¸æ˜¯ç±»çš„åŸºç±»ã€‚[`typing.NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple)
    å‡½æ•°ä½¿ç”¨æ­¤åŠŸèƒ½æ¥å‡è£…å®ƒæ˜¯ä¸€ä¸ªç±»ï¼ˆ[è¯·è§æ­¤å¤„](https://pym.dev/p/2qgzd/)ï¼‰ã€‚
- en: The `__class_getitem__` method allows a class to be subscriptable (*without*
    its metaclass needing a `__getitem__` method). This is typically used for enabling
    fancy type annotations (e.g. `list[int]`).
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`__class_getitem__` æ–¹æ³•å…è®¸ç±»æˆä¸ºå¯ç´¢å¼•çš„ï¼ˆ*æ— éœ€*å…¶å…ƒç±»éœ€è¦ä¸€ä¸ª `__getitem__` æ–¹æ³•ï¼‰ã€‚è¿™é€šå¸¸ç”¨äºå¯ç”¨èŠ±å¼ç±»å‹æ³¨é‡Šï¼ˆä¾‹å¦‚
    `list[int]`ï¼‰ã€‚'
- en: Descriptors ğŸ·ï¸
  id: totrans-split-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æè¿°ç¬¦ ğŸ·ï¸
- en: '[Descriptors](https://docs.python.org/3/glossary.html#term-descriptor) are
    objects that, when attached to a class, can hook into the access of the attribute
    name they''re attached to on that class.'
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[æè¿°ç¬¦](https://docs.python.org/3/glossary.html#term-descriptor)æ˜¯é™„åŠ åˆ°ç±»æ—¶å¯ä»¥æŒ‚é’©åˆ°è¯¥ç±»ä¸Šçš„å±æ€§åç§°è®¿é—®çš„å¯¹è±¡ã€‚'
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-185
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | Dunder æ–¹æ³•è°ƒç”¨ | è¿”å› |'
- en: '| --- | --- | --- |'
  id: totrans-split-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None` |'
  id: totrans-split-187
  prefs: []
  type: TYPE_TB
  zh: '| `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None` |'
- en: '| `t.x` | `T.x.__get__(t, T)` | The value |'
  id: totrans-split-188
  prefs: []
  type: TYPE_TB
  zh: '| `t.x` | `T.x.__get__(t, T)` | è¯¥å€¼ |'
- en: '| `t.x = y` | `T.x.__set__(t, y)` | `None` |'
  id: totrans-split-189
  prefs: []
  type: TYPE_TB
  zh: '| `t.x = y` | `T.x.__set__(t, y)` | `None` |'
- en: '| `del t.x` | `T.x.__delete__(t)` | `None` |'
  id: totrans-split-190
  prefs: []
  type: TYPE_TB
  zh: '| `del t.x` | `T.x.__delete__(t)` | `None` |'
- en: The descriptor protocol is *mostly* a feature that exists to make Python's `property`
    decorator work, though it is also used by a number of third-party libraries.
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
  zh: æè¿°ç¬¦åè®®ä¸»è¦ç”¨äºä½¿ Python çš„ `property` è£…é¥°å™¨å·¥ä½œï¼Œè™½ç„¶ä¹Ÿè¢«è®¸å¤šç¬¬ä¸‰æ–¹åº“ä½¿ç”¨ã€‚
- en: Buffers ğŸ’¾
  id: totrans-split-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç¼“å†²åŒº ğŸ’¾
- en: Implementing a low-level memory array? You need Python's [buffer protocol](https://docs.python.org/3/reference/datamodel.html#emulating-buffer-types).
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
  zh: å®ç°ä½çº§å†…å­˜æ•°ç»„ï¼Ÿä½ éœ€è¦ Python çš„ [ç¼“å†²åŒºåè®®](https://docs.python.org/3/reference/datamodel.html#emulating-buffer-types)ã€‚
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-194
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | åŒä¸‹åˆ’çº¿æ–¹æ³•è°ƒç”¨ | è¿”å›å€¼ |'
- en: '| --- | --- | --- |'
  id: totrans-split-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
  id: totrans-split-196
  prefs: []
  type: TYPE_TB
  zh: '| `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
- en: '| `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
  id: totrans-split-197
  prefs: []
  type: TYPE_TB
  zh: '| `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
- en: The `__release_buffer__` method is called when the buffer that's returned from
    `__buffer__` is deleted.
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä» `__buffer__` è¿”å›çš„ç¼“å†²åŒºè¢«åˆ é™¤æ—¶ï¼Œä¼šè°ƒç”¨ `__release_buffer__` æ–¹æ³•ã€‚
- en: Python's buffer protocol is typically implemented in C, since it's meant for
    low level objects.
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
  zh: Python çš„ç¼“å†²åŒºåè®®é€šå¸¸ç”± C å®ç°ï¼Œå› ä¸ºå®ƒé€‚ç”¨äºä½çº§å¯¹è±¡ã€‚
- en: Asynchronous operations ğŸ¤¹
  id: totrans-split-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¼‚æ­¥æ“ä½œ ğŸ¤¹
- en: 'Want to implement an asynchronous context manager? You need these dunder methods:'
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è¦å®ç°å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Ÿä½ éœ€è¦è¿™äº›åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼š
- en: '`__aenter__`: just like `__enter__`, but it returns an awaitable object'
  id: totrans-split-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__aenter__`: å°±åƒ `__enter__` ä¸€æ ·ï¼Œä½†å®ƒè¿”å›ä¸€ä¸ªå¯ç­‰å¾…å¯¹è±¡'
- en: '`__aexit__`: just like `__exit__`, but it returns an awaitable object'
  id: totrans-split-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__aexit__`: å°±åƒ`__exit__`ä¸€æ ·ï¼Œä½†å®ƒè¿”å›ä¸€ä¸ªå¯ç­‰å¾…å¯¹è±¡ã€‚'
- en: 'Need to support asynchronous iteration? You need these dunder methods:'
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
  zh: éœ€è¦æ”¯æŒå¼‚æ­¥è¿­ä»£ï¼Ÿä½ éœ€è¦è¿™äº›åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼š
- en: '`__aiter__`: must return an asynchronous iterator'
  id: totrans-split-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__aiter__`: å¿…é¡»è¿”å›ä¸€ä¸ªå¼‚æ­¥è¿­ä»£å™¨'
- en: '`__anext__`: like `__next__` or non-async iterators, but this must return an
    awaitable object and this should raise `StopAsyncIteration` instead of `StopIteration`'
  id: totrans-split-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__anext__`: åƒ`__next__`æˆ–éå¼‚æ­¥è¿­ä»£å™¨ä¸€æ ·ï¼Œä½†å®ƒå¿…é¡»è¿”å›ä¸€ä¸ªå¯ç­‰å¾…å¯¹è±¡ï¼Œä¸”åº”è¯¥å¼•å‘`StopAsyncIteration`è€Œä¸æ˜¯`StopIteration`ã€‚'
- en: 'Need to make your own awaitable object? You need this dunder method:'
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
  zh: éœ€è¦åˆ¶ä½œè‡ªå·±çš„å¯ç­‰å¾…å¯¹è±¡ï¼Ÿä½ éœ€è¦è¿™ä¸ªåŒä¸‹åˆ’çº¿æ–¹æ³•ï¼š
- en: '`__await__`: returns an iterator'
  id: totrans-split-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__await__`: è¿”å›ä¸€ä¸ªè¿­ä»£å™¨'
- en: I have little experience with custom asynchronous objects, so look elsewhere
    for more details.
  id: totrans-split-209
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘åœ¨è‡ªå®šä¹‰å¼‚æ­¥å¯¹è±¡æ–¹é¢ç»éªŒæœ‰é™ï¼Œè¯·æŸ¥æ‰¾å…¶ä»–åœ°æ–¹è·å–æ›´å¤šè¯¦æƒ…ã€‚
- en: Construction and finalizing ğŸ­
  id: totrans-split-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ„é€ å’Œç»“æŸ ğŸ­
- en: The last few dunder methods are related to object creation and destruction.
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åå‡ ä¸ªåŒä¸‹åˆ’çº¿æ–¹æ³•ä¸å¯¹è±¡çš„åˆ›å»ºå’Œé”€æ¯æœ‰å…³ã€‚
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-212
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | åŒä¸‹åˆ’çº¿æ–¹æ³•è°ƒç”¨ | è¿”å›å€¼ |'
- en: '| --- | --- | --- |'
  id: totrans-split-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `T(a, b=3)` | `T.__new__(T, a, b=3)` | New instance (`x`) |'
  id: totrans-split-214
  prefs: []
  type: TYPE_TB
  zh: '| `T(a, b=3)` | `T.__new__(T, a, b=3)` | æ–°å®ä¾‹ (`x`) |'
- en: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
  id: totrans-split-215
  prefs: []
  type: TYPE_TB
  zh: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
- en: '| `del x` | `x.__del__()` | `None` |'
  id: totrans-split-216
  prefs: []
  type: TYPE_TB
  zh: '| `del x` | `x.__del__()` | `None` |'
- en: Calling a class returns a new class instance thanks to the `__new__` method.
    The `__new__` method is Python's **constructor method**, though unlike constructors
    in many programming languages, you should almost *never* define your own `__new__`
    method. To control object creation, prefer the initializer (`__init__`), not the
    constructor (`__new__`). [Here's an odd `__new__` example](https://pym.dev/p/28r9m/).
  id: totrans-split-217
  prefs: []
  type: TYPE_NORMAL
  zh: è°ƒç”¨ç±»è¿”å›ä¸€ä¸ªæ–°çš„ç±»å®ä¾‹ï¼Œè¿™è¦å½’åŠŸäº `__new__` æ–¹æ³•ã€‚`__new__` æ–¹æ³•æ˜¯ Python çš„ **æ„é€ æ–¹æ³•**ï¼Œå°½ç®¡ä¸è®¸å¤šç¼–ç¨‹è¯­è¨€ä¸­çš„æ„é€ æ–¹æ³•ä¸åŒï¼Œä½ å‡ ä¹*æ°¸è¿œä¸åº”è¯¥*å®šä¹‰è‡ªå·±çš„
    `__new__` æ–¹æ³•ã€‚è¦æ§åˆ¶å¯¹è±¡åˆ›å»ºï¼Œè¯·ä¼˜å…ˆä½¿ç”¨åˆå§‹åŒ–æ–¹æ³• (`__init__`)ï¼Œè€Œä¸æ˜¯æ„é€ æ–¹æ³• (`__new__`)ã€‚[è¿™é‡Œæœ‰ä¸€ä¸ªå¥‡æ€ªçš„ `__new__`
    ç¤ºä¾‹](https://pym.dev/p/28r9m/)ã€‚
- en: You could think of `__del__` as a "destructor" method, though it's actually
    called the **finalizer method**. Just before an object is deleted, its `__del__`
    method is called ([example](https://pym.dev/p/2hexg/)). Files implement a `__del__`
    method that closes the file and any binary file buffer that it may be linked to.
  id: totrans-split-218
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥æŠŠ `__del__` è§†ä¸ºä¸€ä¸ª "ææ„" æ–¹æ³•ï¼Œå°½ç®¡å®ƒå®é™…ä¸Šè¢«ç§°ä¸º **ç»ˆç»“å™¨æ–¹æ³•**ã€‚åœ¨å¯¹è±¡è¢«åˆ é™¤ä¹‹å‰ï¼Œå…¶ `__del__` æ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼ˆ[ç¤ºä¾‹](https://pym.dev/p/2hexg/)ï¼‰ã€‚æ–‡ä»¶å®ç°äº†ä¸€ä¸ª
    `__del__` æ–¹æ³•ï¼Œç”¨äºå…³é—­æ–‡ä»¶åŠå…¶å¯èƒ½é“¾æ¥åˆ°çš„ä»»ä½•äºŒè¿›åˆ¶æ–‡ä»¶ç¼“å†²åŒºã€‚
- en: Library-specific dunder methods ğŸ§°
  id: totrans-split-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç‰¹å®šäºåº“çš„åŒä¸‹åˆ’çº¿æ–¹æ³• ğŸ§°
- en: 'Some standard library modules define custom dunder methods that aren''t used
    anywhere else:'
  id: totrans-split-220
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€äº›æ ‡å‡†åº“æ¨¡å—å®šä¹‰äº†ä¸åœ¨å…¶ä»–åœ°æ–¹ä½¿ç”¨çš„è‡ªå®šä¹‰åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼š
- en: '[dataclasses](https://www.pythonmorsels.com/dataclasses/) support a `__post_init__`
    method'
  id: totrans-split-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[dataclasses](https://www.pythonmorsels.com/dataclasses/) æ”¯æŒ `__post_init__`
    æ–¹æ³•'
- en: '`abc.ABC` classes have a `__subclasshook__` method which `abc.ABCMeta` calls
    in its `__subclasscheck__` method (more in [goose typing](https://www.pythonmorsels.com/goose-typing/))'
  id: totrans-split-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.ABC` ç±»å…·æœ‰ `__subclasshook__` æ–¹æ³•ï¼Œ`abc.ABCMeta` åœ¨å…¶ `__subclasscheck__` æ–¹æ³•ä¸­è°ƒç”¨å®ƒï¼ˆæ›´å¤šå†…å®¹è¯·å‚è§
    [goose typing](https://www.pythonmorsels.com/goose-typing/)ï¼‰'
- en: Path-like objects have a `__fspath__` method, which returns the file path as
    a string
  id: totrans-split-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç±»ä¼¼è·¯å¾„çš„å¯¹è±¡å…·æœ‰ `__fspath__` æ–¹æ³•ï¼Œè¿”å›æ–‡ä»¶è·¯å¾„å­—ç¬¦ä¸²
- en: Python's `copy` module will use the `__copy__` and `__deepcopy__` methods if
    present
  id: totrans-split-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python çš„ `copy` æ¨¡å—å°†ä½¿ç”¨ `__copy__` å’Œ `__deepcopy__` æ–¹æ³•ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
- en: Pickling relies on `__getnewargs_ex__` or `__getargs__`, though `__getstate__`
    and `__setstate__` can customize further and `__reduce__` or `__reduce_ex__` are
    even lower-level
  id: totrans-split-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pickling ä¾èµ– `__getnewargs_ex__` æˆ– `__getargs__`ï¼Œå°½ç®¡ `__getstate__` å’Œ `__setstate__`
    å¯è¿›ä¸€æ­¥è‡ªå®šä¹‰ï¼Œè€Œ `__reduce__` æˆ– `__reduce_ex__` åˆ™æ›´ä½çº§
- en: '`sys.getsizeof` relies on the `__sizeof__` method to get an object''s size
    (in bytes)'
  id: totrans-split-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys.getsizeof` ä¾èµ–äº `__sizeof__` æ–¹æ³•æ¥è·å–å¯¹è±¡çš„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰'
- en: Dunder attributes ğŸ“‡
  id: totrans-split-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é­”æœ¯å±æ€§ ğŸ“‡
- en: In addition to dunder methods, Python has many non-method **dunder attributes**.
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†é­”æœ¯æ–¹æ³•ä¹‹å¤–ï¼ŒPython è¿˜æœ‰è®¸å¤šéæ–¹æ³•çš„ **é­”æœ¯å±æ€§**ã€‚
- en: 'Here are some of the more common dunder attributes you''ll see:'
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä¸€äº›å¸¸è§çš„é­”æœ¯å±æ€§ï¼š
- en: '`__name__`: name of a function, classes, or module'
  id: totrans-split-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__name__`: å‡½æ•°ã€ç±»æˆ–æ¨¡å—çš„åç§°'
- en: '`__module__`: module name for a function or class'
  id: totrans-split-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__module__`: å‡½æ•°æˆ–ç±»æ‰€åœ¨çš„æ¨¡å—å'
- en: '`__doc__`: [docstring](https://www.pythonmorsels.com/docstrings/) for a function,
    class, or module'
  id: totrans-split-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__doc__`: å‡½æ•°ã€ç±»æˆ–æ¨¡å—çš„ [æ–‡æ¡£å­—ç¬¦ä¸²](https://www.pythonmorsels.com/docstrings/)'
- en: '`__class__`: an object''s class (call [Python''s `type` function](https://www.pythonmorsels.com/built-in-functions-in-python/#type)
    instead)'
  id: totrans-split-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__class__`: å¯¹è±¡çš„ç±»ï¼ˆä½¿ç”¨ [Python çš„ `type` å‡½æ•°](https://www.pythonmorsels.com/built-in-functions-in-python/#type)
    ä»£æ›¿ï¼‰'
- en: '`__dict__`: most objects store their attributes here (see [where are attributes
    stored?](https://www.pythonmorsels.com/where-are-attributes-stored/))'
  id: totrans-split-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__dict__`: å¤§å¤šæ•°å¯¹è±¡å°†å…¶å±æ€§å­˜å‚¨åœ¨æ­¤å¤„ï¼ˆå‚è§ [å±æ€§å­˜å‚¨åœ¨å“ªé‡Œï¼Ÿ](https://www.pythonmorsels.com/where-are-attributes-stored/)ï¼‰'
- en: '`__slots__`: classes using this are more memory efficient than classes using
    `__dict__`'
  id: totrans-split-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__slots__`: ä½¿ç”¨æ­¤ç‰¹æ€§çš„ç±»æ¯”ä½¿ç”¨`__dict__`çš„ç±»æ›´èŠ‚çœå†…å­˜'
- en: '`__match_args__`: classes can define a tuple noting the significance of positional
    attributes when the class is used in structural pattern matching (`match`-`case`)'
  id: totrans-split-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__match_args__`: ç±»å¯ä»¥å®šä¹‰ä¸€ä¸ªå…ƒç»„ï¼Œè®°å½•ç±»åœ¨ç»“æ„åŒ–æ¨¡å¼åŒ¹é… (`match-case`) ä¸­ä½¿ç”¨æ—¶ä½ç½®å±æ€§çš„é‡è¦æ€§'
- en: '`__mro__`: a class''s method resolution order used when for attribute lookups
    and `super()` calls'
  id: totrans-split-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__mro__`: ç±»çš„æ–¹æ³•è§£æé¡ºåºï¼Œç”¨äºå±æ€§æŸ¥æ‰¾å’Œ `super()` è°ƒç”¨'
- en: '`__bases__`: the direct parent classes of a class'
  id: totrans-split-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__bases__`: ç±»çš„ç›´æ¥çˆ¶ç±»'
- en: '`__file__`: the file that defined the module object (though not always present!)'
  id: totrans-split-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__file__`: å®šä¹‰æ¨¡å—å¯¹è±¡çš„æ–‡ä»¶ï¼ˆå°½ç®¡å¹¶éæ€»æ˜¯å­˜åœ¨ï¼ï¼‰'
- en: '`__wrapped__`: functions decorated with [`functools.wraps`](https://docs.python.org/3/library/functools.html#functools.wraps)
    use this to point to the original function'
  id: totrans-split-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__wrapped__`: ä½¿ç”¨ [`functools.wraps`](https://docs.python.org/3/library/functools.html#functools.wraps)
    è£…é¥°çš„å‡½æ•°ä½¿ç”¨æ­¤ç‰¹æ€§æŒ‡å‘åŸå§‹å‡½æ•°'
- en: '`__version__`: commonly used for noting the version of a package'
  id: totrans-split-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__version__`: å¸¸ç”¨äºæŒ‡å®šåŒ…çš„ç‰ˆæœ¬'
- en: '`__all__`: modules can use this to customize the behavior of `from my_module
    import *`'
  id: totrans-split-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__all__`: æ¨¡å—å¯ä»¥ä½¿ç”¨æ­¤ç‰¹æ€§è‡ªå®šä¹‰`from my_module import *`çš„è¡Œä¸º'
- en: '`__debug__`: running Python with `-O` sets this to `False` and disables Python''s
    `assert` statements'
  id: totrans-split-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__debug__`: ä½¿ç”¨ `-O` è¿è¡Œ Python å°†å…¶è®¾ç½®ä¸º `False`ï¼Œå¹¶ç¦ç”¨ Python çš„ `assert` è¯­å¥'
- en: 'Those are only the more commonly seen dunder attributes. Here are some more:'
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ä»…æ˜¯æ›´å¸¸è§çš„é­”æœ¯æ–¹æ³•ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›æ›´å¤šçš„ä¾‹å­ï¼š
- en: Functions have `__defaults__`, `__kwdefaults__`, `__code__`, `__globals__`,
    and `__closure__`
  id: totrans-split-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡½æ•°å…·æœ‰ `__defaults__`ã€`__kwdefaults__`ã€`__code__`ã€`__globals__` å’Œ `__closure__`
- en: Both functions and classes have `__qualname__`, `__annotations__`, and `__type_params__`
  id: totrans-split-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡½æ•°å’Œç±»å‡å…·æœ‰ `__qualname__`ã€`__annotations__` å’Œ `__type_params__`
- en: Instance methods have `__func__` and `__self__`
  id: totrans-split-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ä¾‹æ–¹æ³•å…·æœ‰ `__func__` å’Œ `__self__`
- en: Modules may also have `__loader__`, `__package__`, `__spec__`, and `__cached__`
    attributes
  id: totrans-split-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¨¡å—è¿˜å¯ä»¥å…·æœ‰ `__loader__`ã€`__package__`ã€`__spec__` å’Œ `__cached__` å±æ€§
- en: Packages have a `__path__` attribute
  id: totrans-split-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åŒ…å…·æœ‰ `__path__` å±æ€§
- en: Exceptions have `__traceback__`, `__notes__`, `__context__`, `__cause__`, and
    `__suppress_context__`
  id: totrans-split-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¼‚å¸¸å…·æœ‰ `__traceback__`ã€`__notes__`ã€`__context__`ã€`__cause__` å’Œ `__suppress_context__`
- en: Descriptors use `__objclass__`
  id: totrans-split-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æè¿°ç¬¦ä½¿ç”¨ `__objclass__`
- en: Metaclasses use `__classcell__`
  id: totrans-split-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…ƒç±»ä½¿ç”¨ `__classcell__`
- en: Python's `weakref` module uses `__weakref__`
  id: totrans-split-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python çš„ `weakref` æ¨¡å—ä½¿ç”¨ `__weakref__`
- en: '[Generic aliases](https://docs.python.org/3/library/stdtypes.html#type-annotation-types-generic-alias-union)
    have `__origin__`, `__args__`, `__parameters__`, and `__unpacked__`'
  id: totrans-split-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[é€šç”¨åˆ«å](https://docs.python.org/3/library/stdtypes.html#type-annotation-types-generic-alias-union)å…·æœ‰
    `__origin__`ã€`__args__`ã€`__parameters__` å’Œ `__unpacked__`'
- en: The `sys` module has `__stdout__` and `__stderr__` which point to the original
    `stdout` and `stderr` versions
  id: totrans-split-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys` æ¨¡å—å…·æœ‰æŒ‡å‘åŸå§‹ `stdout` å’Œ `stderr` ç‰ˆæœ¬çš„ `__stdout__` å’Œ `__stderr__`'
- en: 'Additionally, these dunder attributes are used by various standard library
    modules: `__covariant__`, `__contravariant__`, `__infer_variance__`, `__bound__`,
    `__constraints__`. And Python includes a built-in `__import__` function which
    you''re not supposed to use (`importlib.import_module` is preferred) and CPython
    has a `__builtins__` variable that points to the `builtins` module (but this is
    an implementation detail and `builtins` should be explicitly imported when needed
    instead). Also importing from the `__future__` module can enable specific Python
    feature flags and Python will look for a `__main__` module within packages to
    make them runnable as CLI scripts.'
  id: totrans-split-256
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å¤–ï¼Œå„ç§æ ‡å‡†åº“æ¨¡å—ä½¿ç”¨è¿™äº›åŒä¸‹åˆ’çº¿å±æ€§ï¼š`__covariant__`ã€`__contravariant__`ã€`__infer_variance__`ã€`__bound__`ã€`__constraints__`ã€‚Python
    è¿˜åŒ…å«ä¸€ä¸ªå†…ç½®çš„ `__import__` å‡½æ•°ï¼Œä¸å»ºè®®ä½¿ç”¨ï¼ˆæ¨èä½¿ç”¨ `importlib.import_module`ï¼‰ï¼Œè€Œ CPython æœ‰ä¸€ä¸ª `__builtins__`
    å˜é‡æŒ‡å‘ `builtins` æ¨¡å—ï¼ˆä½†è¿™æ˜¯ä¸€ä¸ªå®ç°ç»†èŠ‚ï¼Œåº”åœ¨éœ€è¦æ—¶æ˜¾å¼å¯¼å…¥ `builtins`ï¼‰ã€‚æ­¤å¤–ï¼Œä» `__future__` æ¨¡å—å¯¼å…¥å¯ä»¥å¯ç”¨ç‰¹å®šçš„
    Python åŠŸèƒ½æ ‡å¿—ï¼ŒPython è¿˜ä¼šåœ¨åŒ…ä¸­å¯»æ‰¾ `__main__` æ¨¡å—ä»¥ä½¿å…¶ä½œä¸º CLI è„šæœ¬è¿è¡Œã€‚
- en: And that's just *most* of the dunder attribute names you'll find floating around
    in Python. ğŸ˜µ
  id: totrans-split-257
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åªæ˜¯ Python ä¸­ *å¤§å¤šæ•°* åŒä¸‹åˆ’çº¿å±æ€§åç§°çš„é€ŸæŸ¥è¡¨ã€‚ ğŸ˜µ
- en: 'Every dunder method: a cheat sheet â­'
  id: totrans-split-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ¯ä¸ªåŒä¸‹åˆ’çº¿æ–¹æ³•ï¼šé€ŸæŸ¥è¡¨ â­
- en: This is every Python dunder method organized in categories and ordered very
    roughly by the **most commonly seen** methods first. Some caveats are noted below.
  id: totrans-split-259
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æŒ‰ç±»åˆ«ç»„ç»‡çš„æ¯ä¸ª Python åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼Œå¹¶ä¸”éå¸¸ç²—ç•¥åœ°æŒ‰ç…§ **æœ€å¸¸è§** æ–¹æ³•æ’åºã€‚ä»¥ä¸‹æ˜¯ä¸€äº›æ³¨æ„äº‹é¡¹ã€‚
- en: '| Category | Operation | Dunder Method Call | Returns |'
  id: totrans-split-260
  prefs: []
  type: TYPE_TB
  zh: '| ç±»åˆ« | æ“ä½œ | åŒä¸‹åˆ’çº¿æ–¹æ³•è°ƒç”¨ | è¿”å›å€¼ |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-261
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Object Creation | `x = T(a, b)` | `x.__init__(a, b)` | `None` |'
  id: totrans-split-262
  prefs: []
  type: TYPE_TB
  zh: '| å¯¹è±¡åˆ›å»º | `x = T(a, b)` | `x.__init__(a, b)` | `None` |'
- en: '| Object Creation | `x = T(a, b)` | `T.__new__(T, a, b)` | New instance (`x`)
    |'
  id: totrans-split-263
  prefs: []
  type: TYPE_TB
  zh: '| å¯¹è±¡åˆ›å»º | `x = T(a, b)` | `T.__new__(T, a, b)` | æ–°å®ä¾‹ (`x`) |'
- en: '| Finalizer | `del x` (ish) | `x.__del__()` | `None` |'
  id: totrans-split-264
  prefs: []
  type: TYPE_TB
  zh: '| ç»ˆç»“å™¨ | `del x`ï¼ˆç±»ä¼¼ï¼‰ | `x.__del__()` | `None` |'
- en: '| Comparisons | `x == y` | `x.__eq__(y)` | Typically `bool` |'
  id: totrans-split-265
  prefs: []
  type: TYPE_TB
  zh: '| æ¯”è¾ƒ | `x == y` | `x.__eq__(y)` | é€šå¸¸æ˜¯ `bool` |'
- en: '| Comparisons | `x != y` | `x.__ne__(y)` | Typically `bool` |'
  id: totrans-split-266
  prefs: []
  type: TYPE_TB
  zh: '| æ¯”è¾ƒ | `x != y` | `x.__ne__(y)` | é€šå¸¸æ˜¯ `bool` |'
- en: '| Comparisons | `x < y` | `x.__lt__(y)` | Typically `bool` |'
  id: totrans-split-267
  prefs: []
  type: TYPE_TB
  zh: '| æ¯”è¾ƒ | `x < y` | `x.__lt__(y)` | é€šå¸¸æ˜¯ `bool` |'
- en: '| Comparisons | `x > y` | `x.__rt__(y)` | Typically `bool` |'
  id: totrans-split-268
  prefs: []
  type: TYPE_TB
  zh: '| æ¯”è¾ƒ | `x > y` | `x.__rt__(y)` | é€šå¸¸æ˜¯ `bool` |'
- en: '| Comparisons | `x <= y` | `x.__le__(y)` | Typically `bool` |'
  id: totrans-split-269
  prefs: []
  type: TYPE_TB
  zh: '| æ¯”è¾ƒ | `x <= y` | `x.__le__(y)` | é€šå¸¸æ˜¯ `bool` |'
- en: '| Comparisons | `x >= y` | `x.__ge__(y)` | Typically `bool` |'
  id: totrans-split-270
  prefs: []
  type: TYPE_TB
  zh: '| æ¯”è¾ƒ | `x >= y` | `x.__ge__(y)` | é€šå¸¸æ˜¯ `bool` |'
- en: '| Hashability | `hash(x)` | `x.__hash__()` | `int` |'
  id: totrans-split-271
  prefs: []
  type: TYPE_TB
  zh: '| å¯å“ˆå¸Œæ€§ | `hash(x)` | `x.__hash__()` | `int` |'
- en: '| Conversions | `repr(x)` | `x.__repr__()` | Always `str` |'
  id: totrans-split-272
  prefs: []
  type: TYPE_TB
  zh: '| è½¬æ¢ | `repr(x)` | `x.__repr__()` | æ€»æ˜¯ `str` |'
- en: '| Conversions | `str(x)` | `x.__str__()` | Always `str` |'
  id: totrans-split-273
  prefs: []
  type: TYPE_TB
  zh: '| è½¬æ¢ | `str(x)` | `x.__str__()` | æ€»æ˜¯ `str` |'
- en: '| Conversions | `bool(x)` | `x.__bool__()` | Always `bool` |'
  id: totrans-split-274
  prefs: []
  type: TYPE_TB
  zh: '| è½¬æ¢ | `bool(x)` | `x.__bool__()` | æ€»æ˜¯ `bool` |'
- en: '| Conversions | `int(x)` | `x.__int__()` | Always `int` |'
  id: totrans-split-275
  prefs: []
  type: TYPE_TB
  zh: '| è½¬æ¢ | `int(x)` | `x.__int__()` | æ€»æ˜¯ `int` |'
- en: '| Conversions | `float(x)` | `x.__float__()` | Always `float` |'
  id: totrans-split-276
  prefs: []
  type: TYPE_TB
  zh: '| è½¬æ¢ | `float(x)` | `x.__float__()` | æ€»æ˜¯ `float` |'
- en: '| Conversions | `bytes(x)` | `x.__bytes__()` | Always `bytes` |'
  id: totrans-split-277
  prefs: []
  type: TYPE_TB
  zh: '| è½¬æ¢ | `bytes(x)` | `x.__bytes__()` | æ€»æ˜¯ `bytes` |'
- en: '| Conversions | `complex(x)` | `x.__complex__()` | Always `complex` |'
  id: totrans-split-278
  prefs: []
  type: TYPE_TB
  zh: '| è½¬æ¢ | `complex(x)` | `x.__complex__()` | æ€»æ˜¯ `complex` |'
- en: '| Conversions | `format(x, s)` | `x.__format__(s)` | Always `str` |'
  id: totrans-split-279
  prefs: []
  type: TYPE_TB
  zh: '| è½¬æ¢ | `format(x, s)` | `x.__format__(s)` | æ€»æ˜¯ `str` |'
- en: '| Context Managers | `with x as c:` | `x.__enter__()` | The `c` object |'
  id: totrans-split-280
  prefs: []
  type: TYPE_TB
  zh: '| ä¸Šä¸‹æ–‡ç®¡ç†å™¨ | `with x as c:` | `x.__enter__()` | å¯¹è±¡ `c` |'
- en: '| Context Managers | `with x as c:` | `x.__exit__()` | Truthy/falsey value
    |'
  id: totrans-split-281
  prefs: []
  type: TYPE_TB
  zh: '| ä¸Šä¸‹æ–‡ç®¡ç†å™¨ | `with x as c:` | `x.__exit__()` | çœŸå€¼/å‡å€¼ |'
- en: '| Collections | `len(x)` | `x.__len__()` | `int` |'
  id: totrans-split-282
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆ | `len(x)` | `x.__len__()` | `int` |'
- en: '| Collections | `iter(x)` | `x.__iter__()` | An iterator |'
  id: totrans-split-283
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆ | `iter(x)` | `x.__iter__()` | ä¸€ä¸ªè¿­ä»£å™¨ |'
- en: '| Collections | `x[a]` | `x.__getitem__(a)` |  |'
  id: totrans-split-284
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆ | `x[a]` | `x.__getitem__(a)` |  |'
- en: '| Collections | `x[a] = b` | `x.__setitem__(a, b)` | `None` |'
  id: totrans-split-285
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆ | `x[a] = b` | `x.__setitem__(a, b)` | `None` |'
- en: '| Collections | `del x[a]` | `x.__delitem__(a)` | `None` |'
  id: totrans-split-286
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆ | `del x[a]` | `x.__delitem__(a)` | `None` |'
- en: '| Collections | `a in x` | `x.__contains__(a)` | `bool` |'
  id: totrans-split-287
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆ | `a in x` | `x.__contains__(a)` | `bool` |'
- en: '| Collections | `reversed(x)` | `x.__reversed__()` | An iterator |'
  id: totrans-split-288
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆ | `reversed(x)` | `x.__reversed__()` | ä¸€ä¸ªè¿­ä»£å™¨ |'
- en: '| Collections | `next(x)` | `x.__next__()` | Next iterator item |'
  id: totrans-split-289
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆ | `next(x)` | `x.__next__()` | ä¸‹ä¸€ä¸ªè¿­ä»£å™¨é¡¹ |'
- en: '| Collections | `x[a]` | `x.__missing__(a)` |  |'
  id: totrans-split-290
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆ | `x[a]` | `x.__missing__(a)` |  |'
- en: '| Collections |  | `x.__length_hint__()` | `int` |'
  id: totrans-split-291
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆ |  | `x.__length_hint__()` | `int` |'
- en: '| Arithmetic | `x + y` | `x.__add__(y)` |  |'
  id: totrans-split-292
  prefs: []
  type: TYPE_TB
  zh: '| ç®—æœ¯è¿ç®— | `x + y` | `x.__add__(y)` |  |'
- en: '| Arithmetic | `x + y` | `y.__radd__(x)` |  |'
  id: totrans-split-293
  prefs: []
  type: TYPE_TB
  zh: '| ç®—æœ¯è¿ç®— | `x + y` | `y.__radd__(x)` |  |'
- en: '| Arithmetic | `x - y` | `x.__sub__(y)` |  |'
  id: totrans-split-294
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x - y` | `x.__sub__(y)` |  |'
- en: '| Arithmetic | `x - y` | `y.__rsub__(x)` |  |'
  id: totrans-split-295
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x - y` | `y.__rsub__(x)` |  |'
- en: '| Arithmetic | `x * y` | `x.__mul__(y)` |  |'
  id: totrans-split-296
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x * y` | `x.__mul__(y)` |  |'
- en: '| Arithmetic | `x * y` | `y.__rmul__(x)` |  |'
  id: totrans-split-297
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x * y` | `y.__rmul__(x)` |  |'
- en: '| Arithmetic | `x / y` | `x.__truediv__(y)` |  |'
  id: totrans-split-298
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x / y` | `x.__truediv__(y)` |  |'
- en: '| Arithmetic | `x / y` | `y.__rtruediv__(x)` |  |'
  id: totrans-split-299
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x / y` | `y.__rtruediv__(x)` |  |'
- en: '| Arithmetic | `x % y` | `x.__mod__(y)` |  |'
  id: totrans-split-300
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x % y` | `x.__mod__(y)` |  |'
- en: '| Arithmetic | `x % y` | `y.__rmod__(x)` |  |'
  id: totrans-split-301
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x % y` | `y.__rmod__(x)` |  |'
- en: '| Arithmetic | `x // y` | `x.__floordiv__(y)` |  |'
  id: totrans-split-302
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x // y` | `x.__floordiv__(y)` |  |'
- en: '| Arithmetic | `x // y` | `y.__rfloordiv__(x)` |  |'
  id: totrans-split-303
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x // y` | `y.__rfloordiv__(x)` |  |'
- en: '| Arithmetic | `x ** y` | `x.__pow__(y)` |  |'
  id: totrans-split-304
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x ** y` | `x.__pow__(y)` |  |'
- en: '| Arithmetic | `x ** y` | `y.__rpow__(x)` |  |'
  id: totrans-split-305
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x ** y` | `y.__rpow__(x)` |  |'
- en: '| Arithmetic | `x @ y` | `x.__matmul__(y)` |  |'
  id: totrans-split-306
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x @ y` | `x.__matmul__(y)` |  |'
- en: '| Arithmetic | `x @ y` | `y.__rmatmul__(x)` |  |'
  id: totrans-split-307
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x @ y` | `y.__rmatmul__(x)` |  |'
- en: '| Arithmetic | `x & y` | `x.__and__(y)` |  |'
  id: totrans-split-308
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x & y` | `x.__and__(y)` |  |'
- en: '| Arithmetic | `x & y` | `y.__rand__(x)` |  |'
  id: totrans-split-309
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x & y` | `y.__rand__(x)` |  |'
- en: '| Arithmetic | `x &#124; y` | `x.__or__(y)` |  |'
  id: totrans-split-310
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x &#124; y` | `x.__or__(y)` |  |'
- en: '| Arithmetic | `x &#124; y` | `y.__ror__(x)` |  |'
  id: totrans-split-311
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x &#124; y` | `y.__ror__(x)` |  |'
- en: '| Arithmetic | `x ^ y` | `x.__xor__(y)` |  |'
  id: totrans-split-312
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x ^ y` | `x.__xor__(y)` |  |'
- en: '| Arithmetic | `x ^ y` | `y.__rxor__(x)` |  |'
  id: totrans-split-313
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x ^ y` | `y.__rxor__(x)` |  |'
- en: '| Arithmetic | `x >> y` | `x.__rshift__(y)` |  |'
  id: totrans-split-314
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x >> y` | `x.__rshift__(y)` |  |'
- en: '| Arithmetic | `x >> y` | `y.__rrshift__(x)` |  |'
  id: totrans-split-315
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x >> y` | `y.__rrshift__(x)` |  |'
- en: '| Arithmetic | `x << y` | `x.__lshift__(y)` |  |'
  id: totrans-split-316
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x << y` | `x.__lshift__(y)` |  |'
- en: '| Arithmetic | `x << y` | `y.__rlshift__(x)` |  |'
  id: totrans-split-317
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `x << y` | `y.__rlshift__(x)` |  |'
- en: '| Arithmetic | `-x` | `x.__neg__()` |  |'
  id: totrans-split-318
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `-x` | `x.__neg__()` |  |'
- en: '| Arithmetic | `+x` | `x.__pos__()` |  |'
  id: totrans-split-319
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `+x` | `x.__pos__()` |  |'
- en: '| Arithmetic | `~x` | `x.__invert__()` |  |'
  id: totrans-split-320
  prefs: []
  type: TYPE_TB
  zh: '| Arithmetic | `~x` | `x.__invert__()` |  |'
- en: '| Math functions | `divmod(x, y)` | `x.__divmod__(y)` | 2-item tuple |'
  id: totrans-split-321
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `divmod(x, y)` | `x.__divmod__(y)` | äºŒå…ƒç»„ |'
- en: '| Math functions | `abs(x)` | `x.__abs__()` | `float` |'
  id: totrans-split-322
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `abs(x)` | `x.__abs__()` | `æµ®ç‚¹æ•°` |'
- en: '| Math functions |  | `x.__index__()` | `int` |'
  id: totrans-split-323
  prefs: []
  type: TYPE_TB
  zh: '| Math functions |  | `x.__index__()` | æ•´æ•° |'
- en: '| Math functions | `round(x)` | `x.__round__()` | Number |'
  id: totrans-split-324
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `round(x)` | `x.__round__()` | æ•°å­— |'
- en: '| Math functions | `math.trunc(x)` | `x.__trunc__()` | Number |'
  id: totrans-split-325
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `math.trunc(x)` | `x.__trunc__()` | æ•°å­— |'
- en: '| Math functions | `math.floor(x)` | `x.__floor__()` | Number |'
  id: totrans-split-326
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `math.floor(x)` | `x.__floor__()` | æ•°å­— |'
- en: '| Math functions | `math.ceil(x)` | `x.__ceil__()` | Number |'
  id: totrans-split-327
  prefs: []
  type: TYPE_TB
  zh: '| Math functions | `math.ceil(x)` | `x.__ceil__()` | æ•°å­— |'
- en: '| Assignment | `x += y` | `x.__iadd__(y)` | Typically `self` |'
  id: totrans-split-328
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x += y` | `x.__iadd__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x -= y` | `x.__isub__(y)` | Typically `self` |'
  id: totrans-split-329
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x -= y` | `x.__isub__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x *= y` | `x.__imul__(y)` | Typically `self` |'
  id: totrans-split-330
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x *= y` | `x.__imul__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x /= y` | `x.__itruediv__(y)` | Typically `self` |'
  id: totrans-split-331
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x /= y` | `x.__itruediv__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x %= y` | `x.__imod__(y)` | Typically `self` |'
  id: totrans-split-332
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x %= y` | `x.__imod__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x //= y` | `x.__ifloordiv__(y)` | Typically `self` |'
  id: totrans-split-333
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x //= y` | `x.__ifloordiv__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x **= y` | `x.__ipow__(y)` | Typically `self` |'
  id: totrans-split-334
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x **= y` | `x.__ipow__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x @= y` | `x.__imatmul__(y)` | Typically `self` |'
  id: totrans-split-335
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x @= y` | `x.__imatmul__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x &= y` | `x.__iand__(y)` | Typically `self` |'
  id: totrans-split-336
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x &= y` | `x.__iand__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x &#124;= y` | `x.__ior__(y)` | Typically `self` |'
  id: totrans-split-337
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x &#124;= y` | `x.__ior__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x ^= y` | `x.__ixor__(y)` | Typically `self` |'
  id: totrans-split-338
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x ^= y` | `x.__ixor__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x >>= y` | `x.__irshift__(y)` | Typically `self` |'
  id: totrans-split-339
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x >>= y` | `x.__irshift__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Assignment | `x <<= y` | `x.__ilshift__(y)` | Typically `self` |'
  id: totrans-split-340
  prefs: []
  type: TYPE_TB
  zh: '| Assignment | `x <<= y` | `x.__ilshift__(y)` | é€šå¸¸ä¸º`self` |'
- en: '| Attributes | `x.y` | `x.__getattribute__(''y'')` |  |'
  id: totrans-split-341
  prefs: []
  type: TYPE_TB
  zh: '| Attributes | `x.y` | `x.__getattribute__(''y'')` |  |'
- en: '| Attributes | `x.y` | `x.__getattr__(''y'')` |  |'
  id: totrans-split-342
  prefs: []
  type: TYPE_TB
  zh: '| Attributes | `x.y` | `x.__getattr__(''y'')` |  |'
- en: '| Attributes | `x.y = z` | `x.__setattr__(''y'', z)` | `None` |'
  id: totrans-split-343
  prefs: []
  type: TYPE_TB
  zh: '| Attributes | `x.y = z` | `x.__setattr__(''y'', z)` | `None` |'
- en: '| Attributes | `del x.y` | `x.__delattr__(''y'')` | `None` |'
  id: totrans-split-344
  prefs: []
  type: TYPE_TB
  zh: '| Attributes | `del x.y` | `x.__delattr__(''y'')` | `None` |'
- en: '| Attributes | `dir(x)` | `x.__dir__()` | An iterable |'
  id: totrans-split-345
  prefs: []
  type: TYPE_TB
  zh: '| Attributes | `dir(x)` | `x.__dir__()` | å¯è¿­ä»£å¯¹è±¡ |'
- en: '| Descriptors | `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None`
    |'
  id: totrans-split-346
  prefs: []
  type: TYPE_TB
  zh: '| Descriptors | `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None`
    |'
- en: '| Descriptors | `t.x` | `T.x.__get__(t, T)` |  |'
  id: totrans-split-347
  prefs: []
  type: TYPE_TB
  zh: '| Descriptors | `t.x` | `T.x.__get__(t, T)` |  |'
- en: '| Descriptors | `t.x = y` | `T.x.__set__(t, y)` | `None` |'
  id: totrans-split-348
  prefs: []
  type: TYPE_TB
  zh: '| Descriptors | `t.x = y` | `T.x.__set__(t, y)` | `None` |'
- en: '| Descriptors | `del t.x` | `T.x.__delete__(t)` | `None` |'
  id: totrans-split-349
  prefs: []
  type: TYPE_TB
  zh: '| æè¿°ç¬¦ | `del t.x` | `T.x.__delete__(t)` | `None` |'
- en: '| Class stuff | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
  id: totrans-split-350
  prefs: []
  type: TYPE_TB
  zh: '| ç±»çš„ç›¸å…³å†…å®¹ | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
- en: '| Class stuff | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
  id: totrans-split-351
  prefs: []
  type: TYPE_TB
  zh: '| ç±»çš„ç›¸å…³å†…å®¹ | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
- en: '| Class stuff | `T[y]` | `T.__class_getitem__(y)` |  |'
  id: totrans-split-352
  prefs: []
  type: TYPE_TB
  zh: '| ç±»çš„ç›¸å…³å†…å®¹ | `T[y]` | `T.__class_getitem__(y)` |  |'
- en: '| Metaclasses | `class T: ...` | `type(base).__prepare__()` | `dict`/mapping
    |'
  id: totrans-split-353
  prefs: []
  type: TYPE_TB
  zh: '| å…ƒç±» | `class T: ...` | `type(base).__prepare__()` | `dict`/æ˜ å°„ |'
- en: '| Metaclasses | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
  id: totrans-split-354
  prefs: []
  type: TYPE_TB
  zh: '| å…ƒç±» | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
- en: '| Metaclasses | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
  id: totrans-split-355
  prefs: []
  type: TYPE_TB
  zh: '| å…ƒç±» | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
- en: '| Async | `await x` (ish) | `x.__await__()` | An iterator |'
  id: totrans-split-356
  prefs: []
  type: TYPE_TB
  zh: '| å¼‚æ­¥ | `await x`ï¼ˆè¿‘ä¼¼ï¼‰ | `x.__await__()` | ä¸€ä¸ªè¿­ä»£å™¨ |'
- en: '| Async | `async with x:` | `x.__aenter__()` | An awaitable |'
  id: totrans-split-357
  prefs: []
  type: TYPE_TB
  zh: '| å¼‚æ­¥ | `async with x:` | `x.__aenter__()` | ä¸€ä¸ªå¯ç­‰å¾…å¯¹è±¡ |'
- en: '| Async | `async with x:` | `x.__aexit__()` | An awaitable |'
  id: totrans-split-358
  prefs: []
  type: TYPE_TB
  zh: '| å¼‚æ­¥ | `async with x:` | `x.__aexit__()` | ä¸€ä¸ªå¯ç­‰å¾…å¯¹è±¡ |'
- en: '| Async | `async for a in x:` | `x.__aiter__()` | An awaitable |'
  id: totrans-split-359
  prefs: []
  type: TYPE_TB
  zh: '| å¼‚æ­¥ | `async for a in x:` | `x.__aiter__()` | ä¸€ä¸ªå¯ç­‰å¾…å¯¹è±¡ |'
- en: '| Async | `async for a in x:` | `x.__anext__()` | An awaitable |'
  id: totrans-split-360
  prefs: []
  type: TYPE_TB
  zh: '| å¼‚æ­¥ | `async for a in x:` | `x.__anext__()` | ä¸€ä¸ªå¯ç­‰å¾…å¯¹è±¡ |'
- en: '| Buffers | `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
  id: totrans-split-361
  prefs: []
  type: TYPE_TB
  zh: '| ç¼“å†²åŒº | `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
- en: '| Buffers | `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
  id: totrans-split-362
  prefs: []
  type: TYPE_TB
  zh: '| ç¼“å†²åŒº | `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
- en: 'The above table has a slight but consistent *untruth*. Most of these dunder
    methods are not *actually* called on an object directly but are instead called
    on the *type* of that object: `type(x).__add__(x, y)` instead of `x.__add__(y)`.
    This distinction mostly matters with metaclass methods.'
  id: totrans-split-363
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°è¡¨æ ¼ç•¥å¾®ä½†æ˜¯ä¸€è‡´åœ°*ä¸çœŸå®*ã€‚ è¿™äº›åŒä¸‹åˆ’çº¿æ–¹æ³•å¤§å¤šæ•°æƒ…å†µä¸‹ä¸æ˜¯ç›´æ¥åœ¨å¯¹è±¡ä¸Šè°ƒç”¨ï¼Œè€Œæ˜¯åœ¨è¯¥å¯¹è±¡çš„*ç±»å‹*ä¸Šè°ƒç”¨ï¼š`type(x).__add__(x,
    y)`è€Œä¸æ˜¯`x.__add__(y)`ã€‚ è¿™ç§åŒºåˆ«åœ¨å…ƒç±»æ–¹æ³•ä¸­éå¸¸é‡è¦ã€‚
- en: I've also purposely excluded library-specific dunder methods (like `__post_init__`)
    and dunder methods you're unlikely to ever define (like `__subclasses__`). See
    those below.
  id: totrans-split-364
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è¿˜ç‰¹æ„æ’é™¤äº†ç‰¹å®šäºåº“çš„åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼ˆå¦‚`__post_init__`ï¼‰å’Œæ‚¨ä¸å¤ªå¯èƒ½å®šä¹‰çš„åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼ˆå¦‚`__subclasses__`ï¼‰ã€‚ è¯·å‚é˜…ä¸‹æ–‡ã€‚
- en: '| Category | Operation | Dunder Method Call | Returns |'
  id: totrans-split-365
  prefs: []
  type: TYPE_TB
  zh: '| åˆ†ç±» | æ“ä½œ | åŒä¸‹åˆ’çº¿æ–¹æ³•è°ƒç”¨ | è¿”å›å€¼ |'
- en: '| --- | --- | --- | --- |'
  id: totrans-split-366
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Dataclasses | `x = T(a, b)` | `T.__post_init__(a, b)` | `None` |'
  id: totrans-split-367
  prefs: []
  type: TYPE_TB
  zh: '| æ•°æ®ç±» | `x = T(a, b)` | `T.__post_init__(a, b)` | `None` |'
- en: '| Copying | `copy.copy(x)` | `x.__copy__()` | New object |'
  id: totrans-split-368
  prefs: []
  type: TYPE_TB
  zh: '| å¤åˆ¶ | `copy.copy(x)` | `x.__copy__()` | æ–°å¯¹è±¡ |'
- en: '| Copying | `copy.deepcopy(x)` | `x.__deepcopy__(memo)` | New object |'
  id: totrans-split-369
  prefs: []
  type: TYPE_TB
  zh: '| å¤åˆ¶ | `copy.deepcopy(x)` | `x.__deepcopy__(memo)` | æ–°å¯¹è±¡ |'
- en: '| [Pickling](https://docs.python.org/3/library/pickle.html#pickling-class-instances)
    | `pickle.dumps(x)` | `x.__getnewargs__()` | A 2-item tuple |'
  id: totrans-split-370
  prefs: []
  type: TYPE_TB
  zh: '| [Pickling](https://docs.python.org/3/library/pickle.html#pickling-class-instances)
    | `pickle.dumps(x)` | `x.__getnewargs__()` | ä¸€ä¸ª2é¡¹å…ƒç»„ |'
- en: '| Pickling | `pickle.dumps(x)` | `x.__getnewargs_ex__()` | A 2-item tuple |'
  id: totrans-split-371
  prefs: []
  type: TYPE_TB
  zh: '| Pickling | `pickle.dumps(x)` | `x.__getnewargs_ex__()` | ä¸€ä¸ª2é¡¹å…ƒç»„ |'
- en: '| Pickling | `pickle.dumps(x)` | `x.__getstate__()` | A meaningful state |'
  id: totrans-split-372
  prefs: []
  type: TYPE_TB
  zh: '| Pickling | `pickle.dumps(x)` | `x.__getstate__()` | ä¸€ä¸ªæœ‰æ„ä¹‰çš„çŠ¶æ€ |'
- en: '| Pickling | `pickle.dumps(x)` | `x.__reduce__()` | A 2-6 item tuple |'
  id: totrans-split-373
  prefs: []
  type: TYPE_TB
  zh: '| Pickling | `pickle.dumps(x)` | `x.__reduce__()` | ä¸€ä¸ª2-6é¡¹å…ƒç»„ |'
- en: '| Pickling | `pickle.dumps(x)` | `x.__reduce_ex__(4)` | A 2-6 item tuple |'
  id: totrans-split-374
  prefs: []
  type: TYPE_TB
  zh: '| Pickling | `pickle.dumps(x)` | `x.__reduce_ex__(4)` | ä¸€ä¸ª2-6é¡¹å…ƒç»„ |'
- en: '| Pickling | `pickle.loads(b)` | `x.__setstate__(state)` | `None` |'
  id: totrans-split-375
  prefs: []
  type: TYPE_TB
  zh: '| Pickling | `pickle.loads(b)` | `x.__setstate__(state)` | `None` |'
- en: '| pathlib | [`os.fspath(x)`](https://docs.python.org/3/library/os.html#os.fspath)
    | `p.__fspath__()` | `str` or `bytes` |'
  id: totrans-split-376
  prefs: []
  type: TYPE_TB
  zh: '| pathlib | [`os.fspath(x)`](https://docs.python.org/3/library/os.html#os.fspath)
    | `p.__fspath__()` | `str`æˆ–`bytes` |'
- en: '| sys | `sys.getsizeof(x)` | `x.__sizeof__()` | `int` (size in bytes) |'
  id: totrans-split-377
  prefs: []
  type: TYPE_TB
  zh: '| sys | `sys.getsizeof(x)` | `x.__sizeof__()` | `int`ï¼ˆå­—èŠ‚å¤§å°ï¼‰ |'
- en: '| Class stuff | None? | `x.__subclasses__()` | Subclasses iterable |'
  id: totrans-split-378
  prefs: []
  type: TYPE_TB
  zh: '| ç±»çš„ç›¸å…³å†…å®¹ | Noneï¼Ÿ | `x.__subclasses__()` | å­ç±»çš„å¯è¿­ä»£å¯¹è±¡ |'
- en: '| ABCs | `issubclass(U, T)` | `T.__subclasshook__(U)` | `bool` |'
  id: totrans-split-379
  prefs: []
  type: TYPE_TB
  zh: '| ABCs | `issubclass(U, T)` | `T.__subclasshook__(U)` | `bool` |'
- en: 'So, Python includes 103 "normal" dunder methods, 12 library-specific dunder
    methods, and at least 52 other dunder attributes of various types. That''s over
    150 unique `__dunder__` names! I **do not recommend** memorizing these: let Python
    do its job and look up the dunder method or attribute that you need to implement/find
    whenever you need it.'
  id: totrans-split-380
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒPythonåŒ…æ‹¬äº†103ä¸ªâ€œæ™®é€šâ€çš„åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼Œ12ä¸ªç‰¹å®šäºåº“çš„åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼Œä»¥åŠè‡³å°‘52ä¸ªå…¶ä»–å„ç§ç±»å‹çš„åŒä¸‹åˆ’çº¿å±æ€§ã€‚ è¿™è¶…è¿‡äº†150ä¸ªç‹¬ç‰¹çš„`__dunder__`åç§°ï¼æˆ‘**ä¸å»ºè®®**è®°å¿†è¿™äº›ï¼šè®©Pythonå®Œæˆå…¶å·¥ä½œï¼Œå¹¶åœ¨éœ€è¦å®ç°/æŸ¥æ‰¾çš„åŒä¸‹åˆ’çº¿æ–¹æ³•æˆ–å±æ€§æ—¶æŸ¥é˜…å®ƒã€‚
- en: Keep in mind that **you're not meant to invent your own dunder methods**. Sometimes
    you'll see third-party libraries that *do* invent their own dunder method, but
    this isn't encouraged and it can be quite confusing for users who run across such
    methods and assume they're "*real*" dunder methods.
  id: totrans-split-381
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½ï¼Œ**ä¸è¦è‡ªå·±å‘æ˜åŒä¸‹åˆ’çº¿æ–¹æ³•**ã€‚æœ‰æ—¶ä½ ä¼šçœ‹åˆ°ä¸€äº›ç¬¬ä¸‰æ–¹åº“ç¡®å®å‘æ˜äº†ä»–ä»¬è‡ªå·±çš„åŒä¸‹åˆ’çº¿æ–¹æ³•ï¼Œä½†è¿™å¹¶ä¸è¢«é¼“åŠ±ï¼Œè€Œä¸”å¯¹é‚£äº›å¶ç„¶é‡åˆ°è¿™äº›æ–¹æ³•å¹¶è®¤ä¸ºå®ƒä»¬æ˜¯â€œ*çœŸæ­£*â€åŒä¸‹åˆ’çº¿æ–¹æ³•çš„ç”¨æˆ·æ¥è¯´ï¼Œå¯èƒ½ä¼šç›¸å½“å›°æƒ‘ã€‚
