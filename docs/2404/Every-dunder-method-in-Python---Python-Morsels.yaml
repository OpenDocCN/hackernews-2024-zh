- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:53:16'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Every dunder method in Python - Python Morsels
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://www.pythonmorsels.com/every-dunder-method/](https://www.pythonmorsels.com/every-dunder-method/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You've just made a class. You made a `__init__` method. Now what?
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Python includes *tons* of [dunder methods](https://www.pythonmorsels.com/what-are-dunder-methods/)
    ("double underscore" methods) which allow us to deeply customize how our custom
    classes interact with Python's many features. What dunder methods could you add
    to your class to make it friendly for other Python programmers who use it?
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at **every dunder method in Python**, with a focus on when
    each method is useful.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Python documentation refers to these as [special methods](https://docs.python.org/3/glossary.html#term-special-method)
    and notes the synonym "magic method" but *very* [rarely](https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers)
    uses the term "dunder method". However, "dunder method" is a fairly common Python
    colloquialism, as noted in my [unofficial Python glossary](https://www.pythonmorsels.com/terms/).
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: You can use the links scattered throughout this page for more details on any
    particular dunder method. For a list of all of them, see the cheat sheet in the
    final section.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: The 3 essential dunder methods üîë
  id: totrans-split-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are 3 dunder methods that *most* classes should have: [`__init__`](https://www.pythonmorsels.com/what-is-init/),
    [`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/),
    and [`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/).'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-13
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-14
  prefs: []
  type: TYPE_TB
- en: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
  id: totrans-split-15
  prefs: []
  type: TYPE_TB
- en: '| `repr(x)` | `x.__repr__()` | `str` |'
  id: totrans-split-16
  prefs: []
  type: TYPE_TB
- en: '| `x == y` | `x.__eq__(y)` | Typically `bool` |'
  id: totrans-split-17
  prefs: []
  type: TYPE_TB
- en: The [`__init__`](https://www.pythonmorsels.com/what-is-init/) method is the
    **initializer** (not to be confused with the [constructor](#construction-and-finalizing)),
    the [`__repr__`](https://www.pythonmorsels.com/customizing-string-representation-your-objects/)
    method customizes an object's string representation, and the [`__eq__`](https://www.pythonmorsels.com/overloading-equality-in-python/)
    method customizes what it means for objects to be *equal* to one another.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: The `__repr__` method is particularly helpful at the [the Python REPL](https://www.pythonmorsels.com/using-the-python-repl/)
    and when debugging.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: Equality and hashability üü∞
  id: totrans-split-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the `__eq__` method, Python has 2 other dunder methods for determining
    the "value" of an object in relation to other objects.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-22
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-23
  prefs: []
  type: TYPE_TB
- en: '| `x == y` | `x.__eq__(y)` | Typically `bool` |'
  id: totrans-split-24
  prefs: []
  type: TYPE_TB
- en: '| `x != y` | `x.__ne__(y)` | Typically `bool` |'
  id: totrans-split-25
  prefs: []
  type: TYPE_TB
- en: '| `hash(x)` | `x.__hash__()` | `int` |'
  id: totrans-split-26
  prefs: []
  type: TYPE_TB
- en: Python's `__eq__` method typically returns `True`, `False`, or [`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/)
    (if objects can't be compared). The default `__eq__` implementation relies on
    the `is` operator, which checks for **[identity](https://www.pythonmorsels.com/equality-vs-identity/)**.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation of `__ne__` calls `__eq__` and negates any boolean
    return value given (or returns `NotImplemented` if `__eq__` did). This default
    behavior is usually "good enough", so **you'll almost never see `__ne__` implemented**.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: Hashable objects can be used as keys in dictionaries or values in sets. All
    objects in Python are [hashable](https://www.pythonmorsels.com/what-are-hashable-objects/)
    by default, but if you've written a custom `__eq__` method then your objects *won't*
    be hashable without a custom `__hash__` method. But **the hash value of an object
    must never change** or [bad things will happen](https://pym.dev/p/2ysgz/) so **typically
    only *immutable* objects implement `__hash__`**.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: For implementing equality checks, see [`__eq__` in Python](https://www.pythonmorsels.com/overloading-equality-in-python/).
    For implementing hashability, see [making hashable objects in Python](https://www.pythonmorsels.com/making-hashable-objects/).
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: Orderability ‚öñÔ∏è
  id: totrans-split-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python's comparison operators (`<`, `>`, `<=`, `>=`) can all be overloaded with
    dunder methods as well. The comparison operators also power functions that rely
    on the relative ordering of objects, like `sorted`, `min`, and `max`.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-33
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-34
  prefs: []
  type: TYPE_TB
- en: '| `<` | `__lt__` | Typically `bool` |'
  id: totrans-split-35
  prefs: []
  type: TYPE_TB
- en: '| `>` | `__gt__` | Typically `bool` |'
  id: totrans-split-36
  prefs: []
  type: TYPE_TB
- en: '| `<=` | `__le__` | Typically `bool` |'
  id: totrans-split-37
  prefs: []
  type: TYPE_TB
- en: '| `>=` | `__ge__` | Typically `bool` |'
  id: totrans-split-38
  prefs: []
  type: TYPE_TB
- en: If you plan to implement all of these operators in the *typical* way (where
    `x < y` would be the same as asking `y > x`) then the [`total_ordering` decorator](https://docs.python.org/3/library/functools.html#functools.total_ordering)
    from Python's `functools` module will come in handy.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions and string formatting ‚öóÔ∏è
  id: totrans-split-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a number of dunder methods for converting objects to a different
    type.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Dunder Method Call | Returns |'
  id: totrans-split-42
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-43
  prefs: []
  type: TYPE_TB
- en: '| `str(x)` | `x.__str__()` | `str` |'
  id: totrans-split-44
  prefs: []
  type: TYPE_TB
- en: '| `bool(x)` | `x.__bool__()` | `bool` |'
  id: totrans-split-45
  prefs: []
  type: TYPE_TB
- en: '| `int(x)` | `x.__int__()` | `int` |'
  id: totrans-split-46
  prefs: []
  type: TYPE_TB
- en: '| `float(x)` | `x.__float__()` | `float` |'
  id: totrans-split-47
  prefs: []
  type: TYPE_TB
- en: '| `bytes(x)` | `x.__bytes__()` | [`bytes`](https://pym.dev/p/2ysgz/) |'
  id: totrans-split-48
  prefs: []
  type: TYPE_TB
- en: '| `complex(x)` | `x.__complex__()` | [`complex`](https://docs.python.org/3/glossary.html#term-complex-number)
    |'
  id: totrans-split-49
  prefs: []
  type: TYPE_TB
- en: '| `f"{x:s}"` | `x.__format__(s)` | `str` |'
  id: totrans-split-50
  prefs: []
  type: TYPE_TB
- en: '| `repr(x)` | `x.__repr__()` | `str` |'
  id: totrans-split-51
  prefs: []
  type: TYPE_TB
- en: The `__bool__` function is used for [truthiness](https://www.pythonmorsels.com/truthiness/)
    checks, though `__len__` is used as a fallback.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: If you needed to make an object that acts like a number (like [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html)
    or [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html)),
    you'll want to implement `__int__`, `__float__`, and `__complex__` so your objects
    can be converted to other numbers. If you wanted to make an object that could
    be used in a `memoryview` or could otherwise be converted to `bytes`, you'll want
    a `__bytes__` method.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: The `__format__` and `__repr__` methods are different string conversion flavors.
    Most string conversions rely the `__str__` method, but the default `__str__` implementation
    simply calls `__repr__`.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: The `__format__` method is used by all [f-string conversions](https://www.pythonmorsels.com/string-formatting/),
    by the `str` class's `format` method, and by the (rarely used) built-in `format`
    function. This method allows `datetime` objects to [support custom format specifiers](https://www.pythonmorsels.com/string-formatting/#formatting-datetime-objects).
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: Context managers üö™
  id: totrans-split-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A context manager is an object that can be used in a `with` block.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: '| Use | Dunder Method Call | Returns |'
  id: totrans-split-58
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-59
  prefs: []
  type: TYPE_TB
- en: '| `with` block enter | `x.__enter__()` | A value given to `as` |'
  id: totrans-split-60
  prefs: []
  type: TYPE_TB
- en: '| `with` block exit | `x.__exit__(exc_type, exc, traceback)` | Truthy/falsey
    value |'
  id: totrans-split-61
  prefs: []
  type: TYPE_TB
- en: For more on context managers see, [what is a context manager](https://www.pythonmorsels.com/what-is-a-context-manager/)
    and [creating a context manager](https://www.pythonmorsels.com/creating-a-context-manager/).
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: Containers and collections üóÉÔ∏è
  id: totrans-split-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Collections (a.k.a. containers) are essentially data structures or objects that
    act like data stuctures. Lists, dictionaries, sets, strings, and tuples are all
    examples of collections.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Return Type | Implemented |'
  id: totrans-split-65
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-split-66
  prefs: []
  type: TYPE_TB
- en: '| `len(x)` | `x.__len__()` | integer | Very common |'
  id: totrans-split-67
  prefs: []
  type: TYPE_TB
- en: '| `iter(x)` | `x.__iter__()` | iterator | Very common |'
  id: totrans-split-68
  prefs: []
  type: TYPE_TB
- en: '| `for item in x: ...` | `x.__iter__()` | iterator | Very common |'
  id: totrans-split-69
  prefs: []
  type: TYPE_TB
- en: '| `x[a]` | `x.__getitem__(a)` | any object | Common |'
  id: totrans-split-70
  prefs: []
  type: TYPE_TB
- en: '| `x[a] = b` | `x.__setitem__(a, b)` | None | Common |'
  id: totrans-split-71
  prefs: []
  type: TYPE_TB
- en: '| `del x[a]` | `x.__delitem__(a)` | None | Common |'
  id: totrans-split-72
  prefs: []
  type: TYPE_TB
- en: '| `a in x` | `x.__contains__(a)` | bool | Common |'
  id: totrans-split-73
  prefs: []
  type: TYPE_TB
- en: '| `reversed(x)` | `x.__reversed__()` | iterator | Common |'
  id: totrans-split-74
  prefs: []
  type: TYPE_TB
- en: '| `next(x)` | `x.__next__()` | any object | Uncommon |'
  id: totrans-split-75
  prefs: []
  type: TYPE_TB
- en: '| `x[a]` | `x.__missing__(a)` | any object | Uncommon |'
  id: totrans-split-76
  prefs: []
  type: TYPE_TB
- en: '| `operator.length_hint(x)` | `x.__length_hint__()` | integer | Uncommon |'
  id: totrans-split-77
  prefs: []
  type: TYPE_TB
- en: 'The `__iter__` method is used by the `iter` function *and* for all forms of
    iteration: [`for` loops](https://www.pythonmorsels.com/writing-a-for-loop/), [comprehensions](https://www.pythonmorsels.com/what-are-list-comprehensions/),
    [tuple unpacking](https://www.pythonmorsels.com/tuple-unpacking/), and [using
    `*` for iterable unpacking](https://www.pythonmorsels.com/unpacking-iterables-iterables/).'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: While the `__iter__` method is necessary for creating a custom iterable, the
    `__next__` method is necessary for creating a custom iterator (which is much less
    common). The `__missing__` method is only ever called by the `dict` class on itself,
    unless another class decides to implement `__missing__`. The `__length_hint__`
    method supplies a length guess for structures which do not support `__len__` so
    that lists or other structures can be pre-sized more efficiently.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Also see: [the iterator protocol](https://www.pythonmorsels.com/iterator-protocol/),
    [implementing `__len__`](https://www.pythonmorsels.com/making-the-len-function-work-on-your-python-objects/),
    and [implementing `__getitem__`](https://www.pythonmorsels.com/supporting-index-and-key-lookups/).'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: Callability ‚òéÔ∏è
  id: totrans-split-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions, classes, and all other [callable objects](https://www.pythonmorsels.com/callables/)
    rely on the `__call__` method.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Return Type |'
  id: totrans-split-83
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-84
  prefs: []
  type: TYPE_TB
- en: '| `x(a, b=c)` | `x.__call__(a, b=c)` | any object |'
  id: totrans-split-85
  prefs: []
  type: TYPE_TB
- en: When a class is called, its [metaclass](https://docs.python.org/3/glossary.html#term-metaclass)'s
    `__call__` method is used. When a class *instance* is called, the class's `__call__`
    method is used.
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on callability, see [Callables: Python''s "functions" are sometimes
    classes](https://www.pythonmorsels.com/class-function-and-callable/).'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators ‚ûó
  id: totrans-split-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python's dunder methods are often described as a tool for "operator overloading".
    Most of this "operator overloading" comes in the form of Python's various arithmetic
    operators.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to break down the arithmetic operators:'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical (e.g. `+`, `-`, `*`, `/`, `%`) versus bitwise (e.g. `&`, `|`, `^`,
    `>>`, `~`)
  id: totrans-split-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary (between 2 values, like `x + y`) versus unary (before 1 value, like `+x`)
  id: totrans-split-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mathematical operators are much more common than the bitwise ones and the
    binary ones are a bit more common than the unary ones.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the binary mathematical arithmetic operators:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Left-Hand Method | Right-Hand Method | Description |'
  id: totrans-split-95
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-split-96
  prefs: []
  type: TYPE_TB
- en: '| `x + y` | `__add__` | `__radd__` | Add / Concatenate |'
  id: totrans-split-97
  prefs: []
  type: TYPE_TB
- en: '| `x - y` | `__sub__` | `__rsub__` | Subtract |'
  id: totrans-split-98
  prefs: []
  type: TYPE_TB
- en: '| `x * y` | `__mul__` | `__rmul__` | Multiply |'
  id: totrans-split-99
  prefs: []
  type: TYPE_TB
- en: '| `x / y` | `__truediv__` | `__rtruediv__` | Divide |'
  id: totrans-split-100
  prefs: []
  type: TYPE_TB
- en: '| `%` | `__mod__` | `__rmod__` | Modulo |'
  id: totrans-split-101
  prefs: []
  type: TYPE_TB
- en: '| `x // y` | `__floordiv__` | `__rfloordiv__` | [Integer division](https://www.pythonmorsels.com/integer-division/)
    |'
  id: totrans-split-102
  prefs: []
  type: TYPE_TB
- en: '| `**` | `__pow__` | `__rpow__` | Exponentiate |'
  id: totrans-split-103
  prefs: []
  type: TYPE_TB
- en: '| `x @ y` | `__matmul__` | `__rmatmul__` | Matrix multiply |'
  id: totrans-split-104
  prefs: []
  type: TYPE_TB
- en: Each of these operators includes left-hand and right-hand methods. If `x.__add__(y)`
    returns [`NotImplemented`](https://www.pythonmorsels.com/when-to-use-notimplemented/),
    then `y.__radd__(x)` will be attempted. See [arithmetic dunder methods](https://www.pythonmorsels.com/arithmetic-dunder-methods/)
    for more.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the binary bitwise arithmetic operators:'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Left-Hand Method | Right-Hand Method | Description |'
  id: totrans-split-107
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-split-108
  prefs: []
  type: TYPE_TB
- en: '| `x & y` | `__and__` | `__rand__` | AND |'
  id: totrans-split-109
  prefs: []
  type: TYPE_TB
- en: '| `x &#124; y` | `__or__` | `__ror__` | OR |'
  id: totrans-split-110
  prefs: []
  type: TYPE_TB
- en: '| `x ^ y` | `__xor__` | `__rxor__` | XOR |'
  id: totrans-split-111
  prefs: []
  type: TYPE_TB
- en: '| `x >> y` | `__rshift__` | `__rrshift__` | Right-shift |'
  id: totrans-split-112
  prefs: []
  type: TYPE_TB
- en: '| `x << y` | `__lshift__` | `__rlshift__` | Left-shift |'
  id: totrans-split-113
  prefs: []
  type: TYPE_TB
- en: 'These are Python''s unary arithmetic operators:'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method | Variety | Description |'
  id: totrans-split-115
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-split-116
  prefs: []
  type: TYPE_TB
- en: '| `-x` | `__neg__` | Mathematical | Negate |'
  id: totrans-split-117
  prefs: []
  type: TYPE_TB
- en: '| `+x` | `__pos__` | Bitwise | Affirm |'
  id: totrans-split-118
  prefs: []
  type: TYPE_TB
- en: '| `~x` | `__invert__` | Bitwise | Invert |'
  id: totrans-split-119
  prefs: []
  type: TYPE_TB
- en: The unary `+` operator typically [has no effect](https://stackoverflow.com/questions/16819023/whats-the-purpose-of-the-pos-unary-operator-in-python),
    though some objects use it for a specific operation. For example [using `+` on
    `collections.Counter` objects](https://www.pythonmorsels.com/using-counter/#removing-negative-counts)
    will remove non-positive values.
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s arithmetic operators are often used for non-arithmetic ends: [sequences](https://www.pythonmorsels.com/sequence/)
    use `+` to concatenate and `*` to self-concatenate and [sets](https://www.pythonmorsels.com/practical-uses-of-sets/)
    use `&` for intersection, `|` for union, `-` for asymmetric difference, and `^`
    for symmetric difference. Arithmetic operators are sometimes overloaded for more
    creative uses too. For example, `pathlib.Path` objects [use `/` to create child
    paths](https://docs.python.org/3/library/pathlib.html#operators).'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
- en: In-place arithmetic operations ‚ôªÔ∏è
  id: totrans-split-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python includes many dunder methods for **in-place** operations. If you're making
    a [mutable](https://www.pythonmorsels.com/terms/#mutable) object that supports
    any of the arithmetic operations, you'll want to implement the related in-place
    dunder method(s) as well.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-124
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-125
  prefs: []
  type: TYPE_TB
- en: '| `x += y` | `x.__iadd__(y)` | Typically `self` |'
  id: totrans-split-126
  prefs: []
  type: TYPE_TB
- en: '| `x -= y` | `x.__isub__(y)` | Typically `self` |'
  id: totrans-split-127
  prefs: []
  type: TYPE_TB
- en: '| `x *= y` | `x.__imul__(y)` | Typically `self` |'
  id: totrans-split-128
  prefs: []
  type: TYPE_TB
- en: '| `x /= y` | `x.__itruediv__(y)` | Typically `self` |'
  id: totrans-split-129
  prefs: []
  type: TYPE_TB
- en: '| `x %= y` | `x.__imod__(y)` | Typically `self` |'
  id: totrans-split-130
  prefs: []
  type: TYPE_TB
- en: '| `x //= y` | `x.__ifloordiv__(y)` | Typically `self` |'
  id: totrans-split-131
  prefs: []
  type: TYPE_TB
- en: '| `x **= y` | `x.__ipow__(y)` | Typically `self` |'
  id: totrans-split-132
  prefs: []
  type: TYPE_TB
- en: '| `x @= y` | `x.__imatmul__(y)` | Typically `self` |'
  id: totrans-split-133
  prefs: []
  type: TYPE_TB
- en: '| `x &= y` | `x.__iand__(y)` | Typically `self` |'
  id: totrans-split-134
  prefs: []
  type: TYPE_TB
- en: '| `x &#124;= y` | `x.__ior__(y)` | Typically `self` |'
  id: totrans-split-135
  prefs: []
  type: TYPE_TB
- en: '| `x ^= y` | `x.__ixor__(y)` | Typically `self` |'
  id: totrans-split-136
  prefs: []
  type: TYPE_TB
- en: '| `x >>= y` | `x.__irshift__(y)` | Typically `self` |'
  id: totrans-split-137
  prefs: []
  type: TYPE_TB
- en: '| `x <<= y` | `x.__ilshift__(y)` | Typically `self` |'
  id: totrans-split-138
  prefs: []
  type: TYPE_TB
- en: All of Python's binary arithmetic operators work in **augmented assignment statements**,
    which involve using an operator followed by the `=` sign to assign to an object
    while performing an operation on it.
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
- en: Augmented assignments on **mutable objects** are [expected to mutate the original
    object](https://www.pythonmorsels.com/augmented-assignments-mutate/), thanks to
    the mutable object implementing the appropriate dunder method for in-place arithmetic.
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
- en: When no dunder method is found for an in-place operation, Python performs the
    operation followed by an assignment. **Immutable objects typically do *not* implement
    dunder methods for in-place operations**, since they should return a new object
    instead of changing the original.
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
- en: Built-in math functions üßÆ
  id: totrans-split-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python also includes dunder methods for many math-related functions, both [built-in
    functions](https://www.pythonmorsels.com/built-in-functions-in-python/#type) and
    some functions in the `math` library.
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-144
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-145
  prefs: []
  type: TYPE_TB
- en: '| `divmod(x, y)` | `x.__divmod__(y)` | 2-item tuple |'
  id: totrans-split-146
  prefs: []
  type: TYPE_TB
- en: '| `divmod(x, y)` | `y.__rdivmod__(x)` | 2-item tuple |'
  id: totrans-split-147
  prefs: []
  type: TYPE_TB
- en: '| `abs(x)` | `x.__abs__()` | `float` |'
  id: totrans-split-148
  prefs: []
  type: TYPE_TB
- en: '| `sequence[x]` | `x.__index__()` | `int` |'
  id: totrans-split-149
  prefs: []
  type: TYPE_TB
- en: '| `round(x)` | `x.__round__()` | Number |'
  id: totrans-split-150
  prefs: []
  type: TYPE_TB
- en: '| `math.trunc(x)` | `x.__trunc__()` | Number |'
  id: totrans-split-151
  prefs: []
  type: TYPE_TB
- en: '| `math.floor(x)` | `x.__floor__()` | Number |'
  id: totrans-split-152
  prefs: []
  type: TYPE_TB
- en: '| `math.ceil(x)` | `x.__ceil__()` | Number |'
  id: totrans-split-153
  prefs: []
  type: TYPE_TB
- en: Python's `divmod` function performs [integer division](https://www.pythonmorsels.com/integer-division/)
    (`//`) and a modulo operation (`%`) at the same time. Note that, just like the
    many binary arithmetic operators, `divmod` will also check for an `__rvidmod__`
    method if it needs to ask the *second* argument to handle the operation.
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
- en: The `__index__` method is for making integer-like objects. This method losslessly
    converts to an integer, unlike `__int__` which may perform a "lossy" integer conversion
    (e.g. from `float` to `int`). It's used by operations that require *true* integers,
    such as [slicing](https://www.pythonmorsels.com/slicing/), indexing, and `bin`,
    `hex`, and `oct` functions ([example](https://pym.dev/p/2k9zt/)).
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
- en: Attribute access üìú
  id: totrans-split-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python even includes dunder methods for controlling what happens when you access,
    delete, or assign any attribute on an object!
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-158
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-159
  prefs: []
  type: TYPE_TB
- en: '| `x.missing` | `x.__getattr__("missing")` | Attribute value |'
  id: totrans-split-160
  prefs: []
  type: TYPE_TB
- en: '| `x.anything` | `x.__getattribute__("anything")` | Attribute value |'
  id: totrans-split-161
  prefs: []
  type: TYPE_TB
- en: '| `x.thing = value` | `x.__setattr__("thing", value)` | `None` |'
  id: totrans-split-162
  prefs: []
  type: TYPE_TB
- en: '| `del x.thing` | `x.__delattr__("thing")` | `None` |'
  id: totrans-split-163
  prefs: []
  type: TYPE_TB
- en: '| `dir(x)` | `x.__dir__()` | List of strings |'
  id: totrans-split-164
  prefs: []
  type: TYPE_TB
- en: The `__getattribute__` method is called for *every* attribute access, while
    the `__getattr__` method is only called after Python *fails* to find a given attribute.
    All method calls and attribute accesses call `__getattribute__` so implementing
    it correctly is challenging (due to accidental [recursion](https://www.pythonmorsels.com/what-is-recursion/)).
    See [`__getattr__` versus `__getattribute__`](https://www.pythonmorsels.com/getattr-vs-getattribute/)
    for examples demonstrating the difference between these two methods.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
- en: The `__dir__` method should return an iterable of attribute names (as strings).
    When [the `dir` function](https://www.pythonmorsels.com/built-in-functions-in-python/#dir)
    calls `__dir__`, it converts the returned iterable into a sorted list (like [`sorted`](https://www.pythonmorsels.com/sorting-in-python/)
    does).
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `getattr`, [`setattr`](https://www.pythonmorsels.com/python-setattr/),
    and `delattr` functions correspond to the dunder methods of the same name, but
    they're only intended for dynamic attribute access (not *all* attribute accesses).
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
- en: Now we're getting into the really unusual dunder methods. Python includes many
    dunder methods for metaprogramming-related features.
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
- en: '| Implemented on | Operation | Dunder Method Call | Returns |'
  id: totrans-split-169
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-split-170
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `class T: ...` | `type(base).__prepare__()` | mapping |'
  id: totrans-split-171
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
  id: totrans-split-172
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
  id: totrans-split-173
  prefs: []
  type: TYPE_TB
- en: '| Any class | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
  id: totrans-split-174
  prefs: []
  type: TYPE_TB
- en: '| Any class | (Called manually) | `T.__subclasses__()` | `list` |'
  id: totrans-split-175
  prefs: []
  type: TYPE_TB
- en: '| Any class | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
  id: totrans-split-176
  prefs: []
  type: TYPE_TB
- en: '| Any class | `T[y]` | `T.__class_getitem__(y)` | an item |'
  id: totrans-split-177
  prefs: []
  type: TYPE_TB
- en: The `__prepare__` method customizes the dictionary that's used for a class's
    initial namespace. This is used to pre-populate dictionary values or customize
    the dictionary type ([silly example](https://pym.dev/p/23wfv/)).
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
- en: The `__instancecheck__` and `__subclasscheck__` methods override the functionality
    of `isinstance` and `issubclass`. Python's ABCs use these to practice [goose typing](https://www.pythonmorsels.com/goose-typing/)
    ([duck typing](https://www.pythonmorsels.com/duck-typing/) *while* type checking).
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
- en: The `__init_subclass__` method allows classes to hook into subclass initialization
    ([example](https://pym.dev/p/246z6/)). Classes *also* have a `__subclasses__`
    method (on their [metaclass](https://docs.python.org/3/glossary.html#term-metaclass))
    but it's not typically overridden.
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
- en: Python calls `__mro_entries__` during [class inheritance](https://www.pythonmorsels.com/inheriting-one-class-another/)
    for any base classes that are not *actually* classes. The [`typing.NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple)
    function uses this to pretend it's a class ([see here](https://pym.dev/p/2qgzd/)).
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
- en: The `__class_getitem__` method allows a class to be subscriptable (*without*
    its metaclass needing a `__getitem__` method). This is typically used for enabling
    fancy type annotations (e.g. `list[int]`).
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
- en: Descriptors üè∑Ô∏è
  id: totrans-split-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Descriptors](https://docs.python.org/3/glossary.html#term-descriptor) are
    objects that, when attached to a class, can hook into the access of the attribute
    name they''re attached to on that class.'
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-185
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-186
  prefs: []
  type: TYPE_TB
- en: '| `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None` |'
  id: totrans-split-187
  prefs: []
  type: TYPE_TB
- en: '| `t.x` | `T.x.__get__(t, T)` | The value |'
  id: totrans-split-188
  prefs: []
  type: TYPE_TB
- en: '| `t.x = y` | `T.x.__set__(t, y)` | `None` |'
  id: totrans-split-189
  prefs: []
  type: TYPE_TB
- en: '| `del t.x` | `T.x.__delete__(t)` | `None` |'
  id: totrans-split-190
  prefs: []
  type: TYPE_TB
- en: The descriptor protocol is *mostly* a feature that exists to make Python's `property`
    decorator work, though it is also used by a number of third-party libraries.
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
- en: Buffers üíæ
  id: totrans-split-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing a low-level memory array? You need Python's [buffer protocol](https://docs.python.org/3/reference/datamodel.html#emulating-buffer-types).
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-194
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-195
  prefs: []
  type: TYPE_TB
- en: '| `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
  id: totrans-split-196
  prefs: []
  type: TYPE_TB
- en: '| `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
  id: totrans-split-197
  prefs: []
  type: TYPE_TB
- en: The `__release_buffer__` method is called when the buffer that's returned from
    `__buffer__` is deleted.
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
- en: Python's buffer protocol is typically implemented in C, since it's meant for
    low level objects.
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous operations ü§π
  id: totrans-split-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Want to implement an asynchronous context manager? You need these dunder methods:'
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
- en: '`__aenter__`: just like `__enter__`, but it returns an awaitable object'
  id: totrans-split-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__aexit__`: just like `__exit__`, but it returns an awaitable object'
  id: totrans-split-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Need to support asynchronous iteration? You need these dunder methods:'
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
- en: '`__aiter__`: must return an asynchronous iterator'
  id: totrans-split-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__anext__`: like `__next__` or non-async iterators, but this must return an
    awaitable object and this should raise `StopAsyncIteration` instead of `StopIteration`'
  id: totrans-split-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Need to make your own awaitable object? You need this dunder method:'
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
- en: '`__await__`: returns an iterator'
  id: totrans-split-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have little experience with custom asynchronous objects, so look elsewhere
    for more details.
  id: totrans-split-209
  prefs: []
  type: TYPE_NORMAL
- en: Construction and finalizing üè≠
  id: totrans-split-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last few dunder methods are related to object creation and destruction.
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Dunder Method Call | Returns |'
  id: totrans-split-212
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-213
  prefs: []
  type: TYPE_TB
- en: '| `T(a, b=3)` | `T.__new__(T, a, b=3)` | New instance (`x`) |'
  id: totrans-split-214
  prefs: []
  type: TYPE_TB
- en: '| `T(a, b=3)` | `T.__init__(x, a, b=3)` | `None` |'
  id: totrans-split-215
  prefs: []
  type: TYPE_TB
- en: '| `del x` | `x.__del__()` | `None` |'
  id: totrans-split-216
  prefs: []
  type: TYPE_TB
- en: Calling a class returns a new class instance thanks to the `__new__` method.
    The `__new__` method is Python's **constructor method**, though unlike constructors
    in many programming languages, you should almost *never* define your own `__new__`
    method. To control object creation, prefer the initializer (`__init__`), not the
    constructor (`__new__`). [Here's an odd `__new__` example](https://pym.dev/p/28r9m/).
  id: totrans-split-217
  prefs: []
  type: TYPE_NORMAL
- en: You could think of `__del__` as a "destructor" method, though it's actually
    called the **finalizer method**. Just before an object is deleted, its `__del__`
    method is called ([example](https://pym.dev/p/2hexg/)). Files implement a `__del__`
    method that closes the file and any binary file buffer that it may be linked to.
  id: totrans-split-218
  prefs: []
  type: TYPE_NORMAL
- en: Library-specific dunder methods üß∞
  id: totrans-split-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some standard library modules define custom dunder methods that aren''t used
    anywhere else:'
  id: totrans-split-220
  prefs: []
  type: TYPE_NORMAL
- en: '[dataclasses](https://www.pythonmorsels.com/dataclasses/) support a `__post_init__`
    method'
  id: totrans-split-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.ABC` classes have a `__subclasshook__` method which `abc.ABCMeta` calls
    in its `__subclasscheck__` method (more in [goose typing](https://www.pythonmorsels.com/goose-typing/))'
  id: totrans-split-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path-like objects have a `__fspath__` method, which returns the file path as
    a string
  id: totrans-split-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python's `copy` module will use the `__copy__` and `__deepcopy__` methods if
    present
  id: totrans-split-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pickling relies on `__getnewargs_ex__` or `__getargs__`, though `__getstate__`
    and `__setstate__` can customize further and `__reduce__` or `__reduce_ex__` are
    even lower-level
  id: totrans-split-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys.getsizeof` relies on the `__sizeof__` method to get an object''s size
    (in bytes)'
  id: totrans-split-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dunder attributes üìá
  id: totrans-split-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to dunder methods, Python has many non-method **dunder attributes**.
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the more common dunder attributes you''ll see:'
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
- en: '`__name__`: name of a function, classes, or module'
  id: totrans-split-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__module__`: module name for a function or class'
  id: totrans-split-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__doc__`: [docstring](https://www.pythonmorsels.com/docstrings/) for a function,
    class, or module'
  id: totrans-split-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__class__`: an object''s class (call [Python''s `type` function](https://www.pythonmorsels.com/built-in-functions-in-python/#type)
    instead)'
  id: totrans-split-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__dict__`: most objects store their attributes here (see [where are attributes
    stored?](https://www.pythonmorsels.com/where-are-attributes-stored/))'
  id: totrans-split-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__slots__`: classes using this are more memory efficient than classes using
    `__dict__`'
  id: totrans-split-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__match_args__`: classes can define a tuple noting the significance of positional
    attributes when the class is used in structural pattern matching (`match`-`case`)'
  id: totrans-split-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__mro__`: a class''s method resolution order used when for attribute lookups
    and `super()` calls'
  id: totrans-split-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__bases__`: the direct parent classes of a class'
  id: totrans-split-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__file__`: the file that defined the module object (though not always present!)'
  id: totrans-split-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__wrapped__`: functions decorated with [`functools.wraps`](https://docs.python.org/3/library/functools.html#functools.wraps)
    use this to point to the original function'
  id: totrans-split-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__version__`: commonly used for noting the version of a package'
  id: totrans-split-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__all__`: modules can use this to customize the behavior of `from my_module
    import *`'
  id: totrans-split-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__debug__`: running Python with `-O` sets this to `False` and disables Python''s
    `assert` statements'
  id: totrans-split-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those are only the more commonly seen dunder attributes. Here are some more:'
  id: totrans-split-244
  prefs: []
  type: TYPE_NORMAL
- en: Functions have `__defaults__`, `__kwdefaults__`, `__code__`, `__globals__`,
    and `__closure__`
  id: totrans-split-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both functions and classes have `__qualname__`, `__annotations__`, and `__type_params__`
  id: totrans-split-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance methods have `__func__` and `__self__`
  id: totrans-split-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules may also have `__loader__`, `__package__`, `__spec__`, and `__cached__`
    attributes
  id: totrans-split-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages have a `__path__` attribute
  id: totrans-split-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions have `__traceback__`, `__notes__`, `__context__`, `__cause__`, and
    `__suppress_context__`
  id: totrans-split-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Descriptors use `__objclass__`
  id: totrans-split-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclasses use `__classcell__`
  id: totrans-split-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python's `weakref` module uses `__weakref__`
  id: totrans-split-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Generic aliases](https://docs.python.org/3/library/stdtypes.html#type-annotation-types-generic-alias-union)
    have `__origin__`, `__args__`, `__parameters__`, and `__unpacked__`'
  id: totrans-split-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sys` module has `__stdout__` and `__stderr__` which point to the original
    `stdout` and `stderr` versions
  id: totrans-split-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, these dunder attributes are used by various standard library
    modules: `__covariant__`, `__contravariant__`, `__infer_variance__`, `__bound__`,
    `__constraints__`. And Python includes a built-in `__import__` function which
    you''re not supposed to use (`importlib.import_module` is preferred) and CPython
    has a `__builtins__` variable that points to the `builtins` module (but this is
    an implementation detail and `builtins` should be explicitly imported when needed
    instead). Also importing from the `__future__` module can enable specific Python
    feature flags and Python will look for a `__main__` module within packages to
    make them runnable as CLI scripts.'
  id: totrans-split-256
  prefs: []
  type: TYPE_NORMAL
- en: And that's just *most* of the dunder attribute names you'll find floating around
    in Python. üòµ
  id: totrans-split-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Every dunder method: a cheat sheet ‚≠ê'
  id: totrans-split-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is every Python dunder method organized in categories and ordered very
    roughly by the **most commonly seen** methods first. Some caveats are noted below.
  id: totrans-split-259
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Operation | Dunder Method Call | Returns |'
  id: totrans-split-260
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-split-261
  prefs: []
  type: TYPE_TB
- en: '| Object Creation | `x = T(a, b)` | `x.__init__(a, b)` | `None` |'
  id: totrans-split-262
  prefs: []
  type: TYPE_TB
- en: '| Object Creation | `x = T(a, b)` | `T.__new__(T, a, b)` | New instance (`x`)
    |'
  id: totrans-split-263
  prefs: []
  type: TYPE_TB
- en: '| Finalizer | `del x` (ish) | `x.__del__()` | `None` |'
  id: totrans-split-264
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x == y` | `x.__eq__(y)` | Typically `bool` |'
  id: totrans-split-265
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x != y` | `x.__ne__(y)` | Typically `bool` |'
  id: totrans-split-266
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x < y` | `x.__lt__(y)` | Typically `bool` |'
  id: totrans-split-267
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x > y` | `x.__rt__(y)` | Typically `bool` |'
  id: totrans-split-268
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x <= y` | `x.__le__(y)` | Typically `bool` |'
  id: totrans-split-269
  prefs: []
  type: TYPE_TB
- en: '| Comparisons | `x >= y` | `x.__ge__(y)` | Typically `bool` |'
  id: totrans-split-270
  prefs: []
  type: TYPE_TB
- en: '| Hashability | `hash(x)` | `x.__hash__()` | `int` |'
  id: totrans-split-271
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `repr(x)` | `x.__repr__()` | Always `str` |'
  id: totrans-split-272
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `str(x)` | `x.__str__()` | Always `str` |'
  id: totrans-split-273
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `bool(x)` | `x.__bool__()` | Always `bool` |'
  id: totrans-split-274
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `int(x)` | `x.__int__()` | Always `int` |'
  id: totrans-split-275
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `float(x)` | `x.__float__()` | Always `float` |'
  id: totrans-split-276
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `bytes(x)` | `x.__bytes__()` | Always `bytes` |'
  id: totrans-split-277
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `complex(x)` | `x.__complex__()` | Always `complex` |'
  id: totrans-split-278
  prefs: []
  type: TYPE_TB
- en: '| Conversions | `format(x, s)` | `x.__format__(s)` | Always `str` |'
  id: totrans-split-279
  prefs: []
  type: TYPE_TB
- en: '| Context Managers | `with x as c:` | `x.__enter__()` | The `c` object |'
  id: totrans-split-280
  prefs: []
  type: TYPE_TB
- en: '| Context Managers | `with x as c:` | `x.__exit__()` | Truthy/falsey value
    |'
  id: totrans-split-281
  prefs: []
  type: TYPE_TB
- en: '| Collections | `len(x)` | `x.__len__()` | `int` |'
  id: totrans-split-282
  prefs: []
  type: TYPE_TB
- en: '| Collections | `iter(x)` | `x.__iter__()` | An iterator |'
  id: totrans-split-283
  prefs: []
  type: TYPE_TB
- en: '| Collections | `x[a]` | `x.__getitem__(a)` |  |'
  id: totrans-split-284
  prefs: []
  type: TYPE_TB
- en: '| Collections | `x[a] = b` | `x.__setitem__(a, b)` | `None` |'
  id: totrans-split-285
  prefs: []
  type: TYPE_TB
- en: '| Collections | `del x[a]` | `x.__delitem__(a)` | `None` |'
  id: totrans-split-286
  prefs: []
  type: TYPE_TB
- en: '| Collections | `a in x` | `x.__contains__(a)` | `bool` |'
  id: totrans-split-287
  prefs: []
  type: TYPE_TB
- en: '| Collections | `reversed(x)` | `x.__reversed__()` | An iterator |'
  id: totrans-split-288
  prefs: []
  type: TYPE_TB
- en: '| Collections | `next(x)` | `x.__next__()` | Next iterator item |'
  id: totrans-split-289
  prefs: []
  type: TYPE_TB
- en: '| Collections | `x[a]` | `x.__missing__(a)` |  |'
  id: totrans-split-290
  prefs: []
  type: TYPE_TB
- en: '| Collections |  | `x.__length_hint__()` | `int` |'
  id: totrans-split-291
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x + y` | `x.__add__(y)` |  |'
  id: totrans-split-292
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x + y` | `y.__radd__(x)` |  |'
  id: totrans-split-293
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x - y` | `x.__sub__(y)` |  |'
  id: totrans-split-294
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x - y` | `y.__rsub__(x)` |  |'
  id: totrans-split-295
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x * y` | `x.__mul__(y)` |  |'
  id: totrans-split-296
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x * y` | `y.__rmul__(x)` |  |'
  id: totrans-split-297
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x / y` | `x.__truediv__(y)` |  |'
  id: totrans-split-298
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x / y` | `y.__rtruediv__(x)` |  |'
  id: totrans-split-299
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x % y` | `x.__mod__(y)` |  |'
  id: totrans-split-300
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x % y` | `y.__rmod__(x)` |  |'
  id: totrans-split-301
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x // y` | `x.__floordiv__(y)` |  |'
  id: totrans-split-302
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x // y` | `y.__rfloordiv__(x)` |  |'
  id: totrans-split-303
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x ** y` | `x.__pow__(y)` |  |'
  id: totrans-split-304
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x ** y` | `y.__rpow__(x)` |  |'
  id: totrans-split-305
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x @ y` | `x.__matmul__(y)` |  |'
  id: totrans-split-306
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x @ y` | `y.__rmatmul__(x)` |  |'
  id: totrans-split-307
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x & y` | `x.__and__(y)` |  |'
  id: totrans-split-308
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x & y` | `y.__rand__(x)` |  |'
  id: totrans-split-309
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x &#124; y` | `x.__or__(y)` |  |'
  id: totrans-split-310
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x &#124; y` | `y.__ror__(x)` |  |'
  id: totrans-split-311
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x ^ y` | `x.__xor__(y)` |  |'
  id: totrans-split-312
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x ^ y` | `y.__rxor__(x)` |  |'
  id: totrans-split-313
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x >> y` | `x.__rshift__(y)` |  |'
  id: totrans-split-314
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x >> y` | `y.__rrshift__(x)` |  |'
  id: totrans-split-315
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x << y` | `x.__lshift__(y)` |  |'
  id: totrans-split-316
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `x << y` | `y.__rlshift__(x)` |  |'
  id: totrans-split-317
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `-x` | `x.__neg__()` |  |'
  id: totrans-split-318
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `+x` | `x.__pos__()` |  |'
  id: totrans-split-319
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `~x` | `x.__invert__()` |  |'
  id: totrans-split-320
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `divmod(x, y)` | `x.__divmod__(y)` | 2-item tuple |'
  id: totrans-split-321
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `abs(x)` | `x.__abs__()` | `float` |'
  id: totrans-split-322
  prefs: []
  type: TYPE_TB
- en: '| Math functions |  | `x.__index__()` | `int` |'
  id: totrans-split-323
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `round(x)` | `x.__round__()` | Number |'
  id: totrans-split-324
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `math.trunc(x)` | `x.__trunc__()` | Number |'
  id: totrans-split-325
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `math.floor(x)` | `x.__floor__()` | Number |'
  id: totrans-split-326
  prefs: []
  type: TYPE_TB
- en: '| Math functions | `math.ceil(x)` | `x.__ceil__()` | Number |'
  id: totrans-split-327
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x += y` | `x.__iadd__(y)` | Typically `self` |'
  id: totrans-split-328
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x -= y` | `x.__isub__(y)` | Typically `self` |'
  id: totrans-split-329
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x *= y` | `x.__imul__(y)` | Typically `self` |'
  id: totrans-split-330
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x /= y` | `x.__itruediv__(y)` | Typically `self` |'
  id: totrans-split-331
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x %= y` | `x.__imod__(y)` | Typically `self` |'
  id: totrans-split-332
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x //= y` | `x.__ifloordiv__(y)` | Typically `self` |'
  id: totrans-split-333
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x **= y` | `x.__ipow__(y)` | Typically `self` |'
  id: totrans-split-334
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x @= y` | `x.__imatmul__(y)` | Typically `self` |'
  id: totrans-split-335
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x &= y` | `x.__iand__(y)` | Typically `self` |'
  id: totrans-split-336
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x &#124;= y` | `x.__ior__(y)` | Typically `self` |'
  id: totrans-split-337
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x ^= y` | `x.__ixor__(y)` | Typically `self` |'
  id: totrans-split-338
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x >>= y` | `x.__irshift__(y)` | Typically `self` |'
  id: totrans-split-339
  prefs: []
  type: TYPE_TB
- en: '| Assignment | `x <<= y` | `x.__ilshift__(y)` | Typically `self` |'
  id: totrans-split-340
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `x.y` | `x.__getattribute__(''y'')` |  |'
  id: totrans-split-341
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `x.y` | `x.__getattr__(''y'')` |  |'
  id: totrans-split-342
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `x.y = z` | `x.__setattr__(''y'', z)` | `None` |'
  id: totrans-split-343
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `del x.y` | `x.__delattr__(''y'')` | `None` |'
  id: totrans-split-344
  prefs: []
  type: TYPE_TB
- en: '| Attributes | `dir(x)` | `x.__dir__()` | An iterable |'
  id: totrans-split-345
  prefs: []
  type: TYPE_TB
- en: '| Descriptors | `class T: x = U()` | `T.x.__set_name__(T, ''x'')` | `None`
    |'
  id: totrans-split-346
  prefs: []
  type: TYPE_TB
- en: '| Descriptors | `t.x` | `T.x.__get__(t, T)` |  |'
  id: totrans-split-347
  prefs: []
  type: TYPE_TB
- en: '| Descriptors | `t.x = y` | `T.x.__set__(t, y)` | `None` |'
  id: totrans-split-348
  prefs: []
  type: TYPE_TB
- en: '| Descriptors | `del t.x` | `T.x.__delete__(t)` | `None` |'
  id: totrans-split-349
  prefs: []
  type: TYPE_TB
- en: '| Class stuff | `class U(T): ...` | `T.__init_subclass__(U)` | `None` |'
  id: totrans-split-350
  prefs: []
  type: TYPE_TB
- en: '| Class stuff | `class U(x): ...` | `x.__mro_entries__([x])` | `tuple` |'
  id: totrans-split-351
  prefs: []
  type: TYPE_TB
- en: '| Class stuff | `T[y]` | `T.__class_getitem__(y)` |  |'
  id: totrans-split-352
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `class T: ...` | `type(base).__prepare__()` | `dict`/mapping
    |'
  id: totrans-split-353
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `isinstance(x, T)` | `T.__instancecheck__(x)` | `bool` |'
  id: totrans-split-354
  prefs: []
  type: TYPE_TB
- en: '| Metaclasses | `issubclass(U, T)` | `T.__subclasscheck__(U)` | `bool` |'
  id: totrans-split-355
  prefs: []
  type: TYPE_TB
- en: '| Async | `await x` (ish) | `x.__await__()` | An iterator |'
  id: totrans-split-356
  prefs: []
  type: TYPE_TB
- en: '| Async | `async with x:` | `x.__aenter__()` | An awaitable |'
  id: totrans-split-357
  prefs: []
  type: TYPE_TB
- en: '| Async | `async with x:` | `x.__aexit__()` | An awaitable |'
  id: totrans-split-358
  prefs: []
  type: TYPE_TB
- en: '| Async | `async for a in x:` | `x.__aiter__()` | An awaitable |'
  id: totrans-split-359
  prefs: []
  type: TYPE_TB
- en: '| Async | `async for a in x:` | `x.__anext__()` | An awaitable |'
  id: totrans-split-360
  prefs: []
  type: TYPE_TB
- en: '| Buffers | `memoryview(x)` | `x.__buffer__(flags)` | `memoryview` |'
  id: totrans-split-361
  prefs: []
  type: TYPE_TB
- en: '| Buffers | `del memoryview(x)` | `x.__release_buffer__(m)` | `None` |'
  id: totrans-split-362
  prefs: []
  type: TYPE_TB
- en: 'The above table has a slight but consistent *untruth*. Most of these dunder
    methods are not *actually* called on an object directly but are instead called
    on the *type* of that object: `type(x).__add__(x, y)` instead of `x.__add__(y)`.
    This distinction mostly matters with metaclass methods.'
  id: totrans-split-363
  prefs: []
  type: TYPE_NORMAL
- en: I've also purposely excluded library-specific dunder methods (like `__post_init__`)
    and dunder methods you're unlikely to ever define (like `__subclasses__`). See
    those below.
  id: totrans-split-364
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Operation | Dunder Method Call | Returns |'
  id: totrans-split-365
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-split-366
  prefs: []
  type: TYPE_TB
- en: '| Dataclasses | `x = T(a, b)` | `T.__post_init__(a, b)` | `None` |'
  id: totrans-split-367
  prefs: []
  type: TYPE_TB
- en: '| Copying | `copy.copy(x)` | `x.__copy__()` | New object |'
  id: totrans-split-368
  prefs: []
  type: TYPE_TB
- en: '| Copying | `copy.deepcopy(x)` | `x.__deepcopy__(memo)` | New object |'
  id: totrans-split-369
  prefs: []
  type: TYPE_TB
- en: '| [Pickling](https://docs.python.org/3/library/pickle.html#pickling-class-instances)
    | `pickle.dumps(x)` | `x.__getnewargs__()` | A 2-item tuple |'
  id: totrans-split-370
  prefs: []
  type: TYPE_TB
- en: '| Pickling | `pickle.dumps(x)` | `x.__getnewargs_ex__()` | A 2-item tuple |'
  id: totrans-split-371
  prefs: []
  type: TYPE_TB
- en: '| Pickling | `pickle.dumps(x)` | `x.__getstate__()` | A meaningful state |'
  id: totrans-split-372
  prefs: []
  type: TYPE_TB
- en: '| Pickling | `pickle.dumps(x)` | `x.__reduce__()` | A 2-6 item tuple |'
  id: totrans-split-373
  prefs: []
  type: TYPE_TB
- en: '| Pickling | `pickle.dumps(x)` | `x.__reduce_ex__(4)` | A 2-6 item tuple |'
  id: totrans-split-374
  prefs: []
  type: TYPE_TB
- en: '| Pickling | `pickle.loads(b)` | `x.__setstate__(state)` | `None` |'
  id: totrans-split-375
  prefs: []
  type: TYPE_TB
- en: '| pathlib | [`os.fspath(x)`](https://docs.python.org/3/library/os.html#os.fspath)
    | `p.__fspath__()` | `str` or `bytes` |'
  id: totrans-split-376
  prefs: []
  type: TYPE_TB
- en: '| sys | `sys.getsizeof(x)` | `x.__sizeof__()` | `int` (size in bytes) |'
  id: totrans-split-377
  prefs: []
  type: TYPE_TB
- en: '| Class stuff | None? | `x.__subclasses__()` | Subclasses iterable |'
  id: totrans-split-378
  prefs: []
  type: TYPE_TB
- en: '| ABCs | `issubclass(U, T)` | `T.__subclasshook__(U)` | `bool` |'
  id: totrans-split-379
  prefs: []
  type: TYPE_TB
- en: 'So, Python includes 103 "normal" dunder methods, 12 library-specific dunder
    methods, and at least 52 other dunder attributes of various types. That''s over
    150 unique `__dunder__` names! I **do not recommend** memorizing these: let Python
    do its job and look up the dunder method or attribute that you need to implement/find
    whenever you need it.'
  id: totrans-split-380
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that **you're not meant to invent your own dunder methods**. Sometimes
    you'll see third-party libraries that *do* invent their own dunder method, but
    this isn't encouraged and it can be quite confusing for users who run across such
    methods and assume they're "*real*" dunder methods.
  id: totrans-split-381
  prefs: []
  type: TYPE_NORMAL
