<!--yml

类别：未分类

日期：2024年5月27日13:28:59

-->

# 不变量的问题在于它们随时间变化——《冲浪复杂性》

> 来源：[https://surfingcomplexity.blog/2024/03/26/the-problem-with-invariants-is-that-they-change-over-time/](https://surfingcomplexity.blog/2024/03/26/the-problem-with-invariants-is-that-they-change-over-time/)

Cliff L. Biffle在[Oxide](https://oxide.computer/)上撰写了一篇关于一个调试奥德赛的精彩文章，标题为[谁杀死了网络交换机？](https://cliffle.com/blog/who-killed-the-network-switch/) 这里是让我印象深刻的部分：

> 在编写代码时，它是正确的，但它体现了任何借出内存都将适合一个区域的假设。
> 
> 当马特实施任务打包时，那个假设变得过时，但我们没有注意到。这段代码仍然简单易读，但现在是错误的。

这种假设是不变量的一个例子，即系统中被保证不会随时间改变的属性。不变量在形式化方法中扮演着重要角色（例如，参见Hillel Wayne的《Learn TLA+》站点中的章节[编写不变量](https://www.learntla.com/core/invariants.html)）。

现在，考虑以下情况：

+   我们的系统随时间改变。特别是，我们将始终进行修改以支持在系统生命周期早期无法预见的新功能。

+   我们的代码经常依赖于一些*不变量*，即当前对系统有效的属性，我们假设这些属性将永远保持不变。

+   这些不变量是*隐式*的：假设本身并未在源代码中明确表示。这意味着没有简单的方法可以通过静态分析轻松地提取它们。

+   一种改变可能会违反一个被假设的不变量，这可能发生在依赖于该不变量正常运行的代码远离的地方。

这意味着这些失败模式是*不可避免*的。如果你在这个行业待了足够长的时间，你几乎肯定会遇到一个情况，其中一个贡献者是被新变更违反的隐式不变量。如果你的系统存在足够长的时间，它将会改变。并且这些改变最终会使得某个早些时候的合理假设失效。

隐式不变量根据定义是无法显式执行的。它们是定时炸弹。而且它们无处不在。

**发布于** 2024年3月26日2024年3月26日
