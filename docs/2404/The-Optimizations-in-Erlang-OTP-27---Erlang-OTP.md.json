["```\nerl +JDdump true \n```", "```\nerlc -S base64.erl \n```", "```\n-record(foo, {a,b,c,d,e}).\n\nupdate(N) ->\n    R0 = #foo{},\n    R1 = R0#foo{a=N},\n    R2 = R1#foo{b=2},\n    R2#foo{c=3}. \n```", "```\n {update_record,{atom,reuse},\n                   6,\n                   {literal,{foo,undefined,undefined,undefined,undefined,\n                                 undefined}},\n                   {x,0},\n                   {list,[2,{x,0}]}}.\n    {update_record,{atom,copy},6,{x,0},{x,0},{list,[3,{integer,2}]}}.\n    {update_record,{atom,copy},6,{x,0},{x,0},{list,[4,{integer,3}]}}. \n```", "```\nupdate(N) ->\n    #foo{a=N,b=2,c=3}. \n```", "```\n {put_tuple2,{x,0},\n                {list,[{atom,foo},\n                       {x,0},\n                       {integer,2},\n                       {integer,3},\n                       {atom,undefined},\n                       {atom,undefined}]}}. \n```", "```\n-module(count1).\n-export([count/1]).\n\n-record(s, {atoms=0,other=0}).\n\ncount(L) ->\n    count(L, #s{}).\n\ncount([X|Xs], #s{atoms=C}=S) when is_atom(X) ->\n    count(Xs, S#s{atoms=C+1});\ncount([_|Xs], #s{other=C}=S) ->\n    count(Xs, S#s{other=C+1});\ncount([], S) ->\n    S. \n```", "```\n1> -record(s, {atoms=0,other=0}).\nok\n2> count1:count([a,b,c,1,2,3,4,5]).\n#s{atoms = 3,other = 5} \n```", "```\n {test,is_nonempty_list,{f,6},[{x,0}]}.\n    {get_list,{x,0},{x,2},{x,0}}.\n    {test,is_atom,{f,5},[{x,2}]}.\n    {get_tuple_element,{x,1},1,{x,2}}.\n    {gc_bif,'+',{f,0},3,[{tr,{x,2},{t_integer,{0,'+inf'}}},{integer,1}],{x,2}}.\n    {test_heap,4,3}.\n    {update_record,{atom,inplace},\n                   3,\n                   {tr,{x,1},\n                       {t_tuple,3,true,\n                                #{1 => {t_atom,[s]},\n                                  2 => {t_integer,{0,'+inf'}},\n                                  3 => {t_integer,{0,'+inf'}}}}},\n                   {x,1},\n                   {list,[2,{tr,{x,2},{t_integer,{1,'+inf'}}}]}}.\n    {call_only,2,{f,4}}. % count/2\n  {label,5}.\n    {get_tuple_element,{x,1},2,{x,2}}.\n    {gc_bif,'+',{f,0},3,[{tr,{x,2},{t_integer,{0,'+inf'}}},{integer,1}],{x,2}}.\n    {test_heap,4,3}.\n    {update_record,{atom,inplace},\n                   3,\n                   {tr,{x,1},\n                       {t_tuple,3,true,\n                                #{1 => {t_atom,[s]},\n                                  2 => {t_integer,{0,'+inf'}},\n                                  3 => {t_integer,{0,'+inf'}}}}},\n                   {x,1},\n                   {list,[3,{tr,{x,2},{t_integer,{1,'+inf'}}}]}}.\n    {call_only,2,{f,4}}. % count/2\n  {label,6}.\n    {test,is_nil,{f,3},[{x,0}]}.\n    {move,{x,1},{x,0}}.\n    return. \n```", "```\n {test,is_nonempty_list,{f,6},[{x,0}]}.\n    {get_list,{x,0},{x,2},{x,0}}. \n```", "```\n {test,is_atom,{f,5},[{x,2}]}. \n```", "```\n {get_tuple_element,{x,1},2,{x,2}}.\n    {gc_bif,'+',{f,0},3,[{tr,{x,2},{t_integer,{0,'+inf'}}},{integer,1}],{x,2}}. \n```", "```\n {test_heap,4,3}.\n    {update_record,{atom,inplace},\n                   3,\n                   {tr,{x,1},\n                       {t_tuple,3,true,\n                                #{1 => {t_atom,[s]},\n                                  2 => {t_integer,{0,'+inf'}},\n                                  3 => {t_integer,{0,'+inf'}}}}},\n                   {x,1},\n                   {list,[3,{tr,{x,2},{t_integer,{1,'+inf'}}}]}}. \n```", "```\n# update_record_in_place_IsdI\n    mov rax, qword ptr [rbx+8]\n    mov rcx, qword ptr [rbx+16]\n    test cl, 1\n    short je L38           ; Update directly if small integer.\n\n    ; The new value is a bignum.\n    ; Test whether the tuple is in the safe part of the heap.\n\n    mov rdi, [r13+480]     ; Get the high water mark\n    cmp rax, r15           ; Compare tuple pointer to heap top\n    short jae L39          ; Jump and copy if above\n    cmp rax, rdi           ; Compare tuple pointer to high water\n    short jae L38          ; Jump and overwrite if above high water\n\n    ; The tuple is not in the safe part of the heap.\n    ; Fall through to the copy code.\n\nL39:                       ; Copy the current record\n    vmovups ymm0, [rax-2]\n    vmovups [r15], ymm0\n    lea rax, qword ptr [r15+2] ; Set up tagged pointer to copy\n    add r15, 32            ; Advance heap top past the copy\n\nL38:\n    mov rdi, rcx           ; Get new value for atoms field\n    mov qword ptr [rax+22], rdi\n    mov qword ptr [rbx+8], rax \n```", "```\n mov rax, qword ptr [rbx+8]\n    mov rcx, qword ptr [rbx+16] \n```", "```\n test cl, 1\n    short je L38           ; Update directly if small integer. \n```", "```\n mov rdi, [r13+480]     ; Get the high water mark\n    cmp rax, r15           ; Compare tuple pointer to heap top\n    short jae L39          ; Jump and copy if above\n    cmp rax, rdi           ; Compare tuple pointer to high water\n    short jae L38          ; Jump and overwrite if above high water \n```", "```\nL39:                       ; Copy the current record\n    vmovups ymm0, [rax-2]\n    vmovups [r15], ymm0\n    lea rax, qword ptr [r15+2] ; Set up tagged pointer to copy\n    add r15, 32            ; Advance heap top past the copy \n```", "```\nL38:\n    mov rdi, rcx           ; Get new value for atoms field\n    mov qword ptr [rax+22], rdi\n    mov qword ptr [rbx+8], rax \n```", "```\n-module(whatever).\n-export([main/1]).\n\n-record(bar, {bool,pid}).\n\nmain(Bool) when is_boolean(Bool) ->\n    flip_state(#bar{bool=Bool,pid=self()}).\n\nflip_state(R) ->\n    R#bar{bool=not R#bar.bool}. \n```", "```\n {update_record,{atom,inplace},\n                   3,\n                   {tr,{x,0},\n                       {t_tuple,3,true,\n                                #{1 => {t_atom,[bar]},\n                                  2 => {t_atom,[false,true]},\n                                  3 => pid}}},\n                   {x,0},\n                   {list,[2,{tr,{x,1},{t_atom,[false,true]}}]}}. \n```", "```\n# update_record_in_place_IsdI\n    mov rax, qword ptr [rbx]\n# skipped copy fallback because all new values are safe\n    mov rdi, qword ptr [rbx+8]\n    mov qword ptr [rax+14], rdi\n    mov qword ptr [rbx], rax \n```", "```\n-record(state, {op, data}).\n\nupdate_state(R0, Op0, Data) ->\n    R = R0#state{data=Data},\n    case Op0 of\n        add -> R#state{op=fun erlang:'+'/2};\n        sub -> R#state{op=fun erlang:'-'/2}\n    end. \n```", "```\n {update_record,{atom,inplace},\n                   3,\n                   {tr,{x,0},{t_tuple,3,true,#{1 => {t_atom,[state]}}}},\n                   {x,0},\n                   {list,[2,{literal,fun erlang:'+'/2}]}}. \n```", "```\n# update_record_in_place_IsdI\n    mov rax, qword ptr [rbx]\n# skipped copy fallback because all new values are safe\n    long mov rdi, 9223372036854775807  ; Placeholder for address to fun\n    mov qword ptr [rax+14], rdi\n    mov qword ptr [rbx], rax \n```", "```\nmadd(A, C) ->\n    fun(B) -> A * B + C end. \n```", "```\n# i_make_fun3_FStt\nL38:\n    long mov rsi, 9223372036854775807 ; Placeholder for dispatch table\n    mov edx, 1\n    mov ecx, 2\n    mov qword ptr [r13+80], r15\n    mov rbp, rsp\n    lea rsp, qword ptr [rbx-128]\n    vzeroupper\n    mov rdi, r13\n    call 4337160320       ; Call helper function in runtime system\n    mov rsp, rbp\n    mov r15, qword ptr [r13+80]\n# Move fun environment\n    mov rdi, qword ptr [rbx]\n    mov qword ptr [rax+40], rdi\n    mov rdi, qword ptr [rbx+8]\n    mov qword ptr [rax+48], rdi\n# Create boxed ptr\n    or al, 2\n    mov qword ptr [rbx], rax \n```", "```\n# i_make_fun3_FStt\nL38:\n    long mov rax, 9223372036854775807 ; Placeholder for dispatch table\n# Create fun thing\n    mov qword ptr [r15], 196884\n    mov qword ptr [r15+8], rax\n# Move fun environment\n# (moving two items)\n    vmovups xmm0, xmmword ptr [rbx]\n    vmovups xmmword ptr [r15+16], xmm0\nL39:\n    long mov rdi, 9223372036854775807 ; Placeholder for fun reference\n    mov qword ptr [r15+32], rdi\n# Create boxed ptr\n    lea rax, qword ptr [r15+2]\n    add r15, 40\n    mov qword ptr [rbx], rax \n```", "```\n# Move fun environment\n    mov rdi, qword ptr [rbx]\n    mov qword ptr [rax+40], rdi\n    mov rdi, qword ptr [rbx+8]\n    mov qword ptr [rax+48], rdi \n```", "```\n# Move fun environment\n# (moving two items)\n    vmovups xmm0, xmmword ptr [rbx]\n    vmovups xmmword ptr [r15+16], xmm0 \n```", "```\nensure_fun_0(F) when is_function(F, 0) -> ok. \n```", "```\n# is_function2_fss\n    mov rdi, qword ptr [rbx]   ; Fetch `F` from {x,0}.\n\n    rex test dil, 1            ; Test whether the term is a tagged pointer...\n    short jne label_3          ; ... otherwise fail.\n\n    mov eax, dword ptr [rdi-2] ; Pick up the header word.\n    cmp eax, 212               ; Test whether it is a fun...\n    short jne label_3          ; ... otherwise fail.\n\n    cmp byte ptr [rdi+22], 0   ; Test whether the arity is 0...\n    short jne label_3          ; ... otherwise fail. \n```", "```\n# is_function2_fss\n    mov rdi, qword ptr [rbx]   ; Fetch `F` from {x,0}.\n\n    rex test dil, 1            ; Test whether the term is a tagged pointer...\n    short jne label_3          ; ... otherwise fail.\n\n    cmp word ptr [rdi-2], 20   ; Test whether this is a fun with arity 0...\n    short jne label_3          ; ... otherwise fail. \n```", "```\nmy_fun() ->\n    fun ?MODULE:some_function/0.\n\nmfa(M, F, A) ->\n    fun M:F/A. \n```", "```\nbench() ->\n    Size = 1_262_000,\n    String = binary:copy(<<\"9\">>, Size),\n    {Time, _Val} = timer:tc(erlang, binary_to_integer, [String]),\n    io:format(\"Size: ~p, seconds: ~p\\n\", [Size, Time / 1_000_000]). \n```", "```\nensure_empty_map(Map) when Map =:= #{} ->\n    ok. \n```", "```\n {test,is_eq_exact,{f,1},[{x,0},{literal,#{}}]}. \n```", "```\n# is_eq_exact_fss\nL45:\n    long mov rsi, 9223372036854775807\n    mov rdi, qword ptr [rbx]\n    cmp rdi, rsi\n    short je L44                  ; Succeeded if the same term.\n\n    rex test dil, 1\n    short jne label_1             ; Fail quickly if not a tagged pointer.\n\n    ; Call the general runtime function for comparing two terms.\n    mov rbp, rsp\n    lea rsp, qword ptr [rbx-128]\n    vzeroupper\n    call 4549723200\n    mov rsp, rbp\n\n    test eax, eax\n    short je label_1               ; Fail if unequal.\nL44: \n```", "```\n# is_eq_exact_fss\n# optimized equality test with empty map\n    mov rdi, qword ptr [rbx]\n    rex test dil, 1\n    short jne label_1              ; Fail if not a tagged pointer.\n\n    cmp dword ptr [rdi-2], 300\n    short jne label_1              ; Fail if not a map.\n\n    cmp dword ptr [rdi+6], 0\n    short jne label_1              ; Fail if size is not zero. \n```"]