<!--yml

category: 未分类

date: 2024-05-27 13:04:34

-->

# 为什么 Python 的列表复制看起来奇怪？CPython 内部深入解析

> 来源：[https://codeconfessions.substack.com/p/why-do-python-lists-multiply-oddly](https://codeconfessions.substack.com/p/why-do-python-lists-multiply-oddly)

当我在 X/Twitter 上滚动时，我注意到以下与 Python 相关的帖子，获得了 2.5k 个赞。

乍一看，这似乎是一个令人惊讶的输出，我同意这种行为是反直觉的。我不打算讨论这是否是正确的行为。相反，我想借此机会解释这种行为背后的原因，并展示这个过程中的一些 CPython 内部细节。

我们将通过在 REPL 中进行一些检查来给出一个高层次的答案，然后我们将深入到 CPython 中列表实现的细节，以了解为什么会发生这种情况，最后我们将进一步深入到看看 CPython 如何调用这种行为。

* * *

* * *

Python 的这种特殊行为可以从 REPL 中进行解释。因此，首先让我们先通过 REPL 得到简短的答案。

在 Python 中，当 `*` 操作符用于序列类型对象（如列表、字符串）时，它会将对象的元素重复 `x` 次。例如：`‘a’ * 3` 将产生 `‘aaa’`。同样，`[[]] * 4` 产生 `[[], [], [], []]`。

然而，您可能知道，Python 中的所有东西都是对象，每个对象都通过对它的引用来访问。所以在 `[[]]` 中，内部列表是对一个空列表对象的引用。`*` 操作符只是复制相同的引用四次，导致 `[[], [], [], []]`。而且，所有这些重复的内部列表都是对同一个初始空列表对象的引用。

我们可以通过打印每个空列表的 id 来验证这个理论，如下所示：

```
>>> l = [[]] * 4
>>> l
[[], [], [], []]
>>> [id(x) for x in l]
[140035530892992, 140035530892992, 140035530892992, 140035530892992]
```

正如您所见，每个内部列表都具有相同的对象 id，这意味着它们是对同一对象的引用。这就是为什么修改这些内部列表中的一个会反映为对每个其他列表的更新。

证明每个内部列表确实是对同一列表对象的引用

因此这就是简短的答案。现在，对于那些对此背后的 CPython 实现细节感兴趣的人，让我们深入探讨一下！

* * *

让我们首先看看在文件[Include/cpython/listobject.h](https://github.com/python/cpython/blob/3.12/Include/cpython/listobject.h#L5)中定义的列表对象的定义。下图展示了其结构。

CPython 中列表对象的定义

它由三个字段组成：

+   第一个字段是 `PyObject` 结构的一个实例（也称为对象头，因为它是每个 CPython 对象的第一个字段）—— 它包含有关对象的引用计数和类型实现相关的详细信息。（查看我关于 PyObject 和 PyTypeObject 的[视频](https://codeconfessions.substack.com/p/decoding-pyobject-and-pytypeobject)了解更多详情）。

+   第三个字段是列表的当前容量，即它可以容纳多少对象。当列表即将溢出其容量时，列表会被重新调整大小。

+   第二个字段是`PyObject *`类型的数组。这个数组是列表内部存储所有这些对象的地方。让我们详细讨论一下。

* * *

因此我们知道列表类型在内部使用数组来存储其项。这个数组的数据类型是`PyObject *`，这意味着这个数组中的每个项都是指向`PyObect`对象的指针。这本身意味着列表仅存储对对象的引用，而不是存储实际的对象。下面的插图展示了其外观：

CPython列表对象的内存表示

让我们看看在添加元素后列表的样子。

```
l = []
l.append(3.14)
```

在插入元素后列表的外观

正如您在插图中所看到的 — 当我们向列表添加新元素时，内部列表只存储指向该对象的指针（或引用）。现在，让我们看看CPython中列表对象如何处理`*`运算符，以及在这种情况下这个数组会发生什么变化。

* * *

有了对CPython中列表类型如何定义的基本理解，让我们看看它是如何实现处理`*`运算符的函数。CPython列表对象的完整实现位于文件[Objects/listobject.c](https://github.com/python/cpython/blob/3.12/Objects/listobject.c#L552)，以下插图展示了处理`*`操作的函数。

用于处理`*`运算符的函数在listobject.c中定义

此函数首先创建一个新列表，然后将原始列表中存储的引用复制到新列表中，最后在新列表中重复这些引用n次。

虽然我已经用评论注释了整个函数，但是让我们花些时间来看看函数的核心部分，在这里第一个列表的项被复制并重复到新列表中。让我们首先看看一个将空列表存储为唯一元素的列表在内存中的样子：

```
l1 = []
l1.append([])
```

当列表l1在内存中存储对另一个空列表的引用时的外观

因此，这就是在我们使用`*`运算符之前的情况。外部列表l1包含另一个列表作为其第一个元素。通过在l1的`ob_item`数组中有一个条目指向另一个列表来显示这一点。这个其他列表当前的引用计数为1。我们将看到在我们应用`*`运算符后这将如何改变。

```
>>> l2 = l1 * 4
>>> print(l2)
[[], [], [], []]
```

根据上述代码片段，在l1上应用`*`运算符后的外观。

应用`*`运算符到l1后的结果。创建了一个包含l1中原始存储引用的副本，并重复n次的新列表。

上面的插图展示了执行`l1 * 4`的结果。请注意，列表上的`*`运算符通过在新列表中n次复制原始列表中存储的引用来创建新列表。正如你所见，这个新列表中的`ob_item`数组包含4个指针（或引用），指向同一个空列表对象。此外，它们指向的列表的引用计数从1增加到了5 —— `l2`中的四个引用和`l1`中的一个引用。

最后，当我们执行`l2[0].append()`时会发生什么？下面的插图显示了这一点。

```
l2[0].append(3.14)
```

当我们向`l2`的第一个内部列表中插入一个元素时会发生什么？

我们将浮点值`3.14`附加到`l2`的第一个元素上。上图说明了这造成的变化。`l2`中的4个元素仍然指向同一个共同的列表，但现在这个列表的`ob_item`数组包含对一个值为`3.14`的浮点类型对象的引用。

* * *

在使用列表上的`*`运算符时发生的所有事情都在这里。但是还有一个问题 —— CPython运行时如何知道在列表类型对象上使用`*`运算符时需要调用这个特定的函数？这是一个与理解我们原始问题无关的附加部分。如果你对深入了解CPython内部感兴趣，可以继续阅读。

那么CPython VM如何知道它需要在`listobject.c`内部调用`list_repeat`函数呢？让我们从底层开始学习这个。

在第一节中，我们看到了CPython中列表对象的定义，并且我们看到它的第一个元素是[PyObject](https://github.com/python/cpython/blob/3.12/Include/object.h#L166)结构的一个实例。事实证明，CPython中的每个类型定义都包含这个作为其第一个字段，因此这个字段也被称为对象头（因为它位于每个对象的开头）。

`PyObject`结构包括对象的引用计数以及指向类型为[PyTypeObject](https://github.com/python/cpython/blob/3.12/Include/cpython/object.h#L146)的对象的指针。现在，在这里我们对`PyTypeObject`结构感兴趣，因为它包括用于存储对象的类型相关信息的字段。

在CPython中的PyObject结构的定义

在这些字段中，有一堆函数指针表用于处理各种运算符和对象协议。在这些函数指针表中，有一个称为`tp_as_sequence`的表，它包含用于处理序列类型对象所期望的操作的函数指针。这些操作包括切片、索引、重复、连接等。

下面的插图显示了`PyTypeObject`结构的部分定义（因为它太大了，无法完全显示在这里），并突出显示了一些函数指针表，如`tp_as_number`（用于数值运算符）和`tp_as_sequence`（用于处理序列类型运算符）。

PyTypeObject 的定义以及用于处理数值和序列类型操作的函数指针表

在 CPython 中的每个对象（取决于其类型，即其是否为数值、序列类型等）都需要实现处理各种操作的相关函数。例如，序列类型对象需要实现处理索引、切片、重复等的函数，并在其 `PyTypeObject` 实例中的 `tp_as_sequence` 字段中填充指向这些函数的指针。下面的插图展示了所有这些发生在 `listobject.c` 内部的过程。

在 CPython 中，列表类型如何实现处理长度、连接（+）和重复（*）操作的函数，并使用指向这些函数的指针创建 `PySequenceMethods` 对象，然后该对象进入 `PyTypeObject` 实例内部。

插图展示了列表对象实现处理列表上 `len`、`+` 和 `*` 操作的函数。这些函数的指针用于填充 `PySequenceMethods` 结构体的实例，最终指针指向此对象的一个实例放入 `PyTypeObject`（称为 `PyList_Type`）的实例内部。

接下来，指向 `PyList_Type` 对象的指针用于在初始化时为每个新的列表对象填充头部。下面的插图展示了每次 CPython 运行时需要创建新的列表对象时调用的代码。

每当需要创建新的列表对象时调用的 `listobject.c` 中的函数。

这意味着每个列表对象在运行时的头部都有这些函数指针，虚拟机可以查找并执行它们来处理不同的操作。事实上，每个 CPython 对象在实现上都遵循类似的协议，在其头部填充函数指针表以执行各种操作。现在让我们看看 CPython 虚拟机如何查找这个头部以在对象上执行各种操作。

让我们通过一个示例来理解，在这个示例中，我们有一个函数对列表对象执行 `*` 操作符。

```
>>> def repeat():
...     l = []
...     return l * 4
...
>>> dis.dis(repeat)
  1           0 RESUME                   0
  2           2 BUILD_LIST               0
              4 STORE_FAST               0 (l)
  3           6 LOAD_FAST                0 (l)
              8 LOAD_CONST               1 (4)
             10 BINARY_OP                5 (*)
             14 RETURN_VALUE
```

上述列表还显示了使用 [dis](https://docs.python.org/3/library/dis.html) 模块的这个函数的编译字节码。CPython 使用基于堆栈的虚拟机（VM）来执行这些字节码指令。VM 使用堆栈来存储执行这些指令所需的参数。

除了堆栈之外，还有一个`locals`表用于存储作用域局部变量和函数参数，并且一个`globals`表用于存储全局对象。基于这些信息，让我们来理解这段字节码序列中发生了什么。

+   `BUILD_LIST`：创建一个新的列表对象。

+   `STORE_FAST`：将列表对象放入局部表中（即变量 `l`）的索引 0 处。

+   `LOAD_FAST`：从局部表中索引 0 处加载对象并将其推送到堆栈上。

+   `LOAD_CONST`：将常量 4 推送到堆栈上。

+   `BINARY_OP`: 弹出堆栈顶部的两个对象，并对它们执行`*`操作，例如，它从堆栈中弹出4和`l`，然后对它们执行`*`操作。让我们详细讨论一下。

用于处理所有这些字节码指令的实现位于文件[Python/generated_cases.c.h](https://github.com/python/cpython/blob/3.12/Python/generated_cases.c.h)中。处理`BINARY_OP`指令的代码如下：

在CPython VM中处理BINARY_OP指令

因此，我们看到VM为处理每个操作符拥有一个函数指针表。为了执行二进制操作，它查找此表并调用相应的函数。现在让我们看看这个表是什么样子。

用于处理二元操作符的generated_cases.c.h中的函数指针表

此表中映射的所有函数指针均定义在文件[Objects/abstract.c](https://github.com/python/cpython/blob/3.12/Objects/abstract.c)中。这个`abstract.c`是一个抽象对象接口，它将类型系统实现细节隐藏在VM之外。VM不需要了解不同类型如何实现不同操作符，它让抽象对象接口处理这一部分。现在让我们来看看在`Objects/abstract.c`中`PyNumber_Multiply`函数的实现。

在abstract.c中实现的PyNumber_Multiply函数

上述插图列出了abstract.c中处理`*`运算符的函数。正如你所见，这个函数完全了解CPython中的类型系统如何通过对象头中的函数指针表来公开处理操作符的函数。

即使函数名称是`PyNumber_Multiply`，它也处理了数值类型和序列类型的`*`操作符。首先它尝试查找数值操作的函数指针表（定义在`PyTypeOjbect`的`PyNumberMethods`字段内），当失败时，它再尝试查找序列类型的函数指针表。一旦找到函数，它就调用该函数并返回值。

* * *

因此，这是我们需要了解的关于CPython在处理序列类型对象上的`*`操作背后的实现细节，并且理解我们开始整个探索的那种奇怪行为的原因。让我们快速总结一下本文的所有讨论，以结束本文：

+   在Python中一切皆为对象，但是这些对象是通过引用来访问的，即我们的代码处理的是对对象的引用，而不是直接处理对象。

+   列表也在内部存储对其他对象的引用。

+   当对列表应用`*`运算符时，将创建一个新的列表对象，其中包含原始列表中存储的引用重复n次。这意味着新列表中重复的元素共享对同一对象的引用。

+   我们看了这是如何在CPython的列表实现中实现的。

+   我们查看了CPython中列表对象的定义，并了解到它内部使用数组来存储项目。该数组包含指向`PyObject`类型对象的指针。`PyObject`是CPython运行时中表示所有对象的通用类型。

+   我们看到当我们将一个值存储在列表中时，它导致数组存储指向该对象的指针。

+   我们查看了`listobject.c`中处理`*`运算符的函数，并看到这个函数是如何简单地在新列表中复制这些指针的。这再次表明新列表中重复的值只是指向同一对象的指针。

+   然后我们深入了解了当在列表类型对象上应用`*`运算符时，CPython虚拟机如何调用`listobject.c`中正确的函数。

+   这是通过在列表对象头部的表中进行函数指针查找来完成的。

    * * *

[分享](https://blog.codingconfessions.com/p/why-do-python-lists-multiply-oddly?utm_source=substack&utm_medium=email&utm_content=share&action=share)
