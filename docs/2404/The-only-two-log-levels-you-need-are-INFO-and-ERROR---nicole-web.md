<!--yml

category: 未分类

date: 2024-05-27 13:39:29

-->

# The only two log levels you need are INFO and ERROR | nicole@web

> 来源：[https://ntietz.com/blog/the-only-two-log-levels-you-need-are-info-and-error/](https://ntietz.com/blog/the-only-two-log-levels-you-need-are-info-and-error/)

日志记录是维护任何 Web 应用程序的关键工具，然而我们却搞错了。

使用良好的日志记录，您可以了解应用程序的运行情况。如果没有日志记录呢？问题可能无处不在，而您却一无所知。相反，您会想知道为何您的客户不再回来，并耸耸肩，把责任推给工程之外的人。

遗憾的是，我们常常以无益的方式记录日志。日志级别不一致，日志仅用于修复错误后便被移除。但请看标题，这篇文章主要讨论日志级别。

# 典型的日志级别

Most languages and logging libraries have a handful of log levels, at least five. But they vary! Here are three examples:

+   Rust 的 `tracing` 拥有 [五个日志级别](https://docs.rs/tracing/latest/tracing/struct.Level.html)：ERROR、WARN、INFO、DEBUG 和 TRACE。

+   Python's `logging` also has [five log levels](https://docs.python.org/3/howto/logging.html): CRITICAL, ERROR, WARNING, INFO, and DEBUG.

+   The infamous `log4j` has [six log levels](https://logging.apache.org/log4j/1.x/apidocs/org/apache/log4j/Level.html): FATAL, ERROR, WARN, INFO, DEBUG, and TRACE.

Three examples and three wholly different sets of log levels. They all function in about the same way: you log certain information at different levels, based on your ideas of "severity" and "granularity", and then as you get toward the fatal/error end of the log levels you see only the most critical alerts, and toward the other end you see *everything* to help you debug your application.

确实没有典型的日志级别集，也没有跨语言的常见指导方针来告诉您在哪个级别记录什么。这种建议不可能存在，因为级别差异太大！

# What do we do with logs?

When we add log statements, that's typically because we think that we will need those logs sometime in the future. We think they'll help us debug something, or help us audit that it happened, or discover a critical error.

回想一下，当您尝试调试部署在网络上的 Web 应用程序（而不是在本地机器上），您是如何使用日志的。通常，我们会做以下几件事情：

+   -   **发现需要修复的错误。** 我们希望知道什么时候出了问题，因此我们在日志中查找错误。通常情况下，您还希望在需要修复的时候收到警报。而且相关的是，*如果发生不值得关注的事情，您不希望收到警报*。警报疲劳是一个严重的问题。

+   **调试问题。** 当出现问题时，无论你是否从日志中收到警报，你都会查看日志来理解问题所在。日志可以告诉你发生了什么意外情况。它们应包括任何堆栈跟踪、相关错误以及导致问题发生的条件。

+   **理解用法。** 有时日志对于理解事物的使用方式很有帮助！你可以大致看到应用程序的哪些部分被访问或者被忽略。然而，它们并不能取代指标或分布式追踪！

+   **理解它是如何工作的。** 日志还可以帮助你理解系统的运作方式！如果你只有代码，你会看到很多函数、请求处理程序、数据以及你从哪里开始？通过日志，你通常可以找到一个入口点，即请求或会话的开始。从那里，你可以沿着这些日志来跟踪会话的生命周期和执行过程！

这些可以分为两类日志：把我从睡梦中惊醒的日志，以及帮助我解决问题的日志。

对于把我从睡梦中惊醒的日志，我想知道一些事情。问题*具体*在哪里？它是什么时候发生的？我可以在哪里找到相关的日志？

对于帮助我解决问题的日志，我真的想知道一切。当调试时，所有相关的信息都很重要，我不需要立即陷入有关CNC的细节。而且在你找到问题答案之前，你不知道什么信息是相关的！你可能有猜测，但那只是猜测。

# 你需要的级别

实际上，我倾向于认为你只需要两个日志级别：ERROR 和 INFO。这是因为我们真的只关心是否应该警报某事。对于日志的所有其他用途，我们希望看到*所有*的上下文。

让我们以 WARNING 为例。假设你*应该*有一个 WARNING 日志级别，并且一些警告显示在你的日志中。当你看到它们时，你应该怎么办？有三种选择：

+   如果这些信息在*任何*情况下都没有用处，可以完全删除它们！

+   如果它们帮助你理解其他日志，这些日志可能与错误相关，那么它们只是用于调试的信息日志！它们应该是 INFO 级别以反映这一点。

+   如果是需要修复的错误，那么现在不是警告了吗？将其作为一个 ERROR 日志。

对于像 DEBUG 或 TRACE 这样的日志级别也是类似的。通常你会在想要查看极其详细信息时使用这些日志级别，但是... 在生产环境中启用这些级别并不实际，因为生成的日志量将会非常高。如果在生产环境中无法使用它们，那么在其他地方也不应该使用！这就是你本地调试器的用处。

像 FATAL 这样的事物？是的，那也是一个 ERROR 日志，因为你确实希望在它出现时得到提醒！

在我实际生产环境遇到的每一种情况中，单个日志行的特定级别从未足以调试问题，只能表明发生了什么。即便如此，实际发生了什么？耸耸肩。让我们看更多的日志行。

因此，如果将事物分开到不同的日志级别中，最终您将仍然需要一起查看所有这些，因为要理解您的警告或错误，您需要所有信息日志来查看当时的情况！您需要更广泛的上下文来理解整体情况。这与语法高亮非常微妙地提供了语义信息，但有更好的方法来传达这些信息。

# 通过其他方式增强您的日志

有比严格遵守不同日志级别更好的方式来增加日志的可用性。结构化日志是以机器可读格式发出日志的实践。它们通常是从映射创建的，然后以JSON格式输出到日志中，或者以更可读的格式输出供人类查看。使用结构化日志，您可以以*有用*的方式附加更多详细信息到每个日志中。

这里有几种实践方法我喜欢使用：

+   **附加请求/跟踪ID**。这与分布式跟踪相伴而行，并帮助您有效地进行筛选。按日志级别筛选不会给您上下文，但通过请求ID进行关联将为您提供给定事件的所有日志！

+   **包括时间戳**。所有日志都应包含时间戳，但让我们确保我们拥有它们，并且具有有用的精度。以结构化格式拥有这些信息使得可以更轻松地用于计算。

+   **添加相关的ID**。当传入请求涉及特定用户、文档或其他数据时，将该ID添加到日志中非常有帮助！这样在调试时，您可以查看特定对象的所有日志，或者查看特定数据是否与您正在解决的问题相关。没有这些信息，你只是在猜测“也许这只是一个大公司的问题”，而有了它，你就知道其他客户是否也遇到了这个问题。

+   **注意审计信息**。如果为了审计目的记录信息，您将如何找到它？通过在日志中包含一些内容，让您能够在这堆草堆中寻找针（并在丢弃草堆时保留针），因为支付草堆存储公司就像点燃一堆现金一样。这可以简单到一个用于审计日志的布尔值，或者如果需要的话可以更复杂一些。

+   **设置的标志**。您的应用程序可能具有特性标志。此请求启用了哪些标志？让我们将它们放入日志中，这样我们就可以知道。

+   **日志来源**。包括产生日志的模块或函数名，对于稍后查看周围上下文非常有帮助。太多时候，我没有这个信息，不得不使用grep来查找特定字符串以找到发出该日志的位置。希望只有一个地方。

您确实希望避免添加过多信息，因为这可能会产生压倒性的信息量！但是，如果您适当地添加这些信息，它真的非常有帮助。

并且不要在修复一个问题时添加日志，然后稍后再移除它们，好吗？我见过这样的情况，这表明你一开始并没有足够的日志来理解发生了什么！你可能不清楚你确切需要什么，但是在明确需求后，确保你需要的日志*此*问题都存在。理想情况下，它们应该以更一般的形式存在，以便将来也能调试其他相关但不同的问题。

* * *

看。

我知道，日志级别很有用。我对此并不特别教条，因为*有时*可能存在你希望调整细节程度的情况（特别是对于限制日志级别的库来说，这样做可以避免在INFO级别获取所有内容）。

我只是认为，在我大部分时间从事的工作——主要是Web应用程序方面，超出唤醒我或不唤醒我的范畴，关注其他方面并不太有用。如果你有不同的做法，我很愿意听听你的经验。
