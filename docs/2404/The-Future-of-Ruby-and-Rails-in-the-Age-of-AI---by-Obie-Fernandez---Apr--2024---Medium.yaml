- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:21:34'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: The Future of Ruby and Rails in the Age of AI | by Obie Fernandez | Apr, 2024
    | Medium
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://obie.medium.com/the-future-of-ruby-and-rails-in-the-age-of-ai-8f1acea31bc2](https://obie.medium.com/the-future-of-ruby-and-rails-in-the-age-of-ai-8f1acea31bc2)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Future of Ruby and Rails in the Age of AI
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rubyists Will Lead the AI Revolution via Prompt-Driven Development
  id: totrans-split-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Artificial Intelligence (AI) is transforming the way we build, debug, and optimize
    code, and it’s happening at an unprecedented pace. As a long-time Ruby and Rails
    developer, I’m participating in these developments with excitement via [my startup](https://olympia.chat)
    and [my new book](/patterns-of-application-development-using-ai-fbb660fa9ae7)
    and [open-source projects](https://github.com/OlympiaAI/open_router).
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news I want to share is: not only will Ruby *and* Rails survive this
    AI revolution, Rubyists will pioneer the most revolutionary application development
    approaches of the coming era. The very qualities that drew us to the Ruby and
    Rails ecosystem — the expressiveness, the readability, the emphasis on developer
    happiness — are precisely what position us to spearhead the AI-powered future
    of software development.'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: In case you’re not familiar with it, the magic of Ruby lies in its dynamic,
    expressive nature. It’s a language that gets out of your way and lets you focus
    on solving problems instead of wrestling with syntax. And when you pair that with
    the convention-over-configuration approach of Rails, you have a potent combination
    that enables rapid, iterative development. It’s the reason that 20 years later,
    Rails remains the undisputed king of web application frameworks.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: The very qualities that drew us to the Ruby and Rails ecosystem — the expressiveness,
    the readability, the emphasis on developer happiness — are precisely what position
    us to spearhead the AI-powered future of software development.
  id: totrans-split-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As I’ve learned first-hand in the last year, these “magical” qualities are incredibly
    well-suited for AI-enhanced software development. I envision a near future where
    I’ll be able to declare my application’s functionality in plain, almost natural
    language (pseudo-code, really) instead of extensive code, tests, and documentation.
    This is the real promise of AI for software development, and it’s a promise that
    those of us most familiar with the essence of Ruby are uniquely positioned to
    deliver on.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Prompt-Driven Development: A New Paradigm'
  id: totrans-split-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this brave new world of AI-powered development, I’m not just talking about
    using AI to generate code snippets or autocomplete our methods. I’m talking about
    a fundamental shift. Prompt-Driven Development: a paradigm where application behavior
    is defined not by thousands of lines of painstakingly written and maintained code,
    but by high-level, declarative prompts. In the early days it will be woven into
    plain old Ruby code, but eventually it will just be talk.'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: Imagine describing a complex workflow or a new feature in plain, conversational
    language. Your AI assistant takes this description and brings it to life *in realtime,
    at runtime*. No more spending hours wrestling with intricate implementations or
    worrying about low-level details. You focus on the the business goals, the AI
    takes care of how to make it happen.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想象用简单的会话语言描述复杂的工作流程或新功能。你的 AI 助手将此描述实时转化为现实。不再花费数小时抓住复杂实现或担心低级细节。你专注于业务目标，AI
    处理如何实现它。
- en: '*The vision is not about generating code to be stored and maintained.* It’s
    about creating a dynamic, runtime relationship between your declarative prompts
    and the actual behavior of your application. Your prompts are your living, breathing
    codebase.'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个愿景不是为了生成存储和维护的代码。* 它是关于在你的声明性提示与应用程序的实际行为之间创建动态、运行时的关系。你的提示是你活跃、充满活力的代码库。'
- en: '[PRE0]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The prompt above is not a fantasy. As described [in my new book](https://leanpub.com/patterns-of-application-development-using-ai),
    it’s the actual system prompt supplied to the AccountManager component in [Olympia](https://olympia.chat/?utm_source=medium).
    A component that interfaces with the rest of my app via prompts. Let me say that
    again. The internal API for this component is plain text. I’m literally taking
    what would have been dozens or hundreds of lines of code and letting AI handle
    the job in a black-box fashion. Already. Today.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上述提示并非幻想。正如在[我的新书](https://leanpub.com/patterns-of-application-development-using-ai)中描述的那样，这是供
    [Olympia](https://olympia.chat/?utm_source=medium) 中 AccountManager 组件使用的实际系统提示。该组件通过提示与我的应用程序的其余部分进行交互。再说一遍，这个组件的内部
    API 是纯文本。我正在让 AI 以黑匣子方式处理本应是数十或数百行代码的工作。已经，今天。
- en: Are you taking similar approaches in your projects? Let’s [talk](mailto:obiefernandez@gmail.com)!
  id: totrans-split-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在你的项目中采取类似的方法吗？让我们[交流](mailto:obiefernandez@gmail.com)吧！
- en: Challenges and Opportunities
  id: totrans-split-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战与机遇
- en: Of course, this approach comes with its own set of challenges. How do we ensure
    deterministic results when those are called for? How do we ensure the generated
    code is efficient and secure? How do we debug issues when the code is abstracted
    away? These are the questions we as Rubyists are uniquely equipped to tackle.
    Our community’s blend of pragmatism, creativity, and focus on developer experience
    will be invaluable in shaping the best practices and tools of this new paradigm.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法也带来了一系列挑战。当需要确定性结果时，我们如何确保？如何确保生成的代码高效且安全？当代码抽象时如何调试问题？这些是我们作为 Ruby 程序员独特装备处理的问题。我们社区的务实、创造力和专注于开发者体验的混合将在塑造这种新范式的最佳实践和工具方面非常宝贵。
- en: The potential benefits are game-changing. Faster development cycles, fewer bugs,
    and more maintainable, self-documenting codebases. And with the expressiveness
    and readability of Ruby, we have the opportunity to create prompt-driven DSLs
    that are a joy to work with. It’s a future where the role of the developer shifts
    from low-level code wrangler to high-level prompt composer.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 潜力巨大，开发周期更快，bug 更少，代码库更易维护和自我记录。而且借助 Ruby 的表现力和可读性，我们有机会创建使用即时 DSL（领域专用语言）的快捷驱动工具。这是一个开发者角色从低级代码编写者转变为高级即时驱动组合者的未来。
- en: The History of Declarative Coding and BDD
  id: totrans-split-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明性编码与 BDD 的历史
- en: It’s not the first time in computing history that people have tried to establish
    a declarative paradigm using natural language. In the past, there have been several
    attempts to create programming languages or frameworks that allow developers to
    express their intent using natural language-like syntax.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算历史上，并非首次有人试图使用自然语言建立声明性范式。过去曾多次尝试创建编程语言或框架，允许开发者使用类似自然语言的语法表达他们的意图。
- en: HYPERCARD IS AN interactive system designed to work as a unique information
    centre. It can be used to look for and store text, custom graphics and digitised
    photographs. Unlike a book, which has a linear format (you flip from one page
    to the next), HyperCard’s interactive capabilities let you associate any one piece
    of information with any other. By modelling itself on our thought processes (association
    processes), HyperCard lets you find out what you need to know in the easiest,
    and therefore fastest, way. Excerpt from a*rticle in* [***Music Technology, January
    1988***](https://www.muzines.co.uk/mags/MT/88/01/73)
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**HYPERCARD是一种交互式系统，旨在作为独特的信息中心运行**。它可以用来搜索和存储文本、自定义图形和数字化的照片。与书籍不同，书籍具有线性格式（您从一页翻到下一页），HyperCard
    的交互能力使您能够将任何一条信息与任何其他信息关联起来。通过模仿我们的思维过程（关联过程），HyperCard 让您能够以最简单、最快的方式找到所需知识。摘自*1988年1月的[《音乐技术》](https://www.muzines.co.uk/mags/MT/88/01/73)*文章。'
- en: For example, in the 1980s, there was a language called HyperTalk, used in Apple’s
    HyperCard, which aimed to make programming more accessible by using English-like
    commands. More recently, there have been attempts like [Inform 7](https://ganelson.github.io/inform-website/),
    a programming language for creating interactive fiction that uses a subset of
    English grammar.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在20世纪80年代，有一种名为HyperTalk的语言，用于苹果的HyperCard，旨在通过使用类似英语的命令使编程更加容易。最近也有像[Inform
    7](https://ganelson.github.io/inform-website/)这样的尝试，它是一种用于创建交互式虚构的编程语言，使用英语语法的子集。
- en: Inform is a programming language for creating interactive fiction, using natural
    language syntax. Using natural language and drawing on ideas from linguistics
    and from literate programming, Inform is widely used as a medium for literary
    writing, as a prototyping tool in the games industry, and in education, both at
    school and university level (where Inform is often assigned material for courses
    on digital narrative). It has several times ranked in the top 100 most influential
    programming languages according to the TIOBE index. Created in April 2006, it
    was open-sourced in April 2022.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: Inform是一种使用自然语言语法创建交互式虚构的编程语言。利用语言学和文学编程的思想，Inform广泛用作文学写作的媒介，在游戏行业中作为原型工具，以及在教育领域，包括学校和大学水平（Inform通常作为数字叙事课程的分配材料）。根据TIOBE指数，它已多次排名前100位最有影响力的编程语言之一。Inform于2006年4月创建，于2022年4月开源。
- en: However, these approaches all relied on structured language — while they used
    words and phrases that resembled natural language, they still required the developer
    to adhere to a specific, predefined syntax and grammar. The developer had to learn
    this “pseudo-English” and work within its constraints.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些方法都依赖于结构化语言，虽然它们使用类似自然语言的单词和短语，但仍要求开发者遵循特定预定义的语法和语法。开发者必须学习这种“伪英语”并在其约束内工作。
- en: 'In the mid-2000s, a new approach to software development started gaining traction:
    Behavior-Driven Development (BDD). BDD emerged as an evolution of Test-Driven
    Development (TDD), with a key difference: instead of focusing on testing individual
    units of code, BDD focused on defining the desired behavior of the system using
    a language that could be understood by all stakeholders, including non-technical
    ones.'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在21世纪中期，一种新的软件开发方法开始获得关注：行为驱动开发（BDD）。BDD作为测试驱动开发（TDD）的演进而出现，其主要区别在于：它不再专注于测试单个代码单元，而是通过一种可被所有利益相关者理解的语言来定义系统的期望行为，包括非技术人员。
- en: 'Excitement about BDD amongst me and my colleagues at Thoughtworks led to the
    creation of tools like RSpec, Cucumber and Pickle, which allowed developers to
    define application behavior using a structured form of natural language. My friend
    Aslak Hellesoy’s Gherkin syntax resembles English sentences, organized into scenarios
    and steps. For example:'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我和我在Thoughtworks的同事们来说，对BDD的兴奋促使我们创建了像RSpec、Cucumber和Pickle这样的工具，这些工具允许开发者使用结构化的自然语言来定义应用程序的行为。我朋友Aslak
    Hellesoy的Gherkin语法类似于英语句子，组织成场景和步骤。例如：
- en: '[PRE1]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These scenarios serve as both documentation and automated tests. Developers
    write code that links each step to a corresponding action or assertion in the
    application. When the tests are run, the tool reads the Gherkin scenarios and
    executes the linked code, ensuring that the application behaves as described.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景既作为文档，又作为自动化测试。开发者编写代码，将每个步骤与应用程序中相应的操作或断言关联起来。当运行测试时，工具读取 Gherkin 场景并执行关联的代码，确保应用程序的行为与描述一致。
- en: This approach had a significant impact, especially in the Ruby community, *where
    it was born*. It allowed teams to bridge the gap between business requirements
    and technical implementation. Business analysts, product managers, and even clients
    could contribute to writing these scenarios, ensuring that the development team
    had a clear, shared understanding of what needed to be built.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: This approach had a significant impact, especially in the Ruby community, *where
    it was born*. It allowed teams to bridge the gap between business requirements
    and technical implementation. Business analysts, product managers, and even clients
    could contribute to writing these scenarios, ensuring that the development team
    had a clear, shared understanding of what needed to be built.
- en: Moreover, by tying the application code directly to these human-readable scenarios,
    BDD made the codebase more maintainable and easier to understand. Developers could
    see not just what the code was doing, but why it was doing it. This made it easier
    to make changes and avoid introducing bugs.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: Moreover, by tying the application code directly to these human-readable scenarios,
    BDD made the codebase more maintainable and easier to understand. Developers could
    see not just what the code was doing, but why it was doing it. This made it easier
    to make changes and avoid introducing bugs.
- en: The problem was that while BDD and tools like Cucumber and Pickle represented
    a significant step towards using natural language in software development, they
    still required a level of structure and specificity in how the scenarios were
    written. They also require extensive implementation of “steps”.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: The problem was that while BDD and tools like Cucumber and Pickle represented
    a significant step towards using natural language in software development, they
    still required a level of structure and specificity in how the scenarios were
    written. They also require extensive implementation of “steps”.
- en: '[PRE2]'
  id: totrans-split-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I can tell you from personal experience that even though they look simple, steps
    are a nightmare to write and maintain. The AI-powered approach I’m envisioning
    takes BDD a couple, ahem, steps further.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: I can tell you from personal experience that even though they look simple, steps
    are a nightmare to write and maintain. The AI-powered approach I’m envisioning
    takes BDD a couple, ahem, steps further.
- en: 'Instead of requiring scenarios to be written in a specific format, an AI system
    can understand and generate code from free-form descriptions, or even from a conversation
    about the system requirements. Imagine the following:'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'Instead of requiring scenarios to be written in a specific format, an AI system
    can understand and generate code from free-form descriptions, or even from a conversation
    about the system requirements. Imagine the following:'
- en: 'Human: “When a user clicks the login button, they should be taken to a login
    page where they can enter their username and password. If they enter the correct
    details, they should be logged in and redirected to their dashboard. If they enter
    incorrect details, they should see an error message.”'
  id: totrans-split-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Human: “When a user clicks the login button, they should be taken to a login
    page where they can enter their username and password. If they enter the correct
    details, they should be logged in and redirected to their dashboard. If they enter
    incorrect details, they should see an error message.”'
- en: 'AI: “Do we support Oauth-based logins?'
  id: totrans-split-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'AI: “Do we support Oauth-based logins?'
- en: 'Human: Sure, but just Google for now.'
  id: totrans-split-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Human: Sure, but just Google for now.'
- en: 'AI: And how should I style it?'
  id: totrans-split-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'AI: And how should I style it?'
- en: 'Human: Show me a few options based on our typical style guide.'
  id: totrans-split-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Human: Show me a few options based on our typical style guide.'
- en: And so on and so forth…
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: And so on and so forth…
- en: In the aformentioned conversation (and in contrast to BDD), the AI system is
    generating not just the test scenarios, but also specification, code and visual
    design for this behavior. This is the kind of natural, conversational interaction
    that the advancements in AI are starting to make possible.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: In the aformentioned conversation (and in contrast to BDD), the AI system is
    generating not just the test scenarios, but also specification, code and visual
    design for this behavior. This is the kind of natural, conversational interaction
    that the advancements in AI are starting to make possible.
- en: The AI-powered future of software development promises to take the concept of
    natural language programming to a whole new level. It’s an exciting prospect,
    and one that the Ruby community, with its history of embracing innovative approaches
    to software development, is well-positioned to explore and pioneer — we were literally
    the ones that pioneered BDD.
  id: totrans-split-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: The AI-powered future of software development promises to take the concept of
    natural language programming to a whole new level. It’s an exciting prospect,
    and one that the Ruby community, with its history of embracing innovative approaches
    to software development, is well-positioned to explore and pioneer — we were literally
    the ones that pioneered BDD.
- en: So while BDD and tools like Cucumber and Pickle were groundbreaking in their
    time and are still widely used today, the AI-powered future of software development
    promises to take the concept of natural language programming to a whole new level.
    It’s an exciting prospect, and one that the Ruby community, with its history of
    embracing innovative approaches to software development, is well-positioned to
    explore and pioneer — we were literally the ones that pioneered BDD.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管BDD和像Cucumber和Pickle这样的工具在它们的时代具有开创性并且今天仍被广泛使用，但AI驱动的软件开发未来承诺将把自然语言编程的概念提升到一个全新的层次。这是一个令人兴奋的前景，而且是Ruby社区所能够探索和开拓的——毕竟我们可是BDD的先驱者。
- en: AI Woven into the Fabric of Ruby and Rails
  id: totrans-split-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby和Rails的AI融入之路
- en: I’ve been working with Ruby on Rails almost every day for almost 20 years at
    this point, so my perspective on how to get to the magical future described above
    involves weaving AI tightly into the fabric of Ruby and Rails at a fundamental
    level. LLMs could eventually be leveraged within the Ruby interpreter itself to
    enable magical experiences — intelligently inferring method names and arguments,
    seamlessly connecting disparate services and APIs, and optimizing code in real-time,
    but *first* I plan to include more and more AI integration in the building blocks
    that I use to put together applications in Ruby on Rails.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我已经在Ruby on Rails上工作了近20年，几乎每天都在用。因此，我如何实现上述“神奇未来”的视角包括将AI紧密融入到Ruby和Rails的基础层级中。LLM最终可能会在Ruby解释器内部得到利用，从而实现神奇的体验——智能推断方法名称和参数，无缝连接不同的服务和API，并实时优化代码，但*首先*我计划在我用来构建Ruby
    on Rails应用程序的基础组件中加入越来越多的AI集成。
- en: For example, when defining a function to pass to an LLM, instead of being verbose
    about parameters, [the framework I’m working on](https://github.com/OlympiaAI/raix-rails)
    would provide a smart parameters object that handles the mappings, derivations
    and calculations. Code that uses AI components such as smart parameters objects
    will inevitably start looking more and more like pseudocode.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在定义传递给LLM的函数时，[我正在开发的框架](https://github.com/OlympiaAI/raix-rails)会提供一个智能参数对象，而不是冗长地描述参数，该对象能处理映射、推导和计算。使用智能参数对象等AI组件的代码将不可避免地开始看起来更像伪代码。
- en: Some may criticize this as too magical, too abstract. But they leveled the same
    criticisms at Rails in the early days, and it’s evident how wrong they were about
    it. Will “they” criticize the approach I’m advocating for also? Absolutely. Let
    the gnashing of teeth commence once more.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会批评这太神奇，太抽象。但他们在Rails早期也对此提出了同样的批评，现在显然他们是错的。“他们”会对我所倡导的方法提出批评吗？当然会。让我们再次开始牙齿咬碎的抱怨吧。
