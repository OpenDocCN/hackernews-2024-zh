<!--yml

category: 未分类

date: 2024-05-27 13:04:32

-->

# Chris's Wiki :: blog/programming/ConfigureNoSourceCodeChanges

> 来源：[https://utcc.utoronto.ca/~cks/space/blog/programming/ConfigureNoSourceCodeChanges](https://utcc.utoronto.ca/~cks/space/blog/programming/ConfigureNoSourceCodeChanges)

通常，程序在构建时有配置设置，用于包含的功能、使用的路径等。有时，人们建议处理这些设置的方法不是通过像“configure”脚本（无论是由 [Autoconf](https://www.gnu.org/software/autoconf/manual/) 还是其他方式生成的）这样的系统，而是通过让人们将其设置编辑到像 Makefile 或头文件（在广义上的“源代码”）中的事物中。作为多年来花费大量时间和精力构建他人软件的人，我坚决认为你不应该这样做。

这种方法的核心问题不是你要求人们了解 Makefile 或者 config.h 的语法以配置你的软件，尽管这也是一个问题。核心问题是**你让人们修改你也会改动的文件**，例如当你发布一个新版本的软件，其中包含新的选项，你希望人们能够更改或配置。当这种情况发生时，你使每个升级你的软件的人都需要处理将他们的设置合并到你的更改中。合并更改很困难且容易出错，特别是如果人们没有记录他们所做更改的记录（如果你的配置说明是“编辑这些文件”，通常他们不会）。

多年来，关于维护系统的痛苦教训之一是，你确实不希望两个人修改同一个文件，包括软件提供者和你自己。这是极其有价值的现代运行时配置特性的核心洞见，例如“插入文件”（通过将您自己的文件放入某个目录来添加或更改内容，而不是一切都试图更新一个共同的文件）。当你告诉人们通过编辑头文件或者 Makefile，或者你提供的任何文件来配置你的程序时，你将他们推回到这个痛苦的过去。每一个新的发布，每一个他们从你的版本控制系统中拉取的更新，对他们来说都将是一种痛苦的源泉。

人们可以在发布之外完全维护（或可以维护）其构建时间配置的系统对于人们来说更容易管理。如何实现这一点并不重要，而且有许多相对简单的系统选项；你当然不需要 GNU Autoconf，甚至不需要 CMake。

这个推论是，如果你坚持让人们通过编辑你提供的文件来配置你的软件，那么这些文件应该对你是不可变的。你应该以空状态提供它们，并承诺永远不会更改，这样构建您软件的人就可以从旧版本的构建中复制它们到新版本的软件中（或者当他们从您的版本控制系统存储库中拉取时永远不会遇到合并冲突）。如果您的构建系统甚至不能处理这个限制，那么您就需要重新考虑。
