- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:24:19'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Subset Park: A Combinatory Rosetta Stone'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.zdsmith.com/posts/a-combinatory-rosetta-stone.html](https://blog.zdsmith.com/posts/a-combinatory-rosetta-stone.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2024-04-14'
  prefs: []
  type: TYPE_NORMAL
- en: In [Combinatory Programming](./combinatory-programming.html), we attempt to
    provide motivating examples for the various combinators identified as useful to
    everyday programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of that piece was to extract the basic concept of combinators from
    as much its context as possible, and present certain particularly useful combinators
    as higher-order functions callable inside of nearly any programming language,
    applicable to most styles of programming. In practice, of course, tacit forms—the
    style of programming that we can use combinator functions to achieve—are more
    at home in certain languages and certain contexts than others, and compose most
    nicely with other features of a programming environment: plentiful pure, first-class
    functions; partial application; and terse combinator syntax, among others.'
  prefs: []
  type: TYPE_NORMAL
- en: In this supplement, we can dig deeper into some of those examples; where useful,
    expressing the same logic in multiple styles, and at times commenting on features
    of different styles or languages and the effects they produce.
  prefs: []
  type: TYPE_NORMAL
- en: identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `maybeAbs` is a function which either calls `Math.abs` on `n` or returns
    it directly, depending on the value of `shouldNormalizeNegatives`. This is the
    most explicit, referring directly to `n` by name three times, but also the easiest
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript and Janet versions behave the same: we bind *either* the absolute-value
    function *or* `identity` to our new symbol depending on the value of the conditional.
    In later examples, we’ll see less trivial usages of `identity`.'
  prefs: []
  type: TYPE_NORMAL
- en: A Conditional Combinator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Though we haven’t put it into our personal library of combinators, we can imagine
    a function `agenda` that behaves like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, we can imagine a simple combinator that lets us express conditional
    logic tacitly. J’s Agenda `@.` is such a function. In the slightly silly J example
    above, we are able to reproduce behaviour closer to the JavaScript example: rather
    than using a conditional to choose a function `f` or `g`, which is then applied
    to some values, our J code takes a verb `between_negative_3_and_0`, which is then
    called on every element of the argument to `maybe_abs`. Thus we can use *both*
    `f` *and* `g` within a single call. In this example, `identity` is spelled `[`.'
  prefs: []
  type: TYPE_NORMAL
- en: compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of composed functions (as opposed to the minimal `identity` example
    above), explicit code rarely has many advantages over tacit code. We have to refer
    to `datum` twice, so:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to introduce a name;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not very short.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But in addition to that, the explicit version is structurally complex. Nested
    function calls are difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In both tacit versions, we avoid an unnecessary name in addition to obtaining
    a simpler structure, with less nesting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In J, function composition is an infix operator.
  prefs: []
  type: TYPE_NORMAL
- en: Absolute Difference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the explicit code requires us to bind to both `x` and `y`; in
    a case like subtraction, which is so intuitively transparent, this seems particularly
    unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Janet code also takes advantage of the fact that `-` is a normal function,
    and not an infix operator, while the JavaScript has to rely on Lodash’s `subtract`
    to get a first-class function that does subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The J code is another straightforward application of function composition. In
    this case, however, the composition of subtraction with absolute value is spelled
    `|@:-`, which is shorter than the variable name `absolute_difference`.
  prefs: []
  type: TYPE_NORMAL
- en: Array language practitioners will contend that this obviates the need for binding
    the verb to a name at all; why assign it to a variable name when it would require
    more characters than simply re-spelling it out each time?
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible answer: it’s more straightforward to understand the *semantics*
    of `absolute_difference` than of `|@:-`. I’m not a very experienced J programmer,
    so I can’t argue one way or the other.'
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s worth calling out that function composition is traditionally written “to
    the left”; that is, the innermost function is the last argument and the last function
    to be applied is the first in the argument list. This maps cleanly to traditional
    function call syntax—`f(g(x))` has `f` and `g` in the same order as `(compose
    f g)`—but ends up being harder to read, as the order of application isn’t the
    same as the order of the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Many newer languages have syntax, or standard library functions, to effectively
    perform function composition in reverse, so that the call to the “combinator”
    (such as it is) can be read in the same order as function application.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in Janet we could natively write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is not properly a combinator, because it’s not a higher-order function.
    It’s syntax for a particular tacit form of control flow; it represents the actual
    application of those two functions to `dirty-data`.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless we can imagine a so-called `pipe` that behaves just like `compose`
    but in reverse order, which might feel more comfortable to those programmers who
    have grown used to the conveniences of `->` and its cousins.
  prefs: []
  type: TYPE_NORMAL
- en: apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Absent `apply`, we explicitly destructure the two elements of the argument value
    and then pass them back to `Math.pow`. This is relatively verbose, though still
    readable. If we couldn’t avail ourselves of destructuring either, we’d be forced
    to write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Which begins to feel quite clumsy indeed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the explicit example, we availed ourselves of JavaScript’s infix exponent
    operator, `**`. In the tacit examples, we use their respective languages’ standard
    library `pow` function in order to be able to pass a first-class argument to the
    `apply` combinator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The K language isn’t really designed with tacit programming in mind, but, as
    a member of the array family, it nevertheless has some features that make certain
    tacit forms the most idiomatic way to write programs. One of them is that `apply`
    is spelled `.`. Here `.'` means “apply each”, that is, it applies `pow` to each
    pair in the list of pairs `exponentsAndBases`.
  prefs: []
  type: TYPE_NORMAL
- en: We have used the flipped form `exponentsAndBases` here, because the tacit form
    `pow`, without being flipped itself, expects the exponent first.
  prefs: []
  type: TYPE_NORMAL
- en: '`*/#` is itself an example of `compose`; as a function of two arguments, it
    applies `#` to them, creating an `exponent`-length array of `base`s, and then
    reduces `*` over them. In K, unlike J, function composition is not an infix operator;
    it’s accomplished simply by juxtaposing the two verbs `#` and `*/`.'
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript and Janet, juxtaposition is not very meaningful. On the other
    hand, we will see later on that J relies heavily on juxtaposition, but assigns
    the semantics of combinators more complex than `compose` to that syntax.
  prefs: []
  type: TYPE_NORMAL
- en: flip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Flipping Without `apply`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The minimal example for `flip` includes usage of `apply`, because that’s the
    most natural way to imagine dealing with data consisting of multiple ordered values,
    where the order must be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can also imagine cases where our combinator accepts a variadic
    function such that ordering comes into play. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this slightly artificial example, we want to both take some `x` to the `y`,
    as well as divide `y` by `x`. In a case where the `g` and `h` of a `recombine`
    call expect the same arguments, but in different orders, we can use `flip` with
    one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Flipping Under Partial Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up until now we’ve excluded from consideration the topic of *partial functions*;
    in practice, the easy availability of partial application makes more tacit programming
    convenient.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In Janet, with a built-in `partial` function, we can trivially use partial application
    to define `double`; we bind the first argument and produce a new function that
    takes a single argument and multiplies it by 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we would like to define `square` in terms of `math/pow`, the same technique
    isn’t naively applicable: in this case, the argument we want to bind is the second
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we can work in a tacit style by employing `flip`; now the argument
    we want to bind is the first argument to the function, so we can pass that flipped
    function directly to `partial`.
  prefs: []
  type: TYPE_NORMAL
- en: Flipping Under Partial Application (2)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another example, from a refactor of [bagatto](https://git.sr.ht/~subsetpark/bagatto/commit/1f10e88)
    into tacit style. To be refactored is a higher-order function which takes some
    attribute name and returns a function that calls `sort` by getting that attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In tacit style, this becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By calling `flip` on sort, we obtain a function which can easily have our new
    `by` applied as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: recombine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the case of J we see perhaps the starkest example of that language’s orientation
    towards tacit programming. J combines a few syntactic characteristics such that
    simple juxtaposition of verbs, that is, placing syntactic verbs directly next
    to each other with no operator, triggers the behaviour of application combinators.
    In the case of `mean`, we see that creating a so-called 3-train of 3 verbs, `f
    g h`, creates a new verb whose behaviour is analogous to `recombine(g, f, h)`,
    called a *fork* in J.
  prefs: []
  type: TYPE_NORMAL
- en: Min-max
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Plus or Minus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As in Absolute Difference above, we see that functions of two arguments, when
    treated explicitly, result in quite a bit of noise. Explicit `plusOrMinus` takes
    two arguments, neither of which has a particularly meaningful name (judging from
    the Lodash docs, under addition they should be named `augend` and `addend`; under
    subtraction, `minuend` and `subtrahend`—but what would we call them when both
    operations come into play?), each of which then has to be referred to twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s worth noting that in both our JavaScript and Janet examples, the distinction
    between a unary recombined function, like `minMax`, and a variadic one, like `plusOrMinus`,
    is purely semantic: the syntax of application doesn’t change when the number of
    arguments expected by `g` and `h` do.'
  prefs: []
  type: TYPE_NORMAL
- en: In the J example, on the other hand, our application syntax is by default infix;
    so while our `min_max` is written before its argument, our `plus_minus` is written
    in between its two arguments, syntactically identical to its constituent `g` and
    `h`.
  prefs: []
  type: TYPE_NORMAL
- en: item-getter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another example from [bagatto](https://git.sr.ht/~subsetpark/bagatto/commit/1f10e88)
    shows a real-world refactoring using `recombine`, as well as a non-trivial usage
    of `constant`.
  prefs: []
  type: TYPE_NORMAL
- en: '`item-getter` is a function which takes a path of keywords and should return
    a function that, given two arguments, will retrieve the attribute at that path
    in the second argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A brief test to demonstrate the expected behaviour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The explicit version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Tacit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The tacit version, at least with all of the names spelled out, is *not shorter*.
    And if we’re still trying to remember what `recombine` does, it’s no easier to
    read.
  prefs: []
  type: TYPE_NORMAL
- en: But once we have internalized the behaviour of `recombine` a little bit, the
    tacit example has the advantage of not having to introduce any additional names
    at all. We can read that it returns a function that calls `get-in` on its second
    argument and `path`.
  prefs: []
  type: TYPE_NORMAL
- en: Population Standard Deviation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we showcase the effectiveness of partial functions towards
    programming in a tacit style.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first place, it’s important to note that in our K code we’ve defined
    `pow` differently from the `apply` example: here we’ve opted for an explicit definition
    so that the arguments to pow are `base`, `exponent`, which is arguably the more
    natural ordering.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also defined `mean` using the K translation of `recombine`: where our
    J code in that example took advantage of *juxtaposition* to create a so-called
    *3-train*, which J defines to behave as `recombine`, K has no such built-in support.
    The only effect of juxtaposition is composition, as we saw in the example of `*/#`.
    Instead we’ve used the phrase `@\:`, which means “apply each of the functions
    on the left”, with an array containing `sum` and `length`, and composed `%/` to
    its left, reducing the array containing the results of both operations with division.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final definition, `std`, is a tacit expression describing the composition
    of all the operations performed iteratively in the JavaScript code. In particular
    I want to highlight the spelling `pow[;2]`. This is a so-called *projection*,
    and its semantics are to produce a function which fixes `2` as the second argument
    to the function `pow`. K’s primitive and flexible syntax for projections makes
    it extremely convenient to describe partial function application; whereas in our
    `partial` example above, we needed to include `flip` in order to bind `2` to the
    second argument of `pow`: K’s projection syntax allows partial application in
    any argument positions.'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting function is a juxtaposition of the following functions
  prefs: []
  type: TYPE_NORMAL
- en: '`1 mean\`: produce an array containing `x` and the mean of `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-/`: join those two values with `-`. Implicit in this step is the `map` that’s
    explicit in the JavaScript; as an array language, K “does the right thing” when
    subtracing a single value from an array of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pow[;2]''`: square the differences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mean @`: take the mean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%`: take the square root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases besides the explicit `@`, the juxtaposition of two verbs is syntactically
    treated as function composition, producing a single composed function.
  prefs: []
  type: TYPE_NORMAL
- en: Each Value is Unique
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'J boasts yet another specialization for tacit programming; whereas we’ve seen
    the 3-train create a *fork*, a 2-train (which we express in terms of `recombine`
    by passing in `identity` as either `g` or `h`) has its own combinatorial meaning:
    it creates a *hook*, such that `f g` behaves like `x => f(x, g(x))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Other members of the array family tend to reserve 2-trains for simple function
    composition, as we have seen in other K examples. In K, the specialized hook behaviour
    can be achieved with `n-dos`, where `1 g\ x` produces an array of `(x;g x)`, which
    we can then fold some `f` over. If `f` needed to be passed `g(x), x`, then we
    could reverse the array before folding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equivalently, we could use `eachleft` in the same way we did to write `mean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, the second of the two functions we apply is `::`, the identity function.
  prefs: []
  type: TYPE_NORMAL
- en: under
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In J, dyadic `under` is spelled Appose, `&:`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth noting that with only one argument, `under` behaves just like `compose`:
    `x => _.isEqual(_.sortBy(x))`. (Thus, monadic Appose `&:` is equivalent to At
    `@:`, which we’ve seen above!)'
  prefs: []
  type: TYPE_NORMAL
- en: The noteworthy difference, then, is how we want to wield the innermost function
    when given two or more arguments. Within `compose(f, g)`, all those arguments
    are passed to a single application of `g`, and the result is passed to `f`. Within
    `under`, `g` is treated as a single-argument function and each argument to the
    composition has `g` called on it individually.
  prefs: []
  type: TYPE_NORMAL
