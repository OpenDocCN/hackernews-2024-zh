<!--yml

类别：未分类

日期：2024-05-27 13:03:21

-->

# ImperialViolet - Let's Kerberos

> 来源：[https://www.imperialviolet.org/2024/04/07/letskerberos.html](https://www.imperialviolet.org/2024/04/07/letskerberos.html)

（我认为这值得思考，但不要太认真—不要惊慌。）

是否量子后的签名大小 [让你沮丧](https://dadrian.io/blog/posts/pqc-signatures-2024/)？您是否对部署量子后Web PKI感到绝望？别担心！对称加密也是量子后的！

当您连接到一个站点时，还要从DNS获取一个包含一些“CA”记录的记录。每个记录包含：

+   用于标识CA的UUID。

+   E[CA-key](server-CA-key, AAD=server-hostname)

+   密钥ID，以便CA可以从上述字段中找到“CA-key”。

“CA-key”是只有CA知道的对称密钥，“server-CA-key”是服务器和CA知道的对称密钥。

客户端找到三个这些UUID与客户端信任的CA匹配的CA记录。然后它向每个CA发送包含：

+   E[CA-key’](client-CA-key) — 即客户端和CA共享的密钥，加密给只有CA知道的密钥。我们稍后会解释客户端如何拥有这样的值。

+   CA-key’的密钥ID。

+   E[client-CA-key](client-server-key) — 客户端随机为每个CA生成客户端-服务器密钥。

+   来自服务器DNS的CA记录。

+   客户端连接的主机名。

CA可以解密“client-CA-key”，然后可以使用AAD来解密“server-CA-key”（来自客户端发送的DNS信息），该AAD要么是客户端指定的主机名，要么是具有通配符记录的主机名用第一个标签替换为`*`。

CA 回复 E[server-CA-key](client-server-key)，即客户端选择的密钥，加密给服务器。然后客户端可以与服务器建立TLS连接，将三个加密的客户端-服务器密钥发送给服务器，并且客户端和服务器可以使用连接的三个共享密钥进行Kyber密钥协商认证。

客户端和服务器都需要与每个CA建立的对称密钥才能工作。为此，它们需要与CA建立公钥认证连接。因此，这些连接将需要大的量子后签名，但这种成本可以分摊到客户端和服务器之间的许多连接中。（并且服务器将不得不通过标准挑战来证明它们可以合法地代表特定的主机名。）

一些要点：

+   CA可以看到客户端正在与哪些服务器交流，就像OCSP服务器一样。将需要技术和政策控制以防止该信息被滥用。例如，CA在至少SEV/TDX中运行经过审计的代码。

+   您需要至少三个CA才能取得成果。虽然我们今天有证书透明度，但这是一种事后审计机制，当前的WebPKI中单个CA的妥协仍然是一个问题。

+   CAs 可能需要发布一个针对每个主机名识别的服务器密钥 ID 日志。它们可以选择不记录记录，但是需要至少有三个恶意 CAs 才能威胁到任何事情。

+   联系 CAs 会增加额外的延迟。然而，可以将其与与服务器进行 Kyber 交换的过程重叠。客户端可以缓存并重复使用客户端-服务器密钥一段时间。

+   CAs 可以每天生成新的密钥。旧的密钥可以继续工作几天。服务器每天都在与 CAs 更新共享密钥。（在这里非常假设类似 ACME 的自动化。）

+   当事方用来建立共享密钥的公钥是非常长期的，就像今天的根密钥一样。

+   在这种模型中，不信任一个 CA 不必像今天那样是一件大事：要求站点设置至少五个受信任的 CAs，这样任何一个 CA 都可以被不信任而没有影响。即，这就像不信任证书透明度日志一样。

+   CAs 撤销操作简便且立即生效。

+   CAs 应该具有高可用性，但是系统可以通过使用其他 CAs 来处理一个 CA 不可用的情况。CA 处理的高可用部分设计为几乎无状态，因此应该可以非常好地扩展，并且使用任播地址应该相当稳健。
