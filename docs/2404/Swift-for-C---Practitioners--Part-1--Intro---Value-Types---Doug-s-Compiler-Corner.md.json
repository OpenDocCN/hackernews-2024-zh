["```\nprint(\"Hello, world!\") \n```", "```\nlet reader = \"dear C++ practitioner\"\nprint(\"\"\"\n      Hello, \\(reader)!\n\n      Today, we shall embark on learning a new programming language, Swift.\n      \"\"\") \n```", "```\nstd::vector<std::string> v1 = { \"Hello\", \"original\" };\nstd::vector<std::string> v2 = v1;\nv2[1] = \"copy\"; \n```", "```\nlet v1: [String] = [\"Hello\", \"original\"] \nvar v2 = v1 \nv2[1] = \"copy\"\nprint(v1) \nprint(v2) \n```", "```\nstruct LabeledPoint {\n  var x: Double\n  var y: Double\n  var label: String\n} \n```", "```\nlet p1 = LabeledPoint(x: 0, y: 0, label: \"origin\")\nvar p2 = p1\np2.label = \"center\"\n\nprint(p1) \nprint(p2) \n```", "```\nstruct LabeledPoint {\n  var x: Double\n  var y: Double\n  var label: String\n\n  init(x: Double, y: Double, label: String) {\n    self.x = x\n    self.y = y\n    self.label = label\n  }\n} \n```", "```\n init(x: Double, y: Double, label: String) {\n  self.y = self.x   \n  self.x = x\n  if Int.random(in: 0..<2) == 1 {\n    print(self) \n  }\n} \n```", "```\nlet p: LabeledPoint\nif y > 0 {\n  p = LabeledPoint(x: 0, y: 0, label: \"origin\")\n}\nprint(p) \n```", "```\n init() {\n  self.init(x: 0, y: 0, label: \"origin\")\n} \n```", "```\n init(_ other: LabeledPoint) {\n  self.x = other.x\n  self.y = other.y\n  self.label = other.label\n} \n```", "```\n func badSwapX(_ other: LabeledPoint) {\n  let tmpX = other.x\n  other.x = self.x  \n  self.x = tmpX     \n} \n```", "```\n mutating func reflectOverXAxis() {\n  y = -y\n} \n```", "```\n mutating func swapX(_ other: inout LabeledPoint) {\n  let tmpX = other.x\n  other.x = self.x\n  self.x = tmpX\n} \n```", "```\nvar p1 = LabeledPoint(x: 0, y: 0, label: \"Origin\")\nvar p2 = LabeledPoint(x: 1, y: 1, label: \"Upper right unit\")\np1.swapX(&p2) \n```", "```\n=== exclusivity.swift:28 ===\n   ┆\n26 │   var p1 = LabeledPoint(x: 0, y: 0, label: \"Origin\")\n27 │   var p2 = LabeledPoint(x: 1, y: 1, label: \"Upper right unit\")\n28 │   p1.swapX(&p1)\n   │   │        ╰─ note: conflicting access is here\n   │   ╰─ error: overlapping accesses to 'p1', but modification requires exclusive access; consider copying to a local variable\n29 │ \n```", "```\nvar globalOrigin = LabeledPoint(x: 0, y: 0, label: \"origin\")\n\nfunc swapXWithGlobalOrigin(_ other: inout LabeledPoint) {\n  other.swapX(&globalOrigin) \n}\n\nfunc somewhereElse() {\n  swapXWithGlobalOrigin(&globalOrigin) \n} \n```", "```\nSimultaneous accesses to 0x100e93008, but modification requires exclusive access.\nPrevious access (a modification) started at t`somewhereElse() + 42 (0x100e8e95a).\nCurrent access (a modification) started at:\n0    libswiftCore.dylib                 0x00007ff82b380890 swift::runtime::AccessSet::insert(swift::runtime::Access*, void*, void*, swift::ExclusivityFlags) + 444\n1    libswiftCore.dylib                 0x00007ff82b380ae0 swift_beginAccess + 66\n2    t                                  0x0000000100e8e8d0 swapXWithGlobalOrigin(_:) + 59\n3    t                                  0x0000000100e8e930 somewhereElse() + 51\n4    t                                  0x0000000100e8ea40 static Main.main() + 9\n5    t                                  0x0000000100e8ea50 static Main.$main() + 9\n6    t                                  0x0000000100e8ea70 main + 9\n7    dyld                               0x00007ff81aaa9c10 start + 1942\nFatal access conflict detected. \n```", "```\nenum FontSize {\n  case title\n  case paragraph\n  case footnote\n} \n```", "```\nlet fontSize: FontSize = .paragraph\n\nswitch fontSize {\n  case .title: print(\"Title\")\n  case .paragraph: print(\"Paragraph\")\n  case .footnote: print(\"Footnote\")\n} \n```", "```\nenum class FontSize {\n  title,\n  paragraph,\n  footnote\n};\n\nauto fontSize = FontSize::paragraph;\nswitch (fontSize) {\n  case FontSize::title: print(\"Title\"); break;\n  case FontSize::paragraph: print(\"Paragraph\"); break;\n  case FontSize::footnote: print(\"Footnote\"); break;\n} \n```", "```\nstruct Font {\n  var style: FontStyle = .sanSerif\n  var size: FontSize = .paragraph\n  var weight: FontWeight = .regular\n} \n```", "```\nlet font = Font(size: .title, weight: .bold) \n```", "```\nclass FontSize {\npublic:\n  enum Kind {\n    title,\n    paragraph,\n    footnote,\n    custom\n  };\n\nprivate:\n  Kind kind;\n  int points; \n\npublic:\n  FontSize() : kind(paragraph) { }\n  FontSize(Kind kind) : kind(kind) { assert(kind != custom); }\n\n  static FontSize forCustom() { \n    FontSize size;\n    size.kind = custom;\n    size.points = points;\n    return size;\n  }\n\n  explicit operator Kind() const { return kind; } \n\n  int getPoints() const {\n    assert(kind == custom);\n    return points;\n  }\n}; \n```", "```\ncase custom(points: Int) \n```", "```\nlet customFont: FontSize = .custom(points: 32) \n```", "```\nswitch fontSize {\n  case .title: print(\"Title\")\n  case .paragraph: print(\"Paragraph\")\n  case .footnote: print(\"Footnote\")\n  case .custom(let pt): print(\"\\(pt) points\")\n} \n```", "```\nindirect case scaled(size: FontSize, factor: Double) \n```", "```\nFontSize.scaled(size: .paragraph, factor: 1.2) \n```", "```\n=== FontSize.swift:1 ===\n 1 │ enum FontSize {\n   │      ╰─ error: recursive enum 'FontSize' is not marked 'indirect'\n 2 │   case title\n 3 │   case paragraph\n 4 │   case footnote\n 5 │   case custom(points: Int)\n 6 │   case scaled(size: FontSize, factor: Double)\n   │        ╰─ note: cycle beginning here: (size: FontSize, factor: Double) -> (.0: FontSize)\n 7 │ }\n 8 │ \n```", "```\n func scaled(by factor: Double) -> Self {\n  .scaled(size: self, factor: factor)\n} \n```", "```\nvar fonts = [Font(size: .title, weight: .bold), Font(size: .paragraph)] \nvar oldFonts = fonts  \nfonts.append(Font(size: .footnote))\nprint(fonts.count)    \nprint(oldFonts.count) \nfonts[1].weight = .bold \n```", "```\nvar fontsDict = [  \n  \"Title\" : Font(size: .title, weight: .bold), \n  \"Paragraph\" : Font(size: .paragraph)\n]\n\nvar oldFontsDict = fontsDict \nfontsDict[\"Footnote\"] = Font(size: .footnote) \nprint(fontDict.count)    \nprint(oldFontsDict.count) \n```", "```\n static func ==(lhs: Font, rhs: Font) -> Bool {\n  return lhs.style == rhs.style && lhs.size == rhs.size && lhs.weight == rhs.weight\n} \n```", "```\nstruct Font: Equatable {\n  var style: FontStyle = .sanSerif\n  var size: FontSize = .paragraph\n  var weight: FontWeight = .regular\n} \n```"]