- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:49:58'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: How to stream PostgreSQL CDC to Kafka and use Propel to get an instant API
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.propeldata.com/blog/postgresql-cdc-to-kafka](https://www.propeldata.com/blog/postgresql-cdc-to-kafka)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Learn how to stream PostgreSQL Change Data Capture (CDC) to a Kafka topic and
    serve the data via an API with Propel. This guide provides step-by-step instructions,
    from setting up your PostgreSQL database and Kafka broker to deploying the Debezium
    PostgreSQL connector and creating a Propel Kafka Datapool.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Change Data Capture (CDC) is the process of tracking and capturing changes to
    your data. In PostgreSQL, we can implement CDC efficiently using the transaction
    log so that, rather than running batch jobs to gather data, we can capture data
    changes as they occur continuously. This has numerous benefits, including allowing
    your applications to see and react to changes in near real-time with lower impact
    on your source systems. In this article, we'll walk you step-by-step through how
    to stream CDC from PostgreSQL to a [Propel Kafka Data Pool](https://www.propeldata.com/docs/connect-your-data/kafka)
    to get an instant data-serving API.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: What are we trying to do?
  id: totrans-split-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to power large-scale analytics applications with data coming from PostgreSQL.
    As we all know, PostgreSQL, as an OLTP database, is notoriously slow in handling
    analytical queries that process and aggregate large amounts of data.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: First, we want to capture all changes to our PostgreSQL database table(s) and
    send them as JSON messages (see below) to a [Kafka](https://kafka.apache.org/)
    topic.
  id: totrans-split-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we’ll need to configure  [Kafka Connect](https://docs.confluent.io/platform/current/connect/userguide.html#connect-userguide)
    and the [Debezium PostgreSQL connector](https://debezium.io/documentation/reference/2.6/connectors/postgresql.html)
    to stream the CDC to a Kafka topic.
  id: totrans-split-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, create a Propel Kafka Data Pool that ingests data from the Kafka topic
    and exposes it via a low latency API.
  id: totrans-split-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover how to deploy how to create and deploy all services in a Kubernetes
    cluster.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: How PostgreSQL CDC with Debezium works
  id: totrans-split-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will provide a quick overview of how PostgreSQL change data
    capture works with Debezium.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have a simple table:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
- en: 'You update a row with the following SQL statement:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-19
  prefs: []
  type: TYPE_PRE
- en: The change to the column <span class="code-exp">foo</span> will result in an
    “update” to the transaction log, which Debezium then transforms into the JSON
    message below and drops into a Kafka topic.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: 'CDC JSON with <span class="code-exp">before</span> and <span class="code-exp">after</span>:'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
- en: 'The Debezium PostgreSQL connector generates a data change event for each row-level
    <span class="code-exp">INSERT</span>, <span class="code-exp">UPDATE</span>, and
    <span class="code-exp">DELETE</span> operation. The <span class="code-exp">op</span>
    key describes the operation that caused the connector to generate the event. In
    this example, u indicates that the operation updated a row. Valid values are:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: <span class="code-exp">c</span> = create
  id: totrans-split-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <span class="code-exp">u</span> = update
  id: totrans-split-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <span class="code-exp">d</span> = delete
  id: totrans-split-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <span class="code-exp">r</span> = read (applies to only snapshots)
  id: totrans-split-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <span class="code-exp">t</span> = truncate
  id: totrans-split-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <span class="code-exp">m</span> = message
  id: totrans-split-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the Propel Kafka Datapool?
  id: totrans-split-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kafka [Data Pool](https://www.propeldata.com/docs/connect-your-data#key-concept-2-data-pools)
    lets you ingest real-time streaming data into Propel. It provides an instant low-latency
    API on top of Kafka to power real-time dashboards, streaming analytics, and workflows.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider using Propel on top of Kafka when:'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: You need an API on top of a Kafka topic.
  id: totrans-split-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to power real-time analytics applications with streaming data from
    Kafka.
  id: totrans-split-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to ingest Kafka messages into ClickHouse.
  id: totrans-split-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to ingest from [self-hosted Kafka](https://www.propeldata.com/docs/connect-your-data/kafka/guides/how-to-ingest-data-from-Kafka-into-propel?kafka-platform=self-hosted-kafka),
    [Confluent Cloud](https://www.propeldata.com/docs/connect-your-data/kafka/guides/how-to-ingest-data-from-Kafka-into-propel?kafka-platform=confluent),
    [AWS MSK](https://www.propeldata.com/docs/connect-your-data/kafka/guides/how-to-ingest-data-from-Kafka-into-propel?kafka-platform=aws-msk),
    or [Redpanda](https://www.propeldata.com/docs/connect-your-data/kafka/guides/how-to-ingest-data-from-Kafka-into-propel?kafka-platform=redpanda)
    into ClickHouse.
  id: totrans-split-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to transform or enrich your streaming data.
  id: totrans-split-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to power real-time personalization and recommendations for use cases.
  id: totrans-split-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have the PostgreSQL, Debezium, and Kafka set up, we’ll ingest the data
    into a Propel Kafka Data Pool to expose it via an API.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Minikube, PostgreSQL, Kafka, Kafka Connect, and Debezium
  id: totrans-split-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will walk through setting this up in a Kubernetes cluster on a Mac. This
    can be done in other environments, but Kubernetes is a common platform for hosting
    and running data streaming services in the cloud.  For this example, we will use
    [Minikube](https://minikube.sigs.k8s.io/docs/start/) to deploy our Kubernetes
    cluster, [Redpanda](https://redpanda.com/) to deploy our Kafka cluster, and [Helm](https://helm.sh/)
    to manage Kubernetes applications like PostgreSQL.  I’ll provide the Mac-specific
    commands but links to the installed services if you are running a different OS.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Minikube
  id: totrans-split-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Step 1:** **Install** [**Docker Desktop**](https://www.docker.com/products/docker-desktop/)'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
- en: '**Step 2:** **Install** [**Kubectl**](https://kubernetes.io/docs/tasks/tools/)'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Install minikube**'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-47
  prefs: []
  type: TYPE_PRE
- en: '**Step 4:** **Start minikube**'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-49
  prefs: []
  type: TYPE_PRE
- en: '**Step 5: Interact with your cluster**'
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-51
  prefs: []
  type: TYPE_PRE
- en: '**Step 6:** **Install helm**'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: Setting up PostgreSQL
  id: totrans-split-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Step 1: Install the PostgreSQL Helm Chart with extended configuration**'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: Extend the configuration to set the <span class="code-exp">wal_level</span>
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-56
  prefs: []
  type: TYPE_PRE
- en: '**Step 2:** **Connect to PostgreSQL using the PostgreSQL CLI Create the database**'
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-58
  prefs: []
  type: TYPE_PRE
- en: '**Step 3: Create the table**'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-60
  prefs: []
  type: TYPE_PRE
- en: '**Step 4: Create a PostgreSQL user**'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a PostgreSQL user with the necessary privileges for Debezium to stream
    changes from the PostgreSQL source tables, run this statement with superuser privileges:'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-63
  prefs: []
  type: TYPE_PRE
- en: Setting up Kafka (Redpanda)
  id: totrans-split-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Step 1: Add the helm repo and install dependencies**'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-66
  prefs: []
  type: TYPE_PRE
- en: '**Step 2: Configure and install Redpanda**'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-68
  prefs: []
  type: TYPE_PRE
- en: '**Step 3: Install the Redpanda client <span class="code-exp">rpk</span>**'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-split-70
  prefs: []
  type: TYPE_PRE
- en: '**Step 4:** **Create an alias to simplify the <span class="code-exp">rpk</span>
    commands**'
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-split-72
  prefs: []
  type: TYPE_PRE
- en: '**Step 5: Describe the Redpanda Cluster**'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
- en: '**Step 6: Create a user**'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-split-76
  prefs: []
  type: TYPE_PRE
- en: '**Step 7: Create an** [**ACL**](https://docs.redpanda.com/current/manage/security/authorization/#create-acls)
    **for the user <span class="code-exp">blog</span>**'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-split-78
  prefs: []
  type: TYPE_PRE
- en: Setting up Kafka Connect
  id: totrans-split-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Step 1:  Create a namespace**'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-split-81
  prefs: []
  type: TYPE_PRE
- en: '**Step 2: Create the Service**'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: Below is the manifest you’ll need to apply to set up the Kafka Connect service
    with your Redpanda broker (see above).  Copy the manifest below and provide the
    needed values to configure the service for your environment. In the example below,
    we are connecting with <span class="code-exp">SASL_PLAINTEXT</span> and <span
    class="code-exp">SCRAM-SHA-256</span>, ensure that <span class="code-exp">CONNECT_SASL_JAAS_CONFIG</span>
    is using <span class="code-exp">org.apache.kafka.common.security.scram.ScramLoginModule</span>
    and that you have set the username and password for both the <span class="code-exp">CONNECT_</span>
    and <span class="code-exp">PRODUCER_</span> keys.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-split-84
  prefs: []
  type: TYPE_PRE
- en: Use <span class="code-exp">kubectl</span> to install the manifest and start
    the Kafka Connect pod in your cluster.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-split-86
  prefs: []
  type: TYPE_PRE
- en: After you apply the manifest, you should get the following output.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-split-88
  prefs: []
  type: TYPE_PRE
- en: Check the pod log files to ensure the service can log in to the broker. You
    should see the following in the logs if everything has been configured correctly.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-split-90
  prefs: []
  type: TYPE_PRE
- en: Check that the <span class="code-exp">connect-offsets</span> topic has been
    created on the Redpanda broker.
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-split-92
  prefs: []
  type: TYPE_PRE
- en: Setting up the Debezium PostgreSQL Connector
  id: totrans-split-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must create a topic to store the CDC messages before deploying the Debezium
    PostgreSQL connector to the Kafka Connect service.   If you take a look at the
    config below we’ve set the property <span class="code-exp">topic.prefix</span>
    to “blog” <span class="code-exp">andpublication.autocreate.mode</span> to “filtered”
    and set the <span class="code-exp">table.include.list</span> to “public.simple”.
     This configures the connector to write the CDC messages to a topic named <span
    class="code-exp">blog.public.simple</span>, use the command below to create the
    topic, then deploy the connector using the cURL command. You’ll need to provide
    your environment-specific details for connecting to your PostgreSQL server and
    the username/password for the Redpanda service you used above.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1:  **Create a topic in Redpanda'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-split-96
  prefs: []
  type: TYPE_PRE
- en: Install the Debezium PostgreSQL connector using cURL.  You’ll need to fetch
    the password for the PostgreSQL user and fill it in below.  We will also set up
    port forwarding from the Kafka Connect service to our local host.
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Get the PostgreSQL password**'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-split-99
  prefs: []
  type: TYPE_PRE
- en: '**Step 3: Forward the Kafka-Connect service port (8083)**'
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-split-101
  prefs: []
  type: TYPE_PRE
- en: '**Step 4: Deploy the Debezium Postgres Connector with cURL**'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-split-103
  prefs: []
  type: TYPE_PRE
- en: Insert data and validate the setup
  id: totrans-split-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s validate the CDC messages are landing in the topic we created; we’ll insert
    some data into our PostgreSQL table and then consume a message from the topic.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Connect to the database**'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-split-107
  prefs: []
  type: TYPE_PRE
- en: '**Step 2: Insert data into the table**'
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-split-109
  prefs: []
  type: TYPE_PRE
- en: '**Step 3: Consume the CDC message from the topic**'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-split-111
  prefs: []
  type: TYPE_PRE
- en: We’ve validated that the Debezium CDC messages with <span class="code-exp">before</span>-and-<span
    class="code-exp">after</span> values are landing in the topic.  Don’t be concerned
    if <span class="code-exp">before</span> is not filled out in this example; if
    you take a look, the “op” is <span class="code-exp">c</span>, which means a new
    row was created in the table.
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
- en: Expose Redpanda to the internet
  id: totrans-split-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploying all of the services locally using <span class="code-exp">minikube</span>
    is a great way to do local development and get hands-on experience without paying
    a cloud provider. However, for us to use Propel and create a Kafka Data Pool,
    Propel has to connect to our Redpanda topic. There are a number of ways that this
    can be accomplished. For the sake of simplicity, we are going to install a reverse
    proxy and create a TCP Tunnel to expose the Redpanda port to the internet.  The
    reverse proxy we are going to use is called [LocalXpose](https://localxpose.io/).
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
- en: 💡 To use the LocalXpose TCP Tunnel with a [dedicated port](https://localxpose.io/docs/tunnels/tcp),
    I had to pay $6\.  Other free services also do this, but you can’t control which
    port the tunnel is on.  Redpanda has a limitation when creating the external NodePort
    that restricts it to ports <span class="code-exp">30000-32767</span>.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Install LocalXpose and <span class="code-exp">kcat</span>**'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
- en: '[https://localxpose.io/docs](https://localxpose.io/docs)'
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-split-118
  prefs: []
  type: TYPE_PRE
- en: '**Step 2: Start the TCP Tunnel**'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-split-120
  prefs: []
  type: TYPE_PRE
- en: You can now see the running tunnels. Copy the domain name in <span class="code-exp">From</span>,
    e.g., <span class="code-exp">us.localx.io</span>. This will be used in step 3
    and later when creating the Kafka Data Pool.
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Upgrade the Redpanda install and expose an external NodePort**'
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
- en: Save the yaml below to <span class="code-exp">external-dns.yaml</span>, and
    replace the <span class="code-exp-bracket">domain</span> with the value from step
    2.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-split-124
  prefs: []
  type: TYPE_PRE
- en: Upgrade Redpanda.
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-split-126
  prefs: []
  type: TYPE_PRE
- en: '**Step 4: Forward the traffic to <span class="code-exp">minikube</span>**'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-split-128
  prefs: []
  type: TYPE_PRE
- en: '**Step 5: Validate you can connect externally using <span class="code-exp">kcat</span>**'
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-split-130
  prefs: []
  type: TYPE_PRE
- en: You can now tunnel traffic to Redpanda running in <span class="code-exp">minikube</span>,
    allowing Propel’s backend to connect and consume the CDC messages from the topic.
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
- en: Create a Propel Kafka Data Pool
  id: totrans-split-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Login to the [Propel console](https://console.propeldata.com) or create a new
    account.  Then choose your environment and create a new Kafka Datapool, for this
    example I’m using the <span class="code-exp">development</span> environment.
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
- en: Next, choose Add new credentials to configure the connection to our Redpanda
    cluster. (use the domain and port from the TCP Tunnel that you created above for
    the Bootstrap Servers)
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
- en: Click Create and test Credentials
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the topics are visible
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
- en: Next, choose the topic <span class="code-exp">blog.public.simple</span> to start
    pulling in the CDC data.
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
- en: Click Next to choose the primary timestamp.
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
- en: Give the Data Pool a unique name.
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
- en: Click Next to start syncing the data from the topic into Propel.
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
- en: Once you see two records in the Datapool, you can click Preview Data.
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
- en: Query the data
  id: totrans-split-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To query the data we have in Propel, you’ll need to create an Application. Follow
    the guide in the [docs](https://www.propeldata.com/docs/applications) to create
    an application. Once you’ve created an Application, you can get a token, as seen
    in the image below. We’ll use that token in the subsequent API calls below.
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
- en: Use the [Data Grid API](https://www.propeldata.com/docs/query-your-data/data-grid)
    to query the data in the newly created Kafka Data Pool.  Make sure to copy the
    token you created above and replace <span class="code-exp-bracket">TOKEN</span>
    with the value.  You will also need to replace <span class="code-exp-bracket">DATAPOOL_ID</span>
    with the ID of the newly created Kafka Data Pool. Copy the <span class="code-exp">curl</span>
    command below and execute it from the command line.
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-split-145
  prefs: []
  type: TYPE_PRE
- en: This will return a Data Grid with headers and rows.
  id: totrans-split-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-split-147
  prefs: []
  type: TYPE_PRE
- en: Update the source PostgreSQL database
  id: totrans-split-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we update the PostgreSQL database with a new value for one of the rows, we’ll
    see that change reflected in the Propel Data Pool. Let’s execute the SQL statement
    below and re-run the GraphQL query we ran above.
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-split-150
  prefs: []
  type: TYPE_PRE
- en: When we re-run the GraphQL query, we get the following response.
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-split-152
  prefs: []
  type: TYPE_PRE
- en: This shows that we have three rows in our Data Pool; it reflects the raw CDC
    messages that have been sent to the Kafka Data Pool. In order to use the data
    for analytics, we need to transform it to correctly represent the current state
    in the source database.
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
- en: Create a real-time transformation to unpack the CDC JSON message
  id: totrans-split-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’re getting the stream of CDC messages to Propel and landing them
    in a Kafka Data Pool, we need to write some SQL to transform the messages based
    on the “op” type.  The columns we are interested in using are <span class="code-exp">id</span>,
    <span class="code-exp">_timestamp</span>, and <span class="code-exp">foo</span>.
     Our <span class="code-exp">SELECT</span> statement below will query the source
    table <span class="code-exp">blog-post</span> and extract <span class="code-exp">id</span>
    and <span class="code-exp">foo</span> from <span class="code-exp">_propel_payload.after</span>.
     This will handle both the create and update operations.  In the case of an update
    operation a duplicate row will be inserted and then de-duped by Propel.  This
    will ensure that when we set <span class="code-exp">id</span> as the <span class="code-exp">uniqueId</span>
    column in the MaterializedView only one version of the <span class="code-exp">id</span>
    exists with the latest value from the source table.
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-split-156
  prefs: []
  type: TYPE_PRE
- en: You should get a response like the one below.
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-split-158
  prefs: []
  type: TYPE_PRE
- en: Query the Materialized View Data Pool
  id: totrans-split-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve created the MaterialzedView let’s query the Data Pool that was
    created along with it.  Replace <span class="code-exp-bracket">token</span> with
    the token you created earlier, and use the response from the above <span class="code-exp">curl</span>
    command to get the destination data pool id.  This is available at <span class="code-exp">data.createMaterializedView.materializedView.destination.id</span>
    in the JSON.  Replace <span class="code-exp">datapool_id</span>with that value
    and run the <span class="code-exp">curl</span> command from the command line.
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-split-161
  prefs: []
  type: TYPE_PRE
- en: The response you get should only have two rows and the updated value of <span
    class="code-exp-bracket">baz</span> for <span class="code-exp">9cb52b2a-8ef2-4987-8856-c79a1b2c2f73</span>.
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-split-163
  prefs: []
  type: TYPE_PRE
- en: Visualize the results
  id: totrans-split-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s write a small <span class="code-exp">node.js</span> application that combines
    all of the Propel concepts and renders a table with the results from the MaterializedView.
     Instead of providing a token, we’ll use the Propel API to mint a token using
    the OAuth2 client credentials from the Propel Application we created.  These are
    found in the Propel console within the Applications section, as seen below.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: OAuth2 client credentials**'
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Set environment variables**'
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
- en: Replace the tokens with the values from the console, then paste and execute
    the commands.
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-split-169
  prefs: []
  type: TYPE_PRE
- en: '**Step 3: Install the dependencies**'
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-split-171
  prefs: []
  type: TYPE_PRE
- en: '**Step 4: Copy the code**‍'
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
- en: Copy the code below and replace <span class="code-exp-bracket">DATAPOOL_ID</span>
    with the data pool ID for the MaterializedView from above.
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-split-174
  prefs: []
  type: TYPE_PRE
- en: '**Step 5: Run the script**'
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-split-176
  prefs: []
  type: TYPE_PRE
- en: Wrap up
  id: totrans-split-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In wrapping up this post, it's important to recap the key skills and knowledge
    you've acquired. You have learned how to effectively stream PostgreSQL Change
    Data Capture (CDC) to a Propel Kafka DataPool, a significant step in managing
    real-time data.
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
- en: Further, you've gained the ability to query this data, which opens up a wealth
    of opportunities for analysis and insights. This guide also walked you through
    the process of updating the source PostgreSQL database, ensuring that you can
    maintain the accuracy and relevance of your data.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
- en: One of the highlights of this guide was teaching you how to create a real-time
    transformation to unpack the CDC JSON message. This is a fundamental skill that
    elevates your data management capabilities, enabling you to manipulate and interpret
    data for various applications.
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you've learned how to visualize the results. Visualization plays a
    crucial role in data analysis, making complex data more understandable, revealing
    trends and outliers, and contributing to more effective communication.
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
- en: We hope you found the content both informative and practical and that you enjoyed
    the learning process. Propel is dedicated to empowering you with the tools and
    knowledge to transform your data into valuable insights. We look forward to supporting
    you in your future endeavors with Propel. Keep exploring and transforming your
    data!
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
