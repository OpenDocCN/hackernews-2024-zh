- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:06:59'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: The UX of UUIDs | Unkey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://unkey.dev/blog/uuid-ux](https://unkey.dev/blog/uuid-ux)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'TLDR: Please don''t do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#the-baseline-ensuring-global-uniqueness)The baseline: Ensuring global uniqueness'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unique identifiers are essential for distinguishing individual entities within
    a system. They provide a reliable way to ensure that each item, user, or piece
    of data has a unique identity. By maintaining uniqueness, applications can effectively
    manage and organize information, enabling efficient operations and facilitating
    data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s not pretend like we are Google or AWS who have special needs around this.
    Any securely generated UUID with 128 bits is more than enough for us. There are
    lots of libraries that generate one, or you could fall back to the standard library
    of your language of choice. In this blog, I'll be using Typescript examples, but
    the underlying ideas apply to any language.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Stopping here is an option, but let''s take the opportunity to enhance the
    user experience with small yet effective iterative changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Make them easy to copy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prefixing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More efficient encoding
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing the length
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[](#copying-uuids-is-annoying)Copying UUIDs is annoying'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Try copying this UUID by double-clicking on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you're lucky, you got the entire UUID but for most people, they got a single
    section. One way to enhance the usability of unique identifiers is by making them
    easily copyable. This can be achieved by removing the hyphens from the UUIDs,
    allowing users to simply double-click on the identifier to copy it. By eliminating
    the need for manual selection and copy-pasting, this small change can greatly
    improve the user experience when working with identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing the hyphens is probably trivial in all languages, here’s how you can
    do it in js/ts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Try copying it now, it’s much nicer!
  prefs: []
  type: TYPE_NORMAL
- en: '[](#prefixing)Prefixing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you ever accidentally used a production API key in a development environment?
    I have, and it’s not fun. We can help the user differentiate between different
    environments or resources within the system by adding a meaningful prefix. For
    example, Stripe uses prefixes like `sk_live_` for production environment secret
    keys or `cus_` for customer identifiers. By incorporating such prefixes, we can
    ensure clarity and reduce the chances of confusion, especially in complex systems
    where multiple environments coexist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Naming prefixes is an art just like naming variables. You want to be descriptive
    but be as short as possible. I'll share ours further down.
  prefs: []
  type: TYPE_NORMAL
- en: '[](#encoding-in-base58)Encoding in base58'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of using a hexadecimal representation for identifiers, we can also consider
    encoding them more efficiently, such as base58\. Base58 encoding uses a larger
    character set and avoids ambiguous characters, such as upper case `I` and lower
    case `l` resulting in shorter identifier strings without compromising readability.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, an 8-character long base58 string, can store roughly 30.000 times
    as many states as an 8-char hex string. And at 16 chars, the base58 string can
    store 889.054.070 as many combinations.
  prefs: []
  type: TYPE_NORMAL
- en: You can probably still do this with the standard library of your language but
    you could also use a library like [nanoid](https://github.com/ai/nanoid) which
    is available for most languages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We generated a 22 character long ID here, which can encode ~100x as many states
    as a UUID while being 10 characters shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Characters | Length | Total States |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| UUID | 16 | 32 | 2^122 = 5.3e+36 |'
  prefs: []
  type: TYPE_TB
- en: '| Base58 | 58 | 22 | 58^22 = 6.2e+38 |'
  prefs: []
  type: TYPE_TB
- en: '*The more states, the higher your collision resistance is because it takes
    more generations to generate the same ID twice (on average and if your algorithm
    is truly random)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#changing-the-entropy)Changing the entropy'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all identifiers need to have a high level of collision resistance. In some
    cases, shorter identifiers can be sufficient, depending on the specific requirements
    of the application. By reducing the entropy of the identifiers, we can generate
    shorter IDs while still maintaining an acceptable level of uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the length of your IDs can be nice, but you need to be careful and
    ensure your system is protected against ID collissions. Fortunately, this is pretty
    easy to do in your database layer. In our MySQL database we use IDs mostly as
    primary key and the database protects us from collisions. In case an ID exists
    already, we just generate a new one and try again. If our collision rate would
    go up significantly, we could simply increase the length of all future IDs and
    we’d be fine.
  prefs: []
  type: TYPE_NORMAL
- en: '| Length | Example | Total States |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| nanoid(8) | re6ZkUUV | 1.3e+14 |'
  prefs: []
  type: TYPE_TB
- en: '| nanoid(12) | pfpPYdZGbZvw | 1.4e+21 |'
  prefs: []
  type: TYPE_TB
- en: '| nanoid(16) | sFDUZScHfZTfkLwk | 1.6e+28 |'
  prefs: []
  type: TYPE_TB
- en: '| nanoid(24) | u7vzXJL9cGqUeabGPAZ5XUJ6 | 2.1e+42 |'
  prefs: []
  type: TYPE_TB
- en: '| nanoid(32) | qkvPDeH6JyAsRhaZ3X4ZLDPSLFP7MnJz | 2.7e+56 |'
  prefs: []
  type: TYPE_TB
- en: '[](#conclusion)Conclusion'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By implementing these improvements, we can enhance the usability and efficiency
    of unique identifiers in our applications. This will provide a better experience
    for both users and developers, as they interact with and manage various entities
    within the system. Whether it's copying identifiers with ease, differentiating
    between different environments, or achieving shorter and more readable identifier
    strings, these strategies can contribute to a more user-friendly and robust identification
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '[](#ids-and-keys-at-unkey)IDs and keys at Unkey'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lastly, I'd like to share our implementation here and how we use it in our [codebase](https://github.com/unkeyed/unkey/blob/main/internal/id/src/index.ts).
    We use a simple function that takes a typed prefix and then generates the ID for
    us. This way we can ensure that we always use the same prefix for the same type
    of ID. This is especially useful when you have multiple types of IDs in your system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: And when we use it in our codebase, we can ensure that we always use the correct
    prefix for the correct type of id.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: I've been mostly talking about identifiers here, but an api key really is just
    an identifier too. It's just a special kind of identifier that is used to authenticate
    requests. We use the same strategies for our api keys as we do for our identifiers.
    You can add a prefix to let your users know what kind of key they are looking
    at and you can specify the length of the key within reason. Colissions for API
    keys are much more serious than ids, so we enforce secure limits.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite common to prefix your API keys with something that identifies your
    company. For example [Resend](https://resend.com) are using `re_` and [OpenStatus](https://openstatus.dev)
    are using `os_` prefixes. This allows your users to quickly identify the key and
    know what it's used for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
