<!--yml

类别：未分类

日期：2024-05-27 12:54:48

-->

# BASIC and the ROMs that changed the world (and then disappeared) | 由Jo Christian Oterhals | Medium

> 来源：[https://jcoterhals.medium.com/basic-and-the-roms-that-changed-the-world-and-then-disappeared-38318db4611c](https://jcoterhals.medium.com/basic-and-the-roms-that-changed-the-world-and-then-disappeared-38318db4611c)

就实际目的而言，如今BASIC很少被使用，大多数人已经忘记了它。但考虑到我对它的赞赏，为什么会这样呢？我认为有三个原因，随着时间的推移，它们的累积效应是毁灭性的。

理由 #1。

IBM PC及其克隆后来完全占据了家用计算机市场。在这些PC上，ROM中几乎没有东西。相反，MS-DOS通常从软盘或硬盘加载，突然操作系统本身成为了计算机的面孔。而不是BASIC。

从一开始，你与BASIC相距一度。如果你想使用它，在启动DOS后*再*显式启动它。在这种意义上，BASIC就像任何其他应用程序一样。在BASIC应用程序中，你像在前一代家用计算机上那样输入和运行BASIC程序。但具有讽刺意味的是，在DOS统治着计算机的世界中，没有直接的方法从MS-DOS命令行运行保存的BASIC程序。你必须先加载BASIC环境然后从那里运行它们。

总体而言，在这些计算机上的BASIC感觉像是事后补充。

理由 #2。

如果Street BASIC早期引起了计算机系统之间的不兼容性，那么基于新操作系统的个人电脑可能会在*系统内部*引起不兼容性。

由于MS-DOS的BASIC是从磁盘运行的，你可以获取并使用你喜欢的任何版本的BASIC。例如，Borland的Turbo Basic可能比微软的更吸引你。你可以称之为选择的自由，这是我们大多数人所珍视的东西。但缺点是，如果你把你的程序给朋友，你不能确定你朋友的BASIC和你的是否相同。

即使你选择不使用非捆绑的BASIC，而是完全使用随MS-DOS提供的版本，你可能也会遇到麻烦。在MS-DOS 5.0之前，GW-BASIC与操作系统捆绑在一起。它基本上类似于你在家用计算机上找到的达特茅斯灵感。但如果你安装了MS-DOS 5.0或更新版本，GW-BASIC已被QBasic替代。

QBasic是现代BASIC的一种尝试。从某种角度来看，它确实是一种改进。从使用的角度来看，它是非常不同的。你在专用编辑器中编辑你的BASIC程序，当你运行它们时，编辑器会完全被一个新屏幕替换。在这个屏幕上，你可以与你的程序交互。完成后，交互式屏幕关闭，你回到编辑器中。编程和使用之间的紧密耦合现在已经消失了。

语言上来说，QBasic 摆脱了行号（除非你坚持使用它们）。相反，它引入了带有命名参数的标签和子程序。你还可以区分局部变量和全局变量。在一定程度上，你甚至可以显式地为变量指定类型。它看起来更像是即将到来的 BASIC 变体，而不是它所取代的旧版。但尽管这些变化代表了语言的成熟，它也标志着将 BASIC 从线性描述算法的语言转变为非线性描述的起点。

所有这些无疑使 BASIC 变得更好。但这些变化也使得这种语言对初学者来说变得更难理解。BASIC 不再是基础。

至于兼容性，GW-BASIC 程序在 QBasic 中大多数情况下可以正常运行，前提是程序保存为 ASCII 文件。但由于这是一个非默认选项，很少有程序这样保存。反过来则几乎不可能。鉴于 QBasic 的改进和现代化，为其编写的程序无法在 GW-BASIC 上运行。

即使你和你朋友的软件堆栈是相同的，问题仍可能出现。由于PC的模块化，你甚至不能确定它们之间支持的图形模式是否相同。这是一个可以解决的问题，但仍然是一个麻烦。

理由 #3.

Windows 及类似的图形用户界面进一步将 BASIC 与其根源拉开了距离，因为它们是完全不同的东西。当然，在窗口化的世界中选择保持基于文本是可能的。但在那种情况下，保持基于文本却并不是很令人满意。

将 BASIC 调整以适应 Windows 的主要问题在于，Windows 程序是窗口、按钮、文本字段等组成的集合。尽管软件的某些部分可能有点逐步进行，但大多数软件由独立处理每个按钮、文本字段和窗口的片段组成。代码没有明显的入口点，不能像从 A 到 Z 的步骤一样阅读和理解。

我们现在也进入了一个环境功能如此丰富的世界，以至于不再可能为计算机的每个功能都有一个单独的命令。库和模块变得必不可少，记法变成了类似 Module.Class.Sub() 这样的形式。模块化使得生态系统变得如此庞大，几乎没有人能够完全掌握它了。

这是不可避免的，但现代编程语言及其相应的库的规模如此之大，以至于新手的入门门槛比80年代大了数个数量级。
