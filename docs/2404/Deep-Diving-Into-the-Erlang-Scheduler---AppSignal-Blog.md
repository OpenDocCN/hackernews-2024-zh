<!--yml

category: 未分类

date: 2024-05-27 13:27:04

-->

# 深入探索 Erlang 调度器 | AppSignal 博客

> 来源：[https://blog.appsignal.com/2024/04/23/deep-diving-into-the-erlang-scheduler.html](https://blog.appsignal.com/2024/04/23/deep-diving-into-the-erlang-scheduler.html)

Erlang 以其出色的容错性和高并发性而闻名。Erlang 的调度器高效地处理许多轻量级进程。调度器在管理进程、并发性和系统资源方面发挥着关键作用，有效地协调这些元素，帮助 Erlang 在其应用程序中保持容错性并支持高水平的并发。

本文将剖析调度器的一些关键组成部分，并揭示其内部工作原理。

让我们开始吧！

## Erlang 中的进程

Erlang 进程是由 Erlang 运行时系统管理的轻量级、独立的执行单元。它们由 Erlang 虚拟机（BEAM）创建和调度，每个 Erlang 进程都有自己的内存空间。这些不应与操作系统进程或线程混淆。

操作系统进程是由操作系统管理的实体，通常在内存和资源方面具有更多开销，以及进程间通信。而线程比操作系统进程轻量级，但仍比典型的 Erlang 进程更重，并且在进程内共享一个公共内存空间。线程间通常更容易进行同一进程的同步，但仍需同步机制。

另一方面，Erlang 虚拟机（BEAM）能够生成多个轻量级进程，具有独立的内存空间，并能够通过消息传递轻松通信。虚拟机内的调度程序管理进程，为进程分配资源，并在它们之间进行上下文切换。

## Erlang 调度器架构 — 抢占式调度

在单核设置中，每次只能有一个进程占用CPU核心。为了模拟并发系统，调度程序采用了一种抢占式的、基于优先级的调度机制（别担心，我们很快会探讨这意味着什么），快速在可用进程之间切换，从而产生所有进程都在同时执行的假象。艾伦虚拟机（BEAM）按顺序调度进程运行，一个进程运行一段时间后被挂起，然后允许另一个进程接替其执行。这种进程管理策略是并发的特征，并不涉及真正的并行（这在单核系统上是不可能的）。由于快速的上下文切换，任务看起来是并发运行的，尽管它们实际上是在单个核心上顺序执行。

为了识别可能进行交换的进程，Erlang 引入了“减少”概念。在 Erlang 中，减少表示 BEAM 执行的工作单位，包括基本操作，如函数应用、算术计算或消息传递。调度程序跟踪每个进程执行的减少，并在达到一定减少计数时抢占进程，从而允许其他进程运行。

### 减少

Erlang 中的“减少”概念源于其 Prolog 祖先。在 Prolog 中，每个执行步骤称为目标减少，涉及将逻辑问题分解为各个组件并依次解决每个部分。

为了促进进程间的公平性，Erlang 的抢占式调度依赖于减少而不是时间片。如果一个进程耗尽其分配的减少，即使其执行尚未完成，也可以被抢占。这种方法防止单个进程长时间独占 CPU，促进并发进程之间的公平性。通过以减少作为抢占的基础，Erlang 减少了进程因 CPU 时间而饿死的风险。这种设计确保每个进程，无论其工作负载如何，都能定期获得执行机会。

此外，根据进程执行的操作类型，灵活应用减少。例如，某些操作（如 I/O 操作）可能会消耗不同数量的减少。这种适应性允许调度程序有效地处理不同类型的操作。

在其他语言中，传统的阻塞式 I/O 操作可能导致资源利用效率低下，因为线程可能会因为等待 I/O 完成而被阻塞。Erlang 的异步和非阻塞 I/O 模型允许进程在等待 I/O 操作完成时继续执行其他任务。这最大程度地减少了阻塞操作对整体系统性能的影响。

### 优先级

Erlang 中的每个进程都可以有一个决定调度程序执行频率的`优先级`值。可以使用`Process.flag/2`（或 Erlang 中的 [process_flag/2](https://www.erlang.org/doc/man/erlang.html#process_flag-2) 函数调用来设置进程优先级：

有 4 个优先级级别：`低`、`正常`、`高`和`最大`。`最大`保留供 Erlang 内部使用，不应在应用代码中使用。每个优先级级别的进程都有单独的运行队列，并按照上述正常的轮转方式进行调度。

除了`low`和`normal`外，Erlang会独占每个优先级队列中的进程。这意味着如果在`max`优先级队列中有一个进程，那么只有`max`优先级的进程会被执行，所有其他进程都会被阻塞。类似地，如果在`high`优先级队列中有一个进程，直到所有`high`优先级队列中的进程被执行完（或不可运行），`low`和`normal`进程都不会被执行。`low`和`normal`队列的行为略有不同 — 这两个队列中的进程交错执行，以便`normal`优先级进程比`low`优先级进程更频繁地执行，但`normal`进程不会阻塞`low`优先级进程的执行。

由于`high`优先级进程的阻塞行为，它们应该非常少见，且仅用于短期任务。过度使用`high`优先级进程必定会导致系统故障，并影响应用程序的响应性，因为所有其他常规OTP进程都在`normal`优先级上运行。

另一个重要的点在于，Erlang对不同优先级进程之间的通信没有限制。因此，高优先级进程可以等待来自低优先级进程的消息。虽然允许这样做，但实际上会降低高优先级进程的优先级。

## 在多核上运行

到目前为止，我们已经探讨了调度程序如何在单核系统中编排进程。然而，在多核环境中，即使有额外资源进行并行处理，Erlang VM也会为每个可用核心创建专用的“运行队列”。这样一来，多个进程可以同时运行（每个核心一个进程），实现真正的并行处理。在每个运行队列中，所有进程都遵循我们之前讨论过的抢占式调度机制。

通常情况下，Erlang进程与其父进程共享相同的运行队列，并且可能会使用工作窃取算法来确保负载平衡。例如，如果系统中有两个核心，其中一个始终处理繁忙进程，而另一个相对空闲，那么两个核心上的Erlang调度程序会定期进行通信。这种通信促进了将进程从负载重的核心转移到负载较轻的核心，从而确保在两个核心之间更均衡地分配工作负载。

在更广泛的背景下，除了Erlang的内部运行队列外，操作系统还负责管理将线程调度到操作系统级别的核心上。这意味着进程不仅会在Erlang运行队列内进行交换，还可能进行完整的上下文切换或被移动到另一个核心。

请注意，由于Erlang VM内部的工作窃取概念，通常更有利于在多个核心上运行单个Erlang应用程序实例，而不是在同一台机器的不同核心上运行同一应用程序的单独实例。在单个实例中，专用于每个核心的调度器可以更好地在它们之间进行通信，以公平地共享负载，而在多节点群集中，调度程序无法分享进程负载（即使该群集的所有节点都在同一物理机上）。

## 性能和优化

Erlang的调度器消除了构建并发系统所涉及的大部分复杂性。它通过其抢占式调度算法自动处理锁竞争、线程开销和负载平衡等问题，使开发人员不再需要考虑这些问题。

Erlang提供了各种可调整以实现最佳性能的调度器相关参数。像[+S](https://www.erlang.org/doc/man/erl#+S)（调度器数量）和[+P](https://www.erlang.org/doc/man/erl#+P)（进程的最大数量）等参数允许您配置调度器线程和进程的数量。

例如，您可以使用`erl +S Schedulers:SchedulerOnline`启动Erlang，以控制调度器线程的数量。默认情况下，Erlang使用CPU核数自动识别这些值。请注意，虽然`Scheduler`和`SchedulerOnline`都接受高达1024的值，但在App上启动比CPU核数更多的调度器并不会对其产生任何积极的影响。

优化性能的另一个可能步骤是控制进程的优先级，正如我们所讨论的那样。确实可以在Erlang中执行某些高优先级任务。

尽管如此，这带来了潜在的风险，可能导致系统无响应和增加延迟，因为具有高优先级的进程可能会阻塞所有其他普通/低优先级的进程。相反，将被标记为故意低优先级的任务对于优先考虑其他进程可能是有利的。

所以请小心谨慎，凭自己的判断。

## 总结

在本文中，我们已经看到Erlang调度器作为Erlang架构的基石，促进了容错性、并发性和适应性。它的抢占性和动态性能使开发人员能够构建具有弹性、高并发系统，能够处理故障并最大程度地利用资源。了解Erlang调度器的繁琐之处可以使您有能力打造可伸缩和健壮的分布式应用。

如果您对了解调度器更感兴趣，我推荐您查看《[The BEAM Book中的调度章节](https://blog.stenmans.org/theBeamBook/#CH-Scheduling)》和《[Erlang Efficiency指南中的Processes](https://www.erlang.org/docs/23/efficiency_guide/processes)》。 

愉快编码！

如果你想第一时间阅读 Elixir Alchemy 的文章，请[订阅我们的 Elixir Alchemy 新闻简报，永远不会错过任何一篇文章](/elixir-alchemy)！

[AppSignal 为 Erlang 提供了集成 — 快来看看吧](https://www.appsignal.com/elixir/erlang-monitoring)。
