- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:28:59'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: The problem with invariants is that they change over time – Surfing Complexity
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://surfingcomplexity.blog/2024/03/26/the-problem-with-invariants-is-that-they-change-over-time/](https://surfingcomplexity.blog/2024/03/26/the-problem-with-invariants-is-that-they-change-over-time/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Cliff L. Biffle blogged a great write-up of a debugging odyssey at [Oxide](https://oxide.computer/)
    with the title [Who killed the network switch?](https://cliffle.com/blog/who-killed-the-network-switch/)
    Here’s the bit that jumped out at me:'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: At the time that code was written, it was correct, but it embodied the assumption
    that any loaned memory would fit into one region.
  id: totrans-split-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That assumption became obsolete the moment that Matt implemented task packing,
    but we didn’t notice. This code, which was still simple and easy to read, was
    now also wrong.
  id: totrans-split-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This type of assumption is an example of an *invariant*, a property of the system
    that is supposed to be guaranteed to not change over time. Invariants play an
    important role in formal methods (for example, see the section [Writing an invariant](https://www.learntla.com/core/invariants.html)
    in Hillel Wayne’s [Learn TLA+](https://www.learntla.com/index.html) site).
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider the following:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Our systems change over time. In particular, we will always make modifications
    to support new functionality that we could not have foreseen earlier in the lifecycle
    of the system.
  id: totrans-split-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our code often rests on a number of *invariants*, properties that are currently
    true of our system and that we assume will always be true.
  id: totrans-split-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These invariants are *implicit*: the assumptions themselves are not explicitly
    represented in the source code. That means there’s no easy way to, say, mechanically
    extract them via static analysis.'
  id: totrans-split-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A change can happen that violates an assumed invariant can be arbitrary far
    away from code that depends on the invariant to function properly.
  id: totrans-split-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What this means is that these kinds of failure modes are *inevitable*. If you’ve
    been in this business long enough, you’ve almost certainly run into an incident
    where one of the contributors was an implicit invariant that was violated by a
    new change. If you’re system lives long enough, it’s going to change. And one
    of those changes is eventually going to invalidate an assumption that somebody
    made long ago, which was a reasonable assumption to make at the time.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: Implicit invariants are, by definition, impossible to enforce explicitly. They
    are time bombs. And they are everywhere.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Published** March 26, 2024March 26, 2024'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
