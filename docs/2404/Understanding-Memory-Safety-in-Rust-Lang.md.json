["```\n#include \n#include \nint main (void){\n    printf (\"Hello, world!\\n\");\n    printf (\"Let's overflow the buffer!\\r\\n\");\n    uint32_t array[5] = {0, 0, 0, 0, 0,};\n    for(int index = 0; index < 6; index++) {\n        printf(\"Index %d: %d\\r\\n\", index, array[index]);\n    }\n    return 0;\n} \n```", "```\nHello, world!\nLet's overflow the buffer!\n\nIndex 0: 0\nIndex 1: 0\nIndex 2: 0\nIndex 3: 0\nIndex 4: 0\nIndex 5: 1\n```", "```\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n\n    // println!(\"{}, world!\", s1); // This line would cause a compile-time error\n    println!(\"{}, world!\", s2);\n}\n```", "```\nfn main() {\n    let s = String::from(\"hello\"); // s becomes the owner of the memory holding \"hello\"\n\n    takes_ownership(s); // s's value moves into the function...\n                        // ... and so is no longer valid here\n\n    // println!(\"{}\", s); // This line would cause a compile error because the ownership of s's value has been transferred\n\n    let x = 5;                  \n    makes_copy(x); // x would move into the function,\n                   // but i32 is Copy, so it's okay to still\n                   // use x afterward\n\n    println!(\"{}\", x); // Works fine because i32 is Copy and doesn't move ownership\n}\n\nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!(\"{}\", some_string);\n} // Here, some_string goes out of scope and `drop` is called. The backing memory is freed.\n\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!(\"{}\", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens. \n```", "```\nfn main() {\n    let s1 = String::from(\"hello\");\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n} \n```", "```\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&mut s);\n\n    println!(\"{}\", s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n} \n```", "```\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is {}\", result);\n}\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n} \n```"]