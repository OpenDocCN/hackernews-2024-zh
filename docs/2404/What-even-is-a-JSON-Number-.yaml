- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:47:10'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: What even is a JSON Number?
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.trl.sn/blog/what-is-a-json-number/](https://blog.trl.sn/blog/what-is-a-json-number/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <main id="skip">
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: What even is a JSON Number?
  id: totrans-split-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not a question people generally ponder, and seems fairly straightforward. It's
    a number, *obviously*! But the question turns out to be somewhat hard to answer,
    and for API designers especially, the answer is really important to know! So lets
    explore by diving into the various JSON specifications and implementations. The
    findings are summarized at the end, so feel free to skip to the bottom if you
    just want to know the answer and not wade through the exploration.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: Table of contents
  id: totrans-split-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authoritative sources
  id: totrans-split-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSON is defined by two primary standards: [Ecma-404](https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf)
    and [RFC 8259](https://datatracker.ietf.org/doc/html/rfc8259). Both standards
    are semantically identical, but RFC 8259 provides some additional recommendations
    for good interoperability. A related standard, [RFC 7493](https://datatracker.ietf.org/doc/html/rfc7493),
    describes the closely related Internet JSON format, a restricted profile of JSON
    which adds a bit more teeth to the recommendations found in RFC 8259\. Additionally,
    in the context of API descriptions, [JSON Schema](https://json-schema.org/draft/2020-12/json-schema-core)
    defines a number data type, which is also normatively referenced by [OpenAPI](https://spec.openapis.org/oas/v3.1.0).
    Let''s look at each of these specifications for clues.'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: ECMA-404
  id: totrans-split-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A number is a sequence of decimal digits with no superfluous leading zero. It
    may have a preceding minus sign (U+002D). It may have a fractional part prefixed
    by a decimal point (U+002E). It may have an exponent, prefixed by e (U+0065) or
    E (U+0045) and optionally + (U+002B) or – (U+002D)
  id: totrans-split-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, a JSON number is a sequence of digits with an optional sign, fractional
    part, and exponent. The description is purely syntactical.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: RFC 8259
  id: totrans-split-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This specification provides an equivalent ABNF grammar to the railroad diagrams
    provided by ECMA-404\. It also explicitly allows implementations to set limits
    on the range and precision of numbers accepted. It goes on to note:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: Since software that implements IEEE 754 binary64 (double precision) numbers
    is generally available and widely used, good interoperability can be achieved
    by implementations that expect no more precision or range than these provide
  id: totrans-split-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is pointing out that some JSON implementations use doubles to store JSON
    number values. The implementation found in browsers and used by billions of people
    around the world is one such implementation. So a JSON number will be interoperable
    if its range and precision fit within a double.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: RFC 7493
  id: totrans-split-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This specification makes RFC 8259''s informative note a normative SHOULD NOT:'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: I-JSON messages SHOULD NOT include numbers that express greater magnitude or
    precision than an IEEE 754 double precision number provides
  id: totrans-split-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It goes on to recommend that if you need greater range or precision, that you
    should encode the number as a string.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: JSON Schema & OpenAPI
  id: totrans-split-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JSON Schema describes a number as:'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: An arbitrary-precision, base-10 decimal number value, from the JSON "number"
    value
  id: totrans-split-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JSON Schema and OpenAPI also define the concept of an integer. JSON schema defines
    an integer in terms of its value, as a number with a zero fractional part. It
    also notes that integer values SHOULD NOT be encoded with a fractional part. OpenAPI
    defines an integer in terms of its syntax, as a JSON number without a fractional
    part or exponent part.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: JSON numbers in practice
  id: totrans-split-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RFC 8259 raises the important point that ultimately implementations decide
    what a JSON number is. Certainly there are limits to range and precision in practice,
    but what are they? We know that at least one extremely widely deployed implementation
    is limited to double precision. Are there other interoperability concerns to consider?
    Let''s investigate by going down two parallel tracks: JSON parsers and serializers
    across some common languages, and code generators in the OpenAPI ecosystem.'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: Language implementations
  id: totrans-split-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Language implementations ultimately decide what a JSON number is, so let's look
    at a few examples and check for common patterns. For languages which have configurable
    serialization/deserialization, only the default behavior is covered.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  id: totrans-split-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JavaScript's built-in JSON implementation only works with the built-in `Number`
    type, so all values are limited to the range and precision of a double. Serialization
    of `BigInt` is not supported by default. JavaScript also makes it impossible to
    preserve a numeric literal exactly when round-tripping, e.g. integers-as-decimals
    like `1.0` will be put back on the wire as `1`. There is a [language proposal](https://github.com/tc39/proposal-json-parse-with-source)
    to allow fixing both of these issues without swapping out the entire parser.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.8
  id: totrans-split-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Integers, decimals, and exponentials are treated differently. Integers can round
    trip as JSON numbers within the range of -10^(4299) to 10^(4299), while decimals
    and exponentials use doubles and so are limited to double range and precision.
    Integers outside the range an `int` can be serialized to result in a `ValueError`.
    Exponentials and decimals outside the range of doubles result in `inf`. When parsing
    then serializing exponentials, the exponential formatting is lost.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: C# (.NET 8, System.Text.JSON)
  id: totrans-split-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C#'s `System.Text.JSON` library is the recommended way to handle JSON data these
    days, though `Newtonsoft.JSON` is also commonly used. We examine the behavior
    of the former, the latter likely differs.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: C# supports deserializing into appropriate data types through the use of `TryGet*`
    APIs. Using this API, it is possible to deserialize integer types losslessly up
    to `int64` and somewhat larger integers into a `decimal`. `decimal` can also be
    used to represent decimal values, potentially with precision loss. If you know
    the schema in advance, you can add support for deserializing into other data types,
    like `BigInteger`.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: C# also supports getting the raw text of the literal which allows for custom
    handling and round-tripping of arbitrary literals without precision loss.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: Java (JDK 11+, Jackson)
  id: totrans-split-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Java typically uses the `Jackson` library to handle JSON serialization and deserialization.
    `Jackson` allows serialization and deserialization into any Java numeric type,
    including `BigDecimal`, allowing it to represent numeric literals of any range
    and precision without precision loss.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: Rust (serde)
  id: totrans-split-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rust's `serde_json` crate is commonly used for JSON serialization and deserialization.
    It supports deserialization of integer values that fit within the range of an
    `i64`/`u64`. It also supports deserialization of integer and decimal values that
    fit within the range of an `f64`, though doing so may result in precision loss.
    Integers and decimals outside the range of an `f64` result in an error. Exponentials
    are always deserialized as doubles. However, `serde` has a `arbitrary_precision`
    configuration flag that can be used to round-trip arbitrary numeric values without
    precision loss assuming they are not deserialized in a lossy fashion. Support
    for deseralizing into other data types can be added with some additional code,
    but requires knowing the schema of the data.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: Go
  id: totrans-split-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Go's `encoding/json` library is capable of dynamically unmarshalling JSON number
    literals using the`float64` type. If you know the schema in advance, you can parse
    known integers into an appropriate integer type up to `int64`, and parse decimals
    into a `float32` type as appropriate. Support for unmarshalling e.g. decimal types
    or big integers can be added with some additional code, but also requires knowing
    the schema of the data.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: Go can be instructed to deserialize number literals into strings, allowing for
    custom handling and round-tripping of arbitrary literals without precision loss.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-split-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To summarize the behavior of the various implementations, we can examine their
    behavior with the following values:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: '| Number literal | Description |'
  id: totrans-split-48
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-split-49
  prefs: []
  type: TYPE_TB
- en: '| 10 | Small integer |'
  id: totrans-split-50
  prefs: []
  type: TYPE_TB
- en: '| 1000000000 | Medium integer: beyond int32 range, within int64 range |'
  id: totrans-split-51
  prefs: []
  type: TYPE_TB
- en: '| 10000000000000001 | Large integer: beyond double range, within int64 range
    |'
  id: totrans-split-52
  prefs: []
  type: TYPE_TB
- en: '| 100000000000000000001 | Huge integer: beyond the range of an int64 |'
  id: totrans-split-53
  prefs: []
  type: TYPE_TB
- en: '| 1[309 zeros] | Ridonculous integer: beyond the range of a decimal128 |'
  id: totrans-split-54
  prefs: []
  type: TYPE_TB
- en: '| 10.0 | Low-precision decimal |'
  id: totrans-split-55
  prefs: []
  type: TYPE_TB
- en: '| 10000000000000001.1 | High-precision decimal: precision > double |'
  id: totrans-split-56
  prefs: []
  type: TYPE_TB
- en: '| 1.[34 ones] | Ridonculous-precision decimal: precision > decimal128 |'
  id: totrans-split-57
  prefs: []
  type: TYPE_TB
- en: '| 1E2 | Small expontential |'
  id: totrans-split-58
  prefs: []
  type: TYPE_TB
- en: '| 1E309 | Large exponential: beyond the range of a float |'
  id: totrans-split-59
  prefs: []
  type: TYPE_TB
- en: The following table shows the data type used to represent the literal in each
    language. Cells colored with grey are errors. Cells colored with red are non-errors
    with precision loss. Only the default serialization behavior is covered here.
    It may be possible to code defensively against these kinds of errors by configuring
    the serializer or through other mechanisms. Additionally, the test code I used
    attempts to use a dynamic/schemaless parsing path if it is available. For some
    languages, knowing the schema in advance can result in better behavior. The test
    code can be found in the appendix.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: '| Literal | JavaScript | C# | Python | Java | Go | Rust |'
  id: totrans-split-61
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-split-62
  prefs: []
  type: TYPE_TB
- en: '| Small integer | Number | int16 | int | int | float64 | i8 |'
  id: totrans-split-63
  prefs: []
  type: TYPE_TB
- en: '| Medium integer | Number | int64 | int | long | float64 | i64 |'
  id: totrans-split-64
  prefs: []
  type: TYPE_TB
- en: '| Large integer | Number | int64 | int | long | float64 | i64 |'
  id: totrans-split-65
  prefs: []
  type: TYPE_TB
- en: '| Huge integer | Number | decimal | int | BigInteger | float64 | f64 |'
  id: totrans-split-66
  prefs: []
  type: TYPE_TB
- en: '| Ridonculous integer | Number | error | int | BigInteger | error | error |'
  id: totrans-split-67
  prefs: []
  type: TYPE_TB
- en: '| Low-precision decimal | Number | decimal | double | float | float64 | f64
    |'
  id: totrans-split-68
  prefs: []
  type: TYPE_TB
- en: '| High-precision decimal | Number | decimal | double | BigDecimal | float64
    | f64 |'
  id: totrans-split-69
  prefs: []
  type: TYPE_TB
- en: '| Ridonculous-precision decimal | Number | decimal | double | BigDecimal |
    float64 | f64 |'
  id: totrans-split-70
  prefs: []
  type: TYPE_TB
- en: '| Small exponential | Number | decimal | double | float | float64 | f64 |'
  id: totrans-split-71
  prefs: []
  type: TYPE_TB
- en: '| Large exponential | Number | error | double | BigDecimal | error | error
    |'
  id: totrans-split-72
  prefs: []
  type: TYPE_TB
- en: 'Notes:'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**: The test code attempts to deserialize into the smallest supported int
    `int16`, then `int64`, then `decimal`. No attempt is made to deserialize into
    a `double` at this point, since it would only have the value of `+/- Infinity`.
    Also note that `decimal` is not an IEEE `decimal128` - the former has 28-29 significant
    digits, whereas `decimal128` has 34.'
  id: totrans-split-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rust**: The type in this column represents the smallest possible type the
    value will deserialize into without error. If you know the schema in advance,
    you can make trivially make the huge integer case an error to avoid precision
    loss.'
  id: totrans-split-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Go**: You can serialize into integer types if you know the schema of the
    data and can ask the unmarshaller to give you an int64\. The table represents
    the best you can do if you don''t know the schema in advance. If you know the
    schema, you can handle the large integer case without precision loss, and also
    make the huge integer case an error.'
  id: totrans-split-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenAPI code generators
  id: totrans-split-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the context of JSON APIs, an argument could be made that OpenAPI and its
    ecosystem of code generators matter as much as the parsers found in various implementations.
    Even if a language's JSON parser is capable of parsing a number literal of a particular
    size, it's possible OpenAPI's signatures could be more or less restrictive, especially
    for strongly typed languages.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand how the various languages behave, we will test with
    numeric types and formats defined in the OpenAPI 3 spec itself, as well as the
    numeric formats defined in the [OpenAPI Format Registry](https://spec.openapis.org/registry/format/):'
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Format | Description |'
  id: totrans-split-80
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-81
  prefs: []
  type: TYPE_TB
- en: '| number |  | Arbitrary-precision, base-10 decimal number value |'
  id: totrans-split-82
  prefs: []
  type: TYPE_TB
- en: '| integer |  | JSON number without a fraction or exponent part |'
  id: totrans-split-83
  prefs: []
  type: TYPE_TB
- en: '| number | float | Single precision floating point number |'
  id: totrans-split-84
  prefs: []
  type: TYPE_TB
- en: '| number | double | Double precision floating point number |'
  id: totrans-split-85
  prefs: []
  type: TYPE_TB
- en: '| number | decimal | Fixed point decimal number of unspecified precision and
    range |'
  id: totrans-split-86
  prefs: []
  type: TYPE_TB
- en: '| number | decimal128 | Decimal floating-point number with 34 significant decimal
    digits |'
  id: totrans-split-87
  prefs: []
  type: TYPE_TB
- en: '| integer | int8 | Signed 8-bit integer |'
  id: totrans-split-88
  prefs: []
  type: TYPE_TB
- en: '| integer | uint8 | Unsigned 8-bit integer |'
  id: totrans-split-89
  prefs: []
  type: TYPE_TB
- en: '| integer | int16 | Signed 16-bit integer |'
  id: totrans-split-90
  prefs: []
  type: TYPE_TB
- en: '| integer | int32 | Signed 32-bit integer |'
  id: totrans-split-91
  prefs: []
  type: TYPE_TB
- en: '| integer | int64 | Signed 64-bit integer |'
  id: totrans-split-92
  prefs: []
  type: TYPE_TB
- en: Unsigned ints other than `uint8` are not defined in either OpenAPI or the format
    registry. `double-int` was recently added and is unlikely to be supported anywhere.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
- en: The table below summarizes the output for each language using the [OpenAPI-Generator](https://openapi-generator.tech/)
    code generators. Cells higlighted in red show cases where the generated code creates
    a situation where either precision loss or an error may occur when providing certain
    values in OpenAPI's spec-defined range and precision.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
- en: '| OpenAPI | JavaScript | C# | Python | Java | Go | Rust |'
  id: totrans-split-95
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-split-96
  prefs: []
  type: TYPE_TB
- en: '| number | number | decimal128 | int, float | BigDecimal | float32 | f32 |'
  id: totrans-split-97
  prefs: []
  type: TYPE_TB
- en: '| integer | number | int32 | int | Integer | int32 | i32 |'
  id: totrans-split-98
  prefs: []
  type: TYPE_TB
- en: '| int8 | number | int32 | int | Integer | int32 | i32 |'
  id: totrans-split-99
  prefs: []
  type: TYPE_TB
- en: '| uint8 | number | int32 | int | Integer | int32 | i32 |'
  id: totrans-split-100
  prefs: []
  type: TYPE_TB
- en: '| int16 | number | int32 | int | Integer | int32 | i32 |'
  id: totrans-split-101
  prefs: []
  type: TYPE_TB
- en: '| int32 | number | int32 | int | Integer | int32 | i32 |'
  id: totrans-split-102
  prefs: []
  type: TYPE_TB
- en: '| double-int | number | int32 | int | Integer | int32 | i32 |'
  id: totrans-split-103
  prefs: []
  type: TYPE_TB
- en: '| int64 | number | int64 | int | Long | int64 | i64 |'
  id: totrans-split-104
  prefs: []
  type: TYPE_TB
- en: '| single | number | float | int, float | Float | float32 | f32 |'
  id: totrans-split-105
  prefs: []
  type: TYPE_TB
- en: '| double | number | double | int, float | Double | float64 | f64 |'
  id: totrans-split-106
  prefs: []
  type: TYPE_TB
- en: '| decimal | number | decimal128 | int, float | BigDecimal | float32 | f32 |'
  id: totrans-split-107
  prefs: []
  type: TYPE_TB
- en: '| decimal128 | number | decimal128 | int, float | BigDecimal | float32 | f32
    |'
  id: totrans-split-108
  prefs: []
  type: TYPE_TB
- en: From this we can see that the OpenAPI-generator suite considers an `integer`
    to be an int32, despite the spec suggesting it has arbitrary range. As such, when
    using these tools, there seems to be no way to define an arbitrary-length integer
    across all languages that have a corresponding data type. Moreover, `number` is
    often understood as a 32-bit `float` despite the spec suggesting it has arbitrary
    range and precision.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
- en: Summary of findings
  id: totrans-split-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s answer the question then: what is a JSON number?'
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
- en: According to the authoritative specs, a numeric literal of any length and precision.
  id: totrans-split-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to an interoperable profile of JSON, a numeric literal with the length
    and precision of a double.
  id: totrans-split-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to various JSON implementations, a numeric literal with constraints
    that differ wildly depending on the implementation.
  id: totrans-split-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'According to OpenAPI, either:'
  id: totrans-split-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer of any length
  id: totrans-split-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A decimal value of any length and precision
  id: totrans-split-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: According to OpenAPI code generators,
  id: totrans-split-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without a format, either:'
  id: totrans-split-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `number`, some floating point representation as small as float32
  id: totrans-split-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `integer`, an int32
  id: totrans-split-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With a format, either:'
  id: totrans-split-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the closest data type approximating the specified format in that language
  id: totrans-split-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int32` or its closest approximation if the format is not supported.'
  id: totrans-split-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have also confirmed that interoperability of numbers outside the range of
    a double is spotty. All implementations tested can transact numbers inside the
    double range safely. All implementations except JavaScript can transact integer
    literals within the range of an `int64` (though go requires knowing the schema
    in advance).
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
- en: 'For those using OpenAPI, we can infer some best practices for defining APIs
    that use numbers:'
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
- en: Always specify a format in OpenAPI. Neither `integer` or `number` is likely
    to do what you want.
  id: totrans-split-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid `double-int`. It's not supported and results in potential errors or data
    loss in many languages.
  id: totrans-split-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid `decimal` and `decimal128`. They are also not widely supported.
  id: totrans-split-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid `int64` with a `number` type if you have JavaScript consumers. Use with
    the `string` type instead.
  id: totrans-split-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you''re using TypeSpec, this advice can be summed up as:'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using `decimal`, `decimal128`, `integer`, and `numeric` types.
  id: totrans-split-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use `int64` and you have JavaScript consumers, encode it as a string
    via `@encode("int64", string)`.
  id: totrans-split-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, due to some languages handling numeric literals with exponential and
    decimal parts differently, implementations should preserve the format when round
    tripping (e.g. `10.0` should be put back as `10.0`).
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix: Test Code'
  id: totrans-split-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This code is garbage, LLMs were heavily involved in their creation. The output
    needs some interpretation. Feel free to [suggest improvements on GitHub](https://github.com/bterlson/blog/blob/main/content/blog/what-is-a-json-number.md).
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  id: totrans-split-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-138
  prefs: []
  type: TYPE_PRE
- en: C#
  id: totrans-split-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-140
  prefs: []
  type: TYPE_PRE
- en: Python (3.8)
  id: totrans-split-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-142
  prefs: []
  type: TYPE_PRE
- en: Java (JDK 21, Jackson)
  id: totrans-split-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-144
  prefs: []
  type: TYPE_PRE
- en: Rust
  id: totrans-split-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-146
  prefs: []
  type: TYPE_PRE
- en: Go
  id: totrans-split-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This code demonstrates the default behavior:'
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-149
  prefs: []
  type: TYPE_PRE
- en: 'This code demonstrates deserializing into a struct of a known shape:'
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-151
  prefs: []
  type: TYPE_PRE
- en: </main>
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
