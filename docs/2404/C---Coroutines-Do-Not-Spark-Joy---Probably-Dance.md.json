["```\ngenerator_coro<int> range(int stop, int step = 1)\n{\n    for (int i = 0; i < stop;)\n    {\n        co_yield i;\n        i += step;\n    }\n}\n\n```", "```\nstruct range_struct\n{\n    int i;\n    int stop;\n    int step;\n    enum {\n        At_start,\n        In_loop,\n        Done\n    } state;\n\n    explicit range_struct(int stop, int step = 1)\n        : stop(stop), step(step), state(At_start)\n    {\n    }\n\n    int resume()\n    {\n    switch (state)\n    {\n    case At_start:  for (i = 0; i < stop;)\n                    {\n                        state = In_loop;\n                        return i;\n    case In_loop:       i += step;\n                    }\n                    state = Done;\n    case Done:      return 0;\n    }\n    }\n};\n\n```", "```\nTEST(range, coro_and_struct)\n{\n    std::vector<int> range_result;\n    std::vector<int> range_struct_result;\n    for (int i : range(10, 2))\n    {\n        range_result.push_back(i);\n    }\n    for (int i : range_struct(10, 2))\n    {\n        range_struct_result.push_back(i);\n    }\n    ASSERT_EQ((std::vector<int>{0, 2, 4, 6, 8}), range_result);\n    ASSERT_EQ((std::vector<int>{0, 2, 4, 6, 8}), range_struct_result);\n}\n\n```", "```\nstruct range_struct\n{\n    // ... unchanged top half of the struct\n\n    struct end_iterator {};\n    struct iterator\n    {\n        range_struct * self;\n        bool operator==(const end_iterator&) const\n        {\n            return self->state == Done;\n        }\n        void operator++()\n        {\n            self->resume();\n        }\n        int operator*() const\n        {\n            return self->i;\n        }\n    };\n\n    iterator begin()\n    {\n        resume();\n        return { this };\n    }\n    end_iterator end()\n    {\n        return {};\n    }\n};\n\n```", "```\ngenerator_coro<int> foo()\n{\n    for (int i = 0; i < 10; ++i)\n        co_yield i;\n    generator_coro<int> rest = bar();\n    // ... how do I return all the values from rest?\n    return rest;\n}\n\n```", "```\ngenerator_coro<int> foo()\n{\n    for (int i = 0; i < 10; ++i)\n        co_yield i;\n    generator_coro<int> rest = bar();\n    for (int i : rest)\n        co_yield i;\n}\n\n```", "```\ngenerator_coro<int> foo()\n{\n    for (int i = 0; i < 10; ++i)\n        co_yield i;\n    generator_coro<int> rest = bar();\n    rest.set_is_draining(true);\n    for (int i : rest)\n        co_yield i;\n}\n\n```", "```\ngenerator_coro<int> drain_and_yield_all(generator_coro<int> & coro)\n{\n    coro.set_is_draining(true);\n    for (int i : coro)\n        co_yield i;\n}\n\n```", "```\ngenerator_coro<int> foo()\n{\n    for (int i = 0; i < 10; ++i)\n        co_yield i;\n    generator_coro<int> rest = bar();\n    generator_coro<int> rest2 = drain_and_yield_all(rest);\n    // ... what now?\n}\n\n```", "```\n#define DRAIN_AND_YIELD_ALL(x) if (true)\\\n{\\\n    auto && coro = x;\\\n    coro.set_is_draining(true);\\\n    for (auto && i : coro)\\\n        co_yield i;\\\n} else static_cast<void>(0)\n\n```", "```\ntemplate<typename PromiseType>\nstruct GetPromise\n{\n  PromiseType * p;\n  bool await_ready()\n  {\n      return false; // says we're not ready, call await_suspend\n  }\n  bool await_suspend(costd::coroutine_handle<PromiseType> h)\n  {\n    p = &h.promise();\n    return false; // says no don't suspend coroutine after all\n  }\n  PromiseType * await_resume()\n  {\n      return p;\n  }\n};\n\n```", "```\ngenerator_coro<int> range(int stop, int step)\n{\n    generator_coro<int>::promise_type * promise = co_await GetPromise<generator_coro<int>::promise_type>{};\n    for (promise->i = 0; promise->i < stop;)\n    {\n        co_yield promise->i;\n        promise->i += step;\n    }\n}\n\n```", "```\ngenerator_coro<int> range(generator_coro<int>::promise_type * promise, int stop, int step)\n{\n    for (promise->i = 0; promise->i < stop;)\n    {\n        co_yield promise->i;\n        promise->i += step;\n    }\n}\n\n```", "```\n#define FIBER_YIELD(x) if (fiber_yield(x)) static_cast<void>(0) else return false\n\n```", "```\ngenerator_coro<int> range(int stop, int step = 1)\n{\n    public int i;\n    for (i = 0; i < stop;)\n    {\n        co_yield i;\n        i += step;\n    }\n}\n\n```"]