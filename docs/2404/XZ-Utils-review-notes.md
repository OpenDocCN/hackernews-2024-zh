<!--yml

category: 未分类

date: 2024-05-27 13:12:43

-->

# XZ Utils审查注释

> 来源：[https://tukaani.org/xz-backdoor/review.html](https://tukaani.org/xz-backdoor/review.html)

### 2023-01

* * *

OK。而且VS项目文件也不再存在。

* * *

* * *

* * *

* * *

* * *

他想在一些测试中使用liblzma的内部头文件，最终我屈服了。这需要将这些特定的内部头文件独立出来，以便它们不包含其他内部头文件。

* * *

第二次提交合并了我的编辑，压缩成了一个单独的提交。提交信息显然是他编辑过的，收集了我单独提交的消息。例如，项目符号格式与我本人的风格不符。

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

可能OK。Doxyfile稍后又进行了更新。

* * *

* * *

这个修复的意图是好的，修复了一个很小的在罕见情况下出现的问题。它在分支上等了一段时间，直到我允许合并。这引入了一个在[2023-11](#_2023_11)修复的回归。

* * *

这个修复是好的，但提交消息考虑得过于深入了。文档简单地是错误的，而这就是全部。

* * *

### 2023-02

OK。这些是更新API文档的第一批提交。

* * *

* * *

* * *

* * *

* * *

OK（文档更新）。

* * *

OK（进一步的文档更新）。

* * *

* * *

OK（更多文档更新）。

* * *

OK（文档更新仍在继续）。

返回值的更新是值得做的：

+   `lzma_properties_encode`只应返回`LZMA_OK`或`LZMA_PROG_ERROR`。尽管曾经列出过`LZMA_OPTIONS_ERROR`作为可能的值，但实际上不应该出现这种情况。

+   `lzma_filter_flags_decode`可能也会返回`LZMA_DATA_ERROR`。

* * *

* * *

### 2023-03

* * *

这个系列有中间步骤，我并不喜欢。不过最终结果还是不错的（最后两次提交是我做的）。

这一系列与`v5.4`中的以下两次提交完全相同：

* * *

后来进行的调整使得这个版本足够好了。

* * *

我发现并且现在依然觉得这些对API没有用。他坚持要它们，所以最终我妥协了。从技术上讲并没有错，我只是认为它们并没有提升可读性。

* * *

`tuktest.h`已经使得这些过时。

* * *

这是一个因为时区问题被认为可疑的提交之一。实际上，Jia按照共识将它以我的名义提交，因为我完成了其中相当大部分。

* * *

在5.6.1发布后，这些内容将会有所不同，因为预生成的Doxygen输出将不再包含在发布的压缩包中（这不仅仅是为了减少生成文件的数量，还简化了源代码压缩包的许可问题）。

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

### 2023-06

这来自于[PR #51](https://github.com/tukaani-project/xz/pull/51)。提交消息似乎有点错误，因为它提到了`ZLIB::ZLIB`，但除此之外一切都很好。

* * *

后来确实需要了一些真正的修复，但由于ifunc支持已经从软件包中移除，这些提交现在不再相关。

* * *

这些是贾合并的我的提交。由于ifunc支持现在从`master`分支中消失了，因此这些提交现在不再相关。

* * *

* * *

* * *

好。一个内联函数可能比宏更好。

* * *

* * *

### 2023-07

好。我认为具有各种构建配置的CI设置有助于发现这一点。

* * *

* * *

* * *

`--powerpc`在旧版本中由于错误被缩写为`--power`，但仍然能够正确工作，因为`getopt_long`接受非歧义的缩写。

* * *

好。`str_to_filter`两个提交后更名为更正确的复数形式`str_to_filters`。

这个提交开始了添加`--filters1`到`--filters9`选项系列的提交。

* * *

* * *

作为中间步骤还可以。接下来的提交改进了情况。

* * *

* * *

* * *

我将`{ }`还原为一个`if`语句。我喜欢将两个if语句保持在嵌套形式中，而不是使用短路（`&&`）来使函数调用有条件。

* * *

这确实做到了它应该做的事情，但是需要进行清理：

+   `filters_memusage_max()`设置静态数组`filter_memusages`，但最好将该数组作为局部变量。

+   第二部分比必要的复杂。将字典大小扩展分为三个步骤，使得阅读变得困难。

    +   `orig_dict_size`应该是`uint32_t`，而不是`uint64_t`。

    +   `while (count > 0)`循环和需要`count`变量的方式有点奇怪。它并行调整链条，而不是一次处理一个链条。

    +   `if (filt_mem_usage < memory_limit)`应该是`<=`。实际上并不重要，因为值是以字节为单位的。

我在2024-05对这段代码进行了相当大的编辑，包括上述修复和清理。它可能仍然有些难以理解，但这不是因为2023年的提交。

* * *

好。使用`--flush-timeout`进行多个过滤链的情况不太可能，但这也不需要太多额外的代码。

* * *

然而，最好在`parse_block_list()`中收集所需的信息，因为这样可以避免循环遍历`opt_block_list`数组。我在2024-05做了这个改变，因此这次提交的内容不多了。

这是`--filters1`到`--filters9`系列的最后一次提交。

* * *

* * *

* * *

* * *

* * *

* * *

好。如提交消息所说，它只是重新排列了行。以下内容可能会有所帮助：

```
git log -p f5dc172a402f^! | sed 's/^-/+/' | grep ^+ \
    | sort | uniq -u
```

* * *

* * *

* * *

* * *

* * *

| Tip | 永远不要告诉你要列出多少事物。 |
| --- | --- |

* * *

好。我们被问及如何在一台机器上交叉编译，然后在目标机器上运行测试，因此将其文档化是很好的。

* * *

* * *

* * *

好，但现在已经从`master`分支移除了。

* * *

* * *

好。这样可以使得`test_files.sh`在未配置功能时使用退出状态77（跳过测试），而不是退出状态0（测试通过）。

* * *

* * *

Windows上的特殊情况已经研究并且注释得很好，但结果比必要的复杂。与其在构建目录中创建符号链接然后安装（复制）它们，不如直接在目标目录中的安装时创建符号链接更简单。这在[CMake：简化符号链接创建并安装已翻译的man页。](https://github.com/tukaani-project/xz/commit/67610c245ba6c68cf65991693bab9312b7dc987b)中得到了简化，虽然它本身是一个混乱的提交，因为它做了多件事。

* * *

* * *

### 2023-09

* * *

* * *

这些都是可以接受的，包括极大地简化了的getopt.m4。xz不需要对getopt_long的所有边界情况提供支持，因此也不需要检查这些边界情况。

在GNU/Linux、*BSD、Solaris或MinGW-w64中不使用GNU getopt_long。

* * *

要验证这些提交，以下内容可能会有所帮助：

```
git diff ce162db07f03^..9fb5de41f2fb \
    | sed "/^-/{s/\`/'/g;s/^-/+/}" \
    | grep ^+ | sort | uniq -u
```

* * *

### 2023-10

它与Gnulib中的文件相匹配。

* * *

最终版本是好的。

* * *

这个属性显然很可怕，但是对于这个版本的x86 SIMD代码来说却是不可避免的。代码进行了对齐的16字节读取，如果缓冲区未对齐，可能会读取到缓冲区开始之前或结束之后的15个字节。然后这些不需要的字节会被忽略。它不能越过页面边界，因此不会导致访问违规。

这个正确性很容易审查，因为内存只在几个地方进行只读操作。如果你这样做，我建议看看`master`分支中的最新代码，因为那才是现在实际在使用的代码。

**然而**，它也会触发内存检测器，这与地址检测器是不同的事情。与其添加另一个属性来禁用它，不如改变这段代码以使这些属性不再需要。虽然这样的更改不会被反向移植到5.4.x，因为当前的代码确实正确运行。

* * *

* * *

* * *

* * *

### 2023-11

* * *

把这个作为一个整体审查是最简单的。在`master`分支中，这是一系列有趣的提交，因为我发现了一个在[xz：重构使用--format=raw时自定义后缀的重复检查](https://github.com/tukaani-project/xz/commit/cc5aa9ab138beeecaee5a1e81197591893ee9ca0)中引入的回归。我们讨论了它，并提出了修复的想法，结果发现有点不对劲，需要另一个修复，直到他认为最好另一天再完成。然后测试脚本也被添加了。

* * *

尽管我在下一个提交中澄清了一个注释，但这些仍然是好的。它修复了xz在Windows构建中一个非常古老的错误。

* * *

如果unc检测导致musl出现问题，这似乎没问题，但是[liblzma：删除ifunc支持。](https://github.com/tukaani-project/xz/commit/689ae2427342a2ea1206eb5ca08301baf410e7e0) 所以这也不再重要。

* * *

这实际上只是空间更改，没有点号。

* * *

### 2023-12

这些来自于 [PR #73](https://github.com/tukaani-project/xz/pull/73) 并已正确合并，提交消息和空白使用已经整理干净。

* * *

好的。需要做一个小注释修复。

* * *

* * *

* * *

好的。`options` 绝对不能为 `NULL`，实际上从未为 `NULL`，因为这也会是应用程序中的错误。

* * *

好的，就像提交消息所说的那样。

* * *

这个 bug 并不像提交消息所说的那样严重，因为没有人有理由在 LZMA1 编码器上调用 `lzma_filters_update`，这个函数本来就很少使用。

* * *

`#if` 指令中宏的顺序与 `src/xz/sandbox.h` 中不同，但指令依然正确。

Capsicum 代码相对于 xz 来说稍微简单且更为严格，因为 xzdec 需要执行较少的操作。当内核不支持时静默运行而不使用沙箱 (`ENOSYS`) 是一个有意的特性和普遍接受的做法：否则，在这样的内核上 xz 将完全无法运行。

* * *

* * *

移动代码并进行了一些编辑。比较移动的部分显示它是良好的，包括小的编辑。没有明显的可疑拼写错误（比如拼错 `SANDBOX_COMPILE_DEFINITION`）。

* * *

### 2024-01

在这次提交中，`riscv.c` 文件几乎完全由我编写，并与我在 Git 树之外拥有的文件匹配。Jia 做了一些小工作，比如添加宏以避免重复的代码和改进了一些注释。我对这些进行了审查和进一步编辑。

剩下的提交是由 Jia 完成的。这些更改很好。

* * *

* * *

这是为后门做准备的第一个提交。

* * *

它非常类似于 ARM64 代码中的新代码。

* * *

* * *

尽管现在后门已被移除，这个提交本身并没有做任何事情。但我将其留在这里，以备 *如果* 适当的文件和生成程序一起添加。

* * *

我提到了字典大小，这给了更新后门代码的一个好借口。

* * *

* * *

在这些提交中有些波动，所以最简单的方法是只审查最终结果。

* * *

### 2024-02

* * *

* * *

这些很好且是根据我的请求创建的。它们很大，但很难分割成更小的部分。这些的原始版本来自于 2023-04-24。我做了一些小修改，但同意以他的名义提交这些。

由于这些提交很复杂，如果它们看起来令人生畏，这是可以理解的。新代码每次循环迭代只进行一次输入缓冲区边界检查，检查是否至少有 21 个字节可用。起初这可能看起来不足，因为在最坏的情况下，`rc_normalize` 每次循环迭代最多可能被执行 48 次（22 位模型 + 26 直接）。每个 `rc_normalize` 宏将在需要时读取一个输入字节。然而，条件读取新字节不能始终为真。这已经通过数学和实验验证过。代码中关于此的注释可能可以改进。

我所做的小改动包括修复了一个循环条件的偏移错误。原本的提交中有 20，但我改成了 21，因为在载荷标记（EOPM）结束后的最终规范化被包含在非可恢复路径中。接下来我的提交 ([liblzma: LZMA 解码器改进。](https://github.com/tukaani-project/xz/commit/e0c0ee475c0800c08291ae45e0d66aa00d5ce604)) 让非可恢复变体跳到了安全代码 (`goto eopm`)，因此 21 被改回了 20。

自 2009 年以来，XZ Embedded 自带的每次循环 20 字节检查的代码有些类似，并且自 2010 年以来已经在 Linux 内核中存在。

作为 XZ Utils 中大部分核心压缩代码的一部分，这个细节的原始想法来自于 LZMA SDK。只是代码看起来有些不同而已。

* * *

修改的 build-to-host.m4 文件中有后门触发器。在这里忽略这个文件是正确的，因为在运行 `./autogen.sh` 或 `autoreconf -fi` 时，它会被添加在其他几个 .m4 文件中。

* * *

* * *

* * *

我不喜欢为这个测试而额外添加的宏。最后的提交不仅撤销了单个提交，但更改是可以接受的。

* * *

这个测试假设编码器的输出不会改变，也就是说，如果编码器修改过多，测试就会失败。如果编码器有所修改，更新测试以匹配并不算什么额外工作。

* * *

注意，tests/test_files.sh 使用通配符来选择文件。因此，只需添加文件就可以进行相应的解压缩测试。

* * *

我们讨论过这个问题，我同意这样做。这样一来，手册页翻译就不需要在发布紧张的最后几天再通过翻译人员修复英文源文本中的拼写错误了。

* * *

符号名称本应为 `XZ_5.6` 而不是 `XZ_5.6.0`。实际上这没有任何区别，因为它只是一个字符串。

* * *

好的。他喜欢运行 codespell，而我不喜欢。

* * *

他修复了它是因为我注意到了。显然测试文件早就写好了。

* * *

* * *

* * *

讨论过需要添加这个修复。

* * *

这已经与多人长时间讨论过了。提交符合当时的决定。

* * *

### 2024-03

这是一个 [真实的错误](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=114115#c12)，但提交消息中的错误号码缺少了一个数字。

* * *

这是一个后门提交之一。

* * *

* * *

这是对 [xz: 在手册页的过滤列表中添加遗漏的 RISC-V](https://github.com/tukaani-project/xz/commit/eee579fff50099ba163c12305e81a4bd42b7dd53) 的延续。几乎总是不好在没有上游批准的情况下修改翻译。在这种情况下，我感到犹豫，因为我不确定日期翻译是否正确，但也不想阻止它，以便翻译可以在同一天发布的 5.6.1 版本中进行。

当翻译发送给翻译人员时，他们会重新制作这些更改（他们只从tarball中挑选原始的英文文本）。

* * *

我有一种印象，这次提交引起了很多猜测。

我已经要求贾简化GitHub的PR和问题模板，并且简化`SECURITY.md`也显得合理。报告这类漏洞的人并不需要详细的指导。

我感觉21–30天可能更合适，但贾希望保持90天。像“漏洞”这样的后门，快速全面披露才是唯一正确的方式。
