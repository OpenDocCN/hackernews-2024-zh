["```\n$ curl -s https://apod.nasa.gov/htmltest/gifcity/e.2mil | tr -d '[:space:]' | \\\n          perl -MMath::Prime::Util=is_prime -MList::Util=first -nle \\\n          'print first { is_prime($_) } /(?=([1-9]\\d{9}))/g'\n7427466391 \n```", "```\nuint64_t compute_n(uint64_t k)\n{\n        /* Find n such that\n           (n + 1) * ln(n + 1) - (n + 1) > 1 + k * ln(10)\n           using binary search.\n         */\n\n        uint64_t hi, lo, n;\n\n        hi = UINT64_MAX;\n        lo = 0;\n\n        while (hi - lo > 1) {\n                n = lo + (hi - lo) / 2;\n\n                if ((n + 1) * log(n + 1) - (n + 1) <= 1 + k * log(10)) {\n                        lo = n;\n                } else {\n                        hi = n;\n                }\n        }\n\n        return hi;\n} \n```", "```\n#ifndef NUM_DECIMALS\n#define NUM_DECIMALS 10000ULL\n#endif\n#define NUM_DIGITS (1 + NUM_DECIMALS)\n#define NUM_BITS (NUM_DIGITS * 3322 / 1000 + 999) \n```", "```\nvoid eprime_gmp(void)\n{\n        uint64_t i, n;\n        mpf_t e, term;\n        char *s;\n        mp_exp_t strexp;\n\n        n = compute_n(NUM_DECIMALS);\n\n        /* Compute e. */\n        mpf_set_default_prec(NUM_BITS);\n        mpf_init_set_ui(e, 1);\n        mpf_init_set_ui(term, 1);\n\n        for (i = 1; i <= n; i++) {\n                mpf_div_ui(term, term, i);\n                mpf_add(e, e, term);\n        }\n\n        mpf_clear(term); \n```", "```\n /* Convert to string of decimal digits. */\n        s = mpf_get_str(NULL, &strexp, 10, NUM_DIGITS, e);\n        mpf_clear(e);\n        assert(strexp == 1);\n        assert(strlen(s) == NUM_DIGITS);\n#ifdef PRINT_E\n        printf(\"2.%s\\n\", &s[1]);\n#endif \n```", "```\n find_prime_gmp(&s[1]);\n        free(s);\n}\n\n/* Find the first 10-digit prime in string s with length NUM_DECIMALS. */\nvoid find_prime_gmp(const char *s)\n{\n        int i;\n        mpz_t p;\n\n        mpz_init(p);\n        for (i = 1; i + 9 < NUM_DECIMALS; i++) {\n                if (s[i] == '0' || (s[i + 9] - '0') % 2 == 0) {\n                        /* Skip leading zeros and even numbers. */\n                        continue;\n                }\n\n                gmp_sscanf(&s[i], \"%10Zd\", p);\n                if (mpz_probab_prime_p(p, 20)) {\n                        gmp_printf(\"%Zd is prime\\n\", p);\n                        break;\n                }\n        }\n        mpz_clear(p);\n} \n```", "```\n$ sudo apt-get install libgmp-dev\n$ gcc -O3 -DNDEBUG eprime.c -lm -lgmp\n$ ./a.out\n7427466391 is prime \n```", "```\n$ sudo port install gmp\n$ clang -O3 -DNDEBUG -I/opt/local/include -L/opt/local/lib eprime.c -lm -lgmp\n$ ./a.out\n7427466391 is prime \n```", "```\n$ gcc -O3 -DNDEBUG -DPRINT_E eprime.c -lm -lgmp\n$ ./a.out\n2.718281828459045235360287471352662497757247093699959574966967627724076630353547\n59457138217852516642742746639193200305992181741359662904357290033429526059563073\n81323286279434907632338298807531952510190115738341879307021540891499348841675092\n44761460668082264800168477411853742345442437107539077744992069551702761838606261\n33138458300075204493382656029760673711320070932870912744374704723069697720931014\n...\n91674197015125597825727074064318086014281490241467804723275976842696339357735429\n30186739439716388611764209004068663398856841681003872389214483176070116684503887\n21236436704331409115573328018297798873659091665961240202177855885487617616198937\n07943800566633648843650891448055710397652146960276625835990519870423001794655367\n89\n7427466391 is prime \n```", "```\nint nbr[6] = {1,2,3,4,5,6}; \n```", "```\n/* Add n-place integers u and v into w. */\nvoid addn(int n, const uint64_t *u, const uint64_t *v, uint64_t *w)\n{\n        bool carry, carry_a, carry_b;\n        uint64_t sum_a, sum_b;\n        int j;\n\n        carry = false;\n\n        for (j = 0; j < n; j++) {\n                sum_a = u[j] + carry;\n                carry_a = (sum_a < u[j]);\n\n                sum_b = sum_a + v[j];\n                carry_b = (sum_b < sum_a);\n\n                w[j] = sum_b;\n                assert(carry_a + carry_b <= 1);\n                carry = carry_a + carry_b;\n        }\n} \n```", "```\nuint64_t umullo(uint64_t a, uint64_t b)\n{\n        return a * b;\n} \n```", "```\n#if defined(__GNUC__)\nvoid umul(uint64_t a, uint64_t b, uint64_t *p1, uint64_t *p0)\n{\n        __uint128_t p = (__uint128_t)a * b;\n        *p1 = (uint64_t)(p >> 64);\n        *p0 = (uint64_t)p;\n}\n\nuint64_t umulhi(uint64_t a, uint64_t b)\n{\n        return (uint64_t)(((__uint128_t)a * b) >> 64);\n}\n#elif defined(_MSC_VER) && defined(_M_X64)\n#include <intrin.h> void umul(uint64_t a, uint64_t b, uint64_t *p1, uint64_t *p0)\n{\n        *p0 = _umul128(a, b, p1);\n}\n\nuint64_t umulhi(uint64_t a, uint64_t b)\n{\n        return __umulh(a, b);\n}\n#else\nvoid umul(uint64_t x, uint64_t y, uint64_t *p1, uint64_t *p0)\n{\n        uint32_t x0 = (uint32_t)x, x1 = (uint32_t)(x >> 32);\n        uint32_t y0 = (uint32_t)y, y1 = (uint32_t)(y >> 32);\n        uint64_t p;\n        uint32_t res0, res1, res2, res3;\n\n        p = (uint64_t)x0 * y0;\n        res0 = (uint32_t)p;\n        res1 = (uint32_t)(p >> 32);\n\n        p = (uint64_t)x0 * y1;\n        res1 = (uint32_t)(p += res1);\n        res2 = (uint32_t)(p >> 32);\n\n        p = (uint64_t)x1 * y0;\n        res1 = (uint32_t)(p += res1);\n        p >>= 32;\n        res2 = (uint32_t)(p += res2);\n        res3 = (uint32_t)(p >> 32);\n\n        p = (uint64_t)x1 * y1;\n        res2 = (uint32_t)(p += res2);\n        res3 += (uint32_t)(p >> 32);\n\n        *p0 = ((uint64_t)res1 << 32) | res0;\n        *p1 = ((uint64_t)res3 << 32) | res2;\n}\n\nuint64_t umulhi(uint64_t a, uint64_t b)\n{\n        uint64_t p0, p1;\n        umul(a, b, &p1, &p0);\n        return p1;\n}\n#endif \n```", "```\n/* Algorithm 2 from Möller and Granlund\n   \"Improved division by invariant integers\". */\nuint64_t reciprocal_word(uint64_t d)\n{\n        uint64_t d0, d9, d40, d63, v0, v1, v2, ehat, v3, v4, hi, lo;\n\n        static const uint64_t table[] = {\n        /* Generated with:\n           for (int i = (1 << 8); i < (1 << 9); i++)\n                   printf(\"0x%03x,\\n\", ((1 << 19) - 3 * (1 << 8)) / i); */\n        0x7fd, 0x7f5, 0x7ed, 0x7e5, 0x7dd, 0x7d5, 0x7ce, 0x7c6, 0x7bf, 0x7b7,\n        0x7b0, 0x7a8, 0x7a1, 0x79a, 0x792, 0x78b, 0x784, 0x77d, 0x776, 0x76f,\n        0x768, 0x761, 0x75b, 0x754, 0x74d, 0x747, 0x740, 0x739, 0x733, 0x72c,\n        0x726, 0x720, 0x719, 0x713, 0x70d, 0x707, 0x700, 0x6fa, 0x6f4, 0x6ee,\n        0x6e8, 0x6e2, 0x6dc, 0x6d6, 0x6d1, 0x6cb, 0x6c5, 0x6bf, 0x6ba, 0x6b4,\n        0x6ae, 0x6a9, 0x6a3, 0x69e, 0x698, 0x693, 0x68d, 0x688, 0x683, 0x67d,\n        0x678, 0x673, 0x66e, 0x669, 0x664, 0x65e, 0x659, 0x654, 0x64f, 0x64a,\n        0x645, 0x640, 0x63c, 0x637, 0x632, 0x62d, 0x628, 0x624, 0x61f, 0x61a,\n        0x616, 0x611, 0x60c, 0x608, 0x603, 0x5ff, 0x5fa, 0x5f6, 0x5f1, 0x5ed,\n        0x5e9, 0x5e4, 0x5e0, 0x5dc, 0x5d7, 0x5d3, 0x5cf, 0x5cb, 0x5c6, 0x5c2,\n        0x5be, 0x5ba, 0x5b6, 0x5b2, 0x5ae, 0x5aa, 0x5a6, 0x5a2, 0x59e, 0x59a,\n        0x596, 0x592, 0x58e, 0x58a, 0x586, 0x583, 0x57f, 0x57b, 0x577, 0x574,\n        0x570, 0x56c, 0x568, 0x565, 0x561, 0x55e, 0x55a, 0x556, 0x553, 0x54f,\n        0x54c, 0x548, 0x545, 0x541, 0x53e, 0x53a, 0x537, 0x534, 0x530, 0x52d,\n        0x52a, 0x526, 0x523, 0x520, 0x51c, 0x519, 0x516, 0x513, 0x50f, 0x50c,\n        0x509, 0x506, 0x503, 0x500, 0x4fc, 0x4f9, 0x4f6, 0x4f3, 0x4f0, 0x4ed,\n        0x4ea, 0x4e7, 0x4e4, 0x4e1, 0x4de, 0x4db, 0x4d8, 0x4d5, 0x4d2, 0x4cf,\n        0x4cc, 0x4ca, 0x4c7, 0x4c4, 0x4c1, 0x4be, 0x4bb, 0x4b9, 0x4b6, 0x4b3,\n        0x4b0, 0x4ad, 0x4ab, 0x4a8, 0x4a5, 0x4a3, 0x4a0, 0x49d, 0x49b, 0x498,\n        0x495, 0x493, 0x490, 0x48d, 0x48b, 0x488, 0x486, 0x483, 0x481, 0x47e,\n        0x47c, 0x479, 0x477, 0x474, 0x472, 0x46f, 0x46d, 0x46a, 0x468, 0x465,\n        0x463, 0x461, 0x45e, 0x45c, 0x459, 0x457, 0x455, 0x452, 0x450, 0x44e,\n        0x44b, 0x449, 0x447, 0x444, 0x442, 0x440, 0x43e, 0x43b, 0x439, 0x437,\n        0x435, 0x432, 0x430, 0x42e, 0x42c, 0x42a, 0x428, 0x425, 0x423, 0x421,\n        0x41f, 0x41d, 0x41b, 0x419, 0x417, 0x414, 0x412, 0x410, 0x40e, 0x40c,\n        0x40a, 0x408, 0x406, 0x404, 0x402, 0x400\n        };\n\n        assert(d > UINT64_MAX / 2 && \"d must be normalized.\");\n\n        d0 = d & 1;\n        d9 = d >> 55;\n        d40 = (d >> 24) + 1;\n        d63 = (d >> 1) + d0;\n\n        v0 = table[d9 - (1 << 8)];\n        v1 = (v0 << 11) - (umullo(umullo(v0, v0), d40) >> 40) - 1;\n        v2 = (v1 << 13) + (umullo(v1, (1ULL << 60) - umullo(v1, d40)) >> 47);\n        ehat = (v2 >> 1) * d0 - umullo(v2, d63);\n        v3 = (v2 << 31) + (umulhi(v2, ehat) >> 1);\n        umul(v3, d, &hi, &lo);\n        v4 = v3 - (hi + d + (lo + d < lo));\n\n#if defined(__GNUC__) && defined(__x86_64__) && !defined(NDEBUG)\n        uint64_t asmq, asmr;\n        __asm__(\"divq %2\" : \"=a\"(asmq), \"=d\"(asmr)\n                          : \"r\"(d), \"d\"(UINT64_MAX-d), \"a\"(UINT64_MAX) : \"cc\");\n        assert(v4 == asmq);\n#endif\n\n        return v4;\n} \n```", "```\n/* Algorithm 4 from Möller and Granlund\n   \"Improved division by invariant integers\".\n   Divide u1:u0 by d, returning the quotient and storing the remainder in r.\n   v is the approximate reciprocal of d, as computed by reciprocal_word. */\nuint64_t div2by1(uint64_t u1, uint64_t u0, uint64_t d, uint64_t *r, uint64_t v)\n{\n        uint64_t q0, q1;\n\n        assert(u1 < d && \"The quotient must fit in one word.\");\n        assert(d > UINT64_MAX / 2 && \"d must be normalized.\");\n\n        umul(v, u1, &q1, &q0);\n        q0 = q0 + u0;\n        q1 = q1 + u1 + (q0 < u0);\n        q1++;\n        *r = u0 - umullo(q1, d);\n\n        q1 = (*r > q0) ? q1 - 1 : q1;\n        *r = (*r > q0) ? *r + d : *r;\n\n        if (*r >= d) {\n                q1++;\n                *r -= d;\n        }\n\n#if defined(__GNUC__) && defined(__x86_64__) && !defined(NDEBUG)\n        uint64_t asmq, asmr;\n        __asm__(\"divq %2\" : \"=a\"(asmq), \"=d\"(asmr)\n                          : \"r\"(d), \"d\"(u1), \"a\"(u0) : \"cc\");\n        assert(q1 == asmq && *r == asmr);\n#endif\n\n        return q1;\n} \n```", "```\n/* Count leading zeros. */\n#if defined(__GNUC__)\nint clz(uint64_t x)\n{\n        assert(x != 0);\n        return __builtin_clzll(x);\n}\n#elif defined(_MSC_VER) && defined(_M_X64)\n#include <intrin.h> int clz(uint64_t x)\n{\n        assert(x != 0);\n        return __lzcnt64(x);\n}\n#else\nint clz(uint64_t x)\n{\n        int n = 0;\n        assert(x != 0);\n        while ((x << n) <= UINT64_MAX / 2) n++;\n        return n;\n}\n#endif\n\n/* Right-shift that also handles the 64 case. */\nuint64_t shr(uint64_t x, int n)\n{\n        return n < 64 ? (x >> n) : 0;\n} \n```", "```\n/* Divide n-place integer u by d, yielding n-place quotient q. */\nvoid divnby1(int n, const uint64_t *u, uint64_t d, uint64_t *q)\n{\n        uint64_t v, k, ui;\n        int l, i;\n\n        assert(d != 0);\n        assert(n > 0);\n\n        /* Normalize d, storing the shift amount in l. */\n        l = clz(d);\n        d <<= l;\n\n        /* Compute the reciprocal. */\n        v = reciprocal_word(d);\n\n        /* Perform the division. */\n        k = shr(u[n - 1], 64 - l);\n        for (i = n - 1; i >= 1; i--) {\n                ui = (u[i] << l) | shr(u[i - 1], 64 - l);\n                q[i] = div2by1(k, ui, d, &k, v);\n        }\n        q[0] = div2by1(k, u[0] << l, d, &k, v);\n} \n```", "```\nvoid eprime_manual(void)\n{\n        int n, i;\n        uint64_t *efrac;\n        uint64_t *term;\n        uint64_t d;\n        char *s;\n\n        efrac = calloc(NUM_WORDS, sizeof(*efrac));\n        term = calloc(NUM_WORDS, sizeof(*efrac));\n\n        /* Start efrac and term at 0.5\\. */\n        efrac[NUM_WORDS - 1] = (1ULL << 63);\n        term[NUM_WORDS - 1] = (1ULL << 63);\n\n        /* Sum the series. */\n        n = compute_n(NUM_DECIMALS);\n        for (i = 3; i <= n; i++) {\n                divnby1(NUM_WORDS, term, (uint64_t)i, term);\n                addn(NUM_WORDS, efrac, term, efrac);\n        } \n```", "```\n/* Multiply n-place integer u by x in place, returning the overflow word. */\nuint64_t mulnby1(int n, uint64_t *u, uint64_t x)\n{\n        uint64_t k, p1, p0;\n        int i;\n\n        k = 0;\n\n        for (i = 0; i < n; i++) {\n                umul(u[i], x, &p1, &p0);\n                u[i] = p0 + k;\n                k = p1 + (u[i] < p0);\n        }\n\n        return k;\n} \n```", "```\n /* Convert to decimal. */\n        s = malloc(19 * (NUM_DECIMALS / 19 + 18) + 1);\n        for (i = 0; i < NUM_DECIMALS; i += 19) {\n                d = mulnby1(NUM_WORDS, efrac, 10000000000000000000ULL);\n                sprintf(&s[i], \"%019\" PRIu64, d);\n        }\n#ifdef PRINT_E\n        printf(\"2.%.*s\\n\", NUM_DECIMALS, s);\n#endif \n```", "```\n/* Compute x * y mod n, where n << s is normalized and\n   v is the approximate reciprocal of n << s. */\nuint64_t mulmodn(uint64_t x, uint64_t y, uint64_t n, int s, uint64_t v)\n{\n        uint64_t hi, lo, r;\n\n        assert(s >= 0 && s < 64);\n        assert((n << s) > UINT64_MAX / 2 && \"n << s is normalized.\");\n        assert(x < n && y < n);\n\n        umul(x, y, &hi, &lo);\n        div2by1((hi << s) | shr(lo, 64 - s), lo << s, n << s, &r, v);\n\n        return r >> s;\n}\n\n/* Compute x^p mod n by means of left-to-right binary exponentiation. */\nuint64_t powmodn(uint64_t x, uint64_t p, uint64_t n)\n{\n        uint64_t res, v;\n        int i, l, s;\n\n        assert(x > 0 && x < n);\n\n        s = clz(n);\n        v = reciprocal_word(n << s);\n\n        res = x;\n        l = 63 - clz(p);\n\n        for (i = l - 1; i >= 0; i--) {\n                res = mulmodn(res, res, n, s, v);\n                if (p & (1ULL << i)) {\n                        res = mulmodn(res, x, n, s, v);\n                }\n        }\n\n        return res;\n}\n\n/* Miller-Rabin primality test a.k.a. \"Algorithm P\" in TAOCP 4.5.4\\. */\nbool is_prob_prime(uint64_t n)\n{\n        uint64_t q, x, y;\n        int i, j, k;\n\n        if (n == 2) {\n                return true;\n        } else if (n < 2 || n % 2 == 0) {\n                return false;\n        }\n\n        /* Find q and k such that n = 1 + 2^k * q, where q is odd. */\n        k = 0;\n        q = n - 1;\n        while (q % 2 == 0) {\n                k++;\n                q /= 2;\n        }\n\n        for (i = 0; i < 25; i++) {\n                x = ((uint64_t)rand() << 32) | (uint64_t)rand();\n                x = x % (n - 2) + 2;\n                assert(x > 1 && x < n);\n\n                j = 0;\n                y = powmodn(x, q, n);\n\n                for (;;) {\n                        if (y == n - 1 || (j == 0 && y == 1)) {\n                                /* Maybe prime; try another x. */\n                                break;\n                        } else if (y == 1 && j > 0) {\n                                return false;\n                        }\n\n                        j++;\n                        if (j >= k) {\n                                return false;\n                        }\n                        y = powmodn(y, 2, n);\n                }\n        }\n\n        return true;\n} \n```", "```\n /* Find the first prime. */\n        for (i = 0; i + 9 < NUM_DECIMALS; i++) {\n                if (s[i] == '0' || (s[i + 9] - '0') % 2 == 0) {\n                        /* Skip leading zeros and even numbers. */\n                        continue;\n                }\n\n                sscanf(&s[i], \"%10\" SCNu64, &d);\n                if (is_prob_prime(d)) {\n                        printf(\"%\" PRIu64 \" is prime\\n\", d);\n                        break;\n                }\n        }\n\n        free(term);\n        free(efrac);\n        free(s);\n} \n```", "```\n$ gcc -O3 -march=native -DNDEBUG -DNUM_DECIMALS=1000000ULL -lm -lgmp eprime.c\n$ time ./a.out\n7427466391 is prime\n\nreal\t2m0.800s\nuser\t2m0.872s\nsys\t0m0.000s \n```", "```\nvoid binsplit(uint64_t a, uint64_t b, mpz_t p, mpz_t q)\n{\n        uint64_t m;\n        mpz_t pmb, qmb;\n\n        assert(b > a);\n\n        if (b - a == 1) {\n                mpz_set_ui(p, 1);\n                mpz_set_ui(q, b);\n                return;\n        }\n\n        m = a + (b - a) / 2;\n        mpz_init(pmb);\n        mpz_init(qmb);\n\n        /* Compute p(a, m) and q(a, m), storing the results in p and q to avoid\n         * allocating extra variables. */\n        binsplit(a, m, p, q);\n\n        /* Compute p(m, b) and q(m, b) */\n        binsplit(m, b, pmb, qmb);\n\n        /* p(a,b) = p(a,m) * q(m,b) + p(m,b) */\n        mpz_mul(p, p, qmb);\n        mpz_add(p, p, pmb);\n\n        /* q(a,b) = q(a,m) * q(m,b) */\n        mpz_mul(q, q, qmb);\n\n        mpz_clear(pmb);\n        mpz_clear(qmb);\n}\n\nvoid eprime_binsplit(void)\n{\n        uint64_t n;\n        mpz_t p, q;\n        mpf_t e, qf;\n        char *s;\n        mp_exp_t strexp;\n\n        n = compute_n(NUM_DECIMALS);\n\n        /* Compute the fraction. */\n        mpz_init(p);\n        mpz_init(q);\n        binsplit(0, n, p, q);\n\n        /* Divide to rational. */\n        mpf_set_default_prec(NUM_BITS);\n        mpf_init(e);\n        mpf_init(qf);\n        mpf_set_z(e, p);\n        mpf_set_z(qf, q);\n        mpf_div(e, e, qf);\n        mpz_clear(p);\n        mpz_clear(q);\n        mpf_clear(qf);\n\n        /* Add the missing 1 term. */\n        mpf_add_ui(e, e, 1);\n\n        /* Convert to string of decimal digits. */\n        s = mpf_get_str(NULL, &strexp, 10, NUM_DIGITS, e);\n        mpf_clear(e);\n        assert(strexp == 1);\n        assert(strlen(s) == NUM_DIGITS);\n#ifdef PRINT_E\n        printf(\"2.%s\\n\", &s[1]);\n#endif\n        find_prime_gmp(&s[1]);\n        free(s);\n} \n```", "```\n$ gcc -O3 -march=native -DNDEBUG -DNUM_DECIMALS=1000000ULL -lm -lgmp eprime.c\n$ time ./a.out\n7427466391 is prime\n\nreal\t0m0.379s\nuser\t0m0.376s\nsys\t0m0.004s \n```", "```\n$ gcc -O3 -march=native -DNDEBUG -DNUM_DECIMALS=1000000000ULL -lm -lgmp eprime.c\n$ time ./a.out\n7427466391 is prime\n\nreal\t21m27.575s\nuser\t20m57.308s\nsys\t0m13.956s \n```"]