- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:14:10'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift for C++ Practitioners, Part 1: Intro & Value Types | Doug''s Compiler
    Corner'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.douggregor.net/posts/swift-for-cxx-practitioners-value-types/](https://www.douggregor.net/posts/swift-for-cxx-practitioners-value-types/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Swift for C++ Practitioners, Part 1: Intro & Value Types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a [Getting Started](https://www.swift.org/getting-started/) guide
    for Swift that''s good for a general audience. However, I''ve noticed that folks
    coming from C++ tend to struggle with certain aspects of Swift''s design, and
    can get themselves stuck. I think I understand why: the two languages feel similar
    enough that someone familiar with C++ will take the idioms and patterns from C++
    and project them on to Swift, which doesn''t always end up well. So, I want to
    take a different approach to teaching Swift that is specifically geared toward
    C++ "practitioners": folks who write C++ day-to-day and understand not only the
    C++ language, but its standard library and best practices. For you, dear C++ practitioner,
    I want to teach Swift by mapping from the idioms, patterns, and mental model of
    C++ into Swift. My hope is that you''ll come through this series of posts not
    just learning Swift, but learning how to use Swift *well*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a C++ programmer, some parts of Swift will feel like magic, such as separately
    type-checked generics and value types that compose beautifully, and we''ll revel
    in those. I''ll show how some of the aspects of C++ that we''ve collectively come
    to view as problematic, such as wrong defaults or avoidable foot guns, are addressed
    by Swift''s design. Other parts of Swift will grate against the sensibilities
    of a C++ practitioner, and we won''t shy away from those, either. Instead, we''ll
    explain what is different, why Swift is designed that way, and how to cope. I
    live in both worlds: I''m a Swift designer, implementer, and advocate, and yet
    I''ve a long history with C++ that includes being a code owner of Clang and spending
    a decade on the ISO C++ committee. Most of the code I write day-to-day is in the
    Swift compiler, which is mostly C++ but is migrating toward Swift.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Note:* You may have heard about [Swift''s interoperability with C++](https://www.swift.org/documentation/cxx-interop/).
    It''s a fantastic tool for incrementally moving a C++ code base toward Swift or
    wrapping up a C++ library in a nicer Swift interface. However, it''s the wrong
    place to start if you know C++ already and want to learn Swift. Instead, I recommend
    building something purely in Swift first, to get the feel for Swift without the
    "pull" of existing C++ code toward more C++-centric patterns. You''ll be able
    to integrate Swift better into your existing code bases once you have a solid
    understanding of both languages.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a multi-part series that will walk through the various features of Swift.
    We'll start with the obligatory "Hello, world" and then dive straight into *value
    types*.
  prefs: []
  type: TYPE_NORMAL
- en: Hello, World!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Okay, let''s get this over with: this is "Hello, World" in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But it''s more important to greet you, dear C++ practictioner, so let''s customize
    it a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `let` is how we declare an immutable variable, like `const` in C++, but
    with stronger guarantees: we''ll get to that later. We''ve omitted the type because
    Swift does type inference in a manner that''s similar to `auto` in C++, but we
    could have written the type explicitly with `let reader: String`. The triple-quotes
    describe a [multi-line string literal](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Multiline-String-Literals),
    and the `\(...)` syntax within it is [string interpolation](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#String-Interpolation),
    a feature common in scripting languages that makes it easy to plug values into
    the middle of a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++ provides rich support for *value types*, i.e., types for which each copy
    is completely independent of the original. Let''s take a simple example with C++
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `v1` is a vector containing `"Hello"` and `"original"`. When we make
    a copy `v2`, that copy is completely independent of the original: the change to
    `v2` on the last line, so that it contains `"Hello"` and `"copy"` , doesn''t modify
    the original `v1`.'
  prefs: []
  type: TYPE_NORMAL
- en: Many C++ types are value types, from builtin types like integers and floating-point
    types to standard library containers like `std::string`, `std::vector`, and `std::map`.
    C++ lets you build your own value types by letting you control how a class type
    is created, copied, and destroyed, so long as you follow the [Rule of Three/Five/Zero](https://en.cppreference.com/w/cpp/language/rule_of_three).
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift also emphasizes value types because they aid *local reasoning*, which
    is the ability to look at code in isolation and reason about what it does, and
    whether it does so correctly. When you copy an instance of a value type, you don''t
    need to worry that something you do will affect the original. As in C++, many
    Swift types are value types, including `String`, `Array`, and `Dictionary`, which
    are analogous to `std::string`, `std::vector`, and `std::map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we''ve introduced the `var` keyword: `var` introduces variables that can
    be modified (i.e., they are mutable), whereas `let` introduces variables that
    cannot be modified (they are immutable). In Swift, we prefer that you use `let`
    wherever you can, because immutability aids local reasoning: it''s easier to reason
    about something if it isn''t changing.'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating values in structs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As in C++, Swift has structs to aggregate data together. While in C++ the difference
    between `struct` and `class` is almost cosmetic (it only impacts whether the defaults
    are `public` vs. `private`), in Swift they are completely different animals. A
    Swift `struct` is generally a value type, whereas a Swift `class` is a class in
    the Object-Oriented sense of the word, and has *reference semantics*: copies still
    refer to the same underlying instance. We''ll get back to classes in a later post,
    because `struct`s are one way we build value types out of other value types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Structs containing other value types are themselves value types. For example,
    let''s use that labeled point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That first line is creating a new instance of a `LabeledPoint`, calling an *initializer*
    (that's what Swift calls constructors) to produce the new value from the component
    parts. The result is on the stack, not the heap, just like you'd expect in C++.
    Copying the `p1` value into `p2` produces a completely separate value, just as
    you'd expect from the corresponding C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Labeled arguments**: When creating the new `LabeledPoint` instance, notice
    that each of the arguments requires a label, e.g., `x:`, `y:`, and `label:`. By
    default, all function arguments must be labeled at the call site, which communicates
    information about what the function will be doing with the corresponding argument,
    aiding readability. This is particularly useful when combined with default arguments.
    A function can opt out of having a particular argument labeled, of course, and
    we''ll get back to that later.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Initialization always goes through initializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++ has a couple of different ways to initialize an instance of a `struct`,
    including constructor calls, initializer lists, default initialization, and copy
    initialization. Swift settles on one: calling an initializer. Initializers are
    responsible for initializing all of the fields of the struct before they return
    (no excuses). The creation of the `LabeledPoint` in the previous section is using
    the *memberwise* initializer that Swift provides automatically for structs, which
    initializes the fields in order from the corresponding parameters. We could go
    ahead and write out this initializer directly if we wanted to, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `init` keyword is what defines an initializer, and is the equivalent of
    repeating the class name in C++ to define a constructor, but usually less verbose.
    `self` is the Swift equivalent to `this`, but think of it as being a like a C++
    reference (`ClassName&`) rather than a pointer like it would be in C++ (`ClassName*`).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no special syntax for initializing the fields in a `struct`, like
    there is in C++. Instead, it''s just normal assignments to the fields, and the
    compiler checks that (1) you don''t read a field before it''s been assigned, and
    (2) all fields have been assigned before `self` is referenced as a whole object,
    including the function return. So let''s try out a semantic disaster of an initializer
    that breaks both rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Uses of uninitialized variables don''t happen in Swift, because of a semantic
    guarantee called *definite initialization*: the compiler checks that every variable
    is initialized before it is used, in all execution paths. This applies equally
    to all code, and it helps define away a class of bugs that bite us in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because of definite initialization, Swift has no notion of a default constructor
    the way C++ does. The variable `p` *is not initialized* on the line where it is
    defined, the way a C++ class with a non-trivial default constructor would be.
    Rather, you assign to it, and the first assignment is an initialization. You can't
    read from it before initializing it, so there is no *undefined behavior* due to
    uninitialized values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could write an initializer that takes no arguments, and perhaps that makes
    sense for points to (say) create the origin point, but Swift will never automatically
    call it: you''ll always call it explicitly. Let''s write that out so we can demonstrate
    the Swift equivalent to C++ [delegating constructors](https://learn.microsoft.com/en-us/cpp/cpp/delegating-constructors?view=msvc-170):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `self.init` delegates the responsibility for initializing all of
    the fields of `self` to another initializer. The rules of definite initialization
    kick in here, too: you can''t use (or initialize) any of the fields of `self`
    before the `self.init` call, and after that call `self` is fully initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: Where's my copy constructor?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By now, you''ve probably noted that we could write an initializer that looks
    very much like a copy constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `_` in the declaration of `other` is a placeholder for "not named", and
    here it means that the argument to this initializer is not named. Therefore, we
    can call this initializer with the syntax `LabeledPoint(other)`, just like one
    would in C++. However, Swift will never *implicitly* call an initializer like
    this, because it's not special in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Swift will copy, move, and destroy instances of structs by performing those
    operations directly on each instance property of the `struct`. In essence, a Swift
    `struct` always follows the C++ [rule of zero](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero),
    where one relies on the default implementations of all of the special constructors,
    assignment operators, and destructor. In practice, this means that it's not possible
    to observe when Swift is making copies of value types, so the compiler is free
    to make copies that are necessary for implementing the semantics of the program,
    and optimize away copies when they are no longer needed. The compiler can even
    implicitly turn a "copy" into a move when it determines that the source of the
    copy is going away.
  prefs: []
  type: TYPE_NORMAL
- en: For a type that needs hold on to resources, Swift has classes, which I've already
    noted will be the subject of another post. Swift also has a notion of "noncopyable"
    types, but those will come much later. For now, we'll dive deeper into value types.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability runs deep with value types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier, we introduced `let` as a way to create immutable local variables.
    With value types, immutability is the default. Parameters are immutable unless
    otherwise specified, which also includes `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'One can create methods that mutate `self` by putting the `mutating` modifier
    before the `func` keyword. Let''s start with a sensible example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For other parameters, one can place `inout` on the parameter to indicate that
    it is meant to be modified by the function. Formally, `mutating` on the function
    is equivalant to `inout` on the `self` parameter, but Swift uses `mutating` because
    it reads better. With `inout` parameters and `mutating` methods, we can write
    a working version of the `badSwapX` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling a function with an `inout` argument, the argument must be prefixed
    with `&` to indicate that we''re passing it''s (logical) address to the function.
    For example, here''s a call to `swapX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value we are trying to apply `&` to is immutable, the Swift compiler
    would produce an error. Note that there is no prefix `&` on `p1`, even though
    it''s calling a `mutable` method: it''s not needed because the name of the method
    should [clearly imply the mutation](https://www.swift.org/documentation/api-design-guidelines/).
    Of course, if `p1` were immutable, it would still be an error.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two more important things to say about immutability before we move
    on to our next kind of value type, `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you *cannot cheat immutability* any more than you can cheat Death. There
    is no equivalent to the C++ `const_cast` in Swift. There are no `mutable` data
    members in Swift; even a `var` member of a struct can only be modified on a `var`
    instance of that struct. There are no `const T&` parameters whose values can change
    out from underneath you: an immutable value is truly immutable, and the compiler
    makes sure that no matter how an immutable parameter is actually passed (by-value
    or by-reference), the underlying value won''t change. This can be frustrating,
    because you''ve given up control about when to pass by-value, pass by `const`
    reference, or pass by rvalue reference to do a move. On the other hand, it is
    liberating: there''s no spooky-action-at-a-distance when that `const&` actually
    *does* change underneath you, and you can lean on immutability to make it easier
    to reason about your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That brings us to the second point: *there is no aliasing of inout parameters*.
    Aliasing, as I mean it here, is when two different pass-by-reference parameters
    actually refer to the same underlying instance. If you''ve ever had to go add
    an `if (this == &other) { ... }` check into your copy or move assignment operator
    in C++, you know just how vicious unexpected aliasing of parameters can be for
    program semantics. In Swift, we have the [law of exclusivity](https://github.com/apple/swift/blob/main/docs/OwnershipManifesto.md#the-law-of-exclusivity),
    which prevents any such aliasing.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory safety and the law of exclusivity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift''s *law of exclusivity* states that two accesses to a given value in
    memory can only occur simultaneously if both of them are reads, so it is an error
    to (for example) try to form a mutating access (such as passing something `inout`)
    while accessing that value. But this isn''t some abstract rule that introduces
    undefined behavior when you mess up: Swift enforces the law of exclusivity through
    a combination of static checking (which can produce compiler errors if you produce
    aliasing) and dynamic checking (when it''s not possible for the compiler to prove
    that there is no aliasing).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Static checking of the law of exclusivity applies when the value being accessed
    is sufficiently local that it''s possible to reason about all possible accesses
    to that value. Value types are great for this, because two independent `var` instances
    of value type are guaranteed not to alias. The compiler can correctly determine
    that the two `inout` arguments in the call `p1.swapX(&p2)` do not alias, because
    `p1` and `p2` are separate variables. If one instead wrote `p1.swapX(&p1)`, the
    compiler would produce an error describing the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we''re dealing with a variable that isn''t local---say it''s a global
    variable (gasp!) or a member of a reference type like a `class`, then it''s impossible
    to reason about all of the accesses. Let''s build a small contrived example of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Within `swapXWithGlobalOrigin`, there is no way to know whether some other
    part of the program might access `globalOrigin` while it runs. So, the Swift compiler
    will insert a runtime check that tracks when `globalOrigin` is potentially being
    modified, and will stop the program if a simultaneous access occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Most Swift programmers never think about the Law of Exclusivity: it''s enforcement
    is there to prevent mistakes that would cause undefined behavior mayhem in C++,
    so it''s critical to Swift''s memory-safety story. But a lot of mutation in Swift
    works on local values, and the language helps you avoid most of these situations,
    so the runtime checking is rarely encountered in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Enums are the union of enums and unions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enums are one of Swift''s loveliest little features. We borrowed them from
    [CLU](https://en.wikipedia.org/wiki/CLU_(programming_language)), and for a time
    before Swift 1.0 they even used the keyword `oneof` . A Swift enum is a type-safe
    variant, which subsumes C++''s `enum`, `union`, and `std::variant` in one nice
    little package. An enum can express one of a set of named cases, such as a font
    size expressed via semantic names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This enum works just like you''d expect the equivalent C++ `enum class`. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I snuck a `switch` statement in there because one often uses switch statements
    to deal with each of the cases in an enum. Switch statements in Swift must always
    be exhaustive: if you don''t handle all possible cases, you need to add a `default`
    clause. This eliminates accidents of omission when (for example) someone adds
    a new case, and is commonly a warning in C++ compilers. If you''ve been cringing
    about the missing `break` statements above, don''t: Swift puts a `break` before
    the next case, and if you really want to fall through to the next case, you have
    to explicitly write `fallthrough` to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to `FontSize`: the cases of `FontSize` are inside the type. If you want
    to refer to the `paragraph` case, you can do so with `FontSize.paragraph`. However,
    whenever there is type information, such as when you''re initializing a variable
    of type `FontSize` or switching on a value of type `FontSize`, you can use the
    *leading dot syntax* like `.paragraph` and let Swift''s type inference figure
    out the type. Compare the above to the corresponding C++ `enum class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s the little things, but they really do add up to cleaner code. Swift''s
    leading dot syntax works really nicely with labeled arguments, because the argument
    label implies the type of the argument, leading to very readable code. For example,
    let''s imagine a `Font` struct that uses `FontSize` along with `FontStyle` and
    `FontWeight` enums, including some default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a new `Font` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the argument labels `size` and `weight` naturally describe the arguments
    that follow them, and the types provide enough information so we don''t need to
    write out the redundant `FontSize` and `FontWeight` types on those arguments.
    Moreover, we are able to use the default argument for `style` even though it''s
    the first parameter: labeled arguments make default arguments work really well.
    These are simple design decisions for a language to make, but they reinforce readable
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, back to enums! Imagine that you wrote that `FontSize` as an `enum
    class` in C++. Hold it in your mind. It''s simple, it works. Now, someone comes
    along and tells you that you need to support *custom* font sizes, which can be
    expressed in terms of points. Your nice `enum class` is out the window, because
    you can''t enumerate all of the custom point sizes. Here''s the pattern I would
    use in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That is a *lot* of code. It is implementing a type-safe union that consists
    of the three simple cases, plus the one `custom` case. I cringe ever time I have
    to write one of these in C++ (which happens a lot), because it is so much boilerplate
    and it's so easy to make a silly mistake. I've yet to come across a C++ technique
    or library that makes this cleaner. Feel free to let me know if you have a significantly
    more elegant solution in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, you add one case to `FontSize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift cases can carry values in them, which is why I said earlier that they
    also are like C++ unions---without all of the undefined behavior. Given this case,
    I can create a custom font size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And extend my `switch` statement accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Swift provides pattern matching. When we match the `custom` case, we also declare
    a new variable `pt` to capture the `points` value. The value `pt` is only available
    when one is using a custom font size, so there's no need for runtime assertions
    like `kind == custom` like we had in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add one more case to our font size, which lets us take an existing font
    size and scale it by a given factor. It can be expressed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This way, one can construct a font that is 20% larger than the paragraph font
    using, e.g.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `indirect` is needed to indicate that the value associated with the case
    (called the *associated value* in Swift) needs to be stored *indirectly*, because
    the associated value contains an instance of `FontSize` itself. Enums are value
    types and generally use stack storage, so the `indirect` indicates when the value
    for the case needs to be moved off to the heap. If the `indirect` were missing,
    the compiler would complain because the `FontSize` type doesn''t have a fixed
    size in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Indirect enum cases are useful for building recursive data structures, like
    a binary tree. We'll come back to those when we can do it properly, with generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create a nice member function that scales the font instance we have
    by a specific factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be called as, e.g., `myFontSize.scaled(by: 1.2)`. There are a few
    little things to notice here. The first is that enums can have methods just like
    structs can. They can also have initializers, which must eventually assign one
    of the cases to `self`. Next, our function is returning `Self`, which is shorthand
    for "the type of `self`". Finally, look at how the parameter is named, "`by factor`":
    here, the *argument label* is `by` (it''s used at the call site) and the *parameter
    name* is `factor` (it''s used inside the body). This is because the argument label
    is there to describe the argument at the call site, i.e., we''re scaling "`by`
    1.2", whereas the parameter name is the noun of what the parameter actually is---the
    `factor` used in the computation. Before now, we''ve seen that the two names are
    generally the same, or the argument label is omitted, but separating the two can
    lead to elegant, readable code particularly when the argument label is a preposition.'
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard Swift collections types `Array`, `Dictionary`, and `Set` are value
    types when they are storing value types. For example, we could have an array of
    `Font` instances, which will behave as a value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Dictionaries and sets work similarly. For example, let''s build a dictionary
    that names all of our fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The bracket syntax is used for both dictionary literals (when the elements
    are `key: value` pairs) and array literals (when the elements are just... elements).
    The literals are actually extensible: you can use an array literal to initialize
    a `Set`, or even your own type, by defining an appropriate initializer and opting
    in to be "expressible by" that literal type using the generics system. (More on
    that in a later post, I promise.)'
  prefs: []
  type: TYPE_NORMAL
- en: Regular types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++ we sometimes talk about [regular types](http://stepanovpapers.com/DeSt98.pdf),
    defined by Alexander Stepanov, which are types that behave predictably with respect
    to value semantics: you can copy them, and the copy is equal to the original.
    They can be moved, destroyed, and swapped. C++20 has a [`std::regular` concept](https://en.cppreference.com/w/cpp/concepts/regular)
    to capture these requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Swift value types fulfill most of the requirements of a regular type by default,
    and are based on the same semantic contract. Swift value types are always copyable,
    destructible, assignable, and movable. Indeed, you can't really even express these
    ideas in Swift, it's just the way types behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some notable differences from the Stepanov or C++ standard
    definitions of a regular type. The first was noted earlier: Swift doesn''t have
    a notion of "default construction" at all, so Swift value types are not "default
    constructible". You tend not to need this notion in Swift, though, because of
    definite initialization. There is a benefit here for the authors of types: you
    don''t have to worry about inventing a "default" state if one doesn''t make sense.
    For example, imagine an collection that is always non-empty: how would you give
    it a default constructor? You can''t without doing something weird, like adding
    a single default-constructed element, so such a type can''t be regular.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular types also have (in)equality operators (`==` and `!=`). Swift doesn't
    provide those for free, but you can either write them yourself with, e.g.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'or let the compiler do it for you, by putting `: Equatable` in the type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This says that the `Font` type is `Equatable`, and the compiler will synthesize
    both `==` and `!=` for you based on the data members. You can also put `Hashable`
    here to get a hash function that combines the data members, which then allows
    your type to be used as a key in a `Dictionary` or a value in a `Set`. Again,
    this is dipping our toes into Swift's generics system, but for now you can think
    of `Equatable` as being a little bit like a C++ concept (we call it a *protocol*
    in Swift), but... better.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve talked about value types---a lot. If you''re writing Swift, you should
    use them often, because they provide excellent local reasoning and the ability
    to model most data in a straightforward manner: `struct`s and collections to aggregate
    data and `enum`s to capture different choices.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of this series, we'll talk about reference types. Specifically,
    classes, and how Swift supports Object-Oriented Programming.
  prefs: []
  type: TYPE_NORMAL
