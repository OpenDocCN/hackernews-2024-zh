- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 13:14:10'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 13:14:10'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'Swift for C++ Practitioners, Part 1: Intro & Value Types | Doug''s Compiler
    Corner'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Swift for C++ Practitioners, Part 1: Intro & Value Types | Doug''s Compiler
    Corner'
- en: 来源：[https://www.douggregor.net/posts/swift-for-cxx-practitioners-value-types/](https://www.douggregor.net/posts/swift-for-cxx-practitioners-value-types/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://www.douggregor.net/posts/swift-for-cxx-practitioners-value-types/](https://www.douggregor.net/posts/swift-for-cxx-practitioners-value-types/)
- en: 'Swift for C++ Practitioners, Part 1: Intro & Value Types'
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Swift for C++ Practitioners, Part 1: Intro & Value Types'
- en: 'There is a [Getting Started](https://www.swift.org/getting-started/) guide
    for Swift that''s good for a general audience. However, I''ve noticed that folks
    coming from C++ tend to struggle with certain aspects of Swift''s design, and
    can get themselves stuck. I think I understand why: the two languages feel similar
    enough that someone familiar with C++ will take the idioms and patterns from C++
    and project them on to Swift, which doesn''t always end up well. So, I want to
    take a different approach to teaching Swift that is specifically geared toward
    C++ "practitioners": folks who write C++ day-to-day and understand not only the
    C++ language, but its standard library and best practices. For you, dear C++ practitioner,
    I want to teach Swift by mapping from the idioms, patterns, and mental model of
    C++ into Swift. My hope is that you''ll come through this series of posts not
    just learning Swift, but learning how to use Swift *well*.'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个[入门指南](https://www.swift.org/getting-started/)适合广泛的受众。然而，我注意到从C++过来的人往往会在Swift的某些设计方面遇到困难，并且可能会陷入困境。我认为我理解其中的原因：这两种语言在感觉上相似到足以让熟悉C++的人将C++的习惯和模式投射到Swift上，但结果并不总是理想的。因此，我想以一种针对C++“从业者”的不同方式教授Swift：那些日常写C++并了解C++语言、标准库和最佳实践的人。亲爱的C++从业者，我想通过将C++的习惯、模式和心理模型映射到Swift中来教授Swift。我希望通过这一系列文章，你不仅学会Swift，还学会如何*优雅地*使用Swift。
- en: 'As a C++ programmer, some parts of Swift will feel like magic, such as separately
    type-checked generics and value types that compose beautifully, and we''ll revel
    in those. I''ll show how some of the aspects of C++ that we''ve collectively come
    to view as problematic, such as wrong defaults or avoidable foot guns, are addressed
    by Swift''s design. Other parts of Swift will grate against the sensibilities
    of a C++ practitioner, and we won''t shy away from those, either. Instead, we''ll
    explain what is different, why Swift is designed that way, and how to cope. I
    live in both worlds: I''m a Swift designer, implementer, and advocate, and yet
    I''ve a long history with C++ that includes being a code owner of Clang and spending
    a decade on the ISO C++ committee. Most of the code I write day-to-day is in the
    Swift compiler, which is mostly C++ but is migrating toward Swift.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名C++程序员，Swift的某些部分会让人感到像魔术一样，例如独立类型检查的泛型和精美组合的值类型，我们会为此感到兴奋。我将展示Swift设计如何解决我们共同认为问题的C++方面，例如错误的默认设置或可避免的问题。Swift的设计方式。Swift的其他部分可能会与C++从业者的理念不合，我们也不会回避这些。相反，我们将解释不同之处，Swift为何以此设计，以及如何应对。我身兼两个世界：我是Swift的设计师、实现者和倡导者，同时我在C++方面也有着悠久的历史，包括是Clang的代码所有者并在ISO
    C++委员会上度过了十年。我日常大部分编写的代码是在Swift编译器中，虽然大部分是C++，但正向Swift迁移。
- en: '*Note:* You may have heard about [Swift''s interoperability with C++](https://www.swift.org/documentation/cxx-interop/).
    It''s a fantastic tool for incrementally moving a C++ code base toward Swift or
    wrapping up a C++ library in a nicer Swift interface. However, it''s the wrong
    place to start if you know C++ already and want to learn Swift. Instead, I recommend
    building something purely in Swift first, to get the feel for Swift without the
    "pull" of existing C++ code toward more C++-centric patterns. You''ll be able
    to integrate Swift better into your existing code bases once you have a solid
    understanding of both languages.'
  id: totrans-split-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*注意：* 你可能听说过[Swift与C++的互操作性](https://www.swift.org/documentation/cxx-interop/)。这是一个非常棒的工具，可以逐步将C++代码库转向Swift，或者用更好的Swift接口包装C++库。但如果你已经了解C++并想学习Swift，这不是开始的好地方。相反，我建议首先纯粹用Swift构建一些东西，以便了解Swift的感觉，而不是被现有C++代码向更C++-centric的模式拉扯。一旦你对两种语言都有了扎实的理解，就能更好地将Swift整合到现有的代码库中去。'
- en: This is a multi-part series that will walk through the various features of Swift.
    We'll start with the obligatory "Hello, world" and then dive straight into *value
    types*.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个多部分系列，将详细介绍Swift的各种特性。我们将从必备的“Hello, world”开始，然后直接深入*值类型*。
- en: Hello, World!
  id: totrans-split-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello, World!
- en: 'Okay, let''s get this over with: this is "Hello, World" in Swift:'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们把这事儿过去：这是 Swift 中的 "Hello, World"：
- en: '[PRE0]'
  id: totrans-split-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But it''s more important to greet you, dear C++ practictioner, so let''s customize
    it a little bit:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但更重要的是向你问好，亲爱的 C++ 实践者，所以让我们稍微定制一下：
- en: '[PRE1]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `let` is how we declare an immutable variable, like `const` in C++, but
    with stronger guarantees: we''ll get to that later. We''ve omitted the type because
    Swift does type inference in a manner that''s similar to `auto` in C++, but we
    could have written the type explicitly with `let reader: String`. The triple-quotes
    describe a [multi-line string literal](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Multiline-String-Literals),
    and the `\(...)` syntax within it is [string interpolation](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#String-Interpolation),
    a feature common in scripting languages that makes it easy to plug values into
    the middle of a string.'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 关键字用于声明不可变变量，类似于 C++ 中的 `const`，但提供更强的保证：我们稍后会详细讨论。我们省略了类型，因为 Swift 使用类型推断方式类似于
    C++ 中的 `auto`，不过我们也可以显式地写出类型，如 `let reader: String`。三重引号描述了[多行字符串字面量](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Multiline-String-Literals)，其中的
    `\(...)` 语法是[字符串插值](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#String-Interpolation)，这是一种常见的脚本语言特性，方便在字符串中插入值。'
- en: Value types
  id: totrans-split-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型
- en: 'C++ provides rich support for *value types*, i.e., types for which each copy
    is completely independent of the original. Let''s take a simple example with C++
    vectors:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 提供了对*值类型*的广泛支持，即每个副本都完全独立于原始对象。让我们以 C++ 向量的简单示例来说明：
- en: '[PRE2]'
  id: totrans-split-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `v1` is a vector containing `"Hello"` and `"original"`. When we make
    a copy `v2`, that copy is completely independent of the original: the change to
    `v2` on the last line, so that it contains `"Hello"` and `"copy"` , doesn''t modify
    the original `v1`.'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`v1` 是一个包含 `"Hello"` 和 `"original"` 的向量。当我们复制 `v2` 时，该复制完全独立于原始对象：最后一行对
    `v2` 进行的更改，使其包含 `"Hello"` 和 `"copy"`，不会修改原始的 `v1`。
- en: Many C++ types are value types, from builtin types like integers and floating-point
    types to standard library containers like `std::string`, `std::vector`, and `std::map`.
    C++ lets you build your own value types by letting you control how a class type
    is created, copied, and destroyed, so long as you follow the [Rule of Three/Five/Zero](https://en.cppreference.com/w/cpp/language/rule_of_three).
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 C++ 类型都是值类型，从内置类型如整数和浮点类型到标准库容器如 `std::string`、`std::vector` 和 `std::map`。C++
    允许你通过控制类类型的创建、复制和销毁方式来构建自己的值类型，只要你遵循[三五零法则](https://en.cppreference.com/w/cpp/language/rule_of_three)。
- en: 'Swift also emphasizes value types because they aid *local reasoning*, which
    is the ability to look at code in isolation and reason about what it does, and
    whether it does so correctly. When you copy an instance of a value type, you don''t
    need to worry that something you do will affect the original. As in C++, many
    Swift types are value types, including `String`, `Array`, and `Dictionary`, which
    are analogous to `std::string`, `std::vector`, and `std::map`:'
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 也强调值类型，因为它们有助于*局部推理*，即能够单独查看代码并推断它的作用及其是否正确。当你复制值类型的实例时，你不需要担心你做的任何事情会影响到原始对象。和
    C++ 类似，许多 Swift 类型都是值类型，包括 `String`、`Array` 和 `Dictionary`，它们分别类似于 `std::string`、`std::vector`
    和 `std::map`：
- en: '[PRE3]'
  id: totrans-split-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we''ve introduced the `var` keyword: `var` introduces variables that can
    be modified (i.e., they are mutable), whereas `let` introduces variables that
    cannot be modified (they are immutable). In Swift, we prefer that you use `let`
    wherever you can, because immutability aids local reasoning: it''s easier to reason
    about something if it isn''t changing.'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们引入了 `var` 关键字：`var` 用于声明可修改的变量（即它们是可变的），而 `let` 用于声明不可修改的变量（它们是不可变的）。在 Swift
    中，我们建议尽可能使用 `let`，因为不可变性有助于局部推理：如果某物不在变化，推理它就更容易。
- en: Aggregating values in structs
  id: totrans-split-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在结构体中聚合值
- en: 'As in C++, Swift has structs to aggregate data together. While in C++ the difference
    between `struct` and `class` is almost cosmetic (it only impacts whether the defaults
    are `public` vs. `private`), in Swift they are completely different animals. A
    Swift `struct` is generally a value type, whereas a Swift `class` is a class in
    the Object-Oriented sense of the word, and has *reference semantics*: copies still
    refer to the same underlying instance. We''ll get back to classes in a later post,
    because `struct`s are one way we build value types out of other value types:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++一样，Swift有结构体来聚合数据。而在C++中，`struct`和`class`之间的区别几乎只是装饰性的（仅影响默认是`public`还是`private`），在Swift中它们完全是不同的实体。Swift的`struct`通常是值类型，而Swift的`class`则是面向对象意义上的类，并具有*引用语义*：复制仍然引用相同的底层实例。我们稍后会再次讨论类，因为`struct`是我们从其他值类型构建值类型的一种方式：
- en: '[PRE4]'
  id: totrans-split-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Structs containing other value types are themselves value types. For example,
    let''s use that labeled point:'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 包含其他值类型的结构体本身也是值类型。例如，让我们使用那个带标签的点：
- en: '[PRE5]'
  id: totrans-split-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That first line is creating a new instance of a `LabeledPoint`, calling an *initializer*
    (that's what Swift calls constructors) to produce the new value from the component
    parts. The result is on the stack, not the heap, just like you'd expect in C++.
    Copying the `p1` value into `p2` produces a completely separate value, just as
    you'd expect from the corresponding C++ code.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那一行首先创建了一个`LabeledPoint`的新实例，调用一个*初始化器*（这就是Swift称为构造函数的东西），从组件部分产生新值。结果在堆栈上，而不是堆上，就像你在C++中期望的那样。将`p1`的值复制到`p2`会产生一个完全独立的值，就像对应的C++代码所期望的那样。
- en: '**Labeled arguments**: When creating the new `LabeledPoint` instance, notice
    that each of the arguments requires a label, e.g., `x:`, `y:`, and `label:`. By
    default, all function arguments must be labeled at the call site, which communicates
    information about what the function will be doing with the corresponding argument,
    aiding readability. This is particularly useful when combined with default arguments.
    A function can opt out of having a particular argument labeled, of course, and
    we''ll get back to that later.'
  id: totrans-split-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**带标签的参数**：在创建新的`LabeledPoint`实例时，请注意每个参数都需要一个标签，例如，`x:`、`y:`和`label:`。默认情况下，所有函数参数必须在调用站点上打上标签，这有助于传达函数将如何处理相应参数的信息，提高可读性。这在与默认参数结合使用时特别有用。当然，函数可以选择不标记某个特定参数，我们稍后会回到这一点。'
- en: Initialization always goes through initializers
  id: totrans-split-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化总是通过初始化器进行。
- en: 'C++ has a couple of different ways to initialize an instance of a `struct`,
    including constructor calls, initializer lists, default initialization, and copy
    initialization. Swift settles on one: calling an initializer. Initializers are
    responsible for initializing all of the fields of the struct before they return
    (no excuses). The creation of the `LabeledPoint` in the previous section is using
    the *memberwise* initializer that Swift provides automatically for structs, which
    initializes the fields in order from the corresponding parameters. We could go
    ahead and write out this initializer directly if we wanted to, like this:'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: C++有几种不同的方法来初始化`struct`的实例，包括构造函数调用、初始化列表、默认初始化和复制初始化。Swift选择其中一种：调用初始化器。初始化器负责在返回之前初始化结构的所有字段（没有任何借口）。在上一节中创建`LabeledPoint`正在使用Swift为结构体自动提供的*逐成员*初始化器，该初始化器按顺序从相应的参数初始化字段。如果我们愿意，我们也可以直接编写此初始化器，就像这样：
- en: '[PRE6]'
  id: totrans-split-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `init` keyword is what defines an initializer, and is the equivalent of
    repeating the class name in C++ to define a constructor, but usually less verbose.
    `self` is the Swift equivalent to `this`, but think of it as being a like a C++
    reference (`ClassName&`) rather than a pointer like it would be in C++ (`ClassName*`).
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`关键字是定义初始化器的内容，并且相当于在C++中重复类名以定义构造函数，但通常不那么冗长。`self`是Swift中相当于`this`的东西，但将其视为类似于C++引用（`ClassName&`）而不是指针，因为在C++中它将是指针（`ClassName*`）。'
- en: 'There is no special syntax for initializing the fields in a `struct`, like
    there is in C++. Instead, it''s just normal assignments to the fields, and the
    compiler checks that (1) you don''t read a field before it''s been assigned, and
    (2) all fields have been assigned before `self` is referenced as a whole object,
    including the function return. So let''s try out a semantic disaster of an initializer
    that breaks both rules:'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `struct` 中没有初始化字段的特殊语法，就像在 C++ 中一样。相反，它只是对字段的普通赋值，并且编译器检查：(1) 你不能在赋值之前读取一个字段，以及
    (2) 在引用 `self` 作为整个对象之前，所有字段都已经赋值。因此，让我们尝试一个破坏这两条规则的语义灾难初始化器：
- en: '[PRE7]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Uses of uninitialized variables don''t happen in Swift, because of a semantic
    guarantee called *definite initialization*: the compiler checks that every variable
    is initialized before it is used, in all execution paths. This applies equally
    to all code, and it helps define away a class of bugs that bite us in C++:'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中不会出现未初始化变量的使用，因为有一个语义保证称为 *明确初始化*：编译器会检查在所有执行路径上，在使用之前每个变量都已初始化。这同样适用于所有代码，并且有助于消除在
    C++ 中困扰我们的一类错误：
- en: '[PRE8]'
  id: totrans-split-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because of definite initialization, Swift has no notion of a default constructor
    the way C++ does. The variable `p` *is not initialized* on the line where it is
    defined, the way a C++ class with a non-trivial default constructor would be.
    Rather, you assign to it, and the first assignment is an initialization. You can't
    read from it before initializing it, so there is no *undefined behavior* due to
    uninitialized values.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于明确初始化的存在，Swift 没有像 C++ 那样的默认构造函数概念。变量 `p` 在定义的那一行 *未初始化*，就像一个具有非平凡默认构造函数的
    C++ 类。相反，你要对其进行赋值，而第一次赋值就是初始化。你不能在初始化之前读取它，因此不存在由于未初始化值而导致的 *未定义行为*。
- en: 'You could write an initializer that takes no arguments, and perhaps that makes
    sense for points to (say) create the origin point, but Swift will never automatically
    call it: you''ll always call it explicitly. Let''s write that out so we can demonstrate
    the Swift equivalent to C++ [delegating constructors](https://learn.microsoft.com/en-us/cpp/cpp/delegating-constructors?view=msvc-170):'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写一个不接受任何参数的初始化器，也许对于点来说这是有意义的（比如创建原点），但是 Swift 不会自动调用它：你总是需要显式调用它。让我们写出来，这样我们可以展示
    Swift 中等同于 C++ 的 [委托构造函数](https://learn.microsoft.com/en-us/cpp/cpp/delegating-constructors?view=msvc-170)：
- en: '[PRE9]'
  id: totrans-split-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The call to `self.init` delegates the responsibility for initializing all of
    the fields of `self` to another initializer. The rules of definite initialization
    kick in here, too: you can''t use (or initialize) any of the fields of `self`
    before the `self.init` call, and after that call `self` is fully initialized.'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `self.init` 的调用将初始化 `self` 的所有字段的责任委托给另一个初始化器。明确初始化的规则也适用于这里：在 `self.init`
    调用之前，你不能使用（或初始化）`self` 的任何字段；而在那之后，`self` 就完全初始化了。
- en: Where's my copy constructor?
  id: totrans-split-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我的复制构造函数在哪里？
- en: 'By now, you''ve probably noted that we could write an initializer that looks
    very much like a copy constructor:'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到，我们可以编写一个看起来非常像复制构造函数的初始化器：
- en: '[PRE10]'
  id: totrans-split-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `_` in the declaration of `other` is a placeholder for "not named", and
    here it means that the argument to this initializer is not named. Therefore, we
    can call this initializer with the syntax `LabeledPoint(other)`, just like one
    would in C++. However, Swift will never *implicitly* call an initializer like
    this, because it's not special in any way.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`other` 声明中的 `_` 是一个“未命名”的占位符，这里表示该初始化器的参数未命名。因此，我们可以使用 `LabeledPoint(other)`
    这样的语法来调用这个初始化器，就像在 C++ 中一样。然而，Swift 永远不会 *隐式* 调用这样的初始化器，因为它没有任何特殊之处。'
- en: Swift will copy, move, and destroy instances of structs by performing those
    operations directly on each instance property of the `struct`. In essence, a Swift
    `struct` always follows the C++ [rule of zero](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero),
    where one relies on the default implementations of all of the special constructors,
    assignment operators, and destructor. In practice, this means that it's not possible
    to observe when Swift is making copies of value types, so the compiler is free
    to make copies that are necessary for implementing the semantics of the program,
    and optimize away copies when they are no longer needed. The compiler can even
    implicitly turn a "copy" into a move when it determines that the source of the
    copy is going away.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 将通过在 `struct` 的每个实例属性上直接执行这些操作来复制、移动和销毁 `struct` 的实例。实质上，Swift 的 `struct`
    总是遵循 C++ 的 [zero rule](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero)，其中依赖于所有特殊构造函数、赋值运算符和析构函数的默认实现。实际上，这意味着不可能观察到
    Swift 何时正在复制值类型的实例，因此编译器可以自由地进行必要的复制以实现程序的语义，并在不再需要时优化掉复制。当编译器确定复制源即将消失时，它甚至可以隐式地将“复制”转换为移动。
- en: For a type that needs hold on to resources, Swift has classes, which I've already
    noted will be the subject of another post. Swift also has a notion of "noncopyable"
    types, but those will come much later. For now, we'll dive deeper into value types.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要保留资源的类型，Swift 有类，我已经注意到将是另一篇文章的主题。Swift 也有“不可复制”类型的概念，但这些将在稍后讨论。现在，我们将更深入地探讨值类型。
- en: Immutability runs deep with value types
  id: totrans-split-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性在值类型中深入运行。
- en: 'Earlier, we introduced `let` as a way to create immutable local variables.
    With value types, immutability is the default. Parameters are immutable unless
    otherwise specified, which also includes `self`:'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们介绍了 `let` 作为创建不可变局部变量的一种方式。对于值类型，不可变性是默认的。除非另有规定，否则参数是不可变的，这也包括 `self`：
- en: '[PRE11]'
  id: totrans-split-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One can create methods that mutate `self` by putting the `mutating` modifier
    before the `func` keyword. Let''s start with a sensible example:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `func` 关键字之前放置 `mutating` 修改器，可以创建可以突变 `self` 的方法。让我们从一个合理的例子开始：
- en: '[PRE12]'
  id: totrans-split-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For other parameters, one can place `inout` on the parameter to indicate that
    it is meant to be modified by the function. Formally, `mutating` on the function
    is equivalant to `inout` on the `self` parameter, but Swift uses `mutating` because
    it reads better. With `inout` parameters and `mutating` methods, we can write
    a working version of the `badSwapX` method:'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他参数，可以在参数上放置 `inout` 来指示它是由函数修改的意图。形式上，函数上的 `mutating` 等同于 `self` 参数上的 `inout`，但
    Swift 使用 `mutating` 因为它读起来更好。通过 `inout` 参数和 `mutating` 方法，我们可以编写 `badSwapX` 方法的工作版本：
- en: '[PRE13]'
  id: totrans-split-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When calling a function with an `inout` argument, the argument must be prefixed
    with `&` to indicate that we''re passing it''s (logical) address to the function.
    For example, here''s a call to `swapX`:'
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用具有 `inout` 参数的函数时，必须在参数前加上 `&`，以表明我们正在将其（逻辑）地址传递给函数。例如，这里是对 `swapX` 的调用：
- en: '[PRE14]'
  id: totrans-split-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the value we are trying to apply `&` to is immutable, the Swift compiler
    would produce an error. Note that there is no prefix `&` on `p1`, even though
    it''s calling a `mutable` method: it''s not needed because the name of the method
    should [clearly imply the mutation](https://www.swift.org/documentation/api-design-guidelines/).
    Of course, if `p1` were immutable, it would still be an error.'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图将 `&` 应用于的值是不可变的，Swift 编译器会产生一个错误。请注意，即使在调用`可变`方法时，`p1` 上没有前缀 `&`：因为方法的名称应该[清楚地暗示突变](https://www.swift.org/documentation/api-design-guidelines/)。当然，如果
    `p1` 是不可变的，那么仍然会出现错误。
- en: There are two more important things to say about immutability before we move
    on to our next kind of value type, `enum`.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向下一个值类型 `enum` 之前，还有两件关于不可变性的重要事情要说。
- en: 'First, you *cannot cheat immutability* any more than you can cheat Death. There
    is no equivalent to the C++ `const_cast` in Swift. There are no `mutable` data
    members in Swift; even a `var` member of a struct can only be modified on a `var`
    instance of that struct. There are no `const T&` parameters whose values can change
    out from underneath you: an immutable value is truly immutable, and the compiler
    makes sure that no matter how an immutable parameter is actually passed (by-value
    or by-reference), the underlying value won''t change. This can be frustrating,
    because you''ve given up control about when to pass by-value, pass by `const`
    reference, or pass by rvalue reference to do a move. On the other hand, it is
    liberating: there''s no spooky-action-at-a-distance when that `const&` actually
    *does* change underneath you, and you can lean on immutability to make it easier
    to reason about your code.'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你*无法欺骗不可变性*，就像你无法欺骗死亡一样。 Swift 中没有类似于 C++ 的 `const_cast`。 Swift 中没有可变数据成员；即使是结构体的
    `var` 成员，也只能在该结构体的 `var` 实例上进行修改。 没有 `const T&` 参数可以在你的底层值改变时发生变化：不可变值确实是不可变的，并且编译器确保无论如何传递不可变参数（按值传递还是按引用传递），底层值都不会改变。
    这可能令人沮丧，因为你失去了控制何时按值传递、按 `const` 引用传递或按 rvalue 引用传递来进行移动。 另一方面，这是解放的：当 `const&`
    在你的底层实际上*发生*变化时，没有什么神秘的远程行动，你可以依靠不可变性来更轻松地推理你的代码。
- en: 'That brings us to the second point: *there is no aliasing of inout parameters*.
    Aliasing, as I mean it here, is when two different pass-by-reference parameters
    actually refer to the same underlying instance. If you''ve ever had to go add
    an `if (this == &other) { ... }` check into your copy or move assignment operator
    in C++, you know just how vicious unexpected aliasing of parameters can be for
    program semantics. In Swift, we have the [law of exclusivity](https://github.com/apple/swift/blob/main/docs/OwnershipManifesto.md#the-law-of-exclusivity),
    which prevents any such aliasing.'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们到第二点：*输入参数没有别名*。 这里所说的别名是指两个不同的按引用传递的参数实际上引用了相同的底层实例。 如果你曾经不得不在 C++ 的复制或移动赋值运算符中添加
    `if (this == &other) { ... }` 检查，你就知道参数意外别名对程序语义的影响有多严重。 在 Swift 中，我们有[排他性法则](https://github.com/apple/swift/blob/main/docs/OwnershipManifesto.md#the-law-of-exclusivity)，防止任何这种别名现象发生。
- en: Memory safety and the law of exclusivity
  id: totrans-split-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存安全和排他性法则
- en: 'Swift''s *law of exclusivity* states that two accesses to a given value in
    memory can only occur simultaneously if both of them are reads, so it is an error
    to (for example) try to form a mutating access (such as passing something `inout`)
    while accessing that value. But this isn''t some abstract rule that introduces
    undefined behavior when you mess up: Swift enforces the law of exclusivity through
    a combination of static checking (which can produce compiler errors if you produce
    aliasing) and dynamic checking (when it''s not possible for the compiler to prove
    that there is no aliasing).'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的*排他性法则*规定，只有同时访问给定内存中的值的两个访问是读取时，才能同时进行，因此尝试在访问该值时形成一个突变访问（例如传递某些东西给
    `inout`）是错误的。 但这不是一些抽象的规则，当你搞砸时会引入未定义的行为：Swift 通过静态检查（如果产生别名会产生编译器错误）和动态检查来强制执行排他性法则。
- en: 'Static checking of the law of exclusivity applies when the value being accessed
    is sufficiently local that it''s possible to reason about all possible accesses
    to that value. Value types are great for this, because two independent `var` instances
    of value type are guaranteed not to alias. The compiler can correctly determine
    that the two `inout` arguments in the call `p1.swapX(&p2)` do not alias, because
    `p1` and `p2` are separate variables. If one instead wrote `p1.swapX(&p1)`, the
    compiler would produce an error describing the problem:'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当被访问的值足够局部时，静态检查排他性法则就会应用。 值类型非常适合此操作，因为值类型的两个独立的 `var` 实例保证不会发生别名。 编译器可以正确确定调用
    `p1.swapX(&p2)` 中的两个 `inout` 参数不会别名，因为 `p1` 和 `p2` 是独立的变量。 如果改为 `p1.swapX(&p1)`，编译器将产生描述问题的错误：
- en: '[PRE15]'
  id: totrans-split-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, if we''re dealing with a variable that isn''t local---say it''s a global
    variable (gasp!) or a member of a reference type like a `class`, then it''s impossible
    to reason about all of the accesses. Let''s build a small contrived example of
    this:'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们处理的变量不是局部的——比如说它是一个全局变量（咻！）或者是一个类的成员变量，那么无法推理所有访问。 让我们构建一个小的假设性例子来说明这一点：
- en: '[PRE16]'
  id: totrans-split-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Within `swapXWithGlobalOrigin`, there is no way to know whether some other
    part of the program might access `globalOrigin` while it runs. So, the Swift compiler
    will insert a runtime check that tracks when `globalOrigin` is potentially being
    modified, and will stop the program if a simultaneous access occurs:'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `swapXWithGlobalOrigin` 内部，没有办法知道程序的其他部分是否在运行时访问 `globalOrigin`。因此，Swift 编译器会插入一个运行时检查，跟踪
    `globalOrigin` 何时可能被修改，并在同时访问发生时停止程序：
- en: '[PRE17]'
  id: totrans-split-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Most Swift programmers never think about the Law of Exclusivity: it''s enforcement
    is there to prevent mistakes that would cause undefined behavior mayhem in C++,
    so it''s critical to Swift''s memory-safety story. But a lot of mutation in Swift
    works on local values, and the language helps you avoid most of these situations,
    so the runtime checking is rarely encountered in practice.'
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Swift 程序员从不考虑互斥性法则：它的执行是为了防止在 C++ 中引起未定义行为的错误，因此它对 Swift 的内存安全性至关重要。但是 Swift
    中大部分的变异都作用于局部值，并且语言帮助你避免大部分这类情况，因此实际上很少遇到运行时检查。
- en: Enums are the union of enums and unions
  id: totrans-split-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举是枚举和联合体的结合
- en: 'Enums are one of Swift''s loveliest little features. We borrowed them from
    [CLU](https://en.wikipedia.org/wiki/CLU_(programming_language)), and for a time
    before Swift 1.0 they even used the keyword `oneof` . A Swift enum is a type-safe
    variant, which subsumes C++''s `enum`, `union`, and `std::variant` in one nice
    little package. An enum can express one of a set of named cases, such as a font
    size expressed via semantic names:'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是 Swift 最可爱的小功能之一。我们从 [CLU](https://en.wikipedia.org/wiki/CLU_(programming_language))
    借鉴了它们，在 Swift 1.0 之前甚至使用了 `oneof` 关键字。Swift 的枚举是一种类型安全的变体，它包含了 C++ 的 `enum`、`union`
    和 `std::variant`，集成在一个小巧的包中。枚举可以表示一组命名的情况，比如通过语义名称表示的字体大小：
- en: '[PRE18]'
  id: totrans-split-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This enum works just like you''d expect the equivalent C++ `enum class`. For
    example:'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个枚举的工作方式与你期望的等效的 C++ `enum class` 一样。例如：
- en: '[PRE19]'
  id: totrans-split-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I snuck a `switch` statement in there because one often uses switch statements
    to deal with each of the cases in an enum. Switch statements in Swift must always
    be exhaustive: if you don''t handle all possible cases, you need to add a `default`
    clause. This eliminates accidents of omission when (for example) someone adds
    a new case, and is commonly a warning in C++ compilers. If you''ve been cringing
    about the missing `break` statements above, don''t: Swift puts a `break` before
    the next case, and if you really want to fall through to the next case, you have
    to explicitly write `fallthrough` to do so.'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我悄悄地在这里加入了一个 `switch` 语句，因为通常使用 `switch` 语句处理枚举中的每个情况。在 Swift 中，`switch` 语句必须是全面的：如果你没有处理所有可能的情况，你需要添加一个
    `default` 子句。这消除了遗漏的意外，比如当有人添加一个新情况时，这在 C++ 编译器中通常是一个警告。如果你一直在为上面缺少的 `break` 语句而苦恼，那么不用担心：Swift
    在下一个情况之前会插入一个 `break`，如果你真的想执行下一个情况，你必须显式地写 `fallthrough`。
- en: 'Back to `FontSize`: the cases of `FontSize` are inside the type. If you want
    to refer to the `paragraph` case, you can do so with `FontSize.paragraph`. However,
    whenever there is type information, such as when you''re initializing a variable
    of type `FontSize` or switching on a value of type `FontSize`, you can use the
    *leading dot syntax* like `.paragraph` and let Swift''s type inference figure
    out the type. Compare the above to the corresponding C++ `enum class`:'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `FontSize`：`FontSize` 的情况包含在类型内部。如果你想引用 `paragraph` 情况，可以使用 `FontSize.paragraph`。然而，每当有类型信息时，比如在初始化
    `FontSize` 类型的变量或者在类型为 `FontSize` 的值上进行切换时，你可以使用*前导点语法*，比如 `.paragraph`，让 Swift
    的类型推断确定类型。将上述与相应的 C++ `enum class` 进行比较：
- en: '[PRE20]'
  id: totrans-split-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It''s the little things, but they really do add up to cleaner code. Swift''s
    leading dot syntax works really nicely with labeled arguments, because the argument
    label implies the type of the argument, leading to very readable code. For example,
    let''s imagine a `Font` struct that uses `FontSize` along with `FontStyle` and
    `FontWeight` enums, including some default values:'
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小细节确实积累成为更清晰的代码。Swift 的前导点语法与带标签的参数非常好地配合，因为参数标签暗示了参数的类型，从而产生非常可读的代码。例如，让我们想象一个
    `Font` 结构体，它使用 `FontSize`、`FontStyle` 和 `FontWeight` 枚举，包括一些默认值：
- en: '[PRE21]'
  id: totrans-split-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can create a new `Font` like this:'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样创建一个新的 `Font`：
- en: '[PRE22]'
  id: totrans-split-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note how the argument labels `size` and `weight` naturally describe the arguments
    that follow them, and the types provide enough information so we don''t need to
    write out the redundant `FontSize` and `FontWeight` types on those arguments.
    Moreover, we are able to use the default argument for `style` even though it''s
    the first parameter: labeled arguments make default arguments work really well.
    These are simple design decisions for a language to make, but they reinforce readable
    code.'
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意参数标签 `size` 和 `weight` 如何自然地描述后面的参数，并且类型提供了足够的信息，所以我们不需要在这些参数上写出冗余的 `FontSize`
    和 `FontWeight` 类型。此外，即使 `style` 是第一个参数，我们也能使用默认参数：带标签的参数让默认参数工作得非常好。这些对于语言来说是简单的设计决策，但它们加强了可读性的代码。
- en: 'Alright, back to enums! Imagine that you wrote that `FontSize` as an `enum
    class` in C++. Hold it in your mind. It''s simple, it works. Now, someone comes
    along and tells you that you need to support *custom* font sizes, which can be
    expressed in terms of points. Your nice `enum class` is out the window, because
    you can''t enumerate all of the custom point sizes. Here''s the pattern I would
    use in C++:'
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，回到枚举！想象一下，你在 C++ 中把那个 `FontSize` 写成了一个 `enum class`。记住它。它很简单，很有效。现在，有人告诉你需要支持*自定义*的字体大小，可以用点数表示。你美好的
    `enum class` 瞬间消失了，因为你不能枚举所有自定义的点数大小。在 C++ 中，我会使用以下模式：
- en: '[PRE23]'
  id: totrans-split-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That is a *lot* of code. It is implementing a type-safe union that consists
    of the three simple cases, plus the one `custom` case. I cringe ever time I have
    to write one of these in C++ (which happens a lot), because it is so much boilerplate
    and it's so easy to make a silly mistake. I've yet to come across a C++ technique
    or library that makes this cleaner. Feel free to let me know if you have a significantly
    more elegant solution in C++.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*很多*代码。它实现了一种类型安全的联合体，包含了三种简单的 case，再加上一个 `custom` case。每次我在 C++ 中写这种代码时（这种情况经常发生），我都会感到不安，因为这需要大量样板代码，而且很容易犯愚蠢的错误。我还没有找到一种能使这个过程更清晰的
    C++ 技术或库。如果你有一个更优雅的解决方案，请随时告诉我。
- en: 'In Swift, you add one case to `FontSize`:'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以向 `FontSize` 添加一个 case：
- en: '[PRE24]'
  id: totrans-split-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Swift cases can carry values in them, which is why I said earlier that they
    also are like C++ unions---without all of the undefined behavior. Given this case,
    I can create a custom font size:'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的 case 可以在其中携带值，这就是为什么我之前说它们也像 C++ 中的联合体---但没有所有的未定义行为。考虑到这种情况，我可以创建一个自定义的字体大小：
- en: '[PRE25]'
  id: totrans-split-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And extend my `switch` statement accordingly:'
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 并相应地扩展我的 `switch` 语句：
- en: '[PRE26]'
  id: totrans-split-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Swift provides pattern matching. When we match the `custom` case, we also declare
    a new variable `pt` to capture the `points` value. The value `pt` is only available
    when one is using a custom font size, so there's no need for runtime assertions
    like `kind == custom` like we had in C++.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了模式匹配。当我们匹配 `custom` case 时，我们还声明一个新变量 `pt` 来捕获 `points` 的值。变量 `pt`
    只在使用自定义字体大小时可用，因此不需要像在 C++ 中那样运行时断言 `kind == custom`。
- en: 'Let''s add one more case to our font size, which lets us take an existing font
    size and scale it by a given factor. It can be expressed like this:'
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再为我们的字体大小添加一个 case，这样我们就可以取一个现有的字体大小并按给定的因子进行缩放。它可以这样表达：
- en: '[PRE27]'
  id: totrans-split-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This way, one can construct a font that is 20% larger than the paragraph font
    using, e.g.,
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，就可以构造一个比段落字体大 20% 的字体，例如，
- en: '[PRE28]'
  id: totrans-split-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `indirect` is needed to indicate that the value associated with the case
    (called the *associated value* in Swift) needs to be stored *indirectly*, because
    the associated value contains an instance of `FontSize` itself. Enums are value
    types and generally use stack storage, so the `indirect` indicates when the value
    for the case needs to be moved off to the heap. If the `indirect` were missing,
    the compiler would complain because the `FontSize` type doesn''t have a fixed
    size in memory:'
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`indirect` 关键字需要指示与 case 关联的值（在 Swift 中称为*关联值*）需要间接存储，因为关联值本身包含了 `FontSize`
    的实例。枚举是值类型，通常使用堆栈存储，所以 `indirect` 表示当 case 的值需要移动到堆上时。如果缺少 `indirect`，编译器会报错，因为
    `FontSize` 类型在内存中没有固定大小：'
- en: '[PRE29]'
  id: totrans-split-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Indirect enum cases are useful for building recursive data structures, like
    a binary tree. We'll come back to those when we can do it properly, with generics.
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 间接枚举 case 对于构建递归数据结构（如二叉树）非常有用。我们将在能够适当地使用泛型时回到它们身上。
- en: 'Now we can create a nice member function that scales the font instance we have
    by a specific factor:'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个很好的成员函数，通过特定因子来缩放我们已有的字体实例：
- en: '[PRE30]'
  id: totrans-split-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This can be called as, e.g., `myFontSize.scaled(by: 1.2)`. There are a few
    little things to notice here. The first is that enums can have methods just like
    structs can. They can also have initializers, which must eventually assign one
    of the cases to `self`. Next, our function is returning `Self`, which is shorthand
    for "the type of `self`". Finally, look at how the parameter is named, "`by factor`":
    here, the *argument label* is `by` (it''s used at the call site) and the *parameter
    name* is `factor` (it''s used inside the body). This is because the argument label
    is there to describe the argument at the call site, i.e., we''re scaling "`by`
    1.2", whereas the parameter name is the noun of what the parameter actually is---the
    `factor` used in the computation. Before now, we''ve seen that the two names are
    generally the same, or the argument label is omitted, but separating the two can
    lead to elegant, readable code particularly when the argument label is a preposition.'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: '这可以称为，例如，`myFontSize.scaled(by: 1.2)`。这里有一些小细节需要注意。首先是枚举类型可以像结构体一样拥有方法。它们也可以有初始化器，必须最终将一个案例分配给`self`。接下来，我们的函数正在返回`Self`，这是“`self`的类型”的简写。最后，看看参数的命名，“`by
    factor`”：这里，*参数标签* 是`by`（在调用处使用），*参数名* 是`factor`（在函数体内部使用）。这是因为参数标签用于描述调用处的参数，即我们正在“按`by`
    1.2缩放”，而参数名是实际参数的名词——用于计算中的`factor`。在此之前，我们通常看到这两个名称通常相同，或者省略了参数标签，但是分开这两个名称可以导致优雅、可读的代码，特别是当参数标签是一个介词时。'
- en: Collections
  id: totrans-split-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'The standard Swift collections types `Array`, `Dictionary`, and `Set` are value
    types when they are storing value types. For example, we could have an array of
    `Font` instances, which will behave as a value type:'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的Swift集合类型`Array`、`Dictionary`和`Set`在存储值类型时是值类型。例如，我们可以有一个`Font`实例的数组，它将表现为值类型：
- en: '[PRE31]'
  id: totrans-split-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Dictionaries and sets work similarly. For example, let''s build a dictionary
    that names all of our fonts:'
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 字典和集合的工作方式类似。例如，让我们构建一个列出所有字体名称的字典：
- en: '[PRE32]'
  id: totrans-split-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The bracket syntax is used for both dictionary literals (when the elements
    are `key: value` pairs) and array literals (when the elements are just... elements).
    The literals are actually extensible: you can use an array literal to initialize
    a `Set`, or even your own type, by defining an appropriate initializer and opting
    in to be "expressible by" that literal type using the generics system. (More on
    that in a later post, I promise.)'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: '括号语法用于字典字面量（当元素是`key: value`对时）和数组字面量（当元素只是...元素时）。字面量实际上是可扩展的：你可以使用数组字面量初始化一个`Set`，甚至你自己的类型，通过定义一个适当的初始化器并选择通过泛型系统成为该字面量类型的“可表达”类型（我保证在以后的文章中会详细讨论）。'
- en: Regular types
  id: totrans-split-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正规类型
- en: 'In C++ we sometimes talk about [regular types](http://stepanovpapers.com/DeSt98.pdf),
    defined by Alexander Stepanov, which are types that behave predictably with respect
    to value semantics: you can copy them, and the copy is equal to the original.
    They can be moved, destroyed, and swapped. C++20 has a [`std::regular` concept](https://en.cppreference.com/w/cpp/concepts/regular)
    to capture these requirements.'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们有时会谈论由亚历山大·斯捷潘诺夫（Alexander Stepanov）定义的[正规类型](http://stepanovpapers.com/DeSt98.pdf)，这些类型在值语义方面表现可预测：你可以复制它们，复制品等于原始值。它们可以被移动、销毁和交换。C++20引入了[`std::regular`概念](https://en.cppreference.com/w/cpp/concepts/regular)来捕捉这些要求。
- en: Swift value types fulfill most of the requirements of a regular type by default,
    and are based on the same semantic contract. Swift value types are always copyable,
    destructible, assignable, and movable. Indeed, you can't really even express these
    ideas in Swift, it's just the way types behave.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: Swift值类型默认满足大部分正规类型的要求，并且基于相同的语义契约。Swift值类型始终可复制、可销毁、可分配和可移动。实际上，在Swift中，你甚至无法真正表达这些想法，它只是类型行为的一种方式。
- en: 'However, there are some notable differences from the Stepanov or C++ standard
    definitions of a regular type. The first was noted earlier: Swift doesn''t have
    a notion of "default construction" at all, so Swift value types are not "default
    constructible". You tend not to need this notion in Swift, though, because of
    definite initialization. There is a benefit here for the authors of types: you
    don''t have to worry about inventing a "default" state if one doesn''t make sense.
    For example, imagine an collection that is always non-empty: how would you give
    it a default constructor? You can''t without doing something weird, like adding
    a single default-constructed element, so such a type can''t be regular.'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与 Stepanov 或 C++ 标准定义的常规类型有一些显著差异。首先前面已经提到：Swift 根本没有“默认构造”这个概念，因此 Swift
    值类型并不“默认可构造”。虽然由于确定性初始化，在 Swift 中你不太需要这种概念。对类型的作者来说这里有一个好处：如果某种状态没有意义，你无需担心发明一个“默认”状态。例如，想象一个始终非空的集合：如果没有做一些奇怪的事情，比如添加一个单一的默认构造元素，你怎么给它一个默认构造函数？所以这样的类型在
    Swift 中不可能是正则的。
- en: Regular types also have (in)equality operators (`==` and `!=`). Swift doesn't
    provide those for free, but you can either write them yourself with, e.g.,
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 常规类型也有（不）相等运算符（`==`和`!=`）。Swift 并不免费提供这些，但你可以自己编写，例如，
- en: '[PRE33]'
  id: totrans-split-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'or let the compiler do it for you, by putting `: Equatable` in the type definition:'
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: '或者让编译器为你做，通过在类型定义中加入`: Equatable`：'
- en: '[PRE34]'
  id: totrans-split-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This says that the `Font` type is `Equatable`, and the compiler will synthesize
    both `==` and `!=` for you based on the data members. You can also put `Hashable`
    here to get a hash function that combines the data members, which then allows
    your type to be used as a key in a `Dictionary` or a value in a `Set`. Again,
    this is dipping our toes into Swift's generics system, but for now you can think
    of `Equatable` as being a little bit like a C++ concept (we call it a *protocol*
    in Swift), but... better.
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里说`Font`类型是`Equatable`，编译器会根据数据成员为你合成`==`和`!=`。你也可以在这里加上`Hashable`，以获取结合数据成员的哈希函数，这样你的类型就可以用作`Dictionary`中的键或`Set`中的值。再次说明，这是我们初步接触
    Swift 泛型系统，但目前你可以把`Equatable`想象成类似于 C++ 概念（我们在 Swift 中称之为*协议*），但...更好。
- en: What's next?
  id: totrans-split-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: 'We''ve talked about value types---a lot. If you''re writing Swift, you should
    use them often, because they provide excellent local reasoning and the ability
    to model most data in a straightforward manner: `struct`s and collections to aggregate
    data and `enum`s to capture different choices.'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经大量讨论了值类型--- 如果你在写 Swift，你应该经常使用它们，因为它们提供了出色的局部推理能力和以直观方式建模大多数数据的能力：`struct`用于聚合数据和集合，`enum`用于捕捉不同的选择。
- en: In the next part of this series, we'll talk about reference types. Specifically,
    classes, and how Swift supports Object-Oriented Programming.
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本系列的下一部分中，我们将讨论引用类型。具体来说，是类和 Swift 如何支持面向对象编程。
