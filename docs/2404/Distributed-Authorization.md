<!--yml

类别：未分类

日期：2024-05-27 13:14:59

-->

# 分布式授权

> 来源：[https://www.osohq.com/post/distributed-authorization](https://www.osohq.com/post/distributed-authorization)
> 
> “在我们现有数据库中对数据进行授权查询的能力，减少了架构复杂性，对我们来说是一个重大的技术胜利。我们非常兴奋能够利用它。” – Anthony Cristiano，首席软件工程师，Headway

授权作为一种服务。现实与承诺不符。这是因为要使用授权服务，您必须向其发送大量应用程序数据。任何让您签署数据同步过程的解决方案都不是提供服务，而是造成负担。

当我们开始开发 Oso 时，我们知道这一点。这是我们着手解决的关键问题之一。今天，我们通过发布***分布式授权***迈出了实现这一愿景的重要一步。

分布式授权允许您在不将其同步到 Oso Cloud 的情况下，将应用程序数据应用于授权决策。相反，您在 Oso Cloud 服务和应用程序中的 Oso Cloud 客户端之间分发授权决策。

这听起来可能有些违反直觉——一个授权服务不应该独自回答授权问题吗？令人惊讶的是，不是这样。

在本文中，我们将向您展示我们是如何得出这一结论的，以及我们对分布式授权如此兴奋的原因。

## DIY 授权：好到不行

授权始于一个问题。考虑[gitcloud](https://github.com/osohq/gitcloud)，我们的示例版本控制应用。您可能会被问到这个问题：`alice` 是否可以 `read` `amazing-app` 仓库？为了回答这个问题，您需要两样东西：逻辑和数据。逻辑可能是：

如果用户在组织中拥有 `maintainer` 或 `admin` 角色，则`user`可以`read`其`organization`中的`repository`。

数据可能是：

+   `alice` 是 `acme` 组织的成员。

+   `acme` 组织包含 `amazing-app` 仓库

+   `alice` 在 `amazing-app` 仓库上拥有 `maintainer` 角色

结合逻辑和数据，我们得到了答案：`alice` 可以 `read` `amazing-app` 仓库。

在应用程序的早期阶段，这种逻辑通常存在于应用程序代码中，而数据则存在于应用程序数据库中。对于我们上面的简单问题的情况，可能看起来像这样：

```
// Get this user's roles on the repo  const userRoles = db.getUserRoles({ userId: user.id, repoId: issue.repoId}); 
// Check whether the user has a role that confers read access  if(!userRoles.some((r) => ["maintainer", "admin"].includes(r)) {
  throw  new PermissionDeniedRoleRequired("maintainer"); }
```

```
# SQL for getting the repository roles for a user. select "role"  from repository_role rr join repository r on rr.repo_id = r.id
join organization_member om on r.org_id = om.org_id
where om.user_id = ?
    and r.id = ?
```

如果您的授权逻辑不比这更复杂，那这就可以完全胜任。但随着时间推移，授权问题和逻辑都倾向于变得更加复杂。

+   在仓库级别管理角色变得繁琐时，您允许用户从组织中继承仓库角色。

+   您开始收到许多请求要求向 gitcloud 添加新角色，因此您允许用户创建具有可配置权限的自定义角色

+   您向 gitcloud 添加了一个 Issue 功能，因此仓库用户有了报告错误的途径。

太棒了——您的Issue功能正在火爆上升！实际上，它如此受欢迎，以至于您的用户要求列出他们有权进行审查的问题，因为跟踪它们变得困难。您决定如果用户可以`triage`一个问题，则可以：

+   他们创建了`issue` *或*

+   他们在包含`issue`的`repository`上有`triage`角色 *或*

+   他们在包含`repository`的`organization`上有`triage`角色 *或*

+   他们有一个授予他们必要权限的`custom role`

它看起来像这样：

样例代码留作读者的练习。

从现在起，当您希望弄清楚如何为用户授予审查访问权限的规则时，祝您好运。

## 策略即代码：将授权逻辑与应用程序逻辑分离

无论您是否明确构建了它，您的应用程序都有一个授权策略。当您在应用程序代码中混合应用程序逻辑和授权逻辑时，您使该策略变得隐式化。隐式化的问题在于它们很容易被误解，或者完全被忽视。假设您决定在gitcloud中添加团队，以便组织中的不同团队可以拥有不同的权限。您能找到所有必须修改的函数和查询以使团队正常工作吗？您想要这样做吗？

这就是为什么我们引入了[Polar](https://www.osohq.com/docs/reference/polar/foundations)，我们的声明性授权DSL。Polar允许您将授权逻辑与应用程序逻辑分离，并用专为授权而构建的语言表达它。一个简单的Polar策略看起来像这样：

```
allow(user: User, "read", org: Organization) if   has_role(user, "member", org); 	
has_role(User{"alice"}, "member", Organization{"acme"});
```

我们已指定我们感兴趣的实体：`User`和`Organization`。我们已定义了允许给定`User`根据`member`角色`read`一个`Organization`的条件。最后，我们断言`alice`在`acme`组织上有`member`角色。

就像任何新语言一样，如果您以前没有使用过Polar，那么需要一点时间来适应，但是从这个示例中我们可以看到，它既简洁又富有表现力。这些都是重要特征，如果我们的目标是使您的授权逻辑明确化。如果您不得不浏览一堆混乱的语法来揭示该逻辑，那我们将白费力气。

明确的策略对于复杂的授权逻辑是一个重大进步。现在我们需要让您在代码中利用该策略。这就是为什么我们构建了Oso库。

## Oso库：单体应用的授权

Oso库代表了我们对Polar的初始实现的看法。有很多值得称赞的地方。它是开源的。它直接在您的数据上操作。它与您的应用程序紧密集成。通过在Polar中定义您的策略并将开源库嵌入您的应用程序中，您可以找出`alice`是否可以像这样`read`一个`repository`：

```
@app.route("/repo/<name>") def repo_show(name):
    repo = Repository.get_by_name(name)

  try:
 oso.authorize(User.get_current_user(), "read", repo)

  return f"<h1>A Repo</h1><p>Welcome to repo {repo.name}</p>", 200     except NotFoundError:
  return f"<h1>Whoops!</h1><p>Repo named {name} was not found</p>", 404
```

这个优势在于，随着授权逻辑变得更加复杂，应用程序代码仍然保持简单。您可以在 `.polar` 文件中表达授权逻辑，在这里您可以对其进行版本控制和检查，与应用程序代码并列。当您需要询问特定用户是否被授权执行特定操作时，您总是用完全相同的术语询问同一个问题：

```
oso.authorize(<User>, <action>, <resource>)
```

虽然这样做非常强大，但随着时间的推移，我们发现图书馆方法存在一些显著的缺点。

该库通过 [外部函数接口](https://doc.rust-lang.org/nomicon/ffi.html)（FFI）访问应用程序数据。这是一个巧妙（而有趣）的工程设计，但这种心智模型让许多开发人员感到困惑，并且使调试变得困难。

没有标准数据模型。这正是问题的一部分——我们建立该库来操作您的数据。尽管直接访问数据非常方便，但我们观察到性能问题和由我们无法看到或更改的底层数据模型细节引起的不一致行为。这种标准化缺失还使我们难以在库上构建新的功能能力。

但主要问题是：如果您只有一个服务，该库是一个很好的解决方案。然而，许多人有多个服务！对于这些人来说，库方法只解决了问题的一部分。

## Oso 云：微服务授权

当您的应用程序是单块时，使用像 Oso 库这样的方式实现授权逻辑非常简单。您在与所有其余代码存放在同一个仓库中的 `.polar` 文件中编写逻辑。然后在初始化客户端时加载它。最后，对加载的策略发出授权请求。您不必担心数据，因为所有数据都在一个所有代码都可以访问的单个数据库中。

但是，当您将应用程序分解为多个服务时，您会引入新的问题。哪个服务应该拥有授权模型？没有好的答案，因为模型需要数据才能发挥效果，而这些数据现在分布在各个服务中。每个服务可以有自己的模型吗？不行，因为授权问题通常涉及多个服务。让我们回到决定`alice`是否可以处理`Issue`的问题。

Issue 服务知道`alice`是否创建了该问题。Repository 服务知道`alice`在存储库上是否具有`triage`角色，而 User 服务知道`alice`在组织上是否具有`triage`角色。因此，现在您需要进行多次 API 调用来确定`alice`是否可以`triage`这个问题。

最终最合理的设计是专门为授权创建一个服务，但现在您必须构建自己的 API，创建自己的数据模型，找出如何设计变更控制。这是一项艰巨的工作。

因此，我们的下一步是继续努力。我们设计了Oso Cloud来解决多服务环境中的授权问题。这让我们解决了图书馆模型中的两个持久问题：

+   我们构建了一个托管解决方案，可以由应用程序中的所有服务共享。

+   我们为授权数据定义了一致的数据模型。

Oso Cloud的数据模型称为[facts](https://www.osohq.com/docs/concepts/oso-cloud-data-model)。Facts是一种轻量、灵活的格式，可以表示应用程序中的任何授权数据。

Oso Cloud为多服务应用程序带来了策略即代码的好处。您可以使您的授权逻辑明确化，并在所有服务之间共享它，并使用优化了授权操作的标准格式来表示您的授权数据。但现在，我们正重新创造出我们想要解决的问题：您必须将应用程序数据同步到我们的服务中。

## 授权作为服务：过度集中化

让我们回顾一下为什么我们走上这条路。我们的应用程序变得脆弱，因为应用程序逻辑和授权逻辑交织在一起。我们希望使授权逻辑明确化，为了在微服务中有效地实现这一目标，我们创建了一个通过API提供Polar好处的托管服务。

要回答授权问题，我们需要的不仅仅是逻辑。我们还需要数据。在这方面，Oso Cloud遭受着所有集中式授权服务都会遭受的同样限制。它需要这些数据存在于*服务中*。

但这是我们的问题，而不是您的问题。您已经在需要的地方拥有这些数据：在您的应用程序中。通过要求您将其转换为事实并将其同步到Oso Cloud，我们在以简化我们的生活为代价使您的生活更加艰难。现在，您必须处理潜在的大规模初始数据加载、分布式事务、同步和复制过程以及检测漂移。这些都不容易。

我们知道这并不容易，因为您告诉过我们它不容易。好消息是，对我们来说，这从未是最终状态。

## 分布式授权：正确执行的微服务

我们真正想做的是让您集中您的授权逻辑，而不是集中您所有的授权数据。为了做到这一点，我们必须放弃作为服务的授权的一个基本假设：该服务必须独立回答问题。正是这一要求使得授权服务必须拥有*您的所有应用程序数据*。

相反地，您可以将逻辑和常见授权数据（如角色等）集中在授权服务中，然后在服务器和客户端之间分配授权问题的评估。这就是分布式授权。与仅回答`yes`或`no`不同，Oso Cloud现在可以以`yes, if`来回答授权问题。

那个`yes, if`后面跟着一系列条件，在客户端使用你的本地数据进行评估。你需要给 Oso Cloud 客户端提供一个配置文件，告诉它如何通过将你的应用程序数据转换为事实来测试这些条件。在授权时，Oso Cloud 服务会评估它所知道的请求的尽可能多的部分，然后将剩余部分交给你的应用程序中的 Oso Cloud 客户端处理。

## 实际应用：列表过滤

这个功能特别适合于过滤授权数据列表。我们已经谈论过如何将应用程序数据传输到集中式授权服务中的痛点。将数据从中心化授权服务中取回同样也可能是一件困难的事情。如果你想要生成`alice`可以`triage`的问题列表，并且你所有的数据都集中在授权服务中，那么操作看起来就像这样：

+   向服务请求一个`alice`可以`triage`的问题 ID 列表

+   从服务获取完整的 ID 列表

+   使用 ID 列表查询本地数据库获取问题数据

`oso.list` 命令的工作方式就是这样，它在许多情况下都非常出色。

对于属于多个组织或者活跃度很高的组织的用户来说，问题列表可能会变得非常长！可以很容易想象到，用户可能会访问数百甚至数千个问题。在你能够在应用程序中使用这些数据之前，这些数据需要通过互联网传输。

现在 Oso Cloud 支持使用分布式数据进行[列表过滤](https://www.osohq.com/docs/guides/integrate/filter-lists)。当你使用本地数据生成授权资源列表时，Oso Cloud 不会返回完整的资源列表，而是向客户端返回一个（更短的）查询过滤器。然后客户端使用这个过滤器从本地存储的数据构建完整的列表。你可以更快地从 Oso 获取响应，并且因为你在本地数据库中生成列表，所以可以使用已有工具来处理大量应用程序数据进行排序和分页。

## 聚焦我们的视野

> “我们的团队正在寻找一个新的授权系统。我们评估了许多技术（包括自己构建的）和 Oso 的分布式架构、深入的授权知识以及99.99%的可用性是我们选择 Oso 的关键原因。” – Guhan Venguswamy，平台工程师负责人，Jasper.ai

使用分布式授权，你可以获得显式授权逻辑的好处，而不需要集中所有的授权数据。它是一种与你的应用程序一起工作的授权服务，而不是强迫你重新设计应用程序以适应它。

这对我们来说是一个重要里程碑，但我们知道工作还没有结束。我们继续致力于简化您在Oso Cloud中集中您想要保留的数据的方式。我们将Polar进行增强以使其更加灵活和坚固。而且，我们也没有忘记巨型企业——尽管Oso库现已过时，我们也在努力为您带来这些功能!

接下来几周，我们将分享更多关于分布式授权的底层工作原理，以及客户如Headway和Jasper.ai如何已经在使用它的方式。

如需了解更多如何在您的应用中使用该功能，请[查看我们的分布式授权和列表筛选文档](https://www.osohq.com/docs/guides/integrate/filter-lists?utm_content=distributedauthz_launchpost#list-filtering-with-decentralized-data)。

您有问题或想分享想法吗？在[Slack上联系我们](https://join-slack.osohq.com/) 或者[预约与工程师一对一](https://calendly.com/osohq/oso-cloud-1-on-1?utm_content=distributed_authz_launchpost)! 我们很愿意与您交流。

‍
