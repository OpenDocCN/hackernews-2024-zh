["```\nfn extract(arr: [i32; 3]) -> i32 {\n  arr[1]\n}\n```", "```\nextract:\n  mov   eax, dword ptr [rdi + 4]\n  ret\n```", "```\nextern \"C\" fn extract(arr: [i32; 3]) -> i32 {\n  arr[1]\n}\n```", "```\nextract:\n  mov   rax, rdi\n  shr   rax, 32\n  ret\n```", "```\nfn secret_call() -> i32 {\n  extern \"Rust\" {\n    fn my_func() -> i32;\n  }\n  unsafe { my_func() }\n}\n```", "```\n%InputI = type [6 x i64]\n%InputF = type [0 x double]\n%InputV = type [8 x <2 x i64>]\n\n%OutputI = type [3 x i64]\n%OutputF = type [0 x double]\n%OutputV = type [4 x <2 x i64>]\n\ndefine void @inputs({ %InputI, %InputF, %InputV }) {\n  %p = alloca [4096 x i8]\n  store volatile { %InputI, %InputF, %InputV } %0, ptr %p\n  ret void\n}\n\n%Output = { %OutputI, %OutputF, %OutputV }\n@gOutput = constant %Output zeroinitializer\ndefine %Output @outputs() {\n  %1 = load %Output, ptr @gOutput\n  ret %Output %1\n}\n```", "```\ndeclare {[3 x i64], [4 x <2 x i64>]} @my_func(\n  i64 %rdi, i64 %rsi, i64 %rdx, i64 %rcx, i64 %r8, i64 %r9,\n  <2 x i64> %xmm0, <2 x i64> %xmm1, <2 x i64> %xmm2, <2 x i64> %xmm3,\n  <2 x i64> %xmm4, <2 x i64> %xmm5, <2 x i64> %xmm6, <2 x i64> %xmm7,\n  ; other args...\n)\n```", "```\n; This is a -Zcallconv=fast-style function.\n%Out = type {[3 x i64], [4 x <2 x i64>]}\ndefine %Out @load_rcx(\n  i64 %rdi, i64 %rsi, i64 %rdx,\n  ptr %rcx, i64 %r8, i64 %r9,\n  <2 x i64> %xmm0, <2 x i64> %xmm1,\n  <2 x i64> %xmm2, <2 x i64> %xmm3,\n  <2 x i64> %xmm4, <2 x i64> %xmm5,\n  <2 x i64> %xmm6, <2 x i64> %xmm7\n) {\n  %load = load i64, ptr %rcx\n  %out = insertvalue %Out poison,\n                      i64 %load, 0, 0\n  ret %Out %out\n}\n\ndeclare ptr @malloc(i64)\ndefine i64 @make_the_call() {\n  %1 = call ptr @malloc(i64 8)\n  store i64 42, ptr %1\n  %2 = call %Out @by_rcx(\n    i64 poison, i64 poison, i64 poison,\n    ptr %1,     i64 poison, i64 poison,\n    <2 x i64> poison, <2 x i64> poison,\n    <2 x i64> poison, <2 x i64> poison,\n    <2 x i64> poison, <2 x i64> poison,\n    <2 x i64> poison, <2 x i64> poison)\n  %3 = extractvalue %Out %2, 0, 0\n  %4 = add i64 %3, 42\n  ret i64 %4\n}\n```", "```\nby_rcx:\n  mov   rax, qword ptr [rcx]\n  ret\n\nmake_the_call:\n  push  rax\n  mov   edi, 8\n  call  malloc\n  mov   qword ptr [rax], 42\n  mov   rcx, rax\n  call  load_rcx\n  add   rax, 42\n  pop   rcx\n  ret\n```", "```\n%Out = type {[3 x i64], [4 x <2 x i64>]}\ndefine %Out @square(\n  i64 %rdi, i64 %rsi, i64 %rdx,\n  ptr %rcx, i64 %r8, i64 %r9,\n  <2 x i64> %xmm0, <2 x i64> %xmm1,\n  <2 x i64> %xmm2, <2 x i64> %xmm3,\n  <2 x i64> %xmm4, <2 x i64> %xmm5,\n  <2 x i64> %xmm6, <2 x i64> %xmm7\n) {\n  %sq = mul i64 %rdx, %rdx\n  %out = insertvalue %Out poison,\n                      i64 %sq, 0, 1\n  ret %Out %out\n}\n\ndefine i64 @make_the_call(i64) {\n  %2 = call %Out @square(\n    i64 poison, i64 poison, i64 %0,\n    i64 poison, i64 poison, i64 poison,\n    <2 x i64> poison, <2 x i64> poison,\n    <2 x i64> poison, <2 x i64> poison,\n    <2 x i64> poison, <2 x i64> poison,\n    <2 x i64> poison, <2 x i64> poison)\n  %3 = extractvalue %Out %2, 0, 1\n\n  %4 = call %Out @square(\n    i64 poison, i64 poison, i64 %3,\n    i64 poison, i64 poison, i64 poison,\n    <2 x i64> poison, <2 x i64> poison,\n    <2 x i64> poison, <2 x i64> poison,\n    <2 x i64> poison, <2 x i64> poison,\n    <2 x i64> poison, <2 x i64> poison)\n  %5 = extractvalue %Out %4, 0, 1\n\n  ret i64 %5\n}\n```", "```\nsquare:\n  imul rdx, rdx\n  ret\n\nmake_the_call:\n  push rax\n  mov rdx, rdi\n  call square\n  call square\n  mov rax, rdx\n  pop rcx\n  ret\n```", "```\ndefine i64 @square(i64) {\n  %2 = mul i64 %0, %0\n  ret i64 %2\n}\n\ndefine i64 @make_the_call(i64) {\n  %2 = call i64 @square(i64 %0)\n  %3 = call i64 @square(i64 %2)\n  ret i64 %3\n}\n```", "```\nsquare:\n  mul x0, x0, x0\n  ret\n\nmake_the_call:\n  str x30, [sp, #-16]!\n  bl square\n  ldr x30, [sp], #16\n  b square  // Tail call.\n```", "```\nstruct Options {\n  colorize: bool,\n  verbose_debug: bool,\n  allow_spurious_failure: bool,\n  retries: u32,\n}\n\ntrait Context {\n  fn check(&self, n: usize, colorize: bool);\n}\n\nfn do_thing<'a>(op_count: Option<usize>, context: &dyn Context,\n                name: &'a str, code: [char; 6],\n                options: Options,\n) -> &'a str {\n  if let Some(op_count) = op_count {\n    context.check(op_count, options.colorize);\n  }\n\n  for c in code {\n    if let Some((_, suf)) = name.split_once(c) {\n      return suf;\n    }\n  }\n\n  \"idk\"\n}\n```", "```\ngprs: i64, ptr, ptr, ptr, i64, i32, i32\nxmm0: i32, i32, i32, i32\nxmm1: i32, i1, i1, i1, i1\n```", "```\n%Out = type {[3 x i64], [4 x <2 x i64>]}\ndefine %Out @do_thing(\n  i64 %rdi, ptr %rsi, ptr %rdx,\n  ptr %rcx, i64 %r8, i64 %r9,\n  <4 x i32> %xmm0, <4 x i32> %xmm1,\n  ; Unused.\n  <2 x i64> %xmm2, <2 x i64> %xmm3,\n  <2 x i64> %xmm4, <2 x i64> %xmm5,\n  <2 x i64> %xmm6, <2 x i64> %xmm7\n) {\n  ; First, unpack all the primitives.\n  %r9.0 = trunc i64 %r9 to i32\n  %r9.1.i64 = lshr i64 %r9, 32\n  %r9.1 = trunc i64 %r9.1.i64 to i32\n  %xmm0.0 = extractelement <4 x i32> %xmm0, i32 0\n  %xmm0.1 = extractelement <4 x i32> %xmm0, i32 1\n  %xmm0.2 = extractelement <4 x i32> %xmm0, i32 2\n  %xmm0.3 = extractelement <4 x i32> %xmm0, i32 3\n  %xmm1.0 = extractelement <4 x i32> %xmm1, i32 0\n  %xmm1.1 = extractelement <4 x i32> %xmm1, i32 1\n  %xmm1.1.0 = trunc i32 %xmm1.1 to i1\n  %xmm1.1.1.i32 = lshr i32 %xmm1.1, 1\n  %xmm1.1.1 = trunc i32 %xmm1.1.1.i32 to i1\n  %xmm1.1.2.i32 = lshr i32 %xmm1.1, 2\n  %xmm1.1.2 = trunc i32 %xmm1.1.2.i32 to i1\n  %xmm1.1.3.i32 = lshr i32 %xmm1.1, 3\n  %xmm1.1.3 = trunc i32 %xmm1.1.3.i32 to i1\n\n  ; Next, reassemble them into concrete values as needed.\n  %op_count.0 = insertvalue { i64, i1 } poison, i64 %rdi, 0\n  %op_count = insertvalue { i64, i1 } %op_count.0, i1 %xmm1.1.0, 1\n  %context.0 = insertvalue { ptr, ptr } poison, ptr %rsi, 0\n  %context = insertvalue { ptr, ptr } %context.0, ptr %rdx, 1\n  %name.0 = insertvalue { ptr, i64 } poison, ptr %rcx, 0\n  %name = insertvalue { ptr, i64 } %name.0, i64 %r8, 1\n  %code.0 = insertvalue [6 x i32] poison, i32 %r9.0, 0\n  %code.1 = insertvalue [6 x i32] %code.0, i32 %r9.1, 1\n  %code.2 = insertvalue [6 x i32] %code.1, i32 %xmm0.0, 2\n  %code.3 = insertvalue [6 x i32] %code.2, i32 %xmm0.1, 3\n  %code.4 = insertvalue [6 x i32] %code.3, i32 %xmm0.2, 4\n  %code = insertvalue [6 x i32] %code.4, i32 %xmm0.3, 5\n  %options.0 = insertvalue { i32, i1, i1, i1 } poison, i32 %xmm1.0, 0\n  %options.1 = insertvalue { i32, i1, i1, i1 } %options.0, i1 %xmm1.1.1, 1\n  %options.2 = insertvalue { i32, i1, i1, i1 } %options.1, i1 %xmm1.1.2, 2\n  %options = insertvalue { i32, i1, i1, i1 } %options.2, i1 %xmm1.1.3, 3\n\n  ; Codegen as usual.\n  ; ...\n}\n```"]