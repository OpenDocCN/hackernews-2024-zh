- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 13:14:59'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Distributed Authorization
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.osohq.com/post/distributed-authorization](https://www.osohq.com/post/distributed-authorization)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “The ability to do authorization queries over data in our existing database
    reduces architectural complexity and is a big technical win for us. We’re super
    excited to take advantage of it.” – Anthony Cristiano, Staff Software Engineer,
    Headway
  id: totrans-split-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Authorization as a Service. The reality falls short of the promise. That’s because
    to use an authorization service, you have to send it a lot of application data.
    Any solution that signs you up for a data synchronization process isn’t providing
    a service. It’s creating a burden.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: When we started work on Oso, we knew this. It’s one of the key problems we set
    out to solve. Today we’re taking a major step towards realizing that vision with
    the release of ***Distributed Authorization***.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: Distributed Authorization lets you apply your application data to authorization
    decisions without synchronizing it to Oso Cloud. Instead, you distribute authorization
    decisions between the Oso Cloud service and the Oso Cloud client in your application.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: This may sound counterintuitive – shouldn’t an authorization service answer
    authorization questions on its own? Surprisingly, no.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we’ll show you how we reached that conclusion and why we’re so
    excited about Distributed Authorization.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: 'DIY Authorization: Good until it Isn’t'
  id: totrans-split-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Authorization starts with a question. Consider [gitcloud](https://github.com/osohq/gitcloud),
    our sample version control app. You may be asked this question: May `alice` `read`
    the `amazing-app` repository? In order to answer this question you need two things:
    logic and data. The logic might be:'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: A `user` may `read` a `repository` in their `organization` if they have the
    `maintainer` or `admin` role on that `repository`
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The data might be:'
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: '`alice` is a member of the `acme` organization.'
  id: totrans-split-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the `acme` organization contains the `amazing-app` repository
  id: totrans-split-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alice` has the `maintainer` role on the `amazing-app` repository'
  id: totrans-split-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By combining the logic and the data, we get our answer: `alice` can `read`
    the `amazing-app` repository.'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: 'In the early stages of an application, this logic usually lives in the application
    code, and the data in the application database. For the case of our simple question
    above, that might look like this:'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-21
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
- en: If your authorization logic isn’t much more complicated than that, this works
    just fine. But over time, authorization questions and logic both tend to become
    more complex.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: It becomes cumbersome to manage roles at the repository level, so you allow
    users to inherit roles on repositories from their role in the organization.
  id: totrans-split-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You start getting a lot of requests to add new roles to gitcloud, so you give
    users the ability to create custom roles with configurable permission
  id: totrans-split-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You add an Issue feature to gitcloud, so repo users have a way to report bugs.
  id: totrans-split-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Great news – your Issue feature is taking off! In fact, it’s so popular that
    your users request a list of Issues that they have permission to triage, because
    it’s getting hard to keep track of them. You decide that a user can `triage` an
    issue if:'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: They created the `issue` *or*
  id: totrans-split-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have the `triage` role on the `repository` that contains the `issue` *or*
  id: totrans-split-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have the `triage` role on the `organization` that contains the `repository`
    *or*
  id: totrans-split-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have a `custom role` that grants them the necessary permissions
  id: totrans-split-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This looks something like this:'
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: Sample code left as an exercise for the reader.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: Good luck sifting through that code 6 months from now when you want to figure
    out the rules for granting triage access to a user.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Policy As Code: Decouple Authorization Logic From Application Logic'
  id: totrans-split-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your application has an authorization policy, whether you build it explicitly
    or not. When you mix application logic and authorization logic in your application
    code, you make that policy implicit. The problem with things that are implicit
    is that they’re easy to misunderstand, or to miss entirely. Suppose you decide
    to add teams to gitcloud, so different teams in an organization can have different
    permissions. Will you be able to find all the functions and queries you need to
    modify in order to make teams work properly? Do you want to have to do that?
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why we introduced [Polar](https://www.osohq.com/docs/reference/polar/foundations),
    our declarative DSL for authorization. Polar allows you to separate your authorization
    logic from your application logic and express it in a language that is purpose
    built for authorization. A simple Polar policy looks something like this:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-38
  prefs: []
  type: TYPE_PRE
- en: 'We’ve specified the entities we’re interested in: `User` and `Organization`.
    We’ve defined the conditions that allow a given `User` to `read` an `Organization`,
    in terms of the `member` role. Finally, we’ve asserted that `alice` has the `member`
    role on the `acme` organization.'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: Like any new language, it takes a little getting used to if you haven’t worked
    with Polar before, but we can see from this example that it’s both concise and
    expressive. These are important characteristics if our aim is to make your authorization
    logic explicit. If you had to wade through a bunch of confusing syntax to divine
    that logic, we would have done a lot of work for nothing.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: Explicit policy is a big improvement for complex authorization logic. Now we
    needed to let you take advantage of that policy in your code. This is why we built
    the Oso library.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Oso Library: Authorization for Monoliths'
  id: totrans-split-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Oso library represented our initial implementation of a client to Polar.
    There was a lot to like about it. It was open source. It operated directly over
    your data. It integrated tightly with your application. With your policy defined
    in Polar and the open source library embedded in your application, you could find
    out whether `alice` can `read` a `repository` like this:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
- en: 'The beauty of this was that as your authorization logic gets more complicated,
    the application code stayed just this simple. You expressed the authorization
    logic in a .polar file, where you could version and inspect it alongside your
    application code. When you needed to ask if a given user was authorized to perform
    a given action, you always asked the same question, in exactly those terms:'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-46
  prefs: []
  type: TYPE_PRE
- en: As powerful as this was, over time we learned that the library approach has
    some significant downsides.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: The library got access to application data via a [foreign function interface](https://doc.rust-lang.org/nomicon/ffi.html)
    (FFI). This was clever (and fun) engineering, but the mental model tripped up
    a lot of developers, and made things hard to debug.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: There was no standard data model. This was part of the point – we built the
    library to operate over your data. As convenient as it was to have direct access
    to that data, in practice we observed performance issues and inconsistent behavior
    caused by details of the underlying data model that we could neither see nor change
    ourselves. This lack of standardization also made it hard for us to build new
    capabilities on top of the library.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: 'But the main problem was this: the library was a great solution if you have
    a single service. A lot of people, however, have more than one service! For these
    people, the library approach only solved a piece of the puzzle.'
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Oso Cloud: Authorization for Microservices'
  id: totrans-split-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your application is a monolith, it’s straightforward to implement your
    authorization logic with something like the Oso library. You write your logic
    in a `.polar` file that lives in the same repository as all the rest of your code.
    Then you load it when you initialize the client. Finally, you issue authorization
    requests against the loaded policy. You don’t have to worry about data, because
    it’s all in a single database that all your code can access.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: But when you break your application up into multiple services, you introduce
    new questions. Which service should own the authorization model? There’s no good
    answer, because the model needs data to be effective, and that data is now split
    across services. Can each service have its own model? No, because authorization
    questions often span services. Let’s go back to deciding whether `alice` can triage
    an `Issue`.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: The Issue service knows whether `alice` created the issue. The Repository service
    knows whether `alice` has the `triage` role on the repository, and the User service
    knows whether `alice` has the `triage` role on the organization. So now you’re
    making multiple API calls to figure out whether `alice` can `triage` the issue.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: The design that ends up making the most sense is to have a dedicated service
    for authorization, but now you have to build your own APIs, create your own data
    model, figure out how to design change control. It’s a lot of work.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: 'So our next step was to take that work on. We designed Oso Cloud to solve authorization
    in multi-service environments. This let us address two persistent issues in the
    library model:'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: We built a hosted solution that could be shared by all services in an application.
  id: totrans-split-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined a consistent data model for authorization data.
  id: totrans-split-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Oso Cloud data model is called [facts](https://www.osohq.com/docs/concepts/oso-cloud-data-model).
    Facts are a lightweight, flexible format that can represent any authorization
    data in your application.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Oso Cloud brings the benefits of policy as code to multi-service applications.
    You can make your authorization logic explicit, share it amongst all of your services,
    and represent your authorization data in a standard format that’s optimized for
    authorization operations. But now we’ve recreated exactly the problem we set out
    to solve: you have to sync your application data to our service.'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Authorization as a Service: Excessive Centralization'
  id: totrans-split-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a look back at why we started down this road. Our application got
    brittle because the application logic and the authorization logic were intertwined.
    We wanted to make authorization logic explicit, and in order to do that in a way
    that worked for microservices, we created a hosted service that provides the benefits
    of Polar behind an API.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: To answer authorization questions, we need more than logic. We also need data.
    And in that respect, Oso Cloud suffers from the same limitation that all centralized
    authorization services do. It needs that data to exist *in the service*.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: 'But that’s our problem, not yours. You already have that data where you need
    it: in your application. By requiring you to convert it to facts and synchronize
    it to Oso Cloud, we’re making our lives easier at the cost of making yours harder.
    Now you have to deal with potentially massive initial data loads, distributed
    transactions, sync and replication processes, detecting drift. None of this is
    easy.'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: We know it’s not easy, because you’ve told us it isn’t. The good news is that
    this was never the end state for us.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Distributed Authorization: Microservices done right'
  id: totrans-split-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we really want to do is let you centralize your authorization logic without
    centralizing all of your authorization data. To do this, we have to let go of
    a fundamental assumption of Authorization as a Service: that the service has to
    answer the question independently. It’s this requirement that makes it necessary
    for the authorization service to have *all of your application data*.'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: What if, instead, you could centralize your logic and your common authorization
    data (things like roles) in the authorization service, and then distribute the
    evaluation of authorization questions between the server and the client? That’s
    Distributed Authorization. Instead of only answering `yes` or `no`, Oso Cloud
    can now respond to an authorization question with `yes, if`.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: That `yes, if` is followed by a list of conditions that are evaluated at the
    client using your local data. You give the Oso Cloud client a configuration file
    that tells it how to test those conditions by converting your application data
    to facts. At authorization time, the Oso Cloud service evaluates as much of the
    request as it knows, and then hands off the remainder to the Oso Cloud client
    in your application.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: 'A Practical Application: Filtering Lists'
  id: totrans-split-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One area where this shines is filtering lists of authorized data. We’ve already
    talked about how painful it can be to get your application data into a centralized
    authorization service. It can also be painful to get it back out. If you want
    to generate a list of Issues that `alice` can `triage` and all of your data is
    centralized in your authorization service, then the operation looks like this:'
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: Ask the service for a list of Issue IDs that `alice` can `triage`
  id: totrans-split-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the full list of IDs back from the service
  id: totrans-split-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the list of IDs to query your local database for Issue data
  id: totrans-split-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how the `oso.list` command works, and it works great in a lot of cases.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: For users who belong to multiple organizations, or who belong to organizations
    with very active repositories, that list of Issues can get very long! It's not
    hard to envision situations where a user has access to hundreds or thousands of
    issues. That’s a lot of data going across the internet before you’re able to use
    it in your application.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: Oso Cloud now supports [List Filtering using Distributed Data](https://www.osohq.com/docs/guides/integrate/filter-lists).
    When you use local data to generate lists of authorized resources, rather than
    returning the full list of resources, Oso Cloud instead returns a (much shorter)
    query filter to the client. The client then uses this filter to construct the
    full list from your locally stored data. You get your response back from Oso faster,
    and because you generate the list in your local database, you can sort and paginate
    the results using the tools you're already using to handle large sets of application
    data.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: Bringing our Vision into Focus
  id: totrans-split-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “Our team was looking for a new authorization system. We assessed a number of
    technologies (plus building our own) and Oso's distributed architecture, in-depth
    auth knowledge, and 99.99% uptime were key reasons why we chose Oso.” – Guhan
    Venguswamy, Head of Platform Engineering, Jasper.ai
  id: totrans-split-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With Distributed Authorization, you get the the benefits of explicit authorization
    logic without the penalty of centralizing all your authorization data. It’s Authorization
    as a Service that works with your application, rather than forcing you to rework
    your application to work with it.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: This is a major milestone for us, but we know the job’s not done. We’re continuing
    to make it easier for you to centralize the data that you do want to keep in Oso
    Cloud. We’re enhancing Polar to make it even more flexible and robust. And we
    haven’t forgotten about monoliths – although the Oso library is now deprecated,
    we’re working on bringing these capabilities to you too!
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: In the coming weeks, we’ll be sharing more on how Distributed Authorization
    works under the hood, and the different ways customers like Headway and Jasper.ai
    are already using it.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to learn more about how to use it in your app, [check our our
    docs for Distributed Authorization and List Filtering](https://www.osohq.com/docs/guides/integrate/filter-lists?utm_content=distributedauthz_launchpost#list-filtering-with-decentralized-data).
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: Do you have questions or want to share your thoughts? [Reach out to us on Slack](https://join-slack.osohq.com/)
    or [Schedule a 1x1 with an Engineer](https://calendly.com/osohq/oso-cloud-1-on-1?utm_content=distributed_authz_launchpost)!
    We’d love to talk with you.
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
