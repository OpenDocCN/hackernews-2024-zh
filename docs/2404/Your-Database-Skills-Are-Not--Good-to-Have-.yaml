- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 12:48:35'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Your Database Skills Are Not 'Good to Have'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://renegadeotter.com/2023/11/12/your-database-skills-are-not-good-to-have.html](https://renegadeotter.com/2023/11/12/your-database-skills-are-not-good-to-have.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A MySQL war story
  id: totrans-split-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s 2006, and the New York Magazine digital team set out to create a new search
    experience for its Fashion Week portal. It was one of those projects where technical
    feasibility was not even discussed with the tech team - a common occurrence back
    then. Agile was still new, let alone in publishing. It was just a vision, a real
    friggin’ moonshot, and 10 to 12 weeks to develop the wireframed version of the
    product. There would be almost no time left for proper QA. Fashion Week does not
    start slowly but rather goes from zero to sixty in a blink.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: 'The vision? Thousands of near-real-time fashion show images, each one with
    its sub-items categorized: “2006”, “bag”, “red”, “ leather”, and so on. A user
    will land on the search page and have the ability to “drill down” and narrow the
    results based on those properties. To make things *much* harder, all of these
    properties would come with exact counts.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: The workflow was going to be intense. Photographers will courier their digital
    cartridges from downtown NYC to our offices on Madison Avenue, where the images
    will be processed, tagged by interns, and then indexed every hour by our Perl
    script, reading the tags from the embedded EXIF information. Failure to build
    the search product on our side would have collapsed the entire ecosystem already
    in place, primed and ready to rumble.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: “Oh! Just use the facets in Solr, dude”. Yeah, not so fast - *dude*. In 2006
    that kind of technology didn’t even exist yet. I sat through multiple enterprise
    search engine demos, and none of the products (which cost a LOT of money) could
    do a deep faceted search. We already had an Autonomy license and my first try
    proved that… it just couldn’t do it. It was supposed to be able to, but the counts
    were all wrong. Endeca (now owned by Oracle), [came out of stealth](https://www.digitalcommerce360.com/2006/03/31/endeca-unveils-the-endeca-information-access-platform-takes-aim/)
    when the design part of the project was already underway. Too new, too raw, too
    risky. The idea was just a little too ambitious for its time, especially for a
    tiny team in a non-tech company.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: So here we were, a team of three, myself and two consultants, writing Perl for
    the indexing script, query-parsing logic, and modeling the data - in MySQL 4\.
    It was one of those projects where one single insurmountable technical risk would
    have sunk the whole thing. I will cut the story short and spare you the excitement.
    We did it, and then we went out to celebrate at a karaoke bar (where I got my
    very first work-stress-related severe hangover) 🤮
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: For someone who was in charge of the SQL model and queries, it was days and
    days of tuning those, timing every query and studying the `EXPLAIN` output to
    see what else I could do to squeeze another 50ms out of the database. There were
    no free nights or weekends. In the end, it was a combination of trial and error,
    digging deep into MySQL server settings, and crafting `GROUP BY` queries that
    would make you nauseous. The MySQL query analyzer was fidgety back then, and sometimes
    re-arranging the fields in the `SELECT` clause could change a query’s performance.
    Imagine if `SELECT field1, field2 FROM my_table` was faster than `SELECT field2,
    field1 FROM my_table`. Why would it do that? I have no idea to this day, and I
    don’t even want to know.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些负责SQL模型和查询的人来说，调优是日复一日的工作，计时每一个查询并研究`EXPLAIN`输出，看看还能做些什么来从数据库中挤出另外50ms。没有免费的夜晚或周末。最终，这是试错的结合，深入研究MySQL服务器设置，以及精心设计的`GROUP
    BY`查询，可能会让你感到恶心。那时的MySQL查询分析工具是烦躁不安的，有时候重新排列`SELECT`子句中的字段可以改变查询的性能。想象一下，如果`SELECT
    field1, field2 FROM my_table`比`SELECT field2, field1 FROM my_table`更快。为什么会这样？直到今天我也不知道，而且我也不想知道。
- en: Unfortunately, I lost examples of this work, but the [Way Back Machine](https://web.archive.org/web/20070519214259/http://nymag.com/fashion/fashionshows/2007/spring/main/newyork/womenrunway/yigalazrouel/)
    has proof of our final product.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我丢失了这项工作的例子，但是[Way Back Machine](https://web.archive.org/web/20070519214259/http://nymag.com/fashion/fashionshows/2007/spring/main/newyork/womenrunway/yigalazrouel/)可以证明我们的最终产品。
- en: The point here is - if you really know your database, you can do pretty crazy
    things with it, and with the modern generation of storage technologies and beefier
    hardware, you don’t even need to push the limits - it should easily handle what
    I refer to as “common-scale”.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是 - 如果你真的了解你的数据库，你可以做出相当疯狂的事情，而且随着现代存储技术和更强大的硬件的出现，你甚至不需要推动极限 - 它应该可以轻松处理我所称的“常规规模”。
- en: The fading art of SQL
  id: totrans-split-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL这门日渐衰落的艺术
- en: In the past few years I have been noticing an unsettling trend - software engineers
    are eager to use exotic “planet-scale” databases for pretty rudimentary problems,
    while at the same time not having a good grasp of the very powerful relational
    database engine they are likely already using, let alone understanding the technology’s
    more advanced and useful capabilities. The SQL layer is buried so deep beneath
    libraries and too clever by a half ORMs that it all just becomes high-level code.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，我注意到一个令人不安的趋势 - 软件工程师渴望在处理相当基础的问题时使用外来的“星球规模”数据库，与此同时，他们对自己可能已经在使用的强大的关系型数据库引擎的掌握程度并不高，更不用说理解这些技术更高级和更有用的能力了。SQL层被深深埋藏在库下面，被过于聪明的ORMs所掩盖，一切都变成了高级别的代码。
- en: Modern hardware certainly allows us to go way up from the CPU into the higher
    abstraction layers, while it wasn’t that uncommon in the past to convert certain
    functions to assembly code in order to squeeze every bit of performance out of
    the processor. Now compute and storage is cheaper - it’s true - but abusing this
    abundance has trained us laziness and complacency. Suddenly, that Cloud bill is
    a wee too high, and heavens knows how much energy the world is burning by just
    running billions of auto-generated “Squeel” queries every second against mammoth
    database instances.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现代硬件确实允许我们从CPU提升到更高的抽象层，虽然过去将某些功能转换为汇编代码以挤压处理器的每一位性能并不罕见。现在计算和存储变得更便宜了 - 这是真的
    - 但是滥用这种丰富训练了我们的懒惰和自满。突然间，云账单有点高，而且谁知道世界每秒运行数十亿个自动生成的“Squeel”查询对巨大数据库实例的能源消耗有多大。
- en: The morning of my first job interview in 2004, I was on a subway train memorizing
    the nine levels of database normalization. Or is it five levels? I don’t remember,
    and It doesn’t even matter - no one will ever ask you this now in a software engineer
    interview.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 2004年我第一次求职面试的早晨，我在地铁上背诵数据库规范化的九个级别。还是五个级别吗？我不记得了，但这已经无关紧要了 - 在软件工程师的面试中现在永远不会有人问你这个。
- en: Just skimming through the table of contents of your database of choice, say
    the now [freshly in vogue Postgres](https://www.crunchydata.com/blog/when-did-postgres-become-cool),
    you will find an absolute treasure trove of features fit to handle everything
    but the most gruesome planet-scale computer science problems. Petabyte-sized Postgres
    boxes, replicated, are effortlessly running now as you are reading this.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 只需大略浏览您选择的数据库的目录，比如现在 [风靡一时的 Postgres](https://www.crunchydata.com/blog/when-did-postgres-become-cool)，您会发现一个绝对宝藏般的功能组合，适合处理几乎所有，除了最棘手的全球规模计算机科学问题。像您现在阅读的这样的
    PB 级 Postgres 盒子，已经轻松复制运行了。
- en: The trick is to not expect your database or your ORM to read your mind. Speaking
    of…
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 窍门在于不要指望您的数据库或 ORM 能够读懂您的心思。说到……
- en: ORMs are not magic
  id: totrans-split-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM 不是魔法
- en: I was a new hire at an e-commerce outfit, and right off the bat I was thrown
    into fixing serious performance issues with the company’s product catalog pages.
    Just a straight-forward, paginated grid of product images. How hard could it be?
    Believe it or not - it be. The pages took over 10 seconds to load, sometimes longer,
    the database was struggling, and the solution was to “just cache it”. One last
    datapoint - this was not a high-traffic site. The pages were dead-slow even if
    there was no traffic at all. That’s a rotten sign that something is seriously
    off.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一家电子商务公司的新员工，一开始就被抛入修复公司产品目录页面的严重性能问题中。只是一个简单的、分页的产品图片网格。这能有多难？信不信由你——确实难。页面加载超过
    10 秒，有时更长，数据库挣扎不堪，解决方案是“只需缓存它”。最后一个数据点——这不是一个高流量网站。即使没有流量，页面也会非常缓慢。这表明问题严重。
- en: After looking a bit closer, I realized that I hit the motherlode - all top three
    major database and coding mistakes in one.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看后，我意识到我一次性犯了前三大主要数据库和编码错误。
- en: '❌ Mistake #1: There is no index'
  id: totrans-split-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '❌ 错误 #1：没有索引'
- en: The column that was hit in every single mission-critical query had no index.
    None. After adding the much-needed index in production, you could practically
    hear MySQL exhaling in relief. Still, the performance was not quite there yet,
    so I had to dig deeper, now in the code.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关键任务查询中被命中的列都没有索引。一个都没有。在生产中添加了非常需要的索引后，您几乎可以听到 MySQL 在松了口气。然而，性能还没有完全达到预期，所以我不得不深入代码。
- en: '❌ Mistake #2: Assuming each ORM call is free'
  id: totrans-split-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '❌ 错误 #2：假设每个 ORM 调用都是免费的'
- en: 'Activating the query logs locally and reloading a product listing page, I see…
    200, 300, 500 queries fired off just to load one single page. What the shit? Turns
    out, this was the result of a classic ORM abuse of going through every record
    in a loop, to the effect of:'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地激活查询日志并重新加载产品列表页面时，我看到……为了加载一个页面，竟然发出了 200、300、500 次查询。这是什么鬼？结果，这是经典的 ORM
    滥用导致的，每个记录都通过循环进行查询，效果如下：
- en: '[PRE0]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The high number of queries was also due the fact that some of this logic was
    *nested*. The obvious solution is to keep the number of queries in each request
    to a minimum, using ORM capabilities to join and combine the data into one single
    blob. This is what relational databases do - *it’s in the name*.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 高数量的查询也是因为部分逻辑是*嵌套*的事实。明显的解决方案是使用 ORM 的能力将每个请求中的查询数量保持最小化，将数据联接和组合成一个单一的块。这是关系型数据库做的事情——*这就是它的名字*。
- en: What is happening above is that each separate query needs to travel to the database,
    [get parsed, transformed, analyzed, planned, executed](https://postgrespro.com/blog/pgsql/5969262#:~:text=Any%20query%20can%20be%20executed,rows%20that%20match%20your%20query),
    and then travel back to the caller. It is one of the most expensive operations
    you can do, and ORMs will happily do the worst possible thing for you in terms
    of performance. How does that ORM call translate to SQL? If it’s not what you
    think it should be, is it an ORM limitation or are you just not using the right
    library call? Is it a particular flavor of non-ANSI vendor SQL that your choice
    of ORM has a tough time with? Do you ultimately need to drop into raw SQL for
    this call but not the others? And so on.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况是每个单独的查询需要访问数据库，[进行解析、转换、分析、计划、执行](https://postgrespro.com/blog/pgsql/5969262#:~:text=Any%20query%20can%20be%20executed,rows%20that%20match%20your%20query)，然后返回给调用者。这是你能做的最昂贵的操作之一，ORM
    会乐意为了性能做最糟糕的事情。ORM 调用如何转换为 SQL？如果不符合您的预期，是 ORM 的限制还是您没有使用正确的库调用？这是特定的非 ANSI 厂商
    SQL 的风格吗？对于这个调用，您最终是否需要切换到原始 SQL，但其他不需要？等等。
- en: '<photo-element source="database-skills/55.png" aspect="original-size" alt="Don''t
    do this">#### ❌ Mistake #3: Pulling in the world'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: To make matters worse, the amount of data here was relatively small, but there
    were dozens and dozens of columns. What do ORMs usually do by default in order
    to make your life “easier”? They send the whole thing, all the columns, clogging
    your network pipes with the data that you don’t even need. It is a form of *toxic
    technical debt*, where the speed of development will eventually start eating into
    performance.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: I spent hours within the same project hacking the dark corners of the Dango
    admin, overriding default ORM queries to be less “eager”. This led to a much better
    office-facing experience.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: Performance IS a feature
  id: totrans-split-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Serious, mission-critical systems have been running on classic and boring relational
    databases for decades, serving thousands of requests per second. These systems
    have become more advanced, more capable, and more relevant. They are wonders of
    computer science, one can claim. You would think that an ancient database like
    Postgres (in development since 1982) is in some kind of legacy maintenance mode
    at this point, but the opposite is true. In fact, the work has been only accelerating,
    with the scale and [features becoming pretty impressive](https://www.se-radio.net/2019/04/se-radio-episode-362-simon-riggs-on-advanced-features-of-postgresql/).
    What took multiple queries just a few years ago now takes a single one.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is this significant? It has been known for a long time, [as discovered
    by Amazon](https://www.conductor.com/academy/page-speed-resources/faq/amazon-page-speed-study/),
    that every additional 100ms of a user waiting for a page to load loses a business
    money. We also know now that from a user’s perspective, [the maximum target response
    time for a web page is around 100 milliseconds](https://designingforperformance.com/performance-is-ux/#:~:text=A%20delay%20of%20less%20than,start%20to%20mentally%20context-switch):'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: A delay of less than 100 milliseconds feels instant to a user, but a delay between
    100 and 300 milliseconds is perceptible. A delay between 300 and 1,000 milliseconds
    makes the user feel like a machine is working, but if the delay is above 1,000
    milliseconds, your user will likely start to mentally context-switch.
  id: totrans-split-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The “just add more CPU and RAM if it’s slow” approach may have worked for a
    while, but [many are finding out the hard way](https://venturebeat.com/data-infrastructure/the-shift-to-the-cloud-could-be-costing-businesses-more-than-its-saving/)
    that this kind of laziness is not sustainable in a frugal business environment
    where costs *matter*.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: Database anti-patterns
  id: totrans-split-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Knowing what **not** to do is as important as knowing what **to** do. Some
    of the below mistakes are all too common:'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: '❌ Anti-pattern #1\. Using exotic databases for the wrong reasons'
  id: totrans-split-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Technologies like DynamoDB are designed to handle scale at which Postgres and
    MySQL begin to fail. This is achieved by denormalizing, duplicating the data aggressively,
    where the database is not doing much real-time data manipulation or joining. Your
    data is now modeled after how it is queried, not after how it is *related*. Regular
    relational concepts disintegrate at this insane level of scale. Needless to say,
    if you are resorting to this kind of storage for “common-scale” problems, you
    are already [solving problems you don’t have](/2023/09/10/death-by-a-thousand-microservices.html).
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: '❌ Anti-pattern #2\. Caching things unnecessarily'
  id: totrans-split-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Caching is a necessary evil - *but it’s not always necessary*. There is an entire
    class of bugs and on-call issues that stem from stale cached data. Read-only database
    replicas are a classic architecture pattern that is still very much not outdated,
    and it will buy you insane levels of performance before you have to worry about
    anything. It should not be a surprise that mature relational databases already
    have query caching in place - it just [has to be tuned](https://severalnines.com/blog/overview-caching-postgresql/)
    for your specific needs.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: Cache invalidation is hard. It adds more complexity and states of uncertainty
    to your system. It makes debugging more difficult. I received more emails from
    content teams than I care for throughout my career that wondered “why is the data
    not there, I updated it 30 minutes ago?!”
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: '*Caching should not act as a bandaid for bad architecture and non-performant
    code.*'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: '<photo-element source="database-skills/two-problems.png" aspect="original-size"
    alt="Caching">#### ❌ Anti-pattern #3\. Storing everything and a kitchen sink'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: As much punishment as an industry-standard database can take, it’s probably
    not a good idea to not care at all about what’s going into it, treating it like
    a data landfill of sorts. Management, querying, backups, migrations - all becomes
    painful once the DB grows substantially. Even if that is of no concern as you
    are using a managed cloud DB - the costs should be. An RDBMS is a sophisticated
    piece of technology, and storing data in it is *expensive*.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: Figure out common-scale first
  id: totrans-split-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is fairly easy to make a beefy Postgres or a MySQL database grind to a halt
    if you expect it to do magic without any extra work. *“It’s not web-scale, boss.
    Our 2 million records seem to be too much of a lift. We need DynamoDB, Kafka,
    and event sourcing!”*
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: A relational database is not some antiquated technology that only us tech fossils
    choose to be experts in, a thing that can be waved off like an annoying insect.
    *“Here we React and GraphQL all the things, old man”*. In legal speak, a modern
    RDBMS is innocent until proven guilty, and the burden of proof should be extremely
    high - and almost entirely on you.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if I have to figure out “why it’s slow”, my approximate runbook is:'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: Compile a list of unique queries, from logging, slow query log, etc.
  id: totrans-split-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the most frequent queries first
  id: totrans-split-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `EXPLAIN` to check slow query plans for index usage
  id: totrans-split-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select only the data that needs to travel across the wire
  id: totrans-split-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an ORM is doing something silly without a workaround, pop the hood and get
    dirty with the raw SQL plumbing
  id: totrans-split-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <photo-element source="database-skills/merry-xmas.gif" aspect="landscape" alt="Merry
    Xmas!">Most importantly, study your database (and SQL). Learn it, love it, use
    it, abuse it. Spending a couple of days just leafing through that Postgres manual
    to see what it *can* do will probably make you a better engineer than spending
    more time on the next flavor-of-the-month JavaScript framework hotness. Again.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: Latest
  id: totrans-split-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Related posts
  id: totrans-split-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[I am not your Cloud person](/2023/07/26/i-am-not-your-cloud-person.html)'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-split-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Use the index, Luke - SQL Indexing and Tuning e-Book](https://use-the-index-luke.com/)'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: '[Don’t do this - a Postgres WIKI](https://wiki.postgresql.org/wiki/Don''t_Do_This)</photo-element></photo-element></photo-element>'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
