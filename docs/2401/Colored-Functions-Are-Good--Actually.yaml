- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:22:17'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Colored Functions Are Good, Actually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.danmailloux.com/blog/colored-functions-are-good-actually](https://www.danmailloux.com/blog/colored-functions-are-good-actually)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Colored Functions Are Good, Actually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Bob Nystrom's excellent article [What Color is Your Function?](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/),
    he argues that "colored" (async) functions are bad because they create two separate
    code universes with rules about where you can call what and when. Kind of.
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to flip that assertion on its head and argue that, in practice, this
    limitation is often a good thing. I'll admit that I'm setting up a bit of a strawman
    here, and because Bob is much smarter than me, his article also contains lots
    of technical details that may outweigh the benefits of what I'm about to say.
    Indulge my *sort of* correct intro, and I promise what's to come will be at least
    somewhat interesting.
  prefs: []
  type: TYPE_NORMAL
- en: '## IO in Haskell'
  prefs: []
  type: TYPE_NORMAL
- en: If you've spent some time in online programming circles, you've likely heard
    it said that JavaScript's promises are monads or that they are monadic. While
    a quick Google search reveals that this is not quite true, it is *kind of* true,
    and anyways this is just a botched segue in order to introduce monads.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry, this isn't another article about monads. I'm not gonna "say the
    line." (Sike - monads are just monoids in the category of endofunctors!!!) Really,
    I just want to talk about a specific monad - Haskell's `IO` monad. For the uninitiated,
    Haskell is a [*purely* functional programming language](https://en.wikipedia.org/wiki/Functional_programming),
    emphasis on pure. In Haskell, in order to do things like reading from a database,
    writing logs, or making an HTTP request, you must wrap that code in the `IO` monad.
  prefs: []
  type: TYPE_NORMAL
- en: '"What''s a monad?" you might be asking. It''s a real rabbit hole, and to be
    honest, it doesn''t really matter right now. If you''re interested, I can recommend
    Arialdo Martini''s [Monads For The Rest Of Us](https://arialdomartini.github.io/monads-for-the-rest-of-us)
    series, but you really don''t need it to proceed, and to reiterate, monads are
    a *real* rabbit hole. **For the purposes of this article, think of `IO` as a simple
    type that wraps the return type of a function.** Much like how a function in JavaScript
    can return `promise<string>`, a function in Haskell can return `IO String`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Again, we see a program where side effects are suggested by the presence of
    a type. In this case, that type is `Task`, in JavaScript, it would be `Promise`,
    and as we saw above - in Haskell that type is `IO`. Of course, there are important
    technical distinctions between `Task<int>` and `IO Int`, but they share one important
    benefit. **It signals to the programmer that something effectful is probably happening
    inside that code.**
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in C# the compiler does not enforce this distinction, and not all
    effectful operations even are `async` such as writing to the console or generating
    a random number, but in practice, this turns out to be a pretty useful convention.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgements
  prefs: []
  type: TYPE_NORMAL
- en: I'd like to point out that I am not the first person to notice this. Mark Seemann
    has written the excellent article [Async as surrogate IO](https://blog.ploeh.dk/2016/04/11/async-as-surrogate-io/)
    in which he uses much more rigor to truly compare `IO` and F#'s `Async`. His article
    is wonderful, and technical, and thought-provoking, and every programmer should
    read it.
  prefs: []
  type: TYPE_NORMAL
- en: This article, however, is not meant to be that. It's a more casual look at the
    topic which asks, "even if we can't rely on the similarity, is there still something
    valuable there?"
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we can often get fixated on edge cases and technical details,
    but I think it's okay to acknowledge helpful rules of thumb as well, even if they're
    not always 100% accurate. In our day to day work, many of us are often more like
    tradespeople than scientists. If noticing that a function is `async` makes you
    think, "hey, there's probably a side effect in there" - I think that's nice. :)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
