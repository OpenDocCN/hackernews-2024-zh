- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:56:53'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL and the beads on a string - by Lucca Siaudzionis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.luccasiau.com/p/graphql-and-the-beads-on-a-string](https://blog.luccasiau.com/p/graphql-and-the-beads-on-a-string)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Your database, backend and the user are all beads on a string.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dax ([thdxr](https://twitter.com/thdxr))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Basically:'
  prefs: []
  type: TYPE_NORMAL
- en: 'But normally you’ll be hosting your backend very closely to your database,
    making this other piece of art a bit more accurate:'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading a typical web page requires different pieces of information — for example,
    you may be loading the logged-in user’s profile on the corner, the main content
    in the center, and other little details around the page. In a typical REST API
    design, this will often translate to several separate requests, looking like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the main benefits of GraphQL is that easily enables the client to make
    a single request specifying all those pieces of data, and the backend stitches
    them together. The browser would make a single request asking for the user’s profile,
    the main content, and the rest — and the result looks way better:'
  prefs: []
  type: TYPE_NORMAL
- en: Which brings some simplicity to the client and potentially reduces load time,
    improving your users’ experience.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: While it’s true that, in the RESTful case, you can make those requests asynchronously,
    you would on the other hand add significant complexity to the client. That means
    dealing with independent request failures and all the dependencies between these
    separate calls.
  prefs: []
  type: TYPE_NORMAL
- en: You could also define a single REST endpoint that contains all the information
    to load the page and mimic the GraphQL behavior. But this would just shift the
    burden of dealing with complexity from the client to the backend. And while that
    may be viable for simple applications, it would not be in more complex ones.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, GraphQL’s design fits like a glove for this case. There is no need
    to design solutions to reduce latency, as it was designed specifically to address
    such cases.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This is just one of the many reasons I appreciate GraphQL. Some other advantages
    are the very, very easy use of GraphQL subscriptions, and how it makes the API
    contract between frontend and backend explicitly define (some people don’t like
    this one though, but I’m a huge fan).
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, GraphQL is *quite* different and feels weird at first. It may not
    seem worth spending the effort to “relearn” a new way to do core things. But one
    day I decided to just try it with Apollo and was surprised and how easy it was.
    So, if you ever feel a bit curious, just give it a shot.
  prefs: []
  type: TYPE_NORMAL
- en: '[Share](https://blog.luccasiau.com/p/graphql-and-the-beads-on-a-string?utm_source=substack&utm_medium=email&utm_content=share&action=share)'
  prefs: []
  type: TYPE_NORMAL
