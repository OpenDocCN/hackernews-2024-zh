<!--yml

category: 未分类

date: 2024-05-27 14:29:51

-->

# 终端平滑滚动

> 来源：[https://flak.tedunangst.com/post/terminal-smooth-scrolling](https://flak.tedunangst.com/post/terminal-smooth-scrolling)

我之前并没有意识到我需要这个功能，直到我实现了它，现在，哇，不能想象没有它的生活了。

通常，终端以固定的间隔绘制文本行。第一行从像素0开始，然后第二行从24像素开始，依此类推。当文本滚动时，第二行立即变成第一行，并在像素0处绘制。然而，这种突然的跳跃与您的眼睛跟踪运动的方式不兼容。结果是一片模糊不清的混乱，很难阅读。

很久以前，硬件终端有平滑滚动的选项，每行文字逐帧向上移动，但这种魔法已经随着时间的流逝而失传。我觉得实现这个功能会很有趣，也许是一个炫酷的技巧可以炫耀一下，但在看到结果之前，我认为这主要是个噱头。然而，这完全改变了我浏览文本的方式。

### results

我觉得我们可以从一个视频开始，展示前后的效果。通过*ls*手册进行滚动。在一半左右，终端切换到平滑滚动。

</images/scrollcap.mp4>

我无法以足够快的速度阅读跟得上滚动速度，至少不是每个单词，但我可以在文字经过时快速浏览，直到找到我要找的部分。在阅读代码或文档时非常有帮助，当我不确定那是什么时。

我发现像这样滚动最终比一页一页翻页，然后试图快速浏览整个屏幕更有效。我总是在这样做时错过一些东西。

### implementation

几乎我所看过的每一个终端都有一个开放的问题请求平滑滚动，但没有一个实现了。通常，讨论会陷入琐碎之中。我发现做一些事情并不难，而且结果相当令人满意。我想这可能有助于只关心一个用户。

第一个大问题是哦，不，这会使事情变慢。只有在启用时才会。有一个终端模式序列来启用和禁用它。我发现对于像运行*ls*这样的常规shell工作来说，它稍微分散了注意力，因此只在必要时启用它。滚动速度可以根据滚动量加快。我选了十帧作为目标，尽管它花的时间比那更长，因为它朝着结束减速。

第二个大问题与滚动区域有关。像*vi*这样的程序滚动屏幕上的大多数行，但它们会将底部的状态栏保留下来。的确，滚动它看起来很滑稽。但这很容易通过仅将平滑滚动效果应用于已滚动部分的屏幕来解决。

最后，还有一个问题，那就是滚动消失的内容该怎么处理。当一行消失在备用屏幕上时，没有后备可以将其发送到。它就消失了。那么在下一行完成滚动到位之前，在那个空间内画什么呢？答案是什么也不画。你可以在屏幕顶部（或底部）留下一行或两行空白。新的内容，也就是我关注的内容，出现在另一边。我不是在看消失的行；我在看出现的行。

至于实际实现，屏幕上的每个单元格都是用一些顶点绘制的。如果我们正在平滑滚动，我们会将这些顶点向相反方向偏移。如果屏幕上的文本只是向上移动了，我们就会将每个顶点向下推，这样它们就会出现在之前的相同位置。然后我们会在每一帧中衰减偏移量，这样文本就会滑入位置。

代码的主要部分大约有25行，加上几行零零散散的。

### 杂项细节

概念验证很快就开始了，但确实需要一些实验和调整。如果我们开始得太慢，就会落后于输入。如果我们加速得太快，结果看起来会很颠簸。导数太多。

当前的方法是选择一个距离除以10的速度。然后我们使用前一个速度的加权平均值来平滑平滑。如果我们落后十行以上，这种情况很少发生，但如果整个屏幕被重新绘制则可能发生，那么就会执行一个跳跃滚动。

平滑滚动的区域由滚动时的滚动区域确定，而不是绘制时确定。例如，*vim*会将滚动区域设置为1;23以调整显示的文件内容，然后立即切换回1;24以更新状态栏。由于我们不想滚动状态栏，我们希望将效果应用于先前设置的1;23区域。

现在，我们也会滚动内部行，例如剪切和粘贴操作。这介于干扰和有用之间。这种运动事实证明是一个有用的提示，显示了发生了什么变化，而且速度足够快，不会妨碍操作。

如果一个屏幕外的选项卡滚动，当用户切换回来时会应用平滑效果。这通常不会发生（除非在shell中启用了平滑滚动），但我认为它可以作为某种变化的有用指示器。这是*新*的编译器输出。

每次滚动绘制屏幕十次显然会使用十倍的CPU功率。

### 用法

平滑滚动是通过标准的“\e[4?h”控制序列启用的。

有用的 .vimrc：

```
set t_TI=^[[4?h
set t_TE=^[[4?l
```
