- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:24:45'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Writing a TrueType font renderer | Phillip Tennen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://axleos.com/writing-a-truetype-font-renderer/](https://axleos.com/writing-a-truetype-font-renderer/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <content>Text is *the* medium of digital interaction, and text rendering has
    an outsized impact on the overall fit and finish of any system. It therefore pains
    me that axle has for years relied on a low-resolution 8x8 bitmap font. Let’s fix
    it!
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the characters composing this sentence. Note the curves, the
    negative space, the use of size and distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve got a magnifying glass handy, you can even see how ‘black-on-white’
    text uses many shades of gray to make the text smoother on the eyes. I’ll show
    you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8f86de022dbeff655d130b12cdf384b.png)'
  prefs: []
  type: TYPE_IMG
- en: Font rendering comes down to telling the computer which pixels should be on
    or off, which should be darkened slightly for effect and which should let the
    background shine through.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge comes from describing this to the computer in a way that’s *efficient*
    and *resizable*. Fonts shouldn’t take up too much storage, and we should be able
    to scale a font to any size the user requests while preserving the character of
    the font design. Perhaps most importantly, we’ll want to satisfy these constraints
    while also making the text pleasant to read.
  prefs: []
  type: TYPE_NORMAL
- en: Minimalist Text Renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s do away with all of these requirements for now, and start off with the
    simplest viable approach to rendering characters. How might we go about coloring
    pixels into text?
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we’ll select a fixed size for each character. We’ll agree that every
    character will be exactly 8 pixels wide and 8 pixels high. That gives us a grid
    of 64 pixels per character to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a simple data format that describes whether each pixel in our 8x8
    grid should be on (colored with the font color) or off (retain the background
    color). We can draw out our character grid like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we’ve got 8 pixels in each row, and each pixel has two states, it’s natural
    to store each row in our grid as one byte. For example, we could represent a capital
    `A` using a representation like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following hexadecimal representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '… and allows us to very efficiently store render maps for ASCII:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite a tidy encoding! To render a character, we can directly look
    up its render map using its ASCII representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Believe it or not, that’s it. axle has been using the above font rendering technique
    for the better part of a decade.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fe7c2216452c9e07fc93cc8cd3ba32d.png)'
  prefs: []
  type: TYPE_IMG
- en: Although the font above only natively provides 8px bitmaps, it’s pretty easy
    to scale it to any size we like. However, the font will always appear jagged and
    low-resolution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cccb1360fc1606bcdf0969f91e962a07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While the 8x8 bitmap font *works*, it sure isn’t pretty, and it’s quite limited:
    we can only use whatever font we’re willing to encode into this little 8x8 grid,
    and we’re unable to use any of the many fonts available online and in the public
    domain. Additionally, our 8x8 grid doesn’t give us much of a good way to describe
    curves, which are essential in some fonts (check out this `a`!).'
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, writing a new font renderer sounds like fun.
  prefs: []
  type: TYPE_NORMAL
- en: TrueType
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the next leap in our text rendering journey, we turn to TrueType: the de
    facto standard for encoding and distributing fonts. Unlike our humble 8x8 bitmaps,
    TrueType fonts are distributed as structured binary files (`.ttf`). We’ll need
    to parse these files and render their data into pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s few things in this world I love more than taking an opaque binary and
    gradually uncovering the organization that was present all along. Dissecting the
    underlying and general structure of a binary is as gratifying as anything I can
    imagine.
  prefs: []
  type: TYPE_NORMAL
- en: The [TrueType specification](https://developer.apple.com/fonts/TrueType-Reference-Manual/)
    gives a great introduction to the problem space (I highly recommend the overviews
    in `Digitizing Letterforms` and especially `Instructing Fonts`), but it doesn’t
    give much in the way of signposting “start parsing here”. I’ll save you the trouble.
  prefs: []
  type: TYPE_NORMAL
- en: TTFs are structured somewhat similarly to Mach-Os. This is quite a nice surprise,
    because I’ve spent [a lot of time parsing Mach-Os](https://github.com/datatheorem/strongarm/)!
    Both file formats were developed ~~at Apple~~ around the same time, so I suppose
    they had some design points in the air.
  prefs: []
  type: TYPE_NORMAL
- en: TTFs and Mach-Os are both largely structured around a flat series of sections,
    each of which is described by a table of contents at the beginning of the file.
    In the case of TTFs, each of these sections will contain some metadata or other
    that we’ll need over the course of rendering the font.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f03984ada9bca2e04b2e49f115ecd51.png)'
  prefs: []
  type: TYPE_IMG
- en: Before taking a look at these sections becomes fruitful, though, we need to
    know the fundamental process for describing fonts used by TrueType. The specification
    does a great job, so I’ll keep myself brief.
  prefs: []
  type: TYPE_NORMAL
- en: The collection of lines and curves used to visually represent a particular letter
    is referred to as a *glyph*. As an example, the glyph `b` consists of a vertical
    line and a semicircle.
  prefs: []
  type: TYPE_NORMAL
- en: Without further information, though, our renderer won’t know *which* glyph represents
    each character. We’ll need some additional metadata to convert from a character
    within a *character map* (such as ASCII or Unicode) to the *glyph* that a particular
    font is using to visually represent that character. The job of the TTF is dually
    to describe how to draw all the glyphs represented by the font, and to describe
    the correspondence between the character map and these glyphs.
  prefs: []
  type: TYPE_NORMAL
- en: TrueType describes how to draw each glyph by listing a series of points, which
    collectively compose the *outline* of each glyph. It’s up to the renderer to connect
    these points into lines, to turn these lines into curves, and to ‘color inside
    the lines’ as appropriate. There’s more nuance here, but that’s the bare bones.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a923630a3af9626fc6ab1786bfac129c.png) ![](img/a8846ea8a05bdb7879ec2495ca8bf318.png)
    *Rendering points without connecting them into lines*'
  prefs: []
  type: TYPE_NORMAL
- en: Things start to look a lot more comprehensible once you connect the dots.
  prefs: []
  type: TYPE_NORMAL
- en: Coloring inside the lines turns out to be more difficult than you might imagine.
  prefs: []
  type: TYPE_NORMAL
- en: My first implementation of this renderer didn’t draw any curves, but instead
    directly connected the points with straight lines. My colleague Amos [implemented](https://github.com/codyd51/axle/pull/47)
    the ability for the renderer to interpolate the glyph outline along the curves
    described in the font, which really improved the look of things. Thanks, Amos!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2190a7d64c3d781a5c1cbce04f64abbe.png)*Before and after Amos''s work
    to interpolate along curves*'
  prefs: []
  type: TYPE_NORMAL
- en: Tangled Text Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each section in the TTF is identified by a 4-character ASCII name. Different
    sections in the TTF contain different important metadata, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`glyf`: The set of points for each glyph outline in the font (most important!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hmtx`: Spacing information, i.e. how far to advance the cursor after drawing
    each glyph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmap`: The correspondence of Unicode codepoints to glyph indexes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these sections contains a bunch of structured data describing their
    contents. Here, our first mini challenge presents itself. TTF was designed in
    an era in which neither RAM nor core cycles were cheap. Therefore, the designers
    of the format made sure it’d be as easy as possible for the renderer to complete
    its work. To this end, they offloaded two responsibilities to the font file itself:'
  prefs: []
  type: TYPE_NORMAL
- en: Efficient data structures that the renderer can walk to retrieve info (for example,
    lookup tables to map a character code to a glyph index)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre-computation of some values used during lookup (for example, scaling parameters
    for binary searching a character map)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These optimizations aren’t so relevant today, but we’ll need to work with them
    nonetheless. The first one is particularly important: TTF is designed to be *loaded
    directly into memory* and read by the renderer *in-place*, without the renderer
    populating its own intermediary data structures. ~~Inexplicably, though~~, the
    TTF stores all fields in big endian, so we’ll definitely have to do some work
    on our end before we can read any sane values out of font structures.'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to define and read from these font structures with minimal boilerplate
    and repetition, I set things up such that I could wrap any font structure fields
    in `BigEndianValue`. After I call `.into()`, everything is done and dusted and
    I can move on with my day. A little bit of structure definition upfront for some
    easy breezy parsing code down the line!
  prefs: []
  type: TYPE_NORMAL
- en: '`rust_programs/ttf_renderer/src/parser.rs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ready for the payoff?
  prefs: []
  type: TYPE_NORMAL
- en: '``pub  fn parse(&mut  self)  -> Font``'
  prefs: []
  type: TYPE_NORMAL
- en: '`rust_programs/ttf_renderer/src/parser.rs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Oh yeah! We can parse our high-level, byte-order-corrected representation directly
    from the TTF memory without even needing to *mention* the raw TTF representation
    at the call-site. I’ll call that a win.
  prefs: []
  type: TYPE_NORMAL
- en: Parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handy APIs in hand, we’ll parse all the section descriptions at the start of
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: The `head` section (or *table*, as TTF prefers) stores some important metadata
    about the font as a whole. We know that TTF describes glyph outlines via a series
    of connected points. But if we see a point like `(371, 205)`, without further
    information we don’t have a reference for understanding where this sits visually.
    The `head` table gives us such a reference, by describing the `glyph_bounding_box`
    that all points sit within.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we’ll want to [parse a character map](https://github.com/codyd51/axle/blob/paging-demo/rust_programs/ttf_renderer/src/character_map.rs#L224)
    to find out how we’ll correspond encoded characters to glyph indexes. Each character
    map will also be described in an [extremely gnarly format](https://github.com/codyd51/axle/blob/paging-demo/rust_programs/ttf_renderer/src/character_map.rs#L340-L357)
    that the parser will need to know how to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now the exciting bit: parsing glyphs! The `maxp` table will give us some
    metadata on how many glyphs the font contains, while the glyph data itself is
    stored in `glyf`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can parse each `glyf` entry, we’ll need to know where each entry begins.
    The `loca` table will give us these offsets. However, nowhere is the *size* of
    each glyph’s data given explicitly in the font. Instead, the size of each glyph’s
    data is implicitly given by the difference with the starting offset of the *next*
    glyph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The intrepid font parser will quickly notice that some glyph descriptions appear
    to have *no* size. This is intentional: some glyphs, such as the one corresponding
    to the space character, have no visible manifestation aside from the negative
    space they occupy. When the renderer tries to draw one of these zero-sized glyphs,
    we’ll just advance the cursor based on the corresponding `htmx` size for this
    glyph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve actually got three distinct types of glyphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Polygon* glyphs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These glyphs are the classic case: an ordered collection of edge points and
    control points that should be connected in a series of curves.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Blank* glyphs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special case for glyphs such as those corresponding to the space character.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Compound* glyphs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glyphs manufactured by combining and scaling other glyphs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third category is really interesting! The glyphs for `i` and `j` both share
    an identical dot on top, and there’s no need to duplicate its description in the
    draw instructions. Instead, we can just say that `i` and `j` are each composed
    of a couple of glyph fragments laid out on the canvas at specific scales and positions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce29c4d37b65ade27622d9397351db3c.png)'
  prefs: []
  type: TYPE_IMG
- en: There are all sorts of counterintuitive edge cases with compound glyphs. As
    an example, we know that traditional polygon glyphs specify how far the cursor
    should advance after drawing them via corresponding entries in the `hmtx` and
    `vmtx` tables. However, how far should the cursor advance for a compound glyph?
    Sometimes the compound glyph has its own metrics table entries, and sometimes
    the compound glyph is annotated with a special flag indicating that it should
    take its cursor advance metrics from a specific child glyph.
  prefs: []
  type: TYPE_NORMAL
- en: '`rust_programs/ttf_renderer/src/glyph.rs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Compound glyphs don’t always directly contain polygon glyphs. Instead, a compound
    glyph can be composed of a tree of other compound glyphs, all stretched and scaled
    and repositioned across the bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: Hinting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TrueType famously defines a hinting VM that’s intended to help retain the essence
    of a font when rendering at low resolutions to a limited pixel grid. The job of
    the program running under this VM is to nudge the glyph’s control points into
    a specific layout on low-resolution bitmaps.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you’re trying to scale down a glyph’s points to fit on a small grid.
    If the render resolution isn’t exactly divisible by the glyph’s point spacing,
    you’re going to get scaling artifacts when you round each glyph point to a pixel.
  prefs: []
  type: TYPE_NORMAL
- en: The font can embed a little program that, when executed, nudges the glyph’s
    layout points to better represent the glyph within the available grid.
  prefs: []
  type: TYPE_NORMAL
- en: Our renderer will need to implement this VM, which is always a fun endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hinting VM is built around a standard (and incredibly satisfying) interpreter
    loop that modifies a virtual machine state based on the operations indicated by
    the byte stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rust_programs/ttf_renderer/src/hints.rs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There a slew of hilarious little engineering challenges that come up when trying
    to execute functions targeting a font’s operating environment.
  prefs: []
  type: TYPE_NORMAL
- en: '`rust_programs/ttf_renderer/src/hints.rs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: TrueType Quirks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occult Memorabilia
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The hinting VM is all about nudging the glyph’s outline points so that they
    look better on a small pixel grid. All of these points that actually compose a
    part of the glyph outline are in the ‘Glyph Zone’.
  prefs: []
  type: TYPE_NORMAL
- en: However, the VM designers realized that it was sometimes useful to have a point
    that wasn’t really part of the outline, but was just used as a reference when
    doing distance calculations. These points don’t belong in the Glyph Zone, so instead
    TrueType places them in a different space called… the [Twilight Zone](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html#SZP0).
  prefs: []
  type: TYPE_NORMAL
- en: The TrueType designers were clearly fans of the paranormal. TrueType provides
    convenient support for describing emboldened and italicized versions of fonts
    by embedding offsets to apply to each point in a glyph outline. A font variation
    might need the entire bounding box of a glyph to be modified too, so there are
    [‘phantom points’](https://learn.microsoft.com/en-us/typography/opentype/spec/tt_instructing_glyphs#phantom-points)
    corresponding to the corners of the bounding box that can be stretched and squeezed.
  prefs: []
  type: TYPE_NORMAL
- en: Implied Control Points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The TrueType specification suggests to the reader, hey! Maybe it’d be possible
    to save space by letting the renderer deduce missing control points?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ede638b7a860f08eeb480ac6945383fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Despite the casual tone of observation, renderers are actually required to support
    this. Fonts rely on this all the time! This is the only mention of it in the whole
    spec! Everyone needs to detect and insert implied control points, all on the back
    of one introductory diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Assume Nothing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like we’ve seen, TrueType has sophisticated support for manipulating the rendering
    process in constrained font sizes. But like any good programming environment,
    it also provides lots of escape hatches. One such escape hatch is the `bloc` table,
    which essentially says “if the font size is too small, ignore the glyph curves
    and hinting programs and just render these tiny bitmaps instead.”
  prefs: []
  type: TYPE_NORMAL
- en: Firming Up a Renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s still work to do to integrate this font renderer neatly in all the stacks
    that wind up displaying text on axle’s desktop, but the foundations are ready.
    Here’s what things looked like the last time I worked on propagating TrueType
    throughout the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this renderer is [here](https://github.com/codyd51/axle/tree/9d83c62eaad9dd0850bb7fe3641bd2821e5b84b0/rust_programs/ttf_renderer/src).
    Below are some screenshots from the course of this renderer’s development.</content>
  prefs: []
  type: TYPE_NORMAL
