- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-27 14:33:42'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 14:33:42
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: The Architecture of Open Source Applications (Volume 1)Sendmail
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源应用程序的架构（卷1）：Sendmail
- en: 来源：[https://aosabook.org/en/v1/sendmail.html](https://aosabook.org/en/v1/sendmail.html)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://aosabook.org/en/v1/sendmail.html](https://aosabook.org/en/v1/sendmail.html)
- en: The Architecture of Open Source Applications (Volume 1)
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源应用程序的架构（卷1）
- en: Sendmail
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Sendmail
- en: Eric Allman
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Eric Allman
- en: Most people think of electronic mail as the program that they interact with—their
    mail client, technically known as a Mail User Agent (MUA). But another important
    part of electronic mail is the software that actually transfers the mail from
    the sender to the recipient—the Mail Transfer Agent (MTA). The first MTA on the
    Internet, and still the most prevalent, was sendmail.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人认为电子邮件是他们与之交互的程序——他们的邮件客户端，技术上称为邮件用户代理（MUA）。但电子邮件的另一个重要部分是实际将邮件从发送者传输到接收者的软件——邮件传输代理（MTA）。互联网上第一个
    MTA，至今仍然是最普遍的，是 sendmail。
- en: Sendmail was first created before the Internet officially existed. It has been
    extraordinarily successful, having grown from 1981, when it wasn't at all obvious
    that the Internet was going to be more than an academic experiment with only a
    few hundred hosts, to today, with over 800 million Internet hosts as of January
    2011. Sendmail remains among the most used implementations of SMTP on the Internet.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Sendmail 是在互联网正式存在之前首次创建的。它取得了非凡的成功，从 1981 年开始，当时还不明显互联网会超出只是一个拥有几百台主机的学术实验，到今天，截至
    2011 年 1 月，互联网主机数量已超过 8 亿。Sendmail 仍然是互联网上最常用的 SMTP 实现之一。
- en: 17.1\. Once Upon a Time…
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1\. 从前，有一段时光…
- en: The first versions of the program that would become known as sendmail were written
    in 1980\. It started as a quick hack to forward messages between different networks.
    The Internet was being developed but was not functional at that time. In fact,
    many different networks had been proposed with no obvious consensus emerging.
    The Arpanet was in use in the United States and the Internet was being designed
    as an upgrade, but Europe had thrown its weight behind the OSI (Open Systems Interconnect)
    effort, and for a while it appeared that OSI might triumph. Both of these used
    leased lines from the phone companies; in the US that speed was 56 Kbps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的最初版本，后来被称为 sendmail，是在 1980 年编写的。它最初是一个快速的小工具，用于在不同的网络之间转发消息。互联网正在开发中，但当时还没有正式运行。实际上，许多不同的网络已被提议，但没有明显的共识出现。阿帕网在美国使用中，互联网正在被设计为一种升级，但欧洲已经支持
    OSI（开放系统互连）的努力，有一段时间看来 OSI 可能会取胜。这两者都使用电话公司的租用线路；在美国，速度是 56 Kbps。
- en: 'Probably the most successful network of the time, in terms of numbers of computers
    and people connected, was the UUCP network, which was unusual in that it had absolutely
    no central authority. It was, in some sense, the original peer-to-peer network,
    which ran over dialup phone lines: 9600 bps was about the fastest available for
    some time. The fastest network (at 3 Mbps) was based on the Ethernet from Xerox,
    which ran a protocol called XNS (Xerox Network Systems)—but it didn''t work outside
    of a local installation.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在当时，可能是最成功的网络，从连接的计算机和人数来看，是 UUCP 网络，这是非常不同寻常的，因为它绝对没有中央管理机构。在某种意义上，它是最初的对等网络，它在拨号电话线上运行：一段时间内
    9600 bps 是最快的速度。最快的网络（在 3 Mbps）基于施乐的以太网，运行一种叫做 XNS（Xerox Network Systems）的协议，但它在本地安装外部不能使用。
- en: 'The environment of the time was rather different than what exists today. Computers
    were highly heterogeneous, to the extent that there wasn''t even complete agreement
    to use 8-bit bytes. For example, other machines included the PDP-10 (36 bit words,
    9 bit bytes), the PDP-11 (16 bit words, 8 bit bytes), the CDC 6000 series (60
    bit words, 6 bit characters), the IBM 360 (32 bit words, 8 bit bytes), the XDS
    940, the ICL 470, and the Sigma 7. One of the up-and-coming platforms was Unix,
    which at that time came from Bell Laboratories. Most Unix-based machines had 16-bit
    addresses spaces: at that time the PDP-11 was the major Unix machine, with the
    Data General 8/32 and the VAX-11/780 just appearing. Threads didn''t exist—in
    fact, the concept of dynamic processes was still fairly new (Unix had them, but
    "serious" systems such as IBM''s OS/360 did not). File locking was not supported
    in the Unix kernel (but tricks were possible using filesystem links).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当时的环境与今天存在的环境非常不同。计算机高度异构，甚至没有完全一致使用 8 位字节的协议。例如，其他机器包括 PDP-10（36 位字，9 位字节），PDP-11（16
    位字，8 位字节），CDC 6000 系列（60 位字，6 位字符），IBM 360（32 位字，8 位字节），XDS 940，ICL 470 和 Sigma
    7。 Unix 是一个崭露头角的平台之一，当时来自贝尔实验室。大多数基于 Unix 的机器具有 16 位地址空间：当时 PDP-11 是主要的 Unix 机器，Data
    General 8/32 和 VAX-11/780 刚刚出现。线程根本不存在——事实上，动态进程的概念仍然相当新（Unix 有这些，但是“严肃”的系统，如
    IBM 的 OS/360 并没有）。Unix 内核不支持文件锁定（但是可以使用文件系统链接进行技巧处理）。
- en: To the extent they existed at all, networks were generally low speed (many based
    on 9600-baud TTY lines; the truly rich might have had Ethernet available, but
    for local use only). The venerable socket interface wasn't going to be invented
    for many years. Public key encryption hadn't been invented either, so most network
    security as we know it today wasn't feasible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，网络通常是低速的（许多基于 9600 波特的 TTY 线路；真正富裕的人可能已经有了以太网，但仅用于本地使用）。可敬的套接字接口还要多年才会被发明。公钥加密也还没有被发明，因此今天我们所知道的大多数网络安全措施都是不可行的。
- en: Network email already existed on Unix, but it was created using hacks. The primary
    user agent at the time was the `/bin/mail` command (today sometimes referred to
    as `binmail` or `v7mail`), but some sites had other user agents such as `Mail`
    from Berkeley, which actually understood how to treat messages as individual items
    rather than being a glorified `cat` program. Every user agent read (and usually
    wrote!) `/usr/spool/mail` directly; there was no abstraction for how the messages
    were actually stored.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 上已经存在网络电子邮件，但是它是使用 hack 创建的。当时的主要用户代理是 `/bin/mail` 命令（今天有时称为 `binmail`
    或 `v7mail`），但是一些站点具有其他用户代理，如伯克利的 `Mail`，它实际上知道如何将消息视为单独的项目，而不是作为一个光荣的 `cat` 程序。每个用户代理直接读取（通常是写入！）`/usr/spool/mail`；实际上没有关于消息实际存储方式的抽象化。
- en: The logic to route a message to the network versus local e-mail was nothing
    more than seeing if the address contained an exclamation point (UUCP) or a colon
    (BerkNET). People with Arpanet access had to use a completely separate mail program,
    which would not interoperate with other networks, and which even stored local
    mail in a different place and in a different format.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息路由到网络与本地电子邮件之间的逻辑仅仅是查看地址是否包含感叹号（UUCP）或冒号（BerkNET）。具有 Arpanet 访问权限的人必须使用完全独立的邮件程序，该程序无法与其他网络进行互操作，甚至将本地邮件存储在不同的位置和不同的格式中。
- en: To make things even more interesting, there was virtually no standardization
    on the format of the messages themselves. There was general agreement that there
    would be a block of header fields at the top of the message, that each header
    field would be on a new line, and that header field names and values would be
    separated by a colon. Beyond that, there was very little standardization in either
    the selection of header field names or the syntaxes of individual fields. For
    example, some systems used `Subj:` instead of `Subject:`, `Date:` fields were
    different syntaxes, and some systems didn't understand full names in a `From:`
    field. On top of all of this, what was documented was often ambiguous or not quite
    what was actually in use. In particular, RFC 733 (which purported to describe
    the format of Arpanet messages) was different from what was actually used in subtle
    but sometimes important ways, and the method of actually transmitting messages
    was not officially documented at all (although several RFCs made reference to
    the mechanism, none defined it). The result was that there was somewhat of a priesthood
    around messaging systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，几乎没有关于消息本身格式的标准化。大家普遍同意消息顶部将有一块头部字段，每个头部字段将位于新的一行上，并且头部字段名称和值之间将用冒号分隔。除此之外，头部字段名称的选择和各个字段的语法几乎没有标准化。例如，一些系统使用`Subj:`而不是`Subject:`，`Date:`字段有不同的语法，一些系统不理解`From:`字段中的全名。除此之外，所记录的内容常常是模糊的或者与实际使用不太一致。特别是，RFC
    733（声称描述了Arpanet消息的格式）与实际使用的方式略有不同，有时甚至有重要的差异，而消息传输的实际方法根本没有正式记录（尽管有几个RFC提到了这种机制，但没有一个定义了它）。结果导致消息系统周围形成了一种神秘的氛围。
- en: In 1979, the INGRES Relational Database Management Project (a.k.a. my day job)
    got a DARPA grant, and with it a 9600bps Arpanet connection to our PDP-11. At
    the time it was the only Arpanet connection available in the Computer Science
    Division, so everyone wanted access to our machine so they could get to the Arpanet.
    However, that machine was already maxed out, and so we could only make two login
    ports available for everyone in the department to share. This caused substantial
    contention and frequent conflicts. However, I noticed that what people wanted
    most of all was not remote login or file transfer, but e-mail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 1979年，INGRES关系数据库管理项目（即我的日常工作）获得了DARPA的资助，随之而来的是我们的PDP-11连接到Arpanet的9600bps速度的网络。当时，这是计算机科学部唯一的Arpanet连接，因此每个人都想访问我们的机器，以便访问Arpanet。然而，那台机器已经达到了最大限度，所以我们只能提供两个登录端口供部门内的所有人共享。这引起了相当大的竞争和频繁的冲突。然而，我注意到人们最想要的不是远程登录或文件传输，而是电子邮件。
- en: Into this, sendmail (initially called delivermail) emerged as an attempt to
    unify the chaos into one place. Every MUA (mail user agent, or mail client) would
    just call delivermail to deliver email rather than figuring out how to do it on
    an ad hoc (and often incompatible) basis. Delivermail/sendmail made no attempt
    to dictate how local mail should be stored or delivered; it did absolutely nothing
    except shuffle mail between other programs. (This changed when SMTP was added,
    as we'll see shortly.) In some sense it was just glue to hold the various mail
    systems together rather than being a mail system in its own right.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，sendmail（最初称为delivermail）成为统一混乱的尝试。每个MUA（邮件用户代理程序，或邮件客户端）只需调用delivermail来传递邮件，而不是想出如何以临时（而且通常是不兼容的）的方式进行操作。Delivermail/sendmail并没有试图规定本地邮件应该如何存储或传递；它绝对没有做任何事情，只是在其他程序之间传递邮件。（当SMTP被添加时，情况发生了变化，我们很快就会看到。）在某种意义上，它只是将各种邮件系统粘在一起的胶水，而不是一个独立的邮件系统。
- en: During the development of sendmail the Arpanet was transformed into the Internet.
    The changes were extensive, from the low level packets on the wire up through
    application protocols, and did not happen instantly. Sendmail was literally developed
    concurrently with the standards, and in some cases influenced them. It's also
    notable that sendmail has survived and even thrived as "the network" (as we think
    of it today) scaled from a few hundred hosts to hundreds of millions of hosts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在sendmail的开发过程中，阿帕网转变为互联网。这些变化是广泛的，从低层次的网络数据包到应用层协议，而且并非一蹴而就。Sendmail与标准同时发展，甚至在某些情况下影响了它们。值得注意的是，sendmail在“网络”（就我们今天所理解的意义而言）从几百个主机扩展到数亿个主机的过程中存活下来，甚至繁荣起来。
- en: Another Network
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个网络
- en: It's worth mentioning that another completely separate mail standard was proposed
    at the time called X.400, which was a part of ISO/OSI (International Standards
    Organization/Open Systems Interconnect). X.400 was a binary protocol, with the
    message encoded using ASN.1 (Abstract Syntax Notation 1), which is still in use
    in some Internet protocols today such as LDAP. LDAP was in turn a simplification
    of X.500, which was the directory service used by X.400\. Sendmail made no attempt
    whatsoever to be directly compatible with X.400, although there were some gateway
    services extant at the time. Although X.400 was initially adopted by many of the
    commercial vendors at the time, Internet mail and SMTP ended up winning in the
    marketplace.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在当时还提出了另一个完全独立的邮件标准，名为 X.400，它是 ISO/OSI（国际标准化组织/开放系统互连）的一部分。X.400 是一种二进制协议，消息使用
    ASN.1（抽象语法表示法 1）进行编码，该协议在今天的一些互联网协议中仍在使用，如 LDAP。LDAP 又是 X.500 的简化版本，X.500 是 X.400
    使用的目录服务。Sendmail 并没有试图直接与 X.400 兼容，尽管当时已经存在一些网关服务。尽管当时 X.400 最初被许多商业供应商采用，但是 Internet
    邮件和 SMTP 最终在市场上获胜。
- en: 17.2\. Design Principles
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2\. 设计原则
- en: 'While developing sendmail, I adhered to several design principles. All of these
    in some sense came down to one thing: do as little as possible. This is in sharp
    contrast to some of the other efforts of the time that had much broader goals
    and required much larger implementations.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 sendmail 时，我遵循了几项设计原则。所有这些原则在某种程度上都归结为一件事：尽量做得少。这与当时一些具有更广泛目标并需要更大实现的努力形成了鲜明对比。
- en: 17.2.1\. Accept that One Programmer Is Finite
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.1\. 接受一个程序员的有限性
- en: I wrote sendmail as a part-time, unpaid project. It was intended to be a quick
    way of making Arpanet mail more accessible to people at U.C. Berkeley. The key
    was to forward mail between existing networks, all of which were implemented as
    standalone programs that were unaware that more than one network even existed.
    Modifying more than a tiny amount of the existing software was infeasible with
    only one part-time programmer. The design had to minimize the amount of existing
    code that needed to be modified as well as the amount of new code that needed
    to be written. This constraint drove most of the rest of the design principles.
    As it turned out, in most cases they would have been the right thing to do even
    if there had been a larger team available.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我以兼职、无报酬的形式编写了 sendmail 项目。这是为了让 Arpanet 邮件更易于被加州大学伯克利分校的人们所接触。关键在于在现有网络之间转发邮件，所有这些网络都是作为独立程序实现的，它们甚至不知道存在多个网络。只有一位兼职程序员，修改现有软件的大部分内容是不可行的。设计必须将需要修改的现有代码量以及需要编写的新代码量降到最低。这一约束驱动了大部分其他设计原则。事实证明，在大多数情况下，即使有更大的团队可用，它们也应该是正确的做法。
- en: 17.2.2\. Don't Redesign User Agents
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.2\. 不要重新设计用户代理
- en: 'A Mail User Agent (MUA) is what most end users think of as the "mail system"—it''s
    the program that they use to read, write, and answer mail. It is quite distinct
    from the Mail Transfer Agent (MTA), which routes email from the sender to the
    receiver. At the time sendmail was written, many implementations at least partly
    combined these two functions, so they were often developed in tandem. Trying to
    work on both at the same time would have been too much, so Sendmail completely
    punted on the user interface problem: the only changes to MUAs were to have them
    invoke sendmail instead of doing their own routing. In particular, there were
    already several user agents, and people were often quite emotional about how they
    interacted with mail. Trying to work on both at the same time would have been
    too much. This separation of the MUA from the MTA is accepted wisdom now, but
    was far from standard practice at the time.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件用户代理（MUA）是大多数最终用户认为的“邮件系统”——这是他们用来阅读、写作和回复邮件的程序。它与邮件传输代理（MTA）完全不同，后者将电子邮件从发送方路由到接收方。在编写
    sendmail 时，许多实现至少部分地结合了这两个功能，因此它们经常是一起开发的。尝试同时处理两者将会太过繁琐，因此 Sendmail 完全忽略了用户界面的问题：对
    MUA 的唯一更改是让它们调用 sendmail 而不是进行自己的路由。特别是，已经有几个用户代理，人们对其如何与邮件交互通常非常情绪化。尝试同时处理两者将会太过繁琐。现在将
    MUA 与 MTA 分离开来是被广泛接受的智慧，但在当时远非标准做法。
- en: 17.2.3\. Don't Redesign the Local Mail Store
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.3\. 不要重新设计本地邮件存储
- en: The local mail store (where messages would be saved until the recipient came
    along to read them) was not formally standardized. Some sites liked to store them
    in a centralized place, such as `/usr/mail`, `/var/mail`, or `/var/spool/mail`.
    Other sites liked to store them in the recipient's home directory (e.g., as a
    file called `.mail`). Most sites started each message with a line beginning "From"
    followed by a space character (an extraordinarily bad decision, but that was the
    convention at the time), but sites that were Arpanet-focused usually stored messages
    separated by a line containing four control-A characters. Some sites attempted
    to lock the mailbox to prevent collisions, but they used different locking conventions
    (file locking primitives were not yet available). In short, the only reasonable
    thing to do was treat local mail storage as a black box.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本地邮箱存储（消息将保存在其中，直到收件人来读取它们）并没有正式标准化。一些站点喜欢将它们存储在一个集中的地方，例如 `/usr/mail`、`/var/mail`
    或 `/var/spool/mail`。其他站点喜欢将它们存储在收件人的主目录中（例如，作为一个名为 `.mail` 的文件）。大多数站点以一个以 "From"
    开头的行开始每个消息，后面跟着一个空格字符（这是一个非常糟糕的决定，但那时是约定俗成的），但是关注 Arpanet 的站点通常将消息分开存储，中间用包含四个控制字符
    A 的行分隔。一些站点尝试锁定邮箱以防止冲突，但它们使用不同的锁定约定（文件锁定原语尚不可用）。简而言之，唯一合理的做法是将本地邮箱存储视为一个黑盒子。
- en: On nearly all sites, the actual mechanism for doing local mailbox storage was
    embodied in the `/bin/mail` program. This had a (quite primitive) user interface,
    routing, and storage built into one program. To incorporate sendmail, the routing
    portion was pulled out and replaced with a call to sendmail. A `-d` flag was added
    to force final delivery, i.e., it prevented `/bin/mail` from calling sendmail
    to do the routing. In later years the code used to deliver a message to a physical
    mailbox was extracted into another program called `mail.local`. The `/bin/mail`
    program exists today only to include a lowest common denominator for scripts to
    send mail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有站点上，执行本地邮箱存储的实际机制都体现在 `/bin/mail` 程序中。这个程序有一个（非常原始的）用户界面、路由和存储都内建到一个程序中。为了合并
    sendmail，路由部分被分离出来，并替换为对 sendmail 的调用。添加了一个 `-d` 标志以强制最终投递，即防止 `/bin/mail` 调用
    sendmail 进行路由。后来，将将消息传递到物理邮箱的代码提取到另一个名为 `mail.local` 的程序中。今天，`/bin/mail` 程序仅用于包含脚本发送邮件的最低公共分母。
- en: 17.2.4\. Make Sendmail Adapt to the World, Not the Other Way Around
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.4\. 使 Sendmail 适应世界，而不是相反
- en: Protocols such as UUCP and BerkNET were already implemented as separate programs
    that had their own, sometimes quirky, command line structure. In some cases they
    were being actively developed at the same time as sendmail. It was clear that
    reimplementing them (for example, to convert them to standard calling conventions)
    was going to be painful. This led directly to the principle that sendmail should
    adapt to the rest of the world rather than trying to make the rest of the world
    adapt to sendmail.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 UUCP 和 BerkNET 的协议已经作为独立的程序实现，它们有自己的，有时候很古怪的命令行结构。在某些情况下，它们与 sendmail 一起被积极开发。很明显，重新实现它们（例如将它们转换为标准调用约定）将是痛苦的。这直接导致了一个原则，即
    sendmail 应该适应世界其他部分，而不是试图让世界其他部分适应 sendmail。
- en: 17.2.5\. Change as Little as Possible
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.5\. 尽可能改动少
- en: To the fullest extent possible, during the development of sendmail I didn't
    touch anything I didn't absolutely have to touch. Besides just not having enough
    time to do it, there was a culture at Berkeley at the time that eschewed most
    formal code ownership in favor of a policy of "the last person who touched the
    code is the go-to person for that program" (or more simply, "you touch it, you
    own it"). Although that sounds chaotic by most modern-day standards, it worked
    quite well in a world where no one at Berkeley was assigned full time to work
    on Unix; individuals worked on parts of the system that they were interested in
    and committed to and didn't touch the rest of the code base except in dire circumstances.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 sendmail 的开发过程中，我尽可能地不去触碰我绝对不必触碰的东西。除了没有足够的时间来做，当时在伯克利有一种文化，它避免了大多数正式的代码所有权，而更倾向于一个政策，“最后一个接触代码的人就是该程序的负责人”（或者更简单地说，“你触碰它，你就拥有它”）。尽管在现代标准下，这听起来混乱，但在伯克利，没有人被全职分配到
    Unix 工作；个人工作在他们感兴趣并致力于的系统的部分，并且除非在紧急情况下，否则不接触代码库的其余部分。
- en: 17.2.6\. Think About Reliability Early
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.6\. 提早考虑可靠性
- en: The mail system prior to sendmail (including most of the transport systems)
    wasn't terribly concerned about reliability. For example, versions of Unix prior
    to 4.2BSD did not have native file locking, although it could be simulated by
    creating a temporary file and then linking it to a lock file (if the lock file
    already existed the link call would fail). However, sometimes different programs
    writing the same data file wouldn't agree on how the locking should be done (for
    example, they might use a different lock file name or even make no attempt to
    do locking at all), and so it wasn't that uncommon to lose mail. Sendmail took
    the approach that losing mail wasn't an option (possibly a result of my background
    as a database guy, where losing data is a mortal sin).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 sendmail 出现之前的邮件系统（包括大多数传输系统）并不特别关心可靠性。例如，Unix 4.2BSD 之前的版本没有原生文件锁定功能，尽管可以通过创建临时文件然后将其链接到锁定文件来模拟（如果锁定文件已经存在，则链接调用将失败）。然而，有时候不同的程序写入相同的数据文件时无法就如何进行锁定达成一致（例如，它们可能使用不同的锁定文件名称，甚至根本不尝试进行锁定），因此丢失邮件并不罕见。sendmail
    的方法是认为丢失邮件不是一个选择（可能是因为我的背景是数据库人员，数据丢失是致命的罪行）。
- en: 17.2.7\. What Was Left Out
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.7\. **被遗漏的部分**
- en: 'There were many things that were not done in the early versions. I did not
    try to re-architect the mail system or build a completely general solution: functionality
    could be added as the need arose. Very early versions were not even intended to
    be completely configurable without access to the source code and a compiler (although
    this changed fairly early on). In general, the modus operandi for sendmail was
    to get something working quickly and then enhance working code as needed and as
    the problem was better understood.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本中有许多未完成的事情。我没有尝试重新设计邮件系统或构建完全通用的解决方案：功能可以根据需要添加。非常早期的版本甚至没有打算在没有访问源代码和编译器的情况下完全可配置（尽管这在相当早的时候就改变了）。通常，sendmail
    的操作方式是快速让某些东西工作，然后根据需要和更好地理解问题来增强工作代码。
- en: 17.3\. Development Phases
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.3\. 开发阶段
- en: Like most long-lived software, sendmail was developed in phases, each with its
    own basic theme and feeling.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数存在很长时间的软件一样，sendmail 是分阶段开发的，每个阶段都有其自己的基本主题和感觉。
- en: '17.3.1\. Wave 1: delivermail'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3.1\. 第一阶段：delivermail
- en: 'The first instantiation of sendmail was known as delivermail. It was extremely
    simple, if not simplistic. Its sole job was to forward mail from one program to
    another; in particular, it had no SMTP support, and so never made any direct network
    connections. No queuing was necessary because each network already had its own
    queue, so the program was really just a crossbar switch. Since delivermail had
    no direct network protocol support, there was no reason for it to run as a daemon—it
    would be invoked to route each message as it was submitted, pass it to the appropriate
    program that would implement the next hop, and terminate. Also, there was no attempt
    to rewrite headers to match the network to which a message was being delivered.
    This commonly resulted in messages being forwarded that could not be replied to.
    The situation was so bad that an entire book was written about addressing mail
    (called, fittingly, *!%@:: A Directory of Electronic Mail Addressing & Networks*
    [[AF94](bib1.html#bib:adams:email)]).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'sendmail 的第一个实例被称为 delivermail。它非常简单，甚至可以说过于简单了。它的唯一工作是将邮件从一个程序转发到另一个程序；特别是，它没有
    SMTP 支持，因此从未直接建立任何网络连接。不需要排队，因为每个网络已经有了自己的队列，所以该程序实际上只是一个交换机。由于 delivermail 没有直接的网络协议支持，因此没有理由将其作为守护进程运行——每次提交消息时都会调用它进行路由，将其传递给实现下一跳的适当程序，然后终止。此外，也没有尝试重写标头以匹配将消息传递到的网络。这通常会导致转发无法回复的消息。情况如此糟糕以至于有一整本书是关于邮件地址的（适当地称为
    *!%@:: 电子邮件地址和网络的目录* [[AF94](bib1.html#bib:adams:email)]）。'
- en: 'All configuration in delivermail was compiled in and was based only on special
    characters in each address. The characters had precedence. For example, a host
    configuration might search for an "@" sign and, if one was found, send the entire
    address to a designated Arpanet relay host. Otherwise, it might search for a colon,
    and send the message to BerkNET with the designated host and user if it found
    one, then could check for an exclamation point ("!") signalling that the message
    should be forwarded to a designated UUCP relay. Otherwise it would attempt local
    delivery. This configuration might result in the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 delivermail 中，所有配置都是编译进去的，并且仅基于每个地址中的特殊字符。这些字符具有优先级。例如，主机配置可能会搜索“@”符号，并且如果找到一个，就会将整个地址发送到指定的
    Arpanet 中继主机。否则，它可能会搜索冒号，并且如果找到一个，就会将消息发送到指定的主机和用户的 BerkNET，然后可以检查感叹号（“!”）标志着消息应转发到指定的
    UUCP 中继。否则，它将尝试本地投递。此配置可能导致以下结果：
- en: '| Input | Sent To {net, host, user} |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 发送至 {net, host, user} |'
- en: '| foo@bar | {Arpanet, bar, foo} |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| foo@bar | {Arpanet, bar, foo} |'
- en: '| foo:bar | {Berknet, foo, bar} |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| foo:bar | {Berknet, foo, bar} |'
- en: '| foo!bar!baz | {Uucp, foo, bar!baz} |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| foo!bar!baz | {Uucp, foo, bar!baz} |'
- en: '| foo!bar@baz | {Arpanet, baz, foo!bar} |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| foo!bar@baz | {Arpanet, baz, foo!bar} |'
- en: Note that address delimiters differed in their associativity, resulting in ambiguities
    that could only be resolved using heuristics. For example, the last example might
    reasonably be parsed as {Uucp, foo, bar@baz} at another site.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意地址分隔符在其关联性上有所不同，导致只能通过启发式方法解决的歧义。例如，在另一个站点上，最后一个示例可能被合理地解析为 {Uucp, foo, bar@baz}。
- en: 'The configuration was compiled in for several reasons: first, with a 16 bit
    address space and limited memory, parsing a runtime configuration was too expensive.
    Second, the systems of the time had been so highly customized that recompiling
    was a good idea, just to make sure you had the local versions of the libraries
    (shared libraries did not exist with Unix 6th Edition).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 几个原因导致配置被编译进去：首先，使用 16 位地址空间和有限内存，解析运行时配置的成本太高。其次，当时的系统已经被高度定制，重新编译是个好主意，只是为了确保你拥有本地版本的库（Unix
    第 6 版没有共享库）。
- en: Delivermail was distributed with 4.0 and 4.1 BSD and was more successful than
    expected; Berkeley was far from the only site with hybrid network architectures.
    It became clear that more work was required.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Delivermail 随 4.0 和 4.1 BSD 发行，并且比预期更成功；伯克利远非唯一一个采用混合网络架构的站点。很明显，需要更多的工作。
- en: '17.3.2\. Wave 2: sendmail 3, 4, and 5'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '17.3.2\. Wave 2: sendmail 3, 4, 和 5'
- en: Versions 1 and 2 were distributed under the delivermail name. In March 1981
    work began on version 3, which would be distributed under the sendmail name. At
    this point the 16-bit PDP-11 was still in common use but the 32-bit VAX-11 was
    becoming popular, so many of the original constraints associated with small address
    spaces were starting to be relaxed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1 和 2 是以 delivermail 名义发布的。 1981 年 3 月开始制作版本 3，该版本将以 sendmail 名义发布。此时，16
    位的 PDP-11 仍然在普遍使用中，但 32 位的 VAX-11 开始流行，因此许多与小地址空间相关的原始限制开始得到放宽。
- en: The initial goals of sendmail were to convert to runtime configuration, allow
    message modification to provide compatibility across networks for forwarded mail,
    and have a richer language on which to make routing decisions. The technique used
    was essentially textual rewriting of addresses (based on tokens rather than character
    strings), a mechanism used in some expert systems at the time. There was ad hoc
    code to extract and save any comment strings (in parentheses) as well as to re-insert
    them after the programmatic rewriting completed. It was also important to be able
    to add or augment header fields (e.g., adding a `Date` header field or including
    the full name of the sender in the `From` header if it was known).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: sendmail 的初始目标是转换为运行时配置，允许修改消息以在转发邮件时提供网络间的兼容性，并具有更丰富的语言来做出路由决策。使用的技术本质上是地址的文本重写（基于标记而不是字符串），这是当时一些专家系统中使用的机制。还有专门的代码来提取和保存任何注释字符串（在括号内），以及在程序化重写完成后重新插入它们。还很重要的是能够添加或增强标头字段（例如，在已知发送者的情况下，添加“日期”标头字段或在“发件人”标头中包含发送者的全名）。
- en: SMTP development started in November 1981. The Computer Science Research Group
    (CSRG) at U.C. Berkeley had gotten the DARPA contract to produce a Unix-based
    platform to support DARPA funded research, with the intent of making sharing between
    projects easier. The initial work on the TCP/IP stack was done by that time, although
    the details of the socket interface were still changing. Basic application protocols
    such as Telnet and FTP were done, but SMTP had yet to be implemented. In fact,
    the SMTP protocol wasn't even finalized at that point; there had been a huge debate
    about how mail should be sent using a protocol to be creatively named Mail Transfer
    Protocol (MTP). As the debate raged, MTP got more and more complex until in frustration
    SMTP (Simple Mail Transfer Protocol) was drafted more-or-less by fiat (but not
    officially published until August 1982). Officially, I was working on the INGRES
    Relational Database Management System, but since I knew more about the mail system
    than anyone else around Berkeley at the time, I got talked into implementing SMTP.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP 开发始于1981年11月。加州大学伯克利分校的计算机科学研究小组（CSRG）获得了DARPA的合同，制造了一个基于Unix的平台来支持DARPA资助的研究，旨在使项目之间的共享更加容易。在那个时候，TCP/IP堆栈的初始工作已经完成，尽管套接字接口的细节仍在变化。基本的应用程序协议，如Telnet和FTP已经完成，但SMTP尚未实现。实际上，SMTP协议在那时甚至还没有最终确定；关于如何使用一个被创造性地命名为邮件传输协议（MTP）发送邮件的巨大辩论正在进行中。随着辩论的激烈，MTP变得越来越复杂，直到在沮丧中几乎是通过命令（但直到1982年8月才正式发布）起草了SMTP（简单邮件传输协议）。正式地说，我当时正在开发
    INGRES 关系数据库管理系统，但由于我比当时伯克利周围的任何人都更了解邮件系统，所以我被说服实现SMTP。
- en: My initial thought was to create a separate SMTP mailer that would have its
    own queueing and daemon; that subsystem would attach to sendmail to do the routing.
    However, several features of SMTP made this problematic. For example, the `EXPN`
    and `VRFY` commands required access to the parsing, aliasing, and local address
    verification modules. Also, at the time I thought it was important that the `RCPT`
    command return immediately if the address was unknown, rather than accepting the
    message and then having to send a delivery failure message later. This turns out
    to have been a prescient decision. Ironically, later MTAs often got this wrong,
    exacerbating the spam backscatter problem. These issues drove the decision to
    include SMTP as part of sendmail itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初的想法是创建一个独立的SMTP邮件程序，它将具有自己的排队和守护进程；该子系统将附加到sendmail以执行路由。但是，SMTP的几个特性使这个问题复杂化。例如，`EXPN`和`VRFY`命令需要访问解析，别名和本地地址验证模块。而且，当时我认为如果地址未知，`RCPT`命令应立即返回，而不是接受消息，然后稍后发送传递失败消息，这被证明是一个有远见的决定。具有讽刺意味的是，后来的MTA经常做错了这个，加剧了垃圾邮件回溯问题。这些问题促使将SMTP作为sendmail的一部分包含在内。
- en: Sendmail 3 was distributed with 4.1a and 4.1c BSD (beta versions), sendmail
    4 was distributed with 4.2 BSD, and sendmail 5 was distributed with 4.3 BSD.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Sendmail 3与4.1a和4.1c BSD（测试版本）一起分发，sendmail 4与4.2 BSD一起分发，sendmail 5与4.3 BSD一起分发。
- en: '17.3.3\. Wave 3: The Chaos Years'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3.3\. 第三阶段：混乱年代
- en: After I left Berkeley and went to a startup company, my time available to work
    on sendmail rapidly decreased. But the Internet was starting to seriously explode
    and sendmail was being used in a variety of new (and larger) environments. Most
    of the Unix system vendors (Sun, DEC, and IBM in particular) created their own
    versions of sendmail, all of which were mutually incompatible. There were also
    attempts to build open source versions, notably IDA sendmail and KJS.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 离开伯克利去一家创业公司后，我用于工作在sendmail上的时间迅速减少。但是互联网开始严重膨胀，sendmail被用于各种新（和更大）的环境中。大多数Unix系统供应商（特别是Sun，DEC和IBM）创建了他们自己的sendmail版本，所有这些版本都是相互不兼容的。也有尝试构建开源版本，特别是IDA
    sendmail和KJS。
- en: IDA sendmail came from Linköping University. IDA included extensions to make
    it easier to install and manage in larger environments and a completely new configuration
    system. One of the major new features was the inclusion of dbm(3) database maps
    to support highly dynamic sites. These were available using a new syntax in the
    configuration file and were used for many functions including mapping of addresses
    to and from external syntax (for example, sending out mail as john_doe@example.com
    instead of johnd@example.com) and routing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: IDA sendmail 来自 Linköping University。IDA 包含扩展，使其更容易在较大环境中安装和管理，以及全新的配置系统。主要的新功能之一是包含了
    dbm(3) 数据库映射，以支持高度动态的站点。这些可通过配置文件中的新语法使用，并且用于许多功能，包括将地址映射到和从外部语法（例如，将邮件发送为 john_doe@example.com
    而不是 johnd@example.com）和路由。
- en: King James Sendmail (KJS, produced by Paul Vixie) was an attempt to unify all
    the various versions of sendmail that had sprung up. Unfortunately, it never really
    got enough traction to have the desired effect. This era was also driven by a
    plethora of new technologies that were reflected in the mail system. For example,
    Sun's creation of diskless clusters added the YP (later NIS) directory services
    and NFS, the Network File System. In particular, YP had to be visible to sendmail,
    since aliases were stored in YP rather than in local files.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: King James Sendmail（KJS，由Paul Vixie制作）是统一各种不同版本的sendmail的尝试。不幸的是，它从未真正获得足够的动力来产生预期的效果。这个时代也受到了大量新技术的推动，这些技术反映在邮件系统中。例如，Sun创建了无盘集群，增加了YP（后来的NIS）目录服务和NFS，即网络文件系统。特别是，YP必须对sendmail可见，因为别名存储在YP中而不是本地文件中。
- en: '17.3.4\. Wave 4: sendmail 8'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3.4\. 第四波：sendmail 8
- en: After several years, I returned to Berkeley as a staff member. My job was to
    manage a group installing and supporting shared infrastructure for research around
    the Computer Science department. For that to succeed, the largely ad hoc environments
    of individual research groups had to be unified in some rational way. Much like
    the early days of the Internet, different research groups were running on radically
    different platforms, some of which were quite old. In general, every research
    group ran its own systems, and although some of them were well managed, most of
    them suffered from "deferred maintenance."
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，我作为一名员工回到了伯克利。我的工作是管理一个为计算机科学系周围的研究安装和支持共享基础设施的团队。为了成功，必须以某种合理的方式统一个别研究小组的大部分临时环境。就像互联网的早期一样，不同的研究小组运行在完全不同的平台上，其中一些相当古老。总的来说，每个研究小组都在运行自己的系统，虽然其中一些被很好地管理了，但大多数都遭受了“推迟维护”的困扰。
- en: In most cases email was similarly fractured. Each person's email address was
    "`person@host.berkeley.edu`", where `host` was the name of the workstation in
    their office or the shared server they used (the campus didn't even have internal
    subdomains) with the exception of a few special people who had `@berkeley.edu`
    addresses. The goal was to switch to internal subdomains (so all individual hosts
    would be in the `cs.berkeley.edu` subdomain) and have a unified mail system (so
    each person would have an `@cs.berkeley.edu` address). This goal was most easily
    realized by creating a new version of sendmail that could be used throughout the
    department.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，电子邮件也同样支离破碎。每个人的电子邮件地址都是“`person@host.berkeley.edu`”，其中 `host` 是他们办公室工作站或共享服务器的名称（校园甚至没有内部子域），只有少数特殊人员有
    `@berkeley.edu` 地址。目标是切换到内部子域（使所有个人主机都在 `cs.berkeley.edu` 子域中）并拥有统一的邮件系统（这样每个人都会有一个
    `@cs.berkeley.edu` 地址）。这个目标最容易实现的方式是创建一个新版本的 sendmail，可以在整个部门使用。
- en: I began by studying many of the variants of sendmail that had become popular.
    My intent was not to start from a different code base but rather to understand
    the functionality that others had found useful. Many of those ideas found their
    way into sendmail 8, often with modifications to merge related ideas or make them
    more generic. For example, several versions of sendmail had the ability to access
    external databases such as dbm(3) or NIS; sendmail 8 merged these into one "map"
    mechanism that could handle multiple types of databases (and even arbitrary non-database
    transformations). Similarly, the "generics" database (internal to external name
    mapping) from IDA sendmail was incorporated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始研究许多成为流行的sendmail变种。我的意图不是从不同的代码库开始，而是了解其他人发现有用的功能。这些想法中的许多都进入了sendmail 8，通常以修改的方式合并相关的想法或使它们更通用。例如，几个版本的sendmail都具有访问外部数据库（如dbm(3)或NIS）的能力；sendmail
    8将这些合并为一个可以处理多种类型的数据库（甚至是任意非数据库转换）的“映射”机制。类似地，IDA sendmail的“通用”数据库（内部到外部名称映射）也被合并进来。
- en: Sendmail 8 also included a new configuration package using the m4(1) macro processor.
    This was intended to be more declarative than the sendmail 5 configuration package,
    which had been largely procedural. That is, the sendmail 5 configuration package
    required the administrator to essentially lay out the entire configuration file
    by hand, really only using the "include" facility from m4 as shorthand. The sendmail
    8 configuration file allowed the administrator to just declare what features,
    mailers, and so on were required, and m4 laid out the final configuration file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Sendmail 8 还包括一个使用m4(1)宏处理器的新配置包。这意味着相较于sendmail 5配置包而言，sendmail 8配置包更加声明性，后者基本上是以过程化方式构建的。也就是说，sendmail
    5配置包要求管理员基本上手工布置整个配置文件，而实际上只使用了m4的“include”设施作为速记。而sendmail 8配置文件允许管理员只声明所需的功能、邮件发送程序等，然后m4会布置出最终的配置文件。
- en: Much of [Section 17.7](#sec.sendmail.evo) discusses the enhancements in sendmail
    8.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17.7节](#sec.sendmail.evo) 的大部分内容讨论了sendmail 8 的增强功能。'
- en: '17.3.5\. Wave 5: The Commercial Years'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3.5\. Wave 5：商业年代
- en: As the Internet grew and the number of sendmail sites expanded, support for
    the ever larger user base became more problematic. For a while I was able to continue
    support by setting up a group of volunteers (informally called the "Sendmail Consortium",
    a.k.a. sendmail.org) who provided free support via e-mail and newsgroup. But by
    the late 1990s, the installed base had grown to such an extent that it was nearly
    impossible to support it on a volunteer basis. Together with a more business-savvy
    friend I founded Sendmail, Inc., with the expectation of getting new resources
    to bear on the code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着互联网的发展和sendmail站点数量的增加，支持越来越庞大的用户群变得更加棘手。有一段时间，我能够通过成立一群志愿者（非正式地称为“Sendmail联盟”，又称sendmail.org）来继续提供免费的电子邮件和新闻组支持。但到了1990年代末，安装基数已经增长到几乎不可能以志愿者方式支持的程度。我和一个商业头脑更敏锐的朋友一起成立了Sendmail,
    Inc.，期望能够获得新的资源来改进代码。
- en: Although the commercial product was originally based largely on configuration
    and management tools, many new features were added to the open-source MTA to support
    the needs of the commercial world. Notably, the company added support for TLS
    (connection encryption), SMTP Authentication, site security enhancements such
    as Denial of Service protection, and most importantly mail filtering plugins (the
    Milter interface discussed below).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管商业产品最初主要基于配置和管理工具，但为了支持商业世界的需求，还添加了许多新功能到开源MTA中。值得注意的是，该公司增加了对TLS（连接加密）、SMTP身份验证、站点安全增强功能（如防止服务拒绝）以及最重要的邮件过滤插件（下面讨论的Milter接口）的支持。
- en: At of this writing the commercial product has expanded to include a large suite
    of e-mail based applications, nearly all of which are constructed on the extensions
    added to sendmail during the first few years of the company.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，商业产品已经扩展到包括大量基于电子邮件的应用程序，其中几乎所有的应用程序都是在公司创立的最初几年里添加到sendmail上的扩展上构建的。
- en: 17.3.6\. Whatever Happened to sendmail 6 and 7?
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3.6\. sendmail 6 和 7 发生了什么？
- en: Sendmail 6 was essentially the beta for sendmail 8\. It was never officially
    released, but was distributed fairly widely. Sendmail 7 never existed at all;
    sendmail jumped directly to version 8 because all the other source files for the
    BSD distribution were bumped to version 8 when 4.4 BSD was released in June 1993.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Sendmail 6 本质上是 sendmail 8 的测试版。它从未正式发布，但被相当广泛地分发。Sendmail 7 根本不存在；当1993年6月发布4.4
    BSD时，sendmail 直接跳到了版本8，因为所有其他BSD发行版的源文件都被提升到了版本8。
- en: 17.4\. Design Decisions
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.4\. 设计决策
- en: Some design decisions were right. Some started out right and became wrong as
    the world changed. Some were dubious and haven't become any less so.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设计决策是正确的。有些一开始是正确的，随着世界的变化而变得错误。有些是可疑的，而且现在也没有变得更少。
- en: 17.4.1\. The Syntax of the Configuration File
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.1\. 配置文件的语法
- en: The syntax of the configuration file was driven by a couple of issues. First,
    the entire application had to fit into a 16-bit address space, so the parser had
    to be small. Second, early configurations were quite short (under one page), so
    while the syntax was obscure, the file was still comprehensible. However, as time
    passed, more operational decisions moved out of the C code into the configuration
    file, and the file started to grow. The configuration file acquired a reputation
    for being arcane. One particular frustration for many people was the choice of
    the tab character as an active syntax item. This was a mistake that was copied
    from other systems of the time, notably `make`. That particular problem became
    more acute as window systems (and hence cut-and-paste, which usually did not preserve
    the tabs) became available.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件的语法受到几个问题的驱动。首先，整个应用程序必须适合16位地址空间，因此解析器必须很小。其次，早期配置非常简短（不到一页），因此虽然语法晦涩，但文件仍然可以理解。然而，随着时间的推移，越来越多的运行决策从C代码移出到配置文件中，文件开始增长。配置文件因晦涩而声名远扬。对许多人特别令人沮丧的是，选择制表符作为活动语法项。这是一个错误，是从当时的其他系统（特别是`make`）中复制过来的。随着窗口系统的出现（因此剪切和粘贴通常不保留制表符），这个特定的问题变得更加严重。
- en: In retrospect, as the file got larger and 32-bit machines took over, it would
    have made sense to reconsider the syntax. There was a time when I thought about
    doing this but decided against it because I didn't want to break the "large" installed
    base (which at that point was probably a few hundred machines). In retrospect
    this was a mistake; I had simply not appreciated how large the install base would
    grow and how many hours it would save me had I changed the syntax early. Also,
    when the standards stabilized a fair amount of the generality could have been
    pushed back into the C code base, thus simplifying the configurations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾过去，随着文件的不断增大和32位机的普及，重新考虑语法是有意义的。有一段时间我考虑过这样做，但最终决定不这么做，因为我不想破坏“庞大”的已安装基础（那时可能只有几百台机器）。回顾起来，这是一个错误；我简单地没有意识到安装基础会增长多么庞大，如果我早些时候改变了语法，将会为我节省多少时间。此外，当标准稳定下来时，部分通用性本可以被推回到C代码库中，从而简化配置。
- en: Of particular interest was how more functionality got moved into the configuration
    file. I was developing sendmail at the same time as the SMTP standard was evolving.
    By moving operational decisions into the configuration file I was able to respond
    rapidly to design changes—usually in under 24 hours. I believe that this improved
    the SMTP standard, since it was possible to get operational experience with a
    proposed design change quite quickly, but only at the cost of making the configuration
    file difficult to understand.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得注意的是，更多功能是如何移入配置文件的。我在SMTP标准发展的同时开发sendmail。通过将运行决策移到配置文件中，我能够在短短不到24小时内迅速响应设计变更。我相信这提高了SMTP标准，因为可以很快地获得对拟议设计变更的运行经验，但代价是使配置文件难以理解。
- en: 17.4.2\. Rewriting Rules
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.2\. 重写规则
- en: 'One of the difficult decisions when writing sendmail was how to do the necessary
    rewriting to allow forwarding between networks without violating the standards
    of the receiving network. The transformations required changing metacharacters
    (for example, BerkNET used colon as a separator, which was not legal in SMTP addresses),
    rearranging address components, adding or deleting components, etc. For example,
    the following rewrites would be needed under certain circumstances:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写sendmail时，其中一个困难的决定是如何进行必要的重写，以便在不违反接收网络的标准的情况下在网络之间进行转发。 所需的转换包括更改元字符（例如，BerkNET使用冒号作为分隔符，在SMTP地址中不合法），重新排列地址组件，添加或删除组件等。
    例如，在某些情况下需要进行以下重写：
- en: '| From | To |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 从 | 至 |'
- en: '| a:foo | a.foo@berkeley.edu |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| a:foo | a.foo@berkeley.edu |'
- en: '| a!b!c | b!c@a.uucp |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| a!b!c | b!c@a.uucp |'
- en: '| <@a.net,@b.org:user@c.com> | <@b.org:user@c.com> |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| <@a.net,@b.org:user@c.com> | <@b.org:user@c.com> |'
- en: Regular expressions were not a good choice because they didn't have good support
    for word boundaries, quoting, etc. It quickly became obvious that it would be
    nearly impossible to write regular expressions that were accurate, much less intelligible.
    In particular, regular expressions reserve a number of metacharacters, including
    ".", "*", "+", "{[}", and "{]}", all of which can appear in e-mail addresses.
    These could have been escaped in configuration files, but I deemed that to be
    complicated, confusing, and a bit ugly. (This was tried by UPAS from Bell Laboratories,
    the mailer for Unix Eighth Edition, but it never caught on.) Instead, a scanning
    phase was necessary to produce tokens that could then be manipulated much like
    characters in regular expressions. A single parameter describing "operator characters",
    which were themselves both tokens and token separators, was sufficient. Blank
    spaces separated tokens but were not tokens themselves. The rewriting rules were
    just pattern match/replace pairs organized into what were essentially subroutines.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式并不是一个好选择，因为它们不太好地支持单词边界、引用等。 很快就显而易见，几乎不可能编写准确的、更不用说可读的正则表达式。 特别是，正则表达式保留了许多元字符，包括“。”、“*”、“+”、“{[}”和“{]}”，这些字符都可以出现在电子邮件地址中。
    这些可以在配置文件中转义，但我认为那样会复杂、混乱，而且有点丑陋。（这是贝尔实验室的Unix第八版邮件程序UPAS尝试过的方法，但从未流行起来。）相反，扫描阶段是必要的，以产生可以像正则表达式中的字符一样操作的标记。
    一组描述“操作符字符”的单一参数足以。 空格分隔标记，但不是标记本身。 重写规则只是被组织成实质上是子程序的模式匹配/替换对。
- en: Instead of a large number of metacharacters that had to be escaped to lose their
    "magic" properties (as used in regular expressions), I used a single "escape"
    character that combined with ordinary characters to represent wildcard patterns
    (to match an arbitrary word, for example). The traditional Unix approach would
    be to use backslash, but backslash was already used as a quote character in some
    address syntaxes. As it turned out, "$" was one of the few characters that had
    not already been used as a punctuation character in some email syntax.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不再使用大量需要转义以失去其“magic”属性的元字符（如正则表达式中使用的元字符），而是使用一个与普通字符组合在一起表示通配符模式的“转义”字符（例如，匹配任意单词）。
    传统的Unix方法是使用反斜杠，但反斜杠已经在某些地址语法中用作引号字符。 结果，“$”是少数几个在某些电子邮件语法中还没有用作标点符号的字符之一。
- en: 'One of the original bad decisions was, ironically, just a matter of how white
    space was used. A space character was a separator, just as in most scanned input,
    and so could have been used freely between tokens in patterns. However, the original
    configuration files distributed did not include spaces, resulting in patterns
    that were far harder to understand than necessary. Consider the difference between
    the following two (semantically identical) patterns:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的错误决定之一其实讽刺地仅仅是空白符的使用方式。空格字符是分隔符，就像大多数扫描输入中一样，因此可以在模式中的标记之间自由使用。然而，最初分发的配置文件中没有包含空格，导致模式比必要的难以理解得多。考虑以下两个（在语义上相同的）模式之间的区别：
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 17.4.3\. Using Rewriting for Parsing
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.3\. 使用重写进行解析
- en: 'Some have suggested that sendmail should have used conventional grammar-based
    parsing techniques to parse addresses rather than rewriting rules and leave the
    rewriting rules for address modification. On the surface this would seem to make
    sense, given that the standards define addresses using a grammar. The main reason
    for reusing rewriting rules is that in some cases it was necessary to parse header
    field addresses (e.g., in order to extract the sender envelope from a header when
    receiving mail from a network that didn''t have a formal envelope). Such addresses
    aren''t easy to parse using (say) an LALR(1) parser such as YACC and a traditional
    scanner because of the amount of lookahead required. For example, parsing the
    address: `allman@foo.bar.baz.com <eric@example.com>` requires lookahead by either
    the scanner or the parser; you can''t know that the initial "allman@…" is not
    an address until you see the "<". Since LALR(1) parsers only have one token of
    lookahead this would have had to be done in the scanner, which would have complicated
    it substantially. Since the rewriting rules already had arbitrary backtracking
    (i.e., they could look ahead arbitrarily far), they were sufficient.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人建议 sendmail 应该使用传统的基于语法的解析技术来解析地址，而不是重写规则，并将重写规则保留用于地址修改。从表面上看，这似乎是有道理的，因为标准使用语法来定义地址。重用重写规则的主要原因是在某些情况下需要解析标题字段地址（例如，在从没有正式信封的网络接收邮件时从标题中提取发送者信封）。这样的地址不容易使用（比如说）LALR(1)
    解析器（如 YACC）和传统扫描器进行解析，因为需要大量的向前看。例如，解析地址：`allman@foo.bar.baz.com <eric@example.com>`
    需要扫描器或解析器进行向前看；在看到“<”之前，你不能知道初始的“allman@…”是否是一个地址。由于 LALR(1) 解析器只有一个标记的向前看，这必须在扫描器中完成，这会使其变得复杂。由于重写规则已经具有任意的回溯（即，它们可以向前看任意远），它们就足够了。
- en: A secondary reason was that it was relatively easy to make the patterns recognize
    and fix broken input. Finally, rewriting was more than powerful enough to do the
    job, and reusing any code was wise.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是，很容易使模式识别并修复损坏的输入。最后，重写功能足以完成任务，并且重用任何代码都是明智的。
- en: 'One unusual point about the rewriting rules: when doing the pattern matching,
    it is useful for both the input and the pattern to be tokenized. Hence, the same
    scanner is used for both the input addresses and the patterns themselves. This
    requires that the scanner be called with different character type tables for differing
    input.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有关重写规则的一个不寻常的要点是：在进行模式匹配时，对于输入和模式来说，对它们进行标记化是有用的。因此，相同的扫描器用于输入地址和模式本身。这要求扫描器使用不同的字符类型表来处理不同的输入。
- en: 17.4.4\. Embedding SMTP and Queueing in sendmail
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.4\. 将 SMTP 和排队嵌入 sendmail
- en: An "obvious" way to implement outgoing (client) SMTP would have been to build
    it as an external mailer, similarly to UUCP, But this would raise a number of
    other questions. For example, would queueing be done in sendmail or in the SMTP
    client module? If it was done in sendmail then either separate copies of messages
    would have to be sent to each recipient (i.e., no "piggybacking", wherein a single
    connection can be opened and then multiple `RCPT` commands can be sent) or a much
    richer communication back-path would be necessary to convey the necessary per-recipient
    status than was possible using simple Unix exit codes. If queueing was done in
    the client module then there was a potential for large amounts of replication;
    in particular, at the time other networks such as XNS were still possible contenders.
    Additionally, including the queue into sendmail itself provided a more elegant
    way of dealing with certain kinds of failures, notably transient problems such
    as resource exhaustion.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实现出站（客户端）SMTP的一个“显而易见”的方法是将其构建为外部邮件发送程序，类似于 UUCP，但是这将引发一系列其他问题。例如，排队是在 sendmail
    中进行还是在 SMTP 客户端模块中进行？如果在 sendmail 中进行排队，那么要么必须将各个收件人的消息分别发送（即没有“搭便车”，其中可以打开单个连接，然后发送多个
    `RCPT` 命令），要么需要更丰富的通信反向路径来传达必要的每个收件人的状态，这是使用简单的 Unix 退出代码无法实现的。如果在客户端模块中进行排队，则存在大量复制的潜力；特别是，当时其他网络（如
    XNS）仍然可能是竞争对手。此外，将队列包含到 sendmail 本身中提供了一种更优雅的方法来处理某些类型的故障，尤其是暂时性问题，如资源耗尽。
- en: Incoming (server) SMTP involved a different set of decisions. At the time, I
    felt it was important to implement the `VRFY` and `EXPN` SMTP commands faithfully,
    which required access to the alias mechanism. This would once again require a
    much richer protocol exchange between the server SMTP module and sendmail than
    was possible using command lines and exit codes—in fact, a protocol akin to SMTP
    itself.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 收件方（服务器）SMTP 涉及不同的决策。当时，我认为实现 `VRFY` 和 `EXPN` SMTP 命令是重要的，这需要访问别名机制。这将再次需要服务器
    SMTP 模块与 sendmail 之间比使用命令行和退出码更丰富的协议交换——实际上，这是一种类似于 SMTP 本身的协议。
- en: 'I would be much more inclined today to leave queueing in the core sendmail
    but move both sides of the SMTP implementation into other processes. One reason
    is to gain security: once the server side has an open instance of port 25 it no
    longer needs access to root permissions. Modern extensions such as TLS and DKIM
    signing complicate the client side (since the private keys should not be accessible
    to unprivileged users), but strictly speaking root access is still not necessary.
    Although the security issue is still an issue here, if the client SMTP is running
    as a non-root user who can read the private keys, that user by definition has
    special privileges, and hence should not be communicating directly with other
    sites. All of these issues can be finessed with a bit of work.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我更倾向于将队列留在核心 sendmail 中，但将 SMTP 实现的两端移至其他进程中。一个原因是为了增强安全性：一旦服务器端有一个打开的 25
    号端口的实例，它就不再需要 root 权限。现代扩展例如 TLS 和 DKIM 签名会使客户端部分复杂化（因为私钥不应该对非特权用户可见），但严格来说 root
    访问仍然不是必需的。虽然安全问题仍然存在，但如果客户端 SMTP 作为一个非特权用户运行，并且可以读取私钥，那么这个用户根据定义具有特殊权限，因此不应直接与其他站点通信。所有这些问题都可以通过一些工作来解决。
- en: 17.4.5\. The Implementation of the Queue
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.5\. 队列的实现
- en: Sendmail followed the conventions of the time for storing queue files. In fact,
    the format used is extremely similar to the lpr subsystem of the time. Each job
    had two files, one with the control information and one with the data. The control
    file was a flat text file with the first character of each line representing the
    meaning of that line.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Sendmail 遵循当时存储队列文件的惯例。事实上，所使用的格式与当时的 lpr 子系统极为相似。每个作业都有两个文件，一个带有控制信息，一个带有数据。控制文件是一个扁平文本文件，每行的第一个字符表示该行的含义。
- en: When sendmail wanted to process the queue it had to read all of the control
    files, storing the relevant information in memory, and then sort the list. That
    worked fine with a relatively small number of messages in the queue, but started
    to break down at around 10,000 queued messages. Specifically, when the directory
    got large enough to require indirect blocks in the filesystem, there was a serious
    performance knee that could reduce performance by as much as an order of magnitude.
    It was possible to ameliorate this problem by having sendmail understand multiple
    queue directories, but that was at best a hack.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当 sendmail 想要处理队列时，它必须读取所有控制文件，将相关信息存储在内存中，然后对列表进行排序。这在队列中有相对较少数量的消息时运行良好，但在排队消息达到约
    10,000 条时开始出现问题。具体来说，当目录变得足够大以在文件系统中需要间接块时，可能会出现严重的性能问题，这可能会将性能降低一个数量级。通过使 sendmail
    理解多个队列目录，可以缓解这个问题，但这充其量是一种破解。
- en: An alternative implementation might be to store all the control files in one
    database file. This wasn't done because when sendmail coding began there was no
    generally available database package, and when dbm(3) became available it had
    several flaws, including the inability to reclaim space, a requirement that all
    keys that hashed together fit on one (512 byte) page, and a lack of locking. Robust
    database packages didn't appear for many years.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方法可能是将所有控制文件存储在一个数据库文件中。这样做的原因是因为当 sendmail 编码开始时，没有普遍可用的数据库包，而当 dbm(3)
    可用时，它有几个缺陷，包括无法回收空间、所有散列在一起的键都要适合一个（512 字节）页面以及缺乏锁定。稳健的数据库包在很多年后才出现。
- en: Another alternative implementation would have been to have a separate daemon
    that would keep the state of the queue in memory, probably writing a log to allow
    recovery. Given the relatively low email traffic volumes of the time, the lack
    of memory on most machines, the relatively high cost of background processes,
    and the complexity of implementing such a process, this didn't seem like a good
    tradeoff at the time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种替代实现可能是有一个单独的守护进程，用于将队列的状态保留在内存中，可能会写入日志以实现恢复。考虑到当时的相对低的电子邮件流量、大多数计算机的内存不足、后台进程的相对高成本和实现这种进程的复杂性，这在当时似乎不是一个很好的权衡。
- en: Another design decision was to store the message header in the queue control
    file rather than the data file. The rationale was that most headers needed considerable
    rewriting that varied from destination to destination (and since messages could
    have more than one destination, they would have to be customized multiple times),
    and the cost of parsing the headers seemed high, so storing them in a pre-parsed
    format seemed like a savings. In retrospect this was not a good decision, as was
    storing the message body in Unix-standard format (with newline endings) rather
    than in the format in which it was received (which could use newlines, carriage-return/line-feed,
    bare carriage-return, or line-feed/carriage-return). As the e-mail world evolved
    and standards were adopted, the need for rewriting diminished, and even seemingly
    innocuous rewriting has the risk of error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个设计决定是将消息头存储在队列控制文件中，而不是数据文件中。其理由是大多数头部需要经过相当多的重写，而这种重写因目的地而异（而且由于消息可能有多个目的地，它们将不得不被多次自定义），并且解析头部的成本似乎很高，因此以预解析格式存储它们似乎是一种节省。回顾来看，这不是一个好决定，就像在Unix标准格式（以换行结束）中而不是接收格式中存储消息正文一样（可以使用换行符、回车/换行符、裸回车或换行/回车换行）。随着电子邮件世界的发展和采用的标准，重写的需要减少了，甚至看似无害的重写也存在错误的风险。
- en: 17.4.6\. Accepting and Fixing Bogus Input
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.6\. 接受和修复虚假输入
- en: 'Since sendmail was created in a world of multiple protocols and disturbingly
    few written standards, I decided to clean up malformed messages wherever possible.
    This matches the "Robustness Principle" (a.k.a. Postel''s Law) articulated in
    RFC 793. Some of these changes were obvious and even required: when sending a
    UUCP message to the Arpanet, the UUCP addresses needed to be converted to Arpanet
    addresses, if only to allow "reply" commands to work correctly, line terminations
    needed to be converted between the conventions used by various platforms, and
    so on. Some were less obvious: if a message was received that did not include
    a `From:` header field required in the Internet specifications, should you add
    a `From:` header field, pass the message on without the `From:` header field,
    or reject the message? At the time, my prime consideration was interoperability,
    so sendmail patched the message, e.g., by adding the `From:` header field. However,
    this is claimed to have allowed other broken mail systems to be perpetuated long
    past the time when they should have been fixed or killed off.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于sendmail是在多种协议和令人不安的少量书面标准的世界中创建的，我决定尽可能清理格式不正确的消息。这符合RFC 793中阐述的“鲁棒性原则”（又称Postel's
    Law）。其中一些更改是显而易见的，甚至是必需的：当向Arpanet发送UUCP消息时，需要将UUCP地址转换为Arpanet地址，即使只是为了使“回复”命令能正确运行，行终止需要在各平台使用的约定之间转换，等等。还有一些变化不够明显：如果收到一条消息，其中不包括Internet规范中要求的`From:`头字段，应该添加`From:`头字段，传递不包括`From:`头字段的消息，还是拒绝消息？当时，我主要考虑的是互操作性，所以sendmail对消息进行了修补，例如添加了`From:`头字段。然而，据称这让其他损坏的邮件系统能够长时间存在，远超过它们应该被修复或淘汰的时间。
- en: I believe my decision was correct for the time, but is problematic today. A
    high degree of interoperability was important to let mail flow unimpeded. Had
    I rejected malformed messages, most messages at the time would have been rejected.
    Had I passed them through unfixed, recipients would have received messages that
    they couldn't reply to and in some cases couldn't even determine who sent the
    message—that or the message would have been rejected by another mailer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为当时我的决定是正确的，但今天却存在问题。高度的互操作性对于让邮件无阻地流动很重要。如果我拒绝格式不正确的消息，当时大多数消息都会被拒绝。如果我传递它们而不予修复，收件人将收到他们无法回复的消息，甚至在某些情况下甚至无法确定是谁发送的消息，或者消息将被另一个邮件发送程序拒绝。
- en: Today the standards are written, and for the most part those standards are accurate
    and complete. It is no longer the case that most messages would be rejected, and
    yet there is still mail software out there that send out mangled messages. This
    unnecessarily creates numerous problems for other software on the Internet.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，标准已经制定，并且在大多数情况下，这些标准是准确和完整的。不再是大多数消息会被拒绝的情况了，但仍然有一些邮件软件会发送出损坏的消息。这不必要地给互联网上的其他软件造成了许多问题。
- en: 17.4.7\. Configuration and the Use of M4
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.7\. 配置和M4的使用
- en: For a period I was both making regular changes to the sendmail configuration
    files and personally supporting many machines. Since a large amount of the configuration
    file was the same between different machines, the use of a tool to build the configuration
    files was desirable. The m4 macro processor was included with Unix. It was designed
    as a front end for programming languages (notably ratfor). Most importantly, it
    had "include" capabilities, like "#include" in the C language. The original configuration
    files used little more than this capability and some minor macro expansions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有一段时间，我既在定期更改sendmail配置文件，又在个人支持许多机器。由于不同机器之间的配置文件大部分相同，因此使用工具构建配置文件是可取的。m4宏处理器包含在Unix中。它被设计为编程语言（尤其是ratfor）的前端。最重要的是，它具有"include"功能，就像C语言中的"#include"一样。原始配置文件几乎只使用了这种能力和一些次要的宏扩展。
- en: IDA sendmail also used m4, but in a dramatically different way. In retrospect
    I should have probably studied these prototypes in more detail. They contained
    many clever ideas, in particular the way they handled quoting.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: IDA sendmail也使用了m4，但使用方式截然不同。回顾起来，我应该更仔细地研究这些原型。它们包含了许多聪明的想法，特别是它们处理引号的方式。
- en: Starting with sendmail 6, the m4 configuration files were completely rewritten
    to be in a more declarative style and much smaller. This used considerably more
    of the power of the m4 processor, which was problematic when the introduction
    of GNU m4 changed some of the semantics in subtle ways.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从sendmail 6开始，m4配置文件被完全重写为更具声明性和更小的样式。这更多地利用了m4处理器的能力，但当GNU m4的引入以微妙的方式改变了一些语义时，这就成为了问题。
- en: 'The original plan was that the m4 configurations would follow the 80/20 rule:
    they would be simple (hence 20% of the work), and would cover 80% of the cases.
    This broke down fairly quickly, for two reasons. The minor reason was that it
    turned out to be relatively easy to handle the vast majority of the cases, at
    least in the beginning. It became much harder as sendmail and the world evolved,
    notably with the inclusion of features such as TLS encryption and SMTP Authentication,
    but those didn''t come until quite a bit later.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的计划是，m4配置将遵循80/20法则：它们将是简单的（因此工作的20%），并且将涵盖80%的情况。这很快就崩溃了，有两个原因。次要的原因是，事实证明，至少在开始时，处理绝大多数情况相对容易。随着sendmail和世界的发展，特别是在后来引入诸如TLS加密和SMTP身份验证等功能之后，情况变得更加困难，但这些功能直到相当晚才出现。
- en: The important reason was that it was becoming clear that the raw configuration
    file was just too difficult for most people to manage. In essence, the `.cf` (raw)
    format had become assembly code—editable in principle, but in reality quite opaque.
    The "source code" was an m4 script stored in the `.mc` file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的原因是，人们开始清楚地意识到，原始配置文件对大多数人来说实在是太难管理了。实际上，`.cf`（原始）格式已经变成了汇编代码——原则上可编辑，但实际上相当晦涩。"源代码"是存储在`.mc`文件中的m4脚本。
- en: 'Another important distinction is that the raw format configuration file was
    really a programming language. It had procedural code (rulesets), subroutine calls,
    parameter expansion, and loops (but no gotos). The syntax was obscure, but in
    many ways resembled the `sed` and `awk` commands, at least conceptually. The m4
    format was declarative: although it was possible to drop into the low-level raw
    language, in practice these details were hidden from the user.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的区别是，原始格式的配置文件实际上是一种编程语言。它具有过程性代码（规则集）、子程序调用、参数扩展和循环（但没有goto语句）。语法晦涩，但在许多方面类似于`sed`和`awk`命令，至少在概念上是这样。m4格式是声明性的：尽管可以进入低级原始语言，但在实践中，这些细节对用户是隐藏的。
- en: It isn't clear that this decision was correct or incorrect. I felt at the time
    (and still feel) that with complex systems it can be useful to implement what
    amounts to a Domain Specific Language (DSL) for building certain portions of that
    system. However, exposing that DSL to end users as a configuration methodology
    essentially converts all attempts to configure a system into a programming problem.
    Great power results from this, but at a non-trivial cost.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当时这个决定是否正确并不清楚。我当时感觉（现在仍然感觉）对于复杂系统，实现一种用于构建系统某些部分的特定领域语言（DSL）可能是有用的。然而，将该DSL暴露给最终用户作为配置方法实际上将所有配置系统的尝试都转化为了一个编程问题。这样做会带来巨大的力量，但成本并不低廉。
- en: 17.5\. Other Considerations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.5\. 其他考虑事项
- en: Several other architectural and development points deserve to be mentioned.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个其他的架构和开发要点值得一提。
- en: 17.5.1\. A Word About Optimizing Internet Scale Systems
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.5.1\. 关于优化互联网规模系统的一些话
- en: In most network-based systems there is a tension between the client and the
    server. A good strategy for the client may be the wrong thing for the server and
    vice versa. For example, when possible the server would like to minimize its processing
    costs by pushing as much as possible back to the client, and of course the client
    feels the same way but in the opposite direction. For example, a server might
    want to keep a connection open while doing spam processing since that lowers the
    cost of rejecting a message (which these days is the common case), but the client
    wants to move on as quickly as possible. Looking at the entire system, that is,
    the Internet as a whole, the optimum solution may be to balance these two needs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数基于网络的系统中，客户端和服务器之间存在紧张关系。对客户端而言的良好策略可能对服务器来说是错误的，反之亦然。例如，服务器希望通过尽可能多地将工作推迟到客户端来最小化其处理成本，而客户端当然也有相同的想法，但方向相反。例如，服务器可能希望在进行垃圾邮件处理时保持连接打开，因为这降低了拒绝消息的成本（这在当今是常见情况），但客户端希望尽快继续进行。从整个系统即整个互联网来看，最佳解决方案可能是平衡这两种需求。
- en: There have been cases of MTAs that have used strategies that explicitly favor
    either the client or the server. They can do this only because they have a relatively
    small installed base. When your system is used on a significant portion of the
    Internet you have to design it in order to balance the load between both sides
    in an attempt to optimize the Internet as a whole. This is complicated by the
    fact that there will always be MTAs completely skewed in one direction or the
    other—for example, mass mailing systems only care about optimizing the outgoing
    side.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有过一些MTA使用明确偏向客户端或服务器的策略的情况。他们之所以能够这样做，只是因为他们的安装基数相对较小。当您的系统在互联网的大部分区域上使用时，您必须设计它以平衡双方的负载，以尝试优化整个互联网。这被事实上总会有MTA完全倾向于一边或另一边所复杂化——例如，大规模邮件系统只关心优化外发方面。
- en: When designing a system that incorporates both sides of the connection, it is
    important to avoid playing favorites. Note that this is in stark contrast to the
    usual asymmetry of clients and services—for example, web servers and web clients
    are generally not developed by the same groups.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计涵盖连接两侧的系统时，避免偏袒某一方是很重要的。请注意，这与客户端和服务的通常不对称性形成鲜明对比——例如，Web服务器和Web客户端通常不是由同一组开发者开发的。
- en: 17.5.2\. Milter
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.5.2\. Milter
- en: One of the most important additions to sendmail was the milter (*m*ail f*ilter*)
    interface. Milter allows for the use of offboard plugins (i.e., they run in a
    separate process) for mail processing. These were originally designed for anti-spam
    processing. The milter protocol runs synchronously with the server SMTP protocol.
    As each new SMTP command is received from the client, sendmail calls the milters
    with the information from that command. The milter has the opportunity to accept
    the command or send a rejection, which rejects the phase of the protocol appropriate
    for the SMTP command. Milters are modeled as callbacks, so as an SMTP command
    comes in, the appropriate milter subroutine is called. Milters are threaded, with
    a per-connection context pointer handed in to each routine to allow passing state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 sendmail 最重要的补充之一是 milter（邮件过滤器）接口。Milter 允许使用离板插件（即，它们在单独的进程中运行）进行邮件处理。最初这些设计用于防垃圾邮件处理。milter
    协议与服务器 SMTP 协议同步运行。当从客户端接收到每个新的 SMTP 命令时，sendmail 将调用 milters 并提供该命令的信息。milter
    有机会接受命令或发送拒绝，拒绝与 SMTP 命令相适应的协议阶段。milter 被建模为回调，因此当 SMTP 命令进入时，会调用适当的 milter 子例程。Milter
    是多线程的，对于每个例程都会传递一个每个连接的上下文指针，以允许传递状态。
- en: 'In theory milters could work as loadable modules in the sendmail address space.
    We declined to do this for three reasons. First, the security issues were too
    significant: even if sendmail were running as a unique non-root user id, that
    user would have access to all of the state of other messages. Similarly, it was
    inevitable that some milter authors would try to access internal sendmail state.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，milter 可以作为可加载模块在 sendmail 地址空间中工作。我们之所以不这样做有三个原因。首先，安全问题太重要了：即使 sendmail
    作为唯一的非根用户 id 运行，该用户也会访问其他消息的所有状态。同样，某些 milter 作者将试图访问内部 sendmail 状态是不可避免的。
- en: 'Second, we wanted to create a firewall between sendmail and the milters: if
    a milter crashed, we wanted it to be clear who was at fault, and for mail to (potentially)
    continue to flow. Third, it was much easier for a milter author to debug a standalone
    process than sendmail as a whole.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们想在 sendmail 和 milter 之间创建一个防火墙：如果一个 milter 崩溃了，我们希望清楚地知道谁出了问题，并且邮件可以（可能）继续流动。第三，对于一个
    milter 作者来说，调试一个独立的进程要比整个 sendmail 容易得多。
- en: It quickly became clear that the milter was useful for more than anti-spam processing.
    In fact, the milter.org web site lists milters for anti-spam, anti-virus, archiving,
    content monitoring, logging, traffic shaping, and many other categories, produced
    by commercial companies and open source projects. The postfix mailer has added
    support for milters using the same interface. Milters have proven to be one of
    sendmail's great successes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 很快就清楚地看到，milter 不仅仅对抗垃圾邮件处理有用。事实上，milter.org 网站列出了商业公司和开源项目生产的针对防垃圾邮件、防病毒、归档、内容监控、日志记录、流量整形等许多其他类别的
    milter。邮件发送器 postfix 已经使用相同的接口添加了对 milter 的支持。Milter 已被证明是 sendmail 的伟大成功之一。
- en: 17.5.3\. Release Schedules
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.5.3\. 发布时间表
- en: 'There is a popular debate between "release early and often" and "release stable
    systems" schools of thought. Sendmail has used both of these at various times.
    During times of considerable change I was sometimes doing more than one release
    a day. My general philosophy was to make a release after each change. This is
    similar to providing public access to the source management system tree. I personally
    prefer doing releases over providing public source trees, at least in part because
    I use source management in what is now considered an unapproved way: for large
    changes, I will check in non-functioning snapshots while I am writing the code.
    If the tree is shared I will use branches for these snapshots, but in any case
    they are available for the world to see and can create considerable confusion.
    Also, creating a release means putting a number on it, which makes it easier to
    track the changes when going through a bug report. Of course, this requires that
    releases be easy to generate, which is not always true.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '"早期频繁发布" 和 "发布稳定系统" 两种思想之间存在着热烈的讨论。Sendmail 在不同的时候都使用过这两种方法。在变化很大的时候，有时我一天会做多次发布。我的一般理念是每次变更后发布。这类似于为源管理系统树提供公共访问。我个人更喜欢发布而不是提供公共源树，至少部分原因是我使用源管理的方式现在被认为是不被认可的方式：对于大的变更，我会在写代码的同时检入不起作用的快照。如果树是共享的，我会为这些快照使用分支，但无论如何它们都是对世界可见的，并且可能会造成相当大的混乱。此外，发布意味着给它一个编号，这样在处理
    bug 报告时更容易跟踪变更。当然，这需要发布变得容易生成，这并不总是正确的。'
- en: As sendmail became used in ever more critical production environments this started
    to become problematic. It wasn't always easy for others to tell the difference
    between changes that I wanted out there for people to test versus changes that
    were really intended to be used in the wild. Labeling releases as "alpha" or "beta"
    alleviates but does not fix the problem. The result was that as sendmail matured
    it moved toward less frequent but larger releases. This became especially acute
    when sendmail got folded into a commercial company which had customers who wanted
    both the latest and greatest but also only stable versions, and wouldn't accept
    that the two are incompatible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 sendmail 被越来越多地用于关键的生产环境，这种情况开始变得棘手起来。对于其他人来说，很难区分我希望大家测试的变更和真正用于实际环境的变更。将发布标记为“alpha”或“beta”可以缓解但不能解决问题。结果是，随着
    sendmail 的成熟，发布变得不那么频繁但更大规模。当 sendmail 被并入一个商业公司时，这种情况尤为严重，该公司的客户既想要最新最棒的，又只接受稳定版本，而且不愿意接受这两者是不兼容的事实。
- en: This tension between open source developer needs and commercial product needs
    will never go away. There are many advantages to releasing early and often, notably
    the potentially huge audience of brave (and sometimes foolish) testers who stress
    the system in ways that you could almost never expect to reproduce in a standard
    development system. But as a project becomes successful it tends to turn into
    a product (even if that product is open source and free), and products have different
    needs than projects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 开源开发者需求与商业产品需求之间的紧张关系永远不会消失。及早并频繁发布有许多优点，特别是可能会有庞大的勇敢（有时愚蠢）的测试人员群体，他们以几乎无法在标准开发系统中重现的方式测试系统。但随着项目的成功，它往往会变成一个产品（即使该产品是开源且免费的），而产品与项目有不同的需求。
- en: 17.6\. Security
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.6\. 安全
- en: Sendmail has had a tumultuous life, security-wise. Some of this is well deserved,
    but some not, as our concept of "security" changed beneath us. The Internet started
    out with a user base of a few thousand people, mostly in academic and research
    settings. It was, in many ways, a kinder, gentler Internet than we know today.
    The network was designed to encourage sharing, not to build firewalls (another
    concept that did not exist in the early days). The net is now a dangerous, hostile
    place, filled with spammers and crackers. Increasingly it is being described as
    a war zone, and in war zones there are civilian casualties.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Sendmail 的安全性经历了动荡的生活。其中一些是当之无愧的，但有些则不是，因为我们对“安全性”的概念在我们之下发生了变化。互联网始于几千人的用户群体，主要是学术和研究环境中的用户。在很多方面，这是一个比今天我们所知的更加友善的互联网。网络旨在鼓励共享，而不是建立防火墙（这在早期是不存在的概念）。现在的网络是一个危险、敌对的地方，充满了垃圾邮件发送者和黑客。它越来越被描述为一个战区，在战区中有平民伤亡。
- en: It's hard to write network servers securely, especially when the protocol is
    anything beyond the most simple. Nearly all programs have had at least minor problems;
    even common TCP/IP implementations have been successfully attacked. Higher-level
    implementation languages have proved no panacea, and have even created vulnerabilities
    of their own. The necessary watch phrase is "distrust all input," no matter where
    it comes from. Distrusting input includes secondary input, for example, from DNS
    servers and milters. Like most early network software, sendmail was far too trusting
    in its early versions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 编写网络服务器是困难的，特别是当协议不仅仅是最简单的时候。几乎所有程序都至少有过轻微的问题；甚至常见的 TCP/IP 实现也曾被成功攻击过。更高级的实现语言并没有证明是万灵药，甚至还产生了自己的漏洞。必要的注意点是“不信任所有输入”，无论它来自何处。不信任输入包括来自
    DNS 服务器和 milters 等次要输入。与大多数早期网络软件一样，在其早期版本中，sendmail 对此过于信任。
- en: But the biggest problem with sendmail was that early versions ran with root
    permissions. Root permission is needed in order to open the SMTP listening socket,
    to read individual users' forwarding information, and to deliver to individual
    users' mailboxes and home directories. However, on most systems today the concept
    of a mailbox name has been divorced from the concept of a system user, which effectively
    eliminates the need for root access except to open the SMTP listening socket.
    Today sendmail has the ability to give up root permissions before it processes
    a connection, eliminating this concern for environments that can support it. It's
    worth noting that on those systems that do not deliver directly to users' mailboxes,
    sendmail can also run in a chrooted environment, allowing further permission isolation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但 sendmail 最大的问题在于早期版本以 root 权限运行。需要 root 权限来打开 SMTP 监听套接字，读取个别用户的转发信息，并将邮件发送到个别用户的邮箱和主目录。但是，在今天的大多数系统中，邮箱名称的概念已与系统用户的概念分离，这实际上消除了除了打开
    SMTP 监听套接字之外的 root 访问需求。今天的 sendmail 有能力在处理连接之前放弃 root 权限，消除了对支持它的环境的这种担忧。值得注意的是，在那些不直接发送到用户邮箱的系统上，sendmail
    还可以在 chrooted 环境中运行，从而实现进一步的权限隔离。
- en: Unfortunately, as sendmail gained a reputation for poor security, it started
    to be blamed for problems that had nothing to do with sendmail. For example, one
    system administrator made his `/etc` directory world writable and then blamed
    sendmail when someone replaced the `/etc/passwd` file. It was incidents like this
    that caused us to tighten security substantially, including explicitly checking
    the ownerships and modes on files and directories that sendmail accesses. These
    were so draconian that we were obliged to include the `DontBlameSendmail` option
    to (selectively) turn off these checks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，随着 sendmail 获得恶劣安全记录的声誉，它开始因与 sendmail 无关的问题而受到指责。例如，一位系统管理员将他的 `/etc`
    目录设为全局可写，然后当有人替换了 `/etc/passwd` 文件时却责备 sendmail。正是这类事件促使我们大幅加强了安全措施，包括明确检查 sendmail
    访问的文件和目录的所有权和模式。这些措施是如此严厉，以至于我们被迫包含 `DontBlameSendmail` 选项以（选择性地）关闭这些检查。
- en: There are other aspects of security that are not related to protecting the address
    space of the program itself. For example, the rise of spam also caused a rise
    in address harvesting. The `VRFY` and `EXPN` commands in SMTP were designed specifically
    to validate individual addresses and expand the contents of mailing lists respectively.
    These have been so badly abused by spammers that most sites now turn them off
    entirely. This is unfortunate, at least with `VRFY`, as this command was sometimes
    used by some anti-spam agents to validate the purported sending address.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其他安全方面与保护程序地址空间无关。例如，垃圾邮件的增加也导致了地址收集的增加。SMTP 中的 `VRFY` 和 `EXPN` 命令分别专门设计用于验证个别地址和扩展邮件列表的内容。由于这些命令被垃圾邮件发送者滥用，大多数站点现在完全关闭了它们。至少对于
    `VRFY` 来说，这是不幸的，因为有时一些反垃圾邮件代理会使用此命令来验证所谓的发送地址。
- en: Similarly, anti-virus protection was once seen as a desktop problem, but rose
    in importance to the point where any commercial-grade MTA had to have anti-virus
    checking available. Other security-related requirements in modern settings include
    mandatory encryption of sensitive data, data loss protection, and enforcement
    of regulatory requirements, for example, for HIPPA.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，反病毒保护曾被视为桌面问题，但随着重要性的提高，任何商用级别的 MTA 都必须具备反病毒检查功能。现代设置中与安全相关的其他要求包括对敏感数据的强制加密、数据丢失保护和执行监管要求，例如
    HIPPA。
- en: One of the principles that sendmail took to heart early on was reliability—every
    message should either be delivered or reported back to the sender. But the problem
    of joe-jobs (attackers forging the return address on a message, viewed by many
    as a security issue) has caused many sites to turn off the creation of bounce
    messages. If a failure can be determined while the SMTP connection is still open,
    the server can report the problem by failing the command, but after the SMTP connection
    is closed an incorrectly addressed message will silently disappear. To be fair,
    most legitimate mail today is single hop, so problems will be reported, but at
    least in principle the world has decided that security wins over reliability.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: sendmail 早期就将可靠性视为一个原则——每一条消息都应该被投递或者回报给发送者。但是 joe-jobs（许多人视为安全问题的攻击者伪造消息的回报地址）的问题导致许多站点关闭了回报消息的创建。如果在
    SMTP 连接仍然打开的情况下可以确定失败，服务器可以通过失败的命令报告问题，但是在 SMTP 连接关闭后，一个错误地址的消息将会悄无声息地消失。公平地说，今天大多数合法邮件都是单跳的，因此问题会被报告，但至少从原则上讲，世界已经决定安全优于可靠性。
- en: 17.7\. Evolution of Sendmail
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.7\. Sendmail 的演变
- en: Software doesn't survive in a rapidly changing environment without evolving
    to fit the changing environment. New hardware technologies appear, which push
    changes in the operating system, which push changes in libraries and frameworks,
    which push changes in applications. If an application succeeds, it gets used in
    ever more problematic environments. Change is inevitable; to succeed you have
    to accept and embrace change. This section describes some of the more important
    changes that have occurred as sendmail evolved.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 软件在不断变化的环境中不会存活下来而不适应变化。新的硬件技术出现，推动操作系统的变化，推动库和框架的变化，推动应用程序的变化。如果一个应用程序成功了，它将在越来越有问题的环境中使用。变化是不可避免的；要成功，你必须接受和拥抱变化。本节描述了
    sendmail 发展过程中发生的一些更重要的变化。
- en: 17.7.1\. Configuration Became More Verbose
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.7.1\. 配置变得更加冗长
- en: The original configuration of sendmail was quite terse. For example, the names
    of options and macros were all single characters. There were three reasons for
    this. First, it made parsing very simple (important in a 16-bit environment).
    Second, there weren't very many options, so it wasn't hard to come up with mnemonic
    names. Third, the single character convention was already established with command-line
    flags.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: sendmail 的原始配置非常简洁。例如，选项和宏的名称都是单个字符。有三个原因。首先，这样做使得解析非常简单（在 16 位环境中很重要）。其次，选项并不多，因此很容易想出助记名称。第三，单字符约定已经与命令行标志建立了起来。
- en: Similarly, rewriting rulesets were originally numbered instead of named. This
    was perhaps tolerable with a small number of rulesets, but as their number grew
    it became important that they have more mnemonic names.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，重写规则集最初是用编号而不是名称命名的。这在规则集数量较少时可能是可以容忍的，但随着规则集数量的增加，拥有更有助记性的名称变得更加重要。
- en: As the environment in which sendmail operated became more complex, and as the
    16-bit environment faded away, the need for a richer configuration language became
    evident. Fortunately, it was possible to make these changes in a backward compatible
    way. These changes dramatically improved the understandability of the configuration
    file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 sendmail 运行环境变得更加复杂，并且 16 位环境逐渐消失，更丰富的配置语言的需求变得明显。幸运的是，可以以向后兼容的方式进行这些更改。这些更改大大提高了配置文件的可理解性。
- en: '17.7.2\. More Connections with Other Subsystems: Greater Integration'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.7.2\. 与其他子系统的更多连接：更大的集成
- en: When sendmail was written the mail system was largely isolated from the rest
    of the operating system. There were a few services that required integration,
    e.g., the `/etc/passwd` and `/etc/hosts` files. Service switches had not been
    invented, directory services were nonexistent, and configuration was small and
    hand-maintained.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当 sendmail 被编写时，邮件系统基本上与操作系统的其余部分隔离开来。有一些服务需要集成，例如 `/etc/passwd` 和 `/etc/hosts`
    文件。服务开关尚未被发明，目录服务不存在，配置较小且手工维护。
- en: That quickly changed. One of the first additions was DNS. Although the system
    host lookup abstraction (`gethostbyname`) worked for looking up IP addresses,
    email had to use other queries such as MX. Later, IDA sendmail included an external
    database lookup functionality using dbm(3) files. Sendmail 8 updated that to a
    general mapping service that allowed other database types, including external
    databases and internal transformations that could not be done using rewriting
    (e.g., dequoting an address).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 情况很快就改变了。最早的添加之一是 DNS。虽然系统主机查找抽象化（`gethostbyname`）可用于查找 IP 地址，但电子邮件必须使用其他查询，如
    MX。稍后，IDA sendmail 包含了使用 dbm(3) 文件的外部数据库查找功能。Sendmail 8 将其更新为通用映射服务，允许其他数据库类型，包括外部数据库和无法使用重写完成的内部转换（例如，解除地址引用）。
- en: Today, the email system relies on many external services that are, in general,
    not designed specifically for the exclusive use of email. This has moved sendmail
    toward more abstractions in the code. It has also made maintaining the mail system
    more difficult as more "moving parts" are added.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，电子邮件系统依赖许多通常并非专门为电子邮件的独占使用而设计的外部服务。这导致 sendmail 在代码中更多地使用抽象化。随着更多的“移动部件”被添加，维护邮件系统也变得更加困难。
- en: 17.7.3\. Adaptation to a Hostile World
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.7.3\. 适应恶劣环境
- en: Sendmail was developed in a world that seems completely foreign by today's standards.
    The user population on the early network were mostly researchers who were relatively
    benign, despite the sometimes vicious academic politics. Sendmail reflected the
    world in which it was created, putting a lot of emphasis on getting the mail through
    as reliably as possible, even in the face of user errors.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Sendmail 是在今天看来完全陌生的世界中发展起来的。早期网络上的用户主要是研究人员，尽管有时存在激烈的学术政治斗争，但他们大多相对温和。Sendmail
    反映了它所创建的世界，非常注重尽可能可靠地传递邮件，即使面对用户错误。
- en: Today's world is much more hostile. The vast majority of email is malicious.
    The goal of an MTA has transitioned from getting the mail through to keeping the
    bad mail out. Filtering is probably the first priority for any MTA today. This
    required a number of changes in sendmail.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如今的世界更加恶劣。绝大多数电子邮件都是恶意的。MTA 的目标已经从通过邮件转发变为阻止垃圾邮件。对于任何 MTA 来说，过滤可能是首要任务。这要求 sendmail
    进行了许多更改。
- en: For example, many rulesets have been added to allow checking of parameters on
    incoming SMTP commands in order to catch problems as early as possible. It is
    much cheaper to reject a message when reading the envelope than after you have
    committed to reading the entire message, and even more expensive after you have
    accepted the message for delivery. In the early days filtering was generally done
    by accepting the message, passing it to a filter program, and then sending it
    to another instance of sendmail if the message passed (the so-called "sandwich"
    configuration). This is just far too expensive in today's world.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，已经添加了许多规则集，允许检查传入 SMTP 命令的参数，以尽早发现问题。在读取信封时拒绝邮件要比读取整个邮件后再拒绝要便宜得多，甚至在接受邮件以便递送后再拒绝也更昂贵。在早期，过滤通常是通过接受邮件、将其传递给过滤程序，然后在邮件通过时将其发送到另一个
    sendmail 实例（所谓的“三明治”配置）来完成的。但在今天的世界中，这种方法太过昂贵。
- en: Similarly, sendmail has gone from being a quite vanilla consumer of TCP/IP connections
    to being much more sophisticated, doing things like "peeking" at network input
    to see if the sender is transmitting commands before the previous command has
    been acknowledged. This breaks down some of the previous abstractions that were
    designed to make sendmail adaptable to multiple network types. Today, it would
    involve considerable work to connect sendmail to an XNS or DECnet network, for
    example, since the knowledge of TCP/IP has been built into so much of the code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，sendmail 已经从一个相当普通的 TCP/IP 连接消费者发展为更加复杂，做一些像“窥视”网络输入以查看发送者是否在之前的命令得到确认之前传输命令的事情。这破坏了一些旨在使
    sendmail 适应多种网络类型的先前抽象化。例如，今天要将 sendmail 连接到 XNS 或 DECnet 网络将涉及大量工作，因为对 TCP/IP
    的了解已经构建到代码的很多部分中。
- en: Many configuration features were added to address the hostile world, such as
    support for access tables, Realtime Blackhole Lists, address harvesting mitigation,
    denial-of-service protection, and spam filtering. This has dramatically complicated
    the task of configuring a mail system, but was absolutely necessary to adapt to
    today's world.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了许多配置功能以应对敌对世界，例如支持访问表、实时黑洞列表、地址收集缓解、拒绝服务保护和垃圾邮件过滤。这极大地复杂化了配置邮件系统的任务，但绝对有必要适应当今的世界。
- en: 17.7.4\. Incorporation of New Technologies
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.7.4\. 新技术的整合
- en: Many new standards have come along over the years that required significant
    changes to sendmail. For example, the addition of TLS (encryption) required significant
    changes through much of the code. SMTP pipelining required peering into the low-level
    TCP/IP stream to avoid deadlocks. The addition of the submission port (587) required
    the ability to listen to multiple incoming ports, including having different behaviors
    depending on the arrival port.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来出现了许多新的标准，这些标准要求对sendmail进行重大更改。例如，添加TLS（加密）需要对大部分代码进行重大更改。SMTP管道需要查看低级TCP/IP流以避免死锁。添加提交端口（587）需要能够监听多个传入端口，并根据到达端口的不同行为。
- en: Other pressures were forced by circumstances rather than standards. For example,
    the addition of the milter interface was a direct response to spam. Although milter
    was not a published standard, it was a major new technology.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其他压力是由情况而非标准造成的。例如，添加milter接口是对垃圾邮件的直接响应。虽然milter不是一个公开的标准，但它是一个重大的新技术。
- en: In all cases, these changes enhanced the mail system in some way, be it increased
    security, better performance, or new functionality. However, they all came with
    costs, in nearly all cases complicating both the code base and the configuration
    file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，这些变化都在某种程度上增强了邮件系统，无论是增加了安全性、提高了性能，还是增加了新功能。然而，它们都伴随着成本，在几乎所有情况下都使代码库和配置文件变得更加复杂。
- en: 17.8\. What If I Did It Today?
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8\. 如果今天我再做一次呢？
- en: Hindsight is 20/20\. There are many things I would do differently today. Some
    were unforeseeable at the time (e.g., how spam would change our perception of
    e-mail, what modern toolsets would look like, etc.), and some were eminently predictable.
    Some were just that in the process of writing sendmail I learned a lot about e-mail,
    about TCP/IP, and about programming itself—everyone grows as they code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 事后诸葛亮。今天有许多事情我会做得不同。有些在当时是无法预料的（例如，垃圾邮件将如何改变我们对电子邮件的看法，现代工具集会是什么样子等），有些是可以预见的。有些只是在编写sendmail的过程中，我对电子邮件、TCP/IP和编程本身有了很多了解——每个人在编程时都在成长。
- en: But there are also many things I would do the same, some in contradiction to
    the standard wisdom.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有许多事情我会做相同的，有些事情与标准智慧相矛盾。
- en: 17.8.1\. Things I Would Do Differently
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.8.1\. 我会做出不同选择的事情
- en: Perhaps my biggest mistake with sendmail was to not recognize early enough how
    important it was going to be. I had several opportunities to nudge the world in
    the correct direction but didn't take them; in fact, in some cases I did damage,
    e.g., by not making sendmail stricter about bad input when it became appropriate
    to do so. Similarly, I recognized that the configuration file syntax needed to
    be improved fairly early on, when there were perhaps a few hundred sendmail instances
    deployed, but decided not to change things because I didn't want to cause the
    installed user base undue pain. In retrospect it would have been better to improve
    things early and cause temporary pain in order to produce a better long-term result.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或许我在sendmail上犯的最大错误是没有及早认识到它将会有多重要。我有几次机会来引导世界朝正确的方向发展，但我没有抓住它们；事实上，在某些情况下，我做了损害，例如，当适当时没有让sendmail对不良输入更加严格。同样，我很早就意识到需要改进配置文件语法，当时可能只有几百个sendmail实例部署了，但我决定不改变事情，因为我不想给已安装的用户群带来不必要的痛苦。回想起来，更好的做法是早点改进事情，引起暂时的痛苦以获得更好的长期结果。
- en: Version 7 Mailbox Syntax
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第7版邮箱语法
- en: One example of this was the way version 7 mailboxes separated messages. They
    used a line beginning "From␣" (where "␣" represents the ASCII space character,
    0x20) to separate messages. If a message came in containing the word "From␣" at
    the beginning of the line, local mailbox software converted it to ">From␣". One
    refinement on some but not all systems was to require a preceding blank line,
    but this could not be relied upon. To this day, ">From" appears in extremely unexpected
    places that aren't obviously related to email (but clearly were processed by email
    at one time or another). In retrospect I probably could have converted the BSD
    mail system to use a new syntax. I would have been roundly cursed at the time,
    but I would have saved the world a heap of trouble.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是第7版邮箱分隔消息的方式。它们使用以"From␣"开头的行（其中"␣"代表ASCII空格字符，0x20）来分隔消息。如果一封消息以"From␣"开头的行进来，本地邮箱软件会将其转换为">From␣"。某些但不是所有系统上的一种改进是需要前置空行，但这不能依赖。直到今天，">From"
    出现在极其意想不到的与电子邮件不明显相关的地方（但显然曾经或多或少地被电子邮件处理过）。回顾起来，我可能本可以将BSD邮件系统转换为使用新语法。当时人们可能会咒骂我，但我会为世界节省大量麻烦。
- en: Syntax and Contents of Configuration File
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置文件的语法和内容
- en: Perhaps my biggest mistake in the syntax of the configuration file was the use
    of tab (HT, 0x09) in rewriting rules to separate the pattern from the replacement.
    At the time I was emulating make, only to learn years later that Stuart Feldman,
    the author of make, thought that was one of his biggest mistakes. Besides being
    non-obvious when looking at the configuration on a screen, the tab character doesn't
    survive cut-and-paste in most window systems.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件的语法方面，我可能犯的最大错误是在重写规则中使用制表符（HT，0x09）来分隔模式和替换内容。当时我在模仿make，直到多年后才了解到make的作者斯图尔特·费尔德曼认为那是他的一大错误之一。除了在屏幕上查看配置时不明显之外，制表符在大多数窗口系统中无法进行剪切和粘贴。
- en: Although I believe that rewriting rules were the correct idea (see below), I
    would change the general structure of the configuration file. For example, I did
    not anticipate the need for hierarchies in the configuration (e.g., options that
    would be set differently for different SMTP listener ports). At the time the configuration
    file was designed there were no "standard" formats. Today, I would be inclined
    to use an Apache-style configuration—it's clean, neat, and has adequate expressive
    power—or perhaps even embed a language such as Lua.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我认为重写规则是正确的想法（请参见下文），但我会改变配置文件的一般结构。例如，我没有预料到配置中需要层次结构（例如，为不同的SMTP监听端口设置不同的选项）。在设计配置文件时，当时没有“标准”格式。如今，我倾向于使用类似Apache样式的配置文件——它清晰、整洁，并且具有足够的表达能力——或者甚至嵌入一种语言，比如Lua。
- en: 'When sendmail was developed the address spaces were small and the protocols
    were still in flux. Putting as much as possible into the configuration file seemed
    like a good idea. Today, that looks like a mistake: we have plenty of address
    space (for an MTA) and the standards are fairly static. Furthermore, part of the
    "configuration file" is really code that needs to be updated in new releases.
    The `.mc` configuration file fixes that, but having to rebuild your configuration
    every time you update the software is a pain. A simple solution to this would
    simply be to have two configuration files that sendmail would read, one hidden
    and installed with each new software release and the other exposed and used for
    local configuration.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当sendmail被开发时，地址空间较小，协议仍在不断发展。尽可能多地放入配置文件中似乎是个好主意。今天看来，那看起来是个错误：我们有足够的地址空间（对于MTA来说），而且标准相对稳定。此外，“配置文件”的一部分实际上是需要在新版本中更新的代码。
    `.mc` 配置文件解决了这个问题，但是每次更新软件时都必须重新构建配置文件很麻烦。一个简单的解决方案就是有两个sendmail会读取的配置文件，一个隐藏的文件，每次新软件发布时安装，并且另一个暴露出来用于本地配置。
- en: Use of Tools
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工具的使用
- en: There are many new tools available today—for example, for configuring and building
    the software. Tools can be good leverage if you need them, but they can also be
    overkill, making it harder than necessary to understand the system. For example,
    you should never use a yacc(1) grammar when all you need is strtok(3). But reinventing
    the wheel isn't a good idea either. In particular, despite some reservations I
    would almost certainly use autoconf today.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 今天有许多新的工具可用，例如，用于配置和构建软件的工具。如果需要，工具可以起到很好的 leverage 作用，但它们也可能过度，使理解系统比必要的更加困难。例如，当你所需的只是strtok(3)时，绝不应该使用yacc(1)语法。但是重新发明轮子也不是一个好主意。特别是，尽管有一些保留，但我几乎肯定会今天使用autoconf。
- en: Backward Compatibility
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向后兼容
- en: With the benefit of hindsight, and knowing how ubiquitous sendmail became, I
    would not worry so much about breaking existing installations in the early days
    of development. When existing practice is seriously broken it should be fixed,
    not accommodated for. That said, I would still not do strict checking of all message
    formats; some problems can be easily and safely ignored or patched. For example,
    I would probably still insert a `Message-Id:` header field into messages that
    did not have one, but I would be more inclined to reject messages without a `From:`
    header field rather than try to create one from the information in the envelope.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有了后见之明，并且知道sendmail变得多么普遍，我不会在开发早期太担心破坏现有的安装。当现有的做法严重有问题时，应该修复，而不是迁就。也就是说，我仍然不会严格检查所有消息格式；有些问题可以很容易地安全地忽略或修补。例如，我可能仍然会在没有`Message-Id：`头字段的消息中插入一个，但我更倾向于拒绝没有`From：`头字段的消息，而不是尝试从信封中的信息创建一个。
- en: Internal Abstractions
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内部抽象
- en: There are certain internal abstractions that I would not attempt again, and
    others that I would add. For example, I would not use null-terminated strings,
    opting instead for a length/value pair, despite the fact that this means that
    much of the Standard C Library becomes difficult to use. The security implications
    of this alone make it worthwhile. Conversely, I would not attempt to build exception
    handling in C, but I would create a consistent status code system that would be
    used throughout the code rather than having routines return `null`, `false`, or
    negative numbers to represent errors.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些内部抽象我不会再尝试，还有一些我会添加。例如，我不会再使用空终止的字符串，而是选择长度/值对，尽管这意味着大部分标准C库变得难以使用。单单这个安全隐患就值得这样做。相反，我不会尝试在C中构建异常处理，但我会创建一个一致的状态码系统，该系统将在整个代码中使用，而不是使例程返回`null`，`false`或负数来表示错误。
- en: I would certainly abstract the concept of mailbox names from Unix user ids.
    At the time I wrote sendmail the model was that you only sent messages to Unix
    users. Today, that is almost never the case; even on systems that do use that
    model, there are system accounts that should never receive e-mail.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我肯定会将邮箱名称的概念从Unix用户ID中抽象出来。在我写sendmail的时候，模型是你只能向Unix用户发送消息。今天，这几乎从不是这样的情况；即使在使用该模型的系统上，也有一些系统账户不应该接收电子邮件。
- en: 17.8.2\. Things I Would Do The Same
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.8.2\. 我会做同样的事情
- en: Of course, some things *did* work well…
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些事情确实*做得不错*...
- en: Syslog
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Syslog
- en: 'One of the successful side projects from sendmail was syslog. At the time sendmail
    was written, programs that needed to log had a specific file that they would write.
    These were scattered around the filesystem. Syslog was difficult to write at the
    time (UDP didn''t exist yet, so I used something called mpx files), but well worth
    it. However, I would make one specific change: I would pay more attention to making
    the syntax of logged messages machine parseable—essentially, I failed to predict
    the existence of log monitoring.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: sendmail的一个成功的副产品之一是syslog。当时写sendmail时，需要记录日志的程序有一个特定的文件，它们会写入。这些文件分散在文件系统中。编写syslog当时很困难（UDP还不存在，所以我使用了一个叫做mpx文件的东西），但非常值得。然而，我会做一个具体的改变：我会更加关注使日志消息的语法可机器解析——基本上，我未能预测到日志监视的存在。
- en: Rewriting Rules
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重写规则
- en: Rewriting rules have been much maligned, but I would use them again (although
    probably not for as many things as they are used for now). Using the tab character
    was a clear mistake, but given the limitations of ASCII and the syntax of e-mail
    addresses, some escape character is probably required. In general, the concept
    of using a pattern-replace paradigm worked well and was very flexible.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重写规则曾经受到很多抨击，但我会再次使用它们（尽管可能不会像现在这样用于很多事情）。使用制表符是一个明显的错误，但考虑到 ASCII 的限制和电子邮件地址的语法，可能需要一些转义字符。总的来说，使用模式替换范式的概念效果很好，并且非常灵活。
- en: Avoid Unnecessary Tools
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免不必要的工具
- en: Despite my comment above that I would use more existing tools, I am reluctant
    to use many of the run-time libraries available today. In my opinion far too many
    of them are so bloated as to be dangerous. Libraries should be chosen with care,
    balancing the merits of reuse against the problems of using an overly powerful
    tool to solve a simple problem. One particular tool I would avoid is XML, at least
    as a configuration language. I believe that the syntax is too baroque for much
    of what it is used for. XML has its place, but it is overused today.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我上面评论说我会使用更多现有工具，但我不太愿意使用当今许多可用的运行时库。在我看来，其中太多的库太过臃肿，以至于危险。库应该谨慎选择，权衡重用的优点和使用过于强大的工具解决简单问题的问题。我要避免使用的一个特定工具是
    XML，至少作为配置语言。我认为它的语法对于它现在所用的很多内容来说过于花哨。XML 有它的用处，但是现在被过度使用了。
- en: Code in C
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C 语言中的代码
- en: 'Some people have suggested that a more natural implementation language would
    be Java or C++. Despite the well-known problems with C, I would still use it as
    my implementation language. In part this is personal: I know C much better than
    I know Java or C++. But I''m also disappointed by the cavalier attitude that most
    object-oriented languages take toward memory allocation. Allocating memory has
    many performance concerns that can be difficult to characterize. Sendmail uses
    object-oriented concepts internally where appropriate (for example, the implementation
    of map classes), but in my opinion going completely object-oriented is wasteful
    and overly restrictive.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有人建议更自然的实现语言是 Java 或 C++。尽管 C 存在众所周知的问题，但我仍然会将其作为我的实现语言。部分原因是个人原因：我比了解 Java
    或 C++ 更了解 C。但我也对大多数面向对象语言对内存分配的漫不经心的态度感到失望。内存分配有许多性能方面的问题，很难描述。Sendmail 在适当的情况下（例如，映射类的实现）在内部使用面向对象的概念，但在我看来，完全面向对象是浪费的，并且过于限制性。
- en: 17.9\. Conclusions
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.9\. 结论
- en: The sendmail MTA was born into a world of immense upheaval, a sort of "wild
    west" that existed when e-mail was ad hoc and the current mail standards were
    not yet formulated. In the intervening 31 years the "e-mail problem" has changed
    from just working reliably to working with large messages and heavy load to protecting
    sites from spam and viruses and finally today to being used as a platform for
    a plethora of e-mail-based applications. Sendmail has evolved into a work-horse
    that is embraced by even the most risk-averse corporations, even as e-mail has
    evolved from pure text person-to-person communications into a multimedia-based
    mission-critical part of the infrastructure.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Sendmail MTA 诞生于一个巨大动荡的世界中，一种在电子邮件是临时性的、当前的邮件标准尚未制定时存在的“荒野”环境中。在这 31 年的时间里，“电子邮件问题”已经从仅仅可靠地工作变成了处理大型消息和大量负载，再到保护站点免受垃圾邮件和病毒的侵害，最终演变成今天被用作大量基于电子邮件的应用程序平台的一部分。Sendmail
    已经发展成为一个被即使是最不愿冒险的公司所接受的工作马，即使在电子邮件已经从纯文本个人之间的通信演变成为基础设施中基于多媒体的使命关键部分的情况下也是如此。
- en: The reasons for this success are not always obvious. Building a program that
    survives and even thrives in a rapidly changing world with only a handful of part-time
    developers can't be done using conventional software development methodologies.
    I hope I've provided some insights into how sendmail succeeded.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种成功的原因并不总是显而易见。在一个只有少数兼职开发人员的快速变化的世界中建立一个能够生存甚至蓬勃发展的程序，无法通过传统的软件开发方法论来实现。我希望我已经提供了一些关于
    sendmail 成功的见解。
