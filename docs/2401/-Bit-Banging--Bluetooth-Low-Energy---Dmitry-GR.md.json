["```\nvoid btLeCrc(const uint8_t* data, uint8_t len, uint8_t* dst){\n\n\tuint8_t v, t, d;\n\n\twhile(len--){\n\t\td = *data++;\n\t\tfor(v = 0; v < 8; v++, d >>= 1){\n\n\t\t\tt = dst[0] >> 7;\n\t\t\tdst[0] <<= 1;\n\t\t\tif(dst[1] & 0x80) dst[0] |= 1;\n\t\t\tdst[1] <<= 1;\n\t\t\tif(dst[2] & 0x80) dst[1] |= 1;\n\t\t\tdst[2] <<= 1;\n\n\t\t\tif(t != (d & 1)){\n\n\t\t\t\tdst[2] ^= 0x5B;\n\t\t\t\tdst[1] ^= 0x06;\n\t\t\t}\n\t\t}\t\n\t}\n}\n```", "```\nvoid btLeWhiten(uint8_t* data, uint8_t len, uint8_t whitenCoeff){\n\tuint8_t  m;\n\n\twhile(len--){\n\n\t\tfor(m = 1; m; m <<= 1){\n\n\t\t\tif(whitenCoeff & 0x80){\n\n\t\t\t\twhitenCoeff ^= 0x11;\n\t\t\t\t(*data) ^= m;\n\t\t\t}\n\t\t\twhitenCoeff <<= 1;\n\t\t}\n\t\tdata++;\n\t}\n}\n```", "```\nstruct adv_hdr{\n\tuint8_t header; //we use 0x40 to say it is a non-connectable undirected\n\t\t\t//advertisement and address we're sending is random (not assigned)\n\tuint8_t dataLen; //length of following data (including MAC addr)\n\tuint8_t MAC[6]; //the mac address\n}\n```", "```\n#include <stdio.h>\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <avr/sleep.h>\n#define F_CPU\t8000000\n#include <avr/delay.h>\n\n#define PIN_CE\t1 //Output\n#define PIN_nCS\t2 //Output\n\n#define MY_MAC_0\t0xEF\n#define MY_MAC_1\t0xFF\n#define MY_MAC_2\t0xC0\n#define MY_MAC_3\t0xAA\n#define MY_MAC_4\t0x18\n#define MY_MAC_5\t0x00\n\nISR(PCINT0_vect)\n{\n\t//useless\n}\n\nvoid btLeCrc(const uint8_t* data, uint8_t len, uint8_t* dst){\n\n\tuint8_t v, t, d;\n\n\twhile(len--){\n\n\t\td = *data++;\n\t\tfor(v = 0; v < 8; v++, d >>= 1){\n\n\t\t\tt = dst[0] >> 7;\n\n\t\t\tdst[0] <<= 1;\n\t\t\tif(dst[1] & 0x80) dst[0] |= 1;\n\t\t\tdst[1] <<= 1;\n\t\t\tif(dst[2] & 0x80) dst[1] |= 1;\n\t\t\tdst[2] <<= 1;\n\n\t\t\tif(t != (d & 1)){\n\n\t\t\t\tdst[2] ^= 0x5B;\n\t\t\t\tdst[1] ^= 0x06;\n\t\t\t}\n\t\t}\t\n\t}\n}\n\nuint8_t  swapbits(uint8_t a){\n\n\tuint8 v = 0;\n\n\tif(a & 0x80) v |= 0x01;\n\tif(a & 0x40) v |= 0x02;\n\tif(a & 0x20) v |= 0x04;\n\tif(a & 0x10) v |= 0x08;\n\tif(a & 0x08) v |= 0x10;\n\tif(a & 0x04) v |= 0x20;\n\tif(a & 0x02) v |= 0x40;\n\tif(a & 0x01) v |= 0x80;\n\n\treturn v;\n}\n\nvoid btLeWhiten(uint8_t* data, uint8_t len, uint8_t whitenCoeff){\n\n\tuint8_t  m;\n\n\twhile(len--){\n\n\t\tfor(m = 1; m; m <<= 1){\n\n\t\t\tif(whitenCoeff & 0x80){\n\n\t\t\t\twhitenCoeff ^= 0x11;\n\t\t\t\t(*data) ^= m;\n\t\t\t}\n\t\t\twhitenCoeff <<= 1;\n\t\t}\n\t\tdata++;\n\t}\n}\n\nstatic inline uint8_t btLeWhitenStart(uint8_t chan){\n\t//the value we actually use is what BT'd use left shifted one...makes our life easier\n\n\treturn swapbits(chan) | 2;\t\n}\n\nvoid btLePacketEncode(uint8_t* packet, uint8_t len, uint8_t chan){\n\t//length is of packet, including crc. pre-populate crc in packet with initial crc value!\n\n\tuint8_t i, dataLen = len - 3;\n\n\tbtLeCrc(packet, dataLen, packet + dataLen);\n\tfor(i = 0; i < 3; i++, dataLen++) packet[dataLen] = swapbits(packet[dataLen]);\n\tbtLeWhiten(packet, len, btLeWhitenStart(chan));\n\tfor(i = 0; i < len; i++) packet[i] = swapbits(packet[i]);\n\n}\n\nuint8_t spi_byte(uint8_t byte){\n\n\tuint8_t i = 0;\n\n\tdo{\n\t\tPORTB &=~ (uint8_t)(1 << 6);\n\t\tif(byte & 0x80) PORTB |= (uint8_t)(1 << 6);\n\t\tCLK |= (uint8_t)(1 << 4);\n\t\tbyte <<= 1;\n\t\tif(PINA & (uint8_t)32) byte++;\n\t\tCLK &=~ (uint8_t)(1 << 4);\n\n\t}while(--i);\n\n\treturn byte;\n}\n\nvoid nrf_cmd(uint8_t cmd, uint8_t data)\n{\n\tcbi(PORTB, PIN_nCS);\n\tspi_byte(cmd);\n\tspi_byte(data);\n\tsbi(PORTB, PIN_nCS); //Deselect chip\n}\n\nvoid nrf_simplebyte(uint8_t cmd)\n{\n\tcbi(PORTB, PIN_nCS);\n\tspi_byte(cmd);\n\tsbi(PORTB, PIN_nCS);\n}\n\nvoid nrf_manybytes(uint8_t* data, uint8_t len){\n\n\tcbi(PORTB, PIN_nCS);\n\tdo{\n\n\t\tspi_byte(*data++);\n\n\t}while(--len);\n\tsbi(PORTB, PIN_nCS);\n}\n\nvoid fob_init (void)\n{\n\tDDRA = (uint8_t)~(1<<5);\n\tDDRB = 0b00000110;\n\tPORTA = 0b10001111;\n\tcbi(PORTB, PIN_CE);\n\tTCCR0B = (1<<CS00);\n\tMCUCR = (1<<SM1)|(1<<SE);\n\tsei();\n}\n\nint main (void)\n{\n\tstatic const uint8_t chRf[] = {2, 26,80};\n\tstatic const uint8_t chLe[] = {37,38,39};\n\tuint8_t i, L, ch = 0;\n\tuint8_t buf[32];\n\n\tfob_init();\n\n\tDDRA |= 4;\n\tPORTA |= 4;\n\n\tnrf_cmd(0x20, 0x12);\t//on, no crc, int on RX/TX done\n\tnrf_cmd(0x21, 0x00);\t//no auto-acknowledge\n\tnrf_cmd(0x22, 0x00);\t//no RX\n\tnrf_cmd(0x23, 0x02);\t//5-byte address\n\tnrf_cmd(0x24, 0x00);\t//no auto-retransmit\n\tnrf_cmd(0x26, 0x06);\t//1MBps at 0dBm\n\tnrf_cmd(0x27, 0x3E);\t//clear various flags\n\tnrf_cmd(0x3C, 0x00);\t//no dynamic payloads\n\tnrf_cmd(0x3D, 0x00);\t//no features\n\tnrf_cmd(0x31, 32);\t//always RX 32 bytes\n\tnrf_cmd(0x22, 0x01);\t//RX on pipe 0\n\n\tbuf[0] = 0x30;\t\t\t//set addresses\n\tbuf[1] = swapbits(0x8E);\n\tbuf[2] = swapbits(0x89);\n\tbuf[3] = swapbits(0xBE);\n\tbuf[4] = swapbits(0xD6);\n\tnrf_manybytes(buf, 5);\n\tbuf[0] = 0x2A;\n\tnrf_manybytes(buf, 5);\n\n\twhile(1){\n\n\t\tL = 0;\n\n\t\tbuf[L++] = 0x40;\t//PDU type, given address is random\nXbuf[L++] = 11;X//17 bytes of payload\n\n\t\tbuf[L++] = MY_MAC_0;\n\t\tbuf[L++] = MY_MAC_1;\n\t\tbuf[L++] = MY_MAC_2;\n\t\tbuf[L++] = MY_MAC_3;\n\t\tbuf[L++] = MY_MAC_4;\n\t\tbuf[L++] = MY_MAC_5;\n\n\t\tbuf[L++] = 2;\t\t//flags (LE-only, limited discovery mode)\n\t\tbuf[L++] = 0x01;\n\t\tbuf[L++] = 0x05;\n\n\t\tbuf[L++] = 7;\n\t\tbuf[L++] = 0x08;\n\t\tbuf[L++] = 'n';\n\t\tbuf[L++] = 'R';\n\t\tbuf[L++] = 'F';\n\t\tbuf[L++] = ' ';\n\t\tbuf[L++] = 'L';\n\t\tbuf[L++] = 'E';\n\n\t\tbuf[L++] = 0x55;\t//CRC start value: 0x555555\n\t\tbuf[L++] = 0x55;\n\t\tbuf[L++] = 0x55;\n\n\t\tif(++ch == sizeof(chRf)) ch = 0;\n\n\t\tnrf_cmd(0x25, chRf[ch]);\n\t\tnrf_cmd(0x27, 0x6E);\t//clear flags\n\n\t\tbtLePacketEncode(buf, L, chLe[ch]);\n\n\t\tnrf_simplebyte(0xE2); //Clear RX Fifo\n\t\tnrf_simplebyte(0xE1); //Clear TX Fifo\n\n\t\tcbi(PORTB, PIN_nCS);\n\t\tspi_byte(0xA0);\n\t\tfor(i = 0 ; i < L ; i++) spi_byte(buf[i]);\n\t\tsbi(PORTB, PIN_nCS);\n\n\t\tnrf_cmd(0x20, 0x12);\t//tx on\n\t\tsbi(PORTB, PIN_CE);\t //do tx\n\t\tdelay_ms(10);\n\t\tcbi(PORTB, PIN_CE);\t(in preparation of switching to RX quickly)\n\t}\n\n\treturn 0;\n}\n\n```"]