<!--yml

category: 未分类

date: 2024-05-27 14:55:41

-->

# SQLite 还是 PostgreSQL？这很复杂！| Twilio

> 来源：[https://www.twilio.com/blog/sqlite-postgresql-complicated](https://www.twilio.com/blog/sqlite-postgresql-complicated)

`run_test()` 函数启动一个或多个线程，根据 `num_threads` 参数。所有线程都配置为并行运行 `test()` 函数。这模拟了来自多个并发客户端的负载，每个客户端都按照自己的随机顺序遍历 URL 列表，以创建一些不可预测性。

在所有线程结束后，`run_test()` 打印每个请求 URL 的平均请求时间，以及所有查询的平均值，这是我决定用于分析的度量标准。

命令行参数允许我传递服务器根目录、API 密钥以及查询的起始日期和结束日期，以及并发量。有了这些控制，我有能力测试各种场景。

测试脚本现在已经准备好了，所以是时候获得一些指标了！

我工作的开发系统是一台具有 6 个超线程核心和 16GB RAM 的 Mac 笔记本电脑。这个仪表板的生产环境是一个 Linode 虚拟服务器，具有 1 个 vCPU 和 2GB RAM。

通过以往的基准测试经验，我知道快速系统的结果并不总是与较慢系统相同，所以我的最终目标是测试生产系统，并根据我在该平台上获得的结果做出决策。

但在这之前，我想在我的笔记本电脑上进行第一轮“练习”测试，既是为了确保测试脚本正常工作，也是因为我对这两个数据库在一个相当强大的平台上的性能表现感到好奇。

我决定使用的测试方法如下：我将测试在两个数据库下运行的系统，查询周期为一周、一个月、一个季度和一年，所有查询的起始日期都为 2021-01-01。我还将使用 1、2 和 4 个并发客户端重复测试。对于每个单独的测试，我将运行脚本三次，并记录三次中的最佳运行结果。我将使用的度量标准是所有查询的总平均值。

依据这个计划，我得到了 24 个数据点（2 个数据库 × 4 个查询周期 × 3 个并发级别）。下图显示了在单个客户端下，PostgreSQL（蓝色）和 SQLite（红色）的响应时间。
