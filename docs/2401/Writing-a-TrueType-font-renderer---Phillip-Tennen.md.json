["```\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n```", "```\nByte 1: 0 0 1 1 0 0 0 0 Byte 2: 0 1 1 1 1 0 0 0 Byte 3: 1 1 0 0 1 1 0 0 Byte 4: 1 1 0 0 1 1 0 0 Byte 5: 1 1 1 1 1 1 0 0 Byte 6: 1 1 0 0 1 1 0 0 Byte 7: 1 1 0 0 1 1 0 0 Byte 8: 0 0 0 0 0 0 0 0\n```", "```\nByte 1: 0x0c Byte 2: 0x1e Byte 3: 0x33 Byte 4: 0x33 Byte 5: 0x3f Byte 6: 0x33 Byte 7: 0x33 Byte 8: 0x00\n```", "```\nuint8_t ascii_map[256][8] = [  // 64 previous entries... {0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00}, // U+0041 (A) {0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00}, // U+0042 (B) {0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00}, // U+0043 (C) {0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00}, // U+0044 (D) {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00}, // U+0045 (E) {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00}, // U+0046 (F) {0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00}, // U+0047 (G) {0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00}, // U+0048 (H) // ... ];\n```", "```\nfn render(ch: char) {  let ch_render_map: [u8; 8] = ascii_bitmaps[ch as u8]; // Neat! for row in ch_render_map.iter() { for col in row.bits().iter() { if col == 1 { // This pixel belongs to the character } else { // This pixel should display the background } } } }\n```", "```\n/// Here, we're modelling a structure that's defined by the TTF specification #[repr(C, packed)] #[derive(Debug, Copy, Clone)] struct OffsetSubtableRaw  {  /// Note each field is wrapped in BigEndianValue scalar_type: BigEndianValue<u32>, num_tables: BigEndianValue<u16>, search_range: BigEndianValue<u16>, entry_selector: BigEndianValue<u16>, range_shift: BigEndianValue<u16>, }   /// This marker trait indicates that this structure sits directly in TTF memory impl  TransmuteFontBufInPlace  for  OffsetSubtableRaw  {}   /// This is our 'high-level' parsed representation #[derive(Debug, Copy, Clone)] struct OffsetSubtable  {  scalar_type: u32, num_tables: u16, search_range: u16, entry_selector: u16, range_shift: u16, }   /// Convert the 'raw' TTF memory representation into our high-level representation with native byte order impl  FromFontBufInPlace<OffsetSubtableRaw>  for  OffsetSubtable  {  fn from_in_place_buf(raw: &OffsetSubtableRaw)  -> Self  { Self  { scalar_type: raw.scalar_type.into_value(), num_tables: raw.num_tables.into_value(), search_range: raw.search_range.into_value(), entry_selector: raw.entry_selector.into_value(), range_shift: raw.range_shift.into_value(), } } }\n```", "```\nlet  offset_table  =  OffsetSubtable::from_in_place_buf(self.read_with_cursor(&mut  cursor));\n```", "```\nenum CompoundGlyphComponentFlag  {  HeaderValuesAreWords, HeaderValuesAreCoordinates, RoundCoordinatesToGrid, CustomScale, MoreComponentsFollow, HasDifferentScalesForXAndY, HasTwoByTwoTransformation, HasInstructions, UseMetricsFromThisComponent, ComponentsOverlap, }\n```", "```\n0x4b  =>  {  // Measure pixels per em in the projection vector's axis if  operations.should_print()  { println!( \"MPPEM\\tMeasure pixels per em in {:?}\", graphics_state.projection_vector ); } if  operations.should_execute()  { let  val  =  match  graphics_state.projection_vector  { Axis::X  =>  graphics_state.font_size.width, Axis::Y  =>  graphics_state.font_size.height, }; graphics_state.push(val  as  u32); } } 0x50  =>  {  // Less than let  e2  =  graphics_state.pop(); let  e1  =  graphics_state.pop(); let  result  =  e1  <  e2; if  operations.should_print()  { println!(\"LT\\tLess than? {e1} < {e2} = {result}\"); } if  operations.should_execute()  { graphics_state.push(if  result  {  1  }  else  {  0  }); } }\n```", "```\npub(crate)  fn identify_functions(instructions: &[u8])  -> Vec<FunctionDefinition>  {  // We have a bootstrapping problem: Functions can't be run to // completion without the context (arguments, etc.) from the caller, but we need to // parse function boundaries before we can run callers since callers address functions via // identifiers that get created when the fpgm table is executed. // To resolve this circular dependency, we use a simple heuristic to identify function // definitions, rather than doing a full interpreter pass. // This has the downside that our heuristic can't tell the // difference between code and data. // If some data is pushed to the stack with the same value as the // function definition opcode, we may interpret it as a function definition. // // ... }\n```"]