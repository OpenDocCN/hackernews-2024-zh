["```\n 1 2 3 4 5 6 7 8 9 10 11 12 \n```", "```\nconfig  const  n  =  5;  // use 5-element arrays in examples by default, for brevity  on  here.gpus[0]  {  var  A:  [1..n]  int;  // declare an array with n elements // (to benefit from GPUs, you'd probably want n >> 5) foreach  i  in  1..n  do A[i]  =  i  *  2;   writeln(\"The whole array A is: \",  A); for  i  in  1..n  do writeln(\"A[\",  i,  \"] = \",  A[i]); } \n```", "```\nexport CHPL_LOCALE_MODEL=gpu \n```", "```\nexport CHPL_GPU_ARCH=your_arch_here \n```", "```\n foreach  i  in  1..n  do A[i]  =  i  *  2; \n```", "```\n for  i  in  1..n  do writeln(\"A[\",  i,  \"] = \",  A[i]); \n```", "```\non  here.gpus[0]  {  var  A:  [1..n]  int;   // ... the rest of the even numbers example } \n```", "```\non  firstLocale  {  var  A:  [0..10]  int; A[0]  =  1;  // Cheap to access 'A': // 'A' is accessed from the same locale that it lives on  on  anotherLocale  { A[0]  =  2;  // More expensive to access 'A': // 'A' is accessed from another locale } } \n```", "```\n14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \n```", "```\nuse  GpuDiagnostics;   proc  startCountingKernelLaunches()  {  resetGpuDiagnostics(); startGpuDiagnostics(); }   proc  numKernelLaunches()  {  stopGpuDiagnostics(); var  result  =  +  reduce  getGpuDiagnostics().kernel_launch; startCountingKernelLaunches(); return  result; }   startCountingKernelLaunches(); \n```", "```\n32 33 34 35 36 \n```", "```\n var  Evens  =  2  *  [1,2,3,4,5]; writeln(Evens);   // One kernel launch from the promoted initializer assert(numKernelLaunches()  ==  1); \n```", "```\n38 39 40 41 42 43 44 45 46 \n```", "```\n use  Math;  // Include the 'Math' module for access to 'sin' and 'pi'  const  numSamples  =  10; var  A  =  [i  in  0..#numSamples]  sin(2  *  pi  *  i  /  numSamples);   writeln(A);   // One kernel launch from the loop expression initializer assert(numKernelLaunches()  ==  1); \n```", "```\n48 49 50 51 52 53 54 55 56 57 \n```", "```\n proc  fib(x:  int):  int  { if  x  <=  1  then  return  1; return  fib(x-1)  +  fib(x-2); }   var  Fibs  =  fib(0..#20); writeln(Fibs);   // One kernel launch from the promoted expression in the initializer assert(numKernelLaunches()  ==  1); \n```", "```\n59 60 61 62 63 64 65 66 67 68 \n```", "```\n var  rows,  cols  =  1..5; var  Square:  [rows,  cols]  int; foreach  (r,  c)  in  Square.indices  do Square[r,  c]  =  r  *  10  +  c;   writeln(\"Original array:\"); writeln(Square);   // Two kernel launches: one from initializing Square, one from the loop assert(numKernelLaunches()  ==  2); \n```", "```\n70 71 72 73 74 75 76 77 78 79 80 81 82 83 \n```", "```\n var  ColSums:  [cols]  int; foreach  c  in  cols  do  { var  sum  =  0;   for  r  in  rows  do sum  +=  Square[r,  c];   ColSums[c]  =  sum; } writeln(\"Column sums:\"); writeln(ColSums);   // Two kernel launches: one from initializing ColSums, one from the loop assert(numKernelLaunches()  ==  2); \n```", "```\n85 \n```", "```\n}  // end of `on here.gpus[0]` \n```", "```\n87 88 89 90 91 92 \n```", "```\ncoforall  loc  in  Locales  do  on  loc  {  coforall  gpu  in  here.gpus  do  on  gpu  { var  Evens  =  2  *  [1,2,3,4,5]; writeln(\"Even numbers computed on \",  gpu,  \": \",  Evens); } } \n```", "```\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 \n```", "```\nconfig  const  n  =  5;  // use 5-element arrays in examples by default, for brevity  on  here.gpus[0]  {  var  A:  [1..n]  int;  // declare an array with n elements // (to benefit from GPUs, you'd probably want n >> 5) foreach  i  in  1..n  do A[i]  =  i  *  2;   writeln(\"The whole array A is: \",  A); for  i  in  1..n  do writeln(\"A[\",  i,  \"] = \",  A[i]); }   use  GpuDiagnostics;   proc  startCountingKernelLaunches()  {  resetGpuDiagnostics(); startGpuDiagnostics(); }   proc  numKernelLaunches()  {  stopGpuDiagnostics(); var  result  =  +  reduce  getGpuDiagnostics().kernel_launch; startCountingKernelLaunches(); return  result; }   startCountingKernelLaunches();   on  here.gpus[0]  {   var  Evens  =  2  *  [1,2,3,4,5]; writeln(Evens);   // One kernel launch from the promoted initializer assert(numKernelLaunches()  ==  1);   use  Math;  // Include the 'Math' module for access to 'sin' and 'pi'  const  numSamples  =  10; var  A  =  [i  in  0..#numSamples]  sin(2  *  pi  *  i  /  numSamples);   writeln(A);   // One kernel launch from the loop expression initializer assert(numKernelLaunches()  ==  1);   proc  fib(x:  int):  int  { if  x  <=  1  then  return  1; return  fib(x-1)  +  fib(x-2); }   var  Fibs  =  fib(0..#20); writeln(Fibs);   // One kernel launch from the promoted expression in the initializer assert(numKernelLaunches()  ==  1);   var  rows,  cols  =  1..5; var  Square:  [rows,  cols]  int; foreach  (r,  c)  in  Square.indices  do Square[r,  c]  =  r  *  10  +  c;   writeln(\"Original array:\"); writeln(Square);   // Two kernel launches: one from initializing Square, one from the loop assert(numKernelLaunches()  ==  2);   var  ColSums:  [cols]  int; foreach  c  in  cols  do  { var  sum  =  0;   for  r  in  rows  do sum  +=  Square[r,  c];   ColSums[c]  =  sum; } writeln(\"Column sums:\"); writeln(ColSums);   // Two kernel launches: one from initializing ColSums, one from the loop assert(numKernelLaunches()  ==  2);   }  // end of `on here.gpus[0]`  coforall  loc  in  Locales  do  on  loc  {  coforall  gpu  in  here.gpus  do  on  gpu  { var  Evens  =  2  *  [1,2,3,4,5]; writeln(\"Even numbers computed on \",  gpu,  \": \",  Evens); } } \n```"]