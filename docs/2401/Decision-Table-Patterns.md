<!--yml

类别：未分类

日期：2024-05-27 14:25:07

-->

# 决策表模式

> 来源：[https://www.hillelwayne.com/post/decision-table-patterns/](https://www.hillelwayne.com/post/decision-table-patterns/)

决策表简单、易懂、而且功能强大。你可以在五分钟内教会别人，并在半分钟内写下一个。你可以看着表格理解它在说什么，看看它是否符合你的问题，并检查设计缺陷。所以很奇怪，在线上基本上没什么关于它们的内容。我以前写过一个[介绍](https://www.hillelwayne.com/post/decision-tables/)，但我想要更正式一点的东西。因此，本文将以更正式的方式重新介绍核心思想，然后讨论一些你可以应用来制作更好表格的技术。

请注意，这是一篇理论性的文章。我还没有在生产环境中测试过所有的内容，并且不能保证它们在实践中表现良好。买方自负。

## 基础知识

决策表将有限枚举的输入映射到输出。输出可以是任何东西：返回的值，副作用，不管是什么，但所有可能的输入都必须映射到一个输出。通过查看表，您就知道应该发生什么。这使它们非常适合进行案例分析和审查需求。

| A | B | C | O |
| --- | --- | --- | --- |
| T | T | T | **1** |
| T | T | F | **3** |
| T | F | T | **7** |
| T | F | F | **0** |
| F | - | - | **2** |

对于这些例子，我们将假设有一个输出 O，除非另有说明。在编码输入方面，涉及更多的技巧，而非输出。

如果每一个可能的输入组合都由一行表示，那么决策表就是**完整**的。如果一行输入没有两次出现并带有两个不同的输出，那么它就是**sound**的。如果它既完整又sound，那么它就是**valid**的。因此，一个有效的表会对应每个可能的输入组合有且只有一行。如果我们有两个布尔型输入和一个3值枚举，那么表将有12行。

由于决策表必须符合规则才能被视为有效，它们被认为是一种**正式规范**的形式。通过形式化，1）我们可以用自动化工具分析表的正确性，2）表的构建错误经常映射到设计本身的错误中。

决策表也被称为帕纳斯表，特别是当它们作为正式验证的一部分时。

### vs. 模式匹配

关于决策表的一个常见问题是“为什么不使用模式匹配？”在许多语言中，我们可以做一些类似这样的事情：

```
let patternMatch a b c =
  match  (a, b, c)  with
  |  (true,  true,  true)  ->  1
  |  (true,  true,  false)  ->  3
  |  (true,  false,  true)  ->  7
  |  (true,  false,  false)  ->  0
  |  (false,  _,  _)  ->  2 
```

那么在已经有执行的情况下。那么为什么使用决策表呢？如果它们不能映射到执行的话？

这是因为决策表是*规范*，而不是代码。模式匹配适用于在代码中表示单个决策。决策表可以表示在任何抽象级别上的决策，无论是针对代码还是整个系统。它们甚至可以表示高级别的非代码决策：

| PR 通过审核？ | PR 通过测试？ | O |
| --- | --- | --- |
| T | T | 合并 |
| T | F | 先修复测试 |
| F | T | 修复审查意见 |
| F | F | 先修复测试 |

模式匹配是语言实现的一部分。决策表更多地是帮助你设计的。

话虽如此，你也可以将决策表看作控制流构造。决策表在规则引擎和大型企业使用的自动化 QA 工具中非常流行。SAP 宣传他们的自动化决策表。我对它们作为规范工具的用途更感兴趣，不会进一步讨论它们作为实现构造的用途。

### 表示无限状态

只要将其映射到有限数量的值，系统可以具有无限数量的状态。我们可以通过将状态分组为“有效相似输入”或**等价类**来实现这一点。然后我们用类替换原始输入。作为一个示例，我们*不能*制作一个“天真”的奇数或偶数表格，因为有无限个正数：

| N | O |
| --- | --- |
| 1 | 奇数 |
| 2 | 偶数 |
| 3 | 奇数 |
| 4 | 偶数 |
| … | … |

由于不是每一个可能的输入都可以表示，这个表格不完整，因此也不有效。我们可以用方程`N % 2`替换数字N。这只有有限数量的输入，并导致一个有效的表格。

我们还可以将输入划分为**区间**：为每个类别的数字给出下限和上限。另一个老生常谈的例子，“这个人在美国可以喝酒吗？”

区间可能是模糊的：`0-21`是否包括0、21或两者？如果两者，如何表示0到21之间的实数，不包括0和21？我们可以在这里适应一些数学符号：`(0, 21)`排除两者，而`[0, 21]`包括两者。

| 年龄 | O |
| --- | --- |
| `[0, 21)` | F |
| `[21, ∞)` | T |

惯例上，缺失的边界被认为延伸到无穷大，所以我们将`[21, ∞)`写成`[21, )`。

## 美观性

这些习惯使决策表看起来更加舒适。我不知道它们是否实际上使它们更好，还是只是装饰。

### 行排序

行应该按照列值排序。最左边的列是最重要的键，然后是第二左边的列，依此类推。换句话说：

这样可以更容易地阅读表格。如果你知道你的输入并正在寻找输出，你可以二分查找值。

所有的值应该以相同的方式排序。如果一列将T放在F之前，其他列不应该将F放在T之前。我强烈倾向于先排序T。

### 列排序

列的顺序应该与某人通过决策时的顺序相匹配。如果你正在为登录流程制作表格，你可能有`valid_user?`和`correct_password?`的条件。由于在拥有用户之前谈论密码没有意义，大多数人会先考虑找到用户。该条件的列应该出现在密码列之前。

更小的考虑是处理`Any`字段（见下文）。表格中具有`-`值的列在表格中的重要性较低，应该放在后面。

我认为`-`规则并不像“最重要的列放在前面”规则那样美观，而且两个规则都不如行规则重要。

### 图例

如果你的字段之一不是布尔值，请显式列出可能性。它可能在表中被隐式定义，但这太容易混淆了。

这个表完整吗？我们不知道。它可能缺少了行`|F, Yellow|`！传说本身不一定要成为表格的一部分，只要读者能从周围的上下文中推断出来即可。让读者知道Q可以取值`{red, blue}`。

## 技术

决策表最常见的问题是膨胀：如果你有五列布尔值，那么你的表将有32行。再加上第六列，你就会有64行。大多数技术都是关于减少膨胀，比如压缩行或者分解表格。

### 任何/-

几乎每个人都这样做。`-`表示“对于任何值”。这两个表是等价的：

| P | Q | O |
| --- | --- | --- |
| T | T | 1 |
| T | F | 1 |
| F | T | 2 |
| F | F | 3 |

`-`对于简化表格很有用。检查完整性很容易，因为你可以将紧凑版本映射到完整版本

在值不遵循`-`的情况下，审美上看起来更愉快。`|T - - F|`看起来很滑稽。有时我会重新排列列以使破折号对齐。但这并不总是可行的，并且可能会使规则的自然流动变得不明显。

`-`存在一些缺陷。首先，你可能会不小心地不严谨，因为每个`-`都会扩展成多行。例如：

这是完整但不严谨的，因为`|T T|`对应于1和2。另一个问题是隐式排序。我们可能会有

很容易将其写成

现在行的顺序很重要！有人可以弄清楚你在这里的意思，但现在不再是显式的了。最好在这里列出事物。

注释：`-`通常表示“任何”，但这并不总是清楚的。很容易认为该符号表示“未知”或“n/a”。如果你有疑虑，最好是明确表示。如果您将`+`用作值，则可能应该使用不同的符号。

#### 输入消除

使用`-`通常会发现某一列是不必要的。考虑下表

| P | Q | O |
| --- | --- | --- |
| T | T | 1 |
| T | F | 1 |
| F | T | 2 |
| F | F | 2 |

我们可以将其简化为

这样决策表可以帮助我们确定某些输入是否对我们的逻辑不必要。

### 表格分解

输出依赖于输入，如果该输入对该输出起到“某种作用”。并非所有输出都可能依赖于所有输入。

| P | Q | O1 | O2 |
| --- | --- | --- | --- |
| T | T | F | T |
| T | F | F | F |
| F | T | T | T |
| F | F | T | F |

O1仅依赖于P，而O2仅依赖于Q。我们可以将这个表拆分成两个较小的表：

分解表格使其更简单，但并不总是正确的选择。如果 O1 和 O2 在概念上相关，这可能会使读者感到困惑。分解也不总是能减小表格的大小。一个结果可能取决于一个值，而另一个可能取决于两个值。

| P | Q | O1 | O2 |
| --- | --- | --- | --- |
| T | T | T | T |
| T | F | T | F |
| F | T | T | T |
| F | F | F | F |

分解此表格将给您带来两个共计六行的表格。另一方面，如果 O1 和 O2 完全是概念上不同的，将它们拆分成单独的表格可能更清晰。正如始终如此，最好的方法高度依赖于具体情况。

### 输入依赖

如果一个输入可以限制另一个输入的值，那么它们之间存在依赖关系。接下来我们来看看下面三个业务规则：

1.  如果表单不存在，则将其重定向到“开始”页面。

1.  如果表单存在但尚未提交，则重定向到“继续”。

1.  如果表单存在并且已经提交，则重定向到“审阅”。

我们可以将其写成两个布尔值：`form_exists?` 和 `submitted?`。只有在表单已经存在时，提交才是一个有意义的布尔值。我们可以将这两个布尔值折叠成一个单独的列，比如 `form_status`：

| `form_status` | O |
| --- | --- |
| `not_started` | “start” |
| `incomplete` | “continue” |
| `submitted` | “review” |

对于更大的表格，这种方法就行不通了。考虑一个具有三个值的登录表格：`password_correct?`、`2auth_enabled?` 和 `2auth_correct?`。如果你不知道密码，那么你是否启用了 2auth 是无关紧要的，如果你禁用了 2auth，那么询问你是否通过了 2auth 就是无意义的。有几种不同的建模方式，都很笨拙。最简单的方法可能是使用另一个符号，如 `/`，告诉读者这是不可能的情况：

| `password-correct?` | `2auth-enabled?` | `2auth-correct?` | O |
| --- | --- | --- | --- |
| T | T | T | 4 |
| T | T | F | 3 |
| T | F | / | 2 |
| F | - | / | 1 |

如果您希望不引入新符号并将布尔值转换为三值逻辑，那么另一种选择是使用 `any`。这有点欺骗性，因为它暗示这一列*有*一个值，只是我们不关心它是什么。它可以工作，但会让逻辑学家感到很悲伤。

#### 陷阱

处理相关输入时，重要的是了解依赖是一个**事实**还是一个**断言**。事实是一种*不可能是*错误的东西。如果我们遇到它是错误的情况，那么软件错误就是我们最不用担心的问题了。这种情况最常见于条件不兼容，只有一个条件可以为真的情况。在这种情况下，我们可以将列折叠成一个枚举。

| `thread1_lock?` | `thread2_lock?` | O |
| --- | --- | --- |
| T | F | 1 |
| F | T | 2 |
| … | … | … |
| `lock_held_by` | O |
| --- | --- |
| None | 1 |
| Thread 1 | 2 |
| Thread 2 | 3 |

相比之下，断言是我们构建系统来保证的东西。实际上它可能是假的，但理想情况下它在我们的系统中永远不是假的。

"理想"是一个危险的词。在这种情况下，我想要明确指出奇异组合不是一件*绝对不可能*发生的事，而是*不应该*发生的事情。这意味着如果*确实*发生了，那就有问题了，我们应该停下来弄清楚。也许我们写了自己的锁定机制而且并不完全确定它的正确性，也许我们担心宇宙射线，无论是什么，这些可能性都应该被明确列举，并且输出应该明确标记为未指定或错误。

| `thread1_lock?` | `thread2_lock?` | O |
| --- | --- | --- |
| T | T | **???** |
| F | F | **错误** |
| … | … | … |

最简单的答案是重新设计系统来处理它，但这可能是不可行的。

### 子表

如果许多输入或输出依赖于一个单独的输入，将其拆分成一个单独的表是有意义的。这两个表应该相互引用。例如请看[这里](https://help.sap.com/viewer/2754875d2d2a403f95e58a41a9c7d6de/1911/en-US/2bccc3ed722d1014a688d77c71096543.html)。我一直在寻找一个好的教学示例，所以只是在此提及以供完整性。

## 更困难的情况

### 独立间隔

在处理间隔时，我们会遇到一个问题，不同的条件可能取决于间隔被划分为不同范围的分区。

| P | Q | O |
| --- | --- | --- |
| T | `[0, 2]` | 1 |
| T | `(2, 10]` | 2 |
| F | `[0, 4)` | 3 |
| F | `[4, 10]` | 4 |

这在处理日期间隔时特别常见，就像我们在[Rose Kata](https://www.hillelwayne.com/requirements/)中看到的一样。问题在于确保完整性。如果我们有两组不同的间隔覆盖，我们就失去了可能值与总行数之间的直接映射。而且很容易意外忽略某些情况。

一种彻底但臃肿的解决方案是将所有间隔合并为一个没有重叠的超集。

| P | Q | O |
| --- | --- | --- |
| T | `[0, 2]` | 1 |
| T | `(2, 4)` | 2 |
| T | `[4, 10]` | 2 |
| F | `[0, 2]` | 3 |
| F | `(2, 4)` | 3 |
| F | `[4, 10]` | 4 |

这使得表更加形式化，但也付出了臃肿和隐藏了底层逻辑的代价。您还需要注意在转换为新分区时的错误，特别是在间隔的边界处。

### 状态

实际上，你应该使用转换表或状态机来形式化状态，但我们可以用决策表处理小问题。如果我们想要一个决策表来表示一个变异，我们需要在表上明确表示出旧值和新值之间的差异。惯例是使用带撇号的变量。如果表变异了`x`，我们写原始值为`x`，新值为`x'`。

| `x % 2 == 0` | `x'` |
| --- | --- |
| T | `x/2` |
| F | `3x+1` |

每个表应该只模拟一个步骤。在表的正文中，`x`总是指旧值，而`x'`根本不应该出现。但是，多个输出可能取决于`x`，因此这对于表示同时变异非常有用：

如果我们需要表示更复杂的更新，我们可以将它分解成一个定义`x'`的表和一个定义`x''`的表：

| `x'` | `x''` |
| --- | --- |
| `(, 0]` | 0 |
| `[1, 50]` | `x'` |
| `[51, )` | 50 |

在决策表中表示状态很快会变得笨拙，并且它不适用于复杂的状态。

#### 更复杂的状态

搞一个该死的状态机

### 当你走得太远时

决策表的语法和语义最小。它们易于使用。但它们也很快就会遇到限制。

我不喜欢说“在不适当的时候不要使用它们”，因为那听起来对我来说是一种自满的避免。这个答案并未给你任何有关它们何时不适用的见解。我们希望明确指出它们何时不适用。

决策表在整个问题可以被离散独立输入建模时效果最好。一旦打破这一点，一切都会崩溃。有时你可以像我们在间隔中所做的那样，细化问题空间，但这只能让你走得更远一点。决策表不适用的其他迹象包括：

+   当你有复杂的数据结构时。如果其中一个输入是整数列表，你的表格会非常庞大。

+   当决策在“时间上”做出时，你必须执行一些效果才能完成决策。决策表模拟瞬时决定。考虑使用流程图。

+   当没有简单的方法将你的数据编码为“显然”完整的表时。如果你的输入是“三个带有排名的事件”，一个完整的表仍然看起来像是缺少了一些行。

+   当表格变得非常庞大时。

+   当表格布局并没有让一切变得更清晰。

## 捷径

你对决策表的严格程度取决于你使用它们的目的。如果你的目标是有一个规范工件，那么你希望尽可能严格。如果你试图明确解决设计问题或基于表格进行高层次项目决策，那么你需要严格。如果你将决策表作为一种思维增强工具，那么可以采取捷径。目标是帮助你更好地思考，过度的形式主义并不总是导致洞察力。

## 最后的思考

决策表是简单易懂且功能强大的。你可以在五分钟内教会别人，并在半个小时内写出来。虽然它们的表达能力有限，但先尝试它们是没有机会成本的。最坏的情况是你花了几分钟才意识到它们不适合你的问题。

如果你想看到决策表在实际应用中的例子，两个很好的例子是[这里](https://github.com/rails/rails/pull/36795#issuecomment-515914165)和[这里](https://twitter.com/jesterxl/status/1222728288117972992)。

希望这能让决策表对你更易于理解。如果你对我的其他写作感兴趣，除了这个网站外，我每周还有两次 [newsletter](https://buttondown.email/hillelwayne/) 关于软件，以及一个 [Twitter](https://twitter.com/hillelogram)，内容涵盖技术、数学、糖果制作和一般的 Twitter 无聊。

*感谢 [Nicolas Rinaudo](https://nrinaudo.github.io/) 的反馈。*
