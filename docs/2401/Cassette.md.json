["```\nimport List\nimport Math\nimport Canvas\nimport System\n\nlet width = 800,\n height = 480,\n canvas = Canvas.new(width, height)\n\ncanvas.text(\"Lines!\", {200, 2})\n\nSystem.seed(System.time())\n\ndef rand-line(i) do\n let x0 = Math.floor(i * width / 100),\n y0 = Math.rand-int(20, height / 10),\n x1 = Math.rand-int(0, width),\n y1 = Math.rand-int(20, height)\n canvas.line({x0, y0}, {x1, y1})\nend\n\nList.map(\\i -> rand-line(i), List.range(0, 100))\n```", "```\n-1\n\n1                 ; decimal integer\n0x1F              ; hex integer\n$a                ; => 0x61\n1.0               ; float\n\n-4                ; => -4\n1 + 2             ; => 3\n5 * 5             ; => 25\n10 / 2            ; => 5.0\n12 % 10           ; => 2\n\n0xF0 >> 4         ; => 0x0F (shift right)\n0x55 << 1         ; => 0xAA (shift left)\n0x37 & 0x0F       ; => 0x07 (bitwise and)\n20 ^ 1            ; => 21   (bitwise or)\n~4                ; => 3    (bitwise not)\n```", "```\n:ok\n:not_found\n\n3 > 1             ; => true\n3 < 3             ; => false\n5 <= 4 + 1        ; => true\n5 >= 4 + 1        ; => true\n:ok == :ok        ; => true\n:ok != :ok        ; => false\n3 > 1 and 4 == 5  ; => false\n3 > 1 or 4 == 5   ; => true\n3 >= 0 and 3 < 5  ; => true\nnil and :ok       ; => false\n:error and :ok    ; => true\n```", "```\n\"Hello!\"\n#\"Hello!\"         ; => 6\n#\"\"               ; => 0\n\n\"Hi \" <> \"there\"  ; => \"Hi there\"\n\"foo\" <> \"bar\"    ; => \"foobar\"\n\n\"ob\" in \"foobar\"  ; => true\n$r in \"foobar\"    ; => true\n65 in \"Alpha\"     ; => true\n1000 in \"foobar\"  ; error: bytes must be between 0â€“255\n```", "```\n[1, 2, 3]         ; list\n[1, 2, 3].2       ; => 3\n[1, 2, 3].8       ; error: out of bounds\n[:a, x, 42]\nnil == []         ; => true\n\n1 | [2, 3, 4]     ; => [1, 2, 3, 4]\n3 | nil           ; => [3]\n1 | 2 | 3 | nil   ; => [1, 2, 3]\n\n#[1, 2, 3]        ; => 3\n#nil              ; => 0\n[1, 2] <> [3, 4]  ; => [1, 2, 3, 4]\n:ok in [:ok, 3]   ; => true\n```", "```\n{1, 2, 3}         ; tuple\n{1, 2, 3}.2       ; => 3\n{1, 2, 3}.8       ; error: out of bounds\n#{1, 2, 3}        ; => 3\n#{}               ; => 0\n{1, 2} <> {3, 4}  ; => {1, 2, 3, 4}\n\"x\" in {\"y\", \"z\"} ; => false\n```", "```\n{x: 3, y: 4}      ; a map with keys `:x` and `:y`\nmy_map.x          ; => 3\nmy_map.z          ; => nil\n\n#{x: 1, y: 2}     ; => 2\n{x: 1, z: 4} <> {x: 2, y: 3}\n ; => {x: 2, y: 3, z: 4}\n:x in {x: 1, y: 2}  ; => true\n```", "```\nlet x = 1, y = 2, x-y = 3\n\nprint(x - y)     ; prints \"-1\"\nprint(x-y)       ; prints \"3\"\n\ndo\n let y = 3, z = 4\n\n x       ; => 1 (from the parent scope)\n y       ; => 3 (shadows the parent `y`)\n z       ; => 4\nend\n\nx         ; => 1\ny         ; => 2\nz         ; error: undefined variable\n```", "```\nif x == 0 do\n IO.print(\"Uh oh!\")\n :error\nelse\n :ok\nend\n\ncond do\n x > 10    -> :ten\n x > 1     -> :one\n true      -> :less  ; default\nend\n```", "```\nlet foo = \\x -> x + 1\nfoo(3)            ; => 4\n\n; equivalent, except for scope:\nlet foo = \\x -> x + 1\ndef foo(x) x + 1\n\n; these produce an error, since `b` isn't defined when the body of `a` is compiled\nlet a = \\x -> b(x * 3),\n b = \\x -> a(x / 2)\n\n; these are ok, since `a` and `b` are in scope from the beginning of the block\ndef a(x) b(x * 3)\ndef b(x) a(x / 2)\n```", "```\n; file \"foo.ct\"\nmodule Foo\n\nlet pi = 3.14\ndef bar(x) x + 1\n```", "```\n; file \"main.ct\"\nimport Foo        ; imported as a map called `Foo`\n\nFoo.bar(3)        ; => 4\nFoo.pi            ; => 3.14\n```", "```\n; alternative \"main.ct\"\nimport Foo as F   ; imported as a map called `F`\n\ndef bar(x) x + 8\n\nbar(3)            ; => 11\nF.bar(3)          ; => 4\n```", "```\n; alternative \"main.ct\"\nimport Foo as *   ; imported directly into current scope\n\nbar(3)            ; => 4\npi                ; => 3.14\n```"]