<!--yml

category: 未分类

date: 2024-05-27 15:00:11

-->

# PHP：一种糟糕设计的分形 / 模糊的便笺

> 来源：[`eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/`](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/)

*（这篇文章已被 Jorge Amado Soria Ramirez（PDF，带有一些补充）翻译成西班牙语 — 感谢！）*

我是个脾气暴躁的人。我抱怨很多事情。在技术世界里有很多我不喜欢的东西，这是可以预料的——编程是一个非常年轻的学科，我们都不知道自己在做什么。再加上[斯特金定律](http://en.wikipedia.org/wiki/Sturgeon%27s_Law)，我有一辈子的事情可以抱怨。

这不一样。PHP 不仅仅是使用起来笨拙，或者不适合我想要的东西，或者是次优的，或者违背我的信仰。我可以告诉你有关我避开的语言的所有好东西，以及我喜欢的语言的所有坏东西。来吧，问问！这会是一次有趣的交谈。

PHP 是唯一的例外。PHP 中几乎每个特性都有些问题。语言、框架、生态系统，全部都很**糟糕**。我甚至不能指出任何一个单一的致命问题，因为损害是如此系统化的。每次我试图列出 PHP 的抱怨清单时，我都会陷入这种深度优先搜索中，发现越来越多令人震惊的琐事。（因此，*分形*。）

PHP 让我感到尴尬，它是我的专业的耻辱。它如此破碎，但又被每一个只学会它而没有学到其他东西的有权势的业余爱好者赞扬，以至于令人发狂。它几乎没有什么可取之处，我宁愿忘记它的存在。

但我必须把这些从我的系统中清除出去。所以，这是最后一次尝试。

我只是向 Mel 脱口而出，以解释我的沮丧，她坚持让我在这里复述一下。

> 我甚至无法说出 PHP 有什么*问题*，因为——好吧。想象一下你有一个，嗯，工具箱。一套工具。看起来还不错，在里面有些标准的东西。
> 
> 你拿出了一个螺丝刀，你看到它是一个那种奇怪的三头的东西。好吧，那对你来说不是很有用，但你猜它有时还是会派上用场的。
> 
> 你拿出了锤子，但令你沮丧的是，它的爪子部分在*两侧*都有。但还算好用，我的意思是，你可以侧着拿着它，用锤子中间的头打钉子。
> 
> 你拿出了钳子，但它们没有那些锯齿状的表面；是平的和光滑的。这不太有用，但它仍然可以很好地拧螺丝钉，所以，无所谓了。
> 
> 然后你继续。盒子里的每样东西都有点奇怪和古怪，但也许不足以使它*完全*无用。而且整体上没有明显的问题；它仍然拥有所有的工具。
> 
> 现在想象一下，你遇到了数百万使用这个工具箱的木匠，他们告诉你“嘿，这些工具有什么问题？这是我一直在用的，而且它们运行良好！” 木匠们向你展示了他们建造的房屋，其中每个房间都是五边形，屋顶倒置。你敲门，前门就坍塌了，他们都对你大喊大叫说你破坏了他们的门。
> 
> 这就是 PHP 的问题所在。

我断言以下这些品质对于使一门语言具有生产力和实用性是*重要*的，而 PHP 则放任不管地违反了它们。如果你不能同意这些至关重要，那么，我无法想象我们如何能在很多事情上达成一致。

+   一门语言必须**可预测**。它是表达人类思想并让计算机执行它们的媒介，因此，人类对程序的理解实际上是*正确*的至关重要。

+   一门语言必须**一致**。相似的事物应该看起来相似，不同的事物则不同。了解语言的一部分应该有助于学习和理解*其余部分*。

+   一门语言必须**简洁**。新语言的存在是为了减少旧语言中固有的样板代码。（我们*可以*都写机器码。）因此，一门语言必须努力避免引入新的自己的样板代码。

+   一门语言必须**可靠**。语言是解决问题的工具；它们应该最小化引入的任何新问题。任何“陷阱”都是巨大的*干扰*。

+   一门语言必须**易于调试**。当出现问题时，程序员*必须*修复它，我们需要尽一切可能的帮助。

我的立场是*如此*：

+   PHP 充满了惊喜：`mysql_real_escape_string`，`E_ALL`

+   PHP 是不一致的：`strpos`，`str_rot13`

+   PHP 需要样板代码：围绕 C API 调用的错误检查，`===`

+   PHP 不可靠：`==`，`foreach ($foo as &$bar)`

+   PHP 是不透明的：默认情况下没有堆栈跟踪或者对致命错误的跟踪，复杂的错误*报告*

我无法为每个问题提供一段评论来解释它为什么属于这些类别，否则这将是无休止的。我相信读者会，就像，*思考*。

我已经在 PHP 争论中*很多次*。我听到很多非常通用的反对意见，这些反对意见实际上只是为了立即停止对话。请不要对我使用这些，请*:(*

+   不要告诉我“优秀的开发者可以用任何语言编写优秀的代码”，或者差劲的开发者之类的。那*没有*任何意义。一个优秀的木匠*可以*用石头或者锤子来钉钉子，但你见过多少木匠用石头乱砸东西？成为优秀开发者的一部分是能够*选择*最适合自己的工具。

+   不要告诉我，开发者的责任是记住一千个奇怪的异常和令人惊讶的行为。是的，这在任何系统中都是必要的，因为计算机很差劲。这并不意味着系统中可以接受多少荒谬之处是没有上限的。PHP 只有异常，当与语言搏斗所花费的精力比编写程序实际花费的精力还要多时，这是不可接受的。我的工具不应该给我创造净正的工作。

+   不要告诉我“这就是 C API 的工作方式”。如果高级语言只提供一些字符串帮助程序和大量的直译 C 封装，那么使用它的意义何在？干脆写 C 吧！这里，甚至还有一个[CGI 库](http://www.boutell.com/cgic/)。

+   不要告诉我“这就是你因为做奇怪的事情而得到的结果”。如果有两个特性存在，总有一天，会有人找到理由将它们结合起来使用。而且，这不是 C；没有规范，也不需要“未定义的行为”。

+   不要告诉我 Facebook 和 Wikipedia 是用 PHP 构建的。我知道！它们也可以用 Brainfuck 写成，但只要有足够聪明的人来解决问题，他们*可以*克服平台的问题。我们只是了解到，如果这些产品用其他语言编写，开发时间可能会减半或翻倍；这个数据点本身并没有什么意义。

+   理想情况下，不要告诉我任何东西！这是我唯一的机会；如果这个列表不能改变你对 PHP 的看法，*没有*什么能够。所以停止在互联网上和某人争论，快去以创纪录的速度制作一个酷炫的网站，证明我是错的 :)

旁观：我超级喜欢 Python。如果你真的想听我唠叨，我也很乐意吐槽它。我不认为它是*完美*的；我只是权衡了它的优点和问题，得出结论它是我想要做的事情的最佳选择。

我从来没有遇到过一个 PHP 开发者能够像对待 PHP 一样对待其他语言。但我遇到过很多对 PHP 所有行为都快速道歉的人。这种心态令人恐惧。

CPAN 曾被称为 Perl 的“标准库”。这并没有多大的意义，但这说明了一个坚实的核心可以构建出伟大的东西。

+   PHP 最初是专门为非程序员（读者可以自行揣摩）设计的；它并没有很好地摆脱自己的根源。摘自[PHP 2.0 文档](http://www.php.net/manual/phpfi2.php#overload)，关于 `+` 和其他运算符进行类型转换的选择性引用：

    > 一旦你开始为每种类型设置单独的运算符，你就会使语言变得更加复杂。即。你不能对字符串使用‘==’，你现在会使用‘eq’。我不明白这样做的意义，特别是对于 PHP 这样的语言，其中大部分脚本将是相当简单的，而且在大多数情况下是由非程序员编写的，他们希望使用一种具有基本逻辑语法的语言，学习曲线不会太高。

+   PHP 被构建为不惜一切代价地继续运行。当面临着要么执行一些荒谬的操作，要么中止并显示错误时，它会执行一些荒谬的操作。任何事情都比什么都不做好。

+   没有明确的设计理念。早期的 PHP 受 Perl 启发；带有“输出”参数的巨大 stdlib 来自 C；面向对象部分设计得像 C++ 和 Java。

+   PHP 从其他语言中汲取了大量灵感，但仍然难以理解对那些 *熟悉* 这些语言的人。`(int)` 看起来像 C，但 `int` 不存在。命名空间使用 `\`。新的数组语法导致 `[key => value]`，在具有哈希字面量的每种语言中都是独一无二的。

+   弱类型（即字符串/数字/等之间的隐式自动转换）是如此复杂，以至于任何微小的程序员工作节省都绝对不值得。

+   很少有新功能实现为新的语法；大多数都是用函数或类似函数的东西完成的。除了类支持，它应该有一堆新的运算符和关键字。

+   此页面列出的一些问题确实有第一方解决方案—如果你愿意为他们的开源编程语言向 Zend 支付修复费用的话。

+   这里有很多远程操作。考虑一下这段代码，摘自 PHP 文档的某处。

    |  |
    | --- |

    ```
    `@fopen('http://example.com/not-existing-file',  'r');` 
    ```

    |

    它会做什么？

    +   如果 PHP 使用 `--disable-url-fopen-wrapper` 编译，它将不起作用。（文档没有说明“不起作用”是什么意思；返回 null，抛出异常？）请注意，此标志已在 PHP 5.2.5 中删除。

    +   如果在 php.ini 中禁用了 `allow_url_fopen`，这仍然不起作用。（怎么不起作用？没有想法。）

    +   因为有 `@`，关于不存在文件的警告将不会被打印出来。

    +   但如果在 php.ini 中设置了 `scream.enabled`，它将被打印出来。

    +   或者如果手动使用 `ini_set` 设置了 `scream.enabled`。

    +   但如果没有设置正确的 `error_reporting` 等级，就不会做。

    +   如果 *被打印出来*，它确切的位置取决于 `display_errors`，同样是在 php.ini 中。或 `ini_set`。

    我无法确定这个无害的函数调用在不查看编译时标志、服务器范围的配置和程序中的配置的情况下会表现出什么行为。而这一切都是 *内置的* 行为。

+   语言充满了全局和隐含的状态。`mbstring` 使用全局字符集。`func_get_arg` 等看起来像常规函数，但是操作的是当前执行的函数。错误/异常处理具有全局默认值。`register_tick_function` 设置一个全局函数在每个时钟周期运行—什么？！

+   没有任何线程支持。（考虑到上述情况，这并不奇怪。）再加上缺乏内置的 `fork`（下文提到），这使得并行编程极其困难。

+   PHP 的部分部分实际上 *被设计成* 产生有 bug 的代码。

    +   `json_decode` 对于无效输入返回 null，尽管 null 也是 JSON 解码的一个完全有效的对象—除非你每次使用它时也调用 `json_last_error`，否则这个函数是 *完全不可靠* 的。

    +   `array_search`、`strpos`和类似的函数在找到 needle 在位置零时返回`0`，但在根本找不到时返回 false。

    让我稍微扩展一下最后一部分。

    在 C 中，像`strpos`这样的函数如果找不到该项则返回`-1`。如果你没有检查这种情况并尝试将其用作索引，你将会访问到垃圾内存，导致程序崩溃。（可能。这是 C。谁 tm 知道。至少有一些工具可以做到这一点。）

    比如说，在 Python 中，等效的`.index`方法如果找不到该项会引发一个异常。如果你没有检查这种情况，你的程序将会崩溃。

    在 PHP 中，这些函数会返回 false。如果你把`FALSE`作为索引使用，或者对它做任何事情，除了与`===`比较，PHP 会悄悄地把它转换为`0`。你的程序不会崩溃；相反，它会*不带任何警告*地执行*错误的操作*，除非你记得在每次使用`strpos`和某些其他函数的地方包含正确的样板。

    这很糟糕！编程语言是工具；它们应该与我*协同工作*。在这里，PHP 实际上为我设置了一个微妙的陷阱，我必须时刻保持警惕，即使在如字符串操作和相等比较这样的平凡事物上也是如此。PHP 是一个*雷区*。

我听过很多关于 PHP 解释器和[其开发者](http://en.wikiquote.org/wiki/Rasmus_Lerdorf)的故事，来自很多地方。这些来自于曾在[PHP 核心](http://www.reddit.com/r/lolphp/comments/qeq7k/php_540_ships_with_82_failing_tests_in_the_suite/)工作过、调试过 PHP 核心、与核心开发者互动过的人。没有一个故事是表扬的。

所以我必须在这里说明一下，因为这值得重复：PHP 是一个业余社区。设计它、开发它或在其中编写代码的人似乎很少知道他们在做什么。（哦，亲爱的读者，*你*当然是一个罕见的例外！）那些*确实*有点头脑的人往往会漂移到其他平台，从而降低整体的平均能力水平。这，就是 PHP 最大的问题所在：它绝对是盲人引导盲人。

好了，回到*事实*上来。

+   没有办法声明一个变量。第一次使用时不存在的变量会被创建为 null 值。

+   全局变量需要在使用之前进行`global`声明。这是上述情况的一个自然结果，所以这是完全合理的，除非全局变量甚至*在没有显式声明的情况下*也无法被*读取* — PHP 将悄悄地创建一个同名的局部变量。我不知道还有哪种语言存在类似的作用域问题。

+   没有引用。PHP 所谓的引用实际上是别名；没有任何向后的步骤，就像 Perl 的引用一样，并且没有像 Python 中的对象标识那样的传递。

+   “引用性” 感染了变量，不像语言中的其他东西那样。PHP 是动态类型的，所以变量通常没有类型……除了引用，它装饰了函数定义、变量语法和赋值。一旦一个变量被设为引用（这可以在任何地方发生），它就会一直保持为引用。没有明显的方法来检测这一点，取消引用需要彻底摧毁变量。

+   好吧，我撒了个谎。还有 “[SPL 类型](http://www.php.net/manual/en/book.spl-types.php)” 也会影响变量：`$x = new SplBool(true); $x = "foo";` 会失败。这就像静态类型，你 懂的。

+   可以对未定义变量（变成数组）中不存在的键取引用。通常使用不存在的数组会发出一个通知，但这 并不会。

+   常量是通过一个接受字符串的函数调用来定义的；在此之前，它们不存在。（这实际上可能是 Perl 的 `use constant` 行为的一个复制。）

+   变量名区分大小写。函数和类名不区分大小写。这包括方法名，这使得驼峰命名法成为一个奇怪的选择。

+   `array()` 和几十个类似的构造不是函数。`array` 本身什么也不表示，`$func = "array"; $func();` 不 起作用。

+   可以使用 `list($a, $b) = ...` 操作进行数组解包。`list()` 是类似函数的语法，就像 `array` 一样。我不知道为什么这不是给予真正专用的语法，或者为什么名称如此明显 混淆。

+   `(int)` 显然设计成像 C 语言一样，但它是一个单一的标记；语言中没有叫做 `int` 的东西。试试吧：`var_dump(int)` 不仅不起作用，而且抛出一个解析错误，因为参数看起来像是类型转换 运算符。

+   `(integer)` 是 `(int)` 的同义词。还有 `(bool)`/`(boolean)` 和 `(float)`/`(double)`/`(real)`。

+   有一个 `(array)` 操作符用于转换为数组，还有一个 `(object)` 用于转换为对象。听起来很疯狂，但几乎有一个用处：你可以使用 `(array)` 有一个既可以是单个项又可以是列表的函数参数，并且对待它们是相同的。除非你不能可靠地做到这一点，因为如果有人传递一个单一的 *对象*，将其转换为数组将实际上产生包含该对象属性的数组。（转换为对象执行相反的 操作。）

+   `include()` 和相关函数基本上是 C 的 `#include`：它们将另一个源文件倒入你的源文件。甚至对于 PHP 代码也没有模块系统。

+   没有嵌套或本地范围的函数或类。它们只是全局的。包含一个文件会将其变量倒入当前函数的作用域（并且给该文件访问你的变量的权限），但是将函数和类倒入全局 作用域。

+   向数组追加使用 `$foo[] = $bar`。

+   `echo` 是一种语句式的东西，不是一个 函数。

+   `empty($var)` 完全不是一个函数，所以除了变量以外的任何东西，例如 `empty($var || $var2)`，都是一个语法错误。为什么解析器需要知道 [`empty`](http://phpsadness.com/sad/28) 是多么不可思议？（在 5.5 中修复）

+   代码块有多余的语法：`if (...): ... endif;`，等等。

+   PHP 的一个独特运算符是 `@`（实际上是从 DOS 借用的），它*抑制*错误。

+   PHP 错误不提供堆栈跟踪。您必须安装一个处理程序来生成它们。（但您不能为致命错误—见下文—安装处理程序。）

+   PHP 的解析错误通常只会输出解析状态，没有更多信息，导致忘记引号的情况[难以调试](http://phpsadness.com/sad/44)。

+   PHP 的解析器在内部将例如 `::` 称为 `T_PAAMAYIM_NEKUDOTAYIM`，将 `<<` 运算符称为 `T_SL`。我说“内部”，但是如上所述，当 `::` 或 `<<` 出现在错误的地方时，这就是向程序员显示的内容。

+   大多数错误处理形式是将一行打印到没有人读取的服务器日志中并继续进行。

+   `E_STRICT` 是一件事情，但似乎并没有真正阻止很多东西，而且对于它实际上是什么没有文档说明。

+   `E_ALL` 包括所有错误类别 —— 除了 `E_STRICT`。（在 5.4 中修复）

+   对允许和不允许的事物非常不一致。我不知道 `E_STRICT` 在这里是如何适用的，但是以下这些事物是*允许的*：

    +   尝试访问不存在的对象属性，即 `$foo->x`。（警告）

    +   使用变量作为函数名、变量名或类名。（无提示）

    +   尝试使用未定义的常量。（注意）

    +   尝试访问非对象的属性。（注意）

    +   尝试使用不存在的变量名。（注意）

    +   `2 < "foo"`（无提示）

    +   `foreach (2 as $foo);`（警告）

    而以下这些事物是*不允许的*：

    +   尝试访问不存在的类常量，即 `$foo::x`。（致命错误）

    +   使用常量字符串作为函数名、变量名或类名。（语法错误）

    +   尝试调用一个未定义的函数。（致命错误）

    +   在代码块或文件的最后一条语句省略分号。（语法错误）

    +   使用 `list` 和其他几个准内置函数作为方法名。（语法错误）

    +   对函数返回值进行下标操作，即 `foo()[0]`。（语法错误；在 5.4 中可以，见上文）

    在此列表的其他地方有很多其他奇怪的解析错误示例。

+   `__toString` 方法不能抛出异常。如果尝试抛出，PHP 将会…… 嗯，抛出一个异常。（实际上是致命错误，这本来还能接受， 但……）

+   PHP 错误和 PHP 异常完全是两种不同的东西。它们似乎*完全不*相互作用。

    +   PHP 错误（内部错误和对 `trigger_error` 的调用）不能使用 `try`/`catch` 捕获。

    +   同样，异常不会触发由 `set_error_handler` 安装的错误处理程序。

    +   相反，有一个单独的 `set_exception_handler` 处理未捕获的异常，因为在 `mod_php` 模型中无法将程序的入口点包装在 `try` 块中。

    +   致命错误（例如，`new ClassDoesntExist()`）无法被任何东西捕获。相当多的相当无害的事情会引发致命错误，以疑问的原因强制结束你的程序。关闭函数仍然运行，但它们无法获得堆栈跟踪（它们在顶层运行），并且它们不能轻松地判断程序是由于错误还是运行到完成而退出。

    +   尝试`throw`一个不是`Exception`的对象会导致… 致命错误，而不是异常。

+   没有`finally`结构，使得包装器代码（设置处理程序、运行代码、取消设置处理程序；猴子补丁，运行测试，取消猴子补丁）繁琐且难以编写。尽管 OO 和异常主要是从 Java 复制过来的，这[是故意的](https://bugs.php.net/bug.php?id=32100)，因为在 PHP 的环境中，`finally`“没有多少意义”。嗯？（在 5.5 中修复。）

+   函数调用显然相当[昂贵](http://www.phpwtf.org/php-function-calls-have-quite-some-overhead)。

+   一些内置函数与返回引用函数交互的方式相当奇怪。 (http://www.phpwtf.org/php-function-calls-returning-references)。

+   如其他地方所述，许多看起来像函数或看起来*应该*是函数的东西实际上是语言构造，因此与函数相关的所有东西都不适用于它们。

+   函数参数可以有“类型提示”，基本上只是静态类型。但是，你不能要求参数是`int`或`string`或`object`或其他“核心”类型，尽管每个内置函数都使用这种类型，可能是因为`int`在 PHP 中不存在。 (参见上面关于`(int)`的内容。) 你也不能使用内置函数大量使用的特殊[伪类型修饰符](http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed)：`mixed`、`number`或`callback`。 (PHP 5.4 允许使用`callable`。)

    +   因此， 这个：

        |  |
        | --- |

        ```
        `function foo(string $s) {}

        foo("hello world");` 
        ```

        |

        产生错误：

        |  |
        | --- |

        ```
        `PHP Catchable fatal error:  Argument 1 passed to foo() must be an instance of string, string given, called in...` 
        ```

        |

    +   注意到，给出的“类型提示”实际上并不一定存在；在这个程序中没有`string`类。如果尝试使用`ReflectionParameter::getClass()`动态检查类型提示，*那么*它会抱怨类不存在，从而无法实际检索类名。

    +   函数的返回值不能被提示。

    +   将当前函数的参数传递给另一个函数（调度，不罕见）是通过`call_user_func_array('other_function', func_get_args())`完成的。但是`func_get_args`在运行时抛出致命错误，抱怨它不能是函数参数。这是如何以及为什么甚至是一种*错误*类型的？（在 PHP 5.3 中修复。）

    +   闭包需要显式命名要封闭的每个变量。为什么解释器不能弄清楚这一点？这在某种程度上束缚了整个功能。 (好吧，因为只要使用一个变量，它就会被创建，除非明确告诉它不这样做。)

    +   闭合的变量与其他函数参数具有相同的语义传递方式。也就是说，数组和字符串等等将按值传递给闭包。除非你使用 `&`。

    +   因为闭合的变量实际上是自动传递的参数，并且没有嵌套作用域，一个闭包不能引用私有方法，即使它是在类内部定义的。（可能在 5.4 版本中修复了？不确定。）

    +   函数没有命名参数。实际上，被开发者明确拒绝，因为它“使代码更乱”。

    +   具有默认值的函数参数可以出现在没有默认值的函数参数之前，尽管文档指出这既奇怪又无用。（那为什么允许呢？）

    +   函数的额外参数将被忽略（除了内置函数，它们会引发错误）。缺少的参数被假定为空。

    +   “变长参数”函数需要使用 `func_num_args`、`func_get_arg` 和 `func_get_args` 进行操作。没有这种语法的东西。

+   PHP 的过程部分设计得像 C 语言，但是对象部分设计得像 Java。我无法过分强调这有多令人不适。类系统是围绕 *更低级别* 的 Java 语言设计的，这种语言自然而然地和故意地*比 PHP 的同时代产品*更受限制，我感到困惑。

    +   我还没有找到一个全局函数的名称中甚至有一个大写字母，然而[重要的内置类](http://www.php.net/manual/en/class.reflectionfunction.php)使用驼峰命名法的方法名称，并且具有类似 Java 的 `getFoo` 访问器。

    +   Perl、Python 和 Ruby 都有通过代码访问“属性”的概念；PHP 只有笨拙的 `__get` 和其它方法。（文档莫名其妙地将这样的特殊方法称为“重载”。）

    +   类具有类似变量声明的东西（`var` 和 `const`）用于类属性，而语言的过程部分则没有。

    +   尽管受到 C++/Java 的重大影响，其中对象相当不透明，但 PHP 通常将对象视为高级散列——例如，`foreach ($obj as $key => $value)` 的默认行为是遍历对象的每个可访问属性。

+   类不是对象。任何元编程都必须通过字符串名称引用它们，就像引用函数一样。

+   内置类型不是对象，并且（不像 Perl）无论如何都不能看起来像对象。

+   `instanceof` 是一个运算符，尽管类是后来才加入的，并且大部分语言是基于函数和类似函数的语法构建的。受到 Java 的影响？类不是第一类对象吗？（我不知道它们是否是。）

    +   但是确实有一个 `is_a` 函数。它有一个可选参数，指定是否允许对象实际上是一个命名类的字符串。

    +   `get_class` 是一个函数；没有 `typeof` 操作符。同样适用于 `is_subclass_of`。

    +   但是这在内置类型上不起作用（再次强调，`int` 不是东西）。为此，你需要 `is_int` 等函数。

    +   另外，右侧必须是一个变量或文字字符串；它不能是一个表达式。这会导致...一个解析错误。

+   `clone`是一个运算符？！

+   对象属性是`$obj->foo`，但类属性是`Class::$foo`。（`$obj::$foo`会尝试将`$obj`转换为字符串并将其用作类名。）类属性无法通过对象访问；命名空间完全独立，使得类属性对多态性完全无用。当然，类*方法*不受此规则限制，可以像任何其他方法一样调用。（我被告知 C++也这样做。C++不是一个良好的面向对象编程的典范。）

+   另外，实例方法仍然可以静态调用（`Class::method()`）。如果从另一个方法中这样做，这会被视为在当前`$this`上调用常规方法。我想。

+   `new`、`private`、`public`、`protected`、`static`等。试图吸引 Java 开发人员？我知道这更多是个人口味，但我不知道为什么在动态语言中需要这些东西——在 C++中，大部分都是关于编译和编译时名称解析的。

+   PHP 对“抽象类”有一流的支持，这些类不能被实例化。类似语言中的代码通过在构造函数中抛出异常来实现这一点。

+   子类无法覆盖私有方法。子类对公有方法的覆盖甚至*都看不到*，更别说调用超类的私有方法了。对于测试模拟（test mocks）来说是有问题的。

+   方法不能命名为例如“list”，因为`list()`是特殊语法（不是一个函数），解析器会混淆。这没有理由会造成歧义，而且对类进行猴子补丁（monkeypatching）也可以正常工作。（`$foo->list()`不是一个语法错误。）

+   如果在评估构造函数的参数时抛出异常（例如，`new Foo(bar())`和`bar()`抛出异常），则构造函数不会被调用，但*析构函数*会被调用。（这在 PHP 5.3 中得到了修复。）

+   `__autoload`和析构函数中的异常会导致致命错误。（在 PHP 5.3.6 中得到修复。所以现在析构函数可能随时抛出异常，因为在引用计数降为零时立即调用。嗯。）

+   没有构造函数或析构函数。`__construct`是一个初始化器，就像 Python 的`__init__`一样。没有可以在类上调用以分配内存并创建对象的方法。

+   没有默认的初始化器。如果超类没有定义自己的`__construct`，则调用`parent::__construct()`将会导致致命错误。

+   面向对象带来了一个迭代器接口，语言的部分部分（例如`for...as`）尊重该接口，但没有内置的东西（例如数组）实际上实现了该接口。如果你想要一个数组迭代器，你必须将其包装在一个`ArrayIterator`中。没有内置的方法来链接或切片或以其他方式处理迭代器作为一级对象。

+   像`Iterator`这样的接口保留了一些未带前缀的方法名。如果你希望你的类可迭代（而不是默认行为迭代所有属性），但想使用像`key`、`next`或`current`这样的常见方法名，那么，很遗憾。

+   类可以重载如何转换为字符串和在被调用时的行为，但不能重载如何转换为数字或任何其他内置类型。

+   字符串、数字和数组都有字符串转换；语言严重依赖于此。函数和类*都是*字符串。然而，尝试将内置或用户定义的对象（甚至是闭包）转换为字符串，如果它没有定义`__toString`，则会导致错误。即使`echo`也可能出现错误。 

+   没有关于相等性或排序的重载。

+   实例方法中的静态变量是全局的；它们在类的所有实例之间共享相同的值。

Perl 是“需要一些装配”。Python 是“电池包含”。PHP 是“综合大杂烩，但它来自加拿大，[两个水龙头都标记为 C](http://www.mcguirehimself.com/?p=117)“。

+   没有模块系统。你可以编译 PHP 扩展，但加载哪些扩展是由 php.ini 指定的，你的选项是扩展是否存在（并将其内容注入到全局命名空间中）。

+   由于命名空间是最近的功能，标准库根本没有被分割。全局命名空间中有数千个函数。

+   该库的部分内容在一致性方面大相径庭。

    +   下划线与否：`strpos`/`str_rot13`，`php_uname`/`phpversion`，`base64_encode`/`urlencode`，`gettype`/`get_class`

    +   “to”与 2：`ascii2ebcdic`，`bin2hex`，`deg2rad`，`strtolower`，`strtotime`

    +   对象+动词与动词+对象：`base64_decode`，`str_shuffle`，`var_dump`与`create_function`，`recode_string`

    +   参数顺序：`array_filter($input, $callback)`与`array_map($callback, $input)`，`strpos($haystack, $needle)`与`array_search($needle, $haystack)`

    +   前缀混淆：`usleep`与`microtime`

    +   大小写不敏感的函数在名称中的`i`放置位置不同。

    +   大约一半的数组函数实际上以`array_`开头。其他则不。

    +   `htmlentities`和`html_entity_decode`是彼此的*逆*，具有完全不同的命名约定。

+   综合大杂烩。该库包括：

    +   绑定到 ImageMagick，绑定到 GraphicsMagick（这是 ImageMagick 的分支），以及一些用于检查 EXIF 数据的函数（ImageMagick 已经可以做到）。

    +   用于解析 bbcode 的函数，这是一种由少数特定论坛软件包使用的非常特定的标记语言。

    +   太多的 XML 包。`DOM`（面向对象），`DOM XML`（不是），`libxml`，`SimpleXML`，“XML Parser”，`XMLReader`/`XMLWriter`，还有一些我无法识别的缩写。这些东西肯定有某种区别，你可以自由去找出这是什么。

    +   绑定到两个特定信用卡处理器，SPPLUS 和 MCVE。什么？

    +   访问 MySQL 数据库的三种方式：`mysql`，`mysqli` 和 `PDO` 抽象物。

这值得单独列出来，因为它是如此荒谬却又弥漫于语言之中。PHP 是一种高级、动态类型的编程语言。然而，标准库的一大部分仍然只是对 C API 的非常薄的包装，产生了以下结果：

+   “Out” 参数，即使 PHP 可以在很少的努力下返回临时哈希或多个参数。

+   至少有十几种从特定子系统获取最后错误的函数（见下文），尽管 PHP 已经有了异常八年了。

+   像 `mysql_real_escape_string` 这样的瑕疵，尽管它与已损坏的 `mysql_escape_string` 具有相同的参数，只是因为它是 MySQL C API 的一部分。

+   针对非全局功能的全局行为（比如 MySQL）。显然，使用多个 MySQL 连接需要在每个函数调用中传递一个连接句柄。

+   这些包装器真的非常、非常、非常薄。例如，调用 `dba_nextkey` 而不调用 `dba_firstkey` 将导致段错误。

+   这些包装器通常是平台特定的：在 Linux 上，`fopen(directory, "r")` 起作用，但在 Windows 上返回 false 并生成警告。

+   有一组 `ctype_*` 函数（比如 `ctype_alnum`），它们映射到类似名称的 C 字符类检测函数，而不是，比如说，`isupper`。

没有。如果一个函数可能需要做两件稍微不同的事情，PHP 就有两个函数。

如何进行反向排序？在 Perl 中，您可能会执行 `sort { $b <=> $a }`。在 Python 中，您可能会执行 `.sort(reverse=True)`。在 PHP 中，有一个名为 `rsort()` 的单独函数。

+   查找 C 错误的函数：`curl_error`，`json_last_error`，`openssl_error_string`，`imap_errors`，`mysql_error`，`xml_get_error_code`，`bzerror`，`date_get_last_errors`，其他吗？ 

+   排序函数：`array_multisort`，`arsort`，`asort`，`ksort`，`krsort`，`natsort`，`natcasesort`，`sort`，`rsort`，`uasort`，`uksort`，`usort`

+   查找文本的函数：`ereg`，`eregi`，`mb_ereg`，`mb_eregi`，`preg_match`，`strstr`，`strchr`，`stristr`，`strrchr`，`strpos`，`stripos`，`strrpos`，`strripos`，`mb_strpos`，`mb_strrpos`，以及执行替换的变体

+   还有很多别名，这显然不会帮助解决问题：`strstr`/`strchr`，`is_int`/`is_integer`/`is_long`，`is_float`/`is_double`，`pos`/`current`，`sizeof`/`count`，`chop`/`rtrim`，`implode`/`join`，`die`/`exit`，`trigger_error`/`user_error`，`diskfreespace`/`disk_free_space`…

+   `scandir` 返回给定目录中的文件列表。而不是（可能有用地）按目录顺序返回它们，该函数返回已经排序好的文件。并且有一个可选参数以获取它们以 *反向* 字母顺序排列。显然，没有足够的排序函数。 （PHP 5.4 添加了一个用于排序方向参数的第三个值，它将禁用排序。）

+   `str_split` 将字符串分割成相等长度的块。`chunk_split` 将字符串分割成相等长度的块，然后用分隔符将它们连接起来。

+   阅读归档需要一组独立的函数，具体取决于格式。有六组不同的此类函数，具有不同的 API，用于 bzip2、LZF、phar、rar、zip 和 gzip/zlib。

+   因为使用数组作为参数调用函数非常麻烦（`call_user_func_array`），所以有一些配对函数如 `printf`/`vprintf` 和 `sprintf`/`vsprintf`。它们做同样的事情，但一个函数接受参数，另一个接受参数数组。

+   带有 `/e`（eval）标志的 `preg_replace` 将匹配的字符串替换为替换字符串，*然后对其进行评估*。

+   `strtok` 显然是根据等效的 C 函数设计的，这本身就是一个坏主意，因为各种各样的原因。别管 PHP 能轻松返回一个数组（而在 C 中这很尴尬），或者 `strtok(3)` 使用的非常巧妙的 hack（在原地修改字符串）在这里不起作用。

+   `parse_str` 解析一个*查询*字符串，但其名称并没有体现这一点。此外，它的行为就像 `register_globals` 一样，将查询转储到您的本地作用域中作为变量，除非您传递一个数组来填充它。（当然，它不返回任何东西。）

+   `explode` 拒绝使用空/缺少的分隔符进行拆分。任何其他地方的字符串拆分实现都会在这种情况下进行一些有用的默认操作；相反，PHP 有一个完全独立的函数，令人困惑地称为 `str_split`，并描述为“将字符串转换为数组”。

+   为了格式化日期，有 `strftime`，它的行为类似于 C API 并且支持地区设置。还有 `date`，它有完全不同的语法，只能用于英文。

+   “[`gzgetss`](http://php.net/manual/en/function.gzgetss.php) — 从 gz 文件指针获取行并删除 HTML 标签。”我很想知道是什么一系列情况导致了这个函数的概念。

+   `mbstring`

    +   当问题是字符集时，一切都与“多字节”有关。

    +   仍然操作常规字符串。有一个全局的“默认”字符集。一些函数允许指定字符集，但这样会应用于所有参数和返回值。

    +   提供了 `ereg_*` 函数，但已经弃用了。`preg_*` 则不幸了，虽然它们可以通过输入一些 PCRE 特定的标志来理解 UTF-8。

+   一般来说，有很多函数模糊了文本和变量之间的界限。`compact` 和 `extract` 只是冰山一角。

+   在 PHP 中实际上有几种实现动态性的方式，乍一看并没有明显的差异或相关的好处。`classkit` 可以修改用户定义的类；`runkit` 取代了它，可以修改用户定义的任何东西；`Reflection*` 类可以反映语言的大部分部分；还有许多用于报告函数和类属性的个别函数。这些子系统是独立的、相关的还是多余的？

+   `get_class($obj)` 返回对象的类名。`get_class()` 返回调用该函数所在类的名称。撇开这个函数有两个完全不同的功能这一事实不谈：`get_class(null)`…的行为类似后者。因此，你不能在任意值上信任它。令人惊讶！

+   `stream_*` 类允许实现自定义流对象，以便与 `fopen` 和其他类似文件的内置函数一起使用。“tell” 无法实现由于[内部原因](https://bugs.php.net/bug.php?id=30157)。（此外，与此系统有关的函数[非常多](http://www.php.net/manual/en/book.stream.php)。）

+   `register_tick_function` 将接受闭包对象。`unregister_tick_function` 不会；相反，它会抛出一个错误，抱怨无法将闭包转换为字符串。

+   `php_uname` 告诉你当前的操作系统。除非 PHP 无法确定它正在运行的系统；然后它告诉你关于它*构建*在哪个操作系统上的信息。它不会告诉你是否发生了这种情况。

+   `fork` 和 `exec` 不是内置的。它们随着 pcntl 扩展一起提供，但默认情况下不包括在内。`popen` 不提供进程标识。

+   `stat` 的返回值被缓存。

+   `session_decode` 用于读取任意的 PHP 会话字符串，但只有在已经存在活动会话时才能工作。而且它将结果转储到 `$_SESSION` 中，而不是返回它。

+   `curl_multi_exec` 在错误时不会改变 `curl_errno`，但会改变 `curl_error`。

+   `mktime` 的参数顺序是：小时、分钟、秒、月份、日期、年份。

程序只不过是一些大型机器，它们吞下数据然后吐出更多数据。许多语言都是围绕着它们处理的数据类型设计的，从 awk 到 Prolog 到 C。如果一种语言不能处理数据，它什么也做不了。

+   整数在 32 位平台上是有符号的且为 32 位。与 PHP 的所有同时代语言不同，没有自动的大整数提升。因此，你可能会遇到意外的负文件大小，而且你的数学运算可能会因为*CPU 架构*不同而有所不同。你唯一的选择是使用 GMP 或 BC 包装函数来处理更大的整数。（开发人员提出了[添加一个新的、单独的、64 位类型](http://www.php.net/~derick/meeting-notes.html#add-a-64bit-integer)。这太疯狂了。）

+   PHP 支持以前导 `0` 开头的八进制语法，所以例如 `012` 将是十进制数十。然而，`08` 变成了零。数字 `8`（或 `9`）和之后的任何数字都会消失。`01c` 是语法错误。

+   `0x0+2` 会得到 4。解析器将 `2` 视为十六进制文字的一部分，同时也是一个独立的十进制文字，将其视为 `0x002 + 2`。`0x0+0x2` 显示相同的问题。奇怪的是，`0x0 +2` 仍然是 4，但 `0x0+ 2` 正确地是 2。（这在 PHP 5.4 中已修复。但在 PHP 5.4 中重新出现，使用新的 `0b` 文字前缀：`0b0+1` 会产生 2。）

+   `pi` 是一个函数。或者有一个常量 `M_PI`。

+   没有指数运算符，只有 `pow` 函数。 

+   不支持 Unicode。只有 ASCII 才能可靠地使用，真的。上面提到了`mbstring`扩展，但有点糟糕。

+   这意味着在 UTF-8 文本上使用内置字符串函数可能会导致损坏。

+   同样地，在 ASCII 之外没有大小写比较的概念。尽管函数的大小写不敏感版本泛滥成灾，但其中没有一个会认为`é`等于`É`。

+   在变量内插时不能引用键，即`"$foo['key']"`是语法错误。你可以取消引号（在其他地方*可能*会生成警告！），或者使用`${...}`/`{$...}`。

+   `"${foo[0]}"`是可以的。`"${foo[0][0]}"`是语法错误。将`$`放在内部对两者都可以。类似 Perl 语法的差劲拷贝（语义却截然不同）？

哦，天哪。

+   这种数据类型充当列表、有序哈希、有序集、稀疏列表，有时甚至是这些的奇怪组合。它的表现如何？将会有什么样的内存使用？谁知道？反正我也没有其他选择。

+   `=>`不是一个操作符。它是一个特殊的结构，只存在于`array(...)`和`foreach`结构中。

+   负索引不起作用，因为`-1`和`0`一样有效。

+   尽管这是语言中唯一的数据结构，但没有它的快捷语法；`array(...)`*是*快捷语法。 （PHP 5.4 正在带来“字面量”，`[...]`。）

+   同样令人困惑的是，数组转化为`Array`并引发一个`E_NOTICE`。

+   `=>`结构是基于 Perl 的，它允许`foo => 1`而不引用。 （事实上，这就是它存在于 Perl 中的原因；否则它只是一个逗号。）在 PHP 中，你不能这样做而不会得到警告；它是其领域中唯一没有经过审查的创建哈希的方法而不引用字符串键。

+   数组函数经常有令人困惑或不一致的行为，因为它们必须在列表、哈希或可能是两者的组合上操作。考虑`array_diff`，它“计算数组的差异”。

    |  |
    | --- |

    ```
    `$first  =  array("foo"  =>  123,  "bar"  =>  456); $second  =  array("foo"  =>  456,  "bar"  =>  123); echo  var_dump(array_diff($first,  $second));` 
    ```

    |

    这段代码会做什么？如果`array_diff`将其参数视为哈希，则显然这些是不同的；相同的键有不同的值。如果它将它们视为列表，那么它们仍然不同；值的顺序是错的。

    实际上`array_diff`认为这些是相等的，因为它将它们视为*集合*：它只比较值，并忽略顺序。

+   类似地，`array_rand`有着奇怪的行为，它选择随机的*键*，这对于最常见的需要从一个列表中选择的情况并不是很有帮助。

+   尽管 PHP 代码严重依赖于保持键的顺序：

    |  |
    | --- |

    ```
    `array("foo", "bar") != array("bar", "foo")
    array("foo" => 1, "bar" => 2) == array("bar" => 2, "foo" => 1)` 
    ```

    |

    我留给读者来想象如果数组被混合会发生什么。（我不知道。）

+   `array_fill`不能创建零长度的数组；相反，它会发出警告并返回`false`。

+   所有的（很多...）排序函数都是原地操作，不返回任何东西。没有办法创建一个新的排序副本；你必须自己复制数组，然后排序它，然后使用数组。

+   但`array_reverse`返回一个新数组。

+   一系列有序的事物和一些键到值的映射听起来有点像处理函数参数的好方法，但*不是*。

+   标准库包含“Quickhash”，这是一个“特定强类型类”的 OO 哈希实现。确实，有四个类，每个类处理不同的键和值类型的组合。不清楚为什么内置数组实现不能针对这些极其常见的情况进行优化，或者相对性能如何。

+   有一个`ArrayObject`类（实现了*五*个不同的接口），可以将数组封装起来，并使其像对象一样操作。用户类可以实现相同的接口。但它只有少数几个方法，其中一半与内置数组函数不太相似，而内置数组函数不知道如何在`ArrayObject`或其他类似数组的类上操作。

+   函数不是数据。闭包实际上是对象，但常规函数不是。你甚至不能仅通过它们的裸名字引用它们；`var_dump(strstr)`会发出警告，并假设你的意思是字面字符串`"strstr"`。没有办法区分任意字符串和函数“引用”之间的差异。

+   `create_function`基本上是`eval`的一个包装器。它创建一个带有常规名称的函数并全局安装它（所以它永远不会被垃圾回收——不要在循环中使用！）。它实际上不知道当前作用域的任何信息，所以它不是闭包。名称包含一个 NUL 字节，因此它永远不会与常规函数冲突（因为如果文件中有`NUL`，PHP 的解析器会失败）。

+   声明一个名为`__lambda_func`的函数将会破坏`create_function`——*实际*的实现是通过`eval`创建名为`__lambda_func`的函数，然后在内部将其重命名为破损的名称。如果`__lambda_func`已经存在，则第一部分会抛出致命错误。

+   对`NULL`进行增量运算（`++`）会产生`1`。对`NULL`进行减量运算（`--`）会产生`NULL`。同样，对字符串进行减量运算会使其保持不变。

+   没有生成器。（在 5.5 中修复。哇。他们基本上克隆了整个 Python 生成器 API。令人印象深刻。然而，`$foo = yield $bar;`却是一个语法错误；它必须是`$foo = (yield $bar)`。叹气。）

+   单个共享文件`php.ini`控制着 PHP 功能的*大*部分，并引入了复杂的规则，关于什么时候覆盖什么以及何时覆盖。期望部署在任意机器上的 PHP 软件仍然必须覆盖设置以规范化其环境，这在很大程度上抵消了类似`php.ini`这样的机制的使用。

    +   PHP 在各种地方寻找`php.ini`，所以可能（或者可能不会……）有可能覆盖你主机的设置。然而，只会解析一个这样的文件，所以你不能仅仅覆盖几个设置然后就完事了。

+   PHP 基本上作为 CGI 运行。每次访问页面时，PHP 都会在执行之前重新编译整个内容。即使是 Python 玩具框架的开发服务器也不会这样。

    这导致了一个“PHP 加速器”的整个市场，只需编译一次，就可以将 PHP 加速到任何其他语言的速度。PHP 背后的公司 Zend 已经将这一点纳入了他们的[商业模式](http://www.zend.com/products/server/)。

+   很长一段时间以来，PHP 错误默认发送到客户端——我想这是为了在开发过程中提供帮助。我认为现在不再是这样了，但我仍然偶尔会在页面顶部看到一些 mysql 错误。

+   PHP 充满了奇怪的“彩蛋”，比如[使用正确的查询参数生成 PHP 标志](http://phpsadness.com/sad/11)。这不仅与构建 *你的* 应用程序完全无关，而且允许检测你是否正在使用 PHP（也许还能大致猜测版本），无论你正在进行多少 `mod_rewrite`、FastCGI、反向代理或 `Server:` 配置。

+   在 `<?php ... ?>` 标签之前或之后的空行，即使在库中，也被视为文字，并插入到响应中（或导致“头已发送”错误）。你的选择要么严格避免每个文件末尾的额外空行（`?>` 后的那个不算），要么干脆不写 `?>` 结束标记。

部署经常被认为是 PHP 的最大优势：放置一些文件就可以了。确实，这比你可能不得不在 Python 或 Ruby 或 Perl 中运行一个完整的进程要容易得多。但 PHP 留下了许多不足之处。

在各个方面，我支持将 Web 应用程序作为应用程序服务器运行，并对其进行反向代理。设置这一点所需的工作量很小，而好处很多：你可以分别管理你的 Web 服务器和应用程序，你可以在任意数量的机器上运行任意多或少的应用程序进程而无需更多的 Web 服务器，你可以零成本地将应用程序作为不同的用户运行，你可以更换 Web 服务器，你可以在不触及 Web 服务器的情况下关闭应用程序，你可以通过只改变一个 FIFO 指向的位置来实现无缝部署等等。把你的应用程序与你的 Web 服务器绑定在一起是荒谬的，而且没有任何好的理由再这样做了。

+   PHP 自然与 Apache 绑定在一起。单独运行它，或与任何其他 Web 服务器一起运行，需要和部署任何其他语言一样多的折腾（可能更多）。

+   `php.ini` 适用于任何地方运行的每个 PHP 应用程序。只有一个 `php.ini` 文件，并且它是全局的；如果你在一个共享服务器上需要更改它，或者如果你运行两个需要不同设置的应用程序，你就没戏了；你必须应用所有必要设置的并集，并通过在应用程序内部使用 `ini_set` 或在 Apache 的配置文件或 `.htaccess` 中逐步剔除它们。如果你可以的话。还有哇，你需要检查那么多地方才能弄清楚一个设置是如何得到它的值的。

+   同样地，没有简单的方法来“隔离”一个 PHP 应用程序及其依赖项与系统的其他部分。运行需要不同版本库或甚至 PHP 本身的两个应用程序？首先构建第二个 Apache 的副本。

+   “一堆文件”方法不仅使路由变得非常麻烦，还意味着你必须仔细地列出或列出不可用的内容，因为你的 URL 层次结构也是整个代码树。配置文件和其他“局部文件”需要类似 C 的保护以防止它们被直接加载。版本控制噪声（例如 `.svn`）需要保护。使用 `mod_php`，你文件系统上的 *一切* 都是潜在的入口点；而使用应用服务器，只有一个入口点，只有 URL 控制是否调用它。

+   除非你想让用户在升级过程中访问你的网站，否则无法无缝地升级一堆运行 CGI 风格的文件，因为这会导致崩溃和未定义的行为。

+   尽管配置 Apache 以运行 PHP 看起来“简单”，但即使在那里也有一些微妙的陷阱。虽然 PHP 文档建议使用 `SetHandler` 让 `.php` 文件作为 PHP 运行，但 `AddHandler` 看起来同样有效，实际上谷歌给了我两倍多的结果。这就是问题所在。

    当你使用 `AddHandler` 时，你告诉 Apache “执行这个作为 php” 是处理 `.php` 文件的 *一种可能的* 方法。 **但**！Apache 并不像地球上的每个人那样理解文件扩展名。它设计为支持，比如 `index.html.en` 被同时识别为英语和 HTML。对于 Apache，一个文件可以同时具有 *任意数量* 的文件扩展名。

    想象一下你有一个文件上传表单，它将文件转储到某个公共目录中。为了确保没有人上传 PHP 文件，你只需检查它们是否没有 `.php` 扩展名。攻击者所需做的就是上传一个名为 `foo.php.txt` 的文件；你的上传程序看不出问题，但 Apache *会* 将其识别为 PHP，并且它会愉快地执行。

    这里的问题不是“使用原始文件名”或“验证不够好”; 问题在于你的 Web 服务器配置为运行任何它遇到的旧代码 —— 这恰恰是 PHP “易于部署”的属性。CGI 需要 `+x`，这是 *一种*，但 PHP 甚至没有这样做。这不是一个理论上的问题；我发现有多个实际站点存在此问题。

我认为所有这些都是构建 Web 应用程序的关键因素的不同级别。PHP 的主要卖点是它是一种“网络语言”，因此合理的做法是它应该有一些这样的功能。

+   没有模板系统。有 PHP 本身，但没有像一个大的内插器而不是程序那样的东西。

+   没有 XSS 过滤器。不，“记得使用 `htmlspecialchars`”不是 XSS 过滤器。[这才是。](http://pypi.python.org/pypi/MarkupSafe)

+   没有 CSRF 保护。你必须自己来做。

+   没有通用的标准数据库 API。像 PDO 这样的东西必须包装每个单独数据库的 API 来抽象掉差异。

+   没有路由。你的网站看起来就像你的文件系统一样。许多开发人员被骗以为`mod_rewrite`（以及`.htaccess`总体上）是可以接受的替代品。

+   没有身份验证或授权。

+   没有开发服务器。（在 5.4 中“修复”。导致下面的`Content-Length`漏洞。此外，你必须将所有重写规则端口到 PHP 包装器中，因为没有路由。）

+   没有交互式调试。

+   没有统一的部署机制；只有“将所有这些文件复制到服务器上”。

PHP 的安全声誉很差主要是因为它会将来自一种语言的任意数据转储到另一种语言中。这是一个坏主意。`"<script>"`在 SQL 中可能没有任何意义，但在 HTML 中确实有意义。

更糟糕的是，普遍呼吁“清理你的输入”。那完全是*错误*的；你不能挥舞魔杖使一块数据本质上“干净”。你需要做的是说出语言：在 SQL 中使用占位符，在生成进程时使用参数列表，等等。

+   PHP 直接*鼓励*“清理”：有一个专门的[data 过滤扩展](http://www.php.net/manual/en/book.filter.php)来做这个。

+   所有的`addslashes`，`stripslashes`以及其他与反斜杠相关的废话都是不帮助的干扰信息。

+   据我所知，没有安全地生成进程的方法。你只能通过 shell 执行一个字符串。你的选择是疯狂地转义并希望默认的 shell 使用正确的转义，或者*手动*使用`pcntl_fork`和`pcntl_exec`。

+   `escapeshellcmd`和`escapeshellarg`都存在，描述大致相似。请注意，在 Windows 上，`escapeshellarg`不起作用（因为它假定 Bourne shell 语义），而`escapeshellcmd`只是将一堆标点符号替换为空格，因为没有人能够弄清楚 Windows cmd 的转义（这可能会悄悄地破坏你正在尝试的任何事情）。

+   原始的内置 MySQL 绑定，仍然被广泛使用，没有办法创建准备好的语句。

直到今天，[PHP 关于 SQL 注入的文档](http://www.php.net/manual/en/security.database.sql-injection.php)仍然推荐像类型检查、使用`sprintf`和`is_numeric`、到处手动使用`mysql_real_escape_string`或者到处手动使用`addslashes`（这“可能会有用”！）这样疯狂的做法。除了用户评论，没有提到 PDO 或参数化。至少两年前我向一位 PHP 开发者*具体*抱怨过这个问题，他感到震惊，但页面从未改变过。

+   `register_globals`。现在已经默认关闭一段时间了，在 5.4 中已经移除。我不在乎。这是一种*尴尬*。

+   `include`接受 HTTP URL。同样地。

+   魔术引号。离默认安全很近，但离完全理解概念还差得很远。同样地。

+   你可以，比如说，使用 PHP 的 XML 支持来 [探测网络](http://www.idontplaydarts.com/2011/02/scanning-the-internal-network-using-simplexml/)，通过滥用它对文件名作为 URL 的支持。只有 `libxml_disable_entity_loader()` 可以解决这个问题，而且这个问题只在手册评论中提到过。

（5.5 带来了一个名为 `password_hash` 的立即执行密码哈希函数，这应该会减少手动编写的加密代码。）

PHP 解释器本身也存在一些 *令人着迷的* 安全问题。

+   2007 年，解释器存在整数溢出漏洞。修复从 `if (size > INT_MAX) return NULL;` 开始，[由此而引发的问题](http://use.perl.org/use.perl.org/_Aristotle/journal/33448.html) 不断恶化。（对于不熟悉 C 语言的人：`INT_MAX` 是能够容纳的最大整数。我希望你能从中推断出其他的。）

+   更近些时候，PHP 5.3.7 成功地包含了一个 `crypt()` 函数，事实上，它会让 *任何人* 使用 *任何密码* [登录](https://bugs.php.net/bug.php?id=55439)。

+   PHP 5.4 的开发服务器容易受到拒绝服务攻击，因为它会接受 `Content-Length` 标头（任何人都可以将其设置为任何值）并尝试分配相同数量的内存。 [这是个糟糕的主意。](http://www.exploit-db.com/exploits/18665/)

我可以挖掘更多，但关键不在于存在多少漏洞——软件存在漏洞，这是正常的，无论如何。而是这些漏洞的 *性质* 令人恐惧。我没有刻意寻找它们；它们只是在过去几个月里不期而至地降临到我门前。

一些评论正确指出我没有结论。嗯，事实上我没有结论。如果你一路读到这里，我认为你在开始之前就已经同意了我的观点 :)

如果你只懂 PHP，并且想学习其他东西，可以试试 [Python 教程](http://docs.python.org/tutorial/) 和 [Flask](http://flask.pocoo.org/) 用于网络部分。（我不是它的模板语言的铁杆粉丝，但它做了它的工作。）它会拆分你的应用程序的各个部分，但它们仍然是相同的部分，应该看起来足够熟悉。我可能稍后会写一篇真正的文章；对整个语言和网络堆栈的快速介绍不应该放在这里。

更多时候或者对于更大的项目，你可能需要选择 [Pyramid](http://www.pylonsproject.org/)，它是中等级别的，或者 [Django](https://www.djangoproject.com/)，它是一个复杂的怪物，适用于构建像 Django 这样的站点。

如果你根本不是开发人员但仍然因某种原因阅读这篇文章，我只有在全球每个人都完成了 [Learn Python The Hard Way](http://learnpythonthehardway.org/) 后才会感到满意，所以去做吧。

Ruby 也是一种选择，与 Rails 一起使用，还有一些竞争对手我从未使用过，Perl 仍然与 Catalyst 一起活跃着。阅读、学习、建设，疯狂地去做吧。

特别感谢以下内容的 *灵感*：

如果您有任何补充意见，或者我在某些事情上（事实上！）错误，请告诉我。
