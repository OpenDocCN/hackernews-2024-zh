- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:49:21'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Passing nothing is surprisingly difficult
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://davidben.net/2024/01/15/empty-slices.html](https://davidben.net/2024/01/15/empty-slices.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Passing nothing is surprisingly difficult
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[David Benjamin](/) (2024-01-15)'
  prefs: []
  type: TYPE_NORMAL
- en: 'My day job is in [browsers](https://www.chromium.org/) and [cryptography](https://boringssl.googlesource.com/boringssl/),
    not compilers, yet I often find that I need to spend more of my time working through
    the semantics of programming languages than using them. This post discusses a
    thorny cross-language issue between C, C++, and Rust. In short:'
  prefs: []
  type: TYPE_NORMAL
- en: C’s rules around pointers and `memcpy` leave no good ways to represent an empty
    slice of memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++’s pointer rules are fine, but `memcpy` in C++ inherits the C behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust FFI is not [zero-cost](https://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html).
    Rust picked a C/C++-incompatible slice representation, requiring a conversion
    in each direction. Forgetting the conversion is an easy mistake and unsound.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rust slices appear to *also* be incompatible with Rust pointer arithmetic,
    to the point that the standard library’s slice iterator is unsound. (Update 2024-01-16:
    It sounds like this is [in the process of being fixed](https://github.com/rust-lang/rust/issues/117945)!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As FFI challenges inherently span multiple languages, I wrote this mostly to
    have one common reference that describes the mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All three languages allow working with *slices*, or contiguous sequences of
    objects in memory. (Also called [spans](https://en.cppreference.com/w/cpp/container/span),
    but we’ll use “slices” here.) A slice is typically a pointer and a length, `(start,
    count)`, giving `count` objects from `start`, of some type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: A slice can also be specified by two pointers, `(start, end)`, giving the objects
    from `start` (inclusive) to `end` (exclusive). This is better for iteration because
    only one value needs to be adjusted to advance, but the length is less available.
    C++ iterator pairs are a generalization of this form, and Rust slice iterators
    use this internally. The two forms can be converted with `end = start + count`
    and `count = end - start`, using C-style pointer arithmetic where everything is
    scaled by the object size. We’ll primarily discuss `(start, count)`, but this
    duality means slices are closely related to pointer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: In C and C++, slices are, at best, library types built out of pointers and lengths.
    Sometimes functions just take or return pointer and length separately, but still
    use it to represent a slice of memory. In Rust, slices are language primitives,
    but the underlying components are exposed for unsafe code and FFIs. To work with
    each of these, we must understand what combinations of pointers and lengths are
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is straightforward for a positive-length slice: `start` must point within
    an allocation where there are at least `count` objects of type `T`. But suppose
    we want an empty (length zero) slice. **What are the valid representations of
    an empty slice?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Certainly we can point `start` within (or just past) some array of `T`s and
    set `count` to zero. But we may want to make an empty slice without an existing
    array. For example, a default-constructed `std::span<T>()` in C++ or `&[]` in
    Rust. What are our options then? In particular:'
  prefs: []
  type: TYPE_NORMAL
- en: Can an empty slice be `(nullptr, 0)`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can an empty slice be `(alignof(T), 0)`, or some other aligned address that
    doesn’t correspond to an allocation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second question may seem odd to C and C++ folks, but Rust folks may recognize
    it as `[std::ptr::NonNull::dangling](https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.dangling)`.
  prefs: []
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ is the easiest to discuss, as it has a formal specification and is (almost)
    self-consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `(nullptr, 0)` is a valid empty slice in C++. The STL’s types [routinely
    return it](https://eel.is/c++draft/span.cons#2), and the language is compatible
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(T*)nullptr + 0` is [defined](https://eel.is/c++draft/expr.add#4.1) to be
    `(T*)nullptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(T*)nullptr - (T*)nullptr` is [defined](https://eel.is/c++draft/expr.add#5.1)
    to be `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ defines APIs like `std::span` in terms of [pointer addition](https://eel.is/c++draft/span.cons#4.1)
    for the `(start, count)` form, and iterator pairs in terms of [pointer subtraction](https://eel.is/c++draft/iterator.operations#5)
    for the `(start, end)` form, so this is both necessary and sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, it would be impractical for C++ to forbid `(nullptr, 0)`. C++ code
    routinely needs to interact with APIs that specify slices as individual components.
    Given such an API, *no one* writes code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It is much more natural to use `nullptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This means, to be practical, functions like `takes_a_slice` must accept `(nullptr,
    0)`. For implementing such functions to be practical, the underlying language
    primitives must then also accept `(nullptr, 0)`.
  prefs: []
  type: TYPE_NORMAL
- en: As for the `(alignof(T), 0)` question, pointer [addition](https://eel.is/c++draft/expr.add#4.2)
    and [subtraction](https://eel.is/c++draft/expr.add#5.2) require the pointers point
    to some object and that the operation stays within the bounds of that object (or
    one past the end). C++ does not define there to be an object at `alignof(T)`,
    so this is not allowed, instead producing Undefined Behavior. This has no immediate
    usability concern (no one is going to write `reinterpret_cast<uint8_t*>(1)` to
    call `takes_a_slice`), but we’ll see later that it has some consequences for Rust
    FFIs.
  prefs: []
  type: TYPE_NORMAL
- en: '(Update 2024-01-16: Added the following paragraph, as this shorthand seems
    to have been unclear.)'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, *in principle*, nothing stops `takes_a_slice` from defining its own
    unique rules for these corner cases. Beyond what the type system naturally provides,
    user code will rarely formally define semantics, and we must instead look to fuzzier
    conventions and expectations. Sadly, in C and C++, these fuzzier aspects often
    include well-definedness. When all the slice-adjacent language primitives consistently
    use the same preconditions for slice components, a naively written function will
    match. This is then a reasonable default interpretation for `takes_a_slice`’s
    preconditions. When this post discusses “the” rules for slices for C++ or C, it
    is in part a shorthand for this emergent convention.
  prefs: []
  type: TYPE_NORMAL
- en: However, C++ is merely *almost* self-consistent. C++ picks up `memcpy` and other
    functions from C’s standard library, complete with C’s semantics…
  prefs: []
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C is messier. For the same reasons discussed above, it is impractical to reject
    `(NULL, 0)`. However, C’s language rules make it difficult for a function to accept
    it. C does not have C++’s special cases for `(T*)NULL + 0` and `(T*)NULL - (T*)NULL`.
    See clauses 8 and 9 of section 6.5.6 of [N2310](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf).
    `memcpy` and the rest of the C standard library similarly [forbid](https://www.imperialviolet.org/2016/06/26/nonnull.html)
    `(NULL, 0)`.
  prefs: []
  type: TYPE_NORMAL
- en: I think **this should be considered a bug in the C specification**, and compilers
    should not [optimize based on it](https://gcc.gnu.org/gcc-4.9/porting_to.html).
    In [BoringSSL](https://boringssl.googlesource.com/boringssl/), we found the C
    rules so unusable that we resorted to [wrapping the standard library](https://boringssl.googlesource.com/boringssl/+/17cf2cb1d226b0ba2401304242df7ddd3b6f1ff2%5E%21/)
    with `n != 0` checks. The pointer arithmetic rules are similarly a [tax](https://boringssl.googlesource.com/boringssl/+/6be491b7bb57c3950d4fbb97fdd4a141e3fa4d63%5E%21/)
    [on](https://boringssl.googlesource.com/boringssl/+/4984e4a6325e9c6302f846c7bf2b75e8ea3fd9dd%5E%21/)
    [development](https://boringssl.googlesource.com/boringssl/+/3c6085b6ae982a80633bf5369c274036702c6848%5E%21/).
    Moreover, C++ inherits C’s standard library (but not its pointer rules), including
    this behavior. In Chromium’s C++ code, `memcpy` has been the single biggest blocker
    to [enabling UBSan](https://bugs.chromium.org/p/chromium/issues/detail?id=1394755).
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is hope. [Nikita Popov](https://www.npopov.com/2024/01/01/This-year-in-LLVM-2023.html#zero-length-operations-on-null)
    and Aaron Ballman have written a [proposal](https://docs.google.com/document/d/1guH_HgibKrX7t9JfKGfWX2UCPyZOTLsnRfR6UleD1F8/edit)
    to fix this in C. (Thank you!) While it won’t make C and C++ safe by any stretch
    of imagination, this is an easy step to fix an unforced error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, apart from contrived examples with deleted null checks, the current
    rules do not actually help the compiler meaningfully optimize code. A `memcpy`
    implementation cannot rely on pointer validity to speculatively read because,
    even though `memcpy(NULL, NULL, 0)` is undefined, slices at the end of a buffer
    are fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If `buf` were at the end of a page with nothing allocated afterwards, a speculative
    read from `memcpy` would break.
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust does *not* allow `(nullptr, 0)`. Functions like `std::slice_from_raw_parts`
    [require the pointer to be non-null](https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html).
    This comes from Rust treating types like `&[T]` and `*[T]` as analogous to `&T`
    and `*T`. They are “references” and “pointers” that are represented as `(start,
    count)` pairs. Rust requires every pointer type to have a “null” value outside
    its reference type. This is used in `enum` layout optimizations. For example,
    `Option::<&[T]>` has the same size as `&[T]` because `None` uses this null value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, Rust chose `(nullptr, 0)` for the null slice pointer, which
    means the empty slice, `&[]`, cannot use it. That left Rust having to invent an
    unusual convention: some non-null, aligned, but otherwise dangling pointer, usually
    `(alignof(T), 0)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Is pointer arithmetic defined for this slice? From what I can tell, the answer
    appears to be no! (Update 2024-01-16: It sounds like this is [in the process of
    being defined](https://github.com/rust-lang/rust/issues/117945)!)'
  prefs: []
  type: TYPE_NORMAL
- en: Pointer arithmetic in Rust is spelled with the methods `[add](https://doc.rust-lang.org/std/primitive.pointer.html#method.add)`,
    `[sub_ptr](https://doc.rust-lang.org/std/primitive.pointer.html#method.sub_ptr)`,
    and `[offset_from](https://doc.rust-lang.org/std/primitive.pointer.html#method.offset_from)`,
    which the standard library defines in terms of [allocated objects](https://doc.rust-lang.org/std/ptr/index.html#allocated-object).
    That means, for pointer arithmetic to work with `alignof(T)`, there must be zero-size
    slices allocated at every non-zero address. Moreover, `offset_from` requires the
    two dangling pointers derived from the same slice to point to the “same” of these
    objects. While the third bullet [here](https://doc.rust-lang.org/std/ptr/index.html#safety),
    second sentence, says casting literals gives a pointer that is “valid for zero-sized
    accesses”, it says nothing about allocated objects or pointer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, these semantics come from LLVM. The Rustonomicon has [more to say
    on this](https://doc.rust-lang.org/nomicon/vec/vec-alloc.html#:~:text=The%20other%20corner%2Dcase%20we%20need%20to%20worry%20about%20is%20empty%20allocations)
    (beginning “The other corner-case…”). It concludes that, while there are infinitely
    many *zero-size* types at `0x01`, Rust conservatively assumes alias analysis does
    *not* allow offsetting `alignof(T)` with zero for *positive-sized* types. This
    means **Rust pointer arithmetic rules are incompatible with Rust empty slices.**
    But recall that slice iteration and pointer arithmetic are deeply related. The
    Rustonomicon’s [sample iterator](https://doc.rust-lang.org/nomicon/vec/vec-into-iter.html)
    uses pointer arithmetic, but needs to guard addition with `cap == 0` in `into_iter`
    and cast to `usize` in `size_hint`.
  prefs: []
  type: TYPE_NORMAL
- en: This is too easy for programmers to forget. Indeed the real Rust slice iterator
    does pointer arithmetic unconditionally ([pointer addition](https://github.com/rust-lang/rust/blob/76101eecbe9aa80753664bbe637ad06d1925f315/library/core/src/slice/iter.rs#L94),
    [pointer subtraction](https://github.com/rust-lang/rust/blob/76101eecbe9aa80753664bbe637ad06d1925f315/library/core/src/slice/iter/macros.rs#L57),
    behind [some](https://github.com/rust-lang/rust/blob/76101eecbe9aa80753664bbe637ad06d1925f315/library/core/src/slice/iter/macros.rs#L141)
    [macros](https://github.com/rust-lang/rust/blob/76101eecbe9aa80753664bbe637ad06d1925f315/library/core/src/slice/iter.rs#L132)).
    This suggests **Rust slice iterators are unsound.**
  prefs: []
  type: TYPE_NORMAL
- en: FFIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beyond self-consistency concerns, all this means Rust and C++ slices are incompatible.
    Not all Rust `(start, count)` pairs can be passed into C++ and vice versa. C’s
    issues make its situation less clear, but the natural fix is to bring it in line
    with C++.
  prefs: []
  type: TYPE_NORMAL
- en: This means Rust FFI is not [“zero-cost”](https://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html).
    **Passing slices between C/C++ and Rust requires conversions in both directions
    to avoid Undefined Behavior.**
  prefs: []
  type: TYPE_NORMAL
- en: More important (to me) than performance, this is a safety and ergonomics problem.
    Programmers cannot be expected to memorize language specifications. If given a
    `&[T]` and trying to call a C API, the natural option is to use `[as_ptr](https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr)`,
    but that will return a C/C++-incompatible output. Most Rust crates I’ve seen which
    wrap C/C++ APIs do not convert and are unsound as a result.
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly an issue because C and C++’s (more serious) safety problems
    cause [real user harm](https://security.googleblog.com/2021/09/an-update-on-memory-safety-in-chrome.html)
    and need addressing. But there is half a century of existing C and C++ code. We
    cannot realistically address this with a new language without good FFI. What makes
    for good FFI? At a bare minimum, I think **calling a C or C++ function from Rust
    should not be dramatically less safe than calling that function from C or C++.**
  prefs: []
  type: TYPE_NORMAL
- en: Wishlist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Empty lists should not be so complicated. We could change C, C++, and Rust
    in a few ways to improve things:'
  prefs: []
  type: TYPE_NORMAL
- en: Make C accept `nullptr`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See Nikita Popov and Aaron Ballman’s [proposal](https://docs.google.com/document/d/1guH_HgibKrX7t9JfKGfWX2UCPyZOTLsnRfR6UleD1F8/edit).
  prefs: []
  type: TYPE_NORMAL
- en: Fix Rust’s slice representation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the `alignof(T)` problems ultimately come from Rust’s unusual empty slice
    representation. This falls out of Rust’s need for a “null” `*[T]` value that is
    not a `&[T]` value. Rust could have chosen any of a number of unambiguously unused
    representations, such as `(nullptr, 1)`, `(nullptr, -1)`, or `(-1, -1)`.
  prefs: []
  type: TYPE_NORMAL
- en: While this would be a significant change now, with compatibility implications
    to work through, I think it is worth seriously considering. It would address the
    root cause of this mess, fixing a soundness hazard in not just Rust FFI, but Rust
    on its own. This hazard is real enough that Rust’s standard library hits it.
  prefs: []
  type: TYPE_NORMAL
- en: This is also the only option I see that fully meets Rust’s “zero-cost” FFI [goals](https://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html).
    Even if we make C and C++ accept `(alignof(T), 0)` from Rust (see below), any
    slices passed from C/C++ to Rust may still be `(nullptr, 0)`.
  prefs: []
  type: TYPE_NORMAL
- en: Define pointer arithmetic for invalid pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If Rust leaves its slice representation as is, we instead should define pointer
    arithmetic for `NonNull::dangling()`. Expecting low-level Rust code to guard all
    pointer offsets is impractical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update 2024-01-16: Happily, it sounds like this is already [in the process
    of being defined](https://github.com/rust-lang/rust/issues/117945)!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where `nullptr` is a single value which could just be special-cased, there
    are many `alignof(T)` values. It seems one would need to define it in terms of
    the actual allocated objects. This is well beyond my expertise, so I’ve likely
    gotten all the details and terminology wrong, but one possibility is, in the vein
    of [PNVI-ae-udi](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2364.pdf):'
  prefs: []
  type: TYPE_NORMAL
- en: '`cast_ival_to_ptrval` returns a special `@empty` provenance when casting garbage
    values (unchanged from PNVI-ae-udi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding zero to a pointer with the `@empty` provenance is valid and gives back
    the original pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two pointers with `@empty` provenance can be subtracted to give zero if they
    have the same address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One subtlety, however, is that `cast_ival_to_ptrval` might not give back `@empty`
    if there is an object at that address. Giving back a concrete provenance means
    picking up [pointer-zapping](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2443.pdf)
    semantics, which would be undesirable here. For `alignof(T)`, that shouldn’t happen
    if the maximum alignment is under a page and the bottom page is never allocated.
    But Rust allows not just `alignof(T)` but [any non-zero integer literal](https://doc.rust-lang.org/std/ptr/index.html#safety),
    *even if some allocation happens to exist at that address*. (Perhaps we could
    use the “user-disambiguation” aspect and say all integer-to-pointer casts may
    additionally disambiguate to `@empty`? Would that impact the compiler’s aliasing
    analysis?)
  prefs: []
  type: TYPE_NORMAL
- en: I think this complexity demonstrates why `nullptr` is a much better choice for
    an empty slice than a dangling pointer. Pointer arithmetic with `nullptr` is easy
    to define, and `nullptr` cannot alias a real allocation.
  prefs: []
  type: TYPE_NORMAL
- en: If Rust (and LLVM) accepted invalid pointers, it would fix the soundness issues
    within Rust, but not with FFIs. If the C and C++ standards *also* picked this
    up, it would *partially* fix FFIs. We could then directly pass Rust slices into
    C and C++, but not in the other direction. Directly passing C and C++ slices into
    Rust can only be fixed by changing Rust to accept `(nullptr, 0)` form.
  prefs: []
  type: TYPE_NORMAL
- en: '~~(Outside of Rust FFI, there’s no reason to use `alignof(T)` as a pointer
    in C/C++, so I do not know how plausible it would be for C/C++ to accept it.)~~
    Update 2024-01-16: Nelson Elhage reminded me that non-null sentinel pointers are
    sometimes used to [allocate zero bytes](https://github.com/torvalds/linux/blob/ffc253263a1375a65fa6c9f62a893e9767fbebfa/include/linux/slab.h#L167-L178).
    While C forbids `malloc` from doing this (`malloc(0)` must return either `nullptr`
    or a *unique* non-null pointer), other allocators might reasonably pick this option.
    It makes error checks more uniform without actually reserving address space. So
    there is a non-Rust reason to allow these pointers in C and C++.'
  prefs: []
  type: TYPE_NORMAL
- en: FFI helpers in Rust standard library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the languages’ slice representations cannot be made compatible, we’re still
    left with safety hazards in Rust FFI. In that case, Rust’s standard library should
    do more to help programmers pick the right operations: Add analogs of `slice::from_raw_parts`,
    `slice::as_ptr`, etc., that use the C and C++ representation, converting internally
    as needed. Document existing functions very clear warnings that they cannot be
    used for FFI. Finally, audit all existing calls in crates.io, as the majority
    of existing calls are likely for FFI.'
  prefs: []
  type: TYPE_NORMAL
- en: For `slice::from_raw_parts`, we could go further and fix the existing function
    itself. This would be backwards-compatible, but adds unnecessary conversions to
    non-FFI uses. That said, if the crates.io audit reveals mostly FFI uses, that
    conversion may be warranted. For non-FFI uses, a type signature incorporating
    `[std::ptr::NonNull](https://doc.rust-lang.org/std/ptr/struct.NonNull.html)` would
    have been more appropriate anyway.
  prefs: []
  type: TYPE_NORMAL
- en: This would improve things, but it’s an imperfect solution. We’d still sacrifice
    zero-cost FFI, and we’d still rely on programmers to read the warnings and realize
    the natural options are incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks to Alex Chernyakhovsky, Alex Gaynor, Dana Jansens, Adam Langley, and
    Miguel Young de la Sota for reviewing early iterations of this post. Any mistakes
    in here are my own.
  prefs: []
  type: TYPE_NORMAL
