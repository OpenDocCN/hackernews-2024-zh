["```\nlet mut sound_handle = audio.play(\"sound.mp3\");\nsound_handle.set_volume(0.5); \n```", "```\naudio_producer.push(audio_data);\nwhile let Some(audio_data) = audio_consumer.pop() {\n  play_audio(audio_data); } \n```", "```\nstruct SoundHandle {\n  playback_state: PlaybackState,\n  sound: Arc<Mutex<Sound>>, } \n```", "```\nimpl SoundHandle {\n  pub fn set_playback_state(&self, playback_state: PlaybackState)  {\n    sound.lock().unwrap().playback_state = playback_state; }\n\n  pub fn set_volume(&self, volume: f32)  {\n    sound.lock().unwrap().volume = volume; } } \n```", "```\nstruct Sound {\n  playback_state: Arc<AtomicU8>,\n  volume: Arc<AtomicU32>, } \n```", "```\nstruct SoundHandle {\n  playback_state: Arc<AtomicU8>,\n  volume: Arc<AtomicU32>, } \n```", "```\nimpl SoundHandle {\n  pub fn set_playback_state(&self, playback_state: PlaybackState)  {\n    self.playback_state.store(playback_state as u8, Ordering::SeqCst); }\n\n  pub fn set_volume(&self, volume: f32)  {\n    self.volume.store(volume.to_bits(), Ordering::SeqCst); } } \n```", "```\nstruct VolumeChange {\n  volume: f32,   duration: Duration,   easing: Easing, } \n```", "```\nenum SoundCommand {\n  SetPlaybackState(PlaybackState),\n  SetVolume(f32), } \n```", "```\nstruct SoundHandle {\n  command_producer: Producer<SoundCommand>, }\n\nimpl SoundHandle {\n  pub fn set_playback_state(&self, playback_state: PlaybackState)  {\n    self.command_producer.push(\n      SoundCommand::SetPlaybackState(playback_state), ); }\n\n  pub fn set_volume(&self, volume: f32)  {\n    self.command_producer.push(SoundCommand::SetVolume(volume)); } } \n```", "```\nstruct Sound {\n  playback_rate: PlaybackRate,\n  volume: f32,\n  command_consumer: Consumer<SoundCommand>, }\n\nimpl Sound {\n    pub fn update(&mut self)  {\n    while let Some(command) = self.command_consumer.pop() {\n      match command {\n        SoundCommand::SetPlaybackRate(playback_rate) => {\n          self.playback_rate = playback_rate; }\n        SoundCommand::SetVolume(volume) => {\n          self.volume = volume; } } } } } \n```", "```\nCommand {\n  PlaySound(AudioData),\n  SetSoundPlaybackRate(PlaybackRate),\n  SetSoundVolume(f32), } \n```", "```\nCommand {\n  PlaySound(AudioData),\n  SetSoundPlaybackRate(SoundId, PlaybackRate),\n  SetSoundVolume(SoundId, f32), } \n```", "```\nstruct SoundHandle {\n  sound_id: SoundId,\n  command_producer: Arc<Mutex<Producer<Command>>>, } \n```", "```\nwhile let Some(command) = command_consumer.pop() {\n  match command {\n    Command::PlaySound(audio_data) => play_sound(audio_data),\n    Command::SetSoundPlaybackState(sound_id, playback_state) => {\n      if let Some(sound) = get_sound_by_id(sound_id) {\n        sound.playback_state = playback_state; } }\n    Command::SetSoundVolume(sound_id, volume) => {\n      if let Some(sound) = get_sound_by_id(sound_id) {\n        sound.volume = volume; } } } } \n```", "```\nuse indexmap::IndexMap;\n\nfn main()  {\n  let mut map = IndexMap::with_capacity(10);\n  for i in 0..1000 {\n    map.insert(i, i);\n    println!(\"{} / {}\", map.len(), map.capacity());\n    if i % 5 == 0 {\n      map.swap_remove_index(i / 2);\n      map.swap_remove_index(i / 3);\n      map.swap_remove_index(i / 4); } } } \n```", "```\n28 / 28\n26 / 26 // capacity decreases\n27 / 27\n28 / 28\n29 / 56\n30 / 56 \n```"]