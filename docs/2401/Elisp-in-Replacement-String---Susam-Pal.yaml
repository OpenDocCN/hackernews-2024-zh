- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:43:12'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Elisp in Replacement String - Susam Pal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://susam.net/maze/elisp-in-replacement-string.html](https://susam.net/maze/elisp-in-replacement-string.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <main>
  prefs: []
  type: TYPE_NORMAL
- en: Elisp in Replacement String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By **Susam Pal** on 09 Jan 2024
  prefs: []
  type: TYPE_NORMAL
- en: It is likely well known among Emacs users that the following key sequence starts
    a search-and-replace operation to match strings with the regular expression pattern
    `f..` and replace the matches with `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the following key sequence looks for strings that match a pattern
    that has two capturing groups and replaces each match with a new string that swaps
    the substrings matched by the capturing groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For example, this operation matches a string like `foo-bar` and replaces it
    with `bar-foo`. A string like `postfix-boxing` becomes `postbox-fixing`. The backreference
    `\1` refers to the string matched by the first capturing group `\(f..\)` and similarly
    `\2` refers to the string matched by the second capturing group `\(b..\)`. The
    replacement string then swaps the positions of the matches in both capturing groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'What may be less commonly known is the ability to utilise Elisp expressions
    to dynamically compute portions of the replacement strings. To employ this feature,
    simply write `\,` (i.e., backslash and comma) followed by the Elisp expression
    in the replacement string. Consider the following key sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The backreference `\&` refers to the whole match. We pass it as the argument
    to the Elisp function `upcase`. This function converts its argument to upper-case.
    This example searches for strings that match the pattern `f..` and replaces each
    match with the upper-case form of the match. A string like `foo-bar` is replaced
    with `FOO-bar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another slightly more sophisticated example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The backreference `\#1` refers to the string matched by the first capturing
    group `\([0-9]+\)` as a *number*. The Elisp expression in the replacement pattern
    simply adds `1000` to that number and replaces the matched string with the result.
    A string like `host:80` becomes `host:1080`. Another string like `localhost:8000`
    becomes `localhost:9000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is an example from the real world of text editing where this
    feature was useful to me recently while solving a text editing problem. Consider
    the following text buffer with a list of numbered items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: While this is a toy example presented here for the sake of simplicity and clarity,
    this example is based on an actual text editing problem I encountered recently.
    In my actual problem though, there were more words on each line and there were
    some arbitrary paragraphs of text between every consecutive pair of items. Further,
    the list was long with 50 or so items. The problem now was to remove item number
    3 and renumber all the lines below it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is quite straightforward to remove item 3\. Just move the point (cursor)
    to that line and type `C-S-<backspace>` or `C-a C-k` to kill that line. We get
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we now renumber all the items starting from `4) cat`? This is where
    the support for Elisp expressions in replacement strings turns out to be useful.
    First move the point to the beginning of that line. Then type the following key
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The search pattern captures the item number on each line in a capturing group.
    The replacement string contains an Elisp expression that subtracts one from this
    number. Thus a string like `### 4` gets replaced with `### 3`. After completing
    the replacement, the buffer looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I hope this was useful. Do you have an interesting Elisp-in-replacement-string
    story? Please share it in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: </main>
  prefs: []
  type: TYPE_NORMAL
