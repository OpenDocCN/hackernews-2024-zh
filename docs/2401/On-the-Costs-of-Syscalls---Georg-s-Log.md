<!--yml

类别：未分类

日期：2024-05-27 15:22:06

-->

# 对系统调用成本的探究 | George's Log

> 来源：[`gms.tf/on-the-costs-of-syscalls.html`](https://gms.tf/on-the-costs-of-syscalls.html)

众所周知，[系统调用](https://zh.wikipedia.org/wiki/系统调用)是昂贵的。而软件对抗[CPU 漏洞](https://zh.wikipedia.org/wiki/崩溃 _(计算机安全))（如熔断）甚至使它们变得更加昂贵。但它们真的有多昂贵？为了开始回答这个问题，我写了一个小的[微基准](https://github.com/gsauthof/osjitter/blob/master/bench_syscalls.cc)来衡量系统调用的最小成本。这意味着不管是否发生上下文切换，甚至在内核工作微不足道时，也就是从[用户模式切换到内核模式](https://zh.wikipedia.org/wiki/上下文切换#用户模式和内核模式切换)和切换回去的成本。

## 方法

用户内核模式切换[微基准](https://zh.wikipedia.org/wiki/基准测试 _(计算机))使用了 Google 的[基准库](https://github.com/google/benchmark)进行测量，并且可在[git 存储库](https://github.com/gsauthof/osjitter/blob/master/bench_syscalls.cc)中获得。该存储库还包含一些辅助脚本，例如一个[playbook](https://github.com/gsauthof/osjitter/blob/master/helper/bench_playbook.py)，用于将其分发到一组主机并在其上执行。基准库重复每个案例，直到结果被认为是稳定的，playbook 允许重复执行测试用例。在以下各节中，报告了 100 次重复的中位数值（实际时间以纳秒为单位）。

对于基准测试，调用了一堆预期非常便宜的系统调用，比如获取用户 ID（UID）、程序 ID（PID）、关闭无效文件描述符、调用不存在的系统调用等。因此，一个测量应该真的只包括两次模式切换。作为对照，一些情况下不调用系统调用，而是执行其他廉价的操作。

我在一组异构主机上运行了基准测试，即不同的内核、操作系统和配置。有关更多详细信息，还请参阅主机部分。

## 结果和讨论

以下表格显示了不同情况下的实际时间（纳秒）：

| 主机 | 5i4250u | 7i6600u | ac3758 | x2643 | x2667h | x2667s | x2687w | x2689 | x2690 | xg6144 | xg6148 | xg6246 | xg6256 | xg6256b | xs4110 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 名称 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 分配 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| clock_gettime | 23 | 21 | 31 | 19 | 16 | 16 | 17 | 14 | 21 | 14 | 24 | 14 | 13 | 13 | 24 |
| clock_gettime_mono | 23 | 22 | 32 | 16 | 16 | 16 | 17 | 14 | 21 | 15 | 24 | 14 | 13 | 13 | 24 |
| clock_gettime_mono_raw | 23 | 22 | 33 | 542 | 544 | 350 | 582 | 332 | 762 | 660 | 427 | 274 | 122 | 290 | 218 |
| clock_gettime_tai | 23 | 21 | 32 | 542 | 546 | 352 | 587 | 333 | 762 | 660 | 427 | 274 | 122 | 292 | 218 |
| close | 568 | 262 | 275 | 484 | 495 | 283 | 514 | 277 | 668 | 610 | 356 | 243 | 93 | 257 | 145 |
| getpid | 558 | 257 | 255 | 2 | 1 | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 1 | 1 | 2 |
| getuid | 560 | 231 | 259 | 464 | 473 | 276 | 505 | 259 | 649 | 592 | 347 | 224 | 78 | 239 | 137 |
| nothing | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| pthread_cond_signal | 3 | 2 | 6 | 14 | 13 | 12 | 14 | 11 | 15 | 10 | 17 | 10 | 10 | 10 | 17 |
| sched_yield | 706 | 374 | 430 | 569 | 560 | 414 | 634 | 346 | 773 | 694 | 454 | 280 | 126 | 300 | 232 |
| sqrt | 6 | 2 | 15 | 4 | 4 | 4 | 4 | 1 | 7 | 1 | 3 | 1 | 1 | 1 | 3 |
| sqrtrec | 4 | 4 | 15 | 2 | 3 | 2 | 3 | 2 | 3 | 3 | 5 | 3 | 3 | 3 | 5 |
| syscall | 560 | 252 | 265 | 440 | 460 | 269 | 497 | 243 | 620 | 579 | 345 | 221 | 76 | 233 | 136 |

### 控制

作为对照的情况包括“nothing”，字面上什么都不做；“assign”，只是给一个变量赋值；`sqrt`，计算一个小常数的平方根；`sqrtrec`，放置一堆平方根调用。对于这些情况的结果都是合理的，即什么都不做实际上测量出来只有 `10**-7` 纳秒左右，赋值成本大约为 0.5 纳秒左右，计算平方根只需几纳秒。也许最显著的结果是，在 Atom CPU（ac3758）上计算平方根相对于两种情况来说是非常一致的，而在其他主机上，其运行时间取决于其参数。

### 时钟获取时间

查看系统调用时，一个所有主机上都成立的关系是 `clock_gettime(CLOCK_REALTIME)` 系统调用要比 `getuid()` 或 `close()` 快得多。这可以解释为，在 Linux 上， `clock_gettime(CLOCK_REALTIME)` 和 [另外几个系统调用](https://manpath.be/f34/7/vdso#L334) 都是通过高效的 [vDSO](https://en.wikipedia.org/wiki/VDSO) 机制实现的。也就是说，当它们被调用时不会发生模式切换！

`clock_gettime()` 支持不同的时钟，并非所有内核上的所有时钟都经过 vDSO 优化。该表显示，在 RHEL 7 上查询 `CLOCK_MONOTIC_RAW` 和 `CLOCK_TAI` 会调用真正的系统调用，而在 Fedora 33 内核（5.12/5.13）上，这些时钟读数也作为 vDSO 实现。

### 虚假信号

类似地，虚假的 `pthread_cond_signal()` 情况，即在没有任何人监听的情况下发出信号，要比真正的系统调用便宜得多——因为 C 库不必调用真正的系统调用，而可以只调用一些相对便宜的原子操作。

### Getpid

`getpid()`系统调用在 RHEL 7 上出奇地快。事实证明，RHEL 7 使用了[较旧的 glibc 版本来缓存进程的 ID](https://manpath.be/f34/2/getpid#L43)！这可能是一个有趣的优化，因为，这有什么意义呢？我是说，你多频繁地在程序中调用`getpid()`呢？在某个时候（大约 Fedora 26 左右），这个[特性被移除了](https://bugzilla.redhat.com/show_bug.cgi?id=1469670)，因为显然它引起了更多的[麻烦](https://yarchive.net/comp/linux/getpid_caching.html)而不值得。也许并不奇怪的是，那个[移除](https://bugzilla.redhat.com/show_bug.cgi?id=1469670)甚至[破坏了某人的工作流程](https://xkcd.com/1172/)。

### 真实系统调用

因此，查看真实的系统调用，用户态与内核态之间的切换成本大约在几百纳秒左右，对于所有主机来说都是如此。某些主机上较高的成本可以通过启用 CPU 缺陷修复（它们默认启用）和/或较旧/低端硬件来解释。另请参阅主机部分以获取一些详细信息。

最快的主机是`xg6256`，它成功地在少于 100 纳秒内切换模式。它配备了一颗性能优异的快速 CPU（至强金牌 6256），已禁用频率缩放，并以恒定的 4.1 GHz 频率运行在其基础频率之上（即在基础和睿频频率之间的频率）。

### 调度让步

`sched_yield()`系统调用可以被视为一个最小的工作系统调用，例如当没有东西可让出时。此外，基准进程正在标准调度策略下运行，并且在 Linux 下[`sched_yield()`被描述为](https://manpath.be/f34/2/sched_yield#L43)：

> `sched_yield()`旨在

未指定可能意味着系统调用在进程的调度策略等于`SCHED_OTHER`后就退出了。

在大多数主机上，`sched_yield`比一个真正的最小系统调用（如`getuid()`）昂贵大约 150 纳秒左右，这表明了一些额外的开销，但不一定是一个上下文切换。

### 纳秒睡眠

`nanosleep()`系统调用有点脱颖而出：

| 主机 | 5i4250u | 7i6600u | ac3758 | x2643 | x2667h | x2667s | x2687w | x2689 | x2690 | xg6144 | xg6148 | xg6246 | xg6256 | xg6256b | xs4110 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 名称 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| nanosleep0 | 52632 | 50474 | 52620 | 50588 | 50003 | 50011 | 50000 | 50014 | 50312 | 50018 | 50000 | 50014 | 50000 | 50000 | 54866 |
| nanosleep0_slack1 | 4355 | 2836 | 7076 | 3247 | 2736 | 2483 | 2835 | 3908 | 3401 | 2762 | 2870 | 2446 | 1974 | 2248 | 3837 |
| nanosleep1_slack1 | 4348 | 2840 | 7102 | 3252 | 2736 | 2486 | 2834 | 3908 | 3410 | 2767 | 2871 | 2446 | 1975 | 2246 | 3836 |

调用`nanosleep()`以睡眠 0 ns 或 1 ns 似乎也是一个非常廉价的系统调用，甚至是一个空操作。

但是，在第一种情况下，所有主机都需要 50 µs。巧合的是，50 µs 也是 Linux 上通常安排的进程的[默认定时器松弛值](https://manpath.be/f34/2/prctl#L1052)。[定时器松弛机制](https://lwn.net/Articles/588086/)将定时器到期时间延长到松弛值，以便组合多个定时器，因为这样可以减少唤醒次数，从而节省能量。由于`nanosleep()`创建一个定时器，因此也受到这种机制的影响。

因此，其他 nanosleep 案例[设置了最小的定时器松弛值](https://github.com/gsauthof/osjitter/blob/f1a4ca9cbf7516efc61c3bab2fe06ffe83cfb43c/bench_syscalls.cc#L117)为 1 ns，从而减少了运行时间，符合预期。但是，它仍然比其他系统调用要昂贵得多。当然，定时器到期具有有限的精度。但是，对于 0 ns 或 1 ns，确实不需要到期定时器。事实证明，无条件调用`nanosleep()`会产生（自愿）[上下文切换](https://en.wikipedia.org/wiki/Context_switch)。即使在隔离的核心上，调度程序也会愉快地切换到交换内核线程。因此，最后两个 nanonsleep 案例实际上测量了上下文切换的成本，这比简单的模式切换要昂贵。

上下文切换的成本与[其他人测量的情况](https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/#how-expensive-are-context-switches)相匹配（模除二）。

## 主机

下表显示了受基准测试影响的主机：

|  | 主机 | CPU | 缓解措施 | 轮询 | 操作系统 | 内核 |
| --- | --- | --- | --- | --- | --- | --- |
| 0 | 5i4250u | Core i5-4250U | 是 | 是 | Fedora 33 | 5.12 |
| 1 | 7i6600u | Core i7-6600U | 是 | 是 | Fedora 33 | 5.13 |
| 2 | ac3758 | Atom C3758 | 否 | 是 | Fedora 33 | 5.13 |
| 3 | x2643 | Xeon E5-2643 v2 | 是 | 否 | RHEL 7 | 3.10 |
| 4 | x2667h | Xeon E5-2667 v3 | 是 | 是 | RHEL 7 | 3.10 |
| 5 | x2667s | Xeon E5-2667 v3 | 是 | 是 | RHEL 7 | 3.10 |
| 6 | x2687w | Xeon E5-2687W v3 | 是 | 是 | RHEL 7 | 3.10 |
| 7 | x2689 | Xeon E5-2689 v4 | 是 | 是 | RHEL 7 | 3.10 |
| 8 | x2690 | Xeon E5-2690 0 | 是 | 是 | RHEL 7 | 3.10 |
| 9 | xg6144 | Xeon Gold 6144 | 是 | 是 | RHEL 7 | 3.10 |
| 10 | xg6148 | Xeon Gold 6148 | 否 | 是 | RHEL 7 | 3.10 |
| 11 | xg6246 | Xeon Gold 6246 | 是 | 是 | RHEL 7 | 3.10 |
| 12 | xg6256 | Xeon Gold 6256 | 否 | 是 | RHEL 7 | 3.10 |
| 13 | xg6256b | Xeon Gold 6256 | 是 | 是 | RHEL 7 | 3.10 |
| 14 | xs4110 | Xeon Silver 4110 | 否 | 是 | RHEL 7 | 3.10 |

注：

+   内核是发行版打包的内核

+   大多数 RHEL 主机使用的是 RHEL 7.9

+   通过`mitigations=off`内核参数或类似参数禁用了 CPU 缓解措施

+   轮询意味着通过内核参数和调整的 PM QoS 设置禁用 CPU 频率调节和节能

+   因此，主机的 CPU 以固定频率运行；在可能的情况下，此频率略高于基本频率，例如，在 Xeon Gold 6256 CPU 上设置为 4.1 GHz

+   Atom CPU 不支持超线程，并且所有 Xeon 主机上的超线程都已禁用

+   所有主机都已启用 SELinux 和/或审计（在 Fedora/RHEL 中这些功能默认启用），这在某种程度上增加了一些系统调用的开销

## 术语

在上述讨论中有两个重要的单独的术语需要区分：

1.  [模式切换](https://en.wikipedia.org/wiki/Context_switch#User_and_kernel_mode_switching)（或模式转换）

1.  [上下文切换](https://en.wikipedia.org/wiki/Context_switch)

这些术语的定义在不同的文献和不同的操作系统中可能会有所不同。另外，在其他情境中（不是在开玩笑！）可能会将不同的模式描述为不同的上下文。然而，在链接的维基百科文章中给出的定义是被广泛应用并适用于 Linux。

基本上，模式转换表示用户模式和内核模式（或用户空间和内核空间）之间的切换，而上下文切换表示不同任务之间的切换，这是由内核协助的。上下文切换需要比模式切换更多的工作，因此更昂贵。
