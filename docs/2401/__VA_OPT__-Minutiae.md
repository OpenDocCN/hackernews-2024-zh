<!--yml

category: 未分类

date: 2024-05-27 15:18:38

-->

# __VA_OPT__ 细节

> 来源：[`www.corsix.org/content/va-opt-minutiae`](https://www.corsix.org/content/va-opt-minutiae)

假设我们正在编写 C 代码，并且想要为 `printf`-带换行定义一个宏。我们可能会这样开始：

```
#define printfln(fstr, ...) \
  printf(fstr "\n", __VA_ARGS__) 
```

到目前为止都还好；我们可以写 `printfln("1+1 是 %d", 1+1)`，它会打印 `1 + 1 是 2` 并后跟一个换行符。然而，诸如 `printfln("Hello")` 的简单情况导致语法错误，因为这个宏会扩展为 `printf("Hello" "\n",)`，由于末尾逗号而无效。

**非标准解决方案**

一种常规解决方案是依赖于一种非标准语言扩展，其中在 `,` 和 `__VA_ARGS__` 之间插入 `##` 会产生 *特殊效果*：

```
#define printfln(fstr, ...) \
  printf(fstr "\n", ## __VA_ARGS__) 
```

使用这种方法，`printfln("1+1 是 %d", 1+1)` 和 `printfln("Hello")` 都能正常工作。然而，将两者组合成类似 `printfln("Wrote %d chars", printfln("Hello"))` 的东西会导致一个神秘的错误。要弄清楚原因，我们需要仔细研究这种非标准语言扩展具有什么 *特殊效果*。[GNU C 预处理器关于可变宏的文档](https://gcc.gnu.org/onlinedocs/gcc-13.2.0/cpp/Variadic-Macros.html)中提到：

> 当将 `##` 符号粘贴操作符置于逗号和可变参数之间时，具有特殊意义。如果你写入 [...] 并且可变参数被省略 [...], 那么在 `##` 之前的逗号将被删除。如果传递空参数，或者 `##` 之前的标记不是逗号，则不会发生这种情况。

与此同时，[GCC 可变宏文档](https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Variadic-Macros.html)中提到：

> 如果省略了可变参数或为空，则 `##` 运算符会导致预处理器删除其前面的逗号。如果在宏调用中提供了一些可变参数，GNU CPP 不会对粘贴操作抱怨，而是将可变参数放在逗号后面。与任何其他粘贴的宏参数一样，这些参数不会被宏展开。

第二段文档的最后一句告诉我们正在发生什么：宏参数通常在替换之前扩展，但是宏参数用作 `#` 或 `##` 操作数时则不会发生。在任一情况下，在执行替换后，将对结果标记进行重新扫描以进行更多扩展，尽管在此重新扫描期间原始宏将被停用。在扩展之前替换和在重新扫描期间扩展之间唯一重要的可观察到的区别是，在前者中原始宏是活动的，但在后者中原始宏是停用的。因此，`printfln("Wrote %d chars", printfln("Hello"))` 展开为 `printf("Wrote %d chars" "\n", printfln("Hello"))`，而不会展开内部的 `printfln`，这之后编译器尝试解析为调用不存在的 *函数* `printfln`。

两篇文档对于如果变长参数存在但为空（如 `printfln("Hello",)`）发生什么存在矛盾。在实践中，第一篇文档是正确的；如果变长参数存在但为空，逗号会被保留。

第一段文档中的 *即使 `##` 前的标记不是逗号也不会发生粘贴* 这句话很有意思，实际上这是一个稍微动态的属性：例如对于 `x` 扩展为空的情况，逗号删除可以发生在形如 `, ## x ## __VA_ARGS__` 的情况下。当 `x` 扩展为空时，clang 还会删除 `, x ## __VA_ARGS__` 中的逗号。如果紧接着 `, ## __VA_ARGS__` 跟随更多的粘贴，情况似乎也会变得有点奇怪。例如：

| `#define F(x, ...)` 为 | `F()` | `F(1)` | `F(,)` | `F(1,)` | `F(1,2)` |
| --- | --- | --- | --- | --- | --- |
| `,##__VA_ARGS__` | 空 | 空 | `,` | `,` | `,2` |
| `,##__VA_ARGS__ x` | 空 | `1` | `,` | `,1` | `,2 1` |
| `,##__VA_ARGS__##x` | `,` | 错误 | `,` | 错误 | 错误† 或 `,21`‡ |
| `,##x##__VA_ARGS__` | 空 | 错误 | `,` | 错误 | 错误 |
| `,x##__VA_ARGS__` | `,`† 或 空 ‡ | `,1` | `,` | `,1` | `,12` |

† 根据 gcc 13.2。

‡ 根据 clang 17.0.1。

在 gcc 和 clang 产生差异的情况下，谁能说哪个是正确的呢？毕竟，没有标准文件记录非标准语言扩展的期望行为。

**输入 `__VA_OPT__`**

与标准化这一混乱不同，[C](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3033.htm) 和 [C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0306r4.html) 语言采用了一种不同的解决方案，即 `__VA_OPT__`。使用 `__VA_OPT__`，我们的示例看起来像这样：

```
#define printfln(fstr, ...) \
  printf(fstr "\n" __VA_OPT__(,) __VA_ARGS__) 
```

在此情况下，如果变长参数不存在或为空，或者在宏扩展后变为空，`__VA_OPT__(,)` 扩展为空；否则扩展为 `,`。这里并没有标记粘贴，所以 `printfln("Wrote %d chars", printfln("Hello"))` 现在可行。另一个行为上的差异是看起来奇怪的 `printfln("Hello",)` 现在扩展为有效的 `printf("Hello" "\n")`，`printfln("Hello", EMPTY)` 在 `#define EMPTY /*nothing*/` 的上下文中也是如此。

标准并没有止步于此；在 `__VA_OPT__` 中不仅可以有一个逗号，而且还允许出现一个 `(`-`)` 平衡的标记序列，并且还可以访问宏调用的参数，因此例如以下也是合法的：

```
#define M(x, ...) (0 __VA_OPT__(-(x)) ) 
```

那么 `M(1)` 扩展为 `(0)`，`M(1,2)` 扩展为 `(0 - (1))`。

**那么空格呢？**

编译器在`__VA_OPT(`后或匹配`)`前的空格行为上似乎存在分歧。请考虑：

```
#define TILDAS(...) ~__VA_OPT__( ~ )~
#define S2(x) #x
#define S1(x) S2(x)
const char* s = S1(TILDAS());
const char* sa = S1(TILDAS(a)); 
```

观察得出的结果是：

|  | gcc 13.2 | clang 17.0.1 |
| --- | --- | --- |
| s | `"~~"` | `"~ ~"` |
| sa | `"~~~"` | `"~ ~ ~"` |

一种解释是，根据标准中的这段文字，gcc 是正确的：([N3096](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3096.pdf) 6.10.4.1¶7)

> 对于[...]一个 va-opt-replacement[...]的预处理标记序列[...]由当前函数宏的替换列表中包含的 pp-token 的展开结果组成，在删除占位符标记、重新扫描和进一步替换之前。

结合一个关于替换列表的早期段落：([N3096](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3096.pdf) 6.10.4¶7)

> [...] 在预处理标记的替换列表之前或之后的任何空白字符都不被视为宏的替换列表的一部分，无论是哪种形式的宏。

**`__VA_OPT__()`展开为什么？**

根据扩展规则，简短答案应该是*无*：

1.  如果可变参数不存在、为空或在宏展开后变为空，则`__VA_OPT__()`的展开是一个单一的占位符标记。

1.  否则，如果作为`##`的操作数使用，`__VA_OPT__()`的展开是一个单一的占位符标记（因为在这种情况下，空展开会变成一个占位符）。

1.  否则，`__VA_OPT__()`的展开为空（尽管一个单独的占位符标记同样有效，因为它将会在适当的时候消失）。

因此，`#__VA_OPT__()`成为了编写`""`的一种模糊方式。与此同时，作为`##`操作数的`__VA_OPT__()`可以用来强制*其他*操作数处于`##`上下文中。例如，通过以下方式可以复制`,`不良行为：`## __VA_ARGS__`：

```
#define printfln(fstr, ...) \
  printf(fstr "\n" __VA_OPT__(,) __VA_OPT__() ## __VA_ARGS__) 
```

如果`__VA_OPT__()`展开为什么都没有，无论可变参数是否不存在、为空或在宏展开后变为空，都可能会被优化掉。但也有一个边界情况：确定可变参数在宏展开后是否为空需要对其进行宏展开，并且（非标准的）`__COUNTER__`宏的宏展开具有可见的副作用。考虑：

```
#define EMPTY_VA_OPT(...) __VA_OPT__()
int x = __COUNTER__;
EMPTY_VA_OPT(__COUNTER__)
int y = __COUNTER__;
return y - x; 
```

对于上述情况，gcc 13.2 返回 2，而 clang 17.0.1 返回 1，这表明 clang 优化掉了`__VA_OPT__()`。

**Token pasting and `__VA_OPT__`**

标准特别指出`__VA_OPT__`的展开可以包含占位符标记：([N3096](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3096.pdf) 6.10.4.1¶7，我加重了这一点)

> 对于[...]一个 va-opt-replacement[...]的预处理标记序列[...]由当前函数宏的替换列表中包含的 pp-token 的展开结果组成，**在删除占位符标记、重新扫描和进一步替换之前**。

这些占位符标记最初是标准设想出来的，目的是提供对`##`语义的简洁描述：

+   `##`的操作数始终至少生成一个标记。如果一个操作数生成零个标记，则它将生成一个单一的占位符标记。

+   如果`##`的一个操作数是一个占位符标记，则`##`的结果是另一个操作数。

+   在`##`处理之后和重新扫描之前，占位符标记会被删除。

在 `__VA_OPT__` 之前，可以忽略这个虚构，并且[用周围对 `##` 评估的小心规则来实现预处理算法](https://www.spinellis.gr/blog/20060626/)，而不是生成并稍后删除占位符令牌。使用 `__VA_OPT__` 维护这个虚构变得更加困难。考虑：

```
#define G(x, y, z, ...) 1 ## __VA_OPT__(x y ## y z) ## 5 
```

`G(,,)` 展开为单个令牌 `15`，而 `G(2,3,4,-)` 展开为三个令牌 `12` `33` `45`。如果 `y` 是空的，那么内部的 `y ## y` 应该产生一个占位符，然后事情就变得有趣起来：

| 展开结果 | 结果 | 注意事项 |
| --- | --- | --- |
| `G(2,,4,-)` | `12` `45` | `__VA_OPT__` 展开为 `2``4`。 |
| `G( ,,4,-)` | `1` `45` | 占位符阻止了合并到 `145`。 |
| `G(2,, ,-)` | `12` `5` | 占位符阻止了合并到 `125`。 |
| `G( ,, ,-)` | `1` `5`† 或 `15`‡ | 正确结果是合并后的 `15`。 |

† 根据 gcc 13.2。

‡ 根据 clang 17.0.1。

另一个有趣的观察是，在 `__VA_OPT__` 中的宏参数会被宏展开，即使 `__VA_OPT__` 本身是 `##` 的操作数。考虑：

```
#define H1(...) x ##            __VA_ARGS__
#define H2(...) x ## __VA_OPT__(__VA_ARGS__) 
```

`H1(__LINE__)` 展开为 `x__LINE__`，而 `H2(__LINE__)` 展开为类似 `x3` 的东西。

**进一步阅读**

+   [P1042R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1042r1.html) 在几年前略微调整了 `__VA_OPT__` 的语义。

+   `__VA_OPT__` 可以被（滥）用于[递归宏](https://www.scs.stanford.edu/~dm/blog/va-opt.html)。
