- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-27 14:36:59'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 14:36:59
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Programming as Theory Building - Peter Naur · GitHub
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程如同建构理论 - 彼得·诺尔 · GitHub
- en: 来源：[https://gist.github.com/onlurking/fc5c81d18cfce9ff81bc968a7f342fb1](https://gist.github.com/onlurking/fc5c81d18cfce9ff81bc968a7f342fb1)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://gist.github.com/onlurking/fc5c81d18cfce9ff81bc968a7f342fb1](https://gist.github.com/onlurking/fc5c81d18cfce9ff81bc968a7f342fb1)
- en: Programming as Theory Building
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程如同建构理论
- en: '[](#programming-as-theory-building)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](#programming-as-theory-building)'
- en: Peter Naur's classic 1985 essay "Programming as Theory Building" argues that
    a program is not its source code. A program is a shared mental construct (he uses
    the word theory) that lives in the minds of the people who work on it. If you
    lose the people, you lose the program. The code is merely a written representation
    of the program, and it's lossy, so you can't reconstruct a program from its code.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 彼得·诺尔（Peter Naur）1985年的经典文章《编程如同建构理论》认为，一个程序并不等同于它的源代码。程序是一种共享的心智构造（他使用了理论这个词），存在于参与其中的人们的头脑之中。如果失去了这些人，你就失去了程序。代码只是程序的书面表现，而且它是有损失的，因此你无法从代码中重建一个程序。
- en: The present discussion is a contribution to the understanding of what programming
    is. It suggests that programming properly should be regarded as an activity by
    which the programmers form or achieve a certain kind of insight, a theory, of
    the matters at hand. This suggestion is in contrast to what appears to be a more
    common notion, that programming should be regarded as a production of a program
    and certain other texts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的讨论是对编程是什么的一种贡献。它建议，编程应该被视为程序员形成或达成某种见解、理论的活动。这一建议与一个更常见的观念形成对比，即编程应该被视为生产程序和某些其他文本的活动。
- en: Some of the background of the views presented here is to be found in certain
    observations of what actually happens to programs and the teams of programmers
    dealing with them, particularly in situations arising from unexpected and perhaps
    erroneous program executions or reactions, and on the occasion of modifications
    of programs. The difficulty of accommodating such observations in a production
    view of programming suggests that this view is misleading. The theory building
    view is presented as an alternative.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的观点的一些背景可以在对实际发生的程序以及处理它们的程序员团队的观察中找到，特别是在出现意外和可能错误的程序执行或反应的情况下，以及在修改程序时。很难在生产视图的编程中容纳这些观察结果，这表明这种观点是误导性的。理论建构观被提出作为一种替代方案。
- en: A more general background of the presentation is a conviction that it is important
    to have an appropriate understanding of what programming is. If our understanding
    is inappropriate we will misunderstand the difficulties that arise in the activity
    and our attempts to overcome them will give rise to conflicts and frustrations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本次讨论的更广泛背景是一种信念，即理解编程的本质是重要的。如果我们的理解是不恰当的，我们将误解活动中出现的困难，我们试图克服这些困难的尝试将引发冲突和挫折。
- en: In the present discussion some of the crucial background experience will first
    be outlined. This is followed by an explanation of a theory of what programming
    is, denoted the Theory Building View. The subsequent sections enter into some
    of the consequences of the Theory Building View.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的讨论中，首先概述了一些关键的背景经验。然后解释了编程是什么的一个理论，称之为理论建构观。随后的章节将进入理论建构观的一些后果。
- en: Programming and the Programmers’ Knowledge
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程与程序员的知识
- en: '[](#programming-and-the-programmers-knowledge)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[](#programming-and-the-programmers-knowledge)'
- en: I shall use the word programming to denote the whole activity of design and
    implementation of programmed solutions. What I am concerned with is the activity
    of matching some significant part and aspect of an activity in the real world
    to the formal symbol manipulation that can be done by a program running on a computer.
    With such a notion it follows directly that the programming activity I am talking
    about must include the development in time corresponding to the changes taking
    place in the real world activity being matched by the program execution, in other
    words program modifications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用编程一词来表示编程解决方案的设计和实现的整个活动。我所关心的是将现实世界活动的一部分和方面与程序运行在计算机上可以进行的形式符号操作相匹配的活动。有了这样的概念，很明显我所谈论的编程活动必须包括随着程序执行变化而发生的时间发展，换句话说，程序修改。
- en: One way of stating the main point I want to make is that programming in this
    sense primarily must be the programmers’ building up knowledge of a certain kind,
    knowledge taken to be basically the programmers’ immediate possession, any documentation
    being an auxiliary, secondary product.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表达我想要提出的主要观点的一种方式是，从这个意义上讲，编程主要必须是程序员建立某种类型知识的过程，这种知识被认为基本上是程序员的直接拥有，任何文档都是辅助的、次要的产物。
- en: As a background of the further elaboration of this view given in the following
    sections, the remainder of the present section will describe some real experience
    of dealing with large programs that has seemed to me more and more significant
    as I have pondered over the problems. In either case the experience is my own
    or has been communicated to me by persons having first hand contact with the activity
    in question.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对随后在下文中进一步阐述的背景，本节的剩余部分将描述一些处理大型程序的真实经历，这些经历在我思考这些问题时似乎变得越来越重要。无论哪种情况，这些经历都是我自己的，或者是由与相关活动直接接触的人向我传达的。
- en: Case 1 concerns a compiler. It has been developed by a group A for a Language
    L and worked very well on computer X. Now another group B has the task to write
    a compiler for a language L + M, a modest extension of L, for computer Y. Group
    B decides that the compiler for L developed by group A will be a good starting
    point for their design, and get a contract with group A that they will get support
    in the form of full documentation, including annotated program texts and much
    additional written design discussion, and also personal advice. The arrangement
    was effective and group B managed to develop the compiler they wanted. In the
    present context the significant issue is the importance of the personal advice
    from group A in the matters that concerned how to implement the extensions M to
    the language. During the design phase group B made suggestions for the manner
    in which the extensions should be accommodated and submitted them to group A for
    review. In several major cases it turned out that the solutions suggested by group
    B were found by group A to make no use of the facilities that were not only inherent
    in the structure of the existing compiler but were discussed at length in its
    documentation, and to be based instead on additions to that structure in the form
    of patches that effectively destroyed its power and simplicity. The members of
    group A were able to spot these cases instantly and could propose simple and effective
    solutions, framed entirely within the existing structure. This is an example of
    how the full program text and additional documentation is insufficient in conveying
    to even the highly motivated group B the deeper insight into the design, that
    theory which is immediately present to the members of group A.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 案例 1 涉及一个编译器。它是由 A 组开发的，用于语言 L，并且在计算机 X 上运行得非常好。现在，另一个 B 组的任务是为语言 L + M（L 的一个小的扩展）在计算机
    Y 上编写一个编译器。B 组决定，A 组开发的 L 编译器将是他们设计的良好起点，并与 A 组签订了一份合同，以获得完整的文档支持，包括注释的程序文本和许多额外的书面设计讨论，以及个人建议。这种安排非常有效，B
    组设法开发出了他们想要的编译器。在目前的情况下，重要的问题是 A 组的个人建议在如何实现对语言的扩展 M 的事项上的重要性。在设计阶段，B 组提出了关于如何适应扩展的方式的建议，并提交给
    A 组审查。在几个重要的情况中，事实证明，B 组提出的解决方案在 A 组看来，不仅没有利用现有编译器结构中固有的设施，而且在其文档中详细讨论过，而是基于对该结构的补丁的添加，这些补丁实际上破坏了其功能和简单性。A
    组成员能够立即发现这些情况，并提出简单而有效的解决方案，完全基于现有结构。这是一个例子，说明即使是高度积极的 B 组，完整的程序文本和额外的文档也无法向他们传达对设计的更深层次的洞察力，而这种理论对
    A 组成员来说是立即可见的。
- en: In the years following these events the compiler developed by group B was taken
    over by other programmers of the same organization, without guidance from group
    A. Information obtained by a member of group A about the compiler resulting from
    the further modification of it after about 10 years made it clear that at that
    later stage the original powerful structure was still visible, but made entirely
    ineffective by amorphous additions of many different kinds. Thus, again, the program
    text and its documentation has proved insufficient as a carrier of some of the
    most important design ideas.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些事件之后的几年里，由B组开发的编译器被同一组织的其他程序员接管，而没有来自A组的指导。A组成员在大约10年后关于编译器的进一步修改所获得的信息表明，到了后来阶段，原始强大的结构仍然可见，但由于许多不同类型的无组织添加，已经完全失效。因此，再次证明，程序文本及其文档已被证明不足以作为一些最重要的设计思想的载体。
- en: Case 2 concerns the installation and fault diagnosis of a large real–time system
    for monitoring industrial production activities. The system is marketed by its
    producer, each delivery of the system being adapted individually to its specific
    environment of sensors and display devices. The size of the program delivered
    in each installation is of the order of 200,000 lines. The relevant experience
    from the way this kind of system is handled concerns the role and manner of work
    of the group of installation and fault finding programmers. The facts are, first
    that these programmers have been closely concerned with the system as a full time
    occupation over a period of several years, from the time the system was under
    design. Second, when diagnosing a fault these programmers rely almost exclusively
    on their ready knowledge of the system and the annotated program text, and are
    unable to conceive of any kind of additional documentation that would be useful
    to them. Third, other programmers’ groups who are responsible for the operation
    of particular installations of the system, and thus receive documentation of the
    system and full guidance on its use from the producer’s staff, regularly encounter
    difficulties that upon consultation with the producer’s installation and fault
    finding programmer are traced to inadequate understanding of the existing documentation,
    but which can be cleared up easily by the installation and fault finding programmers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 案例2涉及安装和故障诊断一个大型实时监控工业生产活动的系统。该系统由其生产者销售，每次交付的系统都根据其特定的传感器和显示设备环境进行个性化适配。每次安装交付的程序规模约为20万行。从处理这种类型系统的方式中获得的相关经验涉及安装和故障排除程序员组的角色和工作方式。事实是，首先，这些程序员已经在系统上全职工作了几年时间，从系统处于设计阶段开始。其次，在诊断故障时，这些程序员几乎完全依赖于他们对系统和有注释的程序文本的现成知识，并且无法想象任何额外的文档对他们有用。第三，其他负责特定系统安装运行的程序员组，从生产商的工作人员那里收到系统的文档和完整使用指南，经常遇到由于对现有文档理解不足而导致的困难，但这些困难可以很容易地通过安装和故障排除程序员解决。
- en: The conclusion seems inescapable that at least with certain kinds of large programs,
    the continued adaption, modification, and correction of errors in them, is essentially
    dependent on a certain kind of knowledge possessed by a group of programmers who
    are closely and continuously connected with them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 结论似乎是不可避免的，至少对于某些类型的大型程序来说，对它们的持续调整、修改和纠错，基本上依赖于一种由与之密切和持续连接的程序员组 possessed
    的某种知识。
- en: If it is granted that programming must involve, as the essential part, a building
    up of the programmers’ knowledge, the next issue is to characterize that knowledge
    more closely. What will be considered here is the suggestion that the programmers’
    knowledge properly should be regarded as a theory, in the sense of Ryle [1949].
    Very briefly, a person who has or possesses a theory in this sense knows how to
    do certain things and in addition can support the actual doing with explanations,
    justifications, and answers to queries, about the activity of concern. It may
    be noted that Ryle’s notion of theory appears as an example of what K. Popper
    [Popper, and Eccles, 1977] calls unembodied World 3 objects and thus has a defensible
    philosophical standing. In the present section we shall describe Ryle’s notion
    of theory in more detail.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果承认编程必须包含作为程序员知识的基本部分的积累，下一个问题是更准确地刻画这种知识。这里将考虑的是程序员知识应该被看作是一个理论的建议，这里的理论是指
    Ryle [1949] 的意义上。简要地说，具有或拥有这种意义上的理论的人知道如何做某些事情，并且除了实际做事情外，还能够提供解释、理由和对相关活动的查询的答案。可以注意到，Ryle
    对理论的概念出现为 K. Popper [Popper 和 Eccles，1977] 所谓的非具体化的第三世界对象的例子，因此具有可辩护的哲学地位。在本节中，我们将更详细地描述
    Ryle 对理论的概念。
- en: Ryle [1949] develops his notion of theory as part of his analysis of the nature
    of intellectual activity, particularly the manner in which intellectual activity
    differs from, and goes beyond, activity that is merely intelligent. In intelligent
    behaviour the person displays, not any particular knowledge of facts, but the
    ability to do certain things, such as to make and appreciate jokes, to talk grammatically,
    or to fish. More particularly, the intelligent performance is characterized in
    part by the person’s doing them well, according to certain criteria, but further
    displays the person’s ability to apply the criteria so as to detect and correct
    lapses, to learn from the examples of others, and so forth. It may be noted that
    this notion of intelligence does not rely on any notion that the intelligent behaviour
    depends on the person’s following or adhering to rules, prescriptions, or methods.
    On the contrary, the very act of adhering to rules can be done more or less intelligently;
    if the exercise of intelligence depended on following rules there would have to
    be rules about how to follow rules, and about how to follow the rules about following
    rules, etc. in an infinite regress, which is absurd.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Ryle [1949]在他对知识活动性质的分析中发展了他关于理论的概念，特别是知识活动性质与仅仅是聪明活动的区别以及超越聪明活动的方式。在聪明行为中，人们展示出的不是对事实的任何特定知识，而是能够做某些事情的能力，例如制造和欣赏笑话，语法上的对话，或者钓鱼。更具体地，聪明的表现部分地表现为个体做事情得当，符合某些标准，但更进一步显示了个体能够应用这些标准来检测和纠正失误，从他人的例子中学习等等。可以注意到，这种智力的概念并不依赖于任何智力行为依赖于个体遵循或坚持规则、规范或方法的概念。相反，遵循规则的行为本身可以更或少地表现出智力；如果智力的行使依赖于遵循规则，那么就必须有关于如何遵循规则的规则，以及关于如何遵循关于如何遵循规则的规则的规则等等，形成无限回归，这是荒谬的。
- en: What characterizes intellectual activity, over and beyond activity that is merely
    intelligent, is the person’s building and having a theory, where theory is understood
    as the knowledge a person must have in order not only to do certain things intelligently
    but also to explain them, to answer queries about them, to argue about them, and
    so forth. A person who has a theory is prepared to enter into such activities;
    while building the theory the person is trying to get it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用于区分智力活动与仅仅是聪明的活动的特征是一个人的建构并拥有一个理论，这里的理论被理解为一个人必须具备的知识，不仅能够聪明地做某些事情，还能够解释它们，回答与它们相关的问题，对它们进行论证等等。拥有理论的人准备好参与这些活动；在建构理论时，人们试图理解它。
- en: The notion of theory in the sense used here applies not only to the elaborate
    constructions of specialized fields of enquiry, but equally to activities that
    any person who has received education will participate in on certain occasions.
    Even quite unambitious activities of everyday life may give rise to people’s theorizing,
    for example in planning how to place furniture or how to get to some place by
    means of certain means of transportation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所使用的理论概念不仅适用于专业领域复杂的建构，而且同样适用于接受过教育的任何人在某些场合参与的活动。甚至日常生活中相当不雄心勃勃的活动也可能引发人们的理论化，例如计划如何摆放家具或如何通过某种交通方式到达某个地方。
- en: The notion of theory employed here is explicitly not confined to what may be
    called the most general or abstract part of the insight. For example, to have
    Newton’s theory of mechanics as understood here it is not enough to understand
    the central laws, such as that force equals mass times acceleration. In addition,
    as described in more detail by Kuhn [1970, p. 187ff], the person having the theory
    must have an understanding of the manner in which the central laws apply to certain
    aspects of reality, so as to be able to recognize and apply the theory to other
    similar aspects. A person having Newton’s theory of mechanics must thus understand
    how it applies to the motions of pendulums and the planets, and must be able to
    recognize similar phenomena in the world, so as to be able to employ the mathematically
    expressed rules of the theory properly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此处所使用的理论概念明确不仅限于所谓的洞察最一般或抽象的部分。例如，要理解此处所了解的牛顿的力学理论，仅仅理解中心法则，比如力等于质量乘以加速度，是不够的。此外，如库恩[1970，p.
    187ff]所述，在理解理论的人必须理解中心法则如何适用于现实的某些方面，以便认识并将理论应用于其他相似的方面。持有牛顿力学理论的人因此必须理解它如何应用于摆和行星的运动，并且必须能够在世界中认识类似的现象，以便能够适当地运用理论中用数学表达的规则。
- en: The dependence of a theory on a grasp of certain kinds of similarity between
    situations and events of the real world gives the reason why the knowledge held
    by someone who has the theory could not, in principle, be expressed in terms of
    rules. In fact, the similarities in question are not, and cannot be, expressed
    in terms of criteria, no more than the similarities of many other kinds of objects,
    such as human faces, tunes, or tastes of wine, can be thus expressed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理论对程序员掌握的某种情境和真实世界事件之间的相似性的依赖性，说明持有理论的人所掌握的知识原则上无法用规则来表达。实际上，所谈的相似性无法用标准来表达，就像其他许多对象的相似性，如人脸、曲调或葡萄酒的味道一样，无法用标准来表达。
- en: The Theory To Be Built by the Programmer
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序员要建立的理论
- en: '[](#the-theory-to-be-built-by-the-programmer)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[](#the-theory-to-be-built-by-the-programmer)'
- en: In terms of Ryle’s notion of theory, what has to be built by the programmer
    is a theory of how certain affairs of the world will be handled by, or supported
    by, a computer program. On the Theory Building View of programming the theory
    built by the programmers has primacy over such other products as program texts,
    user documentation, and additional documentation such as specifications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从赖尔的理论的角度来看，程序员必须建立关于世界某些事务将如何经由计算机程序处理或支持的理论。在编程的理论构建观点上，程序员建立的理论优于程序文本、用户文档以及规范等其他产品。
- en: 'In arguing for the Theory Building View, the basic issue is to show how the
    knowledge possessed by the programmer by virtue of his or her having the theory
    necessarily, and in an essential manner, transcends that which is recorded in
    the documented products. The answers to this issue is that the programmer’s knowledge
    transcends that given in documentation in at least three essential areas:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在论证理论构建观点时，基本问题是要说明程序员因持有理论而具有的知识必然且在本质上超越了记录在文件产品中的知识。对这个问题的答案是，程序员的知识在至少三个基本领域超越了文件记录的知识：
- en: The programmer having the theory of the program can explain how the solution
    relates to the affairs of the world that it helps to handle. Such an explanation
    will have to be concerned with the manner in which the affairs of the world, both
    in their overall characteristics and their details, are, in some sense, mapped
    into the program text and into any additional documentation. Thus the programmer
    must be able to explain, for each part of the program text and for each of its
    overall structural characteristics, what aspect or activity of the world is matched
    by it. Conversely, for any aspect or activity of the world the programmer is able
    to state its manner of mapping into the program text. By far the largest part
    of the world aspects and activities will of course lie outside the scope of the
    program text, being irrelevant in the context. However, the decision that a part
    of the world is relevant can only be made by someone who understands the whole
    world. This understanding must be contributed by the programmer.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有着程序理论的程序员可以解释解决方案与其帮助处理的世界事务之间的关系。这样的解释将涉及世界事务的总体特征及其细节以某种方式映射到程序文本和任何额外文档中。因此，程序员必须能够解释，对于程序文本的每一部分以及其整体结构特征的每一部分，它匹配了世界的哪个方面或活动。反过来，对于世界的任何方面或活动，程序员都能够说明它在程序文本中的映射方式。当然，世界方面和活动中的绝大部分将超出程序文本的范围，因为在这个上下文中是不相关的。然而，决定一个世界部分是相关的这个决定只能由理解整个世界的人来做出。这种理解必须由程序员提供。
- en: The programmer having the theory of the program can explain why each part of
    the program is what it is, in other words is able to support the actual program
    text with a justification of some sort. The final basis of the justification is
    and must always remain the programmer’s direct, intuitive knowledge or estimate.
    This holds even where the justification makes use of reasoning, perhaps with application
    of design rules, quantitative estimates, comparisons with alternatives, and such
    like, the point being that the choice of the principles and rules, and the decision
    that they are relevant to the situation at hand, again must in the final analysis
    remain a matter of the programmer’s direct knowledge.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有着程序理论的程序员可以解释程序的每一部分为什么是什么，换句话说，能够用某种形式的理由支持实际的程序文本。理由的最终基础必须始终是程序员的直接、直观的知识或估计。即使在理由使用推理的情况下，也可能涉及设计规则的应用、定量估计、与替代方案的比较等，其中的重点是，原则和规则的选择，以及它们与手头情况的相关性的决定，最终分析还是必须由程序员的直接知识来决定。
- en: The programmer having the theory of the program is able to respond constructively
    to any demand for a modification of the program so as to support the affairs of
    the world in a new manner. Designing how a modification is best incorporated into
    an established program depends on the perception of the similarity of the new
    demand with the operational facilities already built into the program. The kind
    of similarity that has to be perceived is one between aspects of the world. It
    only makes sense to the agent who has knowledge of the world, that is to the programmer,
    and cannot be reduced to any limited set of criteria or rules, for reasons similar
    to the ones given above why the justification of the program cannot be thus reduced.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有着程序理论的程序员能够积极应对对程序修改的任何需求，以支持世界事务以新的方式。设计如何将修改最佳地纳入已建立的程序中取决于对新需求与已经内置在程序中的操作设施的相似性的感知。必须感知到的相似性是世界的各个方面之间的相似性。这只对了解世界的人（即程序员）有意义，并且不能被简化为任何有限的标准或规则集，原因与上述为什么不能将程序的理由简化为这样的原因相似。
- en: While the discussion of the present section presents some basic arguments for
    adopting the Theory Building View of programming, an assessment of the view should
    take into account to what extent it may contribute to a coherent understanding
    of programming and its problems. Such matters will be discussed in the following
    sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节讨论提供了采用程序理论视图的基本论点，但对该视图的评估应考虑它在多大程度上有助于对编程及其问题的一致理解。这些问题将在接下来的章节中讨论。
- en: Problems and Costs of Program Modifications
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序修改的问题与成本
- en: '[](#problems-and-costs-of-program-modifications)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[](#problems-and-costs-of-program-modifications)'
- en: A prominent reason for proposing the Theory Building View of programming is
    the desire to establish an insight into programming suitable for supporting a
    sound understanding of program modifications. This question will therefore be
    the first one to be taken up for analysis.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 提出将编程视为理论建设的一个重要原因是希望建立一种有助于支持对程序修改进行深入理解的编程洞见。因此，这个问题将是第一个被提出进行分析的问题。
- en: One thing seems to be agreed by everyone, that software will be modified. It
    is invariably the case that a program, once in operation, will be felt to be only
    part of the answer to the problems at hand. Also the very use of the program itself
    will inspire ideas for further useful services that the program ought to provide.
    Hence the need for ways to handle modifications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事似乎是所有人都同意的，那就是软件将会被修改。一旦程序开始运行，它往往会被认为只是解决手头问题的一部分。而且程序本身的使用将会激发对程序应该提供进一步有用服务的想法。因此，有必要处理修改的方式。
- en: The question of program modifications is closely tied to that of programming
    costs. In the face of a need for a changed manner of operation of the program,
    one hopes to achieve a saving of costs by making modifications of an existing
    program text, rather than by writing an entirely new program.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编程修改的问题与编程成本密切相关。面对对程序操作方式的变更需求，人们希望通过修改现有程序文本而不是编写全新程序来节省成本。
- en: The expectation that program modifications at low cost ought to be possible
    is one that calls for closer analysis. First it should be noted that such an expectation
    cannot be supported by analogy with modifications of other complicated man–made
    constructions. Where modifications are occasionally put into action, for example
    in the case of buildings, they are well known to be expensive and in fact complete
    demolition of the existing building followed by new construction is often found
    to be preferable economically. Second, the expectation of the possibility of low
    cost program modifications conceivably finds support in the fact that a program
    is a text held in a medium allowing for easy editing. For this support to be valid
    it must clearly be assumed that the dominating cost is one of text manipulation.
    This would agree with a notion of programming as text production. On the Theory
    Building View this whole argument is false. This view gives no support to an expectation
    that program modifications at low cost are generally possible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 认为低成本进行程序修改是可能的预期需要进行更深入的分析。首先应该注意到，这种预期不能通过与其他复杂人造构造物的修改类比来支持。在偶尔进行修改的情况下，例如建筑物的情况，众所周知它们往往昂贵，事实上完全拆除现有建筑后进行新建筑常常被发现在经济上更可取。其次，低成本程序修改的可能性预期在于程序是以允许轻松编辑的媒介保存的文本。为了使这种支持有效，必须明确假定主导成本是文本处理的成本。这与将编程视为文本生产的概念一致。在理论建设观点上，整个论据都是错误的。这种观点不支持普遍认为低成本进行程序修改是可能的预期。
- en: A further closely related issue is that of program flexibility. In including
    flexibility in a program we build into the program certain operational facilities
    that are not immediately demanded, but which are likely to turn out to be useful.
    Thus a flexible program is able to handle certain classes of changes of external
    circumstances without being modified.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个密切相关的问题是程序的灵活性。通过在程序中包含灵活性，我们为程序建立了一些不是立即需求但可能被证明是有用的操作设施。因此，灵活的程序能够处理外部环境变化的某些类别而无需进行修改。
- en: It is often stated that programs should be designed to include a lot of flexibility,
    so as to be readily adaptable to changing circumstances. Such advice may be reasonable
    as far as flexibility that can be easily achieved is concerned. However, flexibility
    can in general only be achieved at a substantial cost. Each item of it has to
    be designed, including what circumstances it has to cover and by what kind of
    parameters it should be controlled. Then it has to be implemented, tested, and
    described. This cost is incurred in achieving a program feature whose usefulness
    depends entirely on future events. It must be obvious that built–in program flexibility
    is no answer to the general demand for adapting programs to the changing circumstances
    of the world.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有人说应该设计程序以包含大量的灵活性，以便能够轻松地适应不断变化的情况。这样的建议在易于实现灵活性方面可能是合理的。然而，一般情况下，灵活性只能以相当大的成本来实现。每个项目都必须进行设计，包括它必须涵盖的情况以及它应该由什么样的参数控制。然后必须实施、测试和描述它。这种成本是为了获得一个程序特性，其有用性完全取决于未来事件。显然，内置的程序灵活性并不能满足将程序适应世界不断变化的情况的普遍需求。
- en: In a program modification an existing programmed solution has to be changed
    so as to cater for a change in the real world activity it has to match. What is
    needed in a modification, first of all, is a confrontation of the existing solution
    with the demands called for by the desired modification. In this confrontation
    the degree and kind of similarity between the capabilities of the existing solution
    and the new demands has to be determined. This need for a determination of similarity
    brings out the merit of the Theory Building View. Indeed, precisely in a determination
    of similarity the shortcoming of any view of programming that ignores the central
    requirement for the direct participation of persons who possess the appropriate
    insight becomes evident. The point is that the kind of similarity that has to
    be recognized is accessible to the human beings who possess the theory of the
    program, although entirely outside the reach of what can be determined by rules,
    since even the criteria on which to judge it cannot be formulated. From the insight
    into the similarity between the new requirements and those already satisfied by
    the program, the programmer is able to design the change of the program text needed
    to implement the modification.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序修改中，现有的编程解决方案必须进行更改，以适应其所匹配的现实世界活动的变化。在修改中首先需要做的是将现有解决方案与所需修改所需的需求进行对比。在这种对比中，必须确定现有解决方案的能力与新需求之间的程度和种类相似性。这种相似性的确定需要理论构建观点的优点。事实上，正是在相似性的确定中，任何忽略直接参与具有适当见解的人员的中心要求的编程观点的不足变得明显。关键在于必须识别的相似性种类是可以由具有该程序理论的人类获得的，尽管甚至连判断其的标准也无法制定。通过对新要求与程序已满足的要求之间的相似性的洞察，程序员能够设计所需的程序文本更改以实施修改。
- en: In a certain sense there can be no question of a theory modification, only of
    a program modification. Indeed, a person having the theory must already be prepared
    to respond to the kinds of questions and demands that may give rise to program
    modifications. This observation leads to the important conclusion that the problems
    of program modification arise from acting on the assumption that programming consists
    of program text production, instead of recognizing programming as an activity
    of theory building.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，不能谈论理论修改，只能谈论程序修改。事实上，具有该理论的人必须已经准备好回答可能导致程序修改的各种问题和需求。这一观察结果导致了一个重要的结论，即程序修改的问题源于假设编程只包括程序文本的生产，而不是将编程视为理论构建的活动。
- en: On the basis of the Theory Building View the decay of a program text as a result
    of modifications made by programmers without a proper grasp of the underlying
    theory becomes understandable. As a matter of fact, if viewed merely as a change
    of the program text and of the external behaviour of the execution, a given desired
    modification may usually be realized in many different ways, all correct. At the
    same time, if viewed in relation to the theory of the program these ways may look
    very different, some of them perhaps conforming to that theory or extending it
    in a natural way, while others may be wholly inconsistent with that theory, perhaps
    having the character of unintegrated patches on the main part of the program.
    This difference of character of various changes is one that can only make sense
    to the programmer who possesses the theory of the program. At the same time the
    character of changes made in a program text is vital to the longer term viability
    of the program. For a program to retain its quality it is mandatory that each
    modification is firmly grounded in the theory of it. Indeed, the very notion of
    qualities such as simplicity and good structure can only be understood in terms
    of the theory of the program, since they characterize the actual program text
    in relation to such program texts that might have been written to achieve the
    same execution behaviour, but which exist only as possibilities in the programmer’s
    understanding.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 基于理论构建观点，程序文本由程序员进行修改，而没有对其潜在理论有适当把握，导致其衰变变得可以理解。事实上，如果仅将其视为程序文本和执行的外部行为的变化，那么一个期望的修改通常可以以许多不同的方式实现，而且都是正确的。同时，如果将其与程序的理论联系起来，这些方式可能看起来非常不同，其中一些可能符合该理论或自然地扩展该理论，而另一些则可能与该理论完全不一致，可能具有在程序的主要部分上的未集成补丁的特征。各种变化的这种性质差异只有程序员掌握程序的理论才能有意义。与此同时，对程序文本
- en: Program Life, Death, and Revival
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序的生命周期、死亡和复苏
- en: '[](#program-life-death-and-revival)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[](#program-life-death-and-revival)'
- en: A main claim of the Theory Building View of programming is that an essential
    part of any program, the theory of it, is something that could not conceivably
    be expressed, but is inextricably bound to human beings. It follows that in describing
    the state of the program it is important to indicate the extent to which programmers
    having its theory remain in charge of it. As a way in which to emphasize this
    circumstance one might extend the notion of program building by notions of program
    life, death, and revival. The building of the program is the same as the building
    of the theory of it by and in the team of programmers. During the program life
    a programmer team possessing its theory remains in active control of the program,
    and in particular retains control over all modifications. The death of a program
    happens when the programmer team possessing its theory is dissolved. A dead program
    may continue to be used for execution in a computer and to produce useful results.
    The actual state of death becomes visible when demands for modifications of the
    program cannot be intelligently answered. Revival of a program is the rebuilding
    of its theory by a new programmer team.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 编程理论构建视图的一个主要观点是，任何程序的一个重要部分，即其理论，是无法想象地表达出来的，但却与人类紧密相连。由此可见，在描述程序状态时，指示程序员对其理论的掌握程度至关重要。为了强调这一点，可以通过程序的生命周期、死亡和复苏来扩展程序构建的概念。程序的构建与程序员团队通过构建其理论相同。在程序的生命周期中，拥有其理论的程序员团队保持对程序的积极控制，并特别保留对所有修改的控制。程序的死亡发生在拥有其理论的程序员团队解散时。一个死亡的程序可能继续在计算机上执行并产生有用的结果。当对程序的修改要求无法得到明智的回答时，实际的死亡状态变得可见。程序的复苏是由新的程序员团队重建其理论。
- en: The extended life of a program according to these notions depends on the taking
    over by new generations of programmers of the theory of the program. For a new
    programmer to come to possess an existing theory of a program it is insufficient
    that he or she has the opportunity to become familiar with the program text and
    other documentation. What is required is that the new programmer has the opportunity
    to work in close contact with the programmers who already possess the theory,
    so as to be able to become familiar with the place of the program in the wider
    context of the relevant real world situations and so as to acquire the knowledge
    of how the program works and how unusual program reactions and program modifications
    are handled within the program theory. This problem of education of new programmers
    in an existing theory of a program is quite similar to that of the educational
    problem of other activities where the knowledge of how to do certain things dominates
    over the knowledge that certain things are the case, such as writing and playing
    a music instrument. The most important educational activity is the student’s doing
    the relevant things under suitable supervision and guidance. In the case of programming
    the activity should include discussions of the relation between the program and
    the relevant aspects and activities of the real world, and of the limits set on
    the real world matters dealt with by the program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些概念，程序的延续寿命取决于新一代程序员接管程序理论。对于新程序员来说，要掌握现有程序的理论，仅仅熟悉程序文本和其他文档是不够的。需要的是，新程序员有机会与已经掌握该理论的程序员密切合作，以便熟悉程序在相关实际情况更广泛背景中的位置，并获得关于程序如何工作以及如何处理异常程序反应和程序修改的知识。在现有程序理论中对新程序员进行教育的问题与其他活动的教育问题非常相似，在这些活动中，如何做某些事情的知识主导于某些事情的知识，比如写作和演奏乐器。最重要的教育活动是学生在适当的监督和指导下进行相关活动。在编程的情况下，这种活动应包括讨论程序与实际世界相关方面和活动之间的关系，以及程序处理的实际世界事务所设定的限制。
- en: A very important consequence of the Theory Building View is that program revival,
    that is reestablishing the theory of a program merely from the documentation,
    is strictly impossible. Lest this consequence may seem unreasonable it may be
    noted that the need for revival of an entirely dead program probably will rarely
    arise, since it is hardly conceivable that the revival would be assigned to new
    programmers without at least some knowledge of the theory had by the original
    team. Even so the Theory Building View suggests strongly that program revival
    should only be attempted in exceptional situations and with full awareness that
    it is at best costly, and may lead to a revived theory that differs from the one
    originally had by the program authors and so may contain discrepancies with the
    program text.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 理论构建观的一个非常重要的结果是，程序复苏，即仅仅从文档中重新建立程序的理论，是严格不可能的。为了避免这一结论似乎不合理，可以注意到，完全死亡的程序需要复苏的情况可能很少会出现，因为很难想象会将复苏任务分配给对原理有至少一些了解的新程序员团队。即使如此，理论构建观强烈暗示，程序复苏应该只在特殊情况下尝试，并且要充分意识到这种尝试至多是代价高昂的，可能会导致与程序作者最初拥有的理论不同的复苏理论，因此可能与程序文本存在差异。
- en: In preference to program revival, the Theory Building View suggests, the existing
    program text should be discarded and the new–formed programmer team should be
    given the opportunity to solve the given problem afresh. Such a procedure is more
    likely to produce a viable program than program revival, and at no higher, and
    possibly lower, cost. The point is that building a theory to fit and support an
    existing program text is a difficult, frustrating, and time consuming activity.
    The new programmer is likely to feel torn between loyalty to the existing program
    text, with whatever obscurities and weaknesses it may contain, and the new theory
    that he or she has to build up, and which, for better or worse, most likely will
    differ from the original theory behind the program text.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与重启程序相比，理论构建视角建议应该放弃现有的程序文本，给予新组建的程序员团队重新解决给定问题的机会。这样的做法更有可能产生可行的程序，且成本不会更高，甚至可能更低。关键在于，构建一个适合并支持现有程序文本的理论是一项困难、令人沮丧且耗时的活动。新程序员很可能在忠于现有程序文本（无论其中可能包含的含糊和弱点）与他/她必须建立的新理论之间感到矛盾，而这个新理论，不管好坏，很可能会与程序文本背后的原始理论有所不同。
- en: Similar problems are likely to arise even when a program is kept continuously
    alive by an evolving team of programmers, as a result of the differences of competence
    and background experience of the individual programmers, particularly as the team
    is being kept operational by inevitable replacements of the individual members.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 即使通过一个不断进化的程序员团队持续保持程序活跃，也可能出现类似问题，这是由于个人程序员的能力和背景经验的差异，特别是在团队由不可避免的替换个体成员时。
- en: Method and Theory Building
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法与理论构建
- en: '[](#method-and-theory-building)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[](#method-and-theory-building)'
- en: Recent years has seen much interest in programming methods. In the present section
    some comments will be made on the relation between the Theory Building View and
    the notions behind programming methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，编程方法引起了很大兴趣。本节将对理论构建视角与编程方法背后的概念之间的关系进行一些评论。
- en: To begin with, what is a programming method? This is not always made clear,
    even by authors who recommend a particular method. Here a programming method will
    be taken to be a set of work rules for programmers, telling what kind of things
    the programmers should do, in what order, which notations or languages to use,
    and what kinds of documents to produce at various stages.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是编程方法？这并不总是清楚的，即使是那些推荐特定方法的作者也不总是清楚。在这里，编程方法将被视为程序员的工作规则集，告诉程序员应该做什么，以什么顺序进行，应该使用哪些符号或语言，并在各个阶段产生什么样的文档。
- en: In comparing this notion of method with the Theory Building View of programming,
    the most important issue is that of actions or operations and their ordering.
    A method implies a claim that program development can and should proceed as a
    sequence of actions of certain kinds, each action leading to a particular kind
    of documented result. In building the theory there can be no particular sequence
    of actions, for the reason that a theory held by a person has no inherent division
    into parts and no inherent ordering. Rather, the person possessing a theory will
    be able to produce presentations of various sorts on the basis of it, in response
    to questions or demands.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较这种方法观点与编程的理论构建视角时，最重要的问题是行为或操作及其顺序。方法意味着一种声明，即程序开发可以且应该作为某种特定类型的行动序列进行，每个行动导致特定类型的文档结果。在构建理论时，没有特定的行动顺序，因为一个人所持有的理论没有固有的划分和固有的顺序。相反，持有理论的人将能够基于它产生各种形式的呈现，以回应问题或需求。
- en: As to the use of particular kinds of notation or formalization, again this can
    only be a secondary issue since the primary item, the theory, is not, and cannot
    be, expressed, and so no question of the form of its expression arises.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 至于特定类型的符号或形式化的使用，同样这只能是次要问题，因为主要项目，即理论，不能被表达，因此不会产生其表达形式的问题。
- en: It follows that on the Theory Building View, for the primary activity of the
    programming there can be no right method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据理论构建视角，对于编程的主要活动，没有正确的方法。
- en: This conclusion may seem to conflict with established opinion, in several ways,
    and might thus be taken to be an argument against the Theory Building View. Two
    such apparent contradictions shall be taken up here, the first relating to the
    importance of method in the pursuit of science, the second concerning the success
    of methods as actually used in software development.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结论似乎与已有观点在几个方面存在冲突，因此可能被认为是针对理论构建观点的论据。这里将探讨两种明显的矛盾，第一种与科学追求中方法的重要性有关，第二种与实际用于软件开发的方法的成功有关。
- en: The first argument is that software development should be based on scientific
    manners, and so should employ procedures similar to scientific methods. The flaw
    of this argument is the assumption that there is such a thing as scientific method
    and that it is helpful to scientists. This question has been the subject of much
    debate in recent years, and the conclusion of such authors as Feyerabend [1978],
    taking his illustrations from the history of physics, and Medawar [1982], arguing
    as a biologist, is that the notion of scientific method as a set of guidelines
    for the practising scientist is mistaken.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个论点是软件开发应该基于科学的方式，因此应该采用类似科学方法的程序。这个论点的缺陷在于假设存在科学方法，并且对科学家有所帮助。这个问题近年来一直是争论的焦点，费耶尔本德[1978]等人的结论，他们的例证来自物理学的历史，以及梅达瓦尔[1982]，作为一名生物学家，认为科学方法作为实践科学家的一套指导原则的概念是错误的。
- en: This conclusion is not contradicted by such work as that of Polya [1954, 1957]
    on problem solving. This work takes its illustrations from the field of mathematics
    and leads to insight which is also highly relevant to programming. However, it
    cannot be claimed to present a method on which to proceed. Rather, it is a collection
    of suggestions aiming at stimulating the mental activity of the problem solver,
    by pointing out different modes of work that may be applied in any sequence.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结论并不被波利亚[1954, 1957]关于问题解决的工作所否定。这项工作以数学领域为例，并导致了对编程也极为相关的洞见。然而，不能声称它提出了一个可以继续进行的方法。相反，它是一系列旨在激发问题解决者的思维活动的建议，通过指出可以应用于任何顺序的不同工作模式。
- en: The second argument that may seem to contradict the dismissal of method of the
    Theory Building View is that the use of particular methods has been successful,
    according to published reports. To this argument it may be answered that a methodically
    satisfactory study of the efficacy of programming methods so far never seems to
    have been made. Such a study would have to employ the well established technique
    of controlled experiments (cf. [Brooks, 1980] or [Moher and Schneider, 1982]).
    The lack of such studies is explainable partly by the high cost that would undoubtedly
    be incurred in such investigations if the results were to be significant, partly
    by the problems of establishing in an operational fashion the concepts underlying
    what is called methods in the field of program development. Most published reports
    on such methods merely describe and recommend certain techniques and procedures,
    without establishing their usefulness or efficacy in any systematic way. An elaborate
    study of five different methods by C. Floyd and several co–workers [Floyd, 1984]
    concludes that the notion of methods as systems of rules that in an arbitrary
    context and mechanically will lead to good solutions is an illusion. What remains
    is the effect of methods in the education of programmers. This conclusion is entirely
    compatible with the Theory Building View of programming. Indeed, on this view
    the quality of the theory built by the programmer will depend to a large extent
    on the programmer’s familiarity with model solutions of typical problems, with
    techniques of description and verification, and with principles of structuring
    systems consisting of many parts in complicated interactions. Thus many of the
    items of concern of methods are relevant to theory building. Where the Theory
    Building View departs from that of the methodologists is on the question of which
    techniques to use and in what order. On the Theory Building View this must remain
    entirely a matter for the programmer to decide, taking into account the actual
    problem to be solved.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '可能会似乎与理论建构观对方法的放弃相矛盾的第二个论点是，根据已发表的报告，使用特定方法是成功的。 对这一论点可以回答，迄今为止对编程方法的有效性进行系统满意的研究似乎从未进行过。
    这样的研究将不得不采用已经建立的控制实验技术（参见[Brooks，1980]或[Moher和Schneider，1982]）。 缺乏这样的研究部分是可以解释的，一方面是因为如果结果是显著的话将会产生的高昂成本，另一方面是由于在程序开发领域建立所谓方法背后概念的操纵方式的问题。
    关于这些方法的大多数发表报告仅仅描述并推荐某些技术和程序，而没有以任何系统的方式建立它们的有用性或有效性。 C·弗洛伊德和几位合作者对五种不同方法进行的详尽研究[弗洛伊德，1984]得出的结论是，将方法看作是在任意情境下机械地导致良好解决方案的规则系统的观念是一种幻觉。
    剩下的是方法在程序员教育中的影响。 这个结论与编程的理论建构观完全一致。 实际上，在这个观点上，程序员构建的理论质量在很大程度上取决于程序员对典型问题的模型解决方案、描述和验证技术以及由许多部分组成的系统的结构原理的熟悉程度。
    因此，许多方法关心的项目与理论建构相关。 理论建构观与方法学家的观点不同的地方在于使用哪些技术以及以什么顺序使用的问题。 在理论建构观中，这完全取决于程序员自行决定，考虑到要解决的实际问题。  '
- en: Programmers’ Status and the Theory Building View
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程人员的地位与理论建构观
- en: '[](#programmers-status-and-the-theory-building-view)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[](#programmers-status-and-the-theory-building-view)'
- en: The areas where the consequences of the Theory Building View contrast most strikingly
    with those of the more prevalent current views are those of the programmers’ personal
    contribution to the activity and of the programmers’ proper status.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 理论建构观与更普遍的当前观点相比最引人注目的差异之处在于编程人员对活动的个人贡献以及编程人员的适当地位。
- en: The contrast between the Theory Building View and the more prevalent view of
    the programmers’ personal contribution is apparent in much of the common discussion
    of programming. As just one example, consider the study of modifiability of large
    software systems by Oskarsson [1982]. This study gives extensive information on
    a considerable number of modifications in one release of a large commercial system.
    The description covers the background, substance, and implementation, of each
    modification, with particular attention to the manner in which the program changes
    are confined to particular program modules. However, there is no suggestion whatsoever
    that the implementation of the modifications might depend on the background of
    the 500 programmers employed on the project, such as the length of time they have
    been working on it, and there is no indication of the manner in which the design
    decisions are distributed among the 500 programmers. Even so the significance
    of an underlying theory is admitted indirectly in statements such as that ‘decisions
    were implemented in the wrong block’ and in a reference to ‘a philosophy of AXE’.
    However, by the manner in which the study is conducted these admissions can only
    remain isolated indications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 理论建构观与更普遍的程序员个人贡献观在对编程的讨论中明显不同。只需举一个例子，考虑奥斯卡森[1982年]关于大型软件系统可修改性的研究。该研究详细描述了一个大型商业系统的一个版本中大量修改的信息。描述涵盖了每个修改的背景、实质和实施，特别关注程序变化是如何限制在特定程序模块中的。然而，完全没有暗示这些修改的实施可能取决于项目中雇用的500名程序员的背景，比如他们在项目上工作的时间长短，也没有显示设计决策是如何在这500名程序员中分布的。尽管如此，对基础理论的重要性间接承认在一些声明中，例如“错误地实现了决策”以及对“AXE哲学”的提及。然而，通过研究的方式，这些承认只能保持孤立的迹象。
- en: More generally, much current discussion of programming seems to assume that
    programming is similar to industrial production, the programmer being regarded
    as a component of that production, a component that has to be controlled by rules
    of procedure and which can be replaced easily. Another related view is that human
    beings perform best if they act like machines, by following rules, with a consequent
    stress on formal modes of expression, which make it possible to formulate certain
    arguments in terms of rules of formal manipulation. Such views agree well with
    the notion, seemingly common among persons working with computers, that the human
    mind works like a computer. At the level of industrial management these views
    support treating programmers as workers of fairly low responsibility, and only
    brief education.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，目前关于编程的讨论似乎假定编程类似于工业生产，程序员被视为生产的一个组成部分，一个必须受到程序规则控制并且可以轻易被替代的组件。另一个相关观点是，人类表现最佳的方式是像机器一样行事，遵循规则，因此强调形式化表达方式，这使得可以用形式化操作规则来表述某些论点。这些观点与似乎普遍存在于与计算机一起工作的人中的观念很吻合，即人的思维工作方式类似于计算机。在工业管理层面上，这些观点支持将程序员视为责任相对较低、只需短暂教育的工人。
- en: On the Theory Building View the primary result of the programming activity is
    the theory held by the programmers. Since this theory by its very nature is part
    of the mental possession of each programmer, it follows that the notion of the
    programmer as an easily replaceable component in the program production activity
    has to be abandoned. Instead the programmer must be regarded as a responsible
    developer and manager of the activity in which the computer is a part. In order
    to fill this position he or she must be given a permanent position, of a status
    similar to that of other professionals, such as engineers and lawyers, whose active
    contributions as employers of enterprises rest on their intellectual proficiency.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据理论建构观，编程活动的主要结果是程序员持有的理论。由于这种理论的本质上是每个程序员的思想财产的一部分，因此必须放弃将程序员视为程序生产活动中可轻易替换的组件的观念。相反，程序员必须被视为该计算机是其中一部分的活动的负责任的开发者和管理者。为了担任这个职位，他或她必须被赋予一个永久的地位，类似于其他专业人士，如工程师和律师，他们作为企业雇主的积极贡献建立在他们的智力水平上。
- en: The raising of the status of programmers suggested by the Theory Building View
    will have to be supported by a corresponding reorientation of the programmer education.
    While skills such as the mastery of notations, data representations, and data
    processes, remain important, the primary emphasis would have to turn in the direction
    of furthering the understanding and talent for theory formation. To what extent
    this can be taught at all must remain an open question. The most hopeful approach
    would be to have the student work on concrete problems under guidance, in an active
    and constructive environment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于理论建构观所提出的程序员地位的提高，将必须得到相应的程序员教育重新定位的支持。虽然诸如符号掌握、数据表示和数据处理等技能仍然重要，但主要重点必须转向促进理解和理论形成的能力。这到底可以教授到什么程度必须保持一个开放的问题。最有希望的方法将是让学生在指导下，在一个积极、建设性的环境中解决具体问题。
- en: Accepting program modifications demanded by changing external circumstances
    to be an essential part of programming, it is argued that the primary aim of programming
    is to have the programmers build a theory of the way the matters at hand may be
    supported by the execution of a program. Such a view leads to a notion of program
    life that depends on the continued support of the program by programmers having
    its theory. Further, on this view the notion of a programming method, understood
    as a set of rules of procedure to be followed by the programmer, is based on invalid
    assumptions and so has to be rejected. As further consequences of the view, programmers
    have to be accorded the status of responsible, permanent developers and managers
    of the activity of which the computer is a part, and their education has to emphasize
    the exercise of theory building, side by side with the acquisition of knowledge
    of data processing and notations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 认为对外部环境变化提出的程序修改是编程的一个重要部分，主张编程的主要目的是让程序员建立关于程序执行支持问题方式的理论。这种观点导致了程序寿命的概念，其取决于程序员对其理论的持续支持。进一步地，根据这一观点，编程方法的概念，理解为程序员必须遵循的一套规程，基于无效的假设，因此必须被拒绝。作为这一观点的进一步结果，程序员必须被授予负责、永久地发展和管理计算机所属活动的地位，而他们的教育必须强调理论建构的实践，与数据处理和符号的知识获取并重。
- en: 'Brooks, R. E. Studying programmer behaviour experimentally. Comm. ACM 23(4):
    207–213, 1980.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '布鲁克斯（Brooks, R. E.）《实验性地研究程序员行为》（Studying programmer behaviour experimentally）。Comm.
    ACM 23(4): 207–213，1980年。'
- en: 'Feyerabend, P. Against Method. London, Verso Editions, 1978; ISBN: 86091–700–2.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 费耶尔本德（Feyerabend, P.）《反方法》（Against Method）。伦敦，Verso Editions 出版社，1978年；ISBN：86091–700–2。
- en: 'Floyd, C. Eine Untersuchung von Software–Entwicklungs–Methoden. Pp. 248–274
    in Programmierumgebungen und Compiler, ed H. Morgenbrod and W. Sammer, Tagung
    I/1984 des German Chapter of the ACM, Stuttgart, Teubner Verlag, 1984; ISBN: 3–519–02437–3.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 弗洛伊德（Floyd, C.）《软件开发方法的研究》（Eine Untersuchung von Software–Entwicklungs–Methoden）。H.
    Morgenbrod 和 W. Sammer 编，《程序环境和编译器》（Programmierumgebungen und Compiler），德国 ACM
    分会1984年第一次会议，斯图加特，Teubner 出版社，1984年；ISBN：3–519–02437–3。
- en: 'Kuhn, T.S. The Structure of Scientific Revolutions, Second Edition. Chicago,
    University of Chicago Press, 1970; ISBN: 0–226–45803–2.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 库恩（Kuhn, T.S.）《科学革命的结构》（The Structure of Scientific Revolutions），第二版。芝加哥，芝加哥大学出版社，1970年；ISBN：0–226–45803–2。
- en: 'Medawar, P. Pluto’s Republic. Oxford, University Press, 1982: ISBN: 0–19–217726–5.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 梅达沃（Medawar, P.）《冥王共和国》（Pluto’s Republic）。牛津，大学出版社，1982年：ISBN：0–19–217726–5。
- en: 'Moher, T., and Schneider, G. M. Methodology and experimental research in software
    engineering, Int. J. Man–Mach. Stud. 16: 65–87, 1\. Jan. 1982.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '莫尔（Moher, T.）和施奈德（Schneider, G. M.）《软件工程方法学与实验研究》（Methodology and experimental
    research in software engineering），Int. J. Man–Mach. Stud. 16: 65–87，1982年1月。'
- en: 'Oskarsson, Ö Mechanisms of modifiability in large software systems Linköping
    Studies in Science and Technology, Dissertations, no. 77, Linköping, 1982; ISBN:
    91–7372–527–7.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 奥斯卡尔森（Oskarsson, Ö）《大型软件系统可修改性机制》（Mechanisms of modifiability in large software
    systems）。林雪平，Linköping Studies in Science and Technology，论文集，第77号，林雪平，1982年；ISBN：91–7372–527–7。
- en: Polya, G. How To Solve It . New York, Doubleday Anchor Book, 1957.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 波利亚（Polya, G.）《解题法》（How To Solve It）。纽约，Doubleday Anchor Book 出版社，1957年。
- en: Polya, G. Mathematics and Plausible Reasoning. New Jersey, Princeton University
    Press, 1954.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 波利亚（Polya, G.）《数学与合理推理》（Mathematics and Plausible Reasoning）。新泽西，普林斯顿大学出版社，1954年。
- en: Popper, K. R., and Eccles, J. C. The Self and Its Brain. London, Routledge and
    Kegan Paul, 1977.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 波普尔（Popper, K. R.）和埃克尔斯（Eccles, J. C.）《自我及其大脑》（The Self and Its Brain）。伦敦，Routledge
    and Kegan Paul 出版社，1977年。
- en: Ryle, G. The Concept of Mind. Harmondsworth, England, Penguin, 1963, first published
    1949\. Applying "Theory Building"
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 莱尔（Ryle, G.）《心灵的概念》（The Concept of Mind）。哈蒙兹沃斯，英国，企鹅出版社，1963年，首次出版1949年。应用“理论建构”。
- en: Applying “Theory Building”
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用“理论建构”
- en: '[](#applying-theory-building)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[](#应用理论建构)'
- en: Viewing programming as theory building helps us understand “metaphor building”
    activity in Extreme Programming (XP), and the respective roles of tacit knowledge
    and documentation in passing along design knowledge.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将编程视为理论建构有助于我们理解极限编程（XP）中“隐喻建构”活动，并且了解隐性知识和文档在传递设计知识中的各自作用。
- en: Kent Beck suggested that it is useful to a design team to simplify the general
    design of a program to match a single metaphor. Examples might be, “This program
    really looks like an assembly line, with things getting added to a chassis along
    the line,” or “This program really looks like a restaurant, with waiters and menus,
    cooks and cashiers.”
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kent Beck建议，将程序的一般设计简化为与单一隐喻相匹配对于设计团队是有用的。例如，“这个程序看起来确实像是一个装配线，沿着线路添加东西”，或者“这个程序看起来确实像是一家餐厅，有侍者和菜单，厨师和收银员。”
- en: If the metaphor is good, the many associations the designers create around the
    metaphor turn out to be appropriate to their programming situation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果隐喻好，设计师围绕隐喻创建的许多联想将被证明与他们的编程情境相关。
- en: That is exactly Naur’s idea of passing along a theory of the design.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Naur对设计理论传递的想法。
- en: If “assembly line” is an appropriate metaphor, then later programmers, considering
    what they know about assembly lines, will make guesses about the structure of
    the software at hand and find that their guesses are “close.” That is an extraordinary
    power for just the two words, “assembly line.”
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“装配线”是一个合适的隐喻，那么稍后的程序员，考虑到他们对装配线的了解，将对手头软件的结构做出猜测，并发现他们的猜测是“接近的”。这对于仅仅两个词“装配线”来说是一种非凡的力量。
- en: The value of a good metaphor increases with the number of designers. The closer
    each person’s guess is “close” to the other people’s guesses, the greater the
    resulting consistency in the final system design.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的隐喻的价值随着设计者的数量增加而增加。每个人的猜测越“接近”其他人的猜测，最终系统设计的一致性就越大。
- en: Imagine 10 programmers working as fast as they can, in parallel, each making
    design decisions and adding classes as she goes. Each will necessarily develop
    her own theory as she goes. As each adds code, the theory that binds their work
    becomes less and less coherent, more and more complicated. Not only maintenance
    gets harder, but their own work gets harder. The design easily becomes a “kludge.”
    If they have a common theory, on the other hand, they add code in ways that fit
    together.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有10个程序员尽可能快地并行工作，每个人都在做设计决策并添加类。每个人在进行时都必然会形成自己的理论。随着每个人添加代码，绑定其工作的理论变得越来越不连贯，越来越复杂。不仅维护变得更加困难，而且他们自己的工作也变得更加困难。设计很容易变成“怪物”。另一方面，如果他们有一个共同的理论，他们就会以适合彼此的方式添加代码。
- en: An appropriate, shared metaphor lets a person guess accurately where someone
    else on the team just added code, and how to fit her new piece in with it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个适当的、共享的隐喻让一个人能够准确猜测到团队中其他人刚刚添加了代码的位置，以及如何将她的新部分与之配合。
- en: Tacit Knowledge and Documentation
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐性知识和文档
- en: '[](#tacit-knowledge-and-documentation)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[](#隐性知识和文档)'
- en: The documentation is almost certainly behind the current state of the program,
    but people are good at looking around. What should you put into the documentation?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文档几乎肯定落后于程序的当前状态，但人们擅长环顾四周。你应该把什么放入文档？
- en: That which helps the next programmer build an adequate theory of the program.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那有助于下一个程序员建立程序的充分理论的东西。
- en: This is enormously important. The purpose of the documentation is to jog memories
    in the reader, set up relevant pathways of thought about experiences and metaphors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是极为重要的。文档的目的是唤起读者的记忆，并建立关于经验和隐喻的相关思维路径。
- en: This sort of documentation is more stable over the life of the program than
    just naming the pieces of the system currently in place.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种文档比仅仅命名当前系统中的部件在程序的生命周期内更稳定。
- en: The designers are allowed to use whatever forms of expression are necessary
    to set up those relevant pathways. They can even use multiple metaphors, if they
    don’t find one that is adequate for the entire program. They might say that one
    section implements a fractal compression algorithm, a second is like an accounting
    ledger, the user interface follows the model-observer design pattern, and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 设计师被允许使用任何形式的表达来建立那些相关路径。即使他们找不到一个适用于整个程序的隐喻，他们甚至可以使用多个隐喻。他们可能会说，一个部分实现了分形压缩算法，第二个部分像会计分类账，用户界面遵循模型-观察者设计模式，依此类推。
- en: Experienced designers often start their documentation with just
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的设计师通常从仅仅的开始他们的文档
- en: The metaphors
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐喻
- en: Text describing the purpose of each major component
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述每个主要组件目的的文本
- en: Drawings of the major interactions between the major components
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要组件之间的主要交互的绘图
- en: These three items alone take the next team a long way to constructing a useful
    theory of the design.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这三项工作本身就足以让下一个团队在构建有用的设计理论方面走得很远。
- en: The source code itself serves to communicate a theory to the next programmer.
    Simple, consistent naming conventions help the next person build a coherent theory.
    When people talk about “clean code,” a large part of what they are referring to
    is how easily the reader can build a coherent theory of the system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码本身就是向下一个程序员传达理论的工具。简单、一致的命名惯例有助于下一个人建立一个连贯的理论。当人们谈论“清晰的代码”时，他们所指的很大程度上是读者能够轻松地建立系统的连贯理论。
- en: Documentation cannot—and so need not—say everything. Its purpose is to help
    the next programmer build an accurate theory about the system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 文档不可能——也不需要——说出一切。它的目的是帮助下一个程序员建立对系统的准确理论。
