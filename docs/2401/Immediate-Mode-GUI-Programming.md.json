["```\nvar count = 0;\n\nvar root = document.getElementById(\"clickcounter\");\n\nvar label = document.createElement(\"h3\");\nlabel.innerText = \"Number of clicks: 0\";\nroot.appendChild(label);\n\nvar btn = document.createElement(\"button\");\nbtn.innerText = \"Click Me!\";\nbtn.addEventListener(\"click\", function() {\n\tcount++;\n\tlabel.innerText = \"Number of clicks:\" + count;\n});\nroot.appendChild(btn); \n```", "```\nIn retained mode the label and button must explicitly be created,\nadded to a widget hierrarchy (the HTML DOM) and the click handler must\nbe registered. The handler callback is invoked at the discretion\nof the UI library, not when convenient for the program.\n\nIn the *immediate mode* model, library owned state is minimized, and the\nprogram is responsible for drawing, layout and event handling,\nsupported by the facilities offered by the UI library.\n\nA [complete Gio version](/include/files/clickcounter/main.go) of the\nclick counter is reproduced below (import statements omitted).\n\n```", "```\n\nIf your browser supports WebAssembly and WebGL, you can run the\nprogram by clicking the `run` button. It may take a little while to\nload.\n\n```", "```\ntype state struct {\n\tbtn         widget.Clickable\n\tballVisible bool\n\ttime        time.Time\n}\n\nvar programState state\n\nfunc (s *state) layout(gtx layout.Context, th *material.Theme) {\n\tfor s.btn.Clicked() {\n\t\ts.ballVisible = !s.ballVisible\n\t\ts.time = gtx.Now\n\t}\n\n\tif s.ballVisible {\n\t\ts.drawBall(gtx)\n\t}\n\tlayout.Center.Layout(gtx, func(gtx layout.Context) layout.Dimensions {\n\t\tlabel := \"Throw ball\"\n\t\tif s.ballVisible {\n\t\t\tlabel = \"Hide ball\"\n\t\t}\n\t\treturn material.Button(th, &s.btn, label).Layout(gtx)\n\t})\n}\n\nfunc (s *state) drawBall(gtx layout.Context) {\n\tdefer op.Save(gtx.Ops).Load()\n\tconst size = 50\n\n\t// Animate bounce.\n\tconst (\n\t\tv0 = 50.0\n\t\tg  = -9.81\n\t)\n\tnow := gtx.Now\n\tt := now.Sub(s.time).Seconds()\n\tt *= 10\n\tt1 := -v0 / (.5 * g)\n\tt = math.Mod(t, t1)\n\ty := v0*t + .5*g*t*t\n\n\t// Position.\n\tbottom := float32(gtx.Constraints.Max.Y)\n\top.Offset(f32.Point{X: 20, Y: bottom - size - float32(y)}).Add(gtx.Ops)\n\n\t// Draw.\n\tpaint.ColorOp{Color: color.NRGBA{A: 0xff, G: 0xff}}.Add(gtx.Ops)\n\tclip.RRect{\n\t\tRect: f32.Rectangle{Max: f32.Point{X: size, Y: size}},\n\t\tNE:   size * .5, NW: size * .5, SE: size * .5, SW: size * .5,\n\t}.Op(gtx.Ops).Add(gtx.Ops)\n\tpaint.PaintOp{}.Add(gtx.Ops)\n\n\t// Request immediate redraw.\n\top.InvalidateOp{}.Add(gtx.Ops)\n} \n```", "```\n\nSee how the high-level button and its centering is naturally mixed\nwith the low-level animation and drawing of the sphere. There is no\nseparate animation system; rather, the program draws and requests\nredrawing as long as the ball is bouncing, and simply stops when it is\nnot. The required state is minimized to just the `ballVisible` boolean\nand the throwing `time`.\n\nCompare the retained mode version:\n\n```", "```\n\n```", "```\nvar root = document.getElementById(\"list\");\n\nvar list = document.createElement(\"div\");\nlist.style = \"overflow-y: scroll; max-height: 200px;\"\nroot.appendChild(list);\n\nvar factor = 1;\n\nfunction addRows() {\n\tfor (var i = 0; i < 1000; i++) {\n\t\tvar row = document.createElement(\"p\");\n\t\trow.innerText = \"Row #\" + i*factor;\n\t\tlist.appendChild(row);\n\t}\n}\naddRows()\n\nvar btn = document.createElement(\"button\");\nbtn.innerText = \"Multiply by 10\";\nbtn.addEventListener(\"click\", function() {\n\twhile (list.firstChild) {\n\t\tlist.firstChild.remove();\n\t}\n\tfactor *= 10;\n\taddRows();\n});\nroot.appendChild(btn); \n```", "```\nBecause every row has a persistent representation to the UI in the\nform of `<p>` elements, the program is left with two options for\nupdating the elements: either go through them one by one, or remove\nthem all and recreate them. Both options perform worse as the number\nof elements grows.\n\nThe equivalent [Gio program](/include/files/list/main.go) has just two\nvariables: the integer factor adjusted by the button, and the list\nobject that tracks the scroll position. There is no need for a\npersistent representation of each row and the list spans a million rows\nwithout impacting performance.\n\n```", "```\n\n```", "```\ntype checkbox struct {\n\tchecked bool\n}\n\nvar boxes [10]checkbox\n\nfunc draw(gtx layout.Context) {\n\tvar children []layout.FlexChild\n\tfor i := range boxes {\n\t\tbox := &boxes[i]\n\t\tchildren = append(children,\n\t\t\tlayout.Rigid(func(gtx layout.Context) layout.Dimensions {\n\t\t\t\treturn layout.UniformInset(unit.Dp(10)).Layout(gtx,\n\t\t\t\t\tbox.layout,\n\t\t\t\t)\n\t\t\t}),\n\t\t)\n\t}\n\tlayout.Flex{}.Layout(gtx, children...)\n}\n\nfunc (c *checkbox) layout(gtx layout.Context) layout.Dimensions {\n\tconst size = 50\n\n\t// Process events using the key, c.\n\tfor _, e := range gtx.Events(c) {\n\t\tif e, ok := e.(pointer.Event); ok {\n\t\t\tif e.Type == pointer.Press {\n\t\t\t\tc.checked = !c.checked\n\t\t\t}\n\t\t}\n\t}\n\n\tst := op.Save(gtx.Ops) // Save operation state.\n\n\t// Confine input to the area covered by the checkbox.\n\tpointer.Rect(image.Rectangle{Max: image.Point{\n\t\tX: size,\n\t\tY: size,\n\t}}).Add(gtx.Ops)\n\t// Declare the filter with the key, c.\n\tpointer.InputOp{Tag: c, Types: pointer.Press}.Add(gtx.Ops)\n\n\tcol := color.NRGBA{A: 0xff, R: 0xff} // Red.\n\tif c.checked {\n\t\tcol = color.NRGBA{A: 0xff, G: 0xff} // Green.\n\t}\n\n\t// Draw checkbox. Red for unchecked, green for checked.\n\tpaint.ColorOp{Color: col}.Add(gtx.Ops)\n\tclip.Rect{\n\t\tMax: image.Point{\n\t\t\tX: size,\n\t\t\tY: size,\n\t\t},\n\t}.Add(gtx.Ops)\n\tpaint.PaintOp{}.Add(gtx.Ops)\n\n\tst.Load() // Restore operation state.\n\n\t// Specify layout dimensions.\n\treturn layout.Dimensions{\n\t\tSize: image.Point{\n\t\t\tX: size, Y: size,\n\t\t},\n\t}\n} \n```", "```\n\nFirst, notice the simple interface of the checkbox; input handling,\ndrawing and layout are all contained in a single method.\n\nSecond, the input protocol. To separate events belonging to different\nwidgets, handler keys that uniquely identify the handlers are used.\nKeys must be declared in the previous frame, along with any predicates\non the input (hit area for pointer input).\n\nFinally, the convenience. The program is free to process events\nanywhere during the frame, and there is no callback or state to\nunregister. Key declarations are automatically discarded before\nthe beginning of each frame.\n\nResources\n\nSponsoring\n\nI work on open source projects such as [Gio](https://gioui.org),\nsupported by sponsorships. If you find my work useful, please consider\n[sponsoring me](https://eliasnaur.com/sponsor).\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]