- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:49:51'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Laurence Tratt: Faster Shell Startup With Shell Switching'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://tratt.net/laurie/blog/2024/faster_shell_startup_with_shell_switching.html](https://tratt.net/laurie/blog/2024/faster_shell_startup_with_shell_switching.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A few days ago Thorsten Ball wrote a post exhorting Unix users to [optimise
    their shell’s startup time](https://registerspill.thorstenball.com/p/how-fast-is-your-shell).
    It’s excellent advice and well worth following.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unix shell has two major use cases: as an interactive prompt (what we often
    call “the command line”); and as a “scripting” or “non-interactive command” language.
    We normally pick one shell (bash, fish, zsh, etc.) and use it for both use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we can use different shells for each use case. People don’t normally
    bother doing so because there is little functional utility in doing so. There
    is, however, a small performance reason for doing so, which I’m going to look
    at in this post. I’m going to call the technique I describe in this post “shell
    switching” since I’m not aware that it has an existing name.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum Shell Overhead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by looking at the absolute minimum cost of starting and stopping
    a non-interactive Unix shell when there’s no user configuration . If I create
    a fresh user account with no configuration (other than an empty `~/.zshrc` to
    stop zsh asking me to do setup) bash, fish, and zsh take the following times to
    run on my OpenBSD laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Benchmarking numbers from laptops are bad enough, but I’m also using a weird
    operating system — those numbers are clearly untrustworthy. Here’s what happens
    if I run the same benchmarks on a fresh user account on a Debian server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The numbers between the two machines tell a fairly consistent story: bash and
    zsh are fairly fast, but fish is several times slower. This seems bad for me,
    because I use fish on my local machines, but should I really worry about a mere
    3-15ms minimum overhead? Thorsten argues that I should care for interactive prompts,
    but personally I care just as much about “non-interactive command” execution.'
  prefs: []
  type: TYPE_NORMAL
- en: I run lots of programs which themselves run lots of commands. This can range
    from me running external commands in my editor to running commands on a remote
    machine (with `ssh example.com "cmd arg1 ... argn"`). Although we often overlook
    this, the commands we specify are generally passed to a shell to run them with
    `shell -c cmd "arg1 ... argn"` — in other words these commands are one-line shell
    scripts. The overhead of the shell is a cost I am forced to bear each time I run
    such a command.
  prefs: []
  type: TYPE_NORMAL
- en: 'An obvious question is: which shell is used to run sub-commands? Surprisingly,
    there is no simple answer to this, and different programs use different shells
    to run sub-commands. Some use the contents of the `$SHELL` environment variable;
    some use the shell set in the user database (i.e. `/etc/passwd` and friends);
    and some use a hard-coded shell (e.g. `/bin/sh`). In most cases, `$SHELL` and
    the shell in the user database are the same, often a “big” shell like bash, fish,
    or zsh. In many of the cases I care about, my non-interactive commands are run
    with one of these big shells, so the overhead of them is something I care about.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, the overhead I experience when running non-interactive commands
    is much higher than the bare minimum would suggest. As luck would have it, I have
    fairly comparable fish and zsh configurations (I migrated from the latter to the
    former a year or two back). Executing a command as my normal user account shows
    what the overhead of the shell plus my configuration is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only are those times 10-20x more than the minimum but they’re slow enough
    to be visible to me slow, aged human eyes! And it gets worse, depending on the
    machine. One of the servers I use frequently is fairly slow (in CPU and IO): if
    the relevant files aren’t in cache, fish and zsh with my configuration add 300ms
    (a third of a second!) overhead.'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing Shell Overhead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Last year I got particularly frustrated when I was executing huge numbers of
    commands, locally and remotely. My normal user shell (depending on the machine,
    fish or zsh) was adding noticeable overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing I did was to change some of my configuration so that it was
    skipped in non-interactive (i.e. “scripting”) mode. That helped a bit, but it’s
    harder than it looks. For example, with zsh I always get confused by when, and
    in which order, the `~/.zlogin`, `~/.zprofile`, `~/.zshenv`, and `~/.zshrc` configuration
    files are loaded. fish has a different model of which files are executed when,
    overloading my poor brain. Whatever shells I might use in the future will probably
    do something different again.
  prefs: []
  type: TYPE_NORMAL
- en: I then had a different idea. I want a fully featured shell like fish or zsh
    for interactive prompts, but I don’t care what’s used for non-interactive commands.
    Indeed, at a basic level, most Unix shells implement [the same base language](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html).
    Even fish, which is explicitly not compatible with this standard, is in practice
    mostly compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most modern Unices come with a small shell installed in `/bin/sh` — for example,
    ksh in OpenBSD or dash in Debian. Here’s our fresh user account running `/bin/sh`
    on my OpenBSD laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s faster than any of the “big” shells, even if only by a couple of milliseconds.
    The performance story is similar on the Linux server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Both ksh and dash are too bare-bones for me to want to use them as an interactive
    shell, so I don’t want to switch to them wholesale. Instead, what I want to do
    is use `/bin/sh` for non-interactive commands and fish (or another “big” shell)
    for interactive prompts.
  prefs: []
  type: TYPE_NORMAL
- en: Shell Switching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out to be straightforward to use one shell for non-interactive commands
    and another for interactive prompts.
  prefs: []
  type: TYPE_NORMAL
- en: First, I set my user shell to `/bin/sh` (with `chsh -c /bin/sh`). However, when
    I login at a terminal I’m now using ksh or dash, when I want to use fish or zsh.
  prefs: []
  type: TYPE_NORMAL
- en: '`/bin/sh` always starts by loading and executing the shell script in `~/.profile`.
    In that file we need to work out if we’re running a non-interactive command or
    an interactive prompt. This stymied me for a while, but it turns out to be fairly
    easy. Shells set an environment variable `$-` which will contain the letter “i”
    if the shell is an interactive prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this knowledge, the minimum version of shell switching is to put the following
    in `~/.profile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If I’m starting an interactive prompt, this `exec`s fish (i.e. overwrites the
    `/bin/sh` process with `fish`), otherwise it sticks with `/bin/sh`. Interestingly,
    because `login` sets `$SHELL`, and fish doesn’t change that value, my fish shell
    reports `/bin/sh` as the value for `$SHELL`. Thus, whether a program uses `$SHELL`
    or the shell set in the user database to run a sub-command they always get a value
    of `/bin/sh`, which is what I want!
  prefs: []
  type: TYPE_NORMAL
- en: 'Happily my small `.profile` is so quick to execute that it has no meaningful
    impact on our benchmark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I can even see how long it takes shell switching to execute fish for an interactive
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If I run this benchmark with fish directly, the resulting benchmark numbers
    are statistically indistinguishable. Shell switching is fast!
  prefs: []
  type: TYPE_NORMAL
- en: 'One question is: do we *need* some configuration even in `~/.profile`? Personally
    I don’t. If you do, the good news is that most of the time spent in shell startup
    tends to be spent on executing things humans want in interactive prompts. Adding
    a line or two to `~/.profile` which, say, adds directories to `$PATH` seems unlikely
    to add much overhead.'
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Against Failing Shell Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A handful of times over the years I’ve found myself using a system where the
    shell binary doesn’t work: either it doesn’t exist; or it fails to execute. In
    both cases, this tends to happen during a system update and the end result is
    that I can’t login.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to minimally extend “shell switching” so that `~/.profile` catches
    the obvious cases of this, meaning that `/bin/sh` ends up being my fall-back interactive
    prompt if my “big” shell doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You may notice a degree of paranoia here. First this does a fast check that
    a binary called “fish” exists (`command -v fish` returns non-zero if it doesn’t).
    Second it tries actually running fish to see if the binary at least minimally
    runs without exiting (using the `--version` flag as a proxy for this). Only if
    that succeeds does it `exec fish`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you care about the speed of non-interactive command execution then shell
    switching is a simple technique for optimising this without effecting the configuration
    of your interactive prompt. It involves:'
  prefs: []
  type: TYPE_NORMAL
- en: setting your shell to `/bin/sh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: putting code into `~/.profile` which `exec`s a different shell when an interactive
    prompt is detected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I’ve been running with this setup for nearly 12 months, and it’s caused me no
    problems, but has given me a useful speed boost!
  prefs: []
  type: TYPE_NORMAL
- en: '*Update (2024-01-16)* The original code I gave for `~/.profile` contained `[[...]]`
    which isn’t POSIX compatible, and causes dash (and potentially other strict shells)
    to error. I’ve replaced it with `case ... esac` which is POSIX compatible. I reran
    the two benchmarks affected, though neither changed in statistically significant
    ways.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Update (2024-01-18)* Fixed typo: `login` sets `$SHELL`, not `/bin/sh`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Newer](/laurie/blog/2024/some_reflections_on_writing_unix_daemons.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 2024-01-16 14:50
  prefs: []
  type: TYPE_NORMAL
- en: '[Older](/laurie/blog/2024/choosing_what_to_read.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like updates on new blog posts: follow me on'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mastodon](https://mastodon.social/@ltratt)'
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[Twitter](https://twitter.com/laurencetratt)'
  prefs: []
  type: TYPE_NORMAL
- en: ; or
  prefs: []
  type: TYPE_NORMAL
- en: '[subscribe to the RSS feed](../blog.rss)'
  prefs: []
  type: TYPE_NORMAL
- en: ; or
  prefs: []
  type: TYPE_NORMAL
- en: '[subscribe to email updates](/laurie/newsletter/)'
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
