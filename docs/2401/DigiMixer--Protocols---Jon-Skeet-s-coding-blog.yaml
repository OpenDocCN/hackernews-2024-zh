- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:29:16'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'DigiMixer: Protocols | Jon Skeet''s coding blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://codeblog.jonskeet.uk/2024/01/02/digimixer-protocols/](https://codeblog.jonskeet.uk/2024/01/02/digimixer-protocols/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Despite this blog series going *very* slowly, the DigiMixer project itself has
    certainly not been stalled. Over the last year, I’ve added support for various
    additional mixers, as well as improving the support for some of the earlier ones,
    and performing quite a lot of refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'DigiMixer now supports the following mixers, to a greater or lesser extent:'
  prefs: []
  type: TYPE_NORMAL
- en: Behringer X series (tested with XR16, XR18, X-32R) and Midas M series (only
    tested with M32R, but I expect it to be identical to the X series)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Harman Soundcraft Ui series (tested with Ui24R)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allen & Heath Qu series (tested with Qu-SB, including the AR84 stage box)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allen & Heath CQ series (tested with CQ-20B)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RCF M-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mackie DL series (tested with DL16S and DL32R, which proved significantly difference)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yamaha DM series (tested with DM-3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PreSonus StudioLive Series III (tested with 16R)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to support each mixer, we have to be able to communicate with it. The
    only sort of “standardised” protocol used by the above mixers is OSC (Open Sound
    Control) – and that’s still only a matter of standardising what an OSC message
    looks like, not what the various addresses and values mean. Some mixers support
    MIDI to a certain extent, sometimes even with documentation around how that support
    works. (Again, there’s no one standard for how MIDI integration in a mixer “should”
    be implemented – it’s not like MIDI on actual instruments where you can reasonably
    expect a given MIDI message to mean “play middle C”.) That’s useful in terms of
    integration within a DAW, but none of the mixers I’ve seen so far provide sufficient
    control via MIDI to meet DigiMixer’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: This post will go into a little detail about the protocols I’ve encountered
    so far, what we actually *need* for DigiMixer, and some practical aspects of how
    I’ve been reverse engineering the protocols.
  prefs: []
  type: TYPE_NORMAL
- en: I’m hoping to start writing more detailed documentation about each protocol
    within the GitHub repo, in the [Protocols directory](https://github.com/jskeet/DemoCode/tree/main/DigiMixer/Protocols).
    There’s a bit of information about the Mackie DL series at the moment, with more
    to come when I find time. It’s worth being aware that any terminology I use within
    that directory is likely to be entirely unofficial – when I talk about a message
    “chunk size” or “subtype” etc, that’s just what I’ve used in the code for lack
    of a better term.
  prefs: []
  type: TYPE_NORMAL
- en: Very high level categorizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the very highest levels of categorization for the protocol:
    everything DigiMixer supports uses the network to communicate, and all over IP.
    There may well be some digital mixers where the client/mixer connection is over
    USB, and as I mentioned before it’s also possible to control some mixers to *some*
    extent using MIDI (which could be via a USB-MIDI connection, dedicated MIDI hardware,
    or even MIDI over IP) – but I haven’t investigated any mixer protocols that aren’t
    network-oriented.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth being really clear about the difference between the “client/mixer”
    protocol and any “client/control surface” protocols. In the same repository as
    DigiMixer, I have some libraries for integration with the [Icon Platform](https://github.com/jskeet/DemoCode/tree/main/IconPlatform)
    and [X-Touch Mini](https://github.com/jskeet/DemoCode/tree/main/XTouchMini) control
    surfaces – both of which are integrated with DigiMixer via an application (which
    currently *isn’t* on public GitHub, unfortunately, as it shares configuration
    with At Your Service). One of the purposes of the abstraction of DigiMixer is
    to allow mixers to be treated as broadly interchangeable – so the same DigiMixer-based
    code that controls (say) a CQ-20B using an X-Touch Mini *should* be able to control
    an X32 with no changes. This post ignores the control surface aspects entirely,
    other than in terms of what we *want* to be able to do with DigiMixer, focusing
    on the client/mixer protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most obvious initial categorization of the protocols is in terms of transport
    (OSI layer 4) protocol: in our case, always UDP or TCP, or a mixture.'
  prefs: []
  type: TYPE_NORMAL
- en: One fairly common pattern (used by the CQ, DM, Qu, StudioLive mixers) is to
    have a TCP connection for control aspects, but report meter levels over UDP. Meters
    show the point-in-time sound level for a particular input or output; typically
    it doesn’t matter if a meter packet is dropped every so often – so it makes sense
    to use UDP for that. It’s obviously rather more important if a “mute this channel”
    message is dropped, so the reliability of TCP is useful there.
  prefs: []
  type: TYPE_NORMAL
- en: The RCF M-18 and the X/M series of Behringer/Midas mixers use OSC over UDP.
    (The DM-3 also supports OSC over UDP, but doesn’t expose enough functionality
    to meet DigiMixer’s requirements.) The unreliability of UDP is worrying here;
    presumably the expectation is that you only operate them on sufficiently reliable
    networks that it’s not a problem, or that clients request “current state” peridiocally
    from the mixer and check it for consistency with their own expected state. My
    experience is that on a wired network with just a single switch between the mixer
    and the client (which would be the common deployment scenario), it’s never *actually*
    caused a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DL and Ui series *only* use TCP as far as I’ve seen (or at least as far
    as DigiMixer is concerned). The Ui series is particularly interesting here; its
    manufacturer-provided user interface is just a web UI. The mixer’s built-in web
    server serves the user interface itself, which connects back to the mixer still
    on port 80 to create a web socket connection. I don’t know enough about web socket
    standards to know how “normal” the implementation is, but it’s very simple to
    code against: issue a request of “GET /raw HTTP1.1”, read the response headers,
    and then it’s just a line-oriented protocol. Each message within the protocol
    (in both directions) is an ASCII line of text. I’ll come back to message formats
    later on.'
  prefs: []
  type: TYPE_NORMAL
- en: Sources of information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working on DigiMixer has been a fascinating exercise in piecing together information
    from multiple sources. Typically the *implementation* of each protocol has been
    relatively straightforward when I’ve had enough information of the protocol itself,
    but that information is hard to come by.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the manufacturer has provided the information itself, either
    officially or unofficially. For the Ui series for example, Harman support responded
    to my enquiry really quickly, sending me documentation which was, while not fully
    comprehensive, easily enough to get started with. (They did stress that this documentation
    was in no way a guarantee of future compatibility or support.)
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, there’s an active community with really strong efforts, including
    a mixture of official and unofficial documentation. The Behringer X series and
    Midas M series (which are basically the same in terms of software, as far as I
    can tell) have lots of active projects to access them via OSC, and the most comprehensive
    documentation comes from [Patrick-Gilles Maillot’s site](https://sites.google.com/site/patrickmaillot/x32).
  prefs: []
  type: TYPE_NORMAL
- en: For the StudioLive mixers, there’s a [GitHub project](https://github.com/featherbear/presonus-studiolive-api)
    and [documentation](https://featherbear.cc/presonus-studiolive-api/#documentation)
    which are strictly unofficial and still at least somewhat incomplete – but invaluable.
    The situation is similar for the RCF M-18, where a [single inactive GitHub repo](https://github.com/Jille/rcf-m18)
    is basically I could find.
  prefs: []
  type: TYPE_NORMAL
- en: For other mixers… there’s [Wireshark](https://www.wireshark.org/). All the digital
    mixers I’ve looked at have manufacturer-supplied clients. When those run on Windows,
    it’s easy to just start Wireshark, open the client and (say) move a fader, then
    close the client and look at the traffic between the mixer and the client. Things
    are slightly more fiddly if the only client provided is an Android or iOS app,
    but I’ve found the [TP-Link TL-SG105E](https://www.tp-link.com/uk/business-networking/easy-smart-switch/tl-sg105e/)
    to be really handy – it’s a small, silent, managed switch which supports port
    mirroring. So all I need to do is plug both my laptop and the mixer into the switch,
    mirror traffic from the mixer port to the laptop port, and again run Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: '[Mixing Station](https://mixingstation.app/) supports all of these mixers too,
    and sometimes it’s useful to look at the traffic between *that* and the mixer
    and compare it with the traffic between the manufacturer-supplied client and the
    mixer.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, capturing the traffic between the mixer and the client doesn’t generally
    *explain* that traffic at all. We don’t need to understand *all* the traffic though
    – only enough for DigiMixer to be effective. So what does that consist of?
  prefs: []
  type: TYPE_NORMAL
- en: DigiMixer requirements for protocol comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I’ve said before, DigiMixer doesn’t try to be a full-fidelity mixer client.
    It only aims to provide control in terms of muting and unmuting, and moving faders
    (for either “overall output” or an “input/output combination” so “aux 1 level”
    or “input 2 level to aux 3” for example). Additionally, it attempts to provide
    information about channel names, general mixer information, any channels that
    are linked together to form stereo pairs, and meter information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In protocol terms, that normally means we need to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: Initial connection requirements, including any “client handshake”. (For mixer
    TCP + UDP protocols, this handshake over TCP sometimes involves each side telling
    the other which UDP port they’re listening on.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to fetch mixer information (model, version, user-specified mixer name)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to fetch the initial state of the mixer (channel names, any stereo links,
    and current fader/mute status)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to send “mute/unmute this channel” and “move this fader” commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the mixer sends to the client if state is changed by *another* client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the mixer sends to the client to report meter levels (potentially including
    how the client requests these in the first place)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some protocols make those requirements very easy to fulfil – others are significantly
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol layers and steps in reverse-engineering a protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve never fully understood the [OSI model](https://en.wikipedia.org/wiki/OSI_model),
    in terms of being able to clearly place any specific bit of a protocol into one
    of the seven layers. However, the idea of layering *in general* has been very
    useful within DigiMixer. Most of the implementations for mixers are implemented
    as two projects, one with a “core” suffix and one without, e.g. `DigiMixer.Mackie.Core`
    and `DigiMixer.Mackie`. The “core” project in each case is focused around what
    I expect would be the presentation layer (and *sometimes* the session layer) in
    OSI; I think of it in terms of *message framing* then *message decomposition*.
    (I believe that I’m using message framing in a perfectly standard way here. There’s
    probably a better name for message decomposition.)
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the protocols used by DigiMixer have the idea of a message:'
  prefs: []
  type: TYPE_NORMAL
- en: TCP connections form a bidirectional stream of messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each UDP connection forms a unidirectional stream of messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (In some protocols the mixer uses UDP connections bidirectionally too – basically
    sending packets to whichever UDP port was used to send packets to it. In other
    protocols the two UDP streams are entirely separate.)
  prefs: []
  type: TYPE_NORMAL
- en: Message framing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the UDP protocols I’ve seen implemented when working on DigiMixer, each
    UDP packet corresponds exactly to one message. There are never UDP packets which
    contain multiple messages, and a message never needs to be split across multiple
    packets.
  prefs: []
  type: TYPE_NORMAL
- en: With TCP, however, it’s a different story. Wireshark allows you to follow a
    TCP stream, showing the flow of data in each direction, but it takes a bit of
    work to figure out how to split each of those streams into messages.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s part of the traffic I see in Wireshark when opening the DM-3 MixPad app
    in Windows, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I *suspect* that the line break after the third line (between bytes 00000024
    and 00000025 outbound) is due to a packet boundary, but it’s also possible that
    Wireshark is doing a little bit more than that, e.g. only showing a line break
    between packets if the gap between them (in terms of time) is above some threshold.
    I’ve generally ignored that, whereas “conversations” of short messages tend to
    make message boundaries fairly clear.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the repeated “MPRO” text at least appears at first glance to indicate
    the start of a message. The four bytes after that “MPRO” then seem to show (in
    big-endian order) the length of the remainder of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, after looking at a reasonable amount of data like the dump
    above, I was able to guess that the DM3 protocol had a message framing of:'
  prefs: []
  type: TYPE_NORMAL
- en: '4 bytes: Message type (e.g. “MPRO”, “EEVT”, “MMIX”)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4 bytes: Message body length, big-endian'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A message framing hypothesis like that is reasonably easy to test, particularly
    after writing a bit of code to parse the text format of a Wireshark hex dump like
    the above. (My experience is that the text format is generally easier than having
    to deal with than the full pcapng files that Wireshark deals with by default.
    The amount of manual work required to follow the TCP stream and then save that
    as text is pretty small.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the protocols I’ve worked with have had some sort of “message header,
    message body” format, where the header includes information about the length of
    the body. There are some differences though:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes there’s some additional state (e.g. a “message counter byte”)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes the message header has no information other than framing, unlike the
    example above, where you really still need to keep the “MPRO” part as the “message
    type” – not that we know what “type” really means yet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes there’s a trailer (e.g. a checksum)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes the length information in the header is *message* length rather than
    *bdoy* length (i.e. the length can include or exclude the header itself, depending
    on the protocol)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of the Ui series, the framing is just based on line breaks instead.
    These two schemes – “message delimiters” (line breaks) or “headers with length
    information” – are the main approaches to message framing that I’ve seen, not
    just in DigiMixer but over the course of my career. (It’s not clear whether you’d
    include the “single message per UDP packet” or “close the TCP connection after
    each message” message framing schemes, or just approaches that mean you don’t
    need message framing at all.) Some protocols have a mixture of the two: HTTP/1.1
    uses delimiters for headers, then specifies a content length within one of the
    headers to allow further requests or responses to be sent on the same connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once I’ve validated a message framing hypothesis in quick-and-dirty code (typically
    in another project with a Tools suffix, e.g. `DigiMixer.Mackie.Tools`) I’ll then
    add that framing into the “core” project, in the form of a message type implementing
    `IMixerMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The addition of this interface into DigiMixer was a relatively new feature,
    as I was waiting for .NET 8 to land. It was predated by the concept of a “message
    processor” which effectively converts a stream of bytes into a stream of messages
    in a suitable form for consumption, but prior to the interface with its fun static
    abstract `TryParse` method, I had to specify various aspects of the message separately.
    Between the message interface, the message processor, and a couple of base classes,
    I now hardly have any code dealing with `TcpClient` and `UdpClient` directly.
    Lovely. (There are now multiple derived classes with hardly any behaviour, and
    I might refactor those at some point, but at least the logic isn’t repeated.)
  prefs: []
  type: TYPE_NORMAL
- en: Message decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Confirming that I’ve understood the message framing for a protocol is immensely
    satisfying, and a necessary first step – but it also tends to be the simplest
    step. It’s often feasible to understand the message framing without understanding
    the whole of the message header, just as in the above example we don’t know what
    the different message types mean, or even how many message types there are. More
    importantly, even if we completely understand the framing, it doesn’t tell us
    anything about the meaning of those messages. They’re just blobs of data.
  prefs: []
  type: TYPE_NORMAL
- en: Message decomposition goes *slightly* further, taking the message body apart
    in terms of its constituent parts – potentially *still* without understanding
    the actual meaning of any values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take the DM-3 example shown above a bit further, it turns out that every
    message body that I’ve seen consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: Byte 0x11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 bytes, again a big-endian integer representing a length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That length in terms of bytes, as the “real” body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That’s just an extra (and redundant as far as I can tell) layer of wrapping,
    but within the “real” body we have a 4-byte set of flags (which do have some pattern
    to them, but I haven’t fully figured out) then a sequence of useful data in segments.
    Each segments consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: A type byte (always 0x11, 0x12, 0x14, 0x24 or 0x31 as far as I’ve seen); more
    on this below
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of “units” being represented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The units themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type byte consists of two nybbles – the first is the “kind” of units (1
    for unsigned integers, including bytes; 2 for signed integers; 3 for characters)
    and then a second for “the number of bytes per unit”. So 0x11 is just a sequence
    of bytes, 0x12 is “a sequence of `UInt16` values”, 0x14 is “a sequence of `UInt32`
    values”, 0x24 is “a sequence of `Int32` values, and 0x31 is basically “a string”
    (which is null-terminated despite also having a length, but hey).
  prefs: []
  type: TYPE_NORMAL
- en: The segments occur one after another, until the end of the “real” body.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for the piece of hex shown earlier from the DM-3 (including a large message
    that was truncated), we can decompose those messages into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: (My formatting is somewhat inconsistent here – I should probably get rid of
    the “`*`” in the lengths for UInt16/UInt32/Int32, but it doesn’t actually hurt
    the readability much… and this is just the output of a fairly quick-and-dirty
    tool.)
  prefs: []
  type: TYPE_NORMAL
- en: There’s still no application-level information here, but we can see the structure
    of the traffic – which makes it much, much easier to then discern *bits* of the
    application level protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Application level protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nothing I’ve described so far is mixer-specific. At some point, some combination
    of message type, flags and values has to actually *mean* something. Maybe it’s
    “please send me the version information about the mixer” or “this is the meter
    levels for the inputs” or “please mute the connection from input channel 1 to
    output channel 5”.
  prefs: []
  type: TYPE_NORMAL
- en: The process of reverse engineering the application level protocol involves both
    inspiration and perspiration – usually in that order, and only after working out
    at least a large proportion of the message framing and message decomposition.
    You don’t need to know everything, but you *do* need to know “if I move a fader
    on the mixer with a different client, I get a message back looking something like
    X.” That takes experimentation and some leaps of faith. But then you need to carefully
    document “well, what’s the difference between moving the fader for input 1, output
    1 or moving the fader for input 2, output 5, or just an output fader?” – and “what’s
    the difference between moving the fader from the bottom of its range to a bit
    higher, and moving it a bit higher still?” That’s somewhat tedious, but still
    surprisingly rewarding work – so long as you can pay enough attention to transcribe
    your results to a log carefully enough.
  prefs: []
  type: TYPE_NORMAL
- en: I’m not going to attempt to describe (here) what the various protocols look
    like at an application level, because they vary so much (even if the lower abstraction
    levels are reasonably similar) – and because there’s so much I still don’t understand
    about them. Once I’ve written up some details, they’ll be on GitHub. But understanding
    how those abstraction levels work at all that’s been really interesting to me
    – and which I suspect will find useful in entirely different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: What’s next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I think after diving into some of the slightly lower level bits of DigiMixer,
    the next post should *probably* be at a very high level, and back towards the
    goal of the whole blog series: abstraction. Assuming I don’t get distracted by
    something else to write about, I’ll try to make the next post as simple as “what
    do mixers have in common, and where do they differ, within the scope of DigiMixer?”
    After that, *maybe* the following post will be about what that abstraction looks
    like in code, and some of the trade-offs I’ve made along the way.'
  prefs: []
  type: TYPE_NORMAL
