<!--yml

category: 未分类

date: 2024-05-27 15:05:21

-->

# 我提交给 CRAN 的旅程 | Andrew Wheeler

> 来源：[`andrewpwheeler.com/2022/07/22/my-journey-submitting-to-cran/`](https://andrewpwheeler.com/2022/07/22/my-journey-submitting-to-cran/)

所以我的 R 包[ptools 已经在 CRAN 上了](https://cran.r-project.org/package=ptools)。CRAN 显然提供了重要的服务 - 我发现我必须处理啰嗦的问题 - 但将在此详细描述我的挣扎，主要是希望其他人将来不必处理相同的问题。长话短说，我知道这可能会很艰难，CRAN 没有让我失望。

最初我在 6 月初提交了这个包，通过了电子邮件验证，但之后没有收到任何邮件回复。我错误地以为它处于手动审查状态。大约一个月后，我给 cran-sysadmin 发了封电子邮件。CRAN 系统管理员立即回了一封电子邮件，解释了自动失败的原因 - 示例太长了 - 但不确定为什么我没有收到自动消息回复（所以它从未到达手动审查阶段）。当我在后来的提交中等价阶段收到自动失败消息时，通常不到一小时就会收到该阶段的自动失败消息。

然后我去修复那些太久的示例（在我个人的机器上都在 5 秒内运行，我有一台价值 400 美元的低端“游戏”台式机，额外加了 100 美元的内存，所以我并不是在一台超级计算机上运行背景）。运行 devtools 的`check()`不同于运行`R CMD check --as-cran path\package.tar.gz`，但也许`check_built()`是一样的，我不确定。所以首先要注意的是，只使用典型的命令行工具，不要在 devtools 上偷懒。

最初，我将我知道太久的示例部分注释掉。然而，在手动审查过程中，有人告诉我不要这样做，而是在`donttest{}`中包裹太长的示例。运行时间的随机变化甚至让我在这方面失败了几次 - 有些示例在某些运行中通过了时间检查，但在其他运行中失败了。一些在我的机器上几乎立即运行的示例在 CRAN 的检查中失败，而在 windows 构建中在 10 秒内失败。（我的示例偶尔使用绘图，并且可能`spplot`是罪魁祸首，以及一些内部不快速并且使用循环的函数。）我在这里没有别的建议，只是始终将绘图函数包装在`donttest{}`中，以及任何对算盘来说太复杂的东西。没有可靠的方法（我可以想到的）知道在我的机器上非常快速的示例将在 CRAN 的检查中花费 10 秒以上的时间。

但是，执行所有这些运行会导致关于拼写错误的其他说明。起初是引文中的姓氏（Wheeler 和 Ratcliffe）。所以我将这些引文拿出来以防止出现说明。后来在手动审查中，我被要求将它们放回去。偶尔 DOI 检查也会失败，[尽管它是正确的 DOI](https://onlinelibrary.wiley.com/doi/10.1002/jip.1449)。

有一件事让我感到困惑 - 一些说明会导致自动失败（例如，示例太长），而其他说明则不会（拼写错误，DOI 检查）。但是对我来说，最终的结果消息是一样的（或者至少我不知道如何解析“这是重要的”说明与“无关紧要的”说明）。在这些与拼写/DOI 说明相关的来回中的讽刺之处在于，描述经历了更改，只是回到了最初的状态。

所以在这一点上（大约提交了 10 次以上），7/16，它终于通过了自动/人工检查的点，上传到了 CRAN。完成得好吗 - 错！然后，当晚晚些时候我收到了来自 Brian Ripley/CRAN 的自动邮件，说它已经上线了，但将在 8/8 被移除，因为`Imports 字段中的命名空间未从导入：'maptools'`。

一个函数使用`requireNamespace("maptools")`来使用 maptools 中的转换函数在 sp/spatspat 对象之间进行转换。这导致了关于 maptools 未加载的“最终”说明。为了解决这个问题，我最终干脆删除了对 maptools 的依赖，因为在本地运行`R CMD check`时使用未导出的函数，例如`maptools:::func`会导致一个说明（因此我认为它会自动失败）。可能有一种更聪明/更合适的方法来使用导入 - 不过，我默认选择做一些我希望能通过 CRAN 检查的事情。

我不确定为什么在这个阶段（已经在 CRAN 上了）这个命名空间是一个破坏性因素，而在之前的阶段不是。再次强调，这只是另一个说明，不是一个警告/错误。但如果我不加以修复，它足以让 CRAN 在几周内移除我的软件包。此电子邮件没有“如果是误报，则发送电子邮件”的选项。

在完成修复后重新提交时，我收到了相同软件包版本的新错误（因为在这一点上它在 CRAN 上），所以我猜我需要将版本增加到 1.0.1，而不是此时修复 1.0.0 包。现在描述中的 DOI 问题会导致“警告”。所以我不确定此更新失败是因为软件包版本（自动失败电子邮件中没有说明或警告）还是因为 DOI 失败（现在又变成了警告，而不是说明）。

为什么有时 DOI 失败会是一个警告，而其他时候则是一种说明，我不知道。在以后的某个阶段，我会把这个有问题的 DOI 删除掉（尽管之前已经进行了手动审核），因为它可能导致自动失败（所有引用也都在示例/文档中）。

好的，所以包版本已增加，命名空间错误已修复。现在正在手动审查 1.0.1 版本，得到一条备注要修复我的错误 - 我的一个测试在 noLD/M1Mac 上失败了（你可能会问什么是 noLD？它是“无长双精度”）。这些在以前技术上也失败了，但我以为我只需要通过 2 个以上的操作系统就可以进入 CRAN 了。于是我此时给 Uwe Ligges 发了一封电子邮件（因为他之前发送了一封关于先前 1.0.0 版本错误的电子邮件），以明确他们到底关心什么（因为我开始第二轮的原因是因为命名空间的威胁，而不是 Macs/noLD 上的测试错误）。Uwe 很快回复说他们关心我的测试失败了，而不是 DOI/命名空间垃圾。

因此，在我的一些确切测试中，我检查了这样的内容`ref <- c(0.25,0.58); act <- round(f,2)`，其中 `f` 是我之前函数调用中收集到的结果。备注将结果舍入到第一个数字，例如失败中的 `0.2 0.5`（我怀疑这是 `testhat` 在打印到控制台上的错误时的一些行为，但我不知道如何精确修复函数调用，以使不会出现双精度）。我只是承认失败，注释掉我认为导致失败的这个测试函数的一部分，任何解决方案我都无法在我的设置中进行测试以查看是否有效。购买者自负，注意我的确切测试*功率*计算函数如果您使用的是无法有长双精度的机器（或者 M1 Mac，我猜，我不懂）可能效果不好。

好的，那个测试修复了，在重新提交后（第二天）我的测试出现了一个*新*错误（现在在 Windows 上） - `Error in sp::CRS(...): PROJ4 argument-value pairs must begin with +`。我不知道为什么现在会出现这个错误，过去一个半月几乎有 20 次提交了。

我传递的投影字符串肯定在前面有一个“+” - 我不知道即使在我尝试修复后连续向 CRAN 提交后（提交简化的 epsg 代码的投影），现在也继续失败。我放弃了，只是删除了那个特定的测试。

Uwe 发来更新的邮件进行手动审查，询问我为什么删除了测试而没有修复它们（或者修复我的代码）。我详细说明了新的 SP 错误（我认为不是我的问题），以及我不知道 noLD/Mac 错误的根本原因（我在 8 月 8 日之前无法调试），代码具有相当好的测试覆盖率（这些函数通过了其他 noLD/Mac 的测试，只有一个失败），并请求他的谅解来上传。他说好的，补丁要提交到 CRAN。从那以后已经过去了 24 小时，所以不能确定我不会收到“将被移除”的自动邮件。

为了明确，这些来回的问题都是我的责任（我确定`\donttest{}`注释在某处[在线文档](https://r-pkgs.org/)中，我应该知道）。在这个过程中，我唯一合理的抱怨是“注意”失败带来了一些模糊性 - 有些注意事项是不可接受的，而有些不是。我怀疑这是因为许多遗留软件包不符合这些严格的检查标准，所以它们不应该自动失败，而应该有一些自由裁量权。

noLD 错误让我质疑现实本身 - 根据 M1 Mac，`0.25 = 0.2`吗？我一生都在过着一个谎言吗？我**真的**知道我的代码是正确的吗？我最终需要启动一个 Docker 镜像，尝试复制 noLD 环境，以了解关于那一个精确测试功率函数的情况。

对于投影误差，最近我没有去过太多地方 - 长岛还存在吗？地球不再是椭圆体吗？在我们的核心，我们只是大脑神经网络中的二进制位吗 - 难道我比机器还差吗？

这里有一个讽刺之处，那些具有更好的测试代码覆盖率的人更有可能失败自动检查（尽管这些软件包也更有可能是正确的！）。这是 CRAN 的预期和合理行为，但它给开发者带来了很大的负担（在自己身上调试 noLD 行为并不容易，而且 M1 Mac 几乎是不可能的，除非你愿意为此付出现金）。

* * *

CRAN 的模型与 Python 的 PyPI 大不相同，我可以向 PyPI 提交一些根本无法安装的东西，或者会安装但在运行`import mypackage`时立即出错。CRAN 的方法更为彻底，但正如我上面所证明的，它有点偏执（在过去一个月里，我的代码没有“功能性”变化）。

我在软件包存储库中真正关心的主要事情是，它没有恶意代码，不会进行可疑的`os`调用和/或将可疑内容发送到互联网上。最终，验证代码的完整性是我自己的责任（即使示例能够工作，也并不意味着代码是正确的，我在 R 上遇到过一些显然错误/误导性的函数）。这不是开源与闭源的问题 - 无论如何，你都需要验证/合理检查一些事情是否按预期工作。

所以我对 CRAN 过多的检查是“值得”的还是不值得的持保留态度。最终，因为你可以做到：

```
library(devtools)
install_github("apwheele/ptools")
```

也许最后这并不重要。你可以查看 github actions，了解它是否在不同的操作系统上运行，并且完全避开 CRAN。
