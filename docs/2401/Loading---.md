<!--yml

类别：未分类

日期：2024-05-27 15:04:36

-->

# 加载中...

> 来源：[https://bugs.openjdk.org/browse/JDK-8321133](https://bugs.openjdk.org/browse/JDK-8321133)

## 概要

通过派生创建增强Java语言的记录。记录是不可变对象，因此开发人员经常从旧记录创建新记录以建模新数据。派生创建通过从现有记录派生新记录，并仅指定不同的组件来简化代码。这是一个[预览语言特性](https://openjdk.org/jeps/12)。

## 目标

+   提供一种简洁的方式来创建从现有记录值派生的新记录值。

+   通过消除提供显式的*wither*方法来简化记录类的声明，这些方法是不可变的setter方法的类比。

## 非目标

+   目前不打算提供一种类似帕斯卡风格的[<code class="prettyprint" >with</code>]构造，简化对任意复杂表达式的访问。

+   目前不打算为一类特殊的wither方法提供支持。

+   目前不打算为普通的非记录值提供派生的创建表达式；这可能是未来JEP的主题。

## 动机

不可变性是一种创建安全、可靠代码并且易于理解的强大技术。在Java语言中编写不可变类传统上是一项繁琐的任务，涉及相当多的样板代码，但是记录类（[JEP 395](https://openjdk.org/jeps/395)），在Java 16中引入，使得声明（浅层）不可变的数据中心类变得简单。

记录类的不可变性确保了安全性和可预测性。它还启用了一些功能，使它们易于使用，包括规范构造函数、访问器方法和明确定义的`Object`方法。但是，我们需要建模的系统仍然具有状态，因此我们需要对这种状态的自然演变进行建模。不幸的是，通过记录类建模的状态的演变可能非常麻烦。例如，考虑一个记录类，它对应于三维空间中的位置：

```
record Point(int x, int y, int z) { }
```

假设我们想通过将`Point` `oldLoc`的`x`坐标加倍来演变状态，得到`Point` `newLoc`：

```
Point newLoc = new Point(oldLoc.x() * 2, oldLoc.y(), oldLoc.z());
```

这段代码虽然直接，但很繁琐。从`oldLoc`派生`newLoc`意味着提取`oldLoc`的每个组件，无论它是否改变，并为`newLoc`的每个组件提供一个值，即使与`oldLoc`相同也是如此。

如果开发人员必须反复解构记录值，提取其所有组件，以便用大部分相同的组件实例化新的记录值，那将是对生产力的持续损失。因此，记录类的作者经常通过声明所谓的*wither*方法来隐藏解构和实例化：

```
record Point(int x, int y, int z) {
    Point withX(int newX) { return new Point(newX, y, z); }
    Point withY(int newY) { return new Point(x, newY, z); }
    Point withZ(int newZ) { return new Point(x, y, newZ); }
}
```

现在可以简洁地从`oldLoc`派生`Point` `newLoc`，并且可以链接方法调用以更改多个组件：

```
Point newLoc = oldLoc.withX(oldLoc.x()*2);

// Double newLoc's y and z components
Point nextLoc = newLoc.withY(newLoc.y()*2)
                      .withZ(newLoc.z()*2);
```

但是，wither方法有两个问题：

+   它们为记录类添加样板代码，这是不幸的，因为记录类的目标是消除诸如 JavaBean getter 和 setter 方法之类的样板代码。

+   一些记录类具有涉及多个组件的语义约束，由规范构造函数强制执行。这意味着在编写 wither 方法时必须特别小心。例如，如果一个记录类有两个必须具有相同长度的 `List` 组件，则不能有仅更新一个 `List` 组件的 wither 方法；我们必须仔细声明一个 wither 方法，以便以一种同时更新两个组件的方式调用规范构造函数。换句话说，wither 方法并不总是简单的样板代码 —— 我们需要考虑语义约束来确定需要什么样的样板代码。

从旧记录值派生新记录值的更好方法是让开发人员专注于转换组件，并让 Java 编译器自动处理记录值的解构和实例化。

## 描述

*派生记录创建表达式* 的形式为

```
e with { ... }
```

例如，要创建一个新的 `Point` 值，其中 `x` 组件设置为 `0`，但 `y` 和 `z` 值派生自现有 `Point` 值 `oldLoc`，可以使用派生记录创建表达式如下：

```
Point nextLoc = oldLoc with {
    x = 0;
};
```

`with` 关键字左侧的表达式，即 `oldLoc`，是初始记录值。 `with` 关键字右侧的块是对初始记录值状态的转换。 状态由三个局部变量 `x`、`y` 和 `z` 表示，它们对应于初始记录值的组件，并且会从这些组件自动初始化；例如，`x` 的值为 `oldLoc.x()`。评估派生记录创建表达式会运行块中的代码以转换 `x`、`y` 和 `z` 中的一部分或全部，然后通过将这些变量传递给规范构造函数，即 `new Point(x, y, z)`，来创建新的记录值。

初始记录值的状态由可变局部变量表示，以便可以在块中查询和更新状态，该块可以更新一部分或全部组件。例如，要将点 `nextLoc` 的比例放大两倍：

```
Point finalLoc = nextLoc with { 
    x *= 2; 
    y *= 2;
    z *= 2;
};
```

新状态通过在块末尾自动调用规范构造函数来验证。这确保了块中的代码遵守任何跨组件的语义约束。在具有两个等长 `List` 组件的记录类的示例中，规范构造函数将检测到是否将块附加到了一个局部 `List` 变量而不是另一个。

要尝试 JDK 23 中的示例，必须启用预览特性：

### 使用派生记录创建表达式

派生记录创建表达式是记录类编程模型的重要组成部分。使用 `with` 派生新记录值对可读性有利，因为它仅关注于更改的状态。它也对正确性有利，因为它自动启用规范构造函数。

`with` 关键字右侧的块只需要提及转换的组件；因此，通过仅对现有记录值进行微小更改来派生新记录值的常见情况得以简洁表达。

如果 `with` 关键字右侧的块为空，则派生记录创建表达式的结果是初始记录值的一个新副本。

派生记录创建表达式可以被链接。这允许将大型转换拆分为一系列较小的步骤，有助于可读性：

```
Point finalLoc = nextLoc
            with { x *= 2; }
            with { y *= 2; }
            with { z *= 2; };
```

记录值可以是嵌套的，其中包含本身是记录值的组件。派生记录创建表达式也可以嵌套，以转换嵌套的记录值：

```
record Marker(Point loc, String label, Icon icon) { }

Marker m = new Marker(new Point(...), ..., ...);
Marker scaled = m with { loc = loc with { x *= 2; y *= 2; z *= 2; }};
```

派生记录创建表达式也可以在记录类内部使用，以简化基本操作的实现：

```
record Complex(double re, double im) {
    Complex conjugate() { return this with { im = -im; }; }
    Complex realOnly()  { return this with { im = 0; }; }
    Complex imOnly()    { return this with { re = 0; }; }
}
```

### 语法和语义

派生记录创建表达式的语法为：

```
DerivedRecordCreationExpression:
  Expression with Block
```

左侧的表达式是 *原始表达式*。原始表达式的类型必须是记录类类型，然后它被视为派生记录创建表达式的整体类型。

右侧的块是 *转换块*。它是一个包含任意块语句的普通块，但它有两个控制流限制：

+   它可能不包含 `return` 语句，且

+   它可能不包含 `yield`、`break` 或其目标包含派生记录创建表达式的 `continue` 语句。

换句话说，控制只能通过正常完成或突然完成、抛出异常来从转换块中转移出来。

对于原始表达式的类型命名的记录类的头部中的每个记录组件，将在转换块内容之前隐式声明一个具有相同名称和类型的本地变量，并将其初始化为组件的值。这些本地组件变量可以隐藏作用域中的任何声明的本地变量。

出现在转换块内的任何赋值语句都有以下约束：如果赋值的左侧是未限定名称，则该名称必须是本地组件变量的名称，或者是显式在转换块中声明的本地变量的名称。

派生记录创建表达式不是一个语句表达式；换句话说，它不能作为语句使用，并在其后跟随分号：

```
finalLoc with { sideEffectingMethod(); }; // Error
```

### 详细评估

派生记录创建表达式的评估如下：

1.  评估原始表达式，其编译时类型命名记录类*R*。如果评估突然完成，则由于相同的原因，派生记录创建表达式的评估也会突然完成。

1.  如果原始表达式的值为`null`，则派生记录创建表达式的评估将以`NullPointerException`突然完成。

1.  在执行转换块的内容之前，按顺序执行从记录类*R*的头部派生的隐式本地变量声明语句序列，以便：

    +   本地变量声明具有与记录组件相同的名称和声明类型。

    +   本地变量声明具有初始值，初始值是通过在原始表达式的值上调用相应的组件访问器方法来给出的。

    如果任何这些本地变量声明语句的评估突然完成，则由于相同的原因，派生记录创建表达式的评估也会突然完成。

1.  执行转换块的内容。如果执行突然完成，则由于相同的原因，派生记录创建表达式的评估也会突然完成。

1.  像通过评估一个新的类实例创建表达式（`new`）一样创建记录类*R*的新实例，其编译时类型为原始表达式的编译时类型，并且参数列表包含本地组件变量（如果有的话），按照它们在记录类*R*的头部中出现的顺序。（这确保调用规范构造函数以创建记录类的实例。）记录类*R*的结果实例被视为派生记录创建表达式的整体值。如果评估新类创建表达式突然完成，则由于相同的原因，派生记录创建表达式的评估也会突然完成。

### 类似于模式匹配

诸如此类的派生记录创建表达式

```
Point finalLoc = nextLoc with {
    x *= 2;
    y *= 2;
    z *= 2;
};
```

可以被视为`switch`表达式

```
Point finalLoc = switch (nextLoc) {
    case Point(var x, var y, var z) -> {
        x *= 2;
        y *= 2;
        z *= 2;
        yield new Point(x, y, z);
    }
};
```

这清楚地表明，派生记录创建表达式基本上将`nextLoc`的值与记录模式进行模式匹配——从而对其进行解构并初始化模式变量`x`、`y`和`z`——然后执行转换块中的语句，然后通过以模式变量的最终值作为参数调用规范构造函数来创建`Point`的新实例。

### 强制执行约束

如果记录类的规范构造函数强制执行约束——正如它应该的那样——那么在构造新的记录值时，派生记录创建表达式隐式地强制执行它们。例如：

```
record Rational(int num, int denom) {
    Rational {
        if (denom == 0)
            throw new IllegalArgumentException("denom must not be zero");
    }
}

Rational r = new Rational(3, 1);     // OK
Rational s = r with { denom = 0; };  // throws IllegalArgumentException
```

评估此派生记录创建表达式将本地变量`num`初始化为3，并将`denom`初始化为1，然后将`denom`赋值为0，然后通过`new Rational(num, denom)`调用规范构造函数。这会抛出一个异常，就像我们明确尝试评估`new Rational(3, 0)`一样。

（派生记录创建表达式中的变换块类似于记录类中紧凑构造函数的主体，因为它们都具有相同的控制流限制（必须正常完成或引发异常），并且都有一组在范围内的隐式声明变量，这些变量预计将被块分配。）

## 替代方案

+   我们可以在声明处支持使用现场创建新记录值的表达式形式，而不是在使用现场支持它，并使用某种特殊支持形式的with方法。我们更喜欢使用现场创建的灵活性，因为声明with方法将为记录类声明添加废话，而记录类当前享有高度的简洁性。

+   而不是支持变换块，我们可以只支持派生记录创建表达式右侧的变量声明列表，例如，`e with { x1 = e1; ..., xn = en; }`。这样做有助于抑制不纯的代码，但可能会笨拙且不必要地限制。

## 风险和假设

+   记录组件与变换块内部局部变量的交互可能导致意外行为的风险非常小。例如，如果变换块引用了一个局部变量，然后相关的记录类被修改为具有相同名称的组件，那么局部变量可能会被变换块隐式声明的局部变量所遮蔽。我们假设这种情况很少见，并且编译器会在必要时发出警告。
