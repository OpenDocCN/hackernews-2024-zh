- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:08:19'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: cohost! - "TCL on the brain/worms"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://cohost.org/sakiamu/post/177439-tcl-on-the-brain](https://cohost.org/sakiamu/post/177439-tcl-on-the-brain)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, first things first, TCL stands for Tool Command Language. It is a language,
    like SmallTalk, IO, or Lisp, which is built around A Big Idea. TCL's big idea
    is that All Values Are Strings. There's a *lot* of consequences to that idea,
    but one of the ones that you hit after the first 10 hours of going "ah, this is
    super cool, I can build UIs at a REPL" is that TCL's type/value system doesn't
    expose references, and actively avoids constructions that could become references
    that aren't based on variables names or namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: So, like, TCL is a *really* cool language and set of libraries, but it, like
    Dark Souls, represents a Different Evolutionary Path amongst its peers. Unlike
    Dark Souls, I don't know that it makes a convincing argument that said path should
    be adopted by the mainstream.
  prefs: []
  type: TYPE_NORMAL
- en: This has consequences. It means that you don't really get mutable closures,
    a la Javascript. It means that when you write code that yields to the TCL event
    loop via `vwait`, it has to wait for writes to a global variable, rather than
    one that's in the current scope. This is at once, almost the promise of await
    that would take the dev world by storm later, but also with *just* enough flaws
    to not take off in nearly the same way. It means that you can reason in terms
    of local scope, the scopes above me, and the global scope, but not in terms of
    little islands of values that can't be edited from the outside, at least that
    I've seen. (though, see also coroutines, I've not tested them here).
  prefs: []
  type: TYPE_NORMAL
- en: And this isn't obvious at first. In a way, it means that TCL has more in common
    with Erlang and it's All Immutable Values, than it does with, say Perl, from a
    values/terms system standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: But, that "Everything is a String" applies to code as well. Which means that
    you can metaprogram code, and turn arguments to a command into a DSL, and that
    TCL, more than many languages, has `eval` and friends at its core.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, TCL is optimized under the hood so that not every usage of a value
    necessarily creates a string. It's more of a moral imperative that values *could*
    become strings, than that they *are* strings at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: This also leaks out into the design of Tk. The core interface to Tk a set of
    commands that create, modify, and layout various Tk widgets. But, those widgets
    are also store in a name heirarchy, not unlike a filesystem in layout. Also each
    widget is turned into a proc/command for easy access and configuration at a REPL.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you wanted to make 10-key number pad, it might look something like this
    in terms of code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here we see a lot of the TCL quirks discussed before. `num_handler` is acting
    more like a macro here than a regular function via string interpolation. `.numpad_0`
    is a command, with `-configure` as a subcommand. If we had nested controls, such
    as putting this in a panel, then we'd have command names like `.panel.numpad_0`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that Tk code that nests widgets has to work inside that name hierarchy.
    It also means that for someone to be able to move widgets in that heirarchy, there'd
    need to be tkmove commands that, to my knowledge, do not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Anywho, TCL is neat, but weird, and tends to force you to use more powerful
    tools, like metaprogramming, where other languages, due to having more data flexiblity,
    allow you to use less powerful tools, like lambda functions.
  prefs: []
  type: TYPE_NORMAL
