- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:08:19'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: cohost! - "TCL on the brain/worms"
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://cohost.org/sakiamu/post/177439-tcl-on-the-brain](https://cohost.org/sakiamu/post/177439-tcl-on-the-brain)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, first things first, TCL stands for Tool Command Language. It is a language,
    like SmallTalk, IO, or Lisp, which is built around A Big Idea. TCL's big idea
    is that All Values Are Strings. There's a *lot* of consequences to that idea,
    but one of the ones that you hit after the first 10 hours of going "ah, this is
    super cool, I can build UIs at a REPL" is that TCL's type/value system doesn't
    expose references, and actively avoids constructions that could become references
    that aren't based on variables names or namespaces.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: So, like, TCL is a *really* cool language and set of libraries, but it, like
    Dark Souls, represents a Different Evolutionary Path amongst its peers. Unlike
    Dark Souls, I don't know that it makes a convincing argument that said path should
    be adopted by the mainstream.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: This has consequences. It means that you don't really get mutable closures,
    a la Javascript. It means that when you write code that yields to the TCL event
    loop via `vwait`, it has to wait for writes to a global variable, rather than
    one that's in the current scope. This is at once, almost the promise of await
    that would take the dev world by storm later, but also with *just* enough flaws
    to not take off in nearly the same way. It means that you can reason in terms
    of local scope, the scopes above me, and the global scope, but not in terms of
    little islands of values that can't be edited from the outside, at least that
    I've seen. (though, see also coroutines, I've not tested them here).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: And this isn't obvious at first. In a way, it means that TCL has more in common
    with Erlang and it's All Immutable Values, than it does with, say Perl, from a
    values/terms system standpoint.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: But, that "Everything is a String" applies to code as well. Which means that
    you can metaprogram code, and turn arguments to a command into a DSL, and that
    TCL, more than many languages, has `eval` and friends at its core.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Of course, TCL is optimized under the hood so that not every usage of a value
    necessarily creates a string. It's more of a moral imperative that values *could*
    become strings, than that they *are* strings at any given time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: This also leaks out into the design of Tk. The core interface to Tk a set of
    commands that create, modify, and layout various Tk widgets. But, those widgets
    are also store in a name heirarchy, not unlike a filesystem in layout. Also each
    widget is turned into a proc/command for easy access and configuration at a REPL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: So, if you wanted to make 10-key number pad, it might look something like this
    in terms of code
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we see a lot of the TCL quirks discussed before. `num_handler` is acting
    more like a macro here than a regular function via string interpolation. `.numpad_0`
    is a command, with `-configure` as a subcommand. If we had nested controls, such
    as putting this in a panel, then we'd have command names like `.panel.numpad_0`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了之前讨论过的很多 TCL 怪癖。`num_handler` 在这里更像是一个宏，而不是通过字符串插值来实现的常规函数。`.numpad_0`
    是一个命令，带有 `-configure` 作为子命令。如果我们有嵌套控件，比如将其放在面板中，那么我们将会有像 `.panel.numpad_0` 这样的命令名称。
- en: This means that Tk code that nests widgets has to work inside that name hierarchy.
    It also means that for someone to be able to move widgets in that heirarchy, there'd
    need to be tkmove commands that, to my knowledge, do not exist.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着嵌套小部件的 Tk 代码必须在该名称层次结构内运行。这也意味着，要让某人能够在该层次结构中移动小部件，需要有我所知道的 tkmove 命令，但实际上并不存在。
- en: Anywho, TCL is neat, but weird, and tends to force you to use more powerful
    tools, like metaprogramming, where other languages, due to having more data flexiblity,
    allow you to use less powerful tools, like lambda functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，TCL 很整洁，但又很奇怪，并且倾向于迫使您使用更强大的工具，如元编程，而其他语言则由于具有更多的数据灵活性，允许您使用不那么强大的工具，如 lambda
    函数。
