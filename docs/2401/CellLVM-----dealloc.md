<!--yml

类别：未分类

日期：2024-05-27 14:32:12

-->

# CellLVM // -dealloc

> 来源：[`belkadan.com/blog/2023/12/CellLVM/`](https://belkadan.com/blog/2023/12/CellLVM/)

几周前我发布了这个：

<https://belkadan.com/blog/2023/12/CellLVM/CellLVM.mp4>

[（屏幕录像）](https://belkadan.com/blog/2023/12/CellLVM/CellLVM.mp4)

如果你现在不想观看视频的话，这是一个 LLVM 到 Excel 电子表格编译器的概念证明。

### 什么。

前一天晚上，我和朋友们谈论了[CSV](https://en.wikipedia.org/wiki/Comma-separated_values)，特别是开玩笑地谈论了对齐图表以及什么被认为是“真正的”CSV。有人指出，按照传统方式打印的汇编代码可以作为 CSV，对此我回应道

> 哦，Excel 中的汇编几乎回到了一个好主意
> 
> 你的标签是行引用

当我躺在床上时，我意识到这比我最初想象的更匹配。忘记 CSV 部分，行引用是让 Excel 进行*计算*的关键。虽然你可以用汇编实现这个功能，但有一个更好的选择：LLVM。

### SSA 格式

[LLVM](https://llvm.org)是用于构建编译器及相关工具的库——实际上是 Swift 和 Rust 使用的库。^(它的核心是一种简化的语言，也称为 LLVM，或者可能是“[LLVM 指令集](https://llvm.org/docs/LangRef.html)”。“除了被设计为编译高级语言的中间阶段之外，这种语言的独特之处在于，每个局部变量仅被分配一次值，作为一个简单的表达式，只能依赖于它之前的变量。这被称为[静态单赋值形式](https://en.wikipedia.org/wiki/Static_single-assignment_form)。”)

我的洞察力，我认为这并不是新的，是 Excel 公式也是同样的工作方式。任何带有公式的单元格都会提前定义该公式，并且值根据公式中设置的引用在电子表格中流动——就像 SSA 一样。因此，对于 LLVM 和 Excel 都支持的操作，应该可以将 LLVM 函数重写为执行相同计算的 Excel 表格！

我兴奋地入睡了，想着那个想法。醒来后我意识到它的主要问题：循环怎么办呢？

### Phi 节点

为了让 SSA 能够表示分支控制流程（例如条件递增），在分支合并时它必须具有某种历史概念。传统的方法是使用一种特殊类型的表达式，称为*phi 节点*，它基本上表示“如果我们来自真块，则使用 x[1]作为值；如果我们来自 else 块，则使用 x[2]作为值”。名称“phi”并不是任何东西的缩写；它显然只是意味着接近“if”的反向。^(这种形式也适用于开关（只是有更多可能的前导），甚至循环：循环体的前导可能是循环的入口，也可能是循环*上一次*的最后一个块。)

但是电子表格没有循环，对吧？我搜索了一下，发现我错了：Excel 电子表格*确实*支持循环，以“迭代计算”的形式。只要公式在一定步数内收敛到一个固定点，Excel 会找到它。所以现在我需要弄清楚如何以这样一种方式编码循环，使得它们实际上会收敛。

这时，我从床上站起来，在 Google 表格中开始胡乱操作。（那天是周末，我不用去上班。）然后我找到了一个解决方案：一种实际 CPU 使用的经典“程序计数器”的变体。如果你跟踪你访问的块的数量，计数重复，那么你总是知道“当前”块是什么，更重要的是知道“上一个”块是什么。这意味着你可以实现 phi 节点。

这就是 Excel 中 phi 表达式的样子：

| `=CHOOSE(` | Phi 是一个选择… |
| --- | --- |
| `XMATCH(` | 基于来源值的… |
| `MAX(` | 这是最新的（最大）PC… |
| `IF(B5=ROW(),C5,0),` | 如果来自第 5 行的分支要来到这里… |
| `IF(B10=ROW(),C10,0),` | 如果来自第 10 行的分支要来到这里… |
| `C7-0.5),` | 和当前行 7，作为最后一手… |
| `{C5,C10,C7-0.5}),` | 我们通过`XMATCH`得到的索引… |
| `B4,B8,B7)` | 然后`CHOOSE`出正确的值 |

不够漂亮，但它完成了工作。有了这一点，我知道了这是可能的，然后着手构建编译器。

### 编译器

实际的编译器仅有 150 行代码，部分是因为它几乎没有实现任何功能，但也因为它实际上没有做太多工作。所有的艰辛工作都在 LLVM（以及它的包装，[LLVMSwift](https://github.com/llvm-swift/LLVMSwift)，我不得不[派生出的](https://belkadan.com/source/LLVMSwift/)）和[xslxwriter](https://libxlsxwriter.github.io/)（以及[它自己的包装](https://github.com/damuellen/xlsxwriter.swift)）中。没有这些预先存在的库，这么快完成这项工作是不可能的。

编译器在单个 LLVM 函数上进行两次操作：一次是为指令和基本块分配行，另一次是将每条指令翻译成公式，1：1。\只有三列相关：包含指令类型的标签，每条指令的值，以及上面描述的“程序计数器”。[如果你愿意，可以阅读整篇文章。](https://belkadan.com/source/CellLVM/)

结果是一个命令行工具，以 LLVM 位代码为输入，并生成 xlsx 文件为输出。如果输入中有超过一个函数，或者有一个它不支持的操作（比如减法），它会抛出错误。但我确实认为这是一个有效的概念验证！当然也是一个成功的项目——这一点很重要，尤其是在[这些天我在工作之外几乎没有时间在电脑上花太多时间。](https://belkadan.com/blog/2021/07/Keyboard-Pants/)

[上面视频的输出在 Google Sheets 上](https://docs.google.com/spreadsheets/d/1_K4gMtS0GGviPAIFkhGZmXXFXvuaAatxcx2ulM1XZXk/edit)，尽管您需要制作自己的副本如果您想要“运行”它。（目前实现的大约所有内容都知道如何处理。）

### 未来方向：alloca

在这个概念验证中*没有*实现的一件事是 alloca，即本地变量。 这既不方便，因为这是非优化构建的默认值，也是真正将 LLVM 编译为电子表格的*确实缺失的一部分*。 问题是，LLVM 的加载和存储指令*明显*是命令式的，而电子表格则不是。 因此，要实际表示一个内存位置，我们可能需要将加载表示为“具有匹配位置的最近存储的值”，类似于我们如何表示 phi 为“基于最近的基本块的数值之一”。 关于循环可能存在一些棘手的问题——也许“程序计数器”实际上应该计算指令而不仅仅是基本块，所以“最近的”可以包括“但不包括我的未来”。

一旦在这里，跳到*任意*内存分配仍然是一件大事，但也许不像它本应该的那样大。 只要将存储器分解为单个字段，我们就可以说 H 列代表堆内存，I 列代表它上次修改的时间。 这将是涉及*程序中每条存储指令*的一个公式，但可能有效。 尽管如此，我还没有尝试详细研究这个问题。

### 未来方向：调用堆栈

另一个重要的遗漏是函数调用。 对于非递归函数，这主要是一种奇怪的分支/phi 组合，但对于递归函数，我们有一个问题：我们所有的局部 SSA 变量都需要双重执行！ 我没有一个好主意来解决这个问题，除非使用*列*来表示堆栈帧。（其中堆栈溢出将耗尽具有正确公式的列。）这也很好，因为您可以*看到调用堆栈*，但我还没有想清楚它是否实际上有效。

此条目发布于[2023 年](https://belkadan.com/blog/2023)年[12 月](https://belkadan.com/blog/2023/12)28 日，并归档在[技术](https://belkadan.com/blog/technical)下。 标签：[编译器](https://belkadan.com/blog/tags/compilers)，[LLVM](https://belkadan.com/blog/tags/llvm)，[电子表格](https://belkadan.com/blog/tags/spreadsheets)，[源代码](https://belkadan.com/blog/tags/source-code)
