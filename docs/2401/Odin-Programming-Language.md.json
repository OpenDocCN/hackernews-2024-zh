["```\npackage main\n\nimport \"core:fmt\"\n\nmain :: proc() {\n\tprogram := \"+ + * ðŸ˜ƒ - /\"\n\taccumulator := 0\n\n\tfor token in program {\n\t\tswitch token {\n\t\tcase '+': accumulator += 1\n\t\tcase '-': accumulator -= 1\n\t\tcase '*': accumulator *= 2\n\t\tcase '/': accumulator /= 2\n\t\tcase 'ðŸ˜ƒ': accumulator *= accumulator\n\t\tcase: // Ignore everything else\n\t\t}\n\t}\n\n\tfmt.printf(\"The program \\\"%s\\\" calculates the value %d\\n\",\n\t           program, accumulator)\n}\n```", "```\npackage main\n\nimport \"core:fmt\"\n\nmain :: proc() {\n\t{\n\t\ta := [3]f32{1, 2, 3}\n\t\tb := [3]f32{5, 6, 7}\n\t\tc := a * b\n\t\td := a + b\n\t\te := 1 +  (c - d) / 2\n\t\tfmt.printf(\"%.1f\\n\", e) // [0.5, 3.0, 6.5]\n\t}\n\n\t{\n\t\ta := [3]f32{1, 2, 3}\n\t\tb := swizzle(a, 2, 1, 0)\n\t\tassert(b == [3]f32{3, 2, 1})\n\n\t\tc := a.xx\n\t\tassert(c == [2]f32{1, 1})\n\t\tassert(c == 1)\n\n\t\td := swizzle(a, 0, 0)\n\t\tassert(d == [2]f32{1, 1})\n\t\tassert(d == 1)\n\t}\n\n\t{\n\t\tVector3 :: distinct [3]f32\n\t\ta := Vector3{1, 2, 3}\n\t\tb := Vector3{5, 6, 7}\n\t\tc := (a * b)/2 + 1\n\t\td := c.x + c.y + c.z\n\t\tfmt.printf(\"%.1f\\n\", d) // 22.0\n\n\t\tcross :: proc(a, b: Vector3) -> Vector3 {\n\t\t\ti := a.yzx * b.zxy\n\t\t\tj := a.zxy * b.yzx\n\t\t\treturn i - j\n\t\t}\n\n\t\tcross_explicit :: proc(a, b: Vector3) -> Vector3 {\n\t\t\ti := swizzle(a, 1, 2, 0) * swizzle(b, 2, 0, 1)\n\t\t\tj := swizzle(a, 2, 0, 1) * swizzle(b, 1, 2, 0)\n\t\t\treturn i - j\n\t\t}\n\n\t\tblah :: proc(a: Vector3) -> f32 {\n\t\t\treturn a.x + a.y + a.z\n\t\t}\n\n\t\tx := cross(a, b)\n\t\tfmt.println(x)\n\t\tfmt.println(blah(x))\n\t}\n}\n```", "```\npackage main\n\nimport \"core:fmt\"\n\nmain :: proc() {\n\t{\n\t\tVector3 :: struct {x, y, z: f32}\n\n\t\tN :: 2\n\t\tv_aos: [N]Vector3\n\t\tv_aos[0].x = 1\n\t\tv_aos[0].y = 4\n\t\tv_aos[0].z = 9\n\n\t\tfmt.println(len(v_aos))\n\t\tfmt.println(v_aos[0])\n\t\tfmt.println(v_aos[0].x)\n\t\tfmt.println(&v_aos[0].x)\n\n\t\tv_aos[1] = {0, 3, 4}\n\t\tv_aos[1].x = 2\n\t\tfmt.println(v_aos[1])\n\t\tfmt.println(v_aos)\n\n\t\tv_soa: #soa[N]Vector3\n\n\t\tv_soa[0].x = 1\n\t\tv_soa[0].y = 4\n\t\tv_soa[0].z = 9\n\n\t\t// Same syntax as AOS and treat as if it was an array\n\t\tfmt.println(len(v_soa))\n\t\tfmt.println(v_soa[0])\n\t\tfmt.println(v_soa[0].x)\n\t\tfmt.println(&v_soa[0].x)\n\t\tv_soa[1] = {0, 3, 4}\n\t\tv_soa[1].x = 2\n\t\tfmt.println(v_soa[1])\n\n\t\t// Can use SOA syntax if necessary\n\t\tv_soa.x[0] = 1\n\t\tv_soa.y[0] = 4\n\t\tv_soa.z[0] = 9\n\t\tfmt.println(v_soa.x[0])\n\n\t\t// Same pointer addresses with both syntaxes\n\t\tassert(&v_soa[0].x == &v_soa.x[0])\n\n\t\t// Same fmt printing\n\t\tfmt.println(v_aos)\n\t\tfmt.println(v_soa)\n\t}\n\t{\n\t\t// Works with arrays of length &lt= 4 which have the implicit fields xyzw/rgba\n\t\tVector3 :: distinct [3]f32\n\n\t\tN :: 2\n\t\tv_aos: [N]Vector3\n\t\tv_aos[0].x = 1\n\t\tv_aos[0].y = 4\n\t\tv_aos[0].z = 9\n\n\t\tv_soa: #soa[N]Vector3\n\n\t\tv_soa[0].x = 1\n\t\tv_soa[0].y = 4\n\t\tv_soa[0].z = 9\n\t}\n\t{\n\t\t// SOA Slices\n\t\t// Vector3 :: struct {x, y, z: f32}\n\t\tVector3 :: struct {x: i8, y: i16, z: f32}\n\n\t\tN :: 3\n\t\tv: #soa[N]Vector3\n\t\tv[0].x = 1\n\t\tv[0].y = 4\n\t\tv[0].z = 9\n\n\t\ts: #soa[]Vector3\n\t\ts = v[:]\n\t\tassert(len(s) == N)\n\t\tfmt.println(s)\n\t\tfmt.println(s[0].x)\n\n\t\ta := s[1:2]\n\t\tassert(len(a) == 1)\n\t\tfmt.println(a)\n\n\t\td: #soa[dynamic]Vector3\n\n\t\tappend_soa(&d, Vector3{1, 2, 3}, Vector3{4, 5, 9}, Vector3{-4, -4, 3})\n\t\tfmt.println(d)\n\t\tfmt.println(len(d))\n\t\tfmt.println(cap(d))\n\t\tfmt.println(d[:])\n\t}\n\t{ // soa_zip and soa_unzip\n\t\tfmt.println(\"\\nsoa_zip and soa_unzip\")\n\n\t\tx := []i32{1, 3, 9}\n\t\ty := []f32{2, 4, 16}\n\t\tz := []b32{true, false, true}\n\n\t\t// produce an #soa slice the normal slices passed\n\t\ts := soa_zip(a=x, b=y, c=z)\n\n\t\t// iterate over the #soa slice\n\t\tfor v, i in s {\n\t\t\tfmt.println(v, i) // exactly the same as s[i]\n\t\t\t// NOTE: 'v' is NOT a temporary value but has a specialized addressing mode\n\t\t\t// which means that when accessing v.a etc, it does the correct transformation\n\t\t\t// internally:\n\t\t\t//         s[i].a === s.a[i]\n\t\t\tfmt.println(v.a, v.b, v.c)\n\t\t}\n\n\t\t// Recover the slices from the #soa slice\n\t\ta, b, c := soa_unzip(s)\n\t\tfmt.println(a, b, c)\n\t}\n}\n```", "```\npackage main\n\nimport \"core:mem\"\n\nmain :: proc() {\n\t// In each scope, there is an implicit value named context. This\n\t// context variable is local to each scope and is implicitly passed\n\t// by pointer to any procedure call in that scope (if the procedure\n\t// has the Odin calling convention).\n\n\t// The main purpose of the implicit context system is for the ability\n\t// to intercept third-party code and libraries and modify their\n\t// functionality. One such case is modifying how a library allocates\n\t// something or logs something. In C, this was usually achieved with\n\t// the library defining macros which could be overridden so that the\n\t// user could define what they wanted. However, not many libraries\n\t// supported this in many languages by default which meant intercepting\n\t// third-party code to see what it does and to change how it does it is\n\t// not possible.\n\n\tc := context // copy the current scope's context\n\n\tcontext.user_index = 456\n\t{\n\t\tcontext.allocator = my_custom_allocator()\n\t\tcontext.user_index = 123\n\t\twhat_a_fool_believes() // the `context` for this scope is implicitly passed to `what_a_fool_believes`\n\t}\n\n\t// `context` value is local to the scope it is in\n\tassert(context.user_index == 456)\n\n\twhat_a_fool_believes :: proc() {\n\t\tc := context // this `context` is the same as the parent procedure that it was called from\n\t\t// From this example, context.user_index == 123\n\t\t// An context.allocator is assigned to the return value of `my_custom_allocator()`\n\t\tassert(context.user_index == 123)\n\n\t\t// The memory management procedure use the `context.allocator` by\n\t\t// default unless explicitly specified otherwise\n\t\tchina_grove := new(int)\n\t\tfree(china_grove)\n\n\t\t_ = c\n\t}\n\n\tmy_custom_allocator :: mem.nil_allocator\n\t_ = c\n\n\t// By default, the context value has default values for its parameters which is\n\t// decided in the package runtime. What the defaults are are compiler specific.\n\n\t// To see what the implicit context value contains, please see the following\n\t// definition in package runtime.\n} \n```", "```\npackage main\n\nimport \"core:fmt\"\nimport \"core:reflect\"\n\nmain :: proc() {\n\tFoo :: struct {\n\t\tx: int    `tag1`,\n\t\ty: string `json:\"y_field\"`,\n\t\tz: bool, // no tag\n\t}\n\n\tid := typeid_of(Foo)\n\tnames := reflect.struct_field_names(id)\n\ttypes := reflect.struct_field_types(id)\n\ttags  := reflect.struct_field_tags(id)\n\n\tassert(len(names) == len(types) && len(names) == len(tags))\n\n\tfmt.println(\"Foo :: struct {\")\n\tfor tag, i in tags {\n\t\tname, type := names[i], types[i]\n\t\tif tag != \"\" {\n\t\t\tfmt.printf(\"\\t%s: %T `%s`,\\n\", name, type, tag)\n\t\t} else {\n\t\t\tfmt.printf(\"\\t%s: %T,\\n\", name, type)\n\t\t}\n\t}\n\tfmt.println(\"}\")\n\n\tfor tag, i in tags {\n\t\tif val, ok := reflect.struct_tag_lookup(tag, \"json\"); ok {\n\t\t\tfmt.printf(\"json: %s -> %s\\n\", names[i], val)\n\t\t}\n\t}\n}\n```"]