["```\nuint32_t state;   int rand() {\n state = state * 214013 + 2531011;\n  return (state >> 16) & 0x7fff; } \n```", "```\nimport random   A = 214013 B = 2531011   class MsvcRng:\n  def __init__(self, state):\n self.state = state   def __call__(self):\n self.state = (self.state * A + B) % 2**32\n  return (self.state >> 16) & 0x7fff   # Create a random RNG state we'll reverse engineer. hidden_rng = MsvcRng(random.randint(0, 2**32))   # Compute guesses for hidden state from 2 observations. r0 = hidden_rng() r1 = hidden_rng() c = (2**16 * (r1 - A * r0) - B) % 2**31 ceil_div = lambda a, b: (a + b - 1) // b h_guesses = [ceil_div(c + 2**31 * k, A) for k in range(-1, 7)]   # Validate guesses until a single guess remains. guess_rngs = [MsvcRng(2**16 * r0 + h0) for h0 in h_guesses] guess_rngs = [g for g in guess_rngs if g() == r1] while len(guess_rngs) > 1:\n r = hidden_rng() guess_rngs = [g for g in guess_rngs if g() == r]\n  # The top bit can not be recovered as it never affects the output, # but we should have recovered the effective hidden state. assert guess_rngs[0].state % 2**31 == hidden_rng.state % 2**31 \n```"]