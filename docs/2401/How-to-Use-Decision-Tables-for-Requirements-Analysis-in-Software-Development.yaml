- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:24:34'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: How to Use Decision Tables for Requirements Analysis in Software Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.methodsandtools.com/archive/archive.php?id=39](https://www.methodsandtools.com/archive/archive.php?id=39)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**How to Use a Decision Table Methodology to Analyze Complex Conditional Actions
    Requirements in Software Development**'
  prefs: []
  type: TYPE_NORMAL
- en: D. Robert Baker
  prefs: []
  type: TYPE_NORMAL
- en: '**Background: Decisions**'
  prefs: []
  type: TYPE_NORMAL
- en: A decision is a choice about a "course of action". A course of action may include
    many individual actions. A decision may be characterized on a continuum from unstructured
    to structured (Simon 1960) [1].
  prefs: []
  type: TYPE_NORMAL
- en: '**Unstructured Decisions**'
  prefs: []
  type: TYPE_NORMAL
- en: Unstructured decisions are generally one-time propositions taken in emergent
    situations (Holsapple and Whinston 1996) [2], i.e. the set of conditions are unique
    and there are no fixed rules for the course of action to take based on the conditions.
    The possible courses of action need not be finite. Making an unstructured decision
    is therefore heuristic. Automating such decisions involves the use of Decision
    Support Systems, which attempt to obtain and organize as much relevant information
    as possible for presentation to the decision maker. The decision maker then applies
    whatever heuristics he considers appropriate to come up with a course of action.
  prefs: []
  type: TYPE_NORMAL
- en: '**Structured Decisions**'
  prefs: []
  type: TYPE_NORMAL
- en: Structured decisions are predictable, i.e. given a particular set of conditions,
    the course of action to be taken is clear and definable. The choice is which actions
    to take among a predefined, finite collection of actions. Making a structured
    decision is therefore algorithmic. There are three common methods of expressing
    these algorithms. Note that all three of these methods are capable of dealing
    with multivariate, not merely binary conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to Use a Decision Table Methodology in Software Development](img/910eb5339937477cbbede784f04c983d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1 - A typical natural language expression of a simple policy
  prefs: []
  type: TYPE_NORMAL
- en: for charging for in-flight services on charter flights
  prefs: []
  type: TYPE_NORMAL
- en: '**Structured English**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Structured English is an attempt to allow the use of natural language, stripped
    of ambiguity, to express actions to be taken under particular conditions. This
    is accomplished by:'
  prefs: []
  type: TYPE_NORMAL
- en: choosing a simple subset of natural language verbs and nouns, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defining constructs to express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this stripping of ambiguity is sufficiently rigorous, the resulting definition
    defines an executable programming language. This was the approach taken in the
    creation of the original procedural computer language compilers in the 50s and
    60s. These definitions were (and remain) so complex that programmers required
    months and even years of training to acquire competence in the syntax and semantics
    of the definition. This made it almost impossible to combine knowledge of the
    business domain and technical proficiency in the programming language in one individual.
  prefs: []
  type: TYPE_NORMAL
- en: Less rigorous non-executable Structured English definitions are known as *pseudocode*
    and are used as analytical tools by analysts to create an intermediate specification.
    This specification is passed to programmers who translate it into actual compiler-compliant
    code. This extra step results in added expense both because of extra specialist
    personnel and because of the inevitable miscommunications and errors involved
    in an intermediate translation.
  prefs: []
  type: TYPE_NORMAL
- en: Attempts were made in the 70s and 80s to create "natural computer languages"
    (e.g. NATURAL, ENGLISH) with much looser syntactic and semantic restrictions.
    The hope was to eliminate the intermediate step by empowering the compiler to
    successfully interpret the "sloppy" natural language of the domain expert directly.
    These efforts met with limited success and are rarely seen today.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to Use a Decision Table Methodology in Software Development](img/5fb4f4c19a4f195cb96a261f7f819a7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2 a typical executable structured English expression of the policy in
    Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: '**Decision Trees**'
  prefs: []
  type: TYPE_NORMAL
- en: A decision tree is a graphic tool that represents conditions and their resulting
    actions. It consists of a directed acyclic graph (rooted tree) in which the non-terminal
    edges represent a set of conditions evaluated sequentially from the root. A node
    is a decision point where a condition is evaluated. The terminal edges (leaves)
    represent actions.
  prefs: []
  type: TYPE_NORMAL
- en: Decision trees are a useful tool for expressing complex decision variables in
    a format conducive to human visualization. Software that directly manipulates
    decision trees is available (Oblique Classifier 1, TreePlan), but tends to be
    limited to highly technical scientific specialties like astronomy or DNA sequence
    analysis and requires a high degree of technical sophistication to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to Use a Decision Table Methodology in Software Development](img/2827abcd09309a8c5f4b128294287861.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3\. a typical decision tree of the policy in Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: '**Decision Tables**'
  prefs: []
  type: TYPE_NORMAL
- en: A decision table is a two-dimensional matrix with one row for each possible
    action and one row for each relevant condition and one column for each combination
    of condition states. A decision table can very concisely and rigorously show complex
    conditions and their resulting actions while remaining comprehensible to a human
    reader.
  prefs: []
  type: TYPE_NORMAL
- en: The first set of rows indicates the possible actions that may be taken. An "X"
    in an action row shows that the action will be taken under the condition states
    indicated in the column below.
  prefs: []
  type: TYPE_NORMAL
- en: In a bivariate decision table, conditions are binary, restricting condition
    evaluations to "yes" and "no". This results in a number of columns equal to 2
    ^(number of conditions). This can quickly result in a huge number of columns as
    the number of conditions rise. Fortunately, it is unusual that every combination
    of conditions results in a different action.
  prefs: []
  type: TYPE_NORMAL
- en: In Figure 4, the use of the "-", or "don't care" notation is illustrated. This
    means that the condition in that row does not affect the action to be taken. Looking
    at the first column, we see that no action will be taken no matter the state of
    the last two conditions as long as the first condition is false. Each "don't care"
    reduces the number of columns necessary and increases the comprehensibility of
    the table. In this example the 2³ = 8 possible combinations are reduced to 4.
  prefs: []
  type: TYPE_NORMAL
- en: The most common tool for the creation of decision tables is spreadsheet software,
    such as Microsoft Excel. Although this is really quite sophisticated software,
    it is cheap, readily available, and has a large base of trained users. Because
    of the ubiquity and sophistication of this software, it is quite easy to create
    additional software that can read decision tables created in the spreadsheet,
    understand the semantics therein contained, and take action to implement the logic
    expressed in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Such simple software finally allows the removal of the "3^(rd) man" in the analysis-synthesis
    process, allowing an analyst or even a logic-savvy policy expert alone to directly
    create executable code to implement policy.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to Use a Decision Table Methodology in Software Development](img/3a690bdff71bb6a4de6d8f2ab55ffeac.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4 a typical bivariate decision table of the policy in Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: '**Taking Action: Decision Table Methods for Describing Policy**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that we have:'
  prefs: []
  type: TYPE_NORMAL
- en: a method of expressing policy that is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: concise,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: comprehensive,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rigorous, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: easy to use and understand, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a mechanism for machine translation directly from this expression to executable
    code that implements the policy,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we get from the messy real world of policy to a nice, neat, unambiguous
    decision table in a spreadsheet ready for machine translation?
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Determine Policy Scope'
  prefs: []
  type: TYPE_NORMAL
- en: 'A project without a predefined scope is subject to peril in the forms of:'
  prefs: []
  type: TYPE_NORMAL
- en: '***   Scope creep**'
  prefs: []
  type: TYPE_NORMAL
- en: '***   Lack of definition of project completion criteria**'
  prefs: []
  type: TYPE_NORMAL
- en: It is often difficult to define terms for project scope that are unambiguous
    and easily determinable to meet the needs of all parties. The use of decision
    tables makes this a very straightforward task.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of a policy project is determined by delineating all the policy that
    to be implemented. In decision table terms, policy implementation is expressed
    by actions. The project itself consists of determining and expressing the conditions
    under which these actions will be taken.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of a decision table-based policy project is determined by enumerating
    all the actions that may possibly be taken. **Such an enumeration is simple, unambiguous
    and clearly defines the boundaries of the project beyond argument.**
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e72e886ce8f3e33c1dccb004b17e214.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5 a typical statement of scope for the policy expressed in Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Determine Policy Authority**'
  prefs: []
  type: TYPE_NORMAL
- en: What *are* our policies, anyway? Where do we find them? Are they all written
    in point form in a big book somewhere? Is there one person in an office somewhere
    who knows them all and can explain them on demand? Probably not.
  prefs: []
  type: TYPE_NORMAL
- en: In most organizations, the sum total of policy is known and maintained by an
    intricate network of documentation and subject matter experts. It's rare to find
    a single source.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, personnel come and go. Expertise is gained and lost. Documentation
    is constantly in a state of flux. New policy is added and old policy is phased
    out. There is usually a lag time in the maintenance of the corresponding documentation,
    often with documentation in different locations being updated at different times,
    if ever.
  prefs: []
  type: TYPE_NORMAL
- en: '**A definitive authority must be established for each area of policy of interest.**
    This authority may be:'
  prefs: []
  type: TYPE_NORMAL
- en: '***   A statement of policy**'
  prefs: []
  type: TYPE_NORMAL
- en: '***   A subject matter expert**'
  prefs: []
  type: TYPE_NORMAL
- en: '***   A group of subject matter experts**'
  prefs: []
  type: TYPE_NORMAL
- en: The more complex, indefinite, and ambiguous the policy, the more important it
    is to have properly constituted authority designated to interpret, and if necessary,
    more rigorously define it. Someone must have the final word.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy logic in policy can be dealt with in decision tables as easily as in any
    other implementation. This is not to be confused with "fuzzy policy", which needs
    to be clarified by the appropriate authority before any implementation is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to Use a Decision Table Methodology in Software Development](img/b72dadeaefcdfaaf9620bfc1b35db16a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6 a note on fuzzy logic
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Partition Policy**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Policy should generally be partitioned in the interests of analytical efficiency.
    Different groups of analysts and subject matter experts can pursue work in different
    partitions in parallel. Bases for policy partitioning include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The separate actions identified in Step 1**This is the simplest basis for
    partitioning but may result in too many partitions to be efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The subject matter areas identified in Step 2** This is the most natural
    basis for policy partitioning. A subject matter expert group will naturally have
    jurisdiction over areas of policy related by their expertise. Partitioning in
    this way allows the analyst to work with one group on a larger section of related
    policy as a unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organizational divisions** Policy may be neatly divided along organizational
    lines or it may be completely orthogonal. If there is a strong correspondence
    between natural policy areas and organizational areas, it may be more efficient
    to partition policy based on these work areas. Interdepartmental political issues
    can thus be avoided and access to policy experts localized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to Use a Decision Table Methodology in Software Development](img/dfb1819781be7eaa189536cbaa630a2d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7 a simple partitioning of the policy scope of Figure 5
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4: Elicit Conditions Associated with Actions and Policy Logic**'
  prefs: []
  type: TYPE_NORMAL
- en: With a firm scope (list of actions to be implemented) and the authorities to
    definitively interpret policy, the next step is to elicit from these authorities
    the conditions which affect the actions and the logic used to determine the actions
    given the conditions.
  prefs: []
  type: TYPE_NORMAL
- en: What form does this specification take? Asking subject matter experts at this
    point in the process to produce completed decision tables for the actions in their
    jurisdictions would be placing unnecessary expectations of sophistication upon
    them. In addition, it is desirable to collate interim results from all policy
    areas to gain efficiencies over the entire project.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, we need to gather two things for each of our partitions from
    our subject area authorities:'
  prefs: []
  type: TYPE_NORMAL
- en: '***   A list of questions to ask to determine what action to take**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subject matter experts should be asked "What questions would you need answered
    in order to decide on a course of action?". The source of the answers is unimportant.
    The answers to these questions may come from users, internal tables, instruments,
    or even distant databases. We are really looking for the data on which actions
    depend. For each question (datum) elicited, we need the following metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '***   the type of answers that could be used to respond to the question**'
  prefs: []
  type: TYPE_NORMAL
- en: '***   the range of answers that could be used to respond to the question**'
  prefs: []
  type: TYPE_NORMAL
- en: '***   a default answer that will be used to populate the answer variable should
    an acceptable answer not be forthcoming**'
  prefs: []
  type: TYPE_NORMAL
- en: '***   any dependencies in the order of questions asked**'
  prefs: []
  type: TYPE_NORMAL
- en: The question format shows its value here. It makes it clear to the subject matter
    experts that actions are based on specific pieces of information and helps them
    to isolate these data.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to Use a Decision Table Methodology in Software Development](img/eef8390aa28d40d5815310fcc6fc85fa.png)'
  prefs: []
  type: TYPE_IMG
- en: '![How to Use a Decision Table Methodology in Software Development](img/4c2e2d37b9c55b55279ac902fecd85a7.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8** annotated question list for Partition A and Partition B from Figure
    7.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: subject matter experts have chosen default values to minimize the chances
    of serving free drinks should some information not be available!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: the default value for question B2 is dependent on the answer to question
    B1\. This implies an order dependency of questions. This dependency must be kept
    track of for future reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: policy authorities must sign off on these analyses before proceeding.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A description of the logic used to decide on the actions based on the input
    data (answers given to the questions)** The form of this logic is open. The best
    method of presentation is that which is at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: most comfortable to the subject matter expert,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: unambiguous, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: comprehensible to both the analyst and the subject matter expert.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The policy logic may be delivered in any form that meets these criteria, including
    those used in Figures 1, 2, 3, 4, or 9\. The analyst must show his skill and creativity
    here in communicating with the subject matter experts to elicit, organize, and
    present this logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The analyst must ensure that:'
  prefs: []
  type: TYPE_NORMAL
- en: all questions are assigned types, ranges, and default values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the answers to all questions are used in the process of arriving at an action,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: no action depends on answers to questions not present, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having gathered this information, the analyst must:'
  prefs: []
  type: TYPE_NORMAL
- en: organize it in a tabular format (See Figure 8),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fill in any remaining blanks,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: represent and explain its meaning to the subject matter experts, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: restate the associated policy logic to the subject matter experts for verification
    (See Figure 9).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These authorities then must either sign off this representation of the policy
    area as correct and authorized or make such changes as necessary to complete this
    signoff.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06a5febd16f85953694867b3c5db95f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9 Still another method of expressing policy logic
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5: Collate Question Lists across Partitions**'
  prefs: []
  type: TYPE_NORMAL
- en: Having analyzed the data from each policy area as partitioned, it is necessary
    to collate this data into a master set.
  prefs: []
  type: TYPE_NORMAL
- en: 'This consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Master Question Set** The Master Question Set is the union of all the separate
    question sets. All the separate question lists must be collated into one large
    list containing all the questions from all the smaller lists. Care must be taken
    with the intersections of these smaller sets. Guidelines for collation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes may be necessary to question wordings, types, ranges, or defaults to
    make them consistent across partitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some questions may have to be split or merged (see Figure 10).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two or more of these lists may contain synonymous questions i.e. questions that
    express the same thing, but use different terms, words, or expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beware also of homonyms i.e. questions on two or more lists that appear to be
    the same, but in fact represent different data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also necessary to amalgamate the question dependencies noted in Step 4
    to keep track of any necessary ordering in the datagathering during the actual
    decision evaluation process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, it is necessary to show for each question the partitions that originally
    used that question.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This allows:'
  prefs: []
  type: TYPE_NORMAL
- en: tracking of the effect of future question changes on policy partitions during
    maintenance,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: repartitioning of the policy area if desired, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: prioritization of the questions within the question set based on usage across
    policy areas should it become necessary to limit or restrict the question set
    for any reason. If this is an issue, a more sophisticated priority ranking system
    than just marking an 'X' may be used, e.g. 1 ' most important, 2 ' 2^(nd) most
    important, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to Use a Decision Table Methodology in Software Development](img/d2530fd0e271857364abe552cb9b7efd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10 merged Master Question Set for the question lists of Figure 8\. Individual
    questions are merged, question dependencies are added, and partitions where the
    questions are used are added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: the first and only question of Partition A has been determined to be
    identical to the first two questions of Partition B. The second expression has
    been chosen as more appropriate for use i.e. more granular, and inclusive of the
    first.'
  prefs: []
  type: TYPE_NORMAL
- en: It is of prime importance in this process to maintain the semantics and intent
    of the original questions as approved by the individual subject area authorities.
    If significant, dubious, or confusing changes have been made during the amalgamation,
    it is wise to reaffirm approvals from the subject matter authorities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question Dependency Chart** The analyst may find it desirable for purposes
    of visualization or presentation to summarize the amalgamated question dependency
    information from all the smaller question lists in a directed acyclic graph as
    shown in Figure 11\. Again, a question may depend on the answers to many other
    questions and many questions may depend on the answer to one question. There better
    not be any loops!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to Use a Decision Table Methodology in Software Development](img/11e479f0a9fa136400b05b35fe15846c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11 Question Dependency Chart for the Master Question Set of Figure 10
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 6: Create the Data Dictionary**'
  prefs: []
  type: TYPE_NORMAL
- en: Creation of a data dictionary of variables for use by the decision evaluation
    software is now a simple matter.
  prefs: []
  type: TYPE_NORMAL
- en: '***   Create a variable name to hold the data solicited by each question**Choose
    a term that is:*   indicative of the meaning of the data value held*   consistent
    with any coding standards preexistent in the policy area*   consistent with the
    coding standards of the decision table language***   Indicate a data source for
    each variable (question)**Use a code to indicate where this data will come from.
    It could be solicited from a user, from any of a variety of databases, or from
    another source.***   Order the questions according to the question dependencies**Ensure
    that questions that depend on the answers to other questions are asked after the
    questions they depend on. This information may even determine if the question
    is asked at all.'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to Use a Decision Table Methodology in Software Development](img/167df6e230427309fb78eaa13ac71a1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12 Data Dictionary for the Master Question Set of Figure 10.
  prefs: []
  type: TYPE_NORMAL
- en: Example data sources are split between user input and SQL database access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: An extra row (question) has been added to the Data Dictionary in order
    to reduce user input by allowing database access for the other pieces of data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adjust the question to match the data source** Given that the data may come
    from any of a variety of sources, the question itself now becomes a question presentation
    specification i.e. What is actually asked of the information source to elicit
    the answer data? Some examples:*   user text '' If the data is solicited from
    a user via text entry, the question presentation specification represents the
    text that will be presented to the user to solicit the answer data.*   It may
    be useful to add some explanatory text to the actual question to help the user
    fully understand the question. For example, instead of merely asking "How many
    seats are occupied on the flight?", it may be more desirable to explain further
    "How many seats are occupied on the flight? This only includes paying passengers,
    not complimentary, promotional, crew or jump seats."*   Also note that it is possible
    to have multiple specifications e.g. in a system designed for a multilingual environment,
    there would be a separate question presentation specification for each language
    in which the question would be asked.*   audio - If the data is solicited from
    a voice response system, the question presentation specification represents the
    audio file (or code necessary to play such a file) that will be played to the
    user to solicit the data. Here again, multiple specifications could be created
    to deal with a multilingual environment.*   database - If the data is solicited
    from a database, the question presentation specification represents the query
    (e.g. SQL) sent to the DBMS to solicit the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 7: Create the Decision Tables**'
  prefs: []
  type: TYPE_NORMAL
- en: The actual creation of executable decision tables is highly dependent on the
    software that reads, interprets, and executes them. To explain this process, it
    would be necessary to expound the syntax and semantics of that executing software.
    This of course, would vary with that software and is beyond the scope of this
    paper, which is limited to the requirements gathering and analysis phase of the
    overall process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion: A Quick, Easy, Rigorous, and Repeatable Methodology**'
  prefs: []
  type: TYPE_NORMAL
- en: Decision table theory has been available since the dawn of the computing era.
    It has features that take advantage of human styles of perception and cognition
    and yet maintain rigor and conciseness. Serious attempts to automate direct machine
    execution of these decision tables in a non-scientific environment have been limited
    by
  prefs: []
  type: TYPE_NORMAL
- en: paradigmatic emphasis being placed on other models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lack of widely available, inexpensive spreadsheet software with a large trained
    user base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lack of inexpensive and efficient decision table executing software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An analysis methodology has been presented which is structured and repeatable.
    Policy of interest is located, partitioned, clarified, and owned. All the information
    (data and logic) necessary to convert this data into an executable format is gathered,
    fleshed out, formatted, and approved.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, given reliable decision table execution software, the entry of
    this data into executable decision tables should be a straightforward task not
    requiring the intervention of a skilled programmer with the subsequent delays
    and errors inherent in that extra step.
  prefs: []
  type: TYPE_NORMAL
- en: '**References**'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] Simon, H.A. 1960\. *The new science of management decision.* New York:
    Harper & Row'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Holsapple, C.W. and Whinston, A.B. 1996\. *Decision support systems: a
    knowledge-based approach.* St. Paul, MN: West'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] Siler, William, Ph.D. [wsiler@aol.com]. "Building Fuzzy Expert Systems"
    [http://users.aol.com/wsiler/]'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view the complete list of archived articles](archive.php)'
  prefs: []
  type: TYPE_NORMAL
- en: '[This article was originally published in the Fall 2004 issue of Methods &
    Tools](../mt/download.php?fall04)**'
  prefs: []
  type: TYPE_NORMAL
