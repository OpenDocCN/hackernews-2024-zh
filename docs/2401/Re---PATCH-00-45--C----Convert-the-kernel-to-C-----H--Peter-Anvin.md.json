["```\nFrom: \"H. Peter Anvin\" <hpa@zytor.com>\nTo: David Howells <dhowells@redhat.com>,\n\tlinux-kernel@vger.kernel.org, pinskia@gmail.com\nSubject: Re: [PATCH 00/45] C++: Convert the kernel to C++\nDate: Tue, 9 Jan 2024 11:57:47 -0800\t[thread overview]\nMessage-ID: <3465e0c6-f5b2-4c42-95eb-29361481f805@zytor.com> (raw)\nIn-Reply-To: <152261521484.30503.16131389653845029164.stgit@warthog.procyon.org.uk>\n\nHi all, I'm going to stir the hornet's nest and make what has become the \nultimate sacrilege.\n\nAndrew Pinski recently made aware of this thread. I realize it was \nreleased on April 1, 2018, and either was a joke or might have been \ntaken as one. However, I think there is validity to it, and I'm going to \ntry to motivate my opinion here.\n\nBoth C and C++ has had a lot of development since 1999, and C++ has in \nfact, in my personal opinion, finally \"grown up\" to be a better C for \nthe kind of embedded programming that an OS kernel epitomizes. I'm \nsaying that as the author of a very large number of macro and inline \nassembly hacks in the kernel.\n\nWhat really makes me say that is that a lot of things we have recently \nasked for gcc-specific extensions are in fact relatively easy to \nimplement in standard C++ and, in many cases, allows for infrastructure \nimprovement *without* global code changes (see below.)\n\nC++14 is in my option the \"minimum\" version that has reasonable \nmetaprogramming support has most of it without the type hell of earlier \nversions (C++11 had most of it, but C++14 fills in some key missing pieces).\n\nHowever C++20 is really the main game changer in my opinion; although \nearlier versions could play a lot of SFINAE hacks they also gave \nabsolutely useless barf as error messages. C++20 adds concepts, which \nmakes it possible to actually get reasonable errors.\n\nWe do a lot of metaprogramming in the Linux kernel, implemented with \nsome often truly hideous macro hacks. These are also virtually \nimpossible to debug. Consider the uaccess.h type hacks, some of which I \ndesigned and wrote. In C++, the various casts and case statements can be \nunwound into separate template instances, and with some cleverness can \nalso strictly enforce things like user space vs kernel space pointers as \nwell as already-verified versus unverified user space pointers, not to \nmention easily handle the case of 32-bit user space types in a 64-bit \nkernel and make endianness conversion enforceable.\n\nNow, \"why not Rust\"? First of all, Rust uses a different (often, in my \nopinion, gratuitously so) syntax, and not only would all the kernel \ndevelopers need to become intimately familiar to the level of getting \nthe same kind of \"feel\" as we have for C, but converting C code to Rust \nisn't something that can be done piecemeal, whereas with some cleanups \nthe existing C code can be compiled as C++.\n\nHowever, I find that I disagree with some of David's conclusions; in \nfact I believe David is unnecessarily *pessimistic* at least given \nmodern C++.\n\nNote that no one in their sane mind would expect to use all the features \nof C++. Just like we have \"kernel C\" (currently a subset of C11 with a \nrelatively large set of allowed compiler-specific extensions) we would \nhave \"kernel C++\", which I would suggest to be a strictly defined subset \nof C++20 combined with a similar set of compiler extensions.) I realize \nC++20 compiler support is still very new for obvious reasons, so at \nleast some of this is forward looking.\n\nSo, notes on this specific subset based on David's comments.\n\nOn 4/1/18 13:40, David Howells wrote:\n> \n> Here are a series of patches to start converting the kernel to C++.  It\n> requires g++ v8.\n> \n> What rocks:\n> \n>   (1) Inline template functions, which makes implementation of things like\n>       cmpxchg() and get_user() much cleaner. \nMuch, much cleaner indeed. But it also allows for introducing things \nlike inline patching of immediates *without* having to change literally \nevery instance of a variable.\n\nI wrote, in fact, such a patchset. It probably included the most awful \nassembly hacks I have ever done, in order to implement the mechanics, \nbut what *really* made me give up on it was the fact that every site \nwhere a patchable variable is invoked would have to be changed from, say:\n\n\tfoo = bar + some_init_offset;\n\n... to ...\n\n\tfoo = imm_add(bar, some_init_offset);\n\n>   (2) Inline overloaded functions, which makes implementation of things like\n>       static_branch_likely() cleaner. \nBasically a subset of the above (it just means that for a specific set \nof very common cases it isn't necessary to go all the way to using \ntemplates, which makes the syntax nicer.)\n\n>   (3) Class inheritance.  For instance, all those inode wrappers that require\n>       the base inode struct to be included and that has to be accessed with\n>       something like:\n> \n> \tinode->vfs_inode.i_mtime\n> \n>       when you could instead do:\n> \n> \tinode->i_mtime \nThis is nice, but it is fundamentally syntactic sugar. Similar things \ncan be done with anonymous structures, *except* that C doesn't allow \nanother structure to be anonymously included; you have to have an \nentirely new \"struct\" statement defining all the fields. Welcome to \nmacro hell.\n\n> What I would disallow:\n> \n>   (1) new and delete.  There's no way to pass GFP_* flags in. \nYes, there is.\n\nvoid * operator new (size_t count, gfp_flags_t flags);\nvoid operator delete(void *ptr, ...whatever kfree/vfree/etc need, or a \nsuitable flag);\n\n>   (2) Constructors and destructors.  Nests of implicit code makes the code less\n>       obvious, and the replacement of static initialisation with constructor\n>       calls would make the code size larger. \nYes and no. It also makes it *way* easier to convert to and from using \ndedicated slabs; we already use semi-initialized slabs for some kinds of \nobjects, but it requires new code to make use of.\n\nWe already *do* use constructors and *especially* destructors for a lot \nof objects, we just call them out.\n\nNote that modern C++ also has the ability to construct and destruct \nobjects in-place, so allocation and construction/destruction aren't \nnecessarily related.\n\nThere is no reason you can't do static initialization where possible; \neven constructors can be evaluated at compile time if they are constexpr.\n\nConstructors (and destructors, for modules) in conjunction with gcc's \ninit_priority() extension is also a nice replacement for linker hack \ntables to invoke intializer functions.\n\n>   (3) Exceptions and RTTI.  RTTI would bulk the kernel up too much and\n>       exception handling is limited without it, and since destructors are not\n>       allowed, you still have to manually clean up after an error. \nAgreed here, especially since on many platforms exception handling \nrelies on DWARF unwind information.\n\n>   (4) Operator overloading (except in special cases). \nSee the example of inline patching above. But yes, overloading and \n*especially* operator overloading should be used only with care; this is \npretty much true across the board.\n\n>   (5) Function overloading (except in special inline cases). \nI think we might find non-inline cases where it matters, too.\n\n>   (6) STL (though some type trait bits are needed to replace __builtins that\n>       don't exist in g++). \nJust like there are parts of the C library which is really about the \ncompiler and not part of the library. <type_traits> is part of that for C++.\n\n>   (7) 'class', 'private', 'namespace'.\n> \n>   (8) 'virtual'.  Don't want virtual base classes, though virtual function\n>       tables might make operations tables more efficient. \nOperations tables *are* virtual classes. virtual base classes make sense \nin a lot of cases, and we de facto use them already.\n\nHowever, Linux also does conversion of polymorphic objects from one type \nto another -- that is for example how device nodes are implemented. \nUsing this with C++ polymorphism without RTTI does require some \ncompiler-specific hacks, unfortunately.\n\n> Issues:\n> \n>   (1) Need spaces inserting between strings and symbols. \nI have to admit I don't really grok this?\n\n>   (2) Direct assignment of pointers to/from void* isn't allowed by C++, though\n>       g++ grudgingly permits it with -fpermissive.  I would imagine that a\n>       compiler option could easily be added to hide the error entirely. \nSeriously. It should also enforce that it should be a trivial type. \nUnfortunately it doesn't look like there is a way to create user-defined \nimplicit conversions from one pointer to another (via a helper class), \nwhich otherwise would have had some other nice applications.\n\n>   (3) Need gcc v8+ to statically initialise an object of any struct that's not\n>       really simple (e.g. if it's got an embedded union). \nWorst case: constexpr constructor.\n\n>   (4) Symbol length.  Really need to extern \"C\" everything to reduce the size\n>       of the symbols stored in the kernel image.  This shouldn't be a problem\n>       if out-of-line function overloading isn't permitted. \nThis really would lose arguably the absolutely biggest advantage of C++: \ntype-safe linkage. This is the one reason why Linus actually tried to \nuse C++ in one single version of the kernel in the early days (0.99.14, \nif I remember correctly.) At that time, g++ was nowhere near mature \nenough, and it got dropped right away.\n\n> So far, it gets as far as compiling init/main.c to a .o file. \n;)\n\n```", "```\nnext prev parent reply  other threads:[~2024-01-09 19:58 UTC|newest]\n\nThread overview: 103+ messages / expand[flat|nested]  mbox.gz  Atom feed  top\n2018-04-01 20:40 [PATCH 00/45] C++: Convert the kernel to C++ David Howells\n2018-04-01 20:40 ` [PATCH 01/45] Use UINT_MAX, not -1, to represent an invalid UID, GID or project ID David Howells\n2018-04-01 23:04   ` Randy Dunlap\n2018-04-01 20:40 ` [PATCH 02/45] Fix exception_enter() return value David Howells\n2018-04-05  1:34   ` Sasha Levin\n2018-04-01 20:40 ` [PATCH 03/45] Fix loop var in be32_to_cpu_array() and cpu_to_be32_array() David Howells\n2018-04-01 20:40 ` [PATCH 04/45] Fix use of ACPI_COMPANION_SET() David Howells\n2018-04-01 20:40 ` [PATCH 05/45] C++: Set compilation as C++ for .c files David Howells\n2018-04-02  6:10   ` kbuild test robot\n2018-04-02  6:10   ` kbuild test robot\n2018-04-03 13:16   ` David Howells\n2018-04-03 13:27     ` Fengguang Wu\n2018-04-10  8:44     ` David Howells\n2018-04-10  9:45       ` Fengguang Wu\n2018-04-11  1:13         ` Li, Philip\n2018-04-01 20:40 ` [PATCH 06/45] C++: Do some basic C++ type definition David Howells\n2018-04-02  4:37   ` kbuild test robot\n2018-04-02  6:10   ` kbuild test robot\n2018-04-01 20:40 ` [PATCH 07/45] C++: Define a header with some C++ type traits for type checking David Howells\n2018-04-02  7:00   ` kbuild test robot\n2018-04-01 20:41 ` [PATCH 08/45] C++: Implement abs() as an inline template function David Howells\n2018-04-01 20:41 ` [PATCH 09/45] C++: x86: Fix the x86 syscall table production for C++ David Howells\n2018-04-02  7:57   ` kbuild test robot\n2018-04-01 20:41 ` [PATCH 10/45] C++: x86: Turn xchg(), xadd() & co. into inline template functions David Howells\n2018-04-01 20:41 ` [PATCH 11/45] C++: x86: Turn cmpxchg() \" David Howells\n2018-04-01 20:41 ` [PATCH 12/45] C++: x86: Turn cmpxchg_double() \" David Howells\n2018-04-01 20:41 ` [PATCH 13/45] C++: x86: Turn cmpxchg64() \" David Howells\n2018-04-01 20:41 ` [PATCH 14/45] C++: x86: Turn put_user(), get_user() \" David Howells\n2018-04-01 20:41 ` [PATCH 15/45] C++: Need space between string and symbol David Howells\n2018-04-01 20:41 ` [PATCH 16/45] C++: Disable VERIFY_OCTAL_PERMISSIONS() for the moment David Howells\n2018-04-01 20:41 ` [PATCH 17/45] C++: Turn READ_ONCE(), WRITE_ONCE() & co. into inline template functions David Howells\n2018-04-01 20:42 ` [PATCH 18/45] C++: Turn RCU accessors \" David Howells\n2018-04-01 20:42 ` [PATCH 19/45] C++: Turn ktime_add/sub_ns() \" David Howells\n2018-04-01 20:42 ` [PATCH 20/45] C++: init/main: Constify pointers David Howells\n2018-04-01 20:42 ` [PATCH 21/45] C++: Set the type of atomic64_t to s64 David Howells\n2018-04-01 20:42 ` [PATCH 22/45] C++: Define apic_intr_mode after the enum definition, not before David Howells\n2018-04-01 20:42 ` [PATCH 23/45] C++: Don't do \"extern asmlinkage\" David Howells\n2018-04-01 20:42 ` [PATCH 24/45] C++: Fix BUILD_BUG_ON_ZERO() David Howells\n2018-04-01 20:42 ` [PATCH 25/45] C++: Fix void variables David Howells\n2018-04-01 20:42 ` [PATCH 26/45] C++: Can't have variable/member names the same as typedef names David Howells\n2018-04-01 20:42 ` [PATCH 27/45] C++: Disable __same_type() for the moment David Howells\n2018-04-01 20:43 ` [PATCH 28/45] C++: Move ctx_state enum out of struct context_tracking David Howells\n2018-04-01 20:43 ` [PATCH 29/45] C++: Move the print_line_t enum before first use David Howells\n2018-04-01 20:43 ` [PATCH 30/45] C++: Include linux/hrtimer.h from linux/timer.h David Howells\n2018-04-01 20:43 ` [PATCH 31/45] C++: Avoid using 'compl' and 'and' as names David Howells\n2018-04-02  7:57   ` kbuild test robot\n2018-04-01 20:43 ` [PATCH 32/45] C++: __to_fd() needs to reduce the size of v for struct fd::flags David Howells\n2018-04-01 20:43 ` [PATCH 33/45] C++: Move irqchip_irq_state enum David Howells\n2018-04-01 20:43 ` [PATCH 34/45] C++: Fix up use of LIST_POISON* David Howells\n2018-04-01 20:43 ` [PATCH 35/45] C++: Fix static_branch_likely/unlikely() David Howells\n2018-04-01 20:43 ` [PATCH 36/45] C++: Fix kernfs_type() int->enum David Howells\n2018-04-01 20:43 ` [PATCH 37/45] C++: Fix page_zonenum() int->enum David Howells\n2018-04-01 20:44 ` [PATCH 38/45] C++: mutex_trylock_recursive_enum() int->enum David Howells\n2018-04-01 23:10   ` Randy Dunlap\n2018-04-01 20:44 ` [PATCH 39/45] C++: Fix spinlock initialisation David Howells\n2018-04-01 20:44 ` [PATCH 40/45] C++: Fix sema_init() David Howells\n2018-04-01 20:44 ` [PATCH 41/45] C++: Cast in bitops David Howells\n2018-04-02  6:10   ` kbuild test robot\n2018-04-01 20:44 ` [PATCH 42/45] C++: Hide C++ keywords David Howells\n2018-04-02  7:32   ` kbuild test robot\n2018-04-01 20:44 ` [PATCH 43/45] C++: Don't need to declare struct pgd_t after typedef David Howells\n2018-04-01 20:44 ` [PATCH 44/45] C++: Can't declare unsized-array in struct cgroup David Howells\n2018-04-01 20:44 ` [PATCH 45/45] C++: Move initcall_level_names[] to __initdata section David Howells\n2018-04-01 22:20 ` [PATCH 00/45] C++: Convert the kernel to C++ Randy Dunlap\n2018-04-02  9:28 ` Vegard Nossum\n2024-01-09 19:57 ` [H. Peter Anvin [this message]](#t)\n2024-01-09 23:29   ` Andrew Pinski\n2024-01-11 21:01     ` Arsen Arsenović\n2024-01-10  0:29   ` David Howells\n2024-01-10  8:58   ` Jiri Slaby\n2024-01-10 13:04     ` Neal Gompa\n2024-01-10 15:52       ` Jason Gunthorpe\n2024-01-10 16:05         ` H. Peter Anvin\n2024-01-10 16:25         ` Neal Gompa\n2024-01-10 17:57           ` Theodore Ts'o\n2024-01-12  2:23             ` H. Peter Anvin\n2024-01-12  2:52               ` Kent Overstreet\n2024-01-11  8:06       ` Andreas Herrmann\n2024-01-10 15:01   ` Michael de Lang\n     [not found]     ` <69fe1c0c-b5ec-4031-b719-d9c14742929c@metux.net>\n2024-01-12 21:58       ` Michael de Lang\n2024-01-11  4:24   ` John Hubbard\n2024-01-11  5:09     ` Dave Airlie\n2024-01-11 15:24       ` Eric Curtin\n2024-01-11 21:37       ` David Laight\n2024-01-11 12:39   ` Chris Down\n2024-01-11 19:40     ` David Laight\n2024-01-24  6:53       ` Jiri Slaby\n2024-01-12  2:54   ` H. Peter Anvin\n2024-01-12  8:52   ` David Howells\n2024-01-12 23:53     ` H. Peter Anvin\n2024-01-09 23:40 ` David Howells\n2024-01-10  7:13   ` Alexey Dobriyan\n2024-01-12  2:25   ` H. Peter Anvin\n2024-01-12  2:40   ` H. Peter Anvin\n2024-01-11 23:09 ` Arsen Arsenović\n2024-01-12  9:20 ` David Howells\n2024-01-12 21:35   ` Arsen Arsenović\n2024-01-12 23:41   ` David Howells\n2018-04-01 21:32 Alexey Dobriyan\n2024-01-11 10:56 Alexey Dobriyan\n2024-01-11 10:58 ` Neal Gompa\n2024-01-11 11:12   ` Alexey Dobriyan\n2024-01-11 12:12   ` Andreas Herrmann\n\n```", "```\nReply instructions:\n\nYou may reply publicly to this message via plain-text email\nusing any one of the following methods:\n\n* Save the following mbox file, import it into your mail client,\n  and reply-to-all from there: mbox\n\n  Avoid top-posting and favor interleaved quoting:\n  https://en.wikipedia.org/wiki/Posting_style#Interleaved_style\n\n* Reply using the --to, --cc, and --in-reply-to\n  switches of git-send-email(1):\n\n  git send-email \\\n    --in-reply-to=3465e0c6-f5b2-4c42-95eb-29361481f805@zytor.com \\\n    --to=hpa@zytor.com \\\n    --cc=dhowells@redhat.com \\\n    --cc=linux-kernel@vger.kernel.org \\\n    --cc=pinskia@gmail.com \\\n    /path/to/YOUR_REPLY\n\n  https://kernel.org/pub/software/scm/git/docs/git-send-email.html\n\n* If your mail client supports setting the In-Reply-To header\n  via mailto: links, try the mailto: link\n\n```", "```\nThis is a public inbox, see mirroring instructions\nfor how to clone and mirror all data and code used for this inbox;\nas well as URLs for NNTP newsgroup(s).\n```"]