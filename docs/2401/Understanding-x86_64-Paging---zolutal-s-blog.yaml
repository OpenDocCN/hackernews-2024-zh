- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:49:47'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Understanding x86_64 Paging - zolutal’s blog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://zolutal.github.io/understanding-paging/](https://zolutal.github.io/understanding-paging/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I’ve spent quite a lot of time messing with x86_64 page tables, understanding
    address translation is not easy and when I started learning about it I felt like
    a lot of the material out there on how it works was hard for me to wrap my head
    around. So in this blog post I am going to attempt to provide a kind of “what
    I wish I had when learning about paging”.
  prefs: []
  type: TYPE_NORMAL
- en: Quick note, I’ll only be discussing paging in the context of PML4 (Page Map
    Level 4) since it’s currently the dominant x86_64 paging scheme and probably will
    be for a while still.
  prefs: []
  type: TYPE_NORMAL
- en: environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its not necessary, but I recommend that you have a Linux kernel debugging setup
    with QEMU + gdb prepared to follow along with. If you’ve never done this, maybe
    give this repo a shot: [easylkb](https://github.com/deepseagirl/easylkb) (I’ve
    never used it, but I’ve heard good things) or if you want to avoid having to setup
    the environment yourself, the practice mode on any of the Kernel Security challenges
    on [pwn.college](https://pwn.college/) would also work (`vm connect` and `vm debug`
    are the commands to know).'
  prefs: []
  type: TYPE_NORMAL
- en: I suggest this because I think running the same commands I am on your own and
    being able to perform a page walk based on what you can see in gdb is a good test
    of understanding.
  prefs: []
  type: TYPE_NORMAL
- en: wtf is a page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On x86_64 a page is a 0x1000 byte slice of memory which is 0x1000 byte aligned.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why if you ever look at /proc/<pid>/maps you see that all
    the address ranges will start and end with an address ending with 0x000 because
    the minimum size of a memory mapping on x86_64 is page size (0x1000 bytes) and
    pages are required to be ‘page aligned’ (the last 12 bits must be zero).
  prefs: []
  type: TYPE_NORMAL
- en: A ‘Virtual Page’ will be resolved to a single ‘Physical Page’ (aka ‘Page Frame’)
    by your MMU though many Virtual Pages may refer to the same Physical Page.
  prefs: []
  type: TYPE_NORMAL
- en: what is in a virtual address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PML4, as one might guess, has four level of paging structures, these paging
    structures are called ‘Page Tables’. A page table is a page-sized memory region
    which contains 512 8-byte page table entries. Each entry of a page table will
    refer to either the next level page table or to the final physical address a virtual
    address resolves to.
  prefs: []
  type: TYPE_NORMAL
- en: The entry from a page table that is used for address translation is based on
    the virtual address of the memory access. With 512 entries per level, that means
    9-bits of the virtual address are used at every level to index into the corresponding
    page table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have an address like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0x7ffe1c9c9000`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last 12 bits of this address represent the offset within the physical page:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0x7ffe1c9c9000 & 0xfff = 0x0`'
  prefs: []
  type: TYPE_NORMAL
- en: This means that once we determine the physical address of the page this virtual
    address resolves to, we will add zero to the result to get the final physical
    address.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the last 12 bits, which is again just the offset within the final page,
    a virtual address is comprised of indicies into the page tables. As mentioned
    each level of paging uses 9 bits of the virtual address, so the lowest level of
    the paging structures, a Page Table, is indexed by the next 9 bits of the address
    (by bit masking with `& 0x1ff` on the shifted value). For the following levels
    we just need to shift right by another nine bits each time and again mask off
    the lower nine bits as our index. Doing this for the address above gives us these
    indicies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: all your base
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to index into page tables and vaguely what they contain,
    where actually are they???
  prefs: []
  type: TYPE_NORMAL
- en: Well each thread of your CPU has a page table base register called `cr3`.
  prefs: []
  type: TYPE_NORMAL
- en: '`cr3` holds the physical address of the highest level of the paging structure,
    aka the Page Global Directory (PGD).'
  prefs: []
  type: TYPE_NORMAL
- en: 'From gdb, when debugging the kernel, you can read the contents of `cr3` like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cr3` register can hold some additional information besides just the PGD
    address depending on what processor features are in use, so a more general way
    of getting the physical address of the PGD from the `cr3` register is to mask
    off the lower 12 bits of its contents like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: page table entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lets look at what is at that physical address we got from `cr3` in gdb. The
    `monitor xp/...` command that is exposed to gdb by the QEMU Monitor lets us print
    out the physical memory of the vm and doing `monitor xp/512gx ...` will print
    the entire contents, all 512 entries, of the PGD referred to by `cr3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This produces a lot of output and most of it is zero, so I’m only including
    the tail of the output here.
  prefs: []
  type: TYPE_NORMAL
- en: This output probably doesn’t mean much to you yet, but we can observe some patterns
    in the data, lots of the 8-byte entries end in `0x67`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: decoding a PGD entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the PGD output above, lets take the PGD entry at `0x000000010d664f50` with
    value `0x0000000123fca067` as an example to see how to decode an entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'and lets do this with the binary representation of that entry’s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a little diagram to show what each bit in the entry represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'and here’s a key for what each of those labels mean:'
  prefs: []
  type: TYPE_NORMAL
- en: NX (Not Executable) – if this bit is set, no memory mapping that is a descendant
    of this PGD entry will be executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved – these values must be zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PUD Physical Address – the physical address of the PUD associated with this
    PGD entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessed – If any pages referred to by this entry or its descendants, this bit
    will be set by the MMU, and can be cleared by the OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page Cache Disabled (PCD) – pages descendant of this PGD entry should not enter
    the CPU’s cache hierarchy, sometimes also called the ‘Uncacheable’ (UC) bit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page Write Through (WT) – writes to pages descendant of this PGD entry should
    immediately write to RAM rather than buffering writes to CPU cache before eventually
    updating RAM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User/Supervisor – if this bit is unset, pages descendant of this PGD cannot
    be accessed unless in supervisor mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read/Write – if this bit is unset, pages descendant of this PGD cannot be written
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Present – if this bit is unset then the processor will not use this entry for
    address translation and none of the other bits will apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The bits that we really care about here are the the Present bit, the ones representing
    the physical address of the next level of the paging structures, the PUD Physical
    Address bits, and the permission bits: NX, User/Supervisor, and Read/Write.'
  prefs: []
  type: TYPE_NORMAL
- en: The Present bit is super important because without it set the rest of the entry
    is ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PUD Physical Address lets us continue page walking by telling us where the
    physical address of the next level of the paging structures is at.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Permission bits all apply to pages which are descendants of the PGD entry
    and determine how those pages are able to be accesssed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The remaining bits are not as important for our purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: The Accessed bit is set if the entry was used in translating a memory access,
    its not important for page walking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page Cache Disabled and Page Write Through are not used for normal memory mappings
    and do not affect page translation or permissions so lets ignore them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So decoding this entry, we learn:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PUD is Present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The mappings in the PUD and below may be able to be Writable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The mappings in the PUD and below may be able to be User accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The PUD’s physical address ( bits (51:12] ) is `0x123fca000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The mappings in the PUD and below may be able to be Executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: decoding entries for all levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve seen how to decode a PGD entry, decoding the rest of the levels
    aren’t so much different, at least in the common case.
  prefs: []
  type: TYPE_NORMAL
- en: For all of these diagrams ‘X’ means the bit can be either zero or one, otherwise,
    if a bit is set to a specific value then that value is either required by the
    architecture or by the specific encoding shown by the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: PGD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This one we’ve already seen, I described it in detail in the previous section,
    but here it is without that specific PGD entry filled in.
  prefs: []
  type: TYPE_NORMAL
- en: PUD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the diagram above for the PUD is very similar to the one for
    the PGD, the only difference is the introduction of the ‘Page Size’ bit. The Page
    Size bit being set changes how we need to interpret a PUD entry quite a lot. For
    this diagram we are assuming it is unset, which is the most common case.
  prefs: []
  type: TYPE_NORMAL
- en: PMD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Again, the PMD diagram is very similar to the previous diagram, and like with
    the PUD entry, we are ignoring the Page Size bit for now.
  prefs: []
  type: TYPE_NORMAL
- en: PT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At the Page Table entry things get more interesting, there are some new fields/attributes
    that weren’t there in the previous levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those new fields/attributes are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory Protection Key (MPK or PK): This is an x86_64 extension that allows
    assigning a 4-bit keys to pages which can be used to configure memory permissions
    for all pages with that key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Global: This has to do with how the TLB (Translation Lookaside Buffer, the
    MMU’s cache for virtual to physical address translations) caches the translation
    for th page, this bit being set means the page will not be flushed from the TLB
    on context switch, this is commonly enabled on Kernel pages to reduce TLB misses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page Attribute Table (PAT): If set, the MMU should consult the Page Attribute
    Table MSR when determining whether the ‘Memory Type’ of the page, e.g. whether
    this page is ‘Uncacheable’, ‘Write Through’, or one of a few other memory types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dirty: This bit is similar to the accessed bit, it gets set by the MMU if this
    page was written to and must be reset by the OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these actually affect the address translation itself, but the configuration
    of the Memory Protection Key can mean that the expected memory access permissions
    for the page referred to by this entry may be stricter than what is encoded by
    the entry itself.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the previous levels, since this is the last level, the entry holds the
    final physical address of the page associated with the virtual address we are
    translating. Once you apply a bit-mask to get the physical address bytes and add
    the last 12 bits of the original virtual address (the offset within the page),
    you have your physical address!
  prefs: []
  type: TYPE_NORMAL
- en: 'Hopefully, this doesn’t seem so bad, the general case of page walking is just
    a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the virtual address to indicies and a page offset by shifting the address
    and applying bitmasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read `cr3` to get the physical address of the PGD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each level until the last:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the indicies calculated from the virtual address to know what entry from
    the page table to use
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply a bitmask to the entry to get the physical address of the next level
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On the final level, again find the entry corresponding with the index from the
    virtual address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply a bitmask to get the physical address of the page associated with the
    virtual address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add offset within the page from the virtual address to the page’s physical address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Done!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: hugeify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, the previous diagrams for the PUD and PMD are for the common case,
    when the Page Size bit is not set.
  prefs: []
  type: TYPE_NORMAL
- en: So, what about when it is set?
  prefs: []
  type: TYPE_NORMAL
- en: When it is set that is effectively telling the MMU, pack it up, we’re done here,
    don’t keep page walking, the current entry holds the physical address of the page
    we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is a bit more to it than that, the physical address of the page in
    entries where the Page Size bit is set isn’t for a normal 4KB (0x1000 byte) page,
    it is a ‘Huge Page’ which comes in two variants: 1GB Huge Pages and 2MB Huge Pages.'
  prefs: []
  type: TYPE_NORMAL
- en: When a PUD entry has the Page Size bit set then it refers to a 1GB Huge Page,
    and when a PMD has the Page Size bit set it refers to a 2MB Huge Page.
  prefs: []
  type: TYPE_NORMAL
- en: But where do the 1GB and 2MB numbers come from?
  prefs: []
  type: TYPE_NORMAL
- en: Each page table level holds up to 512 entries, that means a PT can refer to
    at most 512 pages and `512 * 4KB = 2MB`. So a Huge Page at the PMD level effectively
    means that the entry refers to a page that is the same size as a full PT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extending this to the PUD level, we just multiply by 512 again to get the size
    of a full PMD that has full PTs: `512 * 512 * 4KB = 1GB`.'
  prefs: []
  type: TYPE_NORMAL
- en: Huge Page PUD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When the page size bit is set notice that the PUD entry looks more like a PT
    entry than a normal PUD entry, which makes sense because it is also referring
    to a page rather than a page table.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some distinctions from a PT entry though:'
  prefs: []
  type: TYPE_NORMAL
- en: The Page Size bit is where the Page Attribute Table (PAT) bit is at on a PT,
    so the PAT bit is relocated to bit 12.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The physical address of a 1GB Huge Page is required to have 1GB alignment in
    physical memory, this is why the new reserved bits exist and why bit 12 is able
    to be repurposed as the PAT bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overall, not too much new here, the only other differences when dealing with
    huge pages really is that a different bitmask needs to be applied to the address
    to get the bits for the physical address of the page, also the 1GB alignment means
    when calculating the physical address of a virtual address within the page we
    need to use a mask based on 1GB alignment instead of 4KB alignment.
  prefs: []
  type: TYPE_NORMAL
- en: Huge Page PMD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to the PUD entry with the Page Size bit set, the only thing
    that has changed is that since the alignment is smaller for the 2MB pages at this
    level, there are less reserved bits set.
  prefs: []
  type: TYPE_NORMAL
- en: The 2MB alignment means the offset within the huge page should be calculated
    using a mask based on 2MB alignment.
  prefs: []
  type: TYPE_NORMAL
- en: going for a walk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So the last section was a lot of diagrams, in this section lets look at how
    to actually do a page walk manually in gdb.
  prefs: []
  type: TYPE_NORMAL
- en: preparation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With a booted up vm and gdb attached I first will pick an address to do a page
    walk on, as an example I’ll use the current stack pointer while running in the
    kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the address we are going to walk, lets also get the physical address
    of the PGD from `cr3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ll use this little python function to extract the page table offsets from
    the virtual address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'which outputs this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: PGD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The index we got for the PGD based on the virtual address was 511, multiplying
    511 by 8 will let us get the byte offset into the PGD that the PGD entry for our
    virtual address starts at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'adding that offset to the PGD’s physical address gets us the physical address
    of the PGD entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'and reading the physical memory at that address gets us the PGD entry itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Looks like the entry has the last three bits (present, user, and writeable)
    set, and the top bit (NX) is unset, meaning there aren’t any restrictions so far
    on the permissions of the pages associated with this virtual address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Masking the bits [12, 51) gives us the physical address of the PUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: PUD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The index we got for the PUD based on the virtual address was 510, multiplying
    510 by 8 will let us get the byte offset into the PUD that the PUD entry for our
    virtual address starts at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'adding that offset to the PUD’s physical address gets us the physical address
    of the PUD entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'and reading the physical memory at that address gets us the PUD entry itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: At this level we need to start paying attention to the Size Bit (bit 7), because
    if it is a 1GB page we would stop our page walk here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Seems it is unset on this entry so we will continue page walking.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that the PUD entry ends in 0x3 and not 0x7 like the previous level,
    the bottom two bits (present, writeable) are still set but the third bit, the
    user bit is now unset. That means that usermode accesses to pages belonging to
    this PUD entry will result in a page fault due to the failed permission check
    on the access.
  prefs: []
  type: TYPE_NORMAL
- en: The NX bit is still unset, so pages belonging to this PUD can still be executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Masking the bits [12, 51) gives us the physical address of the PMD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: PMD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The index we got for the PMD based on the virtual address was 70, multiplying
    70 by 8 will let us get the byte offset into the PMD that the PMD entry for our
    virtual address starts at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'adding that offset to the PMD’s physical address gets us the physical address
    of the PMD entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'and reading the physical memory at that address gets us the PMD entry itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Again, at this level we need paying attention to the Size Bit, because if it
    is a 2MB page we will stop our page walk here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Looks like our virtual address refers to a 2MB Huge Page! so the physical address
    in this PMD entry is the physical address of that Huge Page.
  prefs: []
  type: TYPE_NORMAL
- en: Also, looking at the permission bits, looks like the page is still present and
    writeable and the user bit is still unset, so this page is only accessible from
    supervisor mode (ring-0).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the previous levels, the top bit, the NX bit, is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So this Huge Page is not executable memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying a bitmask on bits [21:51) gets us the physical address of the huge
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to apply a mask to the virtual address based on 2MB page alignment
    to get the offset into the Huge Page.
  prefs: []
  type: TYPE_NORMAL
- en: '2MB is equivalent to `1<<21` so applying a bitmask of `(1ull<<21)-1` will get
    us the offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now adding this offset to the base address of the 2MB Huge Page will get us
    the physical address associated with the virtual address we started with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks like the Virtual Address: `0xffffffff88c07da8` has a Physical Address
    of: `0x8c07da8`!'
  prefs: []
  type: TYPE_NORMAL
- en: checking ourselves
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few ways to test that we page walked correctly, an easy check is
    to just dump the memory at the virtual and physical address and compare them,
    if they look the same we were probably right:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Physical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Virtual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Looks good to me!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to check is using the `monitor gva2gpa` (guest virtual address
    to guest physical address) command exposed to gdb by the QEMU Monitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Assuming QEMU is doing address translation correctly (probably a fair assumption),
    then looks like we have double confirmation that our page walk was successful!
  prefs: []
  type: TYPE_NORMAL
- en: wrapping up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully by the end of this you have a pretty solid understanding of how paging
    works on x86_64 systems. I wanted to pack a lot of information into the post so
    it took some thought to figure out how to organize all of it and I’m still not
    sure if this was a great way to go about it.
  prefs: []
  type: TYPE_NORMAL
- en: Anyways, I think paging is pretty neat and I think its one of those things where
    once you get it you’ve got it, but getting to that point can take some time and
    some screwing around in gdb.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’d also like to mention that the inspiration for the diagrams of the various
    page table entries I made for this post came from the documentation of the [blink](https://github.com/jart/blink/)
    project: [blink/machine.h](https://github.com/jart/blink/blob/46d82a0ced97c0df1fc645c5d81a88f0d142fbfd/blink/machine.h#L61).'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading!
  prefs: []
  type: TYPE_NORMAL
