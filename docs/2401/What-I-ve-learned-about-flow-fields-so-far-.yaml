- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:26:56'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What I've learned about flow fields so far.
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://damoonrashidi.me/articles/flow-field-methods](https://damoonrashidi.me/articles/flow-field-methods)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What I've learned about flow fields so far.
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: June 15, 2021, updated December 27, 2023.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: If you feel that this article is too wordy skip all the text and play with the
    illustrations, they get more and more fun as the articles rambles on!
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- Me
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Brief introduction.
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This article will describe the methods and concepts I used to create the series
    of generated artworks pictured below. I've tried to visualize the algorithms and
    provide some code samples. The code samples are written in a Typescript with some
    simplifications so that the code is readable on mobile and to make them more concise
    and easy to follow. The general algorithms can easily be ported to any language
    though, I have for instance done some [implementations using Rust](https://github.com/damoonrashidi/generative-art).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: As a note, far more talented people than me have written [articles on the subject](https://tylerxhobbs.com/essays/2020/flow-fields)
    upon which my work is very obviously based. I recommend reading that one too!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Noise functions
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main driving force behind these flow field images is usually a noise function.
    Without regurgitating the [wikipedia article](https://en.wikipedia.org/wiki/Perlin_noise),
    a noise function is a function that takes a coordinate in 2d space (higher dimension
    noise-functions also exist, but are irrelevant for the purpose of this article)
    and returns a value in the range `-1..=1` such as points close together return
    similar, but slightly different, values.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The interactive illustration below shows how this works by uniformly sampling
    points in a grid and calling the noise function for that point. Note that the
    values have been rounded to one decimal for legibility, the actual values have
    far more precision. Click `Regenerate` to run the noise function again with a
    new seed to get new noise values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: And here is the code that generated the image above, abbreviated for clarity.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To make it a bit easier to digest, we can visualize this in a more effective
    manner by translating the noise values into degrees and draw lines from a starting
    position and a few pixels following the degree of the noise value.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This doesn't look like much currently. It would appear that lines are fairly
    disjointed and go off in seemingly random directions. Not at all the smooth effect
    we're going for.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that noise functions are pretty sensitive. You'd think that the
    points`(1.0, 1.0)` and `(1.0, 2.0)` would produce somewhat similar noise values,
    following the rule that points in close proximity yield fairly similar noise values,
    but they're not close enough to each other.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: To combat this we can force our points to be closer together by just dividing
    our x and y coordinates by some smoothness constant. For example, the distance
    between our two example points was previously `1.0` for the y-axis, and `0.0`
    for the x-axis, for a total distance of `1.0`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对抗这一点，我们可以通过仅将我们的 x 和 y 坐标除以一些平滑度常数来使我们的点彼此更接近。例如，我们两个示例点之间的距离先前为 y 轴上的 `1.0`，x
    轴上的 `0.0`，总距离为 `1.0`。
- en: 'If we divide all our x and y values by the constant `smoothness = 100` we''d
    end up with: `p1 = (0.01, 0.01), p2 = (0.01, 0.02)`, making the distance only
    `0.01`, but keeping the relation between the points the same.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有的 x 和 y 值都除以常数 `smoothness = 100`，我们得到的结果是：`p1 = (0.01, 0.01), p2 = (0.01,
    0.02)`，使距离仅为 `0.01`，但保持点之间的关系不变。
- en: 'The only change we need to make to our code is the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中唯一需要做出的改变是以下内容：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can think of it as shrinking our domain to better fit the noise values.
    Or zooming in on the noise function if that helps.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其视为缩小我们的域以更好地适应噪声值。或者如果有助于理解，可以将其视为对噪声函数进行放大。
- en: As we can see by dragging the smoothness value up, closer to 100 in this case,
    the lines start to smooth out and patterns start to emerge.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通过提高平滑度值所看到的，靠近 100，在这种情况下，线条开始变得平滑，并且开始出现模式。
- en: Drawing lines.
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制线条。
- en: At this point we know how to navigate the flow field. Pick any point `P`, read
    the noise value `n` for that point and increment `P.x` by `cos(n)` and `P.y` by
    `sin(n)` as well as some extra pixels that represents the distance we want to
    travel in the direction of the field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何浏览流场。选择任意点 `P`，读取该点的噪声值 `n`，并将 `P.x` 增加 `cos(n)`，`P.y` 增加 `sin(n)`，以及表示我们想要在场的方向上行进的距离的一些额外像素。
- en: We did this in the previous examples by sampling points in a grid and and having
    a fixed line length. To approximate the effect illustrated in the images at the
    beginning of this article a bit better another implementation is necessary. First
    we need to pick a random point on the canvas and then ride the flow field until
    we get out of bounds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们通过在网格中采样点并设置固定的线长度来完成此操作。为了更好地近似本文开头图片中所示的效果，需要另一种实现方式。首先，我们需要在画布上选择一个随机点，然后沿着流场骑行直到超出边界。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Going from the above example to drawing an actual line should now be trivial.
    Start at any given point on the canvas an instantiate your line, move through
    the field just as before, but instead of drawing a new point at the given position
    add it to the points for the line. Stop the loop when the line has reached the
    end of the canvas and finally draw the line.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述示例转换到绘制实际线条现在应该很简单。从画布上的任意给定点开始并实例化您的线条，沿着场域进行移动，就像以前一样，但不是在给定位置绘制一个新点，而是将其添加到线条的点中。当线条到达画布的末端时停止循环，最后绘制线条。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Mouse over the illustration below to create new lines from your mouse position.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼠标悬停在下图上，可以根据鼠标位置创建新的行。
- en: Experimenting with lines.
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 试验线条。
- en: So far not a lot of variance has been achieved. All results, no matter what
    the seed of the noise function is, will yield somewhat similar images. There are
    a few ways to combat this, one way is by warping the noise value a bit, resulting
    in lines exaggerating their turns, this is done by simply multiplying the noise
    value by some constant before applying the `cos()` and `sin()` functions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，并没有实现很大的变化。无论噪声函数的种子是什么，所有结果都会产生相似的图片。有几种方法可以解决这个问题，一种方法是稍微扭曲噪声值，导致线条夸大其转向，这只需在应用
    `cos()` 和 `sin()` 函数之前简单地将噪声值乘以一些常数即可实现。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Another way is by varying the length of the steps each line takes between each
    step as it progresses through the field. Shorter steps yield much smoother curves
    while longer steps will make the lines a lot more jagged.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在线条在场中前进时调整每步线条的步长长度。较短的步长将产生更加平滑的曲线，而较长的步长将使线条更加锯齿状。
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Alternatives to noise functions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代噪声函数
- en: So far we've been using a noise function called OpenSimplex.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用一个叫做 OpenSimplex 的噪声函数。
- en: OpenSimplex noise is an n-dimensional gradient noise function that was developed
    in order to overcome the patent-related issues surrounding Simplex noise, while
    continuing to also avoid the visually-significant directional artifacts characteristic
    of Perlin noise.
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OpenSimplex 噪声是一个 n 维梯度噪声函数，旨在克服 Simplex 噪声相关的专利问题，同时也避免了 Perlin 噪声的视觉上显著的方向性伪影。
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Kurt Spencer'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- Kurt Spencer'
- en: As alluded to in the quote, there are few different noise functions. A proper
    noise function is a bit complicated and out of scope for this article, but nothing
    is stopping us from writing a function that returns similar values for a given
    coordinate, that part can be done pretty easily.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: These home grown functions won't yield as random seeming results as a noise
    function but they will let us control the final output much more. They will also
    let us be much more creative in trying new things out now that we can draw lines
    that reliably follow a path.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: An easy first test we can do is simply taking a coordinate and return it's distance
    to another point that we'll call the `focalPoint`, just to see what would happen.
    This function would satisfy the rule that points close together yield similar
    values, making our lines nice and smooth.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Mouse over the illustration below to set a new focal point
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: If we instead of returning the distance to `focalPoint` we can return the angle
    the line has from our point to and offset our point along the radius (with a slight
    distortion to the y-axis) we can get a nice swirl-like effect.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Collision Detection
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In my opinion, the real fun doesn't really begin until we start looking at having
    the lines interact with each other. Instead of stopping when we reach the end
    of the canvas or we've reached the max line length we can instead stop when this
    line would collide with another line.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Hover the illustration (or slide your finger over it) to add lines of varying
    width.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Now, a lot can be said about collision detection and how to make it performant.
    I'll show only one method and a small optimization to keep the solution somewhat
    performant.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Checking the [intersection of two straight lines](https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection)
    isn't too bad and can be done in O(1) time. Our lines aren't straight however
    so we'll have to be a bit more clever. If we go back to the beginning of how we
    drew the line, it started with stepping through the noise field and adding a point
    for each step. If we made that point into a circle by giving it same radius as
    the line and kept track of each circle, not just in the line but in all lines
    it's a lot easier to check if the circle we are about to draw overlaps any other
    circle.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Checking if two circles overlap is only a matter of checking if the sum of their
    radii is smaller than the distance between their origo.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here is another illustration that highlights when two non-linear lines meet
    using this method. Play with the illustration to move the colliding line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: <canvas class="h-[500px] w-full touch-none"></canvas>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Optimizing it slightly.
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These example illustrations are fairly small so we haven't ran into any performance
    issues when checking if our line collides with any other line... yet. When trying
    to make a larger image however, in a print-friendly size for instance, we'd end
    up with a lot of lines with a lot of points that we could potentially collide
    with, meaning that for every new point we add we must check collisions against
    all other points. This stacks up fast and will make your render times a lot longer
    than desired. A way to mitigate this is to only check against points that are
    close enough for us to collide with.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way of doing that is by dividing our canvas up into a grid of boxes
    and whenever we are about to add a new point check which box it would go in, and
    then only check against collisions with points in that box.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Time for another illustration. This time, move your finger or mouse cursor around
    to see which points belong to the same box.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Now, with 100 boxes (10 across, 10 down) and if the points are distributed uniformly
    on the canvas, we end up doing 1/100^(th) as many checks that we did previously,
    increasing rendering performance by quite a bit! One thing to note however, is
    that if our boxes would be too small to reliably hold points with the radius of
    our lines then we'd start to get overlapping lines at the edges. This would also
    happen if a points origo was at the very edge of a box, causing its body to spill
    outside the boxes area. We could fix that by checking surrounding boxes for collisions
    as well, but that would mean we'd check another eight boxes besides the current
    one, increasing the search space a bit, but the result would be more exact.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: A final optimisation we can do with this technique is that if our step size
    (the distance between each point in each line) is sufficiently small we could
    skip checking a few points in the box, since if our circle overlaps with one of
    the circles there's a high chance that it overlaps with some other circles as
    well. Now this might yield a less accurate result, but accuracy is not necessarly
    the end goal. Some small overlaps for a few lines might introduce some visually
    pleasing artifacts. Usually those kinds of details are *happy little accidents*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we check against every 7^(th) circle in a box hoping to get a hit if there
    is one. The constant `7` might be too high in some cases, or could be increased
    even more, it all depends on the step size for the lines and can be tweaked to
    get a good balance between render times and correctness.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Colors.
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The theme for this article is converging to *"you can achieve a lot of variation
    with some tweaks"*. That's true for applying colors to these images as well. So
    far things in this article have been pretty monochrome to focus on the underlying
    techniques of how to achieve the overarching look.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to get some color in there is to create a palette with a few
    different colors and picking at random when creating a new line.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Another coloring method is by coloring each line by the angle of the noise function
    where the line started. This will yield a gradient like coloring across larger
    images.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种着色方法是通过根据线条起始点的噪声函数角度来对每条线条着色。这将在较大的图像上产生类似渐变的着色效果。
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, my favorite method is by subdividing the canvas into a set of regions,
    either by some [Piet Mondrian Composition style](https://en.wikipedia.org/wiki/Composition_with_Red_Blue_and_Yellow),
    or recursively splitting the canvas into more and more refined polygons. After
    the canvas has been divided I assign each region a color and whenever a line spawns
    assign it the color of the region it spawned in.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我最喜欢的方法是将画布细分为一组区域，可以采用一些[Piet Mondrian Composition style](https://en.wikipedia.org/wiki/Composition_with_Red_Blue_and_Yellow)的方式，或者通过递归地将画布分割成越来越精细的多边形。画布被划分后，我会为每个区域分配一种颜色，并在线条产生时为其分配该区域的颜色。
- en: This method creates a nice effect where things don't look as disjointed and
    more like streams of paint flowing into other buckets of paint.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法产生了一个很好的效果，使得事物看起来不那么不连贯，更像是油漆流入其他油漆桶的流动。
- en: Conclusion
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Even though this article got quite long, it only scratches the surface of all
    the variants that can be achieved using the fundamental techniques described.
    I highly recommend trying things out and experimenting, swapping a `cos()` for
    a `sin()` somewhere, or maybe even a `tan()` if you're crazy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这篇文章已经相当长了，但它只是描述了使用基本技术所能实现的各种变体的冰山一角。我强烈建议尝试各种方法和实验，尝试在某处用`cos()`换成`sin()`，或者如果你很疯狂的话，甚至用`tan()`。
- en: Try subdividing the canvas into subregions who all have their own rules, or
    maybe dive deeper into noise functions. Or have a small border around the canvas
    and let some small percent of the lines escape it. Why use lines at all? Why not
    circles or squares or blobs?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将画布细分为各自具有自己规则的子区域，或者更深入地研究噪声函数。或者在画布周围留有小边框，让一些线条的一小部分逃离。为什么要使用线条？为什么不使用圆形、正方形或斑点？
- en: Thanks for sticking in there this long, hope it was helpful.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢你一直坚持到这里，希望这篇文章有所帮助。
