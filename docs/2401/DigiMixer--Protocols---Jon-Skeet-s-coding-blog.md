<!--yml

类别：未分类

日期：2024-05-27 14:29:16

-->

# [DigiMixer: 协议 | Jon Skeet 的编码博客](https://codeblog.jonskeet.uk/2024/01/02/digimixer-protocols/)

> 来源：[`codeblog.jonskeet.uk/2024/01/02/digimixer-protocols/`](https://codeblog.jonskeet.uk/2024/01/02/digimixer-protocols/)

尽管这个博客系列进展*非常*缓慢，但 DigiMixer 项目本身确实没有停滞不前。在过去的一年里，我增加了对各种额外混音器的支持，以及改善了一些早期混音器的支持，并进行了相当多的重构。

DigiMixer 现在支持以下混音器，程度不同：

+   Behringer X 系列（已测试 XR16、XR18、X-32R）和 Midas M 系列（仅测试了 M32R，但我预期它与 X 系列相同）

+   Harman Soundcraft Ui 系列（已测试 Ui24R）

+   Allen & Heath Qu 系列（已测试 Qu-SB，包括 AR84 舞台箱）

+   Allen & Heath CQ 系列（已测试 CQ-20B）

+   RCF M-18

+   Mackie DL 系列（已测试 DL16S 和 DL32R，结果显著不同）

+   Yamaha DM 系列（已测试 DM-3）

+   PreSonus StudioLive Series III（已测试 16R）

为了支持每个混音器，我们必须能够与其通信。以上混音器使用的唯一一种“标准化”协议是 OSC（Open Sound Control）- 这仍然只是标准化 OSC 消息的外观，而不是各种地址和值的含义。一些混音器在某种程度上支持 MIDI，有时甚至有关于该支持如何工作的文档。（再次强调，并没有一个标准规定混音器中 MIDI 集成“应该”如何实现- 这不像实际乐器上的 MIDI，您可以合理地期望给定的 MIDI 消息意味着“演奏中音 C”。）在 DAW 中的整合方面是有用的，但迄今为止我见过的混音器没有一个能够通过 MIDI 提供足够的控制来满足 DigiMixer 的需求。

本文将稍微详细地介绍迄今为止遇到的协议，DigiMixer 实际*需要*什么，以及我如何逆向工程协议的一些实际方面。

我希望开始在 GitHub 存储库中的[Protocols 目录](https://github.com/jskeet/DemoCode/tree/main/DigiMixer/Protocols)编写关于每个协议的更详细的文档。目前有关 Mackie DL 系列的一些信息，我会在有时间时添加更多内容。值得注意的是，我在该目录中使用的任何术语可能完全是非官方的- 当我谈论“消息块大小”或“子类型”等时，那只是我在代码中出于缺乏更好术语的使用。

## 非常高级别的分类

让我们从协议的最高级别分类开始：DigiMixer 支持的所有内容都使用网络进行通信，并且都通过 IP 进行。可能会有一些数字混音器，其中客户端/混音器连接是通过 USB 进行的，正如我之前提到的，也可以通过某种程度的 MIDI 控制一些混音器（可以通过 USB-MIDI 连接，专用 MIDI 硬件，甚至 MIDI over IP） - 但我还没有调查过不基于网络的混音器协议。

很重要的一点是要清楚“客户端/混音器”协议与任何“客户端/控制面板”协议之间的区别。在与 DigiMixer 相同的代码库中，我有一些与[Icon Platform](https://github.com/jskeet/DemoCode/tree/main/IconPlatform)和[X-Touch Mini](https://github.com/jskeet/DemoCode/tree/main/XTouchMini)控制面板集成的库 - 这两者都通过一个应用程序（目前*不*在公共 GitHub 上，因为它与 At Your Service 共享配置）与 DigiMixer 集成。DigiMixer 的抽象之一目的是允许混音器被广泛地视为可互换的 - 因此，使用 X-Touch Mini 控制（比如）CQ-20B 的相同基于 DigiMixer 的代码 *应该* 能够在不更改任何内容的情况下控制 X32。本文完全忽略了控制面板方面的内容，只关注我们*想要*通过 DigiMixer 实现的客户端/混音器协议方面的内容。

协议最明显的初始分类是根据传输（OSI 第 4 层）协议来进行的：在我们的情况下，始终是 UDP 或 TCP，或者两者混合使用。

一种相当常见的模式（由 CQ、DM、Qu、StudioLive 混音器使用）是使用 TCP 连接来控制方面，但通过 UDP 报告计量级别。计量器显示特定输入或输出的时点音量；通常偶尔丢失一个计量器数据包并不重要 - 因此使用 UDP 是有道理的。如果“静音此通道”消息被丢失，那么 TCP 的可靠性就显得更加重要了。

RCF M-18 和 Behringer/Midas 混音器的 X/M 系列使用 UDP 上的 OSC 协议。（DM-3 也支持 UDP 上的 OSC 协议，但不提供足够的功能来满足 DigiMixer 的要求。）UDP 的不可靠性在这里令人担忧；可以推测的是您只在足够可靠的网络上操作它们，以至于这不会成为问题，或者客户端周期性地向混音器请求“当前状态”，并检查其与自己期望的状态是否一致。我的经验是，在仅有一个交换机连接混音器和客户端的有线网络上（这将是常见的部署场景），它从未*真正*导致问题。

就我所见（或者至少就 DigiMixer 而言），DL 和 Ui 系列**只**使用 TCP。这里 Ui 系列特别有趣；它的制造商提供的用户界面只是一个 Web 用户界面。混音器内置的 Web 服务器提供用户界面本身，该用户界面连接回混音器仍然在端口 80 上创建一个 Web 套接字连接。我对 Web 套接字标准了解不够，不知道实现有多“正常”，但是编码起来非常简单：发出“GET /raw HTTP1.1”的请求，读取响应头，然后它只是一个基于行的协议。该协议中的每条消息（在两个方向上）都是一条文本 ASCII 行。稍后我会回到消息格式。

## 信息来源

致力于 DigiMixer 的工作是一项迷人的工作，需要从多个来源收集信息。通常情况下，只要我拥有足够的协议信息，每个协议的*实现*就相对简单，但是这些信息很难得到。

在某些情况下，制造商自己提供了信息，无论是官方还是非官方的。例如，对于 Ui 系列，Harman 支持对我的查询做出了非常快速的响应，向我发送了文档，尽管不是完全全面的，但足以开始使用。 （他们强调，这些文档绝不是未来兼容性或支持的保证。）

在其他情况下，有一个活跃的社区，他们非常努力，包括官方和非官方文档的混合。 Behringer X 系列和 Midas M 系列（据我所知，在软件方面基本相同）有很多活跃的项目，可以通过 OSC 访问它们，并且最全面的文档来自 [Patrick-Gilles Maillot 的网站](https://sites.google.com/site/patrickmaillot/x32)。

对于 StudioLive 混音器，有一个 [GitHub 项目](https://github.com/featherbear/presonus-studiolive-api) 和 [文档](https://featherbear.cc/presonus-studiolive-api/#documentation)，严格来说是非官方的，至少在某种程度上还不完整 - 但是非常宝贵。 RCF M-18 的情况类似，这里有一个 [单一的不活跃的 GitHub 存储库](https://github.com/Jille/rcf-m18) 基本上就是我找到的。

对于其他混音器... 有 [Wireshark](https://www.wireshark.org/)。 我查看过的所有数字混音器都有制造商提供的客户端。 当这些客户端在 Windows 上运行时，只需启动 Wireshark，打开客户端（比如移动一个滑杆），然后关闭客户端并查看混音器和客户端之间的通信即可。 如果提供的唯一客户端是 Android 或 iOS 应用程序，则稍微麻烦一些，但我发现 [TP-Link TL-SG105E](https://www.tp-link.com/uk/business-networking/easy-smart-switch/tl-sg105e/) 非常方便 - 它是一款小巧、无噪音的托管交换机，支持端口镜像。 因此，我所需做的就是将我的笔记本电脑和混音器都插入交换机，将混音器端口的流量镜像到笔记本电脑端口，并再次运行 Wireshark。

[Mixing Station](https://mixingstation.app/) 也支持所有这些混音器，并且有时查看混音器和制造商提供的客户端之间的通信，并将其与混音器和制造商提供的客户端之间的通信进行比较是很有用的。

当然，通常捕获混音器和客户端之间的通信并不完全解释这种通信。我们并不需要完全理解所有的通信 - 只需了解足够多以使 DigiMixer 生效即可。那包括什么呢？

## DigiMixer 对协议理解的要求

正如我之前所说，DigiMixer 并不试图成为一个完全忠实的混音器客户端。它的目标仅仅是提供静音和取消静音的控制，并移动滑杆（无论是“总输出”还是“输入/输出组合”，比如“辅助 1 水平”或“输入 2 水平到辅助 3”）。此外，它还试图提供关于通道名称、一般混音器信息、将通道链接在一起形成立体声对的任何通道以及计量信息的信息。

在协议方面，这通常意味着我们需要理解：

+   初始连接要求，包括任何“客户端握手”。 （对于混音器 TCP + UDP 协议，这个握手在 TCP 上有时涉及双方告诉对方他们正在监听的 UDP 端口。）

+   如何获取混音器信息（型号、版本、用户指定的混音器名称）

+   如何获取混音器的初始状态（通道名称、任何立体声链接以及当前滑块/静音状态）

+   如何发送“静音/取消静音此通道”和“移动此滑块”的命令

+   如果由*另一个*客户端更改状态，混音器向客户端发送什么

+   混音器向客户端发送报告表计电平的内容（可能包括客户端首次请求这些内容的方式）

有些协议使这些要求变得非常容易实现，而其他协议则更具挑战性。

## 协议的层次和步骤，在反向工程协议时

我从未完全理解过[OSI 模型](https://en.wikipedia.org/wiki/OSI_model)，无法清楚地将协议的任何特定位放入七个层中的任何一个。但是，分层的*概念*在 DigiMixer 中非常有用。大多数混音器的实现都是作为两个项目实现的，一个带有“core”后缀，一个不带，例如 `DigiMixer.Mackie.Core` 和 `DigiMixer.Mackie`。每种情况下的“核心”项目都集中在我认为会是 OSI 中表示层（和*有时*会话层）的内容；我把它想象成*消息帧格式*然后*消息解构*。（我相信我在这里使用消息帧格式是完全标准的。消息解构可能有一个更好的名称。）

DigiMixer 使用的所有协议都有消息的概念：

+   TCP 连接形成双向消息流。

+   每个 UDP 连接形成单向消息流

（在某些协议中，混音器也使用 UDP 连接进行双向通信 – 基本上向发送数据包到其的任何 UDP 端口发送数据包。在其他协议中，这两个 UDP 流完全独立。）

### 消息帧格式

在我在 DigiMixer 上的工作中看到实现的 UDP 协议中，每个 UDP 数据包恰好对应一个消息。从来没有 UDP 数据包包含多个消息，消息也不需要跨多个数据包拆分。

不过，对于 TCP，情况就不同了。Wireshark 允许您跟踪 TCP 流，显示每个方向的数据流，但需要一些工作来弄清楚如何将每个流分割成消息。

以下是我在 Windows 上打开 DM-3 MixPad 应用程序时在 Wireshark 中看到的部分流量。

```
00000000  4d 50 52 4f 00 00 00 1d  11 00 00 00 18 01 01 01   MPRO.... ........
00000010  02 31 00 00 00 09 50 72  6f 70 65 72 74 79 00 11   .1....Pr operty..
00000020  00 00 00 01 80                                     .....
00000025  4d 50 52 4f 00 00 00 47  11 00 00 00 42 01 10 01   MPRO...G ....B...
00000035  04 11 00 00 00 01 00 31  00 00 00 09 50 72 6f 70   .......1 ....Prop
00000045  65 72 74 79 00 11 00 00  00 10 3a 7c 8d 4c 85 f8   erty.... ..:|.L..
00000055  9f 1e aa 83 4f 96 63 0c  ec 3d 11 00 00 00 10 8b   ....O.c. .=......
00000065  76 f3 98 78 64 6e 83 15  f5 81 7c 06 cc b6 91 4d   v..xdn.. ..|....M
00000075  50 52 4f 00 00 00 09 11  00 00 00 04 01 04 01 00   PRO..... ........
    00000000  4d 50 52 4f 00 00 00 47  11 00 00 00 42 01 10 01   MPRO...G ....B...
    00000010  04 11 00 00 00 01 00 31  00 00 00 09 50 72 6f 70   .......1 ....Prop
    00000020  65 72 74 79 00 11 00 00  00 10 3a 7c 8d 4c 85 f8   erty.... ..:|.L..
    00000030  9f 1e aa 83 4f 96 63 0c  ec 3d 11 00 00 00 10 87   ....O.c. .=......
    00000040  49 a1 3e 61 58 ea ce dc  00 0a cb 7d a1 dd cb      I.>aX... ...}...
    0000004F  4d 50 52 4f 00 00 00 09  11 00 00 00 04 01 04 01   MPRO.... ........
    0000005F  00 4d 50 52 4f 00 00 08  c3 11 00 00 08 be 01 14   .MPRO... ........

```

我*怀疑*第三行后面的换行（在出站字节 00000024 和 00000025 之间）是由于一个数据包边界，但也有可能 Wireshark 做了更多的事情，比如只有在它们之间的间隔（按时间计算）超过某个阈值时才显示包之间的换行。我通常忽略了这一点，而“对话”中的短消息往往能够清楚地显示消息边界。

在这种情况下，重复出现的“MPRO”文本至少乍一看似乎指示了消息的开始。然后，该“MPRO”之后的四个字节似乎显示了（按大端序顺序）消息剩余部分的长度。

换句话说，在查看了类似上面的一定量数据后，我能够猜测 DM3 协议的消息帧格式为：

+   4 字节：消息类型（例如“MPRO”、“EEVT”、“MMIX”）

+   4 字节：消息体长度，大端序

+   消息体

像这样的消息帧假设相对容易测试，特别是在编写一些代码来解析类似上面的 Wireshark 十六进制转储的文本格式之后。（我的经验是，文本格式通常比 Wireshark 默认处理的完整 pcapng 文件更容易处理。跟随 TCP 流并将其保存为文本所需的手工工作量相当小。）

我使用过的大多数协议都具有某种“消息头、消息体”格式，其中标头包含有关主体长度的信息。但也有一些区别：

+   有时会有一些额外的状态（例如，“消息计数器字节”）

+   有时消息标头除了帧之外没有任何信息，不像上面的示例，您仍然需要将“MPRO”部分保留为“消息类型” - 尽管我们还不知道“类型”真正意味着什么

+   有时会有一个尾部（例如，一个校验和）

+   有时标头中的长度信息是*消息*长度而不是*主体*长度（即长度可以包括或不包括标头本身，这取决于协议）

在 Ui 系列的情况下，帧仅基于换行符。这两种方案 - “消息定界符”（换行符）或“具有长度信息的标头” - 是我在 DigiMixer 中看到的消息帧的主要方法，也是我职业生涯中看到的。 （不清楚您是否会包括“每个 UDP 数据包一个消息”或“每个消息后关闭 TCP 连接”消息帧方案，或者只是意味着您根本不需要消息帧的方法。）有些协议混合了这两种方法：HTTP/1.1 使用定界符用于标头，然后在其中一个标头中指定内容长度，以允许在同一连接上发送进一步的请求或响应。

一旦我在一个快速而粗糙的代码中验证了消息帧假设（通常是在另一个带有工具后缀的项目中，例如`DigiMixer.Mackie.Tools`），我将把该帧添加到“核心”项目中，形成一个实现`IMixerMessage`的消息类型：

```
public interface IMixerMessage<TSelf> where TSelf : class, IMixerMessage<TSelf>
{
    static abstract TSelf? TryParse(ReadOnlySpan<byte> data);
    int Length { get; }
    void CopyTo(Span<byte> buffer);
}

```

将这个接口添加到 DigiMixer 中是一个相对较新的功能，因为我在等待 .NET 8 的发布。它的前身是“消息处理器”的概念，有效地将一系列字节转换为适合消费的消息流，但在接口与其具有乐趣的静态抽象`TryParse`方法之前，我必须分别指定消息的各个方面。现在，在消息接口、消息处理器和一些基类之间，我几乎没有任何直接处理`TcpClient`和`UdpClient`的代码。太棒了。（现在有多个派生类几乎没有任何行为，我可能会在某个时候重构它们，但至少逻辑不会重复。）

### 消息分解

确认我已经理解了协议的消息框架是极其令人满足的，也是必要的第一步 - 但它通常也是最简单的步骤。通常可以理解消息框架而不理解整个消息头，就像在上面的例子中，我们不知道不同的消息类型的含义，甚至不知道有多少消息类型。更重要的是，即使我们完全理解了框架，这也并不告诉我们这些消息的含义。它们只是数据块。

消息分解 *稍微* 进一步，根据其组成部分将消息主体拆开 - 可能 *仍然* 不理解任何值的实际含义。

以前面显示的 DM-3 为例，事实证明，我见过的每个消息主体都由以下部分组成：

+   字节 0x11

+   4 字节，再次是表示长度的大端整数

+   以字节为单位的长度，作为“真正”的主体

这只是一个额外的（我认为是多余的）包装层，但在“真正”的主体内部，我们有一组 4 字节的标志（它们确实有一些模式，但我还没有完全弄清楚），然后是一系列有用的数据片段。每个片段包括：

+   一个类型字节（据我所见，始终是 0x11、0x12、0x14、0x24 或 0x31）；关于这一点后面会详细说明

+   被表示的“单位”数量

+   单位本身

类型字节由两个字半字节组成 - 第一个是单位的“类型”（1 表示无符号整数，包括字节；2 表示有符号整数；3 表示字符），然后是“每个单位的字节数”。所以 0x11 只是一系列字节，0x12 是“一系列 `UInt16` 值”，0x14 是“一系列 `UInt32` 值”，0x24 是“一系列 `Int32` 值”，而 0x31 基本上是“一个字符串”（尽管也有一个长度，但是以空字符结尾，不过没关系）。

每个片段依次出现，直到“真正”主体的结束。

之前显示的 DM-3 的十六进制片段（包括被截断的大消息），我们可以将这些消息分解为：

```
=> MPRO: Flags=01010102; Segments=2
  Text: 'Property'
  Binary[1]: 80

=> MPRO: Flags=01100104; Segments=4
  Binary[1]: 00
  Text: 'Property'
  Binary[16]: 3A 7C 8D 4C 85 F8 9F 1E AA 83 4F 96 63 0C EC 3D
  Binary[16]: 8B 76 F3 98 78 64 6E 83 15 F5 81 7C 06 CC B6 91

=> MPRO: Flags=01040100; Segments=0

<= MPRO: Flags=01100104; Segments=4
  Binary[1]: 00
  Text: 'Property'
  Binary[16]: 3A 7C 8D 4C 85 F8 9F 1E AA 83 4F 96 63 0C EC 3D
  Binary[16]: 87 49 A1 3E 61 58 EA CE DC 00 0A CB 7D A1 DD CB

<= MPRO: Flags=01040100; Segments=0

<= MPRO: Flags=01140109; Segments=9
  Binary[1]: 00
  Text: 'Property'
  Text: 'Property'
  UInt16[*1]: 0000
  UInt32[*0]:
  UInt32[*0]:
  UInt32[*1]: 000000f0
  Binary[2164]: 4D 4D 53 58 4C 49 54 00 50 72 6F 70 65 72 74 79 [...]
  Binary[0]:

```

（我的格式有些不一致 - 我应该去掉 UInt16/UInt32/Int32 的长度中的 “`*`”，但这实际上并没有影响可读性太多...而且这只是一个相当快速而粗糙的工具的输出。）

这里仍然没有应用级别的信息，但我们可以看到流量的结构 - 这样就更容易辨别应用级别协议的 *位*。

### 应用级别协议

我到目前为止描述的内容都不是特定于混音器的。在某些时候，消息类型、标志和值的某种组合实际上必须 *表示* 一些东西。也许是“请给我发送混音器的版本信息”或“这是输入的米级别”或“请将输入通道 1 到输出通道 5 的连接静音”。

反向工程应用层协议的过程既包括灵感又包括毅力——通常是按照这个顺序，而且只有在至少解决了消息的大部分框架和消息分解之后才开始。你不需要知道所有的东西，但*确实*需要知道：“如果我在混音器上移动一个滑块，使用不同的客户端，我会收到类似 X 的消息。” 这需要一些实验和一些信仰的飞跃。但是接下来你需要仔细记录：“那么，在移动输入 1、输出 1 的滑块和移动输入 2、输出 5 的滑块之间有什么区别？”，或者“将滑块从其范围底部移动到稍高一点，与将其移动到更高一点有什么区别？” 这有点乏味，但仍然是令人惊讶的有益工作——只要你能够足够注意地将你的结果仔细记录在日志中。

我不打算在这里尝试描述各种协议在应用层是什么样子，因为它们变化太大（即使较低的抽象级别相对相似）——还有因为我对它们还有很多不了解的地方。一旦我写了一些细节，它们将会在 GitHub 上。但是理解这些抽象级别的工作方式，对我来说真的很有趣——我相信在完全不同的场景中也会发现它们有用。

## 接下来是什么？

我想在深入了解一些 DigiMixer 的略低级别位后，下一篇文章 *可能* 应该在非常高的层面上，并且回到整个博客系列的目标：抽象。假设我没有被其他事情分心，我会尽量使下一篇文章简单至“混音器在 DigiMixer 范围内有什么共同之处，又在哪些地方不同？” 之后，*也许* 下一篇文章会讨论这种抽象在代码中的实现方式，以及我在这个过程中做出的一些权衡。
