- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:05:29'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: You (probably) don’t need to learn C | Ned Batchelder
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://nedbatchelder.com/blog/202401/you_probably_dont_need_to_learn_c.html](https://nedbatchelder.com/blog/202401/you_probably_dont_need_to_learn_c.html)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On [Mastodon I wrote](https://hachyderm.io/@nedbat/111789013210403320) that
    I was tired of people saying, “you should learn C so you can understand how a
    computer really works.” I got a lot of replies which did not change my mind, but
    helped me understand more how abstractions are inescapable in computers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: People made a number of claims. C was important because syscalls are defined
    in terms of C semantics (they are not). They said it was good for exploring limited-resource
    computers like Arduinos, but most people don’t program for those. They said it
    was important because C is more performant, but Python programs often offload
    the compute-intensive work to libraries other people have written, and these days
    that work is often on a GPU. Someone said you need it to debug with strace, then
    someone said they use strace all the time and don’t know C. Someone even said
    C was good because it explains why NUL isn’t allowed in filenames, but who tries
    to do that, and why learn a language just for that trivia?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: I’m all for learning C if it will be useful for the job at hand, but you can
    write lots of great software without knowing C.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: A few people repeated the idea that C teaches you how code “really” executes.
    But C is an abstract model of a computer, and modern CPUs do all kinds of things
    that C doesn’t show you or explain. Pipelining, cache misses, branch prediction,
    speculative execution, multiple cores, even virtual memory are all completely
    invisible to C programs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: C is an abstraction of how a computer works, and chip makers work hard to implement
    that abstraction, but they do it on top of much more complicated machinery.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'C is far removed from modern computer architectures: there have been 50 years
    of innovation since it was created in the 1970’s. The gap between C’s model and
    modern hardware is the root cause of famous vulnerabilities like Meltdown and
    Spectre, as explained in [C is *Not* a Low-level Language](https://dl.acm.org/doi/pdf/10.1145/3212477.3212479).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: C can teach you useful things, like how memory is a huge array of bytes, but
    you can also learn that without writing C programs. People say, C teaches you
    about memory allocation. Yes it does, but you can learn what that means as a concept
    without learning a programming language. And besides, what will Python or Ruby
    developers do with that knowledge other than appreciate that their languages do
    that work for them and they no longer have to think about it?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Pointers came up a lot in the Mastodon replies. Pointers underpin concepts in
    higher-level languages, but you can [explain those concepts as references](https://nedbatchelder.com/text/names1.html)
    instead, and skip pointer arithmetic, aliasing, and null pointers completely.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'A question I asked a number of people: what mistakes are JavaScript/Ruby/Python
    developers making if they don’t know these things (C, syscalls, pointers)?”. I
    didn’t get strong answers.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我问了很多人一个问题：如果 JavaScript/Ruby/Python 开发者不懂 C、系统调用和指针，他们会犯什么错误？但我没有得到很有力的答案。
- en: We work in an enormous tower of abstractions. I write programs in Python, which
    provides me abstractions that C (its underlying implementation language) does
    not. C provides an abstract model of memory and CPU execution which the computer
    implements on top of other mechanisms (microcode and virtual memory). When I made
    a wire-wrapped computer, I could pretend the signal travelled through wires instantaneously.
    For other hardware designers, that abstraction breaks down and they need to consider
    the speed electricity travels. Sometimes you need to go one level deeper in the
    abstraction stack to understand what’s going on. Everyone has to find the right
    layer to work at.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个巨大的抽象塔中工作。我用 Python 写程序，它提供了 C（它的底层实现语言）所没有的抽象。C 提供了一个内存和 CPU 执行的抽象模型，计算机在其他机制（微码和虚拟内存）之上实现了它。当我制作一个接线板电脑时，我可以假设信号在电线中瞬间传输。对于其他硬件设计者来说，这种抽象是不适用的，他们需要考虑电信号的传输速度。有时你需要深入抽象栈的一个层次来理解发生了什么。每个人都必须找到适合自己工作的正确层次。
- en: '[Andy Gocke said it well](https://hachyderm.io/@agocke/111791030850237121):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[Andy Gocke说得很好](https://hachyderm.io/@agocke/111791030850237121)：'
- en: When you no longer have problems at that layer, that’s when you can stop caring
    about that layer. I don’t think there’s a universal level of knowledge that people
    need or is sufficient.
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你在那个层面不再有问题时，那就是你可以不再关心那个层面的时候了。我不认为有一个普遍的知识水平是人们需要或足够的。
- en: '[“like jam or bootlaces” made another excellent point](https://toot.cat/@idlestate/111793957024682587):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[“像果酱或鞋带”又提出了一个很好的观点](https://toot.cat/@idlestate/111793957024682587)：'
- en: There’s a big difference between “everyone should know this” and “someone should
    know this” that seems to get glossed over in these kinds of discussions.
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “每个人都应该知道这个”和“有人应该知道这个”之间有一个很大的区别，这在这类讨论中似乎被忽略了。
- en: C can teach you many useful and interesting things. It will make you a better
    programmer, just as learning any new-to-you language will because it broadens
    your perspective. Some kinds of programming need C, though other languages like
    Rust are ably filling that role now too. C doesn’t teach you how a computer really
    works. It teaches you a common abstraction of how computers work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C 可以教会你很多有用和有趣的东西。它会让你成为一个更好的程序员，就像学习任何新的语言一样，因为它会拓宽你的视野。有些类型的编程需要 C，虽然 Rust
    等其他语言现在也能很好地扮演这个角色。C 不会教你计算机的真实运行方式。它教你计算机工作的一个通用抽象。
- en: Find a level of abstraction that works for what you need to do. When you have
    trouble there, look beneath that abstraction. You won’t be seeing how things really
    work, you’ll be seeing a lower-level abstraction that could be helpful. Sometimes
    what you need will be an abstraction one level up. Is your Python loop too slow?
    Perhaps you need a C loop. Or perhaps you need numpy array operations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个适合你所需做的抽象层次。当你在那里遇到问题时，往下看。你不会看到事物真正的运行方式，你会看到一个更低级别的抽象，这可能会有所帮助。有时你需要的是一个更高级别的抽象。你的
    Python 循环太慢了吗？也许你需要一个 C 循环。或者也许你需要 numpy 数组操作。
- en: You (probably) don’t need to learn C.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你（很可能）不需要学习 C。
