["```\nwhile (true) {\n if (stop) { break; }\n // Perform some work completing in a reasonable time\n}\n```", "```\n#include <thread>\n#include <atomic>\n#include <stdio.h>\n#include <unistd.h>\n\nstatic std::atomic<bool> stop = false;\n\nint main() {\n std::thread thr([] {\n // prints every second until stopped\n for (int i = 0; !stop.load(); i++) {\n printf(\"iterated %d times\\n\", i);\n sleep(1);\n }\n printf(\"thread terminating\\n\");\n });\n // waits 5 seconds, then stops thread\n sleep(5);\n stop.store(true);\n thr.join();\n printf(\"thread terminated\\n\");\n return 0;\n}\n```", "```\niterated 0 times\niterated 1 times\niterated 2 times\niterated 3 times\niterated 4 times\nthread terminating\nthread terminated\n```", "```\nlock();\n// critical work here\nunlock();\n```", "```\n{\n const std::lock_guard<std::mutex> lock(mutex);\n // critical work here\n // The destructor for `lock` will do the unlocking\n}\n```", "```\n{\n const std::lock_guard<std::mutex> lock(mutex);\n balance_1 += x;\n balance_2 -= x;\n}\n```", "```\npthread_setcancelstate(PTHREAD_CANCEL_DISABLE);\nwhile (true) {\n pthread_setcancelstate(PTHREAD_CANCEL_ENABLE);\n // syscall that might block indefinitely, e.g. reading\n // from a socket\n pthread_setcancelstate(PTHREAD_CANCEL_DISABLE);\n // Perform some work completing in a reasonable time\n}\n```", "```\n// thread_local isn't really necessary here with one thread,\n// but it would be necessary if we had many threads we wanted\n// to kill separately.\nstatic thread_local std::atomic<bool> stop = false;\n\nstatic void stop_thread_handler(int signum) {\n stop.store(true);\n}\n\nint main() {\n // install signal handler\n {\n struct sigaction act = {{ 0 }};\n act.sa_handler = &stop_thread_handler;\n if (sigaction(SIGUSR1, &act, nullptr) < 0) {\n die_syscall(\"sigaction\");\n }\n }\n ...\n```", "```\nssize_t recvlen;\nif (stop.load()) {\n break;\n} else {\n recvlen = recvfrom(sock, buffer.data(), buffer.size(), 0, nullptr, nullptr);\n}\nif (recvlen < 0 && errno == EINTR && stop.load()) {\n // we got the signal while running the syscall\n break;\n}\n```", "```\nif (stop.load()) {\n break;\n} else {\n // signal handler runs here, syscall blocks until\n // packet arrives -- no prompt termination!\n recvlen = recvfrom(sock, buffer.data(), buffer.size(), 0, nullptr, nullptr);\n}\n```", "```\nptread_sigmask(SIG_SETMASK, &unblock_usr1); // unblock USR1\n// signal handler runs here, syscall blocks until\n// packet arrives -- no prompt termination!\nssize_t recvlen = recvfrom(sock, buffer.data(), buffer.size(), 0, nullptr, nullptr);\nptread_sigmask(SIG_SETMASK, &block_usr1); // block USR1 again\n```", "```\nstruct pollfd pollsock = {\n .fd = sock,\n .events = POLLIN,\n};\nif (ppoll(&pollsock, 1, nullptr, &usr1_unmasked) < 0) {\n if (errno == EINTR) {\n break;\n }\n die_syscall(\"ppoll\");\n}\nssize_t recvlen = recvfrom(sock, buffer.data(), buffer.size(), 0, nullptr, nullptr);\n```", "```\nif (stop.load()) {\n break;\n} else {\n // signal handler runs here, syscall blocks until\n // packet arrives -- no prompt termination!\n recvlen = recvfrom(sock, buffer.data(), buffer.size(), 0, nullptr, nullptr);\n}\n```", "```\n// Returns -1 and sets errno to EINTR if `*stop` was true\n// before starting the syscall.\nlong syscall_or_stop(bool* stop, long n, long a, long b, long c, long d, long e, long f) {\n long ret;\n register long rd __asm__(\"r10\") = d;\n register long re __asm__(\"r8\")  = e;\n register long rf __asm__(\"r9\")  = f;\n __asm__ __volatile__ (\n R\"(\n # struct rseq_cs {\n #     __u32   version;\n #     __u32   flags;\n #     __u64   start_ip;\n #     __u64   post_commit_offset;\n #     __u64   abort_ip;\n # } __attribute__((aligned(32)));\n .pushsection __rseq_cs, \"aw\"\n .balign 32\n 1:\n .long 0, 0                # version, flags\n .quad 3f, (4f-3f), 2f     # start_ip, post_commit_offset, abort_ip\n .popsection\n\n .pushsection __rseq_failure, \"ax\"\n # sneak in the signature before abort section as\n # `ud1 <sig>(%%rip), %%edi`, so that objdump will print it\n .byte 0x0f, 0xb9, 0x3d\n .long 0x53053053\n 2:\n # exit with EINTR\n jmp 5f\n .popsection\n\n # we set rseq->rseq_cs to our structure above.\n # rseq = thread pointer (that is fs) + __rseq_offset\n # rseq_cs is at offset 8\n leaq 1b(%%rip), %%r12\n movq %%r12, %%fs:8(%[rseq_offset])\n 3:\n # critical section start -- check if we should stop\n # and if yes skip the syscall\n testb $255, %[stop]\n jnz 5f\n syscall\n # it's important that syscall is the very last thing we do before\n # exiting the critical section to respect the rseq contract of\n # \"no syscalls\".\n 4:\n jmp 6f\n\n 5:\n movq $-4, %%rax # EINTR\n\n 6:\n )\"\n : \"=a\" (ret) // the output goes in rax\n : [stop] \"m\" (*stop),\n [rseq_offset] \"r\" (__rseq_offset),\n \"a\"(n), \"D\"(a), \"S\"(b), \"d\"(c), \"r\"(rd), \"r\"(re), \"r\"(rf)\n : \"cc\", \"memory\", \"rcx\", \"r11\", \"r12\"\n );\n if (ret < 0 && ret > -4096) {\n errno = -ret;\n ret = -1;\n }\n return ret;\n}\n\n// A version of recvfrom which atomically checks\n// the flag before running.\nstatic long recvfrom_or_stop(bool* stop, int socket, void* buffer, size_t length) {\n return syscall_or_stop(stop, __NR_recvfrom, socket, (long)buffer, length, 0, 0, 0);\n}\n```"]