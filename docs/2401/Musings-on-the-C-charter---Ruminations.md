<!--yml

分类：未分类

日期：2024-05-27 14:27:08

-->

# 对 C 宪章的思考 | 沉思录

> 来源：[`blog.aaronballman.com/2023/12/musings-on-the-c-charter/`](https://blog.aaronballman.com/2023/12/musings-on-the-c-charter/)

在 C 委员会内部，人们一直在讨论[C 宪章](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2611.htm)的含义以及是否应该对其进行更新。我个人对这个话题的思考是，为了让 C 保持长期相关性，C 宪章需要更新。C 是否应该保持长期相关性是留给读者去思考的问题。请注意，随着我从更多地方收集到的反馈越来越多，这些想法可能会随着时间而变化。

## 现有代码很重要，现有实现不重要。

标准是实现者和程序员之间的协定。

对现有代码库的迁移是一个问题。

尽量减少与 C90 的不兼容性。

我认为我们可以将这些原则合并成一个要点，而不是四个，因为它们实际上都是关于将代码迁移到更新的标准版本的。

每个新版本的 C 应该提供从上一个 C 版本到下一个 C 版本的简单升级路径，以便用户可以逐渐过渡到相邻版本的 C，但是版本之间的不兼容性是可以接受的。换句话说，即使没有替代，也可以弃用旧功能，或者删除先前弃用的功能（同样，即使没有替代），但是只有在给出对 C 用户的成本的重要的理由时才应该这样做。

更改代码编译标准是程序员和实现者之间的新协议；这类似于更改您的代码（就像更改编译器一样），并且不应期望一切都保持与之前完全相同。旧功能将被弃用，新功能将被添加，错误将被修复等等。新标准 == 新条约。

我认为我们应该谨慎地遵循这个原则。显然，现有的 C 代码库中有很多经济价值，并且重新编写该代码既昂贵又容易出错。然而，C 在其漫长的历史中已经经历了多次修订。1978 年的一个好主意在 2024 年不一定是可接受的做法。我希望看到这个原则得到更新，以设定一个时间限制，类似于：已经维护不使用过去十年中标记为弃用、废弃或移除功能的现有代码很重要；不维护的代码和现有实现不重要。如果您无法更新您的代码以停止依赖弃用功能，那么您的代码实际上并不重要——人们会花时间和金钱来维护重要的东西。

## C 代码可以是可移植的。

C 代码可能是不可移植的。

我认为这两个原则今天仍然是合理的。虽然商品硬件趋向于更加同质化，但仍然存在大量异构硬件解决方案（DSP、FPGA 等），而且像人工智能、机器学习、密码学等领域正在推动新的硬件解决方案的边界。我们应该继续努力做到尽可能的可移植性，同时不限制自己在硬件的最低公分母上。

## 避免悄无声息的变化。

我依然坚信这个原则。它直接影响标准版本之间的过渡 —— 悄无声息的变化使用户更难以升级到最新的标准。

## 保持 C 的精神。

我不认为这个原则有太多价值，因为它太主观了，尽管我理解它背后的愿望。我认为人们希望 C 在发布之间保持熟悉，而不是被重新发明。例如，我认为用户不希望看到语言和社区出现类似 Perl 5/Perl 6 或 Python 2/Python 3 的分叉。然而，我认为现有代码至关重要的原则已经足以满足这种需求。

特别是，我认为像“相信程序员”、“不阻止程序员做必须要做的事情”、“让它快”等概念在系统级编程语言中的安全性需要得到提升的情况下是有问题的。

我希望看到这个项目被删除，因为它不是一个可操作的原则，我认为其他项目已经涵盖了它试图传达的主要内容。

## 支持国际编程。

我依然坚信这个原则，尽管我担心 WG14 缺乏足够的专业知识来真正帮助验证这个领域的设计。我感激 WG21 的 SG16 成员愿意提供建议，以及 Unicode 联盟的人员也积极与编程语言委员会进行交流。但是国际化不仅仅是文本（例如，度量单位、日期/时间功能和输入方法也是国际化的一部分）。我认为这个目标是优秀的，但希望我们作为一个委员会足够谦虚，认识到我们需要外部建议的时候。 

## 将现有实践系统化以解决明显的不足之处。

不同于 C99，伦敦会议的共识是不应该有任何新的发明，没有例外。

我认为这些要点表达的意思是相同的，如果我们愿意表达，我们只需要说一次。然而，我不认为委员会同意无所不创的想法，我们将其作为原则陈述对每个人都不利。首先，我们已经在 C11 和 C23 循环期间展示了我们对创新的舒适。如果我们想将野外存在的不同做法统一成标准化的东西，创新是必要的。“无新创新”是为什么我们仍然没有“指针 + 大小”类型或“字符串”类型的解决方案。解决这些问题的方法有很多种，直到委员会选择了一种并说：“这就是方法”，我们将继续看到更多的临时解决方案。

话虽如此，我认为这两个要点中隐藏着非常重要的内容。例如，有一种有原则的方法来区分“需求”和“想要”对于避免在不够受益的用户上浪费太多委员会时间至关重要。什么使得一项功能成为标准化的好功能，而不是不是？一个功能应该被整合到多大程度（例如，向语言添加一个新的算术类型是否也要求在标准库中支持其 I/O 操作等）？当两个实现支持具有略有不同语义的相同概念功能时，委员会应该使用未定义行为来解决冲突，以便没有用户需要更改代码，还是应该委员会推动确定的行为，尽管知道它会破坏一些用户？我认为我们想要对这些问题有答案，但它们与章程的关系不大，而更多地是与功能设计指导有关。也许我们需要第二个文件来帮助作者了解委员会在提案中需要什么以及为什么需要？

## 最小化与 C++ 的不兼容性。

[C++ 几乎直接从 C 继承了 C 标准库，](https://eel.is/c++draft/library.c#2)但是核心 C++ 语言的规范完全独立于 C 语言规范。尽管在规范上这两种语言是不同的，但每个生产环境下的 C++ 编译器也声称是符合 C 的编译器。此外，C++ 标准库实现最终需要使用 C 接口与主机操作系统通信。所以我认为对于 WG21、C++ 用户和 C++ 实现者来说，尽量减少与 C++ 的不兼容性是最有利的。

根据我作为前 C 和 C++ 兼容性研究组主席以及在这两个委员会中任职约十年的经验，我认为 WG14 在 C 和 C++ 兼容性上花费的委员会时间比 WG21 多得多。WG14 有一个规约要求我们尽量减少这些不兼容性（WG21 没有这样的规约，因为他们没有一个规约）。WG14 委员会花费相当多的会议时间来研究 C 的变化如何影响 C++，我们的召集人经常提醒我们尽量减少不兼容性。相比之下，WG21 在 C 兼容性上花费的委员会时间相对较少，WG21 的领导不积极地试图引导委员会减少不兼容性。考虑到我们委员会之间的规模差异（WG21 的规模大约是 WG14 的 15 倍），这种情况是不可持续的。资源最少的委员会花费了最多的时间在兼容性上，尽管收获最少。

我认为，将 C++ 的特性引入 C 不应该是一个 WG14 规定的要求。如果 WG21 和 WG14 之间没有更紧密的合作（比如[两种语言之间共享的基础文档](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2644.pdf)），我认为 WG14、C 实现者或 C 用户在与 C++ 兼容性上花费的 WG14 委员会的努力所得到的好处不足以支持。不幸的是，委员会之间无法有效合作，损害了委员会中最少代表的人：在这个共享空间中工作的用户。因此，我认为与 C++ 的兼容性应继续作为一个设计原则的目标，特别是对于可能在混合的 C 和 C++ 代码库之间共享的头文件中使用的特性。

## 保持概念上的简单性。

尽管这个原则对我来说有些模糊不清，但我仍然相信它。一个委员会成员认为简单的东西，另一个可能会觉得太复杂了。例如，一个用于重载运算符的特性是否保持了概念上的简单性？我怀疑，问五个委员会成员这个确切的问题，可能会得到七个不同的答案。

## “相信程序员”作为一个目标，在安全和安全编程社区方面已经过时。

我认为这还不够。我认为“信任程序员”导致了几十年的安全漏洞，以至于主要政府机构现在都[建议不要](https://media.defense.gov/2022/Nov/10/2003112742/-1/-1/0/CSI_SOFTWARE_MEMORY_SAFETY.PDF)使用 C（和 C++）。我更希望我们采取更强硬的立场，比如：不要相信程序员。设计设施，使其滥用几乎在病态代码之外几乎不可能。在可能的情况下，更喜欢“定义”行为（明确定义的、实现定义的或未指定的行为），而不是未定义的行为。当可能发生误用时，要求强大的错误检测机制，可以防止未定义的行为。我认为，可以合理地期望“信任我，我知道我在做什么”的用户必须走出语言范畴来实现他们的目标，并使用诸如内联汇编或实现扩展等设施。

## 应用程序编程接口（API）应尽可能自我记录。

我同意这个想法，但我不同意它关于偏好 VLA 接口的表述方式。对于与任何现有 API 无关的新 API，这是合理的指导，但在添加与现有 API 相关的新 API 时，这是不能被辩护的。例如，添加`memset_explicit`不应（也幸运地没有）重新排列参数顺序以符合这个指导，因为这样做会使人们很难将现有使用`memset`迁移到`memset_explicit`，而不会引入与内存相关的错误。我更希望我们将指导更普遍化，而不是关于 VLAs。

## 还缺了什么？

对我来说，我们最缺少的是一个计划。ISO 标准委员会“有责任”考虑来自委员会成员的所有提案，因此委员会采取的方法是接受到达的任何文件，并尝试给予作者反馈，以便他们能够取得进展。话虽如此，我们的责任不包括对讨论论文的时间安排的强制性规定 —— 在考虑所有其他范围内的工作之后，我们可以选择在委员会计划之外考虑文件。但是，委员会从未做到这一点，因此我们发布的标准包括一系列无关的功能和错误修复。我希望看到委员会章程要求我们制定在给定发布周期中要实现的目标路线图，然后坚持这个路线图。我不介意在周期内考虑偶尔的超范围工作，但这不应以牺牲范围内工作为代价。我认为有一个路线图也将有助于委员会、实施者和用户之间的关系，因为它为每个人提供了更多时间来规划未来几年的事务。

我在路线图上最想看到的第一件事情是解决困扰 C 的内存安全问题的目标。我们不必一次性解决所有问题，但我们确实需要开始着手解决这个问题。

## 总结思考

不管委员会中的其他人是否同意我的当前想法，我认为委员会反思我们的章程是一件好事。我认为 C 从许多方面来看都处于一个拐点，他们应该花时间仔细考虑我们希望编程语言的未来是什么样子。我不认为 C 或 C++ 近期会变得无关紧要，但我担心它们正在朝着这个方向发展，并将在没有调整的情况下继续这样做。没有哪种编程语言是“太大而无法失败”的，即使是像 C 这样古老而普遍的语言也不例外。
