["```\nimport Mathlib.Data.Finset.Basic import Mathlib.Data.Finset.Card \n```", "```\nexample (S T : Finset α) : S ⊆ T -> T ⊆ S -> T = S := by \n exact? \n```", "```\nexample (S T : Finset α) : S ⊆ T -> T ⊆ S -> T = S := by \n intro S_subs T_subs rw? at S_subs \n```", "```\nexample (S T X : Finset α) : S = X -> X = T -> S = T := by\n intro S_eq X_eq rw [S_eq, <-X_eq] \n```", "```\nexample (S T : Finset α) : S ⊆ T -> T ⊆ S -> S = T := by\n intro S_subs T_subs  /- Finset.Subset.antisymm looks like: S ⊆ T -> T ⊆ S -> S = T -/\n  /- the S_subs and T_subs parameters leave us with S = T, which matches the goal. -/\n exact Finset.Subset.antisymm S_subs T_subs \n```", "```\nexample (S T : Finset α) : S ⊆ T ∧ T ⊆ S := by\n  /- Finset.Subset.antisymm_iff.mp looks like S = T -> S ⊆ T ∧ T ⊆ S -/\n apply Finset.Subset.antisymm_iff.mp  /- new goal: S = T -/ \n```", "```\n/- While lean cannot auto-solve the outer statement, it can trivially solve the both steps with `exact?` -/ example [DecidableEq α] (S : Finset α) (e1 e2 : α) : e2 ∈ S → insert e2 (insert e1 S) = (insert e1 S) := by\n intro e2_mem  have : e2 ∈ (insert e1 S) := by exact? exact? \n```", "```\n/- (not runnable) -/ have T_card := ind_rank_eq_largest_ind_subset_card ind (insert e2 S) T T_subs T_ind T_max \n```", "```\n/- there is a theorem in Mathlib for this, but we use `have` to create smaller goals to bypass it -/ example [DecidableEq α] (S : Finset α) (e : α) : (insert e S).card ≤ S.card + 1 := by\n  if h : e ∈ S then\n  have : insert e S = S := Finset.insert_eq_self.mpr h rw [this]\n exact Nat.le_add_right (Finset.card S) 1\n  else\n  have : S.card + 1 = (insert e S).card := (Finset.card_insert_of_not_mem h).symm rw [this] \n```", "```\nexample (S T : Finset α) : S ⊆ T -> T ⊆ S -> S = T := by\n intros refine Finset.Subset.antisymm ?left ?right case left => assumption case right => assumption \n```", "```\nexample (a b : ℕ) : a > b -> b > a -> True := by\n intro left right absurd right exact left.asymm \n```", "```\nexample (a b : ℕ) : a > b -> ¬ a > b -> True := by\n intros contradiction \n```", "```\n/- a theorem for this exists in Mathlib, but again we're ignoring it -/ example (S : Finset α) : ¬ S.card = 0 -> S ≠ ∅ := by\n intro neq_zero contrapose neq_zero rw [not_ne_iff] at neq_zero rw [not_not, neq_zero] rfl \n```", "```\nstruct Foo {\n  a: usize;\n b: usize; }   struct Bar(usize, usize); \n```", "```\nstructure And where\n  left : α\n right : β \n```", "```\nhave : a ∧ b := sorry  have 〈 a, b 〉 := this \n```", "```\nenum Foo {\n A(usize),\n B(usize) } \n```", "```\ninductive Or where | inl : α | inr : β \n```", "```\nhave : a ∨ b := sorry  cases this with | inl a => sorry  | inr b => sorry \n```", "```\nhave : ∃ x : N, x < 4 := sorry  have 〈x, x_lt〉 := this /- note that `x` is actually an N that exists satisfying x_lt! -/ \n```", "```\nexample (S : Finset α) : S ≠ ∅ -> ∃ x : α, x ∈ S := by\n intro h  /- before getting an element from S, we have to construct the Nonempty type -/\n  have : S.Nonempty := Finset.nonempty_of_ne_empty h exact this.bex \n```", "```\nhave <name> : <assumption> := <proof of assumption> \n```", "```\nhave <name> : <type> := <construction> \n```", "```\nlet <name> : <type> := <construction> \n```", "```\nexample [DecidableEq α] (a b : Finset α) (e : α) : ¬ e ∈ a -> insert e a = b -> b.card = a.card + 1 := by\n intro mem h  let x := insert e a  have : x.card = a.card + 1 := by\n rw [Finset.card_insert_of_not_mem mem] rw [← this, ← h] \n```"]