["```\ncontoso!Widget::GetCost\ncontoso!StandardWidgets::get_TotalCost+0x12f\nrpcrt4!Invoke+0x73\nrpcrt4!Ndr64StubWorker+0xb9b\nrpcrt4!NdrStubCall3+0xd7\ncombase!CStdStubBuffer_Invoke+0xdb\ncombase!ObjectMethodExceptionHandlingAction<<lambda_...> >+0x47\ncombase!DefaultStubInvoke+0x376\ncombase!ServerCall::ContextInvoke+0x6f3\ncombase!ComInvokeWithLockAndIPID+0xacb\ncombase!ThreadInvoke+0x103\nrpcrt4!DispatchToStubInCNoAvrf+0x18\nrpcrt4!RPC_INTERFACE::DispatchToStubWorker+0x1a9\nrpcrt4!RPC_INTERFACE::DispatchToStubWithObject+0x1a7\nrpcrt4!LRPC_SCALL::DispatchRequest+0x308\nrpcrt4!LRPC_SCALL::HandleRequest+0xdcb\nrpcrt4!LRPC_SASSOCIATION::HandleRequest+0x2c3\nrpcrt4!LRPC_ADDRESS::HandleRequest+0x183\nrpcrt4!LRPC_ADDRESS::ProcessIO+0x939\nrpcrt4!LrpcIoComplete+0xff\nntdll!TppAlpcpExecuteCallback+0x14d\nntdll!TppWorkerThread+0x4b4\nkernel32!BaseThreadInitThunk+0x18\nntdll!RtlUserThreadStart+0x21\n\n```", "```\n00007fff`73a8a59f mov edx,dword ptr [rcx+40h]\n                                    ds:00000000`00000040=????????\n\n```", "```\nusing namespace Microsoft::WRL;\n\nclass StandardWidgets : RuntimeClass<IStandardWidgets, FtmBase>\n{\n    IFACEMETHODIMP get_TotalCost(INT32* result);\n    ⟦ other methods not relevant here ⟧\n\nprivate:\n    HRESULT LazyInitializeWidgetList();\n\n    static constexpr PCWSTR standardWidgetNames[] = {\n        L\"Bob\", L\"Carol\", L\"Ted\", L\"Alice\" };\n    static constexpr int standardWidgetCount =\n        ARRAYSIZE(standardWidgetNames);\n\n    std::vector<ComPtr<Widget>> m_widgets;\n};\n\n```", "```\nIFACEMETHODIMP StandardWidgets::get_TotalCost(INT32* result)\n{\n    *result = 0;\n\n    RETURN_IF_FAILED(LazyInitializeWidgetList());\n\n    INT32 totalCost = 0;\n    for (int i = 0; i < standardWidgetCount; i++) {\n        totalCost += m_widgets[i]->GetCost(); // here\n    }\n    *result = totalCost;\n    return S_OK;\n}\n\n```", "```\nHRESULT StandardWidgets::LazyInitializeWidgetList()\n{\n    // Early-out if already initialized.\n    if (!m_widgets.empty()) {\n        return S_OK;\n    }\n\n    // Lazy-create the vector of standard widgets\n    try {\n        m_widgets.reserve(standardWidgetCount);\n        for (auto name : standardWidgetNames) {\n            ComPtr<Widget> widget;\n            RETURN_IF_FAILED(\n                MakeAndInitialize<Widget>(&widget, name));\n            m_widgets.push_back(widget);\n        }\n    } catch (std::bad_alloc const&) {\n        return E_OUTOFMEMORY;\n    }\n    return S_OK;\n}\n\n```", "```\nHRESULT StandardWidgets::LazyInitializeWidgetList()\n{\n    // Early-out if already initialized.\n    if (!m_widgets.empty()) {\n        return S_OK;\n    }\n\n    // Lazy-create the vector of standard widgets\n    try {\n        std::vector<ComPtr<Widget>> widgets;\n        widgets.reserve(standardWidgetCount);\n        for (auto name : standardWidgetNames) {\n            ComPtr<Widget> widget;\n            RETURN_IF_FAILED(\n                MakeAndInitialize<Widget>(&widget, name));\n            widgets.push_back(widget);\n        }\n        m_widgets.swap(widgets);\n    } catch (std::bad_alloc const&) {\n        return E_OUTOFMEMORY;\n    }\n    return S_OK;\n}\n\n```", "```\nIFACEMETHODIMP StandardWidgets::get_TotalCost(INT32* result)\n{\n    *result = 0;\n\n    RETURN_IF_FAILED(LazyInitializeWidgetList());\n\n    INT32 totalCost = 0;\n    for (auto&& widget : m_widgets) { \n        totalCost += widget->GetCost();\n    } \n    *result = totalCost;\n    return S_OK;\n}\n\n```", "```\nIFACEMETHODIMP StandardWidgets::get_TotalCost(INT32* result)\n{\n    *result = 0;\n\n    RETURN_IF_FAILED(LazyInitializeWidgetList());\n\n    *result = std::transform_reduce( \n        m_widgets.begin(), m_widgets.end(), 0, std::plus<>(),\n    [](auto&& w) { return w->GetCost(); }); \n    return S_OK;\n}\n\n```", "```\n// Crashing thread\n0:006> .frame 1\n01 contoso!StandardWidgets::get_TotalCost+0x12f\n0:006> dv\n    this = 0x000001b7`492833b0\n    ...\n\n// Another thread running at the time of the crash\n0:004> kn\n # Call Site\n00 ntdll!ZwDelayExecution+0x14\n01 ntdll!RtlDelayExecution+0x4c\n02 KERNELBASE!SleepEx+0x84\n04 kernel32!WerpReportFault+0xa4\n05 KERNELBASE!UnhandledExceptionFilter+0xd3a02\n06 ntdll!TppExceptionFilter+0x7a\n07 ntdll!TppWorkerpInnerExceptionFilter+0x1a\n08 ntdll!TppWorkerThread$filt$3+0x19\n09 ntdll!__C_specific_handler+0x96\n0a ntdll!__GSHandlerCheck_SEH+0x6a\n0b ntdll!RtlpExecuteHandlerForException+0xf\n0c ntdll!RtlDispatchException+0x2d4\n0d ntdll!KiUserExceptionDispatch+0x2e\n0e contoso!StandardWidgets::get_TotalCost+0x12f\n0f rpcrt4!Invoke+0x73\n10 rpcrt4!Ndr64StubWorker+0xb9b\n11 rpcrt4!NdrStubCall3+0xd7\n12 combase!CStdStubBuffer_Invoke+0xdb\n14 combase!ObjectMethodExceptionHandlingAction<<lambda_...> >+0x47\n16 combase!DefaultStubInvoke+0x376\n1a combase!ServerCall::ContextInvoke+0x6f3\n1f combase!ComInvokeWithLockAndIPID+0xacb\n21 combase!ThreadInvoke+0x103\n22 rpcrt4!DispatchToStubInCNoAvrf+0x18\n23 rpcrt4!RPC_INTERFACE::DispatchToStubWorker+0x1a9\n25 rpcrt4!RPC_INTERFACE::DispatchToStubWithObject+0x1a7\n27 rpcrt4!LRPC_SCALL::DispatchRequest+0x308\n29 rpcrt4!LRPC_SCALL::HandleRequest+0xdcb\n2a rpcrt4!LRPC_SASSOCIATION::HandleRequest+0x2c3\n2b rpcrt4!LRPC_ADDRESS::HandleRequest+0x183\n2c rpcrt4!LRPC_ADDRESS::ProcessIO+0x939\n2d rpcrt4!LrpcIoComplete+0xff\n2e ntdll!TppAlpcpExecuteCallback+0x14d\n2f ntdll!TppWorkerThread+0x4b4\n30 kernel32!BaseThreadInitThunk+0x18\n31 ntdll!RtlUserThreadStart+0x21\n0:004> .frame 0xe\n0e contoso!StandardWidgets::get_TotalCost+0x12f\n0:004> dv\n    this = 0x000001b7`492833b0\n    ...\n\n```", "```\nclass StandardWidgets : RuntimeClass<IStandardWidgets, FtmBase>\n{\n    IFACEMETHODIMP get_TotalCost(INT32* result);\n    ⟦ other methods not relevant here ⟧\n\nprivate:\n    HRESULT LazyInitializeWidgetList();\n\n    static constexpr PCWSTR standardWidgetNames[] = {\n        L\"Bob\", L\"Carol\", L\"Ted\", L\"Alice\" };\n    static constexpr int standardWidgetCount =\n        ARRAYSIZE(standardWidgetNames);\n\n    std::once_flag m_initializeFlag;\n    std::vector<ComPtr<Widget>> m_widgets;\n};\n\nHRESULT StandardWidgets::LazyInitializeWidgetList()\n{\n    try {\n        std::call_once(m_initializeFlag, [&] {\n            std::vector<ComPtr<Widget>> widgets;\n            widgets.reserve(standardWidgetCount);\n            for (auto name : standardWidgetNames) {\n                ComPtr<Widget> widget;\n                THROW_IF_FAILED(\n                    MakeAndInitialize<Widget>(&widget, name));\n                widgets.push_back(widget);\n            }\n            m_widgets = std::move(widgets);\n        });\n    } catch (std::bad_alloc const&) {\n        return E_OUTOFMEMORY;\n    }\n    return S_OK;\n}\n\n```", "```\nbool isFreeThreaded = !InhibitFtmBase && (FtmBase || Standard mode);\n\n```"]