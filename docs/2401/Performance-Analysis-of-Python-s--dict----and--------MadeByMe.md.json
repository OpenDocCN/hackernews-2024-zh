["```\n[1](#hl-0-1)$ python -m timeit \"dict()\" [2](#hl-0-2)10000000 loops, best of 5: 40 nsec per loop [3](#hl-0-3)$ python -m timeit \"{}\" [4](#hl-0-4)20000000 loops, best of 5: 19.6 nsec per loop \n```", "```\n [1](#hl-1-1)>>> import dis [2](#hl-1-2)>>> def a(): [3](#hl-1-3)...   return dict() [4](#hl-1-4)... [5](#hl-1-5)>>> def b(): [6](#hl-1-6)...   return {} [7](#hl-1-7)... [8](#hl-1-8)>>> dis.dis(a) [9](#hl-1-9) 1           0 RESUME                   0 [10](#hl-1-10) [11](#hl-1-11) 2           2 LOAD_GLOBAL              1 (NULL + dict) [12](#hl-1-12) 12 CALL                     0 [13](#hl-1-13) 20 RETURN_VALUE [14](#hl-1-14)>>> dis.dis(b) [15](#hl-1-15) 1           0 RESUME                   0 [16](#hl-1-16) [17](#hl-1-17) 2           2 BUILD_MAP                0 [18](#hl-1-18) 4 RETURN_VALUE \n```", "```\n[1](#hl-2-1) (1) |    (2)    |          (3)          | (4) |      (5) [2](#hl-2-2)-----|-----------|-----------------------|-----|--------------- [3](#hl-2-3) 1 |         0 | RESUME                | 0   | [4](#hl-2-4) |           |                       |     | [5](#hl-2-5) 2 |         2 | LOAD_GLOBAL           | 1   | (NULL + dict) [6](#hl-2-6) |        12 | CALL                  | 0   | [7](#hl-2-7) |        20 | RETURN_VALUE          |     | \n```", "```\n[1](#hl-3-1)>>> def a(): [2](#hl-3-2)...   return dict() [3](#hl-3-3)... [4](#hl-3-4)>>> dict = lambda: 42 [5](#hl-3-5)>>> [6](#hl-3-6)>>> assert a() == 42 \n```", "```\n *`[1](#hl-0-1)import dis [2](#hl-0-2) [3](#hl-0-3)class Foo: [4](#hl-0-4) def bar(self): [5](#hl-0-5) return 42 [6](#hl-0-6) [7](#hl-0-7) def __str__(self): [8](#hl-0-8) return self.__class__.__name__ [9](#hl-0-9) [10](#hl-0-10)dis.dis(Foo)`* \n```", "```\n *`[1](#hl-1-1)Disassembly of __str__: [2](#hl-1-2) 8           0 RESUME                   0 [3](#hl-1-3) [4](#hl-1-4) 9           2 LOAD_FAST                0 (self) [5](#hl-1-5) 4 LOAD_ATTR                0 (__class__) [6](#hl-1-6) 24 LOAD_ATTR                2 (__name__) [7](#hl-1-7) 44 RETURN_VALUE [8](#hl-1-8) [9](#hl-1-9)Disassembly of bar: [10](#hl-1-10) 5           0 RESUME                   0 [11](#hl-1-11) [12](#hl-1-12) 6           2 RETURN_CONST             1 (42)`* \n```", "```\n*`[1](#hl-5-1)git clone --depth 1 --branch v3.12.0 https://github.com/python/cpython.git [2](#hl-5-2)# or [3](#hl-5-3)git clone --depth 1 --branch v3.12.0 git@github.com:python/cpython.git`* \n```", "```\n *`[1](#hl-6-1)PyTypeObject PyDict_Type = { [2](#hl-6-2) PyVarObject_HEAD_INIT(&PyType_Type, 0) [3](#hl-6-3) \"dict\", [4](#hl-6-4) sizeof(PyDictObject), [5](#hl-6-5) // ... [6](#hl-6-6) dict_init,                                  /* tp_init */ [7](#hl-6-7) // ... [8](#hl-6-8) dict_new,                                   /* tp_new */ [9](#hl-6-9) // ... [10](#hl-6-10)};`* \n```", "```\n **`[1](#hl-7-1)static PyObject * [2](#hl-7-2)dict_new(PyTypeObject*type, PyObject *args, PyObject*kwds) [3](#hl-7-3){ [4](#hl-7-4) assert(type != NULL); [5](#hl-7-5) assert(type->tp_alloc != NULL); [6](#hl-7-6) // dict subclasses must implement the GC protocol [7](#hl-7-7) assert(_PyType_IS_GC(type)); [8](#hl-7-8) [9](#hl-7-9) PyObject *self = type->tp_alloc(type, 0); [10](#hl-7-10) if (self == NULL) { [11](#hl-7-11) return NULL; [12](#hl-7-12) } [13](#hl-7-13) PyDictObject *d = (PyDictObject *)self; [14](#hl-7-14) [15](#hl-7-15) d->ma_used = 0; [16](#hl-7-16) d->ma_version_tag = DICT_NEXT_VERSION( [17](#hl-7-17) _PyInterpreterState_GET()); [18](#hl-7-18) dictkeys_incref(Py_EMPTY_KEYS); [19](#hl-7-19) d->ma_keys = Py_EMPTY_KEYS; [20](#hl-7-20) d->ma_values = NULL; [21](#hl-7-21) ASSERT_CONSISTENT(d); [22](#hl-7-22) [23](#hl-7-23) // ... [24](#hl-7-24)  [25](#hl-7-25) return self; [26](#hl-7-26)}`** \n```", "```\n **`[1](#hl-8-1)static int [2](#hl-8-2)dict_update_common(PyObject *self, PyObject *args, PyObject *kwds, [3](#hl-8-3) const char *methname) [4](#hl-8-4){ [5](#hl-8-5) PyObject *arg = NULL; [6](#hl-8-6) int result = 0; [7](#hl-8-7) [8](#hl-8-8) if (!PyArg_UnpackTuple(args, methname, 0, 1, &arg)) { [9](#hl-8-9) result = -1; [10](#hl-8-10) } [11](#hl-8-11) else if (arg != NULL) { [12](#hl-8-12) result = dict_update_arg(self, arg); [13](#hl-8-13) } [14](#hl-8-14) [15](#hl-8-15) if (result == 0 && kwds != NULL) { [16](#hl-8-16) if (PyArg_ValidateKeywordArguments(kwds)) [17](#hl-8-17) result = PyDict_Merge(self, kwds, 1); [18](#hl-8-18) else [19](#hl-8-19) result = -1; [20](#hl-8-20) } [21](#hl-8-21) return result; [22](#hl-8-22)}`** \n```", "```\n **`[1](#hl-9-1)static int [2](#hl-9-2)dict_update_arg(PyObject *self, PyObject *arg) [3](#hl-9-3){ [4](#hl-9-4) if (PyDict_CheckExact(arg)) { [5](#hl-9-5) return PyDict_Merge(self, arg, 1); [6](#hl-9-6) } [7](#hl-9-7) PyObject *func; [8](#hl-9-8) if (_PyObject_LookupAttr(arg, &_Py_ID(keys), &func) < 0) { [9](#hl-9-9) return -1; [10](#hl-9-10) } [11](#hl-9-11) if (func != NULL) { [12](#hl-9-12) Py_DECREF(func); [13](#hl-9-13) return PyDict_Merge(self, arg, 1); [14](#hl-9-14) } [15](#hl-9-15) return PyDict_MergeFromSeq2(self, arg, 1); [16](#hl-9-16)}`** \n```", "```\n **`[1](#hl-10-1)static int [2](#hl-10-2)dict_merge(PyInterpreterState *interp, PyObject *a, PyObject *b, int override) [3](#hl-10-3){ [4](#hl-10-4) PyDictObject *mp, *other; [5](#hl-10-5) [6](#hl-10-6) assert(0 <= override && override <= 2); [7](#hl-10-7) [8](#hl-10-8) /* We accept for the argument either a concrete dictionary object, [9](#hl-10-9) * or an abstract \"mapping\" object.  For the former, we can do [10](#hl-10-10) * things quite efficiently.  For the latter, we only require that [11](#hl-10-11) * PyMapping_Keys() and PyObject_GetItem() be supported. [12](#hl-10-12) */ [13](#hl-10-13) if (a == NULL || !PyDict_Check(a) || b == NULL) { [14](#hl-10-14) PyErr_BadInternalCall(); [15](#hl-10-15) return -1; [16](#hl-10-16) } [17](#hl-10-17) mp = (PyDictObject*)a; [18](#hl-10-18) if (PyDict_Check(b) && (Py_TYPE(b)->tp_iter == (getiterfunc)dict_iter)) { [19](#hl-10-19) [20](#hl-10-20) // ... [21](#hl-10-21) else { [22](#hl-10-22) /* Do it the generic, slower way */ [23](#hl-10-23) [24](#hl-10-24) // ... [25](#hl-10-25) } [26](#hl-10-26) ASSERT_CONSISTENT(a); [27](#hl-10-27) return 0; [28](#hl-10-28)}`** \n```", "```\n **`[1](#hl-11-1)inst(BUILD_MAP, (values[oparg*2] -- map)) { [2](#hl-11-2) map = _PyDict_FromItems( [3](#hl-11-3) values, 2, [4](#hl-11-4) values+1, 2, [5](#hl-11-5) oparg); [6](#hl-11-6) if (map == NULL) [7](#hl-11-7) goto error; [8](#hl-11-8) [9](#hl-11-9) DECREF_INPUTS(); [10](#hl-11-10) ERROR_IF(map == NULL, error); [11](#hl-11-11)}`** \n```", "```\n **`[1](#hl-12-1)PyObject * [2](#hl-12-2)_PyDict_FromItems(PyObject *const *keys, Py_ssize_t keys_offset, [3](#hl-12-3) PyObject *const *values, Py_ssize_t values_offset, [4](#hl-12-4) Py_ssize_t length) [5](#hl-12-5){ [6](#hl-12-6) bool unicode = true; [7](#hl-12-7) PyObject *const *ks = keys; [8](#hl-12-8) PyInterpreterState *interp = _PyInterpreterState_GET(); [9](#hl-12-9) [10](#hl-12-10) for (Py_ssize_t i = 0; i < length; i++) { [11](#hl-12-11) if (!PyUnicode_CheckExact(*ks)) { [12](#hl-12-12) unicode = false; [13](#hl-12-13) break; [14](#hl-12-14) } [15](#hl-12-15) ks += keys_offset; [16](#hl-12-16) } [17](#hl-12-17) [18](#hl-12-18) PyObject *dict = dict_new_presized(interp, length, unicode); [19](#hl-12-19) if (dict == NULL) { [20](#hl-12-20) return NULL; [21](#hl-12-21) } [22](#hl-12-22) [23](#hl-12-23) ks = keys; [24](#hl-12-24) PyObject *const *vs = values; [25](#hl-12-25) [26](#hl-12-26) for (Py_ssize_t i = 0; i < length; i++) { [27](#hl-12-27) PyObject *key = *ks; [28](#hl-12-28) PyObject *value = *vs; [29](#hl-12-29) if (PyDict_SetItem(dict, key, value) < 0) { [30](#hl-12-30) Py_DECREF(dict); [31](#hl-12-31) return NULL; [32](#hl-12-32) } [33](#hl-12-33) ks += keys_offset; [34](#hl-12-34) vs += values_offset; [35](#hl-12-35) } [36](#hl-12-36) [37](#hl-12-37) return dict; [38](#hl-12-38)}`** \n```", "```\n***`[1](#hl-13-1)$ python -m timeit \"list((1, 2, 'a'))\" [2](#hl-13-2)5000000 loops, best of 5: 53.4 nsec per loop [3](#hl-13-3)$ python -m timeit \"[1, 2, 'a']\" [4](#hl-13-4)10000000 loops, best of 5: 29.7 nsec per loop`*** \n```", "```\n***`[1](#hl-14-1)PyTypeObject PyList_Type = { [2](#hl-14-2) // ... [3](#hl-14-3) (initproc)list___init__, /* tp_init */ [4](#hl-14-4) PyType_GenericAlloc, /* tp_alloc */ [5](#hl-14-5) PyType_GenericNew, /* tp_new */ [6](#hl-14-6) // ... [7](#hl-14-7)}`*** \n```", "```\n****`[1](#hl-0-1)list((1, 2, 3)) [2](#hl-0-2) [3](#hl-0-3)_tmp = list() [4](#hl-0-4)_tmp.extend((1, 2, 3))`**** \n```", "```\n****`[1](#hl-0-1)while (--oparg >= 0) { [2](#hl-0-2) PyObject *item = POP(); [3](#hl-0-3) PyList_SET_ITEM(list, oparg, item); [4](#hl-0-4)}`**** \n```", "```\n****`[1](#hl-15-1)PyObject **dst = list->ob_item; [2](#hl-15-2)memcpy(dst, src, n * sizeof(PyObject *));`**** \n```", "```\n*****`[1](#hl-16-1)$ python -m timeit \"set((1, 2))\" [2](#hl-16-2)5000000 loops, best of 5: 82.6 nsec per loop [3](#hl-16-3)$ python -m timeit \"{1, 2}\" [4](#hl-16-4)5000000 loops, best of 5: 45.5 nsec per loop`***** \n```", "```\n*****`[1](#hl-17-1)PyTypeObject PySet_Type = { [2](#hl-17-2) // ... [3](#hl-17-3) (initproc)set_init, /* tp_init */ [4](#hl-17-4) PyType_GenericAlloc, /* tp_alloc */ [5](#hl-17-5) set_new, /* tp_new */ [6](#hl-17-6) // ... [7](#hl-17-7)}`***** \n```", "```\n *****`[1](#hl-18-1)inst(BUILD_SET, (values[oparg] -- set)) { [2](#hl-18-2) set = PySet_New(NULL); [3](#hl-18-3) if (set == NULL) [4](#hl-18-4) GOTO_ERROR(error); [5](#hl-18-5) int err = 0; [6](#hl-18-6) for (int i = 0; i < oparg; i++) { [7](#hl-18-7) PyObject *item = values[i]; [8](#hl-18-8) if (err == 0) [9](#hl-18-9) err = PySet_Add(set, item); [10](#hl-18-10) Py_DECREF(item); [11](#hl-18-11) } [12](#hl-18-12) if (err != 0) { [13](#hl-18-13) Py_DECREF(set); [14](#hl-18-14) ERROR_IF(true, error); [15](#hl-18-15) } [16](#hl-18-16)}`***** \n```", "```\n*****`[1](#hl-0-1) 2 BUILD_SET                0 [2](#hl-0-2) 4 LOAD_CONST               1 (frozenset({1, 2, 3})) [3](#hl-0-3) 6 SET_UPDATE               1 [4](#hl-0-4) 8 RETURN_VALUE`***** \n```", "```\n *****`[1](#hl-19-1)>>> import sys [2](#hl-19-2)>>> sys.version_info [3](#hl-19-3)sys.version_info(major=3, minor=12, micro=1, releaselevel='final', serial=0) [4](#hl-19-4)>>> [5](#hl-19-5)>>> def a(): [6](#hl-19-6)...   return tuple((1, 2, [])) [7](#hl-19-7)>>> [8](#hl-19-8)>>> def b(): [9](#hl-19-9)...   return (1, 2, []) [10](#hl-19-10)>>> [11](#hl-19-11)>>> import dis [12](#hl-19-12)>>> [13](#hl-19-13)>>> dis.dis(a) [14](#hl-19-14) 1           0 RESUME                   0 [15](#hl-19-15) [16](#hl-19-16) 2           2 LOAD_GLOBAL              1 (NULL + tuple) [17](#hl-19-17) 12 LOAD_CONST               1 (1) [18](#hl-19-18) 14 LOAD_CONST               2 (2) [19](#hl-19-19) 16 BUILD_LIST               0 [20](#hl-19-20) 18 BUILD_TUPLE              3 [21](#hl-19-21) 20 CALL                     1 [22](#hl-19-22) 28 RETURN_VALUE [23](#hl-19-23)>>> dis.dis(b) [24](#hl-19-24) 1           0 RESUME                   0 [25](#hl-19-25) [26](#hl-19-26) 2           2 LOAD_CONST               1 (1) [27](#hl-19-27) 4 LOAD_CONST               2 (2) [28](#hl-19-28) 6 BUILD_LIST               0 [29](#hl-19-29) 8 BUILD_TUPLE              3 [30](#hl-19-30) 10 RETURN_VALUE`***** \n```", "```\n*****`[1](#hl-20-1)PyTypeObject PyTuple_Type = { [2](#hl-20-2) // ... [3](#hl-20-3) 0, /* tp_init */ [4](#hl-20-4) 0, /* tp_alloc */ [5](#hl-20-5) tuple_new, /* tp_new */ [6](#hl-20-6) // ... [7](#hl-20-7)}`***** \n```"]