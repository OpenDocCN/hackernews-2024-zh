["```\nA very long time ago (11+ years) I wrote an zsh-users post about how to\nuse the coproc command.  It might be time to repeat/update it, especially\ngiven that I now understand the reason for one of the problems I noted in\nthe original article.\n\n* What is a \"coproc\"?\n\nIt's short for \"co-process\" which means a second process cooperating with\nthe shell.  It's very similar to a background job started with an \"&\" at\nthe end of the command, except that instead of sharing the same standard\ninput and output as its parent shell, its standard I/O is connected to\nthe parent shell by a special kind of pipe called a FIFO (first in, first\nout).  This allows the parent shell to communicate with the coproc.\n\n(In fact in ksh you start a coprocess by placing \"|&\" at the end of the\ncommand, but that token is already used by zsh for another purpose.)\n\nOne starts a coproc in zsh with\n\n\tcoproc command\n\nThe command has to be prepared to read from stdin and/or write to stdout,\nor it isn't of much use as a coproc.  Generally speaking, the command also\nshould not be one that uses buffered writes on its output, or you may end\nup waiting for output that never appears (more on this below).\n\nAfter it's running, you have several choices:\n\nWrite to the coproc with \"print -p ...\"\nRead from the coproc with \"read -p ...\"\nRedirect output to the coproc with \"othercommand >&p\"\nRedirect input from the coproc with \"othercommand <&p\"\n\n* Why is a coproc useful?\n\nA coproc allows more explicit control over the order of execution of\ncommands and permits incremental communication between the parent shell\nand the coproc.  A command substitution ( `...` or $(...) ) is the\nmore common way of capturing the output of another command, but must be\ngiven all of its input up front and must run to completion so that all\nof its output can be consumed at once.  Replacing it with a coproc\nruns it in parallel with the shell, so the shell needn't wait.\n\nCoproc can be used to assemble a pipeline in a specific order.  In zsh,\na \"while ...; do\" loop at the right-hand-end of a pipeline is run in\nthe current shell (unless backgrounded), so you can set and export\nparameters and so on and they remain set when the loop finishes; but\nzsh is unique in this.  In other shells, such a loop would be run in a\nsubshell, and the left side of the pipe in the current shell.  With a\ncoproc, you can choose which side of the \"pipeline\" to run in the\ncoproc and use redirection for the other side, and thus explicitly\ncontrol which portion is run in the current shell.\n\nCoprocs are also useful if you ever have two commands that each want to\nconsume the other's output:\n\n    coproc command1\n    command2 <&p >&p\n\nI've never had reason to do that, but I suppose it would be good if one\nwas testing a pair of network protocol daemons.\n\nThere are of course other paradigms that can be implemented with coproc.\nFor example, something like:\n\n    if condition1; then\n        coproc command1\n    elif condition2; then\n        coproc command2\n    else\n        coproc command3\n    fi\n    # ... do a bunch of other setup for command4, then ...\n    command4 <&p\n\nIn practice I find that a coproc is rarely an absolute requirement, it\nis just more efficient or convenient in some circumstances.\n\n* How does it work?\n\nHere's a very simple example of a coproc that converts all the text sent\nto it into upper case (\"zsh% \" is the shell prompt):\n\n    zsh% coproc while read line; do print -r -- \"$line:u\"; done\n\nNote that you can put an entire control structure into a coproc; it works\njust like putting \"&\" at the end.  The coproc shows up in the job table\nas a background job; you can bring it into the foreground, kill it, etc.\nIn fact, it's a no-op to put an \"&\" at the end of a \"coproc ...\", because\nzsh is going to background the job already.\n\nWith that coproc running, I can say\n\n    zsh% print -p foo ; read -ep\n    FOO\n\n(Using \"read -e\" means to immediately echo what was just read.)\n\nAbout that output buffering thing:  You might wonder why I didn't use:\n\n    zsh% coproc tr a-z A-Z\n    zsh% print -p foo ; read -ep\n\nIt's because of the output buffering done by \"tr\".  The \"print -p foo\" is\nhappily consumed by \"tr\", but it doesn't produce any output until it has\neither processed a whole buffer-full of bytes (usually 1024) or until it\nhas seen end-of-file on its input and is about to exit.  So \"read -ep\"\nsits there forever, waiting for \"tr\", which is also sitting there forever\nwaiting for someone to send it some more bytes.\n\n* Where might I go wrong with coproc?\n\nThis brings us to an oddity about zsh's coproc:  It sees end-of-file on\nits input only when a new coproc is started.  In other shells, using the\nequivalent of the \"othercommand >&p\" redirection causes the shell to\ndiscard its own copy of the coproc descriptor, so the coproc gets an\nEOF when \"othercommand\" closes its output (exits).  Zsh, however, keeps\nthe coproc descriptor open so that you can repeatedly direct new output\nto the same coproc.  However, there can only be one magic \"p\" descriptor,\nso when you issue a new \"coproc ...\" command, zsh finally does close its\ncopy of the descriptor.  (Some \"othercommand\" may still have it open.)\n\nOne idiom for closing off a coproc's input and output is to use:\n\n    zsh% coproc exit\n\nThat starts a new coproc (which immediately exits), causing the input and\noutput of the old coproc (if any) to be shut down.\n\nHowever, there is a \"gotcha\" here:  When the coproc is a shell construct\n(a complex command like a loop, or a shell function) zsh must fork a new\nsubshell to run that construct in the background.  All versions of zsh up\nthrough 4.3.11 have bug in that this forked subshell still has the magic\n\"p\" descriptor open.  This means that \"coproc exit\" in the parent won't\nclose the input of the shell construct, because the intermediate subshell\nis also holding it open; so the parent can't force the coprocess to see\nan end-of-file on its input, and the coprocess may deadlock.  This does\nnot affect external commands run as coprocesses.\n\nThe workaround for this gotcha is to close the coproc inside the coproc\nitself:\n\n    zsh% coproc { coproc :\n    while read line; do print -r -- \"$line:u\"; done }\n\nThis demonstrates that you can use coproc on an entire brace construct.\nIt also shows that you can use any command that immediately exits (\":\",\n\"return\", \"exit\", \"true\", \"false\", etc.) to close off the coproc.\n\nThis bug is related to another oddity:  You may think from reading the\n\"Why is a coproc useful?\" section that you can build up your own\npipelines by chaining coproc together like this:\n\n    coproc tail\n    coproc head >&p\n\nThat appears to say \"start `tail' as a coproc, and then start `head' as a\nnew coproc with its output connected to the input of the old coproc.\"\nHowever, that doesn't work; zsh recreates the coproc descriptors before\nprocessing the redirection, so what \"coproc head >&p\" actually does is run\n\"head\" with its output connected back to its own input.  This is a good\nway to create either deadlock or an extremely CPU-intensive loop, so I\ndon't recommend doing it.\n\nIt's possible that one or both of these bugs will be fixed in 4.3.12\nand later.\n\nNow a word about input buffering:  In my example, I sent a line to the\ncoproc with \"print -p foo ;\" leaving the \"print\" in the foreground.\nThat's because I know for a fact that the coproc will consume one line\nof input (the \"while read line\" loop) before producing any output at all,\nso I'm sure that \"print\" will finish successfully.  Some other coproc\nmight read only a few bytes before stopping to do some other work, in\nwhich case my \"print\" would block and \"read -ep\" might never run.  It's\nmore usual, therefore, to send input to the coproc from a background\njob:\n\n    zsh% cat /etc/termcap >&p &\n\n(I picked /etc/termcap because it's usually a huge file, so that command\nwill almost certainly block if not backgrounded.)\n\n* Anything else?\n\nNo, that about covers it.  Enjoy.\n\n```"]