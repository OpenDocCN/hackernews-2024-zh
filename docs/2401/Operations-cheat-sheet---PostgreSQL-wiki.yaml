- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-27 14:54:02'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 14:54:02
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Operations cheat sheet - PostgreSQL wiki
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作备忘单 - PostgreSQL wiki
- en: 来源：[https://wiki.postgresql.org/wiki/Operations_cheat_sheet](https://wiki.postgresql.org/wiki/Operations_cheat_sheet)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://wiki.postgresql.org/wiki/Operations_cheat_sheet](https://wiki.postgresql.org/wiki/Operations_cheat_sheet)
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This page is aimed at learning from the wisdom of the PostgreSQL community.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本页面旨在从 PostgreSQL 社区的智慧中学习。
- en: People involved in the PostgreSQL community, as organizations or individuals,
    are posting vast amounts of useful information on blogs, wikis, and websites.
    However, they are scattered, and it will not be easy to find the information you
    are looking for.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 参与 PostgreSQL 社区的人员，无论是组织还是个人，都在博客、维基和网站上发布了大量有用的信息。然而，它们分散在各处，找到您正在寻找的信息将不容易。
- en: Therefore, this page has compiled a collection of links to articles that the
    editor(s) informative, from hundreds of blog sites registered on Planet PostgreSQL,
    plus the PostgreSQL wiki and websites. Some notable topics from these articles
    are picked up here, trying to organize and summarize them for introduction purposes.
    Please feel free to add links to the articles you find helpful to others. Adding
    the summaries of them is also appreciated in addition to the links.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本页面已经编译了一系列链接到编辑者认为信息丰富的文章，这些文章来自注册在 Planet PostgreSQL 上的数百个博客站点，还有 PostgreSQL
    wiki 和网站。这些文章中选取了一些值得注意的主题，在这里进行组织和总结，以供介绍之用。请随意添加您认为对他人有帮助的文章链接。除链接之外，还很感谢您添加对它们的摘要。
- en: '**Notes**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**'
- en: do not expect everything to be extracted from those articles! Diving directly
    into the original articles is strongly recommended.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要期望从这些文章中提取出所有内容！强烈建议直接深入原始文章。
- en: Some configuration parameters, functions, statistics views, and system tables/views
    may only be available after some major versions. Consult PostgreSQL documentation
    for availability.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些配置参数、函数、统计视图和系统表/视图可能仅在某些主要版本之后才可用。请参阅 PostgreSQL 文档以获取可用性信息。
- en: Architecture
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构
- en: Client-Server architecture
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: Server
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器
- en: 'Database server: postgres'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库服务器：postgres
- en: 'Server application: ex. initdb, pg_ctl, pg_upgrade'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器应用程序：例如 initdb、pg_ctl、pg_upgrade
- en: Client
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端
- en: 'Client interface: ex. libpq, ECPG, pgJDBC, psqlODBC, Npgsql'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端接口：例如 libpq、ECPG、pgJDBC、psqlODBC、Npgsql
- en: 'Client application: ex. psql, pgbench, pg_dump, pg_restore'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端应用程序：例如 psql、pgbench、pg_dump、pg_restore
- en: Frontend/Backend protocol
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端/后端协议
- en: Frontend=client, Backend=server
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端=客户端，后端=服务器
- en: message-based protocol for communication between frontends and backends over
    TCP/IP and Unix-domain sockets
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于消息的协议，用于在 TCP/IP 和 Unix 域套接字上前端和后端之间的通信
- en: Current version has been 3.0 since PostgreSQL 7.4 in 2003
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 7.4 自 2003 年以来的当前版本为 3.0
- en: Compatibility between client and server
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的兼容性
- en: psql works best with servers of the same or an older major version. It also
    works with servers of a newer major version, although backslash commands are likely
    to fail.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: psql 最适用于与相同或更旧主要版本的服务器。它也可以与新主要版本的服务器一起使用，尽管反斜杠命令可能会失败。
- en: pg_dump can dump from servers older than itself (servers back to 9.2\. are supported).
    It cannot dump from servers newer major versions.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_dump 可以从比其自身旧的服务器中备份（支持 9.2 版本之前的服务器）。它无法从新主要版本的服务器中备份。
- en: 'Driver is server-version agnostic: Always use the latest driver version'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动程序与服务器版本无关：始终使用最新的驱动程序版本
- en: ex. pgJDBC supports 8.2+ server, Npgsql is tested with supported 5 server major
    versions.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，pgJDBC 支持 8.2+ 服务器，Npgsql 经过支持的 5 个服务器主要版本测试。
- en: Logical database structures
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑数据库结构
- en: Database cluster is a collection of databases, roles, and tablespaces
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库集群是数据库、角色和表空间的集合
- en: 'The database cluster initially contains some databases after initdb:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化后，数据库集群最初包含一些数据库：
- en: 'template1: a new database is cloned from this, unless another template database
    is specified'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: template1：除非指定了另一个模板数据库，否则新数据库将从此克隆
- en: 'template0: a pristine copy of the original contents of template1'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: template0：模板1的原始内容的原始副本
- en: 'postgres: default database used by utilities and users'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: postgres：实用程序和用户使用的默认数据库
- en: Each database contains its own system catalogs that store the metadata of its
    local database objects
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个数据库都包含自己的系统目录，其中存储了本地数据库对象的元数据。
- en: The database cluster contains some shared system catalogs that store the metadata
    of the cluster-wide global objects
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库集群包含一些共享的系统目录，其中存储了集群范围全局对象的元数据。
- en: Shared system catalogs can be accessed from inside each database
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享系统目录可以从每个数据库内部访问
- en: 'Query to get shared system catalogs: `SELECT relname FROM pg_class WHERE relisshared
    AND relkind = ''r'';`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取共享系统目录的查询：`SELECT relname FROM pg_class WHERE relisshared AND relkind = 'r';`
- en: ex. pg_authid, pg_database, pg_tablespace
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如 pg_authid、pg_database、pg_tablespace
- en: Tablespace
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表空间
- en: 'pg_global ($PGDATA/global/): store shared system catalogs'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_global ($PGDATA/global/)：存储共享系统目录
- en: 'pg_default ($PGDATA/base/): store template0, template1, postgres. The default
    tablespace for other databases.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_default ($PGDATA/base/)：存储 template0、template1、postgres。其他数据库的默认表空间。
- en: 'User tablespaces: created with `CREATE TABLESPACE name LOCATION ''dir_path'';`'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户表空间：使用 `CREATE TABLESPACE name LOCATION 'dir_path';` 创建
- en: Database object hierarchy
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库对象层次结构
- en: Database
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: Access method
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存取方法
- en: Cast
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cast
- en: Event trigger
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件触发器
- en: Extension
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展
- en: Foreign-data wrapper
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部数据包装器
- en: Foreign server
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部服务器
- en: Procedural language
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程语言
- en: Publication
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布
- en: Row-level security policy (the name must be distinct from that of any other
    policy for the table)
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行级安全策略（名称必须与表的任何其他策略的名称不同）
- en: Rule (the name must be distinct from that of any other rule for the same table)
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则（名称必须与同一表的任何其他规则的名称不同）
- en: Schema
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式
- en: Aggregate function
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合函数
- en: Collation
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整理
- en: Conversion
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换
- en: Data type
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Domain
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域
- en: Extended statistics
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展统计信息
- en: Foreign table
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部表
- en: Function
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Index
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引
- en: Materialized view
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料化视图
- en: Operator
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符
- en: Operator class
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符类
- en: Operator family
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符族
- en: Procedure
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序
- en: Sequence
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列
- en: Table
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表
- en: Text search configuration
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本搜索配置
- en: Text search dictionary
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本搜索字典
- en: Text search parser
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本搜索解析器
- en: Text search template
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本搜索模板
- en: Trigger (inherits the schema of its table)
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器（继承其表的模式）
- en: View
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Subscription
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅
- en: Transform
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换
- en: User mapping
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户映射
- en: Role
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色
- en: Tablespace
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表空间
- en: Object identifier (OID)
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象标识符（OID）
- en: OIDs are used internally by PostgreSQL as primary keys for various system tables.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OID 在 PostgreSQL 内部用作各种系统表的主键。
- en: ex. `SELECT oid, relname FROM pg_class WHERE relname = 'mytable';`
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如 `SELECT oid, relname FROM pg_class WHERE relname = 'mytable';`
- en: Type oid represents an OID.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 OID 表示一个 OID。
- en: oid is an unsigned four-byte integer.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: oid 是一个无符号的四字节整数。
- en: An OID is allocated from a single cluster-wide counter, so it is not large enough
    to provide database-wide uniqueness.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 OID 是从单个集群范围的计数器分配的，因此它不足以提供数据库范围的唯一性。
- en: A specific object is identified by two OIDs (classid and objid) in pg_depend
    and pg_shdepend.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_depend 和 pg_shdepend 中的两个 OID（classid 和 objid）标识特定对象。
- en: Physical database structures
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理数据库结构
- en: Directories
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 目录
- en: Data directory ($PGDATA)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据目录（$PGDATA）
- en: 'base/: Subdirectory containing per-database subdirectories'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'base/: 包含每个数据库子目录的子目录'
- en: 'global/: Subdirectory containing cluster-wide tables, such as pg_database'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'global/: 包含集群范围表的子目录，如 pg_database'
- en: 'pg_multixact/: Subdirectory containing multitransaction status data (used for
    shared row locks)'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'pg_multixact/: 包含多事务状态数据的子目录（用于共享行锁）'
- en: 'pg_subtrans/: Subdirectory containing subtransaction status data'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'pg_subtrans/: 包含子事务状态数据的子目录'
- en: 'pg_tblspc/: Subdirectory containing symbolic links to tablespaces'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'pg_tblspc/: 包含指向表空间的符号链接的子目录'
- en: 'pg_wal/: Subdirectory containing WAL (Write-Ahead Log) files'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'pg_wal/: 包含 WAL（预写式日志）文件的子目录'
- en: 'pg_xact/: Subdirectory containing transaction commit status data'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'pg_xact/: 包含事务提交状态数据的子目录'
- en: Configuration file directories (optional)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件目录（可选）
- en: Tablespace directories (optional)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表空间目录（可选）
- en: WAL directory (optional)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL 目录（可选）
- en: Files in data directory
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 数据目录中的文件
- en: 'Configuration files (postgresql.conf, pg_hba.conf, pg_ident.conf): Can be stored
    in other directories'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件（postgresql.conf、pg_hba.conf、pg_ident.conf）：可以存储在其他目录中
- en: 'Control file (global/pg_control): Stores control info such as the cluster state,
    checkpoint log location, next OID, next XID'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制文件（global/pg_control）：存储控制信息，如集群状态、检查点日志位置、下一个 OID、下一个 XID
- en: Regular relation data file
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规关系数据文件
- en: 'A relation is a set of tuples: table, index, sequence, materialized view, etc.'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系是一组元组：表、索引、序列、材料化视图等。
- en: Each relation has its own set of files.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个关系都有自己的一组文件。
- en: Each file consists of 8 KB blocks.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文件由 8 KB 块组成。
- en: 'Lazy allocation: A new heap table file contains 0 blocks, while a new B-tree
    index file contains 1 block.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性分配：新的堆表文件包含 0 个块，而新的 B 树索引文件包含 1 个块。
- en: 'There are some types of data files (forks): main, FSM, VM, initialization'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些类型的数据文件（分叉）：主要、FSM、VM、初始化
- en: Main fork (`base/<database_OID>/<relation_filenode_no>`)
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主分支（`base/<database_OID>/<relation_filenode_no>`）
- en: ex. `"SELECT pg_relation_filepath('mytable');"` returns `base/17354/32185`,
    where 17354 is the database's OID and 32185 is the mytable's filenode number
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`"SELECT pg_relation_filepath('mytable');"` 返回 `base/17354/32185`，其中 17354
    是数据库的 OID，32185 是 mytable 的文件节点编号。
- en: Stores tuple data.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储元组数据。
- en: FSM (free space map) fork (`base/<database_OID>/<relation_filenode_no>_fsm`)
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: FSM（空闲空间图）分叉（`base/<database_OID>/<relation_filenode_no>_fsm`）
- en: Keeps track of free space in the relation.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪关系中的空闲空间。
- en: Entries are organized as a tree, where each leaf node entry stores free space
    in one relation block.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条目组织成一棵树，每个叶节点条目存储一个关系块中的空闲空间。
- en: '[pg_freespacemap](https://www.postgresql.org/docs/current/pgfreespacemap.html)
    and [pageinspect](https://www.postgresql.org/docs/current/pageinspect.html) can
    be used to examine its contents.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_freespacemap](https://www.postgresql.org/docs/current/pgfreespacemap.html)
    和 [pageinspect](https://www.postgresql.org/docs/current/pageinspect.html) 可用于检查其内容。'
- en: VM (visibility map) fork (`base/<database_OID>/<relation_filenode_no>_vm`)
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: VM（可见性图）分叉（`base/<database_OID>/<relation_filenode_no>_vm`）
- en: 'Keeps track of:'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪：
- en: which pages contain only tuples that are known to be visible to all active transactions
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面仅包含已知对所有活动事务可见的元组。
- en: which pages contain only frozen tuples
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面仅包含已冻结元组的页面
- en: Each heap relation has a Visibility Map; an index does not have one.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个堆关系都有一个可见性图；索引没有一个。
- en: 'Stores two bits per heap page:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个堆页存储两位：
- en: 'All-visible bit: if set, the page does not contain any tuples that need to
    be vacuumed. Also used by index-only scans to answer queries using only the index
    tuple.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有可见位：如果设置，则页面不包含需要清理的元组。还可由仅索引扫描使用，以仅使用索引元组来回答查询。
- en: 'All-frozen bit: if set, all tuples on the page have been frozen, therefore
    vacuum can skip the page.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有冻结位：如果设置，则页面上的所有元组都已冻结，因此清理程序可以跳过页面。
- en: '[pg_visibility](https://www.postgresql.org/docs/current/pgvisibility.html)
    can be used to examine its contents.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_visibility](https://www.postgresql.org/docs/current/pgvisibility.html)
    可用于检查其内容。'
- en: Initialization fork (base/<database_OID>/<relation_filenode_no>_init)
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化分叉（base/<database_OID>/<relation_filenode_no>_init）
- en: Each unlogged table and index has an initialization fork.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个未记录的表和索引都有一个初始化分叉。
- en: 'The content is empty: table is 0 block, index is 1 block.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容为空：表是 0 块，索引是 1 块。
- en: 'Unlogged relations are reset during recovery: the initialization fork is copied
    over the main fork, and other forks are erased.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未记录关系在恢复期间被重置：初始化分叉被复制到主分叉，其他分叉被擦除。
- en: Temporary relation data file
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时关系数据文件
- en: '`base/<database_OID>/tBBB_FFF`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base/<database_OID>/tBBB_FFF`'
- en: BBB is the backend ID of the backend which created the file, and FFF is the
    filenode number
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: BBB 是创建文件的后端的后端 ID，FFF 是文件节点编号。
- en: ex. `base/5/t3_16450`
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如 `base/5/t3_16450`
- en: Has main, FSM, and VM forks, but not the initialization fork.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有主、FSM 和 VM 分叉，但没有初始化分叉。
- en: A large relation is divided into 1 GB segment files.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大关系被划分为 1 GB 段文件。
- en: e.g., `12345, 12345.1, 12345.2, ...`
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`12345, 12345.1, 12345.2, ...`
- en: Page (= block)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 页面（= 块）
- en: Each page is 8 KB. Configurable when building PostgreSQL.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每页为 8 KB。在构建 PostgreSQL 时可配置。
- en: Relations have the same format.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系具有相同的格式。
- en: The content is the same in memory and on storage.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容在内存和存储中相同。
- en: Each page stores multiple data values called items. In a table, an item is a
    row; in an index, an item is an index entry.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每页存储多个称为项的数据值。在表中，一个项是一行；在索引中，一个项是一个索引条目。
- en: '[pageinspect](https://www.postgresql.org/docs/current/pageinspect.html) can
    be used to examine the content.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pageinspect](https://www.postgresql.org/docs/current/pageinspect.html) 可用于检查内容。'
- en: 'Layout of a page:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面布局：
- en: 'Page header: 24 bytes'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面头：24 字节
- en: 'An array of item identifiers pointing to the actual items: Each entry is an
    (offset,length) pair. 4 bytes per item.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向实际项的项目标识符数组：每个条目是一个 (偏移量，长度) 对。每项 4 字节。
- en: Free space
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空闲空间
- en: Items
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项
- en: 'Special space: 0 byte for tables, different bytes for index types (btree, GIN,
    GiST, etc.)'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊空间：表为 0 字节，索引类型（btree、GIN、GiST 等）的不同字节。
- en: Table row
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 表行
- en: '[[1]](https://www.postgresql.org/docs/current/pageinspect.html) pageinspect]
    can be used to examine the content.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pageinspect](https://www.postgresql.org/docs/current/pageinspect.html) 可用于检查内容。'
- en: Layout of a row
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行布局
- en: 'Header: 23 bytes'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头部：23 字节
- en: 'Null bitmap (optional): 1 bit for each column'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空位图（可选）：每列 1 位
- en: 'User data: columns of the row'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户数据：行的列
- en: Instance
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例
- en: The instance is a group of server-side processes, their local memory, and the
    shared memory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实例是一组服务器端进程，它们的本地内存和共享内存。
- en: Processes
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 进程
- en: 'Single-threaded: postmaster launches a single backend process for each client
    connection. Thus, each SQL execution only uses a single CPU core. Parallel query,
    index build, VACUUM etc. can utilize multiple CPU cores by running multiple server
    processes.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单线程：postmaster 为每个客户端连接启动单个后端进程。因此，每个 SQL 执行仅使用一个 CPU 核心。并行查询、索引构建、VACUUM 等可以通过运行多个服务器进程利用多个
    CPU 核心。
- en: 'postmaster: The parent of all server processes. Controls the server startup
    and shutdown. Create shared memory and semaphores. Launches other server processes
    and reaps dead ones. Opens and listens on TCP ports and/or Unix domain sockets,
    accepts connection requests, and spawns client backends to pass the connection
    requests to.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: postmaster：所有服务器进程的父进程。控制服务器的启动和关闭。创建共享内存和信号量。启动其他服务器进程并清理死掉的进程。打开并侦听 TCP 端口和/或
    Unix 域套接字，接受连接请求，并生成客户端后端以将连接请求传递给它们。
- en: '(Client) backend: Acts on behalf of a client session and handles its requests,
    i.e., executes SQL commands.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （客户端）后端：代表客户端会话并处理其请求，即执行 SQL 命令。
- en: Background processes
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后台进程
- en: 'logger: Catches all stderr output from other processes through pipes, and writes
    them to log files.'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录器：通过管道捕获来自其他进程的所有 stderr 输出，并将其写入日志文件。
- en: 'checkpointer: Handles all checkpoints.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查点处理程序：处理所有检查点。
- en: 'background writer: Periodically wakes up and writes out dirty shared buffers
    so that other processes don''t have to write them when they need to free a shared
    buffer to read in another page.'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后台写入者：定期唤醒并将脏共享缓冲区写出，以便其他进程在需要释放共享缓冲区以读入另一页时不必写入它们。
- en: 'startup: Performs crash and point-in-time recovery. Ends as soon as the recovery
    is complete.'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动：执行崩溃和时间点恢复。一旦恢复完成，就会结束。
- en: 'stats collector: Receives messages from other processes through UDP sockets,
    accumulates statistics about server activity, and writes them to files. The statistics
    can be viewed with pg_stat... views. This process is gone as of PostgreSQL 15.'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计收集器：通过 UDP 套接字从其他进程接收消息，累积关于服务器活动的统计信息，并将其写入文件。可以使用 pg_stat... 视图查看统计信息。此进程在
    PostgreSQL 15 中已消失。
- en: 'walwriter: Periodically wakes up and writes out WAL buffers to reduce the amount
    of WAL that other processes have to write. Also ensures the writes of commit WAL
    records from asynchronously committed transactions.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL 缓冲区写入者：定期唤醒并将 WAL 缓冲区写入，以减少其他进程必须写入的 WAL 量。还确保来自异步提交事务的提交 WAL 记录的写入。
- en: 'archiver: Archives WAL files.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存档程序：存档 WAL 文件。
- en: 'autovacuum launcher: Always running when autovacuum is enabled. Schedules autovacuum
    workers to run.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动清理启动器：当自动清理启用时始终运行。安排自动清理工作者运行。
- en: 'autovacuum worker: Connect to a database as determined in the launcher, examine
    system catalogs to select the tables, and vacuum them.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动清理工作者：根据启动器确定连接到数据库，检查系统目录以选择表，并对其进行清理。
- en: 'parallel worker: Executes part of a parallel query plan.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行工作者：执行并行查询计划的一部分。
- en: 'walreceiver: Runs on the standby server. Receives WAL from the walsender, stores
    it on disk, and tells the startup process to continue recovery based on it.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL 接收者：在备用服务器上运行。从 walsender 接收 WAL，将其存储在磁盘上，并告诉启动过程基于其继续恢复。
- en: 'walsender: Runs on the primary server. Sends WAL to a single walreceiver.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: walsender：在主服务器上运行。将 WAL 发送到单个 walreceiver。
- en: 'logical replication launcher: Run on the subscriber. Coordinates logical replication
    workers to run.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑复制启动器：在订阅者上运行。协调逻辑复制工作者的运行。
- en: 'logical replication worker: Runs on the subscriber. An apply worker per subscription
    receives logical changes from walsender on the publisher and applies them. One
    or more tablesync workers perform initial table copy for each table.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑复制工作者：在订阅者上运行。每个订阅的应用程序工作者从发布者的 walsender 接收逻辑更改并应用它们。一个或多个表同步工作者为每个表执行初始表复制。
- en: 'Background worker: Runs system-supplied or user-supplied code. e.g., used for
    parallel query and logical replication.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后台工作者：运行系统提供的或用户提供的代码。例如，用于并行查询和逻辑复制。
- en: Memory
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 内存
- en: Shared memory
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存
- en: 'Shared buffers: Stores the cached copy of data files (main, FSM, and VM forks).'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享缓冲区：存储数据文件（主要、FSM 和 VM 分叉）的缓存副本。
- en: 'WAL buffers: Transactions put WAL records here before writing them out to disk.'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL 缓冲区：事务在将其写入磁盘之前将 WAL 记录放在这里。
- en: 'Other various areas: One large shared memory segment is divided into areas
    for specific uses.'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他各种区域：一个大的共享内存段被划分为用于特定用途的区域。
- en: The allocations of areas can be examined with [pg_shmem_allocations](https://www.postgresql.org/docs/current/view-pg-shmem-allocations.html).
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用[pg_shmem_allocations](https://www.postgresql.org/docs/current/view-pg-shmem-allocations.html)查看区域的分配情况。
- en: Local memory
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地内存
- en: 'Work memory: Allocated for a query operation such as sort and hash. Configured
    with work_mem and hash_mem_multiplier parameters.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作内存：为排序和哈希等查询操作分配。通过work_mem和hash_mem_multiplier参数配置。
- en: 'Maintenance work memory: Allocated for maintenance operations, such as VACUUM,
    CREATE INDEX, and ALTER TABLE. Configured with maintenance_work_mem parameter.'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护工作内存：为维护操作分配，例如VACUUM、CREATE INDEX和ALTER TABLE。通过maintenance_work_mem参数配置。
- en: 'Temporary buffers: Allocated for caching temporary table blocks. Configured
    with temp_buffers parameter.'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时缓冲区：用于缓存临时表块。通过temp_buffers参数配置。
- en: 'Other various areas: A memory context is allocated for a specific usage (e.g.,
    a message from client, transaction, query plan, execution state). Hundreds of
    memory contexts per session are possible.'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他各种区域：为特定用途（例如来自客户端的消息、事务、查询计划、执行状态）分配内存上下文。每个会话可能有数百个内存上下文。
- en: The allocation and usage of memory contexts can be examined with [pg_backend_memory_contexts](https://www.postgresql.org/docs/current/view-pg-backend-memory-contexts.html)
    view for the current session, and with the function `pg_log_backend_memory_contexts(backend_pid)`
    for other sessions.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用[pg_backend_memory_contexts](https://www.postgresql.org/docs/current/view-pg-backend-memory-contexts.html)视图查看当前会话的内存上下文的分配和使用情况，并使用函数`pg_log_backend_memory_contexts(backend_pid)`查看其他会话的情况。
- en: Reading and writing database data
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取和写入数据库数据
- en: 'Read:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读：
- en: First, search the shared buffers for a buffer containing the target block. If
    found, it's returned to the requester.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在共享缓冲区中搜索包含目标块的缓冲区。如果找到，它将返回给请求者。
- en: Otherwise, allocate a buffer from a free buffer list, and read the target block
    from the data file into the buffer.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，从空闲缓冲区列表中分配一个缓冲区，并将目标块从数据文件读入缓冲区中。
- en: If there's no free buffer, evict and use a used buffer. If it's dirty, writes
    out the buffer to disk.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有空闲缓冲区，则驱逐并使用已用缓冲区。如果是脏的，则将缓冲区写出到磁盘。
- en: Write
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写
- en: Find the target shared buffer, modify its contents, and write the changes to
    the WAL buffers.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找目标共享缓冲区，修改其内容，并将更改写入WAL缓冲区。
- en: The modifying transaction writes out its WAL records from the WAL buffers to
    disk, including the commit WAL record.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改事务将其WAL记录从WAL缓冲区写入磁盘，包括提交WAL记录。
- en: The modified dirty shared buffers are flushed to disk by background writer,
    checkpointer, or any other process. This is asynchronous with the transaction
    completion.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改的脏共享缓冲区由后台写入程序、检查点程序或任何其他进程刷新到磁盘。这与事务完成是异步的。
- en: Any backend can read and write shared buffers, WAL buffers, data and WAL files.
    Unlike some other DBMSs, writes are not exclusively performed by a particular
    background process.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何后端都可以读取和写入共享缓冲区、WAL缓冲区、数据和WAL文件。与其他一些DBMS不同，写操作不是由特定的后台进程执行的。
- en: The database data file is read and written one block at a time. There's no multiblock
    I/O.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库数据文件一次读取和写入一个块。没有多块I/O。
- en: 'Some operations bypass shared buffers: the write of an index during index creation,
    CREATE DATABASE, ALTER TABLE ... SET TABLESPACE'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些操作绕过共享缓冲区：在索引创建期间写入索引、CREATE DATABASE、ALTER TABLE ... SET TABLESPACE
- en: Query processing
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询处理
- en: A client connects to a database, sends a query (SQL command) to the server,
    and receives the result.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端连接到数据库，向服务器发送查询（SQL命令），然后接收结果。
- en: The parser first checks the query for correct syntax. Then, it interprets the
    semantics of the query to understand which tables, views, functions, data types,
    etc. are referenced.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器首先检查查询的正确语法。然后，解释查询的语义，以了解引用了哪些表、视图、函数、数据类型等。
- en: 'The rewrite system (rewriter) transforms the query based on the rules stored
    in the system catalog pg_rewrite. One example is the view: a query that accesses
    a view is rewritten to use the base table.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写系统（重写器）根据系统目录pg_rewrite中存储的规则转换查询。一个例子是视图：访问视图的查询被重写以使用基表。
- en: The planner/optimizer creates a query plan.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计划器/优化器创建查询计划。
- en: The executor executes the query plan and returns the result set to the client.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行器执行查询计划，并将结果集返回给客户端。
- en: Notes
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Each session runs on a connection to a single database. Therefore, it cannot
    access tables on a different database. However, one session can connect to another
    database and create another session via a foreign data wrapper like postgres_fdw,
    and access tables there. For example, an SQL command can join one table on the
    local database and another table on a remote database.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个会话都在与单个数据库的连接上运行。因此，它无法访问不同数据库中的表。但是，一个会话可以连接到另一个数据库并通过像 postgres_fdw 这样的外部数据包装器创建另一个会话，并在那里访问表。例如，一个
    SQL 命令可以在本地数据库上连接一个表，而在远程数据库上连接另一个表。
- en: Each SQL command basically uses only one CPU core. A parallel query and some
    utility commands such as CREATE INDEX and VACUUM can use multiple CPU cores by
    running background workers.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 SQL 命令基本上只使用一个 CPU 核心。并行查询和一些实用命令（如 CREATE INDEX 和 VACUUM）可以通过运行后台工作进程使用多个
    CPU 核心。
- en: References
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考资料
- en: PostgreSQL Documentation
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 文档
- en: Other resources
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 其他资源
- en: Reliability and availability
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可靠性和可用性
- en: Connection
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: What to check when troubleshooting connectivity
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除连接时要检查的内容
- en: Is the database server reachable?
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库服务器是否可达？
- en: '`telnet <host> <port>`, or'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`telnet <host> <port>`，或'
- en: '`nc -zv <host> <port>`'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nc -zv <host> <port>`'
- en: Use `traceroute` (Unix/Linux) or `tracert` (Windows), specifying the protocol
    allowed by the host and intermediary routers.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `traceroute`（Unix/Linux）或 `tracert`（Windows），指定主机和中间路由器允许的协议。
- en: Are the host and port correct?
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机和端口是否正确？
- en: Is the server running?
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器是否正在运行？
- en: Does the server-side firewall allow communication through the port?
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端防火墙是否允许通过该端口通信？
- en: Does the client-side firewall allow communication to the server port?
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端防火墙是否允许与服务器端口通信？
- en: Does pg_hba.conf have any entry that allow the combination of SSL/non-SSL, client
    host, database and user?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_hba.conf 文件中是否有允许 SSL/非 SSL、客户端主机、数据库和用户组合的条目？
- en: Is the listen_addresses parameter configured to allow connection through the
    desired IP addresses, including IPv4 and/or IPv6?
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否配置了 listen_addresses 参数以允许通过所需的 IP 地址（包括 IPv4 和/或 IPv6）进行连接？
- en: Are the database, user name, and password correct?
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库、用户名和密码是否正确？
- en: Does the user have permission to connect to the database?
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否有连接到数据库的权限？
- en: Check privileges with psql's `\l` or pg_database.datacl
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 psql 的 `\l` 或 pg_database.datacl 来检查权限
- en: Does the database server have enough CPU and memory resources?
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库服务器是否具有足够的 CPU 和内存资源？
- en: Isn't the maximum connection limit reached?
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否达到了最大连接限制？
- en: max_connections and superuser_reserved_connections parameters (at instance level)
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: max_connections 和 superuser_reserved_connections 参数（在实例级别）
- en: CREATE/ALTER DATABASE CONNECTION LIMIT (at database level)
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CREATE/ALTER DATABASE CONNECTION LIMIT（在数据库级别）
- en: CREATE/ALTER ROLE CONNECTION LIMIT (at user level)
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CREATE/ALTER ROLE CONNECTION LIMIT（在用户级别）
- en: Connection termination and query cancellation
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 连接终止和查询取消
- en: When the connection is closed, any incomplete transaction is rolled back.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当连接关闭时，任何未完成的事务都将被回滚。
- en: Terminating a connection (`pg_terminate_backend()`) and canceling a query (`pg_cancel_backend()`)
    does not always work. For example, they don't work while the backend process is
    running in an uninterruptible section, such as waiting to acquire a lightweight
    lock, a read/write system call against a network storage device, and a loop without
    a cancellation point.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止连接（`pg_terminate_backend()`）和取消查询（`pg_cancel_backend()`）并不总是有效。例如，在后端进程运行于不可中断的部分时，它们就不起作用，比如等待获取轻量级锁、针对网络存储设备的读/写系统调用以及没有取消点的循环。
- en: Set statement_timeout at appropriate levels (statement, user, database, instance).
    A short timeout is not recommended at a wide level because it cancels intentional
    long-running queries.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的级别设置 statement_timeout（语句、用户、数据库、实例）。不建议在广泛级别设置短超时，因为它会取消意图长时间运行的查询。
- en: Set client-side timeouts appropriately.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当设置客户端超时。
- en: Set server-side timeouts appropriately.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当设置服务器端超时。
- en: tcp_keepalives_idle, tcp_keepalives_interval, tcp_keepalives_count
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: tcp_keepalives_idle、tcp_keepalives_interval、tcp_keepalives_count
- en: TCP keep-alive works while the TCP connection is idle. It does not work when
    the socket connection is being established, or some data has been sent and waiting
    for its ACK.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP keep-alive 在 TCP 连接空闲时工作。当套接字连接正在建立或已发送某些数据并等待其 ACK 时，它不起作用。
- en: The effective timeout is tcp_keepalives_idle + tcp_keepalives_interval * tcp_keepalives_count.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效超时时间是 `tcp_keepalives_idle + tcp_keepalives_interval * tcp_keepalives_count`。
- en: tcp_user_timeout
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: tcp_user_timeout
- en: Sets the TCP retransmission timeout. Relatively newly available on Linux.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 TCP 重传超时。在 Linux 上相对较新的功能。
- en: Comes to the rescue when TCP keep-alive doesn't help. i.e., when the socket
    connection is being established, or some data has been sent and waiting for its
    ACK.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 TCP keep-alive 无效时，提供帮助。即，当套接字连接正在建立或已发送某些数据并等待其 ACK 时。
- en: Confusing when used together with TCP keep-alive because this changes when TCP
    keep-alive times out. It would be safe to set tcp_user_timeout to tcp_keepalives_idle
    + tcp_keepalives_interval * tcp_keepalives_count.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 TCP keep-alive 一起使用时会引起混淆，因为此时 TCP keep-alive 超时。将 tcp_user_timeout 设置为 tcp_keepalives_idle
    + tcp_keepalives_interval * tcp_keepalives_count 可以确保安全。
- en: authentication_timeout
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: authentication_timeout
- en: idle_in_transaction_session_timeout
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: idle_in_transaction_session_timeout
- en: idle_session_timeout
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: idle_session_timeout
- en: client_connection_check_interval
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: client_connection_check_interval
- en: Connection failover
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 连接故障转移
- en: Client drivers allow multiple hosts to be specified in the connection string.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端驱动程序允许在连接字符串中指定多个主机。
- en: Connection timeout is applied to each host in the connection string. Therefore,
    making a connection may take unexpectedly long if there are many failed hosts
    before the running one in the list.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接超时应用于连接字符串中的每个主机。因此，在列表中运行的主机之前有许多失败的主机，如果存在，则建立连接可能需要意外长的时间。
- en: 'Restore session state after failover: session variables, prepared statements,
    temporary tables, holdable cursors (created with DECLARE CURSOR WITH HOLD), advisory
    locks, session user (set with SET SESSION AUTHORIZATION), current user (set with
    SET ROLE).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障转移后恢复会话状态：会话变量、预处理语句、临时表、可保持游标（使用 DECLARE CURSOR WITH HOLD 创建）、咨询锁、会话用户（使用
    SET SESSION AUTHORIZATION 设置）、当前用户（使用 SET ROLE 设置）。
- en: 'Be careful about transaction retry: It''s unknown whether the transaction was
    committed or rolled back when a database server failover happens during the transaction
    commit.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎处理事务重试：当事务提交期间发生数据库服务器故障转移时，无法确定事务是已提交还是已回滚。
- en: '`pg_xact_status( xid8 )` can be used to determine the transaction outcome.'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pg_xact_status( xid8 )` 可用于确定事务结果。'
- en: WAL
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WAL
- en: What WAL is for
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: WAL 的作用是什么
- en: 'Crash recovery, archive recovery (Point-In-Time-Recovery: PITR), and replication'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 崩溃恢复、存档恢复（时间点恢复：PITR）和复制
- en: Updates are redone regardless of whether the transaction was committed.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新无论事务是否已提交都会重新执行。
- en: There is no undo log (before image) or operation, unlike other popular DBMSs.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他流行的 DBMS 不同，没有撤消日志（前置图像）或操作。
- en: Therefore, transaction rollback and crash recovery is fast.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，事务回滚和崩溃恢复很快。
- en: Changes by an aborted transaction are left in memory and on disk, but they are
    invisible to other transactions thanks to MVCC.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中止事务的更改保留在内存和磁盘上，但由于 MVCC，它们对其他事务是不可见的。
- en: WAL structure
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: WAL 结构
- en: A sequence of 8 KB blocks.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列 8 KB 块。
- en: Each block can contain multiple WAL records. Also, each WAL record can span
    multiple blocks.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个块可以包含多个 WAL 记录。此外，每个 WAL 记录可以跨越多个块。
- en: The content is the same both in memory and on storage.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容在内存和存储上都相同。
- en: The WAL buffer is a contiguous array of blocks in memory. It's used in a circular
    fashion.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL 缓冲区是内存中的一系列连续块。它以循环方式使用。
- en: The WAL on storage is divided into WAL segment files. Each WAL segment file
    is 16 MB by default, which is configurable with `initdb`'s `--wal-segsize=size`.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储上的 WAL 被分割为 WAL 段文件。每个 WAL 段文件默认为 16 MB，可使用 `initdb` 的 `--wal-segsize=size`
    进行配置。
- en: Writing WAL
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 WAL
- en: In memory, modify the data pages in shared buffers, and then write the change
    into the WAL buffer.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存中，修改共享缓冲区中的数据页，然后将更改写入 WAL 缓冲区。
- en: WAL buffer is always written to WAL files sequentially (no random write).
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL 缓冲区始终按顺序写入 WAL 文件（无随机写）。
- en: Before writing a dirty data page in a shared buffer out to disk, first all WAL
    records up to the latest one that affected the data page. This rule is the WAL
    (Write Ahead Log).
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将共享缓冲区中的脏数据页写出到磁盘之前，首先写入到最新的影响数据页的所有 WAL 记录。这条规则就是 WAL（预写日志）。
- en: Each data page has, in its page header, the location (LSN) of the WAL record
    that represents the latest update to it. This is the page LSN.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个数据页在其页头中都有一个 WAL 记录的位置（LSN），表示对其的最新更新。这就是页 LSN。
- en: 'LSN (Log Sequence Number): an unsigned 8-byte integer. It represents the WAL
    segment, block, and an offset in that block.'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: LSN（日志序列号）：一个无符号的 8 字节整数。它表示 WAL 段、块和块中的偏移量。
- en: If writing to the WAL file fails, the instance will crash with a PANIC message.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果写入 WAL 文件失败，则实例将崩溃并显示 PANIC 消息。
- en: 'WAL volume can grow beyond max_wal_size due to the reasons such as:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL 体积可能会因为以下原因而超过 max_wal_size：
- en: Heavy writes like loading data with COPY
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像使用 COPY 加载数据这样的大量写入
- en: failure to archive WAL files
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法存档 WAL 文件
- en: the large value of wal_keep_size
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: wal_keep_size 的大值
- en: an unused replication slot
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个未使用的复制槽
- en: 'SELECT can modify data pages and write WAL when:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当：SELECT 可以修改数据页并写入 WAL 时：
- en: acquiring row locks, e.g., SELECT FOR UPDATE. They set xmax in the tuple header,
    and could possibly update MultiXact data structures.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取行锁，例如，SELECT FOR UPDATE。它们在元组头中设置 xmax，并且可能更新 MultiXact 数据结构。
- en: pruning line pointers and defragmenting the page.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修剪行指针并整理页面。
- en: setting hint bits to tuple headers. WAL is emitted when page checksums are enabled.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置提示位到元组头。启用页面校验和时，会发出 WAL。
- en: Transaction
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事务
- en: 'ACID: what they are attributed to'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ACID：它们归因于什么
- en: 'Atomicity: transaction rollback and database recovery'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子性：事务回滚和数据库恢复
- en: 'Consistency: integrity constraints and triggers, such as non-NULL, check, primary
    key/unique/foreign key constraints'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性：完整性约束和触发器，例如非 NULL、检查、主键/唯一/外键约束
- en: 'Isolation: MVCC and locks'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离：MVCC 和锁
- en: 'Durability: WAL'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性：WAL
- en: Transaction ID (XID)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 事务 ID（XID）
- en: A transaction is assigned an XID when it first modifies data, such as in INSERT,
    UPDATE, DELETE, and SELET FOR SHARE/UPDATE.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当事务首次修改数据时，例如在 INSERT、UPDATE、DELETE 和 SELET FOR SHARE/UPDATE 中，会为其分配 XID。
- en: XID assignments are serialized with XidGen LWLock.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: XID 分配与 XidGen LWLock 串行化。
- en: XID assignment is usually very fast, but it might sometimes experience hiccups.
    It allocates and zeros a new commit log (clog) page through SLRU cache every 32K
    transactions. That clog page allocation could possibly flush a dirty page for
    page replacement.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: XID 分配通常非常快，但有时可能会出现故障。它每 32K 个事务分配并清零一个新的提交日志（clog）页通过 SLRU 缓存。该 clog 页分配可能会刷新一个脏页以进行页面替换。
- en: This could cause an unpredictable spike of response time.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能导致响应时间的不可预测的波动。
- en: Read-only transactions do not assign an XID. They are free from the LWLock contention
    for assigning a new XID.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读事务不分配 XID。它们不受 LWLock 分配新 XID 的竞争的限制。
- en: XIDs are stored in tuple headers and visible as xmin and xmax system columns
    (`SELECT xmin, xmax, * FROM mytable`).
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XIDs 存储在元组头中，并作为 xmin 和 xmax 系统列可见（`SELECT xmin, xmax, * FROM mytable`）。
- en: xmin is the XID of a transaction that created the tuple (INSERT, UPDATE, COPY).
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: xmin 是创建元组（INSERT、UPDATE、COPY）的事务的 XID。
- en: 'xmax is the XID of a transaction that either:'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: xmax 是一个事务的 XID，它可能：
- en: deleted the tuple (DELETE, UPDATE).
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了元组（DELETE、UPDATE）。
- en: locked the tuple (e.g., SELECT FOR SHARE/UPDATE)
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定了元组（例如，SELECT FOR SHARE/UPDATE）
- en: Special XID values
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊 XID 值
- en: '0: invalid XID'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0：无效 XID
- en: '1: bootstrap XID. Used by bootstrap processing during initdb.'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1：引导 XID。在 initdb 期间的引导处理中由引导使用。
- en: '2: Frozen XID: Recent versions of PostgreSQL only use this for sequence tuples,
    not for tables.'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2：冻结 XID：最近的 PostgreSQL 版本仅对序列元组使用此值，而不用于表。
- en: 'MVCC: Multi-Version Concurrency Control'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: MVCC：多版本并发控制
- en: The major advantage of MVCC is "reading never blocks writing and writing never
    blocks reading." i.e., UPDATE/DELETE and SELECT on the same row do not block each
    other.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVCC 的主要优势是“读不阻塞写，写不阻塞读”。即，对同一行的 UPDATE/DELETE 和 SELECT 不会互相阻塞。
- en: Writes to the same row block each other.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入相同行的阻塞彼此。
- en: In the traditional lock-based concurrency control, read and write on the same
    row conflict.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传统的基于锁的并发控制中，对同一行的读写会发生冲突。
- en: 'How it works overall:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体运作方式：
- en: Insert and update to a row create a new version of the row. Update leaves the
    old row version for other running transactions. (Multi-version)
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对行进行插入和更新会创建行的新版本。更新会为其他正在运行的事务保留旧的行版本。（多版本）
- en: XID of the creating transaction is set to xmin field in the new row version.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建事务的 XID 设置为新行版本中的 xmin 字段。
- en: The new row version is only visible to its creating transaction until it commits.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新行版本只对其创建事务可见，直到其提交。
- en: Once the creating transaction commits, all new subsequent transactions will
    be able to see the new row version. Other existing transactions continue to see
    the old row version. The old row version is a "dead tuple" now.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦创建事务提交，所有后续的新事务都将能够看到新的行版本。其他现有事务继续看到旧的行版本。旧的行版本现在是一个“死元组”。
- en: Delete to a row does not remove the row version. It sets the XID of the deleting
    transaction to xmax field in the row version.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除行不会移除行版本。它会将删除事务的 XID 设置为行版本中的 xmax 字段。
- en: The deleted row version is only invisible to its deleting transaction until
    it commits.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被删除的行版本在其删除事务提交之前对其删除事务是不可见的。
- en: Once the deleting transaction commits, all new subsequent transactions won't
    be able to see the row version. Other existing transactions continue to see the
    row version. The row version is a "dead tuple" now.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦删除事务提交，所有新的后续事务将无法看到行版本。其他现有事务继续看到行版本。现在行版本是一个“死元组”。
- en: Finally, when there are no transactions remaining that can see the dead tuple,
    vacuum removes it.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当没有剩余的事务能够看到死元组时，vacuum会将其移除。
- en: 'How tuple visibility works:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组可见性的工作原理：
- en: Each transaction uses its own snapshot, commit log (clog), and the xmin and/or
    xmax in the target tuple header, to determine whether it can see a given row version.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个事务使用自己的快照、提交日志（clog）、以及目标元组头中的xmin和/或xmax，以确定它是否可以看到给定的行版本。
- en: 'What snapshot is:'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照是什么：
- en: A picture of what transactions are running at a certain point of time.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示某一时间点运行的事务的图像。
- en: You can run "`SELECT pg_current_snapshot();`" to see the snapshot of the current
    transaction.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以运行"`SELECT pg_current_snapshot();`"来查看当前事务的快照。
- en: The snapshot's textual representation is xmin:xmax:xip_list. e.g., 10:20:10,14,15.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照的文本表示形式是xmin:xmax:xip_list。例如，10:20:10,14,15。
- en: 'xmin: Lowest transaction ID that was still active. All transaction IDs less
    than xmin are either committed and visible, or rolled back and dead.'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: xmin：仍处于活动状态的最低事务ID。所有小于xmin的事务ID要么已提交且可见，要么已回滚且已死。
- en: 'xmax: One past the highest completed transaction ID. All transaction IDs greater
    than or equal to xmax had not yet completed as of the time of the snapshot, and
    thus are invisible.'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: xmax：最高已完成的事务ID的后一个。所有大于或等于xmax的事务ID在快照生成时尚未完成，因此是不可见的。
- en: 'xip_list: Transactions in progress at the time of the snapshot. A transaction
    ID that is xmin <= X < xmax and not in this list was already completed at the
    time of the snapshot, and thus is either visible or dead according to its commit
    status.'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: xip_list：在快照生成时正在进行的事务。一个事务ID，满足xmin <= X < xmax且不在此列表中，已在快照生成时完成，因此根据其提交状态，它可能是可见的或死的。
- en: In a READ COMMITTED transaction, a snapshot is taken at the beginning of every
    SQL statement.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在读提交事务中，每个SQL语句的开始都会获取一个快照。
- en: In a REPEATABLE READ or SERIALIZABLE transaction, a snapshot is obtained at
    the start of the first SQL statement and used throughout the transaction.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可重复读或串行化事务中，快照在第一个SQL语句开始时获取，并在整个事务期间使用。
- en: 'What commit log (clog) is:'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交日志（clog）是什么：
- en: An array of bits representing the transaction status.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示事务状态的位数组。
- en: 'Two bits are used to indicate a transaction''s outcome: IN PROGRESS, COMMITTED,
    ABORTED, SUBCOMMITTED.'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个位用于指示事务的结果：进行中、已提交、已中止、子已提交。
- en: Stored in a set of files in $PGDATA/pg_xact/.
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在$PGDATA/pg_xact/目录下的一组文件中。
- en: Cached in memory buffers of 128 8 KB pages.
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存在128个8 KB页面的内存缓冲区中。
- en: Clog is consulted when the snapshot shows that the target transaction has been
    completed.
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当快照显示目标事务已完成时，会查询clog。
- en: Based on the snapshot and clog, the change by a committed transaction is visible,
    and that by an aborted or running transaction is invisible.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于快照和clog，已提交事务的更改是可见的，而已中止或正在运行的事务的更改是不可见的。
- en: The actual tuple visibility is much more complex...
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的元组可见性要复杂得多...
- en: Hint bit
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示位**'
- en: Hint bits are the bits in the tuple header's infomask field that help determine
    tuple visibility.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示位是元组头的infomask字段中帮助确定元组可见性的位。
- en: They are for performance optimization. Not essential to data correctness.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们用于性能优化。对数据正确性不是必需的。
- en: 'They represent whether the transaction indicated by xmin or xmax was committed
    or aborted. There are four flag bits:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们表示由xmin或xmax指示的事务是已提交还是已中止。有四个标志位：
- en: '`HEAP_XMIN_COMMITTED`: xmin transaction was committed'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HEAP_XMIN_COMMITTED`: xmin事务已提交'
- en: '`HEAP_XMIN_INVALID`: xmin transaction was aborted'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HEAP_XMIN_INVALID`: xmin事务已中止'
- en: '`HEAP_XMAX_COMMITTED`: xmax transaction was committed'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HEAP_XMAX_COMMITTED`: xmax事务已提交'
- en: '`HEAP_XMAX_INVALID`: xmax transaction was aborted'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HEAP_XMAX_INVALID`: xmax事务已中止'
- en: 'How hint bits are used:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示位的使用方式：
- en: A transaction checks the hint bits to see if the xmin and/or xmax transaction
    was committed or aborted.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事务检查提示位以查看xmin和/或xmax事务是否已提交或已中止。
- en: If the hint bits are set, done.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设置了提示位，完成。
- en: Otherwise, examine the commit log ($PGDATA/pg_xact/), and possibly the subtransaction
    hierarchy ($PGDATA/pg_subtrans/) to determine the transaction outcome. This is
    an expensive operation.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，检查提交日志（$PGDATA/pg_xact/），可能还要检查子事务层次结构（$PGDATA/pg_subtrans/）以确定事务结果。这是一项昂贵的操作。
- en: Set the hint bits. They will be persisted to disk later.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置提示位。稍后将它们持久化到磁盘上。
- en: Setting hint bits writes a data page, and can also write WAL if page checksums
    are enabled.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置提示位会写入一个数据页面，并且如果启用了页面校验和，则也会写入 WAL。
- en: Lock
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁
- en: A lock request can wait, even when the requested mode is compatible with held
    locks.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定请求可以等待，即使请求的模式与持有的锁兼容。
- en: 'Q: Do you think Transaction 3 goes on to run the query?'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q：你认为事务 3 是否会继续运行查询？
- en: 'Transaction 1: A long-running `SELECT` is still running against mytable.'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事务 1：针对 mytable 运行的长时间`SELECT`查询仍在运行。
- en: 'Transaction 2: Run "`ALTER TABLE mytable ADD COLUMN new_col int;`". Get blocked
    because ALTER TABLE''s Access Exclusive lock request conflicts with the Access
    Share lock held by Transaction 1''s `SELECT`.'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事务 2：运行 "`ALTER TABLE mytable ADD COLUMN new_col int;`"。被阻塞，因为 ALTER TABLE 的
    Access Exclusive 锁请求与事务 1 的`SELECT`持有的 Access Share 锁冲突。
- en: 'Transaction 3: Run a short `SELECT` query against mytable.'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事务 3：针对 mytable 运行一个简短的`SELECT`查询。
- en: 'A: Transaction 3 waits until Transaction 2 completes, because Transaction 2
    came earlier and is waiting.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A：事务 3 将等待，直到事务 2 完成，因为事务 2 较早，并且正在等待。
- en: Later requestors respect earlier waiters in the wait queue and do not overtake
    them. Otherwise, earlier requestors might wait for an unduly long time.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后续请求者尊重等待队列中的早期请求者，并且不会超越它们。否则，早期请求者可能会等待过长时间。
- en: 'Therefore, execute even the DDL that is expected to run fast:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，即使是预计会快速运行的 DDL 也要执行：
- en: during off-peak hours, and/or
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非高峰时段，和/或者
- en: with a lock timeout. e.g., run "`SET lock_timeout = '5s';`" before the DDL.
    Retry the DDL if it times out.
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有锁定超时。例如，在DDL之前运行 "`SET lock_timeout = '5s';`"。如果超时，请重试DDL。
- en: This is not true for lightweight locks. In extreme cases, an Exclusive mode
    request on a LWLock could wait for dozens of seconds due to later Share mode requestors
    coming one after another.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于轻量级锁来说，这并不正确。在极端情况下，对 LWLock 的独占模式请求可能会等待几十秒，因为后续的共享模式请求者一个接一个地到来。
- en: Prepared transactions lurk holding locks
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 准备事务潜伏持有锁定
- en: A prepared transaction continues to hold locks, but it does not appear in [pg_stat_activity](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW)
    because it has no associated session.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备事务继续持有锁定，但它不会出现在 [pg_stat_activity](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW)
    中，因为它没有关联的会话。
- en: '[pg_locks](https://www.postgresql.org/docs/current/view-pg-locks.html) shows
    the prepared transaction as an entry having NULL pid. Check pg_prepared_xacts.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_locks](https://www.postgresql.org/docs/current/view-pg-locks.html)显示准备事务为具有
    NULL pid 的条目。检查 pg_prepared_xacts。'
- en: Data integrity validation
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据完整性验证
- en: Data checksums
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 数据校验和
- en: Purpose and usage
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的和用途
- en: The data page of every relation, including all forks, has a 16-bit checksum
    in its page header.
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个关系的数据页面，包括所有分支，都在其页面头中具有一个 16 位的校验和。
- en: Designed to detect corruption by the I/O system (e.g., volume manager, file
    system, disk driver, storage firmware, storage device, etc.) Early detection prevents
    the propagation of corruption.
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旨在通过 I/O 系统（例如，卷管理器，文件系统，磁盘驱动器，存储固件，存储设备等）检测损坏。早期检测可防止损坏的传播。
- en: Not designed to detect memory errors.
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不设计用于检测内存错误。
- en: Enabled at the full cluster level, either with `initdb`'s -k/--data-checksums
    or with `pg_checksums` while the database server is shut down. Disabled by default
    due to its performance overhead.
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个集群级别启用，要么使用 `initdb` 的 -k/--data-checksums，要么在数据库服务器关闭时使用 `pg_checksums`。由于其性能开销，默认情况下是禁用的。
- en: Run `"SHOW data_checksums"` to know if data checksums are enabled. It returns
    on or off.
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `"SHOW data_checksums"` 以了解数据校验和是否已启用。它返回 on 或 off。
- en: How it works
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作原理
- en: The checksum is calculated from the page content and set when the data page
    is about to be written out to disk.
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据页面即将写入磁盘时，从页面内容计算校验和并设置校验和。
- en: Just after reading the page from disk, the checksum is verified by comparing
    the value set in the page header and the newly calculated value.
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刚刚从磁盘读取页面后，通过比较页面头中设置的值和新计算的值来验证校验和。
- en: If the verification fails, a WARNING and ERROR messages are emitted, resulting
    in a query failure.
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果验证失败，则发出警告和错误消息，导致查询失败。
- en: If the page header fails a basic sanity check before performing checksum verification,
    the query will fail with the same ERROR message, without the WARNING that indicates
    the checksum failure.
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在执行校验和验证之前，页面头未通过基本的合理性检查，则查询将以相同的错误消息失败，而不会出现指示校验和失败的警告。
- en: WAL CRC
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: WAL CRC
- en: WAL uses a 32-bit CRC in each WAL record header.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL 在每个 WAL 记录头中使用 32 位 CRC。
- en: The CRC is set when the WAL record is put in the WAL buffer, and verified when
    the WAL record is read.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当WAL记录放入WAL缓冲区时设置CRC，并在读取WAL记录时验证。
- en: Utilities to detect, bypass, or repair data corruption (some could be dangerous!)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 检测、绕过或修复数据损坏的实用工具（有些可能很危险！）
- en: Additional modules
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加模块
- en: '[amcheck](https://www.postgresql.org/docs/current/amcheck.html): Detects logical
    corruption of heaps (table, sequence, materialized view) and B-tree indexes.'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[amcheck](https://www.postgresql.org/docs/current/amcheck.html)：检测堆（表、序列、物化视图）和B-tree索引的逻辑损坏。'
- en: '[pg_surgery](https://www.postgresql.org/docs/current/pgsurgery.html): `heap_force_kill()`
    and `heap_force_freeze()` forcibly removes and freezes heap tuples respectively.'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_surgery](https://www.postgresql.org/docs/current/pgsurgery.html)：`heap_force_kill()`和`heap_force_freeze()`分别强制删除和冻结堆元组。'
- en: '[pg_visibility_map](https://www.postgresql.org/docs/current/pgvisibility.html):
    `pg_check_frozen()` and `pg_check_visible()` detect visibility map corruption.'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_visibility_map](https://www.postgresql.org/docs/current/pgvisibility.html)：`pg_check_frozen()`和`pg_check_visible()`检测可见性映射损坏。'
- en: Configuration parameters
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置参数
- en: ignore_checksum_failure
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ignore_checksum_failure
- en: zero_damaged_pages
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: zero_damaged_pages
- en: ignore_system_indexes
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ignore_system_indexes
- en: Backup and recovery
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备份和恢复
- en: Backup and recovery methods
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 备份和恢复方法
- en: File system level backup (binary format)
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件系统级备份（二进制格式）
- en: SQL Dump with pg_dump/pg_dumpall (text format)
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQL dump与pg_dump/pg_dumpall（文本格式）
- en: Continuous archiving (binary format)
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连续归档（二进制格式）
- en: Characteristics of backup and recovery methods
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 备份和恢复方法的特征
- en: SQL dump and continuous archiving can be performed online. The file system level
    backup requires the database server to be shut down.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL dump和连续归档可以在线执行。文件系统级备份需要关闭数据库服务器。
- en: SQL dump can selectively back up and restore individual tables. The other methods
    cannot back up or restore only certain individual tables or tablespaces.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL dump可以选择性地备份和还原单个表。其他方法无法备份或还原仅某些单个表或表空间。
- en: The SQL dump will typically be smaller, because the SQL script needs to contain
    just the index creation command, not the index data.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL dump通常会更小，因为SQL脚本只需包含索引创建命令，而不是索引数据。
- en: The SQL dump can be loaded into a database of a newer major version.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL dump可以加载到较新主要版本的数据库中。
- en: The SQL dump can transfer a database to a different machine architecture, such
    as going from a 32-bit to a 64-bit server.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL dump可以将数据库传输到不同的机器架构，例如从32位服务器到64位服务器。
- en: Continuous archiving can perform PITR. The database cluster can be recovered
    up-to-date or to a certain point of time.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续归档可以执行PITR。数据库集群可以恢复到最新状态或到某个特定时间点。
- en: Dumps created by pg_dump are consistent; the dump of each database is a snapshot
    of the database when pg_dump started. pg_dumpall calls pg_dump for each database
    in turn, so the database cluster-wide consistency is not guaranteed.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由pg_dump创建的转储文件是一致的；每个数据库的转储是pg_dump启动时数据库的快照。pg_dumpall为每个数据库依次调用pg_dump，因此不保证数据库集群的一致性。
- en: 'pg_dump dumps all data in a database within a single transaction, issuing many
    SELECT commands. That long-running transaction could:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_dump在单个事务中为数据库中的所有数据进行转储，发出许多SELECT命令。该长时间运行的事务可能：
- en: block other operations that require strong lock modes, such as ALTER TABLE,
    TRUNCATE, CLUSTER, REINDEX.
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止其他需要强锁定模式的操作，例如ALTER TABLE、TRUNCATE、CLUSTER、REINDEX。
- en: cause table and index bloat, because vacuum cannot remove dead tuples.
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致表和索引膨胀，因为vacuum无法删除死元组。
- en: '`pg_backup_start()` and `pg_basebackup` of continuous archiving performs a
    checkpoint at the beginning. The user can choose the checkpoint speed between
    "fast" and "spread".'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续归档的`pg_backup_start()`和`pg_basebackup`在开始时执行检查点。用户可以在“快速”和“扩散”之间选择检查点速度。
- en: Archive recovery, as well as crash recovery, empties the content of unlogged
    relations. SQL dump outputs the contents of unlogged tables.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存档恢复以及崩溃恢复会清空未记录关系的内容。SQL dump会输出未记录表的内容。
- en: pg_dumpall's --no-role-passwords option uses pg_roles instead of pg_authid to
    dump database roles. This allows the use of pg_dumpall in restricted environments
    like DBaaS where users are not permitted to read pg_authid to protect passwords.
    The restored roles will have NULL passwords.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_dumpall的--no-role-passwords选项使用pg_roles而不是pg_authid来转储数据库角色。这允许在像DBaaS这样的受限环境中使用pg_dumpall，其中用户不被允许读取pg_authid以保护密码。恢复的角色将具有NULL密码。
- en: Streaming replication
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流复制
- en: Architecture
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 架构
- en: Topology
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑结构
- en: Only the entire database cluster is replicated. Partial replication is not possible.
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有整个数据库集群会被复制。无法部分复制。
- en: One primary server replicates to one or more standby servers.
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主服务器复制到一个或多个备用服务器。
- en: Each standby replicates from one primary.
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个备用服务器从一个主服务器复制。
- en: The standby can cascade changes to other standbys.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备用服务器可以级联更改到其他备用服务器。
- en: The primary is unaware of the locations of standbys. The standby connects to
    the primary specified by primary_conninfo parameter.
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主服务器不知道备用服务器的位置。备用服务器连接到由primary_conninfo参数指定的主服务器。
- en: ex. `primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'`
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如。`primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'`
- en: Primary and standby versions
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主服务器和备用服务器版本
- en: Different major versions don't work.
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的主要版本不兼容。
- en: Different minor versions will work because the disk format is the same, but
    no formal support is offered. It's advised to keep primary and standby servers
    at the same minor version.
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的次要版本会工作，因为磁盘格式相同，但不提供正式支持。建议将主服务器和备用服务器保持在相同的次要版本。
- en: It's safest to update the standby servers first during minor version upgrade.
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在次要版本升级期间，最安全的做法是首先更新备用服务器。
- en: Processes and data flow
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程和数据流
- en: At server startup, the standby first reads and applies WAL from archive, next
    from $PGDATA/pg_wal/, and then launches one walreceiver, which connects to the
    primary and streams WAL from there. If the replication connection is terminated,
    it repeats this cycle at 5 second intervals, which can be configured by wal_retrieve_retry_interval.
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器启动时，备用服务器首先从归档中读取并应用WAL，然后从$PGDATA/pg_wal/读取，并启动一个walreceiver，该walreceiver连接到主服务器并从主服务器流式传输WAL。如果复制连接终止，它会以5秒的间隔重复此周期，该间隔可以由wal_retrieve_retry_interval配置。
- en: The primary spawns the walsender when it accepts the connection request from
    walreceiver.
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主服务器在接受来自walreceiver的连接请求时生成walsender。
- en: walsender reads and sends WAL to the walreceiver.
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: walsender读取并发送WAL到walreceiver。
- en: walreceiver writes and flushes the streamed WAL to $PGDATA/pg_wal/, and notifies
    the startup process.
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: walreceiver将流式WAL写入并刷新到$PGDATA/pg_wal/，并通知启动进程。
- en: A single startup process reads and applies the WAL.
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个启动进程读取并应用WAL。
- en: walreceiver periodically notifies the walsender of replication progress -- how
    far it has written, flushed, and applied the WAL.
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: walreceiver定期通知walsender有关复制进度的信息--它已经写入，刷新和应用了多远的WAL。
- en: A cascading standby has walsenders as well as a walreceiver running.
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级联备用服务器具有运行walsenders和walreceiver的功能。
- en: Replication user
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制用户
- en: The replication user needs REPLICATION role attribute.
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制用户需要REPLICATION角色属性。
- en: REPLICATION enables the user to read all data for replication, but not for consumption
    by SELECT queries.
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: REPLICATION使用户能够读取用于复制的所有数据，但不能用于SELECT查询的消耗。
- en: General administration
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一般管理
- en: The standby is read-only. Any object, including roles, cannot be created only
    on the standby.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备用服务器是只读的。包括角色在内的任何对象都不能仅在备用服务器上创建。
- en: max_wal_senders should be slightly higher than the number of standby servers,
    so that the standby can accept connections after a temporary unexpected disconnection
    while the disconnected walsender still remains.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: max_wal_senders应该略高于备用服务器的数量，这样在临时意外断开连接后，备用服务器仍然保留断开的walsender时，备用服务器可以接受连接。
- en: Backups can be taken on the standby.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份可以在备用服务器上进行。
- en: archive_timeout is not required to reduce the data loss window.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: archive_timeout不需要缩短数据丢失窗口。
- en: Cascading replication reduces the load on the primary.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级联复制减少了主服务器的负载。
- en: WAL on the primary
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主服务器上的WAL
- en: Without any measure, the primary does not care about the standby and remove/recycle
    old WAL files that the standby still need.
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何措施，主服务器不关心备用服务器并删除/回收备用服务器仍然需要的旧WAL文件。
- en: 'If the standby requests WAL that has already been removed, the primary emits
    a message like `"ERROR: requested WAL segment 000000020000000300000041 has already
    been removed"`.'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果备用服务器请求已删除的WAL，则主服务器会发出如下消息：`"ERROR: requested WAL segment 000000020000000300000041
    has already been removed"`。'
- en: To make the primary preserve WAL files, either use a replication slot (preferred)
    or set keep_wal_size (old method).
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使主服务器保留WAL文件，可以使用复制插槽（首选）或设置keep_wal_size（旧方法）。
- en: max_slot_wal_keep_size caps the WAL volume preserved by the replication slot.
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: max_slot_wal_keep_size限制了复制插槽保留的WAL卷。
- en: Synchronous replication
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步复制
- en: The transaction hangs during its commit if no synchronous standby is available.
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有同步备用服务器可用，事务在提交期间会挂起。
- en: To resume the hanging transaction, remove synchronous_standby_names setting
    and reload the configuration. That makes the replication asynchronous.
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要恢复挂起的事务，请移除synchronous_standby_names设置并重新加载配置。这会使复制变为异步。
- en: Causes of replication lag
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 复制延迟的原因
- en: 'Hardware configuration: Server, storage, and network'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件配置：服务器、存储和网络
- en: 'Heavy workload on the primary: The amount of WAL generated on the primary is
    so large that the solo startup process cannot keep up.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主服务器负载过重：主服务器生成的WAL量过大，以至于独立启动进程无法跟上。
- en: Set wal_compression = on to reduce the amount of WAL.
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将wal_compression设置为on以减少WAL的数量。
- en: 'Retrieving WAL from slow archive: The standby could not get WAL from the primary,
    so it has to fetch it from the WAL archive.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从缓慢的归档检索WAL：备机无法从主服务器获取WAL，因此必须从WAL归档中获取。
- en: 'Recovery conflicts: The replay of some operations can be blocked by queries
    running on the standby.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复冲突：某些操作的回放可能会被在备机上运行的查询阻塞。
- en: This is relevant when hot standby is used.
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用热备时，这是相关的。
- en: Reduce max_standby_archive_delay and max_standby_streaming_delay to cancel conflicting
    queries and resume WAL replay early.
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将max_standby_archive_delay和max_standby_streaming_delay减少到取消冲突查询并尽早恢复WAL回放。
- en: Hot standby
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 热备
- en: The ability to run read-only queries while the server is in archive recovery
    or standby mode.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器处于归档恢复或备机模式时运行只读查询的能力。
- en: To determine if the server is in hot standby, use `"SHOW in_hot_standby"` for
    PostgreSQL 14+, or `"SELECT pg_is_in_recovery()"` otherwise.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要确定服务器是否处于热备状态，请使用PostgreSQL 14+的`"SHOW in_hot_standby"`或否则使用`"SELECT pg_is_in_recovery()"`
- en: Recovery conflicts
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复冲突
- en: Conflicts between the WAL replay and queries on the standby.
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL回放与备机上的查询之间的冲突。
- en: Either delay WAL replay or cancel queries.
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟WAL回放或取消查询。
- en: 'Actions on the primary that cause recovery conflicts include:'
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致恢复冲突的主服务器操作包括：
- en: 'Operations that take Access Exclusive locks: DDL, LOCK, file truncation by
    vacuum (including autovacuum)'
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要独占访问锁的操作：DDL、LOCK、通过vacuum进行文件截断（包括自动vacuum）
- en: Access Exclusive lock requests are WAL-logged and replayed by the standby.
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独占访问锁请求通过WAL记录并由备机重放。
- en: Dropping a tablespace where queries put temporary files on the standby
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在备机上放置临时文件的表空间被删除
- en: Dropping a database to which clients are connected on the standby
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除备机上连接的客户端的数据库
- en: Vacuum cleanup of dead tuples that standby transaction still can see according
    to their snapshots
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对备机事务仍然可见的死元组进行vacuum清理，根据它们的快照
- en: Vacuum cleanup of a page on which standby transactions have a buffer pin (e.g.,
    the cursor is positioned on the page.)
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对备机事务有缓冲引用的页面进行vacuum清理（例如，光标位于该页面上。）
- en: What happens upon recovery conflicts
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在恢复冲突发生时会发生什么
- en: WAL application waits for at most the period specified by max_standby_archive_delay
    and max_standby_streaming_delay (except for the replay of DROP DATABASE and ALTER
    DATABASE SET TABLESPACE.)
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL应用程序最多等待由max_standby_archive_delay和max_standby_streaming_delay指定的时间段（除了回放DROP
    DATABASE和ALTER DATABASE SET TABLESPACE之外。）
- en: Then, conflicting sessions are terminated in the case of replaying DROP DATABASE,
    or conflicting queries are canceled in other cases.
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在回放DROP DATABASE时终止冲突会话，或在其他情况下取消冲突查询。
- en: If an idle session holds a lock, the session is also terminated.
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果空闲会话持有锁，则该会话也将被终止。
- en: Monitoring recovery conflicts
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控恢复冲突
- en: '[pg_stat_database_conflicts](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW)
    on the standby shows the number of canceled queries due to each type of recovery
    conflict.'
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_stat_database_conflicts](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW)
    在备机上显示由于每种恢复冲突类型而取消的查询数量。'
- en: '"log_recovery_conflict_waits = on" logs messages that the WAL application has
    waited longer than deadlock_timeout and the wait finished.'
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"log_recovery_conflict_waits = on" 记录WAL应用程序等待时间超过deadlock_timeout并且等待结束的消息。'
- en: '`LOG: recovery still waiting after 1.023 ms: recovery conflict on snapshot`'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOG: recovery still waiting after 1.023 ms: recovery conflict on snapshot`'
- en: '`DETAIL: Conflicting processes: 1234, 1235`'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DETAIL: Conflicting processes: 1234, 1235`'
- en: '`LOG: recovery finished waiting after 3.234 ms: recovery conflict on snapshot`'
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOG: recovery finished waiting after 3.234 ms: recovery conflict on snapshot`'
- en: Minimizing the number of queries cancelled due to recovery conflict
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化由于恢复冲突取消的查询数量
- en: Avoid operations that require Access Exclusive locks. e.g., ALTER TABLE, VACUUM
    FULL, CLUSTER, REINDEX, TRUNCATE
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免需要独占访问锁的操作。例如，ALTER TABLE、VACUUM FULL、CLUSTER、REINDEX、TRUNCATE
- en: Disable file truncation by vacuum by setting vacuum_truncate storage parameter
    on the primary.
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在主服务器上设置vacuum_truncate存储参数来禁用通过vacuum进行的文件截断。
- en: ex. `ALTER TABLE some_table SET (vacuum_truncate = off);`
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ex. `ALTER TABLE some_table SET (vacuum_truncate = off);`
- en: Set hot_standby_feedback = on the standby.
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在备机上设置hot_standby_feedback = on。
- en: sends the oldest XID to the primary, reflected in pg_stat_replication.backend_xmin,
    which is taken into account when vacuum decides to remove a dead tuple.
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将最老的XID发送给主服务器，在pg_stat_replication.backend_xmin中反映，当清理死元组时会考虑这一点。
- en: can incur table bloat because dead tuple removal is delayed.
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能因为延迟清理死元组而导致表膨胀。
- en: cannot prevent all conflicts.
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法阻止所有冲突。
- en: Adjust max_standby_streaming_delay/max_standby_archive_delay on the standby.
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在备机上调整max_standby_streaming_delay/max_standby_archive_delay。
- en: Adjust vacuum_defer_cleanup_age on the primary.
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主服务器上调整vacuum_defer_cleanup_age。
- en: It's ideal to have separate standbys, some for high availability and others
    for read workloads that tolerate stale data.
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好有单独的备机，一些用于高可用性，另一些用于容忍陈旧数据的读工作负载。
- en: Monitoring replication lag
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 监控复制延迟
- en: '[pg_stat_replication](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-VIEW)'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_stat_replication](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-VIEW)'
- en: Available not only on the primary but also on the cascading standby.
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅在主服务器上可用，也在级联备机上可用。
- en: Large differences between pg_current_wal_lsn and the view's sent_lsn field might
    indicate that the primary server is under heavy load.
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_current_wal_lsn和视图的sent_lsn字段之间存在很大差异，可能表明主服务器负载过重。
- en: Differences between sent_lsn and pg_last_wal_receive_lsn on the standby might
    indicate network delay, or that the standby is under heavy load.
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在备机上，sent_lsn和pg_last_wal_receive_lsn之间的差异可能表示网络延迟，或者备机负载过重。
- en: '[pg_stat_wal_receiver](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-WAL-RECEIVER-VIEW)'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_stat_wal_receiver](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-WAL-RECEIVER-VIEW)'
- en: A large difference between pg_last_wal_replay_lsn() and the view's flushed_lsn
    indicates that WAL is being received faster than it can be replayed.
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_last_wal_replay_lsn()和视图的flushed_lsn之间存在很大差异，表明WAL接收速度快于回放速度。
- en: ex. `SELECT pg_wal_lsn_diff(pg_last_wal_replay_lsn(), flushed_lsn) FROM pg_stat_wal_receiver;`
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如。`SELECT pg_wal_lsn_diff(pg_last_wal_replay_lsn(), flushed_lsn) FROM pg_stat_wal_receiver;`
- en: '[pg_stat_wal](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-WAL-VIEW)'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_stat_wal](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-WAL-VIEW)'
- en: Check the amount of WAL generated for heavy write workload.
  id: totrans-505
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查为重写工作负载生成的WAL量。
- en: Storage write latency, IOPs, and throughput to check for heavy write activity.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查存储写入延迟、IOPs和吞吐量，以检查是否存在大量写入活动。
- en: '[pg_stat_database_conflicts](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW)'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_stat_database_conflicts](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW)'
- en: Logical replication
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑复制
- en: Architecture
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 架构
- en: Uses a publish and subscribe model
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用发布和订阅模型
- en: A publication is a collection of tables whose changes are to be replicated.
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布物是要复制其更改的表的集合。
- en: A subscription represents a connection to the publisher and its publications
    to subscribe to.
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅表示连接到发布者及其要订阅的发布物的连接。
- en: One publisher publishes one or more publications.
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个发布者可以发布一个或多个发布物。
- en: One subscriber has one or more subscriptions.
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个订阅者可以有一个或多个订阅。
- en: A publication can have multiple subscribers.
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个发布物可以有多个订阅者。
- en: A subscription can subscribe to multiple publications.
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个订阅可以订阅多个发布物。
- en: Publications can choose to limit the changes they produce to any combination
    of INSERT, UPDATE, DELETE, and TRUNCATE.
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布物可以选择限制它们产生的更改到任何组合的INSERT、UPDATE、DELETE和TRUNCATE。
- en: Publications can restrict the rows and columns to be replicated.
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布物可以限制要复制的行和列。
- en: Processes and data flow
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程和数据流
- en: 'Processes involved: walsender on the publisher, subscription workers (apply
    worker, tablesync worker) on the subscriber.'
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与的进程：发布者上的walsender，订阅者上的订阅工作者（应用工作者、表同步工作者）。
- en: walreceiver does not appear, even though some walreceiver-related parameters
    are used.
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: walreceiver不会出现，即使使用了一些与walreceiver相关的参数。
- en: At the server startup on the subscriber, logical replication launcher is started
    unless max_logical_replication_workers is 0.
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在订阅者的服务器启动时，逻辑复制启动器会启动，除非max_logical_replication_workers为0。
- en: logical replication launcher starts an apply worker for each enabled subscription.
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑复制启动器为每个启用的订阅启动一个应用工作者。
- en: The apply worker connects to the publisher.
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用工作者连接到发布者。
- en: The apply worker launches tablesync workers for tables that have not completed
    initial synchronization. Those tablesync workers each connect to the publisher.
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用工作者为尚未完成初始同步的表启动tablesync工作者。这些tablesync工作者各自连接到发布者。
- en: The publisher spawns a walsender for each connection request from the subscription
    workers.
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布者为每个来自订阅工作者的连接请求生成一个walsender。
- en: The walsender for a tablesync worker sends the initial copy of a table to the
    tablesync worker. (Initial data synchronization/copy)
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: tablesync工作者的发布者为tablesync工作者发送表的初始副本。（初始数据同步/复制）
- en: walsender reads WAL, decodes changes into the logical replication protocol format,
    and store them in the logical decoding work memory and possibly file. When a transaction
    commits, walsender sends its decoded changes to the subscription workers.
  id: totrans-528
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: walsender读取WAL，将更改解码为逻辑复制协议格式，并将它们存储在逻辑解码工作内存和可能的文件中。当事务提交时，walsender将其解码的更改发送给订阅工作者。
- en: The subscription workers apply the received changes.
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅工作者应用接收到的更改。
- en: General administration
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 常规管理
- en: Major restrictions
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要限制
- en: Publications can only contain tables.
  id: totrans-532
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布只能包含表。
- en: DDL are not replicated.
  id: totrans-533
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDL不会被复制。
- en: Add table columns on the subscriber first, then on the publisher. Reverse the
    order when dropping table columns.
  id: totrans-534
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在订阅者上首先添加表列，然后在发布者上添加。删除表列时反转顺序。
- en: Sequence data is not replicated.
  id: totrans-535
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列数据不会被复制。
- en: Replication identity
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制标识
- en: A published table must have a replica identity to replicate UPDATE and DELETE
    operations.
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布的表必须具有复制标识以复制UPDATE和DELETE操作。
- en: Used as a key to identify rows to update or delete on the subscriber.
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用作在订阅者上更新或删除行的标识键。
- en: UPDATE and DELETE fail on the publisher if the published table has no replica
    identity. INSERT succeeds.
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发布表没有复制标识，那么在发布者上UPDATE和DELETE会失败。INSERT会成功。
- en: Can be either of the primary key (by default), unique index, or the full row.
  id: totrans-540
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以是主键（默认）、唯一索引或整行。
- en: Can be configured by `ALTER TABLE REPLICA IDENTITY`.
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`ALTER TABLE REPLICA IDENTITY`进行配置。
- en: The old values of replica identity columns are WAL-logged.
  id: totrans-542
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制标识列的旧值被记录在WAL中。
- en: Tuning performance
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整性能
- en: max_sync_workers_per_subscription
  id: totrans-544
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: max_sync_workers_per_subscription
- en: Multiple tablesync workers (one for each table) will run in parallel based on
    the max_sync_workers_per_subscription configuration.
  id: totrans-545
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于max_sync_workers_per_subscription配置，多个tablesync工作者（每个表一个）将并行运行。
- en: This may be effective to speed up initial table synchronization when there are
    many tables in a subscription.
  id: totrans-546
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个订阅中有许多表时，这可能会有效地加快初始表同步的速度。
- en: logical_decoding_work_mem
  id: totrans-547
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: logical_decoding_work_mem
- en: Check [pg_stat_replication_slots](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-SLOTS-VIEW)
    for spilled transactions to disk. If spill_txns, spill_count, and spill_bytes
    are high, consider increasing this parameter value.
  id: totrans-548
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查[pg_stat_replication_slots](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-SLOTS-VIEW)以查看溢出到磁盘的事务。如果spill_txns、spill_count和spill_bytes很高，请考虑增加此参数值。
- en: Replication conflicts
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 复制冲突
- en: The application of incoming changes on the subscriber may fail due to constraint
    violation or lack of permission. This is the conflict.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于约束违反或缺乏权限，订阅者上传入更改的应用可能会失败。这就是冲突。
- en: 'Resolving conflicts:'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决冲突：
- en: Disable the subscription if it's not yet by running `"ALTER SUBSCRIPTION name
    DISABLE;"`. The subscription can be configured to be automatically disabled when
    any errors are detected by the apply worker. Run `"ALTER SUBSCRIPTION ... WITH
    (disable_on_error = on);"`
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未，请通过运行`"ALTER SUBSCRIPTION name DISABLE;"`来禁用订阅。订阅可以被配置为在应用工作者检测到任何错误时自动禁用。运行`"ALTER
    SUBSCRIPTION ... WITH (disable_on_error = on);"`
- en: Look up the replication origin name and the end LSN of a conflicting transaction
    in the server log.
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器日志中查找冲突事务的复制起点名称和结束LSN。
- en: 'Do either of:'
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下操作之一：
- en: skip the transaction from publisher by running `"ALTER SUBSCRIPTION ... SKIP
    (end LSN of a conflicting transaction)"` or `"SELECT pg_replication_origin_advance(rep_origin_name,
    next LSN of the end of a conflicting transaction)"`
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过运行`"ALTER SUBSCRIPTION ... SKIP (end LSN of a conflicting transaction)"`或`"SELECT
    pg_replication_origin_advance(rep_origin_name, next LSN of the end of a conflicting
    transaction)"`跳过发布者的事务。
- en: fix the table data on the subscriber.
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在订阅者上修复表数据。
- en: Enable the subscription by running `"ALTER SUBSCRIPTION name ENABLE;"`.
  id: totrans-557
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`"ALTER SUBSCRIPTION name ENABLE;"`来启用订阅。
- en: Monitoring
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 监控
- en: Publisher
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者
- en: '[pg_stat_replication_slots](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-SLOTS-VIEW)'
  id: totrans-560
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_stat_replication_slots](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-SLOTS-VIEW)'
- en: One row per logical replication slot. Total number of transactions and amount
    of decoded data, and number of transactions and amount of decoded data that were
    spilled to disk.
  id: totrans-561
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个逻辑复制插槽一行。总事务数和解码数据量，以及溢出到磁盘的事务数和解码数据量。
- en: Other system and statistics views used for streaming replication.
  id: totrans-562
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于流复制的其他系统和统计视图。
- en: Subscriber
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者
- en: '[pg_stat_subscription_stats](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-SUBSCRIPTION-STATS)'
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_stat_subscription_stats](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-SUBSCRIPTION-STATS)'
- en: One row per subscription. Numbers of errors during the initial table synchronization
    and while applying changes.
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个订阅的一行。在初始表同步期间和应用更改时出现的错误数。
- en: '[pg_stat_subscription](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-SUBSCRIPTION)'
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_stat_subscription](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-SUBSCRIPTION)
    监控统计信息'
- en: One row per subscription worker (apply worker, tablesync worker). Table being
    copied, last WAL location sent/reported etc.
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个订阅工作进程（应用程序工作进程，表同步工作进程）的一行。正在复制的表，上次 WAL 位置发送/报告等。
- en: '[pg_subscription_rel](https://www.postgresql.org/docs/current/catalog-pg-subscription-rel.html)'
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_subscription_rel](https://www.postgresql.org/docs/current/catalog-pg-subscription-rel.html)'
- en: One row for each subscribed table. Status of the table to know whether the initial
    synchronization is in progress.
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个订阅表的一行。表的状态，以了解初始同步是否正在进行。
- en: References
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: PostgreSQL Documentation
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 文档
- en: Connection
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 连接
- en: WAL
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: WAL
- en: Transaction
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 事务
- en: Lock
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 锁
- en: Data integrity validation
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 数据完整性验证
- en: Backup and recovery
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 备份和恢复
- en: Streaming replication
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 流复制
- en: Logical replication
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑复制
- en: Security
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Authentication
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证
- en: Encrypt password when changing it
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改密码时加密密码
- en: '`CREATE/ROLE ... PASSWORD ''some_password''` sends and logs the specified password
    as is. Thus, specifying an unencrypted password is dangerous.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE/ROLE ... PASSWORD ''some_password''` 将指定的密码原样发送和记录，因此指定未加密的密码是危险的。'
- en: Those statements accept an encrypted password (hashed with MD5 or SCRAM).
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些语句接受加密密码（使用 MD5 或 SCRAM 哈希）。
- en: psql's \password is convenient
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: psql 的 \password 命令很方便
- en: psql runs `"SHOW password_encryption"` to determine the password hash scheme
    (MD5 or SCRAM), hashes the supplied password, and then issues an ALTER command.
  id: totrans-586
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: psql 运行 `"SHOW password_encryption"` 命令来确定密码哈希方案（MD5 或 SCRAM），对提供的密码进行哈希处理，然后发出
    ALTER 命令。
- en: The hashed password still can appear in the server log. Temporarily setting
    log_min_error_statement to 'PANIC' prevents that.
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希密码仍然可能出现在服务器日志中。临时将 log_min_error_statement 设置为 'PANIC' 可以防止这种情况。
- en: In-database authentication profile is very limited
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库内的认证配置文件功能非常有限
- en: PostgreSQL offers only password expiration by `CREATE/ROLE VALID UNTIL 'some_timestamp'`.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 仅通过 `CREATE/ROLE VALID UNTIL 'some_timestamp'` 提供密码过期功能。
- en: 'Does not provide functionality such as:'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不提供如下功能：
- en: Enforcing password complexity
  id: totrans-591
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制密码复杂性
- en: Locking out a user account when the number of failed login attempts exceeds
    a threshold within a certain period of time
  id: totrans-592
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当某用户在特定时间段内的失败登录尝试次数超过阈值时，锁定该用户账户
- en: Restricting reuse of the same password before a certain number of days pass
  id: totrans-593
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一定天数之前限制重新使用相同的密码
- en: 'Implementing password complexity: use either of:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 实施密码复杂性：使用以下之一：
- en: 'Tracking failed login attempts: Do either of:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪失败的登录尝试：执行以下操作之一：
- en: Search the server log for messages that include "password authentication failed"
    or the SQLSTATE 28P01 (invalid_password)
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索服务器日志以查找包含 "password authentication failed" 或 SQLSTATE 28P01 (invalid_password)
    的消息
- en: Using SQLSTATE is better than the message text, because the message can vary
    depending on the server version and lc_message setting. (Add %e to log_line_prefix
    to emit the SQLSTATE.)
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLSTATE 比消息文本更好，因为消息可能根据服务器版本和 lc_message 设置而变化。（将 %e 添加到 log_line_prefix
    以发出 SQLSTATE。）
- en: '[Trusted Language Extensions for PostgreSQL (pg_tle)](https://github.com/aws/pg_tle)'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PostgreSQL 的 Trusted Language Extensions (pg_tle)](https://github.com/aws/pg_tle)'
- en: The user uses the client authentication hook and creates an extension that records
    and checks login failures.
  id: totrans-599
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用客户端认证钩子并创建记录和检查登录失败的扩展。
- en: Authorization
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授权
- en: Role privileges are inherited by default
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下角色权限会继承
- en: In the SQL standard and other DBMSs, `SET ROLE` needs to be used to gain privileges
    of another role.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SQL 标准和其他 DBMS 中，需要使用 `SET ROLE` 命令以获取另一个角色的权限。
- en: In PostgreSQL, a role automatically inherits the privileges of other roles that
    it is a member of. This might be surprising.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PostgreSQL中，角色会自动继承其所属的其他角色的权限。这可能会让人感到惊讶。
- en: To approximate the SQL standard, use NOINHERIT for users and NOINHERIT for roles.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了逼近SQL标准，对于用户和角色使用NOINHERIT。
- en: Predefined roles
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义角色
- en: Some roles are provided to give part of administrative privileges to non-superusers.
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一些角色，以将部分管理权限授予非超级用户。
- en: They can be given by GRANT.
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以由GRANT给予。
- en: 'The representative roles are:'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表角色是：
- en: 'pg_monitor: can read various useful configuration settings, statistics and
    other system information.'
  id: totrans-609
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_monitor：可以读取各种有用的配置设置、统计信息和其他系统信息。
- en: 'pg_signal_backend: can send signals to other backends to cancel a query or
    terminate a session.'
  id: totrans-610
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_signal_backend：可以向其他后端发送信号以取消查询或终止会话。
- en: 'pg_read_server_files, pg_write_server_files and pg_execute_server_program:
    access files and run programs on the database server as the user the database
    runs as. e.g., these enable COPY data to/from files on the server or another program
    like gzip and curl.'
  id: totrans-611
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_read_server_files、pg_write_server_files和pg_execute_server_program：以数据库运行的用户身份访问文件并在数据库服务器上运行程序。例如，这些使COPY可以在服务器上的文件和另一个程序之间复制数据，如gzip和curl。
- en: Default privileges
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 默认权限
- en: '`ALTER DEFAULT PRIVILEGES` can set the default privileges that will be automatically
    given to database objects created in the future.'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALTER DEFAULT PRIVILEGES`可以设置将自动授予未来创建的数据库对象的默认权限。'
- en: ex. `ALTER DEFAULT PRIVILEGES IN SCHEMA app_schema GRANT INSERT, UPDATE, DELETE,
    SELECT ON TABLES TO app_user;`
  id: totrans-614
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如。`ALTER DEFAULT PRIVILEGES IN SCHEMA app_schema GRANT INSERT, UPDATE, DELETE,
    SELECT ON TABLES TO app_user;`
- en: The target database objects are schema, table, view, sequence, function, and
    type.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标数据库对象是模式、表、视图、序列、函数和类型。
- en: Does not change the privileges of existing database objects.
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会改变现有数据库对象的权限。
- en: References
  id: totrans-617
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考资料
- en: PostgreSQL Documentation
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL文档
- en: '[ The PostgreSQL User Accounthttps://www.postgresql.org/docs/current/postgres-user.html]'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PostgreSQL用户账户](https://www.postgresql.org/docs/current/postgres-user.html)'
- en: '[ Database Roleshttps://www.postgresql.org/docs/current/user-manag.html]'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库角色](https://www.postgresql.org/docs/current/user-manag.html)'
- en: '[ Client Authenticationhttps://www.postgresql.org/docs/current/client-authentication.html]'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[客户端身份验证](https://www.postgresql.org/docs/current/client-authentication.html)'
- en: '[ Privilegeshttps://www.postgresql.org/docs/current/ddl-priv.html]'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[权限](https://www.postgresql.org/docs/current/ddl-priv.html)'
- en: '[ Row Security Policieshttps://www.postgresql.org/docs/current/ddl-rowsecurity.html]'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[行安全策略](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)'
- en: '[ Encryption Optionshttps://www.postgresql.org/docs/current/encryption-options.html]'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[加密选项](https://www.postgresql.org/docs/current/encryption-options.html)'
- en: '[ Secure TCP/IP Connections with SSLhttps://www.postgresql.org/docs/current/ssl-tcp.html]'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SSL安全TCP/IP连接](https://www.postgresql.org/docs/current/ssl-tcp.html)'
- en: '[ Secure TCP/IP Connections with GSSAPI Encryptionhttps://www.postgresql.org/docs/current/gssapi-enc.html]'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用GSSAPI加密的安全TCP/IP连接](https://www.postgresql.org/docs/current/gssapi-enc.html)'
- en: Authentication
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证
- en: Authorization
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 授权
- en: Hiding data
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏数据
- en: Manageability
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可管理性
- en: Memory
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存
- en: A large result set causes out of memory on the client
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 大型结果集导致客户端内存耗尽
- en: When running SELECT, psql retrieves the entire result set and stores all rows
    in the client memory.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行SELECT时，psql检索整个结果集并将所有行存储在客户端内存中。
- en: With the FETCH_COUNT variable like `"psql -v FETCH_COUNT=100 ..."`, psql uses
    a cursor and issues DECLARE, FETCH, and CLOSE to retrieve the result set piecemeal.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FETCH_COUNT变量，例如`"psql -v FETCH_COUNT=100 ..."`，psql使用游标并发出DECLARE、FETCH和CLOSE以逐步检索结果集。
- en: Client drivers have similar facility, such as psqlODBC's UseDeclareFetch and
    PgJDBC's defaultRowFetchSize connection parameter.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端驱动程序具有类似的功能，例如psqlODBC的UseDeclareFetch和PgJDBC的defaultRowFetchSize连接参数。
- en: Common causes of server-side out of memory (OOM) issues
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端内存不足（OOM）问题的常见原因
- en: A high number of connections
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高数量的连接
- en: Even idle connections could continue to hold much memory. PostgreSQL keeps database
    object metadata in memory during the session. This is for performance. You can
    notice this by bloated CacheMemoryContext.
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使空闲连接也可能继续占用大量内存。PostgreSQL在会话期间将数据库对象元数据保留在内存中。这是为了性能。您可以通过庞大的CacheMemoryContext来注意到这一点。
- en: If connection pooling is used, many connections may consume large amounts of
    memory over time. This is because connections are picked up randomly from the
    pool, used to access some relations, and released back to the pool, which results
    in many sessions accumulating the meta data of many relations.
  id: totrans-639
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用连接池，许多连接随着时间的推移可能会消耗大量内存。这是因为连接是随机从池中选取的，用于访问某些关系，然后释放回池中，这导致许多会话积累了许多关系的元数据。
- en: A high value of work_mem
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高的work_mem值
- en: It's advised not to set a high value to work_mem at an instance level (postgresql.conf)
    or a database level (ALTER DATABASE). Many sessions could allocate that amount
    of memory simultaneously. What's worse, each SQL statement could run such sort
    and/or hash operations in parallel, each of which can allocate as much memory
    as work_mem.
  id: totrans-641
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议不要在实例级别（postgresql.conf）或数据库级别（ALTER DATABASE）设置高值的work_mem。许多会话可能同时分配那么多内存。更糟糕的是，每个SQL语句可能会并行运行这样的排序和/或哈希操作，其中每个操作可以分配与work_mem一样多的内存。
- en: For a hash-based operation, work_mem * hash_mem_multiplier bytes of work memory
    will be allocated at maximum.
  id: totrans-642
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于哈希的操作，最多将分配work_mem * hash_mem_multiplier字节的工作内存。
- en: Low max_locks_per_transaction
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低的max_locks_per_transaction值
- en: Each lockable object (e.g., table, index, sequence, XID, but not row) is allocated
    an entry in the lock table when it's locked. The entry represents the lockable
    object, grantees, waiters, and granted/requested lock modes.
  id: totrans-644
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个可锁定对象（例如，表、索引、序列、XID，但不是行）在锁定时都会在锁表中分配一个条目。该条目表示可锁定对象、授予者、等待者和授予/请求的锁模式。
- en: The lock table is allocated in shared memory. Its size is fixed at server startup.
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁表分配在共享内存中。其大小在服务器启动时固定。
- en: The default value of max_locks_per_transaction is 64\. This means that each
    transaction is expected to lock 64 or fewer objects.
  id: totrans-646
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: max_locks_per_transaction的默认值为64。这意味着每个事务预计将锁定64个或更少的对象。
- en: The number of entries in the lock table is (max_connections + max_prepared_transactions
    + alpha) * max_locks_per_transaction.
  id: totrans-647
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁表中的条目数为（max_connections + max_prepared_transactions + alpha）* max_locks_per_transaction。
- en: One transaction can use more than max_locks_per_transaction entries, if those
    are available.
  id: totrans-648
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可用的话，一个事务可以使用超过max_locks_per_transaction条目。
- en: If each of many concurrent transactions may access more objects, say, touch
    hundreds or thousands of partitions, increase max_locks_per_transaction.
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果许多并发事务中的每个事务可能会访问更多对象，例如，触及数百或数千个分区，请增加max_locks_per_transaction。
- en: Cannot retrieve a large bytea value
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 无法检索大的bytea值
- en: For example, after successfully inserting 550 MB of bytea column value, fetching
    it fails with an error message like `"invalid memory aloc request size 1277232195"`.
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，成功插入550 MB的bytea列值后，抓取失败，并显示类似于“"invalid memory aloc request size 1277232195"”的错误消息。
- en: Why?
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么？
- en: When the PostgreSQL server sends query results to the client, it either converts
    the data to text format or returns it in binary format.
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当PostgreSQL服务器将查询结果发送给客户端时，它会将数据转换为文本格式或以二进制格式返回。
- en: psql and client drivers instruct the server to use text format.
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: psql和客户端驱动程序指示服务器使用文本格式。
- en: '[PostgreSQL uses either hex or escape format](https://www.postgresql.org/docs/current/datatype-binary.html)
    when it converts bytea data to text format. The default format is hex. hex and
    escape formats use 2 and 4 bytes respectively to represent each original byte
    in text format.'
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[当将bytea数据转换为文本格式时，PostgreSQL使用十六进制或转义格式](https://www.postgresql.org/docs/current/datatype-binary.html)。默认格式为十六进制。十六进制和转义格式分别使用2和4个字节来表示文本格式中的每个原始字节。'
- en: ex. `SELECT 'abc'::bytea;` returns `\x616263`
  id: totrans-656
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如。`SELECT 'abc'::bytea;` 返回`\x616263`
- en: The PostgreSQL server allocates one contiguous memory area to convert each column
    value to text format. This allocation size is limited to 1 GB - 1\. That restriction
    has something to do with the handling of variable-length data types in TOAST.
  id: totrans-657
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL服务器为将每个列值转换为文本格式分配一个连续的内存区域。此分配大小限制为1 GB - 1。这个限制与TOAST中的可变长度数据类型的处理有关。
- en: Due to this limitation, PostgreSQL cannot return bytea data over 500 MB in text
    format.
  id: totrans-658
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这个限制，PostgreSQL无法以文本格式返回超过500 MB的bytea数据。
- en: Storage
  id: totrans-659
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储
- en: Common causes of full storage
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 全存储的常见原因
- en: 'Table bloat because vacuum cannot remove dead tuples: the reasons dead tuples
    remain are described separately.'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表膨胀是因为清理程序无法移除死元组：死元组保留的原因另行描述。
- en: 'WAL accumulation: the reasons WAL volume continues to grow are described separately.'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL积累：WAL容量持续增长的原因另行描述。
- en: Server log files
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器日志文件
- en: Excessive logging because of pgAudit, auto_explain, and other logging parameters
    such as log_statement and log_min_duration_statement
  id: totrans-664
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为pgAudit、auto_explain和其他日志参数（如log_statement和log_min_duration_statement）而导致过多的日志记录
- en: 'Log rotation and purge are not configured properly: log_rotation_age, log_rotation_size,
    log_truncate_on_rotation'
  id: totrans-665
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志轮换和清除未正确配置：log_rotation_age、log_rotation_size、log_truncate_on_rotation
- en: Temporary files are created
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建临时文件
- en: The work_mem is small and/or the query plan is bad.
  id: totrans-667
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: work_mem较小和/或查询计划不佳。
- en: A holdable cursor is kept open.
  id: totrans-668
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持可保持的游标打开。
- en: e.g. `DECLARE CURSOR cur WITH HOLD FOR SELECT * FROM mytable; COMMIT;`
  id: totrans-669
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如 `DECLARE CURSOR cur WITH HOLD FOR SELECT * FROM mytable; COMMIT;`
- en: During the commit, the result set of the holdable cursor is stored in a work
    memory area of size work_mem, and the content beyond work_mem is spilled to a
    temporary file.
  id: totrans-670
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提交期间，可保持游标的结果集存储在大小为work_mem的工作内存区域中，并将超出work_mem的内容溢出到临时文件中。
- en: 'Check temporary file usage with:'
  id: totrans-671
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令检查临时文件的使用情况：
- en: temp_files and temp_bytes of pg_stat_database
  id: totrans-672
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_stat_database的temp_files和temp_bytes
- en: log_temp_files = on, which logs the file path and size when the file is deleted
  id: totrans-673
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: log_temp_files = on，当删除文件时记录文件路径和大小
- en: query plans obtained by EXPLAIN ANALYZE or auto_explain
  id: totrans-674
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过EXPLAIN ANALYZE或auto_explain获得的查询计划
- en: Storage quota
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 存储配额
- en: PostgreSQL cannot constrain storage usage except for temporary files.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL除了临时文件外无法限制存储使用。
- en: temp_file_limit can limit the total size of temporary files used by each session
    at any instant. A transaction exceeding this limit will be aborted.
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: temp_file_limit可以限制每个会话在任何时刻使用的临时文件的总大小。超过此限制的事务将被中止。
- en: If you want to limit the size of a database, table, or WAL ($PGDATA/pg_wal/),
    put it in a tablespace on a file system with limited size.
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要限制数据库、表或WAL（$PGDATA/pg_wal/）的大小，请将其放入具有有限大小的文件系统上的表空间中。
- en: The tablespace of a database/table can be specified explicitly by `CREATE/ALTER
    DATABASE/TABLE ... TABLESPACE`, or implicitly by the default_tablespace parameter.
  id: totrans-679
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`CREATE/ALTER DATABASE/TABLE ... TABLESPACE`显式指定数据库/表的表空间，也可以通过default_tablespace参数隐式指定。
- en: temp_tablespaces can be used to specify where temporary files are created for
    temporary tables/indexes and sort/hash operations.
  id: totrans-680
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: temp_tablespaces可用于指定为临时表/索引和排序/散列操作创建临时文件的位置。
- en: WAL directory can be specified by initdb's --waldir option. Also, after the
    database cluster has been created, it can be moved outside the data directory
    and linked with a symbolic link.
  id: totrans-681
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL目录可以通过initdb的--waldir选项指定。另外，在创建数据库集群后，可以将其移动到数据目录外并使用符号链接进行链接。
- en: Logging and debugging
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录和调试
- en: '`FATAL: database is starting up`'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '`FATAL: database is starting up`'
- en: In old major versions, this message can be output at 1 second intervals during
    the server startup.
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在旧的主要版本中，此消息可能在服务器启动期间每秒输出一次。
- en: This may look startling, but it's not an actual problem.
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能看起来令人震惊，但这并不是实际问题。
- en: '"Why? pg_ctl start" launches postmaster in the background, and tries to connect
    to the database at 1 second intervals. If the connection is successful, pg_ctl
    returns success. Otherwise, if the server is still performing recovery and unable
    to accept connections, the above message is reported.'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “为什么？pg_ctl start”在后台启动postmaster，并尝试在1秒间隔内连接到数据库。如果连接成功，pg_ctl将返回成功。否则，如果服务器仍在执行恢复且无法接受连接，则报告以上消息。
- en: In newer major versions, you won't see the message any more. pg_ctl does not
    attempt connection. Instead, postmaster writes "ready" in postmaster.pid when
    it can accept connections, and pg_ctl checks it.
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在较新的主要版本中，您将不再看到此消息。 pg_ctl不会尝试连接。相反，当postmaster可以接受连接时，postmaster在postmaster.pid中写入“ready”，并且pg_ctl对其进行检查。
- en: Avoid excessive logging by restricting targets
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 避免通过限制目标来避免过多的记录。
- en: 'Not only logging but many parameters can be configured for each user, database,
    or the combination of them. For example:'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅可以为每个用户、数据库或它们的组合配置日志记录，还可以配置许多其他参数。例如：
- en: '`ALTER USER oltp_user SET log_min_duration_statement = ''3s'';`'
  id: totrans-690
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALTER USER oltp_user SET log_min_duration_statement = ''3s'';`'
- en: '`ALTER DATABASE analytics_db SET log_min_duration_statement = ''60s'';`'
  id: totrans-691
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALTER DATABASE analytics_db SET log_min_duration_statement = ''60s'';`'
- en: '`ALTER USER batch_user IN DATABASE oltp_db SET log_min_duration_statement =
    ''30s'';`'
  id: totrans-692
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALTER USER batch_user IN DATABASE oltp_db SET log_min_duration_statement =
    ''30s'';`'
- en: Debug-logging can be enabled for a session without cluttering the server log
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为会话启用调试日志记录，而不会使服务器日志混乱
- en: It may not be acceptable to globally set log_min_messages to DEBUG1 - DEBUG5,
    because that would output voluminous logs.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能不可接受将log_min_messages全局设置为DEBUG1 - DEBUG5，因为那样会输出大量日志。
- en: 'You can obtain debug messages for a particular operation only on the client
    like this:'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以像这样在客户端仅获取特定操作的调试消息：
- en: '`export PGOPTIONS="-c client_min_messages=DEBUG5"`'
  id: totrans-696
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export PGOPTIONS="-c client_min_messages=DEBUG5"`'
- en: '`psql -d postgres -c "select 1"`'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '`psql -d postgres -c "select 1"`'
- en: Find out what psql's backslash commands do
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚psql的反斜杠命令的作用
- en: Use psql's -E/--echo-hidden option. It reveals the query issued in the background.
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用psql的-E/--echo-hidden选项。它会显示后台发出的查询。
- en: Deleting duplicate rows
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 删除重复行
- en: The following query deletes duplicate rows, leaving the one with the minimum
    ctid and displays the deleted row content.
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下查询删除重复行，仅保留最小ctid的行并显示已删除的行内容。
- en: 'ctid is a system column that represents the physical location of the row version
    within its table: (block number, item ID). ctid can change due to UPDATE and VACUUM
    FULL, so it''d be probably safe to lock the table in Share or stronger mode during
    this operation.'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ctid是一个系统列，表示行版本在其表内的物理位置：（块编号，项ID）。由于UPDATE和VACUUM FULL，ctid可能会改变，因此在此操作期间锁定表可能是安全的。
- en: '[PRE0]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Vacuum
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理
- en: Purposes of vacuum
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 清理的目的
- en: To recover or reuse disk space occupied by updated or deleted rows.
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了回收或重用由更新或删除行占用的磁盘空间。
- en: To update data statistics used by the PostgreSQL query planner.
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更新PostgreSQL查询规划器使用的数据统计信息。
- en: To update the visibility map, which speeds up index-only scans.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更新可见性图，从而加速仅索引扫描。
- en: To protect against loss of very old data due to transaction ID wraparound or
    multixact ID wraparound.
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为防止由于事务ID环绕或多事务ID环绕而导致的非常旧数据的丢失。
- en: Vacuum types
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 清理类型
- en: Concurrent (lazy, or regular) vacuum
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发（惰性或常规）清理
- en: Acquires a Share Update Exclusive lock on the target relation. Does not prevent
    SELECT and DML commands.
  id: totrans-712
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标关系上获取共享更新独占锁。不会阻止SELECT和DML命令。
- en: Keeps the original data files and modifies them. TIDs do not change.
  id: totrans-713
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留原始数据文件并对其进行修改。TIDs不会改变。
- en: The data file shrinks only when there are more than certain number of contiguous
    empty blocks at the end. Unused space in the middle of the file is left for reuse.
  id: totrans-714
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当末尾有一定数量的连续空块时，数据文件才会收缩。文件中间未使用的空间留作重用。
- en: Reports its progress in the pg_stat_progress_vacuum view.
  id: totrans-715
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在pg_stat_progress_vacuum视图中报告其进度。
- en: FULL vacuum
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全量清理
- en: Acquires an Access Exclusive lock on the target relation. Prevents SELECT and
    DML commands.
  id: totrans-717
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标关系上获取独占访问锁。阻止SELECT和DML命令。
- en: Copies live tuples from the old data files to new data files, and remove old
    data files. Rebuilds indexes. TIDs change.
  id: totrans-718
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将活跃元组从旧数据文件复制到新数据文件，并删除旧数据文件。重建索引。TIDs会改变。
- en: The data files will be packed fully and minimal.
  id: totrans-719
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据文件将被完全和最小地打包。
- en: 'Could uses twice the disk space: one for existing relations, and another for
    new ones.'
  id: totrans-720
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会使用两倍的磁盘空间：一个用于现有关系，另一个用于新关系。
- en: Always aggressively freezes tuples.
  id: totrans-721
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是积极地冻结元组。
- en: The actual processing is the same as CLUSTER.
  id: totrans-722
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际处理与CLUSTER相同。
- en: Reports its progress in the pg_stat_progress_cluster view.
  id: totrans-723
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在pg_stat_progress_cluster视图中报告其进度。
- en: Autovacuum never runs FULL vacuum.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动清理永远不会运行全量清理。
- en: Main steps of vacuum
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 清理的主要步骤
- en: Starts a transaction.
  id: totrans-726
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个事务。
- en: When there are multiple target relations, vacuum starts and commits a transaction
    for each relation to release locks as soon as possible.
  id: totrans-727
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当存在多个目标关系时，清理会为每个关系启动并提交一个事务，以尽快释放锁。
- en: Gets an Share Update Exclusive lock for a heap and opens it. Non-wrap-around-prevention
    vacuum gives up vacuuming the relation if the relation cannot get the lock, emitting
    the following message.
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取堆的共享更新独占锁并打开它。如果关系无法获取锁，不可逆转的清理会放弃对关系的清理，发出以下消息。
- en: '`LOG: skipping of vacuum "rel_name" --- lock not available`'
  id: totrans-729
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOG: 跳过了vacuum "rel_name" --- 锁不可用`'
- en: Gets Row Exclusive locks for the indexes and opens them.
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取索引的行独占锁并打开它们。
- en: Allocates the work memory to accumulate the TIDs of dead tuples.
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配工作内存以累积死元组的TIDs。
- en: 'Repeats the following steps until the entire heap has been processed:'
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直到整个堆被处理完为止，重复执行以下步骤：
- en: 'Scans the heap: Accumulates dead tuple TIDs in the work memory until it gets
    full or the end of the heap is reached. The item IDs for the dead tuples are retained.
    Also, prunes and defragments each page if required, and possibly freezes live
    tuples.'
  id: totrans-733
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描堆：在工作内存中累积死元组TIDs，直到工作内存满或达到堆的末尾。保留死元组的项ID。此外，如果需要，修剪和重组每个页面，并可能冻结活元组。
- en: 'Vacuums the indexes: Delete index entries that contain dead tuple TIDs.'
  id: totrans-734
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理索引：删除包含死元组TID的索引条目。
- en: 'Vacuums the heap: Reclaims the item IDs for the dead tuples. This is done here,
    not while scanning the heap, because the item ID cannot be freed until the index
    entries pointing to it have been deleted.'
  id: totrans-735
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对堆进行清理：回收死元组的项目ID。这是在这里完成的，而不是在扫描堆时完成的，因为直到指向它的索引条目被删除之后，项目ID才能被释放。
- en: Updates the FSM and VM during the above processing.
  id: totrans-736
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上述处理过程中更新FSM和VM。
- en: Cleans up the indexes.
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理索引。
- en: Updates every index's stats in pg_class's relpages and reltuples.
  id: totrans-738
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新pg_class的relpages和reltuples中每个索引的统计信息。
- en: Closes the indexes but retains their locks until transaction end.
  id: totrans-739
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭索引，但保留它们的锁直到事务结束。
- en: Truncate the heap so as to return empty pages at the end of the relation to
    the operating system.
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 截断堆，以便将关系末尾的空页面返回给操作系统。
- en: The data file is truncated if the heap has at least the lesser of 1,000 blocks
    and (relation_size / 16) contiguous empty blocks at its end.
  id: totrans-741
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果堆至少具有1,000个块和（relation_size / 16）个连续空块，那么数据文件将被截断。
- en: Takes an Access Exclusive lock on the heap. If another transaction holds a conflicting
    lock, wait for at most 5 seconds. If the lock cannot be obtained, gives up truncating.
  id: totrans-742
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆上获取访问独占锁。如果另一个事务持有冲突的锁，则最多等待5秒。如果无法获得锁，则放弃截断。
- en: Scans backwards the heap to verify that the end pages are still empty. Periodically
    checks if another transaction is waiting for a conflicting lock. If someone else
    is waiting, releases the Access Exclusive lock and gives up truncating.
  id: totrans-743
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向后扫描堆以验证末尾页面仍然为空。定期检查是否有另一个事务正在等待冲突的锁。如果有其他人在等待，释放访问独占锁并放弃截断。
- en: Updates relation stats.
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新关系统计信息。
- en: Updates pg_class's relpages, reltuples, relallvisible, relhasindex, relhasrules,
    relhastriggers, relfrozenxid, and relminmxid.
  id: totrans-745
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新pg_class的relpages、reltuples、relallvisible、relhasindex、relhasrules、relhastriggers、relfrozenxid和relminmxid。
- en: Close the relation.
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭关系。
- en: Commits a transaction.
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交事务。
- en: Vacuums the relation's TOAST table.
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对关系的TOAST表进行清理。
- en: Repeats the above processing for each relation.
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个关系重复上述处理过程。
- en: Updates database stats.
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新数据库统计信息。
- en: Updates pg_database.datfrozenxid to be the minimum of pg_class.relfrozenxid
    values, and truncates commit log in pg_xact/.
  id: totrans-751
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将pg_database.datfrozenxid更新为pg_class.relfrozenxid值的最小值，并在pg_xact/中截断提交日志。
- en: Updates pg_database.datminmxid to be the minimum of pg_class.relminmxid values,
    and truncates MultiXact data in pg_multixact/.
  id: totrans-752
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将pg_database.datminmxid更新为pg_class.relminmxid值的最小值，并在pg_multixact/中截断MultiXact数据。
- en: Autovacuum is designed to be non-intrusive
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: Autovacuum设计为非侵入式。
- en: Autovacuum takes a rest (sleep) every time it has done a certain amount of work.
    Therefore, it does not continuously consume resources.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autovacuum每完成一定量的工作就休息（睡眠）一次。因此，它不会持续消耗资源。
- en: '"A certain amount of work" and the sleep time can be configured by autovacuum_vacuum_cost_limit
    and autovacuum_vacuum_cost_delay respectively. autovacuum_vacuum_cost_delay is
    2 ms by default.'
  id: totrans-755
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “一定量的工作”和休眠时间可以通过autovacuum_vacuum_cost_limit和autovacuum_vacuum_cost_delay进行配置。autovacuum_vacuum_cost_delay默认为2毫秒。
- en: Autovacuum skips the relation if it cannot get a lock on it due to some conflicting
    lock. Wrap-around-prevention autovacuum does not do this.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由于某些冲突的锁而无法锁定关系，则Autovacuum跳过该关系。回绕防止自动真空不会执行此操作。
- en: 'A concurrent transaction cancels non-aggressive autovacuum, if it has waited
    on a conflicting relation lock for deadlock_timeout seconds and found out that
    the lock is held by autovacuum. These messages can be seen:'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果并发事务在等待冲突的关系锁并且发现该锁被Autovacuum持有，则取消非侵入式autovacuum。可以看到这些消息：
- en: '`ERROR: canceling autovacuum task`'
  id: totrans-758
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR: canceling autovacuum task`'
- en: '`DETAIL: automatic vacuum of table "mytable"`'
  id: totrans-759
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DETAIL: automatic vacuum of table "mytable"`'
- en: Vacuum skips reading data pages if VM shows that they have only tuples visible
    to all transactions (all-visible bit is set in VM). Aggressive vacuum reads even
    such pages to freeze tuples.
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果VM显示数据页仅具有对所有事务可见的元组（VM中设置了all-visible位），则VACUUM跳过读取数据页。即使是这样的页面，Aggressive
    vacuum也会读取以冻结元组。
- en: Vacuum skips reading data pages if VM shows that they have only frozen tuples
    (all-frozen bit is set in VM).
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果VM显示数据页仅具有冻结元组（VM中设置了all-frozen位），则VACUUM跳过读取数据页。
- en: Autovacuum performs reduced work on a data page when it cannot get an exclusive
    LWLock on it. Autovacuum for wrap-around does not do this.
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当无法在数据页上获得独占LWLock时，Autovacuum对数据页执行减少的工作。对于回绕，Autovacuum不会执行此操作。
- en: Vacuum gives up truncating the relation if another transaction holds or is waiting
    for a lock on the target relation.
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果另一个事务持有或等待对目标关系的锁，则VACUUM放弃截断关系。
- en: Autovacuum is not run against a relation
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 自动清理未针对一个关系运行
- en: Check the following to see if that is the case.
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查以下情况是否存在。
- en: last_autovacuum and autovacuum_count columns of pg_stat_all_tables
  id: totrans-766
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_stat_all_tables 的 last_autovacuum 和 autovacuum_count 列
- en: Server logs after setting log_autovacuum_min_duration to 0
  id: totrans-767
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 log_autovacuum_min_duration 设置为 0 后的服务器日志
- en: Common reasons
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见原因
- en: The relation has to be eligible for autovacuum.
  id: totrans-769
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系必须符合自动清理的条件。
- en: 'UPDATE/DELETE-mostly relations: updated/deleted tuples >= autovacuum_vacuum_threshold
    + autovacuum_vacuum_scale_factor * pg_class.reltuples'
  id: totrans-770
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UPDATE/DELETE 多的关系：更新/删除的元组 >= autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor
    * pg_class.reltuples
- en: 'INSERT-mostly relations: inserted tuples >= autovacuum_vacuum_insert_threshold
    + autovacuum_vacuum_insert_scale_factor * pg_class.reltuples'
  id: totrans-771
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: INSERT 多的关系：插入的元组 >= autovacuum_vacuum_insert_threshold + autovacuum_vacuum_insert_scale_factor
    * pg_class.reltuples
- en: Autovacuum workers are busy with other many and/or large relations.
  id: totrans-772
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动清理工作者忙于其他许多和/或大型关系。
- en: Some transactions continuously request or hold a conflicting relation lock for
    long. Non-wrap-around-prevention vacuum gives up such a relation.
  id: totrans-773
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些事务持续请求或长时间持有冲突的关系锁。不带环绕预防的清理操作会放弃这样的关系。
- en: Autovacuum cannot vacuum temporary tables. Manual vacuum needs to be run. This
    might lead to XID wrap-around and database shutdown.
  id: totrans-774
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动清理无法清理临时表。需要手动运行清理。这可能导致 XID 环绕和数据库关闭。
- en: Statistics stored in pg_stat/ were lost due to crash or archive recovery, including
    failover. Those statistics are always reset during recovery. Autovacuum depends
    on the statistics, which can be seen via pg_stat_all_tables, to determine if vacuuming
    is needed.
  id: totrans-775
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在 pg_stat/ 中的统计数据由于崩溃或存档恢复（包括故障转移）而丢失。这些统计数据在恢复期间总是被重置。自动清理依赖于统计数据，可以通过 pg_stat_all_tables
    看到，以确定是否需要清理。
- en: Why vacuum does not remove dead tuples
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么清理操作不会移除死元组
- en: Slow autovacuum
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动清理缓慢
- en: Long-running transactions
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时间长的事务
- en: Physical standbys with hot_standby_feedback = on
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有 hot_standby_feedback = on 的物理备用
- en: Unused replication slots
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未使用的复制槽
- en: Orphaned prepared transactions
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孤立的预备事务
- en: Reducing the risk of XID wrap-around
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 减少 XID 环绕的风险
- en: Reduce XID consumption.
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少 XID 的消耗。
- en: Each subtransaction allocates its own XID. A subtransaction is started by SAVEPOINT
    and PL/pgSQL's exception block (BEGIN ... EXCEPTION).
  id: totrans-784
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个子事务都分配了自己的 XID。子事务由 SAVEPOINT 和 PL/pgSQL 的异常块（BEGIN ... EXCEPTION）启动。
- en: Some client drivers offer statement-level rollback. It encloses each SQL statement
    with SAVEPOINT and RELEASE SAVEPOINT.
  id: totrans-785
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些客户端驱动程序提供了语句级别的回滚。它会将每个 SQL 语句用 SAVEPOINT 和 RELEASE SAVEPOINT 包围起来。
- en: Make autovacuum run smoothly (see above).
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让自动清理顺利运行（见上文）。
- en: Lower autovacuum_vacuum_insert_scale_factor (PostgreSQL 13+) or autovacuum_freeze_max_age
    so that autovacuum processes the table more frequently.
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低 autovacuum_vacuum_insert_scale_factor（PostgreSQL 13+）或 autovacuum_freeze_max_age，以便自动清理更频繁地处理表。
- en: Schedule regular VACUUM FREEZE runs.
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期安排 VACUUM FREEZE 运行。
- en: Configuration to speed up autovacuum
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 加速自动清理的配置
- en: Lower autovacuum_vacuum_threshold, autovacuum_vacuum_scale_factor, autovacuum_vacuum_insert_threshold,
    autovacuum_vacuum_insert_scale_factor for large tables.
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为大型表降低 autovacuum_vacuum_threshold、autovacuum_vacuum_scale_factor、autovacuum_vacuum_insert_threshold、autovacuum_vacuum_insert_scale_factor。
- en: Decrease autovacuum_naptime
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少 autovacuum_naptime
- en: Even 1s is practical if the write workload is heavy and the host has many CPU
    cores.
  id: totrans-792
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使写入工作负载繁重，主机具有许多 CPU 核心，1 秒也是实用的。
- en: Increase autovacuum_max_workers
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加 autovacuum_max_workers
- en: Effective when there are many relations. Each relation is handled by only one
    autovacuum worker.
  id: totrans-794
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有许多关系的情况下效果更好。每个关系只由一个自动清理工作者处理。
- en: Increase autovacuum_vacuum_cost_limit as well. Otherwise, each autovacuum worker
    would sleep more frequently, because cost limits are shared among all active autovacuum
    workers.
  id: totrans-795
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样要增加 autovacuum_vacuum_cost_limit。否则，每个自动清理工作者都会更频繁地休眠，因为成本限制是所有活动自动清理工作者共享的。
- en: Increase maintenance_work_mem/autovacuum_work_mem
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加 maintenance_work_mem/autovacuum_work_mem
- en: The work memory stores an array of dead tuple TIDs. A TID is (block no, item
    no), which is 6 bytes.
  id: totrans-797
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作内存存储着一组死元组的 TID 数组。TID 是 (块编号, 项编号)，大小为 6 个字节。
- en: Setting a large value reduces the number of index scans.
  id: totrans-798
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置大的值可以减少索引扫描次数。
- en: The maximum allocated size is 1 GB - 1 no matter how large the parameter values
    are.
  id: totrans-799
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大分配大小为 1 GB - 1，无论参数值有多大。
- en: Does not always allocate the specified size. The actual size is large enough
    to accommodate all possible TIDs, so it will be small for small tables.
  id: totrans-800
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不总是分配指定大小。实际大小足以容纳所有可能的 TID，因此对于小表来说，它会很小。
- en: For a table with no index, only less than 2 KB is allocated. Vacuum only accumulates
    TIDs for one table block because it does not need to scan indexes.
  id: totrans-801
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于没有索引的表，只分配少于 2 KB。Vacuum 仅累积一个表块的 TID，因为它不需要扫描索引。
- en: Increase vacuum_buffer_usage_limit
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加 vacuum_buffer_usage_limit。
- en: Vacuum uses 256 KB of ring buffers by default to cache data pages, so that it
    does not evict pages that are likely to be used by applications.
  id: totrans-803
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Vacuum 使用 256 KB 的环形缓冲区来缓存数据页面，以便不驱逐应用程序可能使用的页面。
- en: 'Vacuum also benefits from caching pages: heap pages are read twice, and index
    pages may possibly be read more than once.'
  id: totrans-804
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vacuum 也受益于缓存页面：堆页面被读取两次，索引页面可能被多次读取。
- en: Setting this to 0 allows vacuum to use shared buffers without limit.
  id: totrans-805
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此设置为 0 允许 vacuum 无限制地使用共享缓冲区。
- en: Decrease autovacuum_vacuum_cost_delay, increase autovacuum_vacuum_cost_limit
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少 autovacuum_vacuum_cost_delay，增加 autovacuum_vacuum_cost_limit。
- en: Setting autovacuum_vacuum_cost_delay to 0, which keeps autovacuum running like
    the manual vacuum.
  id: totrans-807
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 autovacuum_vacuum_cost_delay 设置为 0，这样可以使 autovacuum 运行类似于手动 vacuum。
- en: Partition a large table so that multiple autovacuum workers can work on its
    partitions concurrently.
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对一个大表进行分区，以便多个 autovacuum 工作者可以同时处理其分区。
- en: Delete unnecessary indexes.
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除不必要的索引。
- en: Autovacuum processes indexes one at a time. (Manual vacuum can process them
    in parallel with its PARALLEL option.)
  id: totrans-810
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autovacuum 一次处理一个索引。（手动 vacuum 可以使用其 PARALLEL 选项并行处理它们。）
- en: Upgrade
  id: totrans-811
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级。
- en: Characteristics of versions
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 版本的特征。
- en: Major version
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要版本。
- en: Contains new features and incompatibilities.
  id: totrans-814
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含新功能和不兼容性。
- en: Released once a year.
  id: totrans-815
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每年发布一次。
- en: Sensitive bug fixes are only incorporated into the latest major version. "Sensitive"
    includes the fixes that could lead to incompatibility, adverse effects such as
    unstability and security, or require lots of code changes not worth the benefit.
  id: totrans-816
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感的错误修复仅合并到最新的主要版本中。“敏感”包括可能导致不兼容性、不稳定性和安全性问题或需要大量代码更改但价值不大的修复。
- en: The upgrade can skip intervening major versions. e.g., version 11 can be upgraded
    to 16 without going through 12 to 15.
  id: totrans-817
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级可以跳过中间的主要版本。例如，版本 11 可以直接升级到 16，而不需要经过 12 到 15。
- en: Always requires careful planning and testing to deal with incompatible changes.
  id: totrans-818
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终需要仔细规划和测试来处理不兼容的更改。
- en: Minor version
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次要版本。
- en: Contains only frequently-encountered bugs, security issues, and data corruption
    problems to reduce the risk associated with upgrading.
  id: totrans-820
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅包含经常遇到的错误、安全问题和数据损坏问题，以减少升级风险。
- en: Running the latest minor version is always recommended. The community considers
    not upgrading to be riskier than upgrading.
  id: totrans-821
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终建议运行最新的次要版本。社区认为不升级比升级更加危险。
- en: Released at least once every three months, the second Thursday of February,
    May, August, November. Additional minor versions may be released to address urgent
    issues.
  id: totrans-822
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每三个月发布至少一次，2 月、5 月、8 月、11 月的第二个星期四。可能会发布额外的次要版本以解决紧急问题。
- en: The upgrade can skip intervening minor versions.
  id: totrans-823
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级可以跳过中间的次要版本。
- en: Does not normally require a dump and restore; you can stop the database server,
    install the updated binaries, and restart the server.
  id: totrans-824
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常不需要转储和恢复；您可以停止数据库服务器，安装更新的二进制文件，然后重新启动服务器。
- en: Additional manual steps may be required for some minor versions to remedy the
    bad effects of fixed bugs, such as rebuilding affected indexes. See the section
    "Migration to Version <major>.<minor>" in the release note.
  id: totrans-825
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于某些次要版本，可能需要额外的手动步骤来修复已修复错误的不良影响，例如重建受影响的索引。请参阅发行说明中的“迁移到版本 <major>.<minor>”部分。
- en: Major upgrade methods
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 主要升级方法。
- en: 'pg_dumpall/pg_dump and psql/pg_restore: easy, long downtime'
  id: totrans-827
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pg_dumpall/pg_dump 和 psql/pg_restore：易于使用，停机时间长。
- en: 'pg_upgrade: relatively easy, shorter downtime'
  id: totrans-828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pg_upgrade：相对容易，停机时间较短。
- en: 'Logical replication: complex setup and operation, minimal downtime'
  id: totrans-829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑复制：复杂的设置和操作，最小的停机时间。
- en: Overview of pg_upgrade
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: pg_upgrade 概述。
- en: Upgrades a database cluster to a later major version without dump/restore of
    user data.
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库集群升级到稍后的主要版本，而无需转储/恢复用户数据。
- en: 'Not an in-place upgrade: migrates data from an old database cluster to a new
    database cluster freshly created with initdb.'
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是就地升级：将数据从旧的数据库集群迁移到使用 initdb 新创建的新数据库集群。
- en: The basic idea is that because the relation data storage format rarely changes
    and only the layout of system catalogs change, pg_upgrade just dumps and restores
    the database schema and uses relation data files as-is.
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本思想是因为关系数据存储格式很少更改，而只有系统目录的布局更改，所以 pg_upgrade 只是转储并恢复数据库架构，并使用关系数据文件原样。
- en: Upgrade from 9.2 and later is supported.
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持从 9.2 版本及更高版本升级。
- en: Downgrade is not possible.
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持降级。
- en: Does not migrate database statistics in pg_statistic. The user needs to run
    ANALYZE in every database after pg_upgrade completes.
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不迁移 pg_statistic 中的数据库统计信息。用户需要在每个数据库完成 pg_upgrade 后运行 ANALYZE。
- en: Main steps of pg_upgrade
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: pg_upgrade 的主要步骤
- en: Creates output directory for log and intermediate files.
  id: totrans-838
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建日志和中间文件的输出目录。
- en: Checks that the major version of the target cluster is newer, and that the old
    and new clusters are binary-compatible by comparing information in pg_control.
  id: totrans-839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查目标集群的主要版本是否较新，并且通过比较 pg_control 中的信息来检查旧集群和新集群是否二进制兼容。
- en: Gets the list of databases and relations (table, index, TOAST table, matview)
    of the old cluster.
  id: totrans-840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取旧集群的数据库和关系（表、索引、TOAST 表、matview）列表。
- en: Gets the list of library names that contain C-language functions.
  id: totrans-841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取包含 C 语言函数的库名称列表。
- en: Performs various checks to find blockers of upgrade, such as the inability to
    connect to databases and the presence of prepared transactions.
  id: totrans-842
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行各种检查以查找升级的阻碍者，例如无法连接到数据库和存在准备事务。
- en: Creates a dump of global objects by running `pg_dumpall --globals-only`.
  id: totrans-843
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `pg_dumpall --globals-only` 创建全局对象的转储。
- en: Creates dumps of each database by running `pg_dump --schema-only`. This is parallelized
    by spawning one process or thread for each database when --jobs is specified.
  id: totrans-844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `pg_dump --schema-only` 为每个数据库创建转储。当指定 --jobs 时，这将并行化，为每个数据库生成一个进程或线程。
- en: Checks the previously extracted loadable libraries with C-language functions
    exist in the new cluster by running `LOAD`.
  id: totrans-845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `LOAD` 检查之前提取的带有 C 语言函数的加载库是否存在于新集群中。
- en: Copies commit log files in pg_xact/ and MultiXact files in pg_multixact/ from
    the old cluster to the new cluster.
  id: totrans-846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从旧集群复制提交日志文件和 pg_xact/ 中的 MultiXact 文件到新集群。
- en: Sets next XID and MultiXact ID for the new cluster to take over the old cluster.
  id: totrans-847
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新集群设置下一个 XID 和 MultiXact ID 以接管旧集群。
- en: Restores global objects in the new cluster by running `psql`.
  id: totrans-848
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `psql` 在新集群中恢复全局对象。
- en: Restores database schemas in the new cluster by running `pg_restore`. This is
    parallelized by spawning one process or thread for each database when --jobs is
    specified.
  id: totrans-849
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `pg_restore` 在新集群中恢复数据库模式。当指定 --jobs 时，这将并行化，为每个数据库生成一个进程或线程。
- en: Gets the list of databases and relations (table, index, TOAST table, matview)
    of the new cluster.
  id: totrans-850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取新集群的数据库和关系（表、索引、TOAST 表、matview）列表。
- en: Links or copies user relation files from the old cluster to the new cluster.
    This is parallelized by spawning one process or thread for each tablespace when
    --jobs is specified.
  id: totrans-851
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从旧集群链接或复制用户关系文件到新集群。当指定 --jobs 时，这将并行化，为每个表空间生成一个进程或线程。
- en: Sets next OID for the new cluster.
  id: totrans-852
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新集群设置下一个 OID。
- en: Creates a script to delete the old cluster (delete_old_cluster.sh). This script
    removes the data directory and tablespace version directories.
  id: totrans-853
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个删除旧集群的脚本（delete_old_cluster.sh）。该脚本删除数据目录和表空间版本目录。
- en: Reports extensions that should be updated and creates update_extensions.sql.
    This script contains a list of ALTER EXTENSION ... UPDATE commands.
  id: totrans-854
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告应更新的扩展并创建 update_extensions.sql。此脚本包含一系列 ALTER EXTENSION ... UPDATE 命令。
- en: Log files for troubleshooting pg_upgrade
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 用于故障排除 pg_upgrade 的日志文件
- en: Stored in $NEWPGDATA/pg_upgrade_output.d/<timestamp>/
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在 $NEWPGDATA/pg_upgrade_output.d/<时间戳>/
- en: Removed when pg_upgrade completes successfully.
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功完成 pg_upgrade 后移除。
- en: 'Files:'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件：
- en: 'pg_upgrade_server.log: The postgres server logs. Specified as pg_ctl''s -l.'
  id: totrans-859
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_upgrade_server.log：Postgres 服务器日志。作为 pg_ctl 的 -l 指定。
- en: 'pg_upgrade_dump_<DB-OID>.log: Logs of pg_dump and pg_restore.'
  id: totrans-860
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_upgrade_dump_<DB-OID>.log：pg_dump 和 pg_restore 的日志。
- en: 'pg_upgrade_utility.log: Logs of miscellaneous commands run by pg_upgrade, such
    as psql, pg_resetwal. This includes pg_dumpall/psql to dump and restore global
    objects.'
  id: totrans-861
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_upgrade_utility.log：pg_upgrade 运行的各种命令的日志，如 psql、pg_resetwal。这包括用于转储和恢复全局对象的
    pg_dumpall/psql。
- en: 'pg_upgrade_internal.log: Other pg_upgrade logs.'
  id: totrans-862
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_upgrade_internal.log：其他 pg_upgrade 日志。
- en: 'loadable_libraries.txt: List of C-language function libraries that exist in
    the old cluster but are not found in the new cluster.'
  id: totrans-863
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: loadable_libraries.txt：在旧集群中存在但在新集群中找不到的 C 语言函数库列表。
- en: References
  id: totrans-864
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: PostgreSQL Documentation
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 文档
- en: Memory
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 内存
- en: Storage
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 存储
- en: Internationalization and localization
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化和本地化
- en: Logging
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 记录
- en: Vacuum
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 真空
- en: Partitioning
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 分区
- en: Upgrade
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 升级
- en: Miscellaneous tips
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 杂项提示
- en: Application development
  id: totrans-874
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序开发
- en: Data type
  id: totrans-875
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型
- en: Numeric
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 数字
- en: For exact calculation and/or numbers with many digits, choose numeric.
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于精确计算和/或数字位数很多的情况，请选择numeric类型。
- en: For small storage space and faster calculation, choose integer types (smallint,
    int, bigint) and floating-point types (real, double precision, float).
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于小的存储空间和更快的计算，请选择整数类型（smallint、int、bigint）和浮点类型（real、double precision、float）。
- en: decimal type is an alias for numeric. psql's \d and pg_dump output decimal columns
    as numeric instead of decimal.
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: decimal类型是numeric的别名。 psql的\d和pg_dump输出decimal列为numeric而不是decimal。
- en: Timestamp
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳
- en: timestamp without time zone ignores the TimeZone parameter. The value is stored
    and returned as-is.
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: timestamp without time zone忽略TimeZone参数。 值被存储并原样返回。
- en: timestamp with time zone honors the explicit time zone in the input value or
    otherwise the TimeZone parameter. The input value is converted to UTC, and the
    output value is converted from the stored value, according to the time zone in
    effect.
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: timestamp with time zone尊重输入值中的显式时区或者TimeZone参数。输入值转换为UTC，输出值根据生效的时区从存储值转换。
- en: Binary
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制
- en: Available methods to store binary data
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储二进制数据的可用方法
- en: bytea data type
  id: totrans-885
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: bytea数据类型
- en: 'Large object: Use filesystem-like open/close/read/write interface, data is
    stored in pg_largeobject, the user table column contains an OID value that points
    to a row in pg_largeobject.'
  id: totrans-886
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大对象：使用类似文件系统的open/close/read/write接口，数据存储在pg_largeobject中，用户表列包含指向pg_largeobject中行的OID值。
- en: 'External file: The application manages data in filesystems, or object storage
    and stores the file path in a table character column.'
  id: totrans-887
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部文件：应用程序在文件系统或对象存储中管理数据，并将文件路径存储在表字符列中。
- en: 'How to choose:'
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择：
- en: Need transactional (ACID) properties? -> bytea, large object
  id: totrans-889
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要事务（ACID）属性吗？->bytea、大对象
- en: Handle 1 GB or larger column value? -> large object, external file
  id: totrans-890
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理1 GB或更大的列值？->大对象、外部文件
- en: Need random and/or piecemeal access? -> large object, external file
  id: totrans-891
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要随机和/或分段访问吗？->大对象、外部文件
- en: Want best performance with 100 MB or larger column values? -> external file
  id: totrans-892
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要在100 MB或更大的列值中获得最佳性能？->外部文件
- en: Tips for using large objects
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大对象的提示
- en: '**Do not use large objects.** They can be problematic. Use bytea columns or
    external file storage such as an OS file system and object storage.'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用大对象。** 它们可能会有问题。 使用bytea列或外部文件存储，如操作系统文件系统和对象存储。'
- en: Removing lots of LOBs
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除大量的LOB
- en: 'Trying to remove many large objects within a single transaction, e.g., `"SELECT
    lo_unlink(lo_oid) FROM mytable;"` can fail with the following message:'
  id: totrans-896
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在单个事务中删除多个大对象，例如，`"SELECT lo_unlink(lo_oid) FROM mytable;"`可能会失败，并显示以下消息：
- en: '`ERROR: out of shared memory`'
  id: totrans-897
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`错误：共享内存已用完`'
- en: '`HINT: You might need to increase max_locks_per_transaction.`'
  id: totrans-898
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`提示：您可能需要增加max_locks_per_transaction。`'
- en: 'Cause: When a large object is deleted, it is locked with Access Exclusive mode.
    Therefore, as many entries as the deleted LOBs are required in the lock table.'
  id: totrans-899
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原因：当删除大对象时，它会以独占访问模式锁定。因此，需要在锁表中有与删除的LOB相同数量的条目。
- en: 'Solutions: Do either or both of:'
  id: totrans-900
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案：执行以下任一项或两项：
- en: Increase max_locks_per_transaction. The database server has to be restarted.
  id: totrans-901
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加max_locks_per_transaction。必须重新启动数据库服务器。
- en: Delete LOBs in chunks, e.g., 100 LOBs per transaction.
  id: totrans-902
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按块删除LOB，例如，每个事务删除100个LOB。
- en: Dealing with orphaned LOBs
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理孤立的LOB
- en: An orphaned LOB is a large object whose OID does not appear in any oid or lo
    data column of the database.
  id: totrans-904
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孤立的LOB是一个大对象，其OID未出现在数据库的任何oid或lo数据列中。
- en: Such an orphaned LOB would result if the application fails to delete it by calling
    lo_unlink() when it deletes the associated table row.
  id: totrans-905
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序在删除关联表行时未调用`lo_unlink()`，则会导致这样一个孤立的LOB存在。
- en: 'Solutions: Do both of:'
  id: totrans-906
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案：执行以下任一项或两项：
- en: Use [vacuumlo](https://www.postgresql.org/docs/current/vacuumlo.html) to delete
    orphaned LOBs.
  id: totrans-907
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[vacuumlo](https://www.postgresql.org/docs/current/vacuumlo.html)来删除孤立的LOB。
- en: Use [extension](https://www.postgresql.org/docs/current/lo.htmllo) and set a
    trigger on the LOB column. It automatically calls lo_unlink() when the table row
    containing the LOB OID is updated or deleted.
  id: totrans-908
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[扩展](https://www.postgresql.org/docs/current/lo.htmllo)，并在LOB列上设置触发器。当包含LOB
    OID的表行被更新或删除时，它会自动调用lo_unlink()。
- en: Sequence
  id: totrans-909
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列
- en: There is no gapless sequence
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 没有无间隙序列
- en: 'A sequence produces gaps when:'
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当：
- en: 'The transaction rolls back: Because nextval() and setval() calls are never
    rolled back, allocated sequence values are not reclaimed.'
  id: totrans-912
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务回滚：因为nextval()和setval()调用永远不会回滚，分配的序列值不会被回收。
- en: 'Cached values are unused: If the caching is enabled for a sequence, nextval()
    preallocates the specified number of values and caches them in the session''s
    local memory. Subsequent nextval() calls fetch values from the cache until the
    cache is empty, and then preallocate some values again. So, if the session ends
    without using all the cached values, those will be gaps.'
  id: totrans-913
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存的值未使用：如果为序列启用了缓存，则nextval()会预先分配指定数量的值，并将它们缓存在会话的本地内存中。随后的nextval()调用会从缓存中获取值，直到缓存为空，然后再次预分配一些值。因此，如果会话结束而未使用所有缓存的值，则会出现间隙。
- en: 'The server crashes: Even with a NO CACHE sequence, you can see a gap in these
    steps: nextval() -> crash recovery -> nextval(). For performance, PostgreSQL does
    not WAL-log every fetching of a value from a sequence. nextval() WAL-logs a value
    32 numbers ahead of the current value, and the next 32 calls to nextval() don’t
    WAL-log anything. As a result, some numbers appear to be skipped.'
  id: totrans-914
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器崩溃：即使使用NO CACHE序列，您也可以在这些步骤中看到间隙：nextval() -> 崩溃恢复 -> nextval()。出于性能考虑，PostgreSQL不会为每次从序列获取值都进行WAL日志记录。nextval()会WAL日志记录当前值之后32个数字的值，接下来的32次调用nextval()不会WAL日志记录任何内容。因此，某些数字似乎被跳过了。
- en: References
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: PostgreSQL Documentation
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL文档
- en: Data type
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型
- en: Large object
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 大对象
- en: Pagination
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 分页
- en: Sequence
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 序列
- en: Scalability and performance
  id: totrans-921
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性和性能
- en: Many connections
  id: totrans-922
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 许多连接
- en: 'Want to handle many concurrent clients? Then do:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 想处理许多并发客户端？那么就要做：
- en: Set up connection pooling on each application server as well as on a central
    server.
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个应用程序服务器以及中央服务器上设置连接池。
- en: Limit max_connections and the actual number of connections to a few times the
    number of CPU cores, or at most a few hundreds.
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将max_connections和实际连接数限制为CPU核心数量的几倍，或者最多几百个。
- en: 'Performance tends to drop above this limit, mainly because of:'
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能往往会在此限制以上下降，主要原因是：
- en: high memory usage by client backends, possibly leading to swapping.
  id: totrans-927
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端后端的内存使用率高，可能导致交换。
- en: CPU context switches
  id: totrans-928
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU上下文切换
- en: CPU cache line contention
  id: totrans-929
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU缓存行争用
- en: 'locks, particularly spinlocks: if one process holds a spinlock and other processes
    comes to the same protected section, those latecomers will wait spinning on the
    lock and continues to consume CPU.'
  id: totrans-930
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁，特别是自旋锁：如果一个进程持有自旋锁，并且其他进程进入相同的受保护区域，那些后来者将等待自旋锁并继续消耗CPU。
- en: 'processing PostgreSQL internal data structures: some data structures and its
    processing depends on the number of connections; creating a snapshot stands out
    here'
  id: totrans-931
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理PostgreSQL内部数据结构：某些数据结构及其处理取决于连接数；在这里，创建快照突出显示
- en: Even idle connections are not innocent. They contribute to high resource usage.
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是空闲连接也不是无辜的。它们会导致高资源使用率。
- en: Detecting problems
  id: totrans-933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测问题
- en: Increase track_activity_query_size for ORMs (Object Relational Mappers)
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 为ORM（对象关系映射器）增加track_activity_query_size
- en: Some views such as pg_stat_activity and pg_stat_statements show query strings.
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些视图，如pg_stat_activity和pg_stat_statements，显示查询字符串。
- en: Because those query strings are stored in fixed-size shared memory, the length
    of each such query string is fixed, which is track_activity_query_size. Longer
    queries are cut off at this limit.
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为这些查询字符串存储在固定大小的共享内存中，每个这样的查询字符串的长度都是固定的，即track_activity_query_size。较长的查询会被截断到此限制。
- en: Hibernate or some other ORMs produce very long queries. It may be useful to
    set track_activity_query_size to 32 KB or so.
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate或其他ORM产生非常长的查询。将track_activity_query_size设置为32 KB左右可能会有用。
- en: Utilize [plprofiler](https://github.com/bigsql/plprofiler) to diagnose the bottlenecks
    of PL/pgSQL functions and procedures
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 利用[plprofiler](https://github.com/bigsql/plprofiler)诊断PL/pgSQL函数和过程的瓶颈
- en: This is an extension that creates an HTML report showing the runtimes of each
    step of the function and procedure, total runtimes of routines called from there,
    as well as the execution time of each routine.
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个创建HTML报告的扩展，显示函数和过程每个步骤的运行时间，从那里调用的例程的总运行时间，以及每个例程的执行时间。
- en: Logging
  id: totrans-940
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志记录
- en: Server logging could block but not show waits
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器日志可能会阻塞但不显示等待
- en: The logging collector (logger) is the sole process to write logs to server log
    files.
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志收集器（记录器）是唯一将日志写入服务器日志文件的进程。
- en: Every backend process writes logs to its standard error, which is connected
    through a Unix pipe to the read endpoint of the logger. The logger reads messages
    from the pipe and writes them to files.
  id: totrans-943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个后端进程将日志写入其标准错误，该标准错误通过Unix管道连接到记录器的读端点。记录器从管道中读取消息并将其写入文件。
- en: If the pipe gets full, the backend could block when writing to it. This happens
    when the logger is behind due to overwhelming amount of logging, for example,
    when some combination of pgAudit, auto_explain, and log_min_duration_statement
    is used and many concurrent sessions are running short queries.
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果管道被填满，后端在写入时可能会被阻塞。当日志记录量过大时（例如，当使用了一些 pgAudit、auto_explain 和 log_min_duration_statement
    的组合并且有许多并发会话运行短查询时），就会发生这种情况。
- en: The block on the pipe is not treated as a wait event (possibly by mistake),
    so the backend appears to be consuming CPU.
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道上的阻塞不会被视为等待事件（可能是错误），因此后端似乎正在消耗 CPU。
- en: Import and export
  id: totrans-946
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入和导出
- en: '`ALTER TABLE SET UNLOGGED/LOGGED` is heavy'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALTER TABLE SET UNLOGGED/LOGGED` 非常耗费资源'
- en: This rewrites the entire table into new data files and WAL-logs those writes.
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会将整个表重写到新的数据文件中，并将这些写操作写入 WAL 日志。
- en: Hence, you cannot use it for efficient data loading - switching the table to
    UNLOGGED, load data into the table, and setting it back to LOGGED.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，您不能用它来进行有效的数据加载 - 将表切换为 UNLOGGED，加载数据到表中，然后将其设置回 LOGGED。
- en: Queries or the first vacuum are slow after loading data with COPY
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 COPY 加载数据后，查询或第一个 VACUUM 会变慢
- en: This is because those commands have to set hint bits for rows they want to see.
    Setting hint bits modifies shared buffers and WAL-logs the changes if data checksums
    are enabled. These could generate massive writes.
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是因为这些命令必须为它们想要查看的行设置提示位。设置提示位会修改共享缓冲区，并在启用数据校验和的情况下写入 WAL 日志。这可能会产生大量的写入。
- en: '`COPY (FREEZE)` comes to the rescue. FREEZE option freezes the loaded rows
    and set their hint bits.'
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`COPY (FREEZE)`来解决。FREEZE 选项冻结加载的行并设置它们的提示位。
- en: The table must have been created or truncated in the current subtransaction.
    This is to prevent other transactions from seeing the frozen rows before the COPY
    transaction commits.
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表必须在当前子事务中已经创建或截断。这是为了防止其他事务在 COPY 事务提交之前看到冻结的行。
- en: Foreign Data Wrapper (FDW)
  id: totrans-954
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部数据包装器（FDW）
- en: Speeding up queries via [postgres_fdw](https://www.postgresql.org/docs/current/postgres-fdw.html)
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 [postgres_fdw](https://www.postgresql.org/docs/current/postgres-fdw.html)
    加快查询速度
- en: Run ANALYZE manually on foreign tables
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在外部表上手动运行 ANALYZE
- en: autovacuum does not execute ANALYZE on foreign tables. Hence, the local statistics
    may get stale and lead to poor query plans.
  id: totrans-957
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: autovacuum 不会在外部表上执行 ANALYZE。因此，本地统计信息可能会变得过时，并导致查询计划不佳。
- en: Enable use_remote_estimate for long-running queries
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为长时间运行的查询启用 use_remote_estimate
- en: i.e., `ALTER FOREIGN SERVER/TABLE ... OPTIONS (use_remote_estimate 'true');`
  id: totrans-959
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即，`ALTER FOREIGN SERVER/TABLE ... OPTIONS (use_remote_estimate 'true');`
- en: This makes postgres_fdw issue EXPLAIN to perform the cost estimate on the remote
    server.
  id: totrans-960
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得 postgres_fdw 发出 EXPLAIN 以在远程服务器上执行成本估算。
- en: The query planning time will get longer due to the round-trip for EXPLAIN. So,
    this may not be worth the cost for short queries. You can use different foreign
    servers/tables with different settings for OLTP, batch, and analytics workloads.
  id: totrans-961
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 EXPLAIN 的往返，查询计划时间会变长。因此，对于短查询来说，这可能不值得成本。您可以针对 OLTP、批处理和分析工作负载使用具有不同设置的不同外部服务器/表。
- en: Increase fetch_size
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加 fetch_size
- en: i.e., `ALTER FOREIGN SERVER/TABLE ... OPTIONS (fetch_size '1000');`
  id: totrans-963
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即，`ALTER FOREIGN SERVER/TABLE ... OPTIONS (fetch_size '1000');`
- en: postgres_fdw uses a cursor to fetch rows from a foreign table. fetch_size determines
    the number of rows to fetch at a time. The default is 100.
  id: totrans-964
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: postgres_fdw 使用游标从外部表中获取行。fetch_size 确定一次获取的行数。默认值为 100。
- en: If the network latency is high, reducing the round-trips by increasing this
    setting may help. Be aware that higher values require more memory to store fetched
    rows.
  id: totrans-965
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网络延迟较高，通过增加此设置来减少往返次数可能会有所帮助。请注意，较高的值需要更多的内存来存储获取的行。
- en: Increase batch_size
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加 batch_size
- en: i.e., `ALTER FOREIGN SERVER/TABLE ... OPTIONS (batch_size '1000');`
  id: totrans-967
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即，`ALTER FOREIGN SERVER/TABLE ... OPTIONS (batch_size '1000');`
- en: By default, postgres_fdw inserts one row at a time into a foreign table during
    multi-row inserts (`INSERT ... SELECT, INSERT ... VALUES (row1), (row2),..., COPY
    FROM`).
  id: totrans-968
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，postgres_fdw 在多行插入（`INSERT ... SELECT, INSERT ... VALUES (row1), (row2),...,
    COPY FROM`）期间逐行插入外部表中的一行。
- en: Raising this setting will dramatically increase the throughput, particularly
    where the network latency is high.
  id: totrans-969
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高此设置将大幅提高吞吐量，特别是在网络延迟高的情况下。
- en: List the extension names in extensions parameter that have compatible behavior
    on both the local and remote servers
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在扩展参数中列出在本地和远程服务器上具有兼容行为的扩展名称
- en: i.e., `ALTER FOREIGN SERVER ... OPTIONS (extensions 'extension1,extension2');`
  id: totrans-971
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即，`ALTER FOREIGN SERVER ... OPTIONS (extensions 'extension1,extension2');`
- en: The immutable functions and operators in those extensions are considered to
    bring the same result on the local and remote servers. As a result, execution
    of them will be shipped to the remote server.
  id: totrans-972
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些扩展中的不可变函数和运算符被认为会在本地服务器和远程服务器上产生相同的结果。因此，它们的执行将被发送到远程服务器。
- en: This is particularly beneficial when those functions and operators are used
    in the WHERE clause. Those filters will be executed on the remote server and thus
    fewer rows are transfered.
  id: totrans-973
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这在WHERE子句中使用这些函数和运算符时特别有益。这些过滤器将在远程服务器上执行，因此传输的行数较少。
- en: Full text search
  id: totrans-974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全文搜索
- en: Full-text search queries got much slower after inserting many new documents
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 插入许多新文档后，全文搜索查询变得慢得多
- en: When inserting data into an GIN index that has fastupdate enabled, the new index
    entries are not put into the index main structure. Instead, they are placed in
    the index's pending-list whose size is set by gin_pending_list_limit. Later, when
    the pending-list area becomes full, those pending-list entries are moved to the
    main index structure.
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入数据到启用了fastupdate的GIN索引时，新的索引条目不会放入主索引结构中。相反，它们被放在由gin_pending_list_limit设置的索引的挂起列表中。稍后，当挂起列表区域变满时，那些挂起列表条目将被移动到主索引结构中。
- en: This is for good performance, because inserting one document involves many insertions
    into the main index, depending on the number of words in the document.
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这对于良好的性能很重要，因为插入一个文档会涉及对主索引的许多插入，具体取决于文档中的单词数量。
- en: Full-text search queries scan the pending-list before the main index structure.
    Therefore, they are slow if the pending-list contains many pending entries.
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全文搜索查询在扫描主索引结构之前会扫描挂起列表。因此，如果挂起列表包含许多挂起条目，查询就会变慢。
- en: Vacuum, including autovacuum, also moves the pending-list entries into the main
    index. So, the full-text search query will be faster after vacuum.
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行vacuum（包括自动vacuum）也会将pending-list项移到主索引中。因此，在vacuum后，全文搜索查询将变得更快。
- en: It is advised to tune autovacuum so that it runs reasonably frequently after
    inserting or updating documents.
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议调整autovacuum，以便在插入或更新文档后合理频繁地运行。
- en: 'The number of pending-list pages and tuples can be seen with this query (the
    pgstatginindex is in pgstattuple extension):'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下查询来查看挂起列表页面和元组的数量（pgstatginindex在pgstattuple扩展中）：
- en: '`SELECT * FROM pgstatginindex(''some_gin_index'');`'
  id: totrans-982
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT * FROM pgstatginindex(''some_gin_index'');`'
- en: Utility
  id: totrans-983
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用性
- en: Fast random sampling of table rows
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 快速随机抽样表行
- en: The traditional method is slow, because it scans and sorts the entire table.
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统方法速度慢，因为它扫描并对整个表进行排序。
- en: '`SELECT * FROM mytable ORDER BY random() LIMIT 1;`'
  id: totrans-986
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT * FROM mytable ORDER BY random() LIMIT 1;`'
- en: Using TABLESAMPLE clause returns rows very quickly almost independently of the
    table size.
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TABLESAMPLE子句返回行非常快，几乎与表的大小无关。
- en: TABLESAMPLE fetches a sample portion of a table. Some built-in sampling methods
    are provided.
  id: totrans-988
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TABLESAMPLE获取表的抽样部分。提供了一些内置的抽样方法。
- en: 'Also, The sampling method can be customized by adding an extension. For example,
    [tsm_system_rows](https://www.postgresql.org/docs/current/tsm-system-rows.html)
    retrieves a specified number of random rows:'
  id: totrans-989
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，可以通过添加扩展来定制抽样方法。例如，[tsm_system_rows](https://www.postgresql.org/docs/current/tsm-system-rows.html)检索指定数量的随机行：
- en: '`CREATE EXTENSION tsm_system_rows;`'
  id: totrans-990
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE EXTENSION tsm_system_rows;`'
- en: '`SELECT * FROM mytable TABLESAMPLE SYSTEM_ROWS(1);`'
  id: totrans-991
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT * FROM mytable TABLESAMPLE SYSTEM_ROWS(1);`'
- en: SYSTEM_ROWS picks up a random block in the table's data file, and then fetchs
    rows sequentially in it. If more rows are necessary, additional blocks will be
    chosen.
  id: totrans-992
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYSTEM_ROWS在表的数据文件中随机选取一个块，然后在其中顺序提取行。如果需要更多行，将选择其他块。
- en: Memory
  id: totrans-993
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存
- en: Use huge pages
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 使用huge pages
- en: Set huge_pages = on.
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置huge_pages = on。
- en: This will reduce memory usage dramatically because the [page table](https://en.wikipedia.org/wiki/Page_table)
    gets smaller.
  id: totrans-996
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将大大减少内存使用，因为页面表变得更小。
- en: Also, improved performance can be expected thanks to the reduction of CPU's
    TLB cache misses.
  id: totrans-997
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，由于CPU的TLB缓存未命中减少，可以期待性能得到改善。
- en: '"on" should be preferred for huge_pages to "try", considering the reduced memory
    usage and improved performance as a part of stable operation.'
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在稳定运行的一部分中，应优先选择“on”而不是“try”来使用huge_pages，考虑到内存使用量的减少和性能的改善。
- en: 'When huge_pages is set to "on", and the OS cannot allocate enough huge pages,
    PostgreSQL refuses to start emitting the following messages:'
  id: totrans-999
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当huge_pages设置为“on”且操作系统无法分配足够的huge页面时，PostgreSQL拒绝启动并发出以下消息：
- en: '`FATAL: could not map anonymous shared memory: Cannot allocate memory`'
  id: totrans-1000
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FATAL: could not map anonymous shared memory: Cannot allocate memory`'
- en: '`HINT: This error usually means that PostgreSQL''s request for a shared memory
    segment exceeded available memory, swap space, or huge pages. To reduce the request
    size (currently 1234567890 bytes), reduce PostgreSQL''s shared memory usage, perhaps
    by reducing shared_buffers or max_connections.`'
  id: totrans-1001
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`提示：这个错误通常意味着 PostgreSQL 对共享内存段的请求超出了可用的内存、交换空间或大页面。要减少请求大小（当前为 1234567890
    字节），可以通过减少 PostgreSQL 的共享内存使用量来减少，例如减少 shared_buffers 或 max_connections。`'
- en: In this case, reboot the OS or perform failover.
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，重新启动操作系统或执行故障转移。
- en: Tips for shared buffers
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 共享缓冲区的提示
- en: Avoid disk writes by client backends.
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免客户端后端进行磁盘写入。
- en: If there is no free shared buffer when the server process wants a new page,
    it has to evict a used buffer. If the evicted page is dirty, the server process
    needs to write the page to disk. This adds to the response time.
  id: totrans-1005
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务器进程想要一个新页面时没有可用的免费共享缓冲区，它必须驱逐一个已使用的缓冲区。如果被驱逐的页面是脏的，则服务器进程需要将页面写入磁盘。这会增加响应时间。
- en: This undesirable situation can be detected by checking that the buffers_backend
    in [pg_stat_bgwriter](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-BGWRITER-VIEW)
    is high. If buffers_backend_fsync is also high, the situation is worse.
  id: totrans-1006
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过检查 [pg_stat_bgwriter](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-BGWRITER-VIEW)
    中的 buffers_backend 是否高来检测到这种不良情况。如果 buffers_backend_fsync 也很高，则情况更糟。
- en: 'To alleviate this:'
  id: totrans-1007
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓解方法：
- en: 'Make more free buffers: increase shared_buffers.'
  id: totrans-1008
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加更多的空闲缓冲区：增加 shared_buffers。
- en: 'Make more clean buffers: increase bgwriter_lru_multiplier so that the background
    writer writes dirty buffers more aggressively. If the maxwritten_clean of pg_stat_bgwriter
    rises frequently, try increasing bgwriter_lru_maxpages.'
  id: totrans-1009
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加更多的清理缓冲区：增加 bgwriter_lru_multiplier，使后台写进程更积极地写入脏缓冲区。如果 pg_stat_bgwriter 的
    maxwritten_clean 经常上升，请尝试增加 bgwriter_lru_maxpages。
- en: Large shared buffers may be counterproductive.
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型共享缓冲区可能会适得其反。
- en: The benefits of shared buffers is diminished on a host with high-performance
    storage.
  id: totrans-1011
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有高性能存储的主机上，共享缓冲区的好处减少了。
- en: 'That''s because PostgreSQL uses the OS''s filesystem cache: the data is cached
    in the filesystem cache as well as in shared buffers (double buffering).'
  id: totrans-1012
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是因为 PostgreSQL 使用操作系统的文件系统缓存：数据被缓存在文件系统缓存中，以及在共享缓冲区中（双缓冲）。
- en: Therefore, start with 25% of RAM for shared buffers, and then increase it up
    to around 40% as long as you can see some improvement.
  id: totrans-1013
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，首先将 RAM 的 25% 用于共享缓冲区，然后将其增加到大约 40%，只要您能看到一些改善。
- en: However, some benchmark demonstrated that 64 GB or more can do harm.
  id: totrans-1014
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，一些基准测试表明，64 GB 或更多可能会有害。
- en: Leverage [pg_prewarm](https://www.postgresql.org/docs/current/pgprewarm.html)
    to quickly regain performance after failover.
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用[pg_prewarm](https://www.postgresql.org/docs/current/pgprewarm.html)在故障转移后快速恢复性能。
- en: After the database server restart or failover, the contents of shared buffers
    is empty or can be quite different from what was before the failover. Thus, application
    response times get worse until the shared buffers are warmed up.
  id: totrans-1016
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库服务器重启或故障转移后，共享缓冲区的内容为空或与故障转移前相比可能会有很大不同。因此，应用程序响应时间会恶化，直到共享缓冲区被预热。
- en: Add pg_prewarm in shared_preload_libraries, and set pg_prewarm.autoprewarm to
    on.
  id: totrans-1017
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 shared_preload_libraries 中添加 pg_prewarm，并将 pg_prewarm.autoprewarm 设置为 on。
- en: This launches the autoprewarm worker, which periodically saves in a file the
    list of relation and block numbers cached in shared buffers. At server startup,
    pg_prewarm worker reads the file to refill shared buffers.
  id: totrans-1018
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将启动自动预热工作进程，该进程周期性地将在共享缓冲区中缓存的关系和块编号列表保存在文件中。在服务器启动时，pg_prewarm 工作进程会读取文件以重新填充共享缓冲区。
- en: '`"SELECT * FROM some_table;"` does not necessarily cache the entire table.'
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"SELECT * FROM some_table;"` 不一定会缓存整个表。'
- en: You may want to do this for performance test or application warmup, but it doesn't
    work. Also, it does not cache indexes at all.
  id: totrans-1020
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能希望为性能测试或应用程序预热而这样做，但这是行不通的。而且，它根本不缓存索引。
- en: If the size of a relation is larger than a quarter of shared buffers, its sequential
    scan only uses 256 KB of shared buffers.
  id: totrans-1021
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果关系的大小大于共享缓冲区的四分之一，则其顺序扫描仅使用 256 KB 的共享缓冲区。
- en: The idea behind this is that a page that has been touched only by such a scan
    is unlikely to be needed again soon, so PostgreSQL tries to prevent such large
    sequential scans from evicting many useful pages out of the shared buffers.
  id: totrans-1022
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这背后的想法是，只有这样一个扫描所触及的页面不太可能很快再次需要，因此 PostgreSQL 尝试防止这样的大型顺序扫描将许多有用的页面从共享缓冲区中驱逐出去。
- en: Likewise, bulk writes, e.g., COPY FROM and CREATE TABLE AS SELECT, use only
    16 MB of shared buffers.
  id: totrans-1023
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，批量写入，例如，COPY FROM 和 CREATE TABLE AS SELECT，仅使用 16 MB 的共享缓冲区。
- en: To cache the entire relation, run `SELECT pg_prewarm('relation_name')`. This
    works for indexes as well.
  id: totrans-1024
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要缓存整个关系，请运行`SELECT pg_prewarm('relation_name')`。这对索引也适用。
- en: Tips for local memory
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 本地内存的技巧
- en: Setting enough work_mem requires try and error.
  id: totrans-1026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置足够的work_mem需要尝试和错误。
- en: Unfortunately, there is no easy way to estimate a work_mem setting to avoid
    disk spilling.
  id: totrans-1027
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的是，没有一种简单的方法来估算work_mem设置以避免磁盘溢出。
- en: The temporary file that log_temp_files shows is not sufficient. Additional overhead
    for buffering temporary data in memory must be included.
  id: totrans-1028
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: log_temp_files显示的临时文件不足以说明问题。必须包括在内存中缓冲临时数据的额外开销。
- en: One way to estimate work_mem is to multiply the width and number of plan rows
    that are sorted or hashed, found in the query plan. Add some extra for overhead,
    say, further multiply it by 1.1 or so.
  id: totrans-1029
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估算work_mem的一种方法是将在查询计划中找到的已排序或已散列的计划行的宽度和数量相乘。为了考虑额外的开销，比如再乘以1.1或者更多。
- en: If parallel query is used, divide the result by (number of parallel workers
    used + 1). "+1" is for the parallel leader process.
  id: totrans-1030
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用了并行查询，请将结果除以（使用的并行工作者数+1）。“+1”是指并行领导进程。
- en: Run EXPLAIN ANALYZE to see if external file is used. Try increasing work_mem
    until the use of external file disappears.
  id: totrans-1031
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行EXPLAIN ANALYZE以查看是否使用了外部文件。尝试增加work_mem直到外部文件的使用消失为止。
- en: effective_cache_size does not allocate any memory.
  id: totrans-1032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: effective_cache_size不会分配任何内存。
- en: This is only used to estimate the costs of index scans. The planner assumes
    this amount of memory is available for caching query data.
  id: totrans-1033
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这仅用于估算索引扫描的成本。规划器假设此数量的内存可用于缓存查询数据。
- en: A higher value makes it more likely index scans will be used, a lower value
    makes it more likely sequential scans will be used.
  id: totrans-1034
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较高的值使索引扫描的使用更有可能，较低的值使顺序扫描的使用更有可能。
- en: Network
  id: totrans-1035
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络
- en: Watch out for network latency when running lots of short SQL commands
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行大量短SQL命令时要注意网络延迟
- en: Did your batch application, which issues a lot of small SQL statements in succession,
    get many times slower when you migrated it to a different environment?
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您将批处理应用程序（在连续发出许多小SQL语句的情况下）迁移到不同的环境时，它是否变得慢了很多倍？
- en: That may be because the network latency is higher. Check to see if the network
    communication is slow.
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能是因为网络延迟较高。检查一下网络通信是否缓慢。
- en: Measure the round-trip time of a simple SQL, e.g.,
  id: totrans-1039
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量简单SQL的往返时间，例如，
- en: Check if the wait events ClientRead and ClientWrite are increasing.
  id: totrans-1040
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查等待事件ClientRead和ClientWrite是否增加。
- en: Cursor
  id: totrans-1041
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游标
- en: DECLARE CURSOR is fast. It creates a query plan, but does not calculate the
    result set. FETCH starts the calculation.
  id: totrans-1042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DECLARE CURSOR很快。它创建了一个查询计划，但不计算结果集。FETCH开始计算。
- en: A cursor query is planned differently from a non-cursor query. You can see different
    query plans for the same SELECT statement.
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游标查询与非游标查询的计划方式不同。您可以看到相同SELECT语句的不同查询计划。
- en: Non-cursor queries are optimized for total runtime. The optimizer assumes that
    the client will consume the entire result set.
  id: totrans-1044
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非游标查询针对总运行时间进行了优化。优化器假设客户端将消耗整个结果集。
- en: A sequential scan and sort is more likely to be chosen because the index scan
    is considered expensive.
  id: totrans-1045
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于索引扫描被认为是昂贵的，因此更有可能选择顺序扫描和排序。
- en: Cursor queries are optimized for the runtime of startup and initial data retrieval.
    The optimizer assumes that the client will fetch only a fraction of the result
    set.
  id: totrans-1046
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游标查询针对启动时间和初始数据检索的运行时间进行了优化。优化器假设客户端只会获取结果集的一部分。
- en: The optimizer goes for an index scan to speed up the creation of the first 10%
    of the data.
  id: totrans-1047
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化器选择索引扫描以加快数据的前10%的创建速度。
- en: The "10%" can be configured with cursor_tuple_fraction parameter.
  id: totrans-1048
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “10%”可以通过cursor_tuple_fraction参数进行配置。
- en: Lock
  id: totrans-1049
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁
- en: Utilize fast-path locks for high performance
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 利用高性能的快速路径锁
- en: If lots of concurrent short transactions each touch many relations, the lwlocks
    to protect the lock table can become a contention bottleneck. That contention
    is visible as the LWLock:LockManager wait event.
  id: totrans-1051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果大量并发的短事务每个都触及许多关系，则保护锁表的lwlocks可能成为争用瓶颈。这种争用可视为LWLock:LockManager等待事件。
- en: Although the lock table is divided into 16 partitions and they are covered by
    different lwlocks, hundreds of concurrent transactions can lead to waits on those
    lwlocks.
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管锁表被分成了16个分区，并且它们被不同的lwlocks覆盖，但数百个并发事务可能导致在这些lwlocks上等待。
- en: 'Fast-path locks come to the rescue:'
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速路径锁来拯救：
- en: Weak locks (Access Share, Row Share, and Row Exclusive modes) are taken using
    the fast-path lock mechanism. It doesn't use the lock table. Instead, those locks
    are recorded in the per-backend area in shared memory.
  id: totrans-1054
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱锁（访问共享、行共享和行排它模式）使用快速路径锁机制获取。它不使用锁表。相反，这些锁记录在共享内存中的每个后端区域中。
- en: SELECT and DMLs take those weak locks, so they don't suffer from the lock manager
    lwlock contention.
  id: totrans-1055
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELECT 和 DMLs 获取这些弱锁，因此它们不会遭受锁管理器 lwlock 竞争的影响。
- en: 'However, fast-path locks cannot be used if either of the following is true:'
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，如果以下任一条件为真，则无法使用快速路径锁：
- en: The transaction already has 16 fast-path relation locks. The per-backend recording
    area is limited to 16 entries. Queries that access tables with many partitions
    and indexes, or join many tables will lose.
  id: totrans-1057
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务已经具有 16 个快速路径关系锁。每个后端记录区域限制为 16 个条目。访问具有许多分区和索引的表或连接许多表的查询将丢失。
- en: Some transaction tries to acquire a strong lock (Share, ShareRowExclusive, Exclusive,
    and AccessExclusiveLock modes).
  id: totrans-1058
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些事务尝试获取强锁（共享、共享行排它、排它和访问排它锁模式）。
- en: Existing fast-path locks on the same relation are transferred to the lock table.
  id: totrans-1059
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一关系上的现有快速路径锁将转移到锁表中。
- en: If someone has or requesting a strong lock, subsequent transactions which acquire
    a lock on a different relation may not be able to use the fast-path lock. This
    is because the presence of strong locks are managed using an array of 1024 integer
    counters, which are in effect a 1024-way partitioning of the lock space. If the
    requested weak lock is to be managed in the same partition as an existing strong
    lock, it cannot be fast-path.
  id: totrans-1060
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有人拥有或请求强锁，则随后的事务可能无法使用快速路径锁获取不同关系上的锁。这是因为强锁的存在是使用 1024 个整数计数器的数组管理的，这些计数器实际上是对锁空间的
    1024 分区。如果请求的弱锁要在与现有强锁相同的分区中管理，则不能使用快速路径。
- en: The fast-path lock shows up in [pg_locks](https://www.postgresql.org/docs/current/view-pg-locks.html)
    as the fastpath column being true.
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速路径锁会显示在 [pg_locks](https://www.postgresql.org/docs/current/view-pg-locks.html)
    中，其 fastpath 列为 true。
- en: HOT
  id: totrans-1062
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HOT
- en: Take advantage of HOT (Heap-Only Tuple)
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 HOT（仅堆元组）
- en: HOT speeds up UPDATEs.
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HOT 加快了 UPDATE。
- en: What's wrong if HOT is not used?
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有使用 HOT，那么出了什么问题？
- en: Indexes will be bigger, because each row version has an index entry in every
    index. Index scans using those indexes will be slower, too.
  id: totrans-1066
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引会变得更大，因为每个行版本在每个索引中都有一个索引条目。使用这些索引进行索引扫描也会变慢。
- en: WAL volume will be larger and update will be slower, because the update of any
    column inserts new entries into all indexes.
  id: totrans-1067
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAL 卷会变大，更新会变慢，因为任何列的更新都会在所有索引中插入新条目。
- en: 'For HOT to work, both of the following conditions must be met:'
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使 HOT 起作用，必须同时满足以下两个条件：
- en: The block containing the updated row has enough free space to accommodate the
    new row version.
  id: totrans-1069
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含更新行的块具有足够的空闲空间来容纳新的行版本。
- en: The update does not modify any indexed column.
  id: totrans-1070
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新不修改任何索引列。
- en: Then, what should I do?
  id: totrans-1071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，我该怎么办呢？
- en: Set fillfactor on the table to make room for new row versions.
  id: totrans-1072
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表上设置填充因子以为新行版本腾出空间。
- en: e.g., `CREATE TABLE mytable ... WITH (fillfactor = 90);`, `ALTER TABLE mytable
    SET (fillfactor = 90);`
  id: totrans-1073
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`CREATE TABLE mytable ... WITH (fillfactor = 90);`，`ALTER TABLE mytable SET
    (fillfactor = 90);`
- en: Lower fillfactor makes the table bigger, which results in shared buffer misses
    and longer sequential scans.
  id: totrans-1074
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较低的填充因子会使表变大，从而导致共享缓冲区未命中和较长的顺序扫描。
- en: Maybe you should start with fillfactor = 90, and lower the setting if HOT is
    not working well.
  id: totrans-1075
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许你应该从 fillfactor = 90 开始，并在 HOT 的效果不佳时降低设置。
- en: Drop unnecessary indexes.
  id: totrans-1076
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除不必要的索引。
- en: How do I know if HOT is working?
  id: totrans-1077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我怎么知道 HOT 是否在起作用？
- en: Table layout
  id: totrans-1078
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表布局
- en: For best storage efficiency and performance, declare table columns from largest
    fixed length types (e.g., bigint, timestamp) to smallest fixed length types (e.g.,
    smallint, bool), then variable length types (e.g., numeric, text, bytea)
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳的存储效率和性能，应从最大的固定长度类型（例如 bigint、timestamp）到最小的固定长度类型（例如 smallint、bool），然后到可变长度类型（例如
    numeric、text、bytea）声明表列。
- en: Storage efficiency comes from the data alignment requirements.
  id: totrans-1080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储效率来自数据对齐要求。
- en: For example, bigint is aligned on 8 byte boundary, while bool is aligned on
    1 byte boundary.
  id: totrans-1081
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，bigint 在 8 字节边界上对齐，而 bool 在 1 字节边界上对齐。
- en: In the following example, the former of the following returns 48, and the latter
    returns 39.
  id: totrans-1082
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下示例中，前者返回 48，后者返回 39。
- en: '`SELECT pg_column_size(ROW(''true''::bool, ''1''::bigint, ''1''::smallint,
    ''1''::int));`'
  id: totrans-1083
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT pg_column_size(ROW(''true''::bool, ''1''::bigint, ''1''::smallint,
    ''1''::int));`'
- en: '`SELECT pg_column_size(ROW(''1''::bigint, ''1''::int, ''1''::smallint, ''true''::bool));`'
  id: totrans-1084
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT pg_column_size(ROW(''1''::bigint, ''1''::int, ''1''::smallint, ''true''::bool));`'
- en: 'The alignment requirements can be seen with: `SELECT typalign, typname FROM
    pg_type ORDER BY 1, 2;`'
  id: totrans-1085
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过 `SELECT typalign, typname FROM pg_type ORDER BY 1, 2;` 查看对齐要求。
- en: Better performance comes from the aforementioned smaller data size, and direct
    column access.
  id: totrans-1086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更小的数据大小和直接列访问带来更好的性能。
- en: If fixed-length columns are placed in front of the row, PostgreSQL can calculate
    and cache the positions of fixed-length columns in the row. So, a requested fixed-length
    column data of any row can be accessed directly using its offset.
  id: totrans-1087
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果固定长度列位于行的前面，PostgreSQL 可以计算并缓存行中固定长度列的位置。因此，可以使用其偏移量直接访问任何行的请求的固定长度列数据。
- en: Once a variable-length column appears, the positions of subsequent columns need
    to be calculated for each row, by adding up its columns' actual lengths. As a
    result, access to columns at the end of the row will be slow.
  id: totrans-1088
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦出现可变长度列，需要为每行计算后续列的位置，方法是加上其列的实际长度。因此，对行尾的列的访问将变慢。
- en: Use functions returning a composite type in FROM clause instead of SELECT column
    list
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FROM 子句中使用返回复合类型的函数，而不是 SELECT 列列表
- en: Suppose sample_func()'s return type is a composite type `(a int, b int, c int)`.
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设 sample_func() 的返回类型是复合类型 `(a int, b int, c int)`。
- en: 'Bad: `SELECT (sample_func()).*;`'
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不好：`SELECT (sample_func()).*;`
- en: 'Good: `SELECT * FROM sample_func();`'
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好的：`SELECT * FROM sample_func();`
- en: In the bad case, `"(sample_func()).*"` is expanded to `"(sample_func()).a"`,
    `"(sample_func()).b"`, `"(sample_func()).c"`. Thus, the function is called three
    times.
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不好的情况下，`"(sample_func()).*"` 被扩展为 `"(sample_func()).a"`、`"(sample_func()).b"`、`"(sample_func()).c"`。因此，该函数被调用三次。
- en: TOAST (The Oversized-Attribute Storage Technique)
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: TOAST（超大属性存储技术）
- en: This is a mechanism to store large values of up to 1 GB - 1.
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种存储高达 1 GB - 1 的大值的机制。
- en: A tuple cannot span multiple pages. Then, how is a column value stored that
    is larger than the page size (commonly 8 KB)?
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组不能跨多个页面。那么，如果列值大于页面大小（通常为 8 KB），该如何存储？
- en: Large column values of TOAST-able data types are compressed and/or broken up
    into chunks. Each chunk is stored as a separate row in the table's associated
    TOAST table. The chunk size is chosen so that four chunk rows will fit on a page.
    That is about 2,000 bytes for 8 KB page size.
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可 TOAST 的数据类型的大列值被压缩和/或分成块。每个块作为表的相关 TOAST 表中的单独行存储。块大小被选择为四个块行将适合于一个页面。这对于
    8 KB 页面大小约为 2,000 字节。
- en: A TOAST-able data type is the one which has a variable-length (varlena) representation.
    That is, a 1 or 4 byte varlena header followed by the column value. char(n) seems
    like fixed-length, but it has a varlena format.
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可 TOAST 的数据类型是具有可变长度（varlena）表示的数据类型。也就是说，一个 1 或 4 字节的 varlena 头后跟列值。char(n)
    看起来像是固定长度的，但它有 varlena 格式。
- en: TOAST table
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TOAST 表
- en: Each table has 0 or 1 TOAST table and TOAST index.
  id: totrans-1100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个表有 0 或 1 个 TOAST 表和 TOAST 索引。
- en: The TOAST table and its index are created in CREATE/ALTER TABLE if needed.
  id: totrans-1101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，TOAST 表及其索引将在 CREATE/ALTER TABLE 中创建。
- en: The TOAST table is pg_toast.pg_toast_<main_table_OID>.
  id: totrans-1102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TOAST 表是 pg_toast.pg_toast_<main_table_OID>。
- en: The TOAST index is pg_toast.pg_toast_<main_table_OID>_index.
  id: totrans-1103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TOAST 索引是 pg_toast.pg_toast_<main_table_OID>_index。
- en: The TOAST table's OID is stored in the table's pg_class.reltoastrelid.
  id: totrans-1104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TOAST 表的 OID 存储在表的 pg_class.reltoastrelid 中。
- en: The TOAST index's OID is stored in the TOAST table's pg_class.reltoastidxid.
  id: totrans-1105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TOAST 索引的 OID 存储在 TOAST 表的 pg_class.reltoastidxid 中。
- en: 'Every TOAST table has these columns:'
  id: totrans-1106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 TOAST 表都有这些列：
- en: 'chunk_id OID: an OID identifying the particular TOASTed value'
  id: totrans-1107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: chunk_id OID：标识特定的 TOASTed 值
- en: 'chunk_seq int: a sequence number for the chunk within its value'
  id: totrans-1108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: chunk_seq int：值内块的序列号
- en: 'chunk_data bytea: the actual data of the chunk'
  id: totrans-1109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: chunk_data bytea：块的实际数据
- en: Primary key (chunk_id, chunk_seq)
  id: totrans-1110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键（chunk_id，chunk_seq）
- en: How TOAST works
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TOAST 如何工作
- en: It's triggered only when a row value to be stored in a table is wider than 2
    KB (when the page size is 8 KB).
  id: totrans-1112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当要存储在表中的行值宽于 2 KB（当页面大小为 8 KB 时）时才会触发。
- en: Compresses and/or moves column values to the TOAST table, until the row value
    is shorter than 2 KB (when the page size is 8 KB) or no more gains can be had.
    This 2 KB threshold can be adjusted for each table using the storage parameter
    toast_tuple_target in CREATE/ALTER TABLE.
  id: totrans-1113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩和/或将列值移动到 TOAST 表，直到行值短于 2 KB（当页面大小为 8 KB 时）或无法获得更多收益为止。可以使用 CREATE/ALTER
    TABLE 中的存储参数 toast_tuple_target 来调整每个表的此 2 KB 阈值。
- en: Stores the TOASTed value's chunk_id in the main table's column. This is called
    a TOAST pointer.
  id: totrans-1114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将TOAST值的chunk_id存储在主表的列中。这称为TOAST指针。
- en: The value storage strategy - whether it should be compressed or moved to the
    TOAST table - can be chosen from four options using `ALTER TABLE ALTER COLUMN
    column_name SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }`
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`ALTER TABLE ALTER COLUMN column_name SET STORAGE { PLAIN | EXTERNAL | EXTENDED
    | MAIN }`从四个选项中选择值存储策略——是否应该压缩或移动到TOAST表中。
- en: The compression method can be chosen between pglz and lz4\. It can be set for
    each column by using the COMPRESSION column option in CREATE/ALTER TABLE or otherwise
    the default_toast_compression parameter.
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩方法可以在pglz和lz4之间选择。它可以通过在CREATE/ALTER TABLE中使用COMPRESSION列选项为每个列设置，否则使用default_toast_compression参数。
- en: Insertion of a TOASTed value could become unsurprisingly slow.
  id: totrans-1117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TOAST值的插入可能会变得出奇的慢。
- en: This tends to be seen when the target table already has millions of TOASTed
    values, particularly after inserting lots of rows in succession.
  id: totrans-1118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种情况通常在目标表已经拥有数百万个TOAST值后出现，特别是在连续插入大量行之后。
- en: Why?
  id: totrans-1119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么？
- en: Each TOASTed value is identified by an OID.
  id: totrans-1120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个TOAST值都由一个OID标识。
- en: OID is an unsigned 4-byte value, which is generated from a cluster-wide counter
    that wraps around every 4 billion values. Therefore, a single table cannot have
    more than 2^32 (4 billion) TOASTed values.
  id: totrans-1121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OID是一个无符号4字节值，它是从每40亿个值都会环绕的群集范围计数器生成的。因此，单个表不能有超过2^32（40亿）个TOAST值。
- en: When inserting a TOASTed value, PostgreSQL generates a new OID for it, checks
    if an existing TOASTed value in the target table already uses the same OID. If
    it's used, PostgreSQL generates the next OID and perform the check again. This
    is repeated until a free OID is found.
  id: totrans-1122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当插入一个TOAST值时，PostgreSQL为其生成一个新的OID，检查目标表中是否已经使用了相同的OID的现有TOAST值。如果已使用，PostgreSQL将生成下一个OID并再次执行检查。直到找到一个空闲的OID。
- en: If successive OIDs are used in the target table, this retry takes a long time.
  id: totrans-1123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标表中使用连续的OID，则此重试会花费很长时间。
- en: The remedy is to partition the table. Each partition has its own TOAST table.
    Thus, the likelihood of duplicate OID in each partition is reduced.
  id: totrans-1124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方法是对表进行分区。每个分区都有自己的TOAST表。因此，每个分区中重复OID的可能性降低了。
- en: Transaction
  id: totrans-1125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事务
- en: Killed (dead) index tuples can give mysterious query speedup
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 被杀死（死掉）的索引元组可能会使查询速度奇怪地加快
- en: If you encounter varying execution times for the same execution plan of the
    same query, that may be thanks to killed index tuples.
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在相同查询的相同执行计划中遇到不同的执行时间，可能是由于被杀死的索引元组。
- en: Whenever an index scan fetches a heap tuple only to find that it is dead, it
    marks the index tuple as killed (dead). Then future index scans will ignore it.
    This avoids its index key comparison as well as its heap tuple fetch.
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当索引扫描获取一个堆元组，只发现它已经死掉时，它就会将索引元组标记为被杀死的（死掉的）。然后，将来的索引扫描将会忽略它。这样可以避免其索引键比较以及其堆元组获取。
- en: Subtransactions can be harmful
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 子事务可能会有害
- en: A subtransaction is a part of a transaction that can be rolled back without
    rolling back the main (top-level) transaction.
  id: totrans-1130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子事务是事务的一部分，可以回滚而不回滚主（顶级）事务。
- en: A subtransaction is started explicitly by a SAVEPOINT command, or implicitly
    when you enter a block with an EXCEPTION clause in PL/pgSQL.
  id: totrans-1131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子事务可以由SAVEPOINT命令显式启动，也可以在PL/pgSQL中进入带有EXCEPTION子句的块时隐式启动。
- en: Some client drivers provide an option to start and end a subtransaction for
    every SQL statement, such as PgJDBC's connection parameter "autosave". Watch out
    for their default values.
  id: totrans-1132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些客户端驱动程序提供了一个选项，可以为每个SQL语句启动和结束一个子事务，例如PgJDBC的连接参数“autosave”。要注意它们的默认值。
- en: Each subtransaction allocates its own XID when it performs an operation that
    needs an XID, such as modifying data or locking a row.
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个子事务在执行需要XID的操作时（例如修改数据或锁定行）都会分配自己的XID。
- en: The tuple header's xmin and xmax fields record the XID of the subtransaction
    that updated it. For checking tuple visibility, a transaction that sees the xmin/xmax
    needs to know whether the main transaction, not the subtransaction, has ended.
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组头的xmin和xmax字段记录了更新它的子事务的XID。为了检查元组的可见性，看到xmin/xmax的事务需要知道主事务是否已经结束，而不是子事务。
- en: 'How to know the main transaction of a subtransaction:'
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何知道子事务的主事务：
- en: When a subtransaction assigns its XID, it records its direct parent's XID in
    $PGDATA/pg_subtrans/.
  id: totrans-1136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当子事务分配其XID时，它会在$PGDATA/pg_subtrans/中记录其直接父项的XID。
- en: The structure of pg_subtrans is an array of XIDS. For example, the parent XID
    of XID 100 is stored in the 101st element of the array. The array is divided into
    8 KB pages.
  id: totrans-1137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_subtrans的结构是XIDS数组。 例如，XID 100的父XID存储在数组的第101个元素中。 数组分为8 KB页面。
- en: The pg_subtrans data is cached in a memory area of 32 pages. The area is managed
    by SLRU (simple least-recently used) buffers. So, The cache can contain 32 pages
    * 8 KB / 4 = 65,536 transactions.
  id: totrans-1138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_subtrans数据被缓存在32页的内存区域中。 该区域由SLRU（简单最近未使用）缓冲区管理。 因此，缓存可以包含32页 * 8 KB / 4
    = 65,536个事务。
- en: Therefore, to get the main transaction's XID, as many entries as the subtransaction
    nesting depth need to be traversed.
  id: totrans-1139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，为了获取主事务的XID，需要遍历与子事务嵌套深度相同的条目数。
- en: Is pg_subtrans always examined for tuple visibility?
  id: totrans-1140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_subtrans是否总是用于元组可见性的检查？
- en: No. A snapshot stores not only main transactions' XIDs but also subtransactions'
    XIDs. If the checker's snapshot contains all subtransactions, it can get the job
    done without consulting pg_subtrans.
  id: totrans-1141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不。 快照不仅存储主事务的XID，还存储子事务的XID。 如果检查者的快照包含所有子事务，则可以在不查阅pg_subtrans的情况下完成工作。
- en: However, that's not always the case. Each backend can have at most 64 subtransaction
    XIDs in its ProcArray entry in shared memory. If the main transaction has more
    than 64 subtransactions, its ProcArray entry is marked overflowed.
  id: totrans-1142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，情况并非总是如此。 每个后端最多可以在共享内存中的ProcArray条目中具有64个子事务XID。 如果主事务有超过64个子事务，则其ProcArray条目将被标记为溢出。
- en: When creating a snapshot, the ProcArray entries of all running transactions
    are scanned to collect the XIDs of main and sub transactions. If any entry is
    marked overflowed, the snapshot is marked suboverflowed.
  id: totrans-1143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建快照时，扫描所有运行中事务的ProcArray条目，以收集主事务和子事务的XID。 如果任何条目被标记为溢出，则将快照标记为子溢出。
- en: A suboverflowed snapshot does not contain all data required to determine visibility,
    so the tuple's xmin/xmax must be traced back to their top-level transaction XID
    using pg_subtrans.
  id: totrans-1144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子溢出的快照不包含确定可见性所需的所有数据，因此必须使用pg_subtrans将元组的xmin/xmax追溯到它们的顶层事务XID。
- en: So, what's the problem?
  id: totrans-1145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以，问题是什么？
- en: The readers of pg_subtrans contend for lwlocks to protect the SLRU buffers with
    the writers, who register their parents' XID. The reader and writer takes Share
    and Exclusive mode locks respectively.
  id: totrans-1146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_subtrans的读取器与写入器竞争lwlocks以保护SLRU缓冲区，读取器和写入器分别以共享模式和独占模式锁定其父级的XID。
- en: The pg_subtrans cache is not so big. Under many concurrent subtransactions,
    disk I/O arise.
  id: totrans-1147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_subtrans缓存不是很大。 在许多并发子事务中，会出现磁盘I/O。
- en: How can I know the possibility of this happening?
  id: totrans-1148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我怎样才能知道这种情况发生的可能性？
- en: The wait events LWLock:SubtransBuffer, LWLock:SubtransSLRU, IO:SLRURead, and
    IO:SLRUWrite keep growing.
  id: totrans-1149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待事件LWLock:SubtransBuffer，LWLock:SubtransSLRU，IO:SLRURead和IO:SLRUWrite不断增长。
- en: '[pg_stat_slru](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-SLRU-VIEW)
    shows increasing blks_read and blks_hit in its row for Subtrans. (PostgreSQL 13+)'
  id: totrans-1150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_stat_slru](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-SLRU-VIEW)显示其Subtrans行中的blks_read和blks_hit持续增加。（PostgreSQL
    13+）'
- en: pg_stat_get_backend_subxact(backend_id) returns subxact_count and subxact_overflow.
    (PostgreSQL 16+)
  id: totrans-1151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_stat_get_backend_subxact(backend_id)返回subxact_count和subxact_overflow。（PostgreSQL
    16+）
- en: MultiXact can harm performance under the hood
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，MultiXact可能会影响性能
- en: What is MultiXact?
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MultiXact是什么？
- en: A mechanism to record the XIDs of multiple lockers on a tuple. (Multi-transaction)
  id: totrans-1154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种记录元组上多个锁定者XID的机制。（多事务）
- en: The xmax field in the tuple header records the XID that locks the tuple.
  id: totrans-1155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组头中的xmax字段记录了锁定该元组的XID。
- en: Then, what happens when multiple transactions acquire locks on the same tuple?
  id: totrans-1156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，当多个事务在同一元组上获取锁时会发生什么？
- en: For example, the first transaction with XID 100 runs `SELECT ... FOR SHARE`.
    The xmax becomes 100.
  id: totrans-1157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，具有XID 100的第一个事务运行了`SELECT ... FOR SHARE`。 xmax变成了100。
- en: Next, the second transaction with XID 101 runs the same `SELECT ... FOR SHARE`
    on the same tuple. Then, a new MultiXact ID, say 1, is allocated and set to the
    xmax field.
  id: totrans-1158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，具有XID 101的第二个事务在相同的元组上运行相同的`SELECT ... FOR SHARE`。 然后，分配一个新的MultiXact ID，例如1，并设置为xmax字段。
- en: The mapping from MultiXact ID 1 to the actual lockers' XIDS (100, 101) is added
    in $PGDATA/pg_multixact/.
  id: totrans-1159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将MultiXact ID 1到实际锁定者的XIDS（100、101）的映射添加到$PGDATA/pg_multixact/中。
- en: The foreign key constraint is implemented as a constraint trigger that executes
    `"SELECT ... FOR KEY SHARE"`. Therefore, MultiXact may be used without your knowledge.
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外键约束实现为执行`"SELECT ... FOR KEY SHARE"`的约束触发器。 因此，可能在您不知情的情况下使用MultiXact。
- en: What could be the problem?
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题可能是什么？
- en: Like pg_subtrans, pg_multixact is cached through the SLRU. So, it can suffer
    from the lwlock contention and disk I/O.
  id: totrans-1162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像 pg_subtrans 一样，pg_multixact 也通过 SLRU 进行缓存。因此，它可能会受到 lwlock 争用和磁盘 I/O 的影响。
- en: When an XID is added as a new member of an existing MultiXact ID, a new MultiXact
    ID is allocated and existing member XIDs are copied to a new location. In the
    above example, when XID 102 joins MultiXact ID 1 with members (100, 101), MultiXact
    2 is newly allocated, (100, 101) are copied there, and 102 is added. If many transactions
    lock the same row concurrently, this copy gets heavier.
  id: totrans-1163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个 XID 被添加为现有 MultiXact ID 的新成员时，将分配一个新的 MultiXact ID，并将现有成员 XID 复制到新位置。在上面的例子中，当
    XID 102 加入具有成员（100、101）的 MultiXact ID 1 时，将新分配 MultiXact 2，将（100、101）复制到那里，并添加
    102。如果许多事务同时锁定同一行，则此复制变得更加重要。
- en: How can I know the possibility of this happening?
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我怎么知道这种情况发生的可能性？
- en: The wait events LWLock:MultiXact*, IO:SLRURead, and IO:SLRUWrite keep growing.
  id: totrans-1165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待事件 LWLock:MultiXact*、IO:SLRURead 和 IO:SLRUWrite 不断增加。
- en: '[pg_stat_slru](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-SLRU-VIEW)
    shows increasing blks_read and blks_hit in its rows for MultiXactOffset and MultiXactMember.
    (PostgreSQL 13+)'
  id: totrans-1166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pg_stat_slru](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-SLRU-VIEW)
    在其行中显示了 MultiXactOffset 和 MultiXactMember 的 blks_read 和 blks_hit 的增加。 (PostgreSQL
    13+)'
- en: pg_get_multixact_members('<MultiXact ID>') returns a set of member XIDs and
    their lock modes.
  id: totrans-1167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg_get_multixact_members('<MultiXact ID>') 返回一个成员 XID 及其锁模式的集合。
- en: WAL and checkpoint
  id: totrans-1168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WAL 和检查点
- en: Overview of checkpoint
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点概述
- en: A processing to synchronize data both in memory and on storage by flushing unwritten
    (=dirty) cached data.
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过刷新未写入（=脏）缓存数据，同步内存和存储中的数据的处理。
- en: When is it performed?
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么时候执行？
- en: The time specified by checkpoint_timeout has passed since the last checkpoint.
  id: totrans-1172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自上次检查点以来已经经过了由 checkpoint_timeout 指定的时间。
- en: A certain amount of WAL has accumulateed, which is based on max_wal_size.
  id: totrans-1173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 max_wal_size 累积了一定数量的 WAL。
- en: At the start of a base backup (pg_basebackup, pg_backup_start()).
  id: totrans-1174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基本备份开始时（pg_basebackup，pg_backup_start()）。
- en: Shutting down the database instance.
  id: totrans-1175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭数据库实例。
- en: Completing any form of recovery.
  id: totrans-1176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成任何形式的恢复。
- en: Other miscellaneous required timings such as CREATE DATABASE, so that data files
    can be copied/moved without going through shared buffers.
  id: totrans-1177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他杂项所需的时间，例如 CREATE DATABASE，以便数据文件可以在不经过共享缓冲区的情况下被复制/移动。
- en: The checkpoint caused by checkpoint_timeout is called a scheduled checkpoint,
    while others are called a requested checkpoint.
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 checkpoint_timeout 引起的检查点称为计划检查点，而其他检查点称为请求检查点。
- en: When finishing a checkpoint, old WAL segment files are removed or recycled as
    new WAL segment files for future reuse, based on min_wal_size.
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成检查点时，旧的 WAL 段文件将被删除或回收为新的 WAL 段文件以供将来重用，基于 min_wal_size。
- en: Here, "old" means "no longer necessary for crash recovery because all the changes
    in those WAL segments have been persisted to data files."
  id: totrans-1180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，“旧的”意味着“不再需要用于崩溃恢复，因为这些 WAL 段中的所有更改都已经持久化到数据文件中”。
- en: However, old WAL segment files are kept until they are archived and no longer
    needed by wal_keep_size or any replication slots.
  id: totrans-1181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，旧的 WAL 段文件会保留，直到它们被归档并且不再被 wal_keep_size 或任何复制插槽所需。
- en: 'Checkpoint is intrusive because:'
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查点是侵入式的，因为：
- en: Storage I/O contention, for both data and WAL.
  id: totrans-1183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储 I/O 争用，对于数据和 WAL 都是如此。
- en: 'Buffer content lock lwlock contention: While the checkpointer is flushing a
    shared buffer with its buffer content lock held in Share mode, a transaction that
    modifies the same buffer, which requires an Exclusive lock, needs to wait for
    the lwlock to be released.'
  id: totrans-1184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区内容锁 lwlock 争用：当检查点正在以共享模式持有其缓冲区内容锁并刷新共享缓冲区时，修改相同缓冲区的事务需要独占锁，并且需要等待 lwlock
    被释放。
- en: WAL volume increase due to full page writes.
  id: totrans-1185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于完整页写入，WAL 体积增加。
- en: What is full page writes?
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是完整页写入？
- en: During the first modification to each data page after a checkpoint, the entire
    page content is WAL-logged instead of just the change. This is necessary to recover
    a torn page during recovery.
  id: totrans-1187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检查点之后对每个数据页进行首次修改时，整个页面内容都会被 WAL 记录，而不仅仅是更改部分。这对于在恢复期间恢复破损的页面是必要的。
- en: A torn page can result if the host crashes while PostgreSQL is writing a page.
    Because the atomic unit of I/O is usually smaller (say, 512 byte disk sector)
    than the PostgreSQL page size (commonly 8 KB), it could be possible that part
    of a page is new and the other is old.
  id: totrans-1188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在 PostgreSQL 写入页面时主机崩溃，则可能会导致页面破损。因为 I/O 的原子单位通常比 PostgreSQL 页面大小小（例如，512
    字节的磁盘扇区），所以可能会出现页面的一部分是新的而另一部分是旧的。
- en: Reducing the impact of checkpoints
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 减少检查点的影响
- en: Monitor the frequency of checkpoints
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控检查点的频率。
- en: The number of scheduled and requested checkpoints can be seen by checkpoints_timed
    and checkpoints_req respectively in [pg_stat_bgwriter](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-BGWRITER-VIEW).
  id: totrans-1191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度和请求的检查点数量分别可以在[pg_stat_bgwriter](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-BGWRITER-VIEW)中的checkpoints_timed和checkpoints_req中查看。
- en: The vast majority of checkpoints should be scheduled rather than requested.
    Scheduled checkpoints allow the load to be evenly spread throughout the normal
    operation of the system. Frequent requested checkpoints are likely to cause variations
    in performance.
  id: totrans-1192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝大部分检查点应该是计划的，而不是请求的。计划的检查点允许负载均匀分布在系统的正常操作中。频繁的请求检查点可能导致性能变化。
- en: The server log shows the following messages, if the elapsed time between two
    successive checkpoints is shorter than checkpoint_warning and the newer one is
    requested by WAL accumulation.
  id: totrans-1193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个连续检查点之间的经过时间小于checkpoint_warning，并且新的检查点是由WAL积累请求的，则服务器日志会显示以下消息。
- en: '`LOG: checkpoints are occurring too frequently (8 seconds apart)`'
  id: totrans-1194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOG:检查点发生得太频繁（相隔8秒）`'
- en: '`HINT: Consider increasing the configuration parameter "max_wal_size".`'
  id: totrans-1195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`提示：考虑增加配置参数“max_wal_size”。`'
- en: Lower the frequency of checkpoints by increasing max_wal_size and/or checkpoint_timeout.
  id: totrans-1196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加max_wal_size和/或checkpoint_timeout来降低检查点的频率。
- en: Note that this can increase the amount of time needed for crash recovery.
  id: totrans-1197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，这可能会增加崩溃恢复所需的时间。
- en: Set wal_compression to on. This reduces the WAL for full page writes.
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将wal_compression设置为on。这会减少对全页写入WAL的需求。
- en: Increase min_wal_size. This reduces the need for transactions to create new
    WAL segment files.
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加min_wal_size。这减少了事务创建新WAL段文件的需求。
- en: Index
  id: totrans-1200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引
- en: Disadvantages of indexes
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的缺点
- en: Indexes consume disk space.
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引会消耗磁盘空间。
- en: Larger disk space increases the size and duration of physical backups.
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更大的磁盘空间会增加物理备份的大小和持续时间。
- en: Indexes slow down INSERT/DELETE/COPY statements because they always have to
    modify all indexes.
  id: totrans-1204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引会减慢INSERT/DELETE/COPY语句，因为它们总是要修改所有索引。
- en: Indexes prevent HOT updates. HOT works only for modifications to non-indexed
    columns.
  id: totrans-1205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引会阻止HOT更新。HOT仅适用于对非索引列的修改。
- en: Benefits of indexes you might not notice
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有注意到的索引好处
- en: B-tree indexes can speed up the max() and min() aggregates. They can just read
    the index entries at the end of the index.
  id: totrans-1207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B-tree索引可以加速max()和min()聚合。它们只需在索引的末尾读取索引条目。
- en: Indexes on expressions also gather statistics on the calculated values of the
    expression.
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式上的索引也会收集计算值的统计信息。
- en: ex. `CREATE INDEX myindex1 ON mytable ((col1 + col2 * 3));`
  id: totrans-1209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：`CREATE INDEX myindex1 ON mytable ((col1 + col2 * 3));`
- en: You can see the statistics of indexed expressions. For example, in the above
    case, the statistics appear in pg_stats as tablename=myindex1 and attname=expr.
  id: totrans-1210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以查看索引表达式的统计信息。例如，上述情况中，统计信息出现在pg_stats中，tablename=myindex1，attname=expr。
- en: The statistics target can be set for indexed expressions. e.g., `ALTER INDEX
    index_name ALTER COLUMN expr SET STATISTICS 1000;`
  id: totrans-1211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对索引表达式可以设置统计目标。例如，`ALTER INDEX index_name ALTER COLUMN expr SET STATISTICS 1000;`
- en: Indexes on foreign keys speed up constraint processing.
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外键上的索引可以加快约束处理的速度。
- en: ex. `CREATE TABLE orders (..., product_id int REFERENCES products ON CASCADE
    DELETE);`
  id: totrans-1213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：`CREATE TABLE orders (...，product_id int REFERENCES products ON CASCADE DELETE);`
- en: You can see the time taken for the constraint cascade processing with EXPLAIN
    ANALYZE and auto_explain. Foreign key constraints are implemented using triggers
    internally.
  id: totrans-1214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用EXPLAIN ANALYZE和auto_explain来查看约束级联处理所用的时间。外键约束在内部使用触发器实现。
- en: ex. `EXPLAIN ANALYZE DELETE FROM products WHERE product_id = 2;`
  id: totrans-1215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：`EXPLAIN ANALYZE DELETE FROM products WHERE product_id = 2;`
- en: '... `Trigger for constraint orders_product_id_fkey: time=0.322 calls=1`'
  id: totrans-1216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...`约束orders_product_id_fkey的触发器：时间=0.322 调用=1`'
- en: Making an index-only scan work
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 使索引只扫描起作用
- en: 'Use EXPLAIN ANALYZE to see how many times the index-only scan had to read the
    heap. For example, it shows something like "Heap Fetches: 0". 0 is the best.'
  id: totrans-1218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EXPLAIN ANALYZE查看索引只扫描需要读取堆的次数。例如，它显示类似于“堆抓取：0”。0是最好的。
- en: Make autovacuum more aggressive or run VACUUM to update the visibility map.
    That would reduce the heap fetches.
  id: totrans-1219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将autovacuum设置得更积极一些，或者运行VACUUM来更新可见性地图。这会减少堆抓取。
- en: Query planning
  id: totrans-1220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询计划
- en: Pitfalls of ANALYZE
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: ANALYZE的风险
- en: Autovacuum does not run ANALYZE on temporary tables or foreign tables. Manually
    ANALYZE them.
  id: totrans-1222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autovacuum不会在临时表或外部表上运行ANALYZE。需要手动运行ANALYZE。
- en: The query plan can change after ANALYZE even when the table content hasn't changed.
  id: totrans-1223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使表内容没有更改，ANALYZE 之后也可能会改变查询计划。
- en: ANALYZE takes a random sample of the table contents (300 x default_statistics_target
    rows). Hence, the collected statistics can vary depending on which rows are read.
  id: totrans-1224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ANALYZE 获取表内容的随机样本（300 x 默认统计目标行）。因此，收集的统计信息可能会因读取的行而异。
- en: 'To avoid or reduce this query plan variance, do either of:'
  id: totrans-1225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要避免或减少此查询计划变化，请执行以下操作之一：
- en: Fix the query plan using third-party software like pg_hint_plan.
  id: totrans-1226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像 pg_hint_plan 这样的第三方软件修复查询计划。
- en: Raise the amount of statistics collected by ANALYZE, i.e., `ALTER TABLE ...
    ALTER COLUMN ... SET STATISTICS`. The more rows are used, the less the statistics
    fluctuation would be. However, this will make the ANALYZE and query planning slower
    because more statistics are written or read.
  id: totrans-1227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高 ANALYZE 收集的统计信息量，即 `ALTER TABLE ... ALTER COLUMN ... SET STATISTICS`。使用的行数越多，统计数据波动就越小。但是，这会使
    ANALYZE 和查询规划变慢，因为写入或读取的统计数据更多。
- en: Set the table's storage parameters autovacuum_analyze_threshold and autovacuum_analyze_scale_factor
    to large values, so that autovacuum won't practically ANALYZE it. Then, do manual
    ANALYZE if needed.
  id: totrans-1228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表的存储参数 autovacuum_analyze_threshold 和 autovacuum_analyze_scale_factor 设置为较大的值，以便
    autovacuum 几乎不会 ANALYZE 它。然后，如果需要，进行手动 ANALYZE。
- en: Use of a set-returning function could lead to a poor query plan
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用返回集函数可能导致查询计划不佳
- en: This is likely to be observed when the function is used to filter rows in WHERE
    clause or join.
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当函数用于 WHERE 子句或连接中过滤行时，可能会观察到这种情况。
- en: That's because the planner does not have reasonably accurate information about
    selectivity. Thus, its cost estimate would be inaccurate.
  id: totrans-1231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是因为规划器没有关于选择性的合理准确信息。因此，其成本估算将不准确。
- en: CREATE/ALTER FUNCTION can set a fixed cost and the number of rows it returns.
    The planner support function given by the SUPPORT clause, which needs to be written
    in C, can change the cost and rows dynamically.
  id: totrans-1232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CREATE/ALTER FUNCTION 可以设置固定的成本和返回的行数。SUPPORT 子句提供的规划器支持函数，需要用 C 编写，可以动态更改成本和行数。
- en: '`CREATE FUNCTION ... RETURNS {SETOF ... | TABLE(...)} COST execution_cost ROWS
    result_rows SUPPORT support_function`'
  id: totrans-1233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE FUNCTION ... RETURNS {SETOF ... | TABLE(...)} COST execution_cost ROWS
    result_rows SUPPORT support_function`'
- en: Custom plan and generic plan
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义计划和通用计划
- en: PREPARE performs parse, analysis, and rewrite to generate a prepared statement.
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PREPARE 执行解析、分析和重写以生成准备好的语句。
- en: ex. `PREPARE stmt(int) AS SELECT * FROM mytable WHERE col = $1;`
  id: totrans-1236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如 `PREPARE stmt(int) AS SELECT * FROM mytable WHERE col = $1;`
- en: EXECUTE makes a query plan and execute it.
  id: totrans-1237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EXECUTE 制定查询计划并执行它。
- en: A query plan that takes specific parameter values into account is the best.
    Such plans are called a custom plan. On the other hand, a query plan that doesn't
    consider parameter values is called a generic plan.
  id: totrans-1238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑特定参数值的查询计划是最好的。这种计划称为自定义计划。另一方面，不考虑参数值的查询计划称为通用计划。
- en: You can tell a custom plan from a generic plan by the presence of a placeholder.
    For instance,
  id: totrans-1239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过占位符的存在，你可以区分自定义计划和通用计划。例如，
- en: 'Custom plan: `Filter: (col = 123)`'
  id: totrans-1240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '自定义计划：`Filter: (col = 123)`'
- en: 'Generic plan: `Filter: (col = $1)`'
  id: totrans-1241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '通用计划：`Filter: (col = $1)`'
- en: But planning is costly. If the generic plan is good enough, PostgreSQL uses
    it to avoid making custom plans.
  id: totrans-1242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是规划是昂贵的。如果通用计划足够好，PostgreSQL 会使用它来避免制定自定义计划。
- en: PostgreSQL uses a custom plan for the first five executions of a prepared statement.
  id: totrans-1243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 在准备语句的前五次执行中使用自定义计划。
- en: On the sixth execution, a generic plan is generated, and its cost is compared
    with the average cost of the past five executions.
  id: totrans-1244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第六次执行时，将生成一个通用计划，并将其成本与过去五次执行的平均成本进行比较。
- en: If the cost of the generic plan is cheaper, it continues to adopt it. Custom
    plans won't be considered.
  id: totrans-1245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通用计划的成本更低，则会继续采用它。不会考虑自定义计划。
- en: Otherwise, a new custom plan is created and used. On subsequent executions,
    the cost of the generic plan is compared with the average cost of all past executions
    of custom plans, and whichever is cheaper is chosen.
  id: totrans-1246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将创建并使用新的自定义计划。在后续的执行中，将通用计划的成本与所有过去自定义计划执行的平均成本进行比较，并选择较低者。
- en: You can force a generic or custom plan by setting plan_cache_mode to force_generic_plan
    or force_custom_plan respectively. This might be necessary to force custom plans,
    if the cost estimate of the generic plan is underestimated.
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过将 plan_cache_mode 设置为 force_generic_plan 或 force_custom_plan 来强制使用通用计划或自定义计划。如果通用计划的成本估计过低，则可能需要强制使用自定义计划。
- en: References
  id: totrans-1248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考资料
- en: PostgreSQL Documentation
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 文档
- en: Many connections
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 多连接
- en: Detecting problems
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 问题检测
- en: Memory
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 存储器
- en: Storage
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 存储
- en: Network
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 网络
- en: Table layout
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 表格布局
- en: SQL tricks
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 技巧
- en: Transaction
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 事务
- en: HOT
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 热度优化（HOT）
- en: WAL and checkpoint
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: WAL 和检查点
- en: Lock
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定
- en: Index
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: Query planning
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 查询规划
- en: Join
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 连接
- en: Logging
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录
- en: Parallel query
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 并行查询
- en: Import and export
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 导入和导出
- en: Foreign Data Wrapper (FDW)
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 外部数据包装器（FDW）
- en: Trigger
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器
- en: Full text search
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 全文搜索
- en: Utility
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 实用性
