<!--yml

类别：未分类

日期：2024-05-27 15:01:21

-->

# 在已有 C++、D 和 Rust 的情况下为什么选择 Zig？⚡ Zig 编程语言

> 来源：[`ziglang.org/learn/why_zig_rust_d_cpp/`](https://ziglang.org/learn/why_zig_rust_d_cpp/)

# 在已有 C++、D 和 Rust 的情况下为什么选择 Zig？

## 没有隐藏的控制流

如果 Zig 代码看起来没有跳转来调用函数，那就是确实没有。这意味着你可以确信以下代码只调用了`foo()`然后是`bar()`，而且无需知道任何东西的类型：

```
var a = b + c.d;
foo();
bar(); 
```

隐藏控制流的示例：

+   D 语言有`@property`函数，这些是你使用看起来像字段访问的方式调用的方法，所以在上面的例子中，`c.d`可能会调用一个函数。

+   C++、D 和 Rust 都有运算符重载，所以`+`运算符可能会调用一个函数。

+   C++、D 和 Go 都有抛出/捕获异常，所以`foo()`可能会抛出异常，并阻止`bar()`被调用。（当然，即使在 Zig 中，`foo()`可能会死锁并阻止`bar()`被调用，但这在任何图灵完备的语言中都可能发生。）

这个设计决策的目的是提高可读性。

## 没有隐藏的分配

Zig 在堆分配方面采取了一种不干涉的方法。没有`new`关键字或者任何其他使用堆分配器的语言特性（比如字符串连接运算符[1]）。堆的整个概念由库和应用代码管理，而不是由语言管理。

隐藏分配的示例：

+   Go 的`defer`会为函数局部栈分配内存。除了这种控制流方式让人难以理解之外，如果你在循环中使用`defer`，还可能导致内存不足错误。

+   C++协程分配堆内存以调用协程。

+   在 Go 中，函数调用可能会导致堆分配，因为 goroutine 会分配小堆栈，当调用栈足够深时会调整大小。

+   主要的 Rust 标准库 API 在内存不足的情况下会 panic，而接受分配器参数的备选 API 是事后想到的（参见[rust-lang/rust#29802](https://github.com/rust-lang/rust/issues/29802)）。

几乎所有的垃圾收集语言都有隐藏的分配，因为垃圾收集器在清理时隐藏了证据。

隐藏分配的主要问题是它阻止了代码片段的*可重用性*，不必要地限制了代码适用的环境数量。简单来说，有些用例必须依赖于控制流和函数调用没有内存分配的副作用，因此只有在编程语言可以真正提供此保证时，它才能为这些用例提供服务。

在 Zig 中，有一些标准库特性提供并与堆分配器一起工作，但这些是可选的标准库特性，而不是内置于语言本身的。如果你从未初始化堆分配器，那么你可以确信你的程序不会堆分配。

每个需要分配堆内存的标准库功能都接受一个 `Allocator` 参数来完成。这意味着 Zig 标准库支持独立的目标。例如 `std.ArrayList` 和 `std.AutoHashMap` 可以用于裸金属编程！

自定义分配器使手动内存管理变得轻而易举。Zig 具有维护内存安全性的调试分配器，以防止使用后释放和双重释放。它自动检测并打印内存泄漏的堆栈跟踪。有一个区域分配器，使您可以将任意数量的分配绑定到一个分配中，而不是独立管理每个分配。特定目的的分配器可以用于改进特定应用程序的性能或内存使用情况。

[1]: 其实有一个字符串连接运算符（通常是数组连接运算符），但它只在编译时工作，因此仍然不会进行任何运行时堆分配。

## 一流的无标准库支持

如上所示，Zig 有一个完全可选的标准库。只有在使用它时，每个 std lib API 才会编译到您的程序中。Zig 对链接到 libc 或不链接到它具有相等的支持。Zig 对裸金属和高性能开发友好。

这是两全其美的最佳选择；例如在 Zig 中，WebAssembly 程序既可以使用标准库的常规功能，又可以与其他支持编译到 WebAssembly 的编程语言相比产生最小的二进制文件。

## 用于库的可移植语言

编程的至高境界之一是代码重用。不幸的是，在实践中，我们发现自己一次又一次地重新发明轮子。通常这是有道理的。

+   如果一个应用程序有实时要求，那么任何使用垃圾收集或任何其他非确定性行为的库都会被淘汰为依赖项。

+   如果一种语言使忽略错误变得太容易，从而难以验证库是否正确处理并传播错误，那么忽略库并重新实现它可能是诱人的，因为您知道已正确处理了所有相关的错误。Zig 的设计使得程序员能够正确处理错误成为最懒惰的事情，因此可以合理地相信库将正确地传播错误。

+   目前实际上可靠的是，C 是最通用和可移植的语言。任何不具备与 C 代码交互能力的语言都面临被遗忘的风险。Zig 正试图成为新的可移植库语言，通过同时使得符合 C ABI 用于外部函数变得直观，并引入安全性和语言设计，防止实现中的常见错误。

## 现有项目的包管理器和构建系统

Zig 是一个工具链，也是一种编程语言。它提供了一个构建系统和包管理器，即使在传统的 C/C++ 项目中也很有用。

使用 Zig 代码而不是 C 或 C++ 代码编写，还可以将 Zig 用作 autotools、cmake、make、scons、ninja 等的替代品。此外，它还提供了本地依赖项的包管理器。即使项目的整个代码库都是 C 或 C++，这种构建系统也是合适的。例如，通过[将 ffmpeg 移植到 zig 构建系统](https://github.com/andrewrk/ffmpeg)，可以在任何支持的系统上编译 ffmpeg，而且仅需使用 50 MiB 的 zig 下载即可。对于开源项目来说，这种简化的从源代码构建能力 - 甚至跨平台编译 - 可能是获得或失去宝贵贡献者的区别所在。

apt-get、pacman、homebrew 等系统包管理器对用户体验至关重要，但对开发者的需求可能不够。语言特定的包管理器可以决定是否有贡献者。对于开源项目来说，使项目能够构建起来的难度对潜在贡献者来说是一个巨大的障碍。对于 C/C++ 项目，具有依赖关系可能是致命的，尤其是在 Windows 上，那里没有包管理器。即使只是构建 Zig 本身，大多数潜在贡献者也会遇到 LLVM 依赖的困难。Zig 提供了一种方式，让项目直接依赖本地库 - 而不依赖用户的系统包管理器是否有正确版本可用，而且这种方式几乎保证能够在第一次尝试时成功构建项目，无论使用什么系统和独立于目标平台。

**其他语言有包管理器，但它们不能像 Zig 一样消除讨厌的系统依赖。**

Zig 可以用具有声明性 API 的合理语言替换项目的构建系统，还提供了包管理，因此可以依赖其他 C 库。具有依赖关系的能力使高级抽象变得可能，从而推动了可重用的高级代码的传播。

## 简单明了

C++、Rust 和 D 有大量特性，可能会分散注意力，导致你在调试编程语言的知识而不是调试应用程序本身。

Zig 没有宏，但仍然足够强大，可以以清晰、不重复的方式表达复杂的程序。即使 Rust 有像`format!`这样的特殊情况宏，它也是在编译器自身实现的。与此同时，在 Zig 中，等效的函数是在标准库中实现的，没有编译器中的特殊情况代码。

可从下载部分下载 Zig。Zig 提供 Linux、Windows 和 macOS 的二进制存档。以下描述了这些存档之一的内容：

+   通过下载和提取单个存档进行安装，无需系统配置

+   静态编译，因此没有运行时依赖

+   支持在优化的发布构建中使用 LLVM，同时在更快的编译性能方面使用 Zig 的自定义后端

+   另外支持输出 C 代码的后端

+   开箱即用，可交叉编译到大多数主要平台

+   随附支持 libc 的源代码，在任何支持的平台上需要时会动态编译

+   包含具有并发和缓存功能的构建系统

+   编译带有 libc 支持的 C 和 C++ 代码

+   使用 `zig cc` 兼容 GCC/Clang 命令行

+   Windows 资源编译器
