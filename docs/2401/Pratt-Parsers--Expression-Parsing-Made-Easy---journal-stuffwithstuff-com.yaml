- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:57:55'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Pratt Parsers: Expression Parsing Made Easy – journal.stuffwithstuff.com'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/](https://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Every now and then, I stumble onto some algorithm or idea that’s so clever
    and such a perfect solution to a problem that I feel like I got smarter or gained
    [a new superpower](http://xkcd.com/208/) just by learning it. [Heaps](http://en.wikipedia.org/wiki/Heap_%28data_structure%29)
    were one, just about the only thing I got out of my truncated CS education. I
    recently stumbled onto another: [Pratt](http://en.wikipedia.org/wiki/Vaughan_Pratt)
    or “top-down operator precedence” parsers.'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re writing a parser, [recursive descent](http://en.wikipedia.org/wiki/Recursive_descent)
    is as easy as spreading peanut butter. It excels when you can figure out what
    to parse based on the next bit of code you’re looking at. That’s usually true
    at the declaration and statement levels of a language’s grammar since most syntax
    there starts with keywords—`class`, `if`, `for`, `while`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing gets trickier when you get to expressions. When it comes to infix operators
    like `+`, postfix ones like `++`, and even mixfix expressions like `?:`, it can
    be hard to tell what kind of expression you’re parsing until you’re halfway through
    it. You *can* do this with recursive descent, but it’s a chore. You have to write
    separate functions for each level of precedence (JavaScript has 17 of them, for
    example), manually handle associativity, and smear your grammar across a bunch
    of parsing code until it’s hard to see.
  prefs: []
  type: TYPE_NORMAL
- en: Peanut butter and jelly, the secret weapon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pratt parsing solves that. If recursive descent is peanut butter, Pratt parsing
    is the jelly. When you mix the two together, you get a simple, terse, readable
    parser that can handle any grammar you throw at it.
  prefs: []
  type: TYPE_NORMAL
- en: Pratt’s technique for handling operator precedence and infix expressions is
    so simple and effective it’s a mystery why almost no one knows about it. After
    the seventies, top down operator precedence parsers seem to have fallen off the
    Earth. Douglas Crockford’s [JSLint](http://www.jslint.com/) uses one to [parse
    JavaScript](http://crockford.com/javascript/tdop/tdop.html), but his treatment
    is one of the [very few](http://effbot.org/zone/simple-top-down-parsing.htm) remotely
    modern articles about it.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the problem, I think, is that Pratt’s terminology is opaque, and Crockford’s
    article is itself rather murky. Pratt uses terms like “null denominator” and Crockford
    mixes in extra stuff like tracking lexical scope that obscures the core idea.
  prefs: []
  type: TYPE_NORMAL
- en: This is where I come in. I won’t do anything revolutionary. I’ll just try to
    get the core concepts behind top down operator precedence parsers and present
    them as clearly as I can. I’ll switch out some terms to (I hope) clarify things.
    Hopefully I won’t offend anyone’s purist sensibilities. I’ll be coding in Java,
    the vulgar Latin of programming languages. I figure if you can write it in Java,
    you can write it in anything.
  prefs: []
  type: TYPE_NORMAL
- en: What we’ll be making
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’m a learn-by-doing person, which means I’m also a teach-by-doing one. So to
    show how Pratt parsers work, we’ll build a parser for a [tiny little toy language
    called *Bantam*](https://github.com/munificent/bantam). The language only has
    expressions since that’s where Pratt parsing is really helpful, but that should
    be enough to convince you of its usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though Bantam is simple, it has a full gamut of operators: prefix (`+`,
    `-`, `~`, `!`), postfix (`!`), infix (`+`, `-`, `*`, `/`, `^`), and even a mixfix
    conditional operator (`?:`). It has multiple precedence levels and both right
    and left associative operators. It also has assignment, function calls and parentheses
    for grouping. If we can parse this, we can parse anything.'
  prefs: []
  type: TYPE_NORMAL
- en: What we’ll start with
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All we care about is parsing, so we’ll ignore the tokenizing phase. I slapped
    together [a crude lexer](https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Lexer.java)
    that works and we’ll just pretend that tokens are raining down from heaven or
    something.
  prefs: []
  type: TYPE_NORMAL
- en: 'A token is the smallest chunk of meaningful code. It has a type and a string
    associated with it. Given `from + offset(time)`, the tokens would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For this exercise, we won’t be *interpreting* or *compiling* this code. We
    just want to parse it to a nice data structure. For our purposes, that means our
    parser should chew up a bunch of [Token](https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Token.java)
    objects and spit out an instance of some class that implements [Expression](https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/expressions/Expression.java).
    To give you an idea, here’s a simplified version of the class for a [conditional
    expression](https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/expressions/ConditionalExpression.java):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: (You gotta love Java’s “please sign it in quadruplicate” level of bureaucracy
    here. Like I said, if you can tolerate this in Java, it can work in *any* language.)
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start from a simple [Parser](https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Parser.java)
    class. The parser owns the token stream, handles lookahead and provides the basic
    methods you need to write a top-down recursive descent parser with a single token
    of lookahead (it’s [LL(1)](https://en.wikipedia.org/wiki/LL_parser)). This is
    enough to get us going. If we need more later, it’s easy to extend it.
  prefs: []
  type: TYPE_NORMAL
- en: OK, let’s build ourselves a parser!
  prefs: []
  type: TYPE_NORMAL
- en: First things first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though a “full” Pratt parser is pretty tiny, I found it to be hard to decipher.
    Sort of like [quicksort](http://en.wikipedia.org/wiki/Quicksort), the implementation
    is a deceptively simple handful of deeply intertwined code. To untangle it, we’ll
    build it up one tiny step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest expressions to parse are prefix operators and single-token expressions.
    For those, the current token tells us everything we need to do. Bantam has one
    single-token expression: named variables. It has four prefix operators: `+`, `-`,
    `~`, and `!`. The simplest possible code to parse those is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But that’s a bit monolithic. As you can see, we’re switching off of a TokenType
    to branch to different parsing behavior. Let’s encode that directly by making
    a Map from TokenTypes to chunks of parsing code. We’ll call these chunks “parselets”,
    and they will implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'An parselet implementation to parse variable names is simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a single class for all of the prefix operators since they only differ
    in the actual operator token itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You’ll note that it calls back into `parseExpression()` to parse the operand
    that appears after the operator (for example, to parse the `a` in `-a`). This
    recursion takes care of nested operators like `-+~!a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in Parser, the chained `if` statements are replaced with a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To define the grammar we have so far—variables and the four prefix operators—we’ll
    add these helper methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can define the grammar like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is already an improvement over a recursive descent parser because our grammar
    is now more declarative instead of being spread out over a few imperative functions,
    and we can see the actual grammar all in one place. Even better, we can extend
    the grammar just by registering new parselets. We don’t have to change the Parser
    class itself.
  prefs: []
  type: TYPE_NORMAL
- en: If we *only* had prefix expressions, we’d be done now. Alas, we don’t.
  prefs: []
  type: TYPE_NORMAL
- en: Stuck in the middle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have so far only works if the *first* token tells us what kind of expression
    we’re parsing, but that isn’t always the case. With an expression like `a + b`,
    we don’t know we have an add expression until after we parse the `a` and get to
    `+`. We have to extend the parser to support that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we’re in a good place to do so. Our current `parseExpression()`
    method parses a complete prefix expression including any nested prefix expressions
    and then stops. So, if we throw this at it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will parse `-a` and leave us sitting on `+`. That’s exactly the token we
    need to tell what infix expression we need to parse. Compared to prefix parsing,
    the only change for infix parsing is that there’s another expression *before*
    the infix operator that the infix parser receives as an argument. Let’s define
    a parselet that supports that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that `left` argument, which is the expression we parsed
    before we got to the infix token. We wire this up to our parser by having another
    table of infix parselets.
  prefs: []
  type: TYPE_NORMAL
- en: Having separate tables for prefix and infix expressions is important because
    we sometimes have both a prefix and infix parselet for the same TokenType. For
    example, the prefix parselet for `(` handles grouping in an expression like `a
    * (b + c)`. Meanwhile, the *infix* parselet for `(` handles function calls like
    `a(b)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after we parse the leading prefix expression, we look for an infix parser
    that matches the next token and wraps the prefix expression as an operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty straightforward. We can implement an infix parselet for binary arithmetic
    operators like `+` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Infix parselets also works for postfix operators. I’m calling them “infix”,
    but they’re really “anything but prefix”. If there’s some leading subexpression
    that comes before the token, the token will be handled by an infix parselet. That
    includes postfix expressions and mixfix ones like `?:`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Postfix expressions are as simple as single-token prefix parselets: they just
    take the `left` operand and wraps it in another expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Mixfix is easy too. It’s similar to recursive descent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can parse prefix, postfix, infix, and even mixfix expressions. With
    a pretty small amount of code, we can parse complex nested expressions like `a
    + (b ? c! : -d)`. We’re done, right? Well… almost.'
  prefs: []
  type: TYPE_NORMAL
- en: Excuse you, aunt Sally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our parser *can* parse all of this stuff, but it doesn’t parse it with the right
    precedence or associativity. If you throw `a - b - c` at the parser, it will parse
    the nested expressions like `a - (b - c)`, which isn’t right. (Well, actually
    it is *right*—associative that is. We need it to be *left*.)
  prefs: []
  type: TYPE_NORMAL
- en: And this *last* step where we fix that is where Pratt parsers go from pretty
    nice to totally radical. We’ll make two simple changes. We extend `parseExpression()`
    to take a *precedence*—a number that tells which expressions can be parsed by
    that call. If `parseExpression()` encounters an expression whose precedence is
    lower than we allow, it stops parsing and returns what it has so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make that check we need to know the precedence of any given infix expression.
    We’ll let the parselet specify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using that, our core expression parser looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That relies on a tiny helper function to get the precedence of the current
    token or a default value if there’s no infix parselet for the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s it. To wire precedence into Bantam’s grammar, we set up a little
    precedence table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To make our operators parse their operands with the correct precedence, they
    pass an appropriate value back into `parseExpression()` when they call it recursively.
    For example, the [BinaryOperatorParselet](https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/parselets/BinaryOperatorParselet.java)
    instance that handles the `+` operator passes in `Precedence.SUM` when it parses
    its right-hand operand.
  prefs: []
  type: TYPE_NORMAL
- en: Associativity is easy too. If an infix parselet calls `parseExpression()` with
    the *same* precedence that it returns for its own `getPrecedence()` call, you
    get left associativity. To be right-associative, it just needs to pass in *one
    less* than that instead.
  prefs: []
  type: TYPE_NORMAL
- en: Go forth and multiply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve rewritten the [parser for Magpie](https://github.com/munificent/magpie/blob/master/src/com/stuffwithstuff/magpie/parser/MagpieParser.java)
    using this and it worked like a charm. I’m also working on a JavaScript parser
    using this technique and again it’s been a great fit.
  prefs: []
  type: TYPE_NORMAL
- en: I Pratt parsers to be simple, terse, extensible (Magpie, for example, uses this
    to [let you extend its own syntax](/2011/02/13/extending-syntax-from-within-a-language/)
    at runtime), and easy to read. I’m at the point where I can’t imagine writing
    a parser any other way. I never thought I’d say this, but parsers feel easy now.
  prefs: []
  type: TYPE_NORMAL
- en: To see for yourself, just take a look at [the complete program](https://github.com/munificent/bantam).
  prefs: []
  type: TYPE_NORMAL
