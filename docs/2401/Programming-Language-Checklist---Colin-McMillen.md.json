["```\nYou appear to be advocating a new:\n[ ] functional  [ ] imperative  [ ] object-oriented  [ ] procedural [ ] stack-based\n[ ] \"multi-paradigm\"  [ ] lazy  [ ] eager  [ ] statically-typed  [ ] dynamically-typed\n[ ] pure  [ ] impure  [ ] non-hygienic  [ ] visual  [ ] beginner-friendly\n[ ] non-programmer-friendly  [ ] completely incomprehensible\nprogramming language.  Your language will not work.  Here is why it will not work.\n\nYou appear to believe that:\n[ ] Syntax is what makes programming difficult\n[ ] Garbage collection is free                [ ] Computers have infinite memory\n[ ] Nobody really needs:\n    [ ] concurrency  [ ] a REPL  [ ] debugger support  [ ] IDE support  [ ] I/O\n    [ ] to interact with code not written in your language\n[ ] The entire world speaks 7-bit ASCII\n[ ] Scaling up to large software projects will be easy\n[ ] Convincing programmers to adopt a new language will be easy\n[ ] Convincing programmers to adopt a language-specific IDE will be easy\n[ ] Programmers love writing lots of boilerplate\n[ ] Specifying behaviors as \"undefined\" means that programmers won't rely on them\n[ ] \"Spooky action at a distance\" makes programming more fun\n\nUnfortunately, your language (has/lacks):\n[ ] comprehensible syntax  [ ] semicolons  [ ] significant whitespace  [ ] macros\n[ ] implicit type conversion  [ ] explicit casting  [ ] type inference\n[ ] goto  [ ] exceptions  [ ] closures  [ ] tail recursion  [ ] coroutines\n[ ] reflection  [ ] subtyping  [ ] multiple inheritance  [ ] operator overloading\n[ ] algebraic datatypes  [ ] recursive types  [ ] polymorphic types\n[ ] covariant array typing  [ ] monads  [ ] dependent types\n[ ] infix operators  [ ] nested comments  [ ] multi-line strings  [ ] regexes\n[ ] call-by-value  [ ] call-by-name  [ ] call-by-reference  [ ] call-cc\n\nThe following philosophical objections apply:\n[ ] Programmers should not need to understand category theory to write \"Hello, World!\"\n[ ] Programmers should not develop RSI from writing \"Hello, World!\"\n[ ] The most significant program written in your language is its own compiler\n[ ] The most significant program written in your language isn't even its own compiler\n[ ] No language spec\n[ ] \"The implementation is the spec\"\n   [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you\n[ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed\n   [ ] a proof of same is attached\n   [ ] invoking this proof crashes the compiler\n[ ] The name of your language makes it impossible to find on Google\n[ ] Interpreted languages will never be as fast as C\n[ ] Compiled languages will never be \"extensible\"\n[ ] Writing a compiler that understands English is AI-complete\n[ ] Your language relies on an optimization which has never been shown possible\n[ ] There are less than 100 programmers on Earth smart enough to use your language\n[ ] ____________________________ takes exponential time\n[ ] ____________________________ is known to be undecidable\n\nYour implementation has the following flaws:\n[ ] CPUs do not work that way\n[ ] RAM does not work that way\n[ ] VMs do not work that way\n[ ] Compilers do not work that way\n[ ] Compilers cannot work that way\n[ ] Shift-reduce conflicts in parsing seem to be resolved using rand()\n[ ] You require the compiler to be present at runtime\n[ ] You require the language runtime to be present at compile-time\n[ ] Your compiler errors are completely inscrutable\n[ ] Dangerous behavior is only a warning\n[ ] The compiler crashes if you look at it funny\n[ ] The VM crashes if you look at it funny\n[ ] You don't seem to understand basic optimization techniques\n[ ] You don't seem to understand basic systems programming\n[ ] You don't seem to understand pointers\n[ ] You don't seem to understand functions\n\nAdditionally, your marketing has the following problems:\n[ ] Unsupported claims of increased productivity\n[ ] Unsupported claims of greater \"ease of use\"\n[ ] Obviously rigged benchmarks\n   [ ] Graphics, simulation, or crypto benchmarks where your code just calls\n       handwritten assembly through your FFI\n   [ ] String-processing benchmarks where you just call PCRE\n   [ ] Matrix-math benchmarks where you just call BLAS\n[ ] Noone really believes that your language is faster than:\n    [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog\n[ ] Rejection of orthodox programming-language theory without justification\n[ ] Rejection of orthodox systems programming without justification\n[ ] Rejection of orthodox algorithmic theory without justification\n[ ] Rejection of basic computer science without justification\n\nTaking the wider ecosystem into account, I would like to note that:\n[ ] Your complex sample code would be one line in: _______________________\n[ ] We already have an unsafe imperative language\n[ ] We already have a safe imperative OO language\n[ ] We already have a safe statically-typed eager functional language\n[ ] You have reinvented Lisp but worse\n[ ] You have reinvented Javascript but worse\n[ ] You have reinvented Java but worse\n[ ] You have reinvented C++ but worse\n[ ] You have reinvented PHP but worse\n[ ] You have reinvented PHP better, but that's still no justification\n[ ] You have reinvented Brainfuck but non-ironically\n\nIn conclusion, this is what I think of you:\n[ ] You have some interesting ideas, but this won't fly.\n[ ] This is a bad language, and you should feel bad for inventing it.\n[ ] Programming in this language is an adequate punishment for inventing it.\n\n```"]