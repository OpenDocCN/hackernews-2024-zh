<!--yml

类别：未分类

日期：2024-05-27 14:25:27

-->

# 白象游戏出奇的有效

> 来源：[`bobbiec.github.io/white-elephant.html`](https://bobbiec.github.io/white-elephant.html)

人们喜爱的[白象礼物交换游戏](https://zh.wikipedia.org/wiki/%E7%99%BD%E8%B1%A1%E7%A4%BC%E7%89%A9%E4%BA%A4%E6%8D%A2)在社交场合备受喜爱，原因显而易见：不用压力地找到完美的礼物，社交上可以接受的偷窃癖，还有多汁但暂时的戏剧性。

但如果我告诉你，这也是一种非常高效的方式来分发一堆礼物，以便每个人都会喜欢自己的礼物呢？玩白象游戏可能会在下个圣诞季节为你节省数亿小时。

只需看看输入：几份礼物，以及每个玩家对这些礼物的价值。输出是什么？将礼物分配给人的任务。如果你仔细看，白象游戏显然是一种资源分配算法。但它有多有效呢？

你怎么知道白象游戏是否能很好地给人们喜欢的礼物？我别无选择，只能花费几天时间模拟白象游戏，检查它到底有多好。

## 规则刷新

每个人玩的这个游戏的变化略有不同，所以这是我使用的规则集的复习。

在白象游戏中，几个人聚在一起。每个人带来一份礼物，每个人将带回一份（可能不同的）礼物。

1.  在第一轮中，一人选择一份礼物并展示出来。

1.  在接下来的回合中：

1.  一个人选择并揭示一个新礼物，或者

1.  一个人偷走之前某人已揭示的礼物。

1.  被偷的人现在必须选择一个新的礼物，或者偷一个已经打开的礼物。

1.  被偷的人不能立即偷回相同的礼物。

1.  每个礼物只能被偷三次（不包括初始揭示）。

1.  游戏持续直到所有礼物都被揭示。

## 我们如何知道游戏的结果是“好”的？

我们还需要为“好的”白象游戏结果定义一些标准。

每个玩家都有自己对哪种礼物（或多种）更喜欢的偏好；换句话说，同一份礼物可以（并且通常是）由每个玩家以不同的方式价值化。让我们把那个价值定义为从 0 到 100 的数字，其中 100 是最好的礼物。游戏结束时，每个玩家都将获得一份礼物和相应的 0 到 100 的价值。

有很多可能的“好”的定义，任何哲学家都会告诉你。对于一个游戏最终结果（将礼物分配给玩家）是否比另一个结果更好，做出判断是否傲慢？把梦幻塔罗作为永恒的链锁在岩石上，强迫你决定推车是撞你的肝还是你的两个肾？

不管怎样，我将专注于三个好处的度量标准。

+   **幸福总和**：经典功利主义的做法。团体的幸福等于每个玩家的幸福之和。

+   **帕累托最优性**：如果没有一种结果使每个人都更幸福，那么结果就是帕累托最优的。换句话说，所有其他分配都会导致至少有一个人不那么开心，因此没有机会进行“免费午餐”式的改进。

+   **前 k 个选择**：如果足够多的人得到他们的前 k 个偏好之一，那么结果是好的。如果一个人的前 1 个选择是他们的最爱，那么他们得到他们的前 1 个选择，如果它在他们的两个最高偏好中，则得到前 2 个选择，依此类推。对于给定的分配，你可以计算每个 k 中有多少玩家得到他们的前 k 个选择。

## 我们如何知道白象游戏在产生良好结果方面是否“好”？

虽然**幸福总和**和**前 k 个选择**可以很容易地计算出来（而**帕累托最优性**需要更多的努力），但查看单个游戏的最终结果对于了解白象游戏在所有可能的分配和偏好宇宙中的好坏并没有任何帮助。

例如，让我们来玩一个 2 名玩家的游戏，其中玩家 1 和玩家 2 都非常想要礼物 A（价值=100），而不在乎礼物 B（价值=0）。无论谁得到礼物，我们最终都得到以下结果：

+   **幸福总和**：100 + 0 = 100。

+   **帕累托最优性**：真：你不能交换礼物 A 而不使原来的所有者不高兴。

+   **前 k 个选择**：

    +   前 1 名：1 名玩家（谁得到礼物 A）

    +   前 2 名：2 名玩家（对于 N 名玩家的游戏，前 N 名总是 N）

因此，在这个玩具示例中，100 是一个好的总和吗？这是任意的，因为我们知道另一种结果是相同的。Top-1 为 1 好还是不好？不好，除了同样是任意的之外，它还完全由礼物偏好确定。而且我们只能因为玩家数量太少而确信地说出这一点。

对于更大的游戏，我真的想知道，相对于其他可能的结果，它有多好？如果我们查看了对一组礼物偏好的每个排列，白象游戏是否比平均水平更好？

## 方法论

为了回答这些问题，我用 Python 编写了一个白象游戏模拟。

对于一个有*N*名玩家的游戏，有*N*个礼物。每个玩家对这些礼物有不同的随机偏好，范围从 0 到 100（包括 0 和 100）。

遵循上述规则，在每个玩家的回合中，使用~~生成式人工智能~~以下过程做出决策：

1.  检查已经揭示的礼物，并找到价值最高的可用礼物。如果该值大于或等于 50，则窃取它。

1.  如果没有，那意味着当前没有可窃取的好礼物。揭示一个新礼物，希望一切顺利。

游戏结束后，计算上述好处的措施。

幸福总和和前 k 个选择很容易从最终分配中计算出来。对于帕累托最优性，我们采取了蛮力方法：对于所有可能的礼物和玩家排列，检查是否有任何排列对所有玩家都比白象游戏结果更好。

由于我们已经生成了所有排列，我们也可以计算每个排列的幸福总和。我们可以按幸福总和对结果排列，并找出我们的白象游戏结果确切的位置。

### 示例游戏

例如，在一个 4 人游戏中，对于给定的玩家偏好，有 4! = 24 种可能的结果。让我们看一个特定的偏好设置。

| 玩家 | 礼物 A | 礼物 B | 礼物 C | 礼物 D |
| --- | --- | --- | --- | --- |
| 1 | 49 | 97 | 53 | 5 |
| 2 | 33 | 65 | 62 | 51 |
| 3 | 100 | 38 | 61 | 45 |
| 4 | 74 | 27 | 64 | 17 |

在这个表格中，单元格代表玩家对该礼物的价值，例如，玩家 1 认为礼物 A 值 49，玩家 2 认为同样的礼物 A 值 33，依此类推。

根据这些起始条件模拟白象游戏的结果如下：

**白象游戏结果（总和=283）**

| 玩家 | 礼物 A | 礼物 B | 礼物 C | 礼物 D |
| --- | --- | --- | --- | --- |
| 1 | 49 | 97 | 53 | 5 |
| 2 | 33 | 65 | 62 | 51 |
| 3 | 100 | 38 | 61 | 45 |
| 4 | 74 | 27 | 64 | 17 |

这种结果的总幸福值为 97 + 51 + 61 + 74 = 283。前 k 个结果：

+   前一名：2 (P1，P4 得到了他们的首选)

+   前两名：3 (P3 得到他们的第二选择，而 P1+P4 得到了更好的结果)

+   前三名：4 (P2 得到他们的第三选择 - 完成)

粗略估计，这看起来相当不错。但有更好的东西吗？

借助蛮力的力量，我们可以将其与其他一些情景进行比较 - 结果是，是的，存在更好的结果！也有远远更糟糕的结果...

**蛮力法最佳（总和=312）**

| 玩家 | 礼物 A | 礼物 B | 礼物 C | 礼物 D |
| --- | --- | --- | --- | --- |
| 1 | 49 | 97 | 53 | 5 |
| 2 | 33 | 65 | 62 | 51 |
| 3 | 100 | 38 | 61 | 45 |
| 4 | 74 | 27 | 64 | 17 |

**蛮力法最差（总和=126）**

| 玩家 | 礼物 A | 礼物 B | 礼物 C | 礼物 D |
| --- | --- | --- | --- | --- |
| 1 | 49 | 97 | 53 | 5 |
| 2 | 33 | 65 | 62 | 51 |
| 3 | 100 | 38 | 61 | 45 |
| 4 | 74 | 27 | 64 | 17 |

白象游戏结果在所有 24 种可能性中排名第二。请注意，即使上面的“最佳”结果总和更高，但它并不是白象游戏结果的帕累托改进，因为玩家 4 在从礼物 A 切换到礼物 C 时损失了 10 点价值。

单独考虑 24 种情况中的 2 种是很容易理解的，但是当我们考虑到游戏中参与玩家数量不同时，情况就变得更加混乱，因为最差的可能排名会基于玩家数量(*N!*)而变化。我们将它们转换为百分位数，以便更容易比较：白象游戏比 24 种结果中的 23 种都好，所以它是 23 除以 24 = ~95th 百分位数。

最后，为了考虑玩家偏好的影响，我们进行了多次试验，使用随机偏好设置进行了 10000 次模拟，对组大小进行了范围从 2（因为它很简单）到 9（因为这是我笔记本电脑可以在合理时间内完成的最大数量）的模拟。

## 预测

在我们继续之前，先猜一猜：白象游戏有多好？

+   白象游戏结果有多频繁地达到 99 分位数（前 1%）的潜在结果，在幸福值的总和方面？

    +   关于 50 分位数（高于平均水平）怎么样？

+   白象游戏结果多频繁地达到帕累托最优？

+   在一个 *N* 人游戏中，有多少人得到了他们的第一（top-1）选择？

我会给你一个提示：这些答案会根据 *N*，也就是玩家数量而变化。知道了这一点，最后一个问题是：从 *N*=2 到 *N*=9，你的预测有何变化？

## 初步分析

以下图表展示了 1 万场白象模拟游戏的排名百分位分布。每个柱子代表了 1%的可能结果，右边是最好的。每场游戏都是一个数据点，并且这些数据被分成百分位数 - 每个柱子代表了 1%的可能结果，左边是最好的。

在这个关于 5 人游戏的第一个图表中，你可以看到在一组起始偏好中有 120 种可能的结果。在不同偏好设置下进行了 1 万场白象游戏后，大约有 14%（七分之一）的游戏最终进入了 99 分位数（前 1%）的可能结果！

*注意：在手机上阅读这些图表可能有些困难，抱歉 - 试试旋转屏幕可能会有帮助。*

你可以点击上面的箭头查看基于 *N* 的分布如何变化。去吧，我会等你的。

……这不是太好，有点令人惊讶吧？我检查了一遍我的代码，因为这似乎太美好而令人难以置信。（而且我还发布了一些非常丑陋的[源代码](https://github.com/bobbiec/white-elephant)，所以如果有什么问题，请告诉我！）

你还可以看到绝大多数的结果都是帕累托最优的 - 对于更高的 *N* 来说，这个数字越来越少。随着玩家数量的增加，似乎会收敛到 1%的顽固的非最优结果（尽管我不知道为什么）。

Top-k 实际上是 N 种不同的分布，因此在这里显示为箱形图。每个分布的平均值都以黑色虚线表示：

这算好吗？最初，我不知道如何解释它 - 在一个 9 人游戏中平均有 6.5 人得到他们的前 3 个礼物似乎相当不错，但我真的不知道什么是可能的。现在回想起来，为了更好地理解，我们可能需要对预期的独特偏好数量进行一些更多的数学计算，这取决于偏好是如何生成的。

考虑到最佳的情况。当每个人都得到他们的最佳礼物时，最好的可能结果就会发生。但是多个人可能会想要相同的最佳礼物，因此重叠的偏好会降低最佳的 top-1。那么独特顶级偏好的预期值是多少？

由于偏好是随机的，每个人应该有同等机会选择任何特定礼物作为他们的最爱（...我认为）。 这对应于生日问题：在一个有 N 个人的房间里，至少有两个人共享一个~~生日~~最喜欢的礼物的概率是多少？ 维基百科给出了一个封闭形式的解决方案，用于[至少有一个生日的天数](https://en.wikipedia.org/wiki/Birthday_problem#Number_of_days_with_at_least_one_birthday)，这使我们可以建立以下表格。 （将公式扩展到前 k 个礼物留给读者作为练习。）

**预期的唯一 top-1 礼物**

| 玩家数量 | 独特礼物数量 |
| --- | --- |
| 2 | 1.5 |
| 3 | 2.1 |
| 4 | 2.7 |
| 5 | 3.3 |
| 6 | 4 |
| 7 | 4.6 |
| 8 | 5.3 |
| 9 | 5.9 |

看起来在顶部还有改进的空间：白象游戏似乎在任何给定 N 的理想 top-1 的 50%左右。 我可以检查数据，看看它是否与这些预测的理想 top-1 值相匹配，但我正在快速接近我自我设定的截止日期，所以让我们去...

## 直觉和改进空间

虽然我以为它会很好，但我没有想到会*这么*好。 但这是有道理的！

让我们从前 k 开始。 人们应该得到一个在他们的偏好中位于前列的礼物：这直接融入了算法中，因为玩家将偷取最佳可用的礼物。

实际上，根据定义，一个好的 top-k 很可能有一个好的幸福总和：更多的人得到他们喜欢的东西，这对应于更高的总分数。

同样，帕累托最优性是非常可能的，因为玩家会偷取最佳可用的礼物。 如果你看到一个非最优的结果，这意味着没有玩家——应该交换的玩家能够偷取他们喜欢的礼物（因为它尚未被揭示，或者因为它已经达到了最大偷取次数）。

*(顺便说一句：top-1 = *N*，其中每个人都得到他们最喜欢的礼物，相当于[无嫉妒](https://en.wikipedia.org/wiki/Envy-freeness)在公平分配问题中；这在白象游戏中是不太可能的，因为每个人必须拿走一个礼物。)*

现在，对好处感到满意后，我想了解更多有关不良情况的情况——这些表现不佳的白象游戏中发生了什么？

我浏览了几场表现不佳的游戏的日志，并注意到一个模式：这些游戏发生在第一个玩家（有时是接下来的几个玩家）透露出他们不喜欢的礼物，然后...他们只能与之一直困在一起。 他们永远没有机会偷取，因为没有人从他们那里偷取，他们只会在更好的礼物被揭示时受苦。

我意识到我错过了一个关键（也很普遍的）规则：**第一个玩家在游戏结束时有机会交换！** 这消除了一种常见的“卡住”的方式，并且确保了在最后被偷走的人有机会以全面了解可能性的方式偷回他们最喜欢的可用礼物（因为现在所有的礼物都被揭示了）。

在草率地编写这个规则并修复错误后，我再次运行了我的模拟，看看它如何改变了结果。

## 添加“最后偷取”规则

看一下比较：这明显地将分布向右移动，无论玩家数量如何。在下面的图表中，原始规则集的结果为红色，而添加“最后偷取”规则的结果显示为蓝色。

Pareto 最优性和 top-k 也得到了改善。使用“最后偷取”规则，Pareto 最优性收敛到非最优游戏的 0.5%：减少了 50%。top-k 也发生变化，以便更多人收到他们的首选。你已经看够了图表，所以我会为你节省（即：我在找借口避免更多的绘图）。

不错。我们已经确定了“最后偷取”规则改善了游戏的结果，这意味着如果你还没有使用它，你应该在自己的游戏中采用它。如果你需要向某人证明它，只需发送给他们这个链接。

所以现在我们知道白象游戏是一种产生相当好结果的算法，而且比蛮力算法需要的努力要少得多。究竟少了多少努力？

## 性能

为了对性能进行简要估算，我使用了内置的 Python 模块[cProfile](https://docs.python.org/3/library/profile.html)来了解模拟程序的不同部分花费了多少时间。请看下面生成的火焰图（使用[SnakeViz](https://jiffyclub.github.io/snakeviz/)生成）来查看一组 5 人游戏的结果。

在第二行（如果你能读到微小的文本），你可以看到蛮力算法（紫色）部分花费的时间比白象游戏本身（蓝色）稍微长一些。

我们可以深入研究哪些代码的“热点”区域花费了最多的时间。例如，白象游戏的灰色子块仅仅是在计算总分数，这发生在每位玩家的回合之后；我们可能通过仅在最后计算一次分数来改善时间。

现在让我们先专注于整体时间比较：对于 5 名玩家，运行时的差异不大。蛮力方法保证完美结果，只比玩白象游戏多花费 42%的时间。

但是随着玩家数量的增加，蛮力算法所需时间显著增加。看看这个愚蠢的图表：

尽管你实际上可以放大这些图表（使用[Plotly.js](https://plotly.com/javascript/)创建），但是看起来可能更容易查看对数刻度版本，该版本显示了蛮力方法的指数（实际上是阶乘）增长。与此同时，白象游戏以相对温和的增长率进行。

对于 9 人游戏，白象游戏运行速度约为 100 百万倍（文字意思为：10⁸），我们从排名分析中知道，99%的结果游戏属于可能结果的前 18%。对于加速效果来说，这个结果不错！对于更大的游戏，趋势指向更好的结果。

在我家今年的圣诞聚会上，我们进行了一个 21 人的白象游戏。我没有对此进行模拟，因为我希望在宇宙热死亡之前再次使用我的笔记本电脑，但我认为结果相对于所有可能的结果来说是好的。

## 注意事项

显然，这些模拟缺少了几个重要细节。以下是我想到的一些大问题：

+   101 分的刻度可能太细了 - 没有人在如此精确地评估价值。

+   这也意味着在更大的游戏中，可能存在帕累托最优性的样本大小问题，因为（随机的）玩家偏好可能会使帕累托最优性更有可能发生 - 记住上面的两个玩家示例，所有可能的结果都是帕累托最优的。

+   同样地，均匀随机的偏好看起来不太可能。我们以前都参加过游戏，其中有普遍受欢迎和不受欢迎的礼物（谢谢约翰尼）。

+   没有关于偷窃限制的策略：一个精明的玩家可能会推迟偷取他们最喜欢的物品，除非这样做会达到偷窃次数上限 - 否则它可能会再次被偷走。

+   没有代表玩家之间动态的表示：

    +   窃取满足感。去年，我的朋友杰克逊花了几分钟时间设置了一双发光手指无手套，我后来非常喜欢偷走它们（比起自己揭示手套来说更喜欢）。

    +   窃取内疚。在反向方向上，你可能会因为偷走别人显然喜欢的东西而感到内疚 - 即使它是你在可用礼物中的最爱。

    +   玩家之间的勾结。家庭成员或伴侣会（如果他们彼此友好）为了他们所爱的人而花费自己的机会来偷走礼物。Yee Aun 和我基本上合并了我们的偏好，这改变了我们看待可用物品的方式。

尽管如此，剖析当前的天真模拟也很有趣。

## 结论和下一步

白象游戏很好！可以衡量！

在这个项目的过程中，我花了比我预想的更多的时间思考白象游戏。另一方面，编写模拟和分析结果比基于规则对系统进行抽象推理要容易得多。

顺便说一句：白象算法感觉非常容易计算，作为一群真实生活中的人（*"设计非常人性化。"*）。规则和优先级足够简单，以便每个人能够实时快速做出决策，而不需要了解所有事情或基于其他人的偏好做出决策。相比之下，与一些其他算法相比，快速排序和归并排序是非常非人类的排序算法；通常人们在现实生活中做的更像是插入排序（如果有很多项目，可能会首先进行一轮基数/桶排序），因为合并和分区操作非常不自然。有人知道这种可以由人类实施的算法概念是否有名称吗？

回到白象交换活动：这个兔子洞非常深，我们还远远没有到底。有很多潜在的未来工作。除了上面的警告之外，还有一些更多的想法：

+   模拟给定偏好集合的所有可能白象交换活动的玩家顺序，因为这是一种路径相关的游戏。我怀疑这可能会对单个游戏产生很大影响，但对不同偏好集合的聚合结果实际上不会产生影响，因为已经是随机的了。

+   尝试其他规则变体，看看游戏如何变化：不同数量的最大偷取次数，或者首个玩家最终偷取可以忽略最大偷取次数的变体。这可能是一个确定规则集的好方法。

+   比较其他物品分配启发式算法的结果：例如，如果所有物品都是一开始就被揭示出来，玩家只是贪婪地选择自己喜欢的物品会怎样？白象交换活动可能是与暴力破解（以最昂贵的方式完成）相比的一个很好的近似值，但是 top-k 图表表明可能有更好的方法来满足人们的需求。

    +   编辑：感谢阿伦指出了最大（加权）二分匹配算法，这些算法可能比白象交换活动效率更高（如果不是更有趣的话）。这也唤起了我大学时代压抑的回忆：我实现了一个图像分割的图形算法，但是完成得非常接近截止日期，只能提交 100 张图片中的 2 张（教授给了我满分并认为这很有趣）。

我还觉得在浏览器中可视化和模拟单个游戏将会非常有趣，就像[Raft 可视化](https://raft.github.io/#raftscope)那样。作为调试的一部分，我有一些日志看起来是这样的：

```
  P1's turn!
    1 reveals Gift A
    Total score: 79 (+79)

  P2's turn!
    2 steals Gift A from 1 (steal count: 1)
    Total score: 83 (+4)

  P1's turn!
    1 reveals Gift B
    Total score: 115 (+32)

  P3's turn!
    3 steals Gift A from 2 (steal count: 2)
    Total score: 115 (+0)

```

想象一下，在玩家之间的礼物跳动并实时更新分数。然后你可以改变玩家决定偷取的方式，或者尝试不同的规则集，并看看它们对结果产生了什么影响。有任何合作者吗？

对于任何未来的工作，这是[GitHub 仓库](https://github.com/bobbiec/white-elephant)，其中包含模拟代码和一些有趣的分析和可视化。

祝节日快乐，并开始计划明年的白象交换活动！

-*鲍比和伊昂*

* * *

关于这个项目的更多思考在我的博客上：[白象交换活动和“固定时间、可变范围”](https://bobbiechen.com/blog/2024/1/30/white-elephant-and-fixed-time-variable-scope)。

*特别感谢[Frank Li](https://www.linkedin.com/in/frank-li-64b52316b)提供了许多想法、反馈和分析帮助。感谢阿伦和约翰尼的反馈。Favicon 图标是由[Nur Achmadi Yusuf](https://thenounproject.com/browse/icons/term/elephant/ "Elephant Icons")的作品（CC BY 3.0）提供。*
