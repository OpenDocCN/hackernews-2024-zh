["```\n0 = |f, x| x                             # f applied 0 times 1 = |f, x| f(x)                          # f applied 1 times 2 = |f, x| f(f(x))                       # f applied 2 times 3 = |f, x| f(f(f(x)))                    # f applied 3 times ...                                      # f applied . times n = |f, x| f( .. n - 2 more f's .. f(x)) # f applied n times \n```", "```\n0\\. 0 is a natural number. 1\\. The successor, S(n), of a natural number is a natural number. \n```", "```\n0 = 0 1 = S(0) 2 = S(1) = S(S(0)) 3.= S(2) = S(S(S(0))) ... n = S( .. n - 2 more S's .. S(0)) \n```", "```\nstruct Zero; struct Succ<T>(PhantomData<T>); \n```", "```\ntype One = Succ<Zero>; type Two = Succ<Succ<Zero>>; type Three = Succ<Succ<Succ<Zero>>>; ... \n```", "```\n#[macro_export] macro_rules! encode {\n () => { Zero }; ($_a:tt $($tail:tt)*) => {\n Succ<encode!($($tail)*)>\n }; } \n```", "```\n encode!(* ***) ^ these tokens correspond to $tail = Succ<encode!(* **)> = Succ<Succ<encode!(* *)>> = Succ<Succ<Succ<encode!(*)>>> = Succ<Succ<Succ<Succ<encode!()>>>>\n ^ input is empty, so encode!() expands to Zero = Succ<Succ<Succ<Succ<Zero>>>> \n```", "```\ntrait SpecialNumber {\n  const MAGIC: usize; }   impl SpecialNumber for Foo {\n  const MAGIC: usize = 13; }   impl SpecialNumber for Bar {\n  const MAGIC: usize = 29; } \n```", "```\ntrait Value {\n  const VALUE: usize; }   impl Value for Zero {\n  const VALUE: usize = 0; }   impl<T> Value for Succ<T> where T: Value {  const VALUE: usize = 1 + T::VALUE; } \n```", "```\ntrait Add {\n  type Sum; } \n```", "```\nimpl Add for (Zero, Zero) { // 0 + 0 = 0\n  type Sum = Zero; }   impl<T> Add for (Succ<T>, Zero) { // x + 0 = x\n  type Sum = Succ<T>; }   impl<T> Add for (Zero, Succ<T>) { // 0 + x = x\n  type Sum = Succ<T>; } \n```", "```\nimpl<T, U> Add for (Succ<T>, Succ<U>) where\n (T, Succ<Succ<U>>): Add, {\n  type Sum = <(T, Succ<Succ<U>>) as Add>::Sum; } \n```", "```\n Add<Succ<Succ<Zero>>, Succ<Succ<Zero>>> = Add<Succ<Zero>, Succ<Succ<Succ<Zero>>>> // move one Succ to the right = Add<Zero, Succ<Succ<Succ<Succ<Zero>>>>> // again = Succ<Succ<Succ<Succ<Zero>>>>>           // base case :) \n```", "```\ntrait Sub {\n  type Diff; }   impl Sub for (Zero, Zero) { // 0 - 0 = 0\n  type Diff = Zero; }   impl<T> Sub for (Succ<T>, Zero) { // x - 0 = x\n  type Diff = Succ<T>; }   impl<T> Sub for (Zero, Succ<T>) { // 0 - x = 0, we'll saturate\n  type Diff = Zero; } \n```", "```\nimpl<T, U> Sub for (Succ<T>, Succ<U>) where\n (T, U): Sub, {\n  type Diff = <(T, U) as Sub>::Diff; } \n```", "```\n5 [***] ** - 3 [***] = 2 [   ] ** \n```", "```\ntrait Mul {\n  type Product; }   impl<T> Mul for (T, Zero) { // x * 0 = 0\n  type Product = Zero; }   impl<T> Mul for (Zero, Succ<T>) { // 0 * x = 0\n  type Product = Zero; } \n```", "```\nimpl<T, U> Mul for (Succ<T>, Succ<U>) where\n (T, Succ<U>): Mul, (Succ<U>, <(T, Succ<U>) as Mul>::Product): Add, {\n  type Product = <(\n Succ<U>,                       // y <(T, Succ<U>) as Mul>::Product // (x - 1) * y ) as Add>::Sum; } \n```", "```\ntrait GreaterThanEq {\n  type Greater; }   impl GreaterThanEq for (Zero, Zero) { // 0 >= 0\n  type Greater = Succ<Zero>; }   impl<T> GreaterThanEq for (Zero, Succ<T>) { // 0 >!= { 1 .. }\n  type Greater = Zero; }   impl<T> GreaterThanEq for (Succ<T>, Zero) { // { 1 .. } >= 0\n  type Greater = Succ<Zero>; }   impl<T, U> GreaterThanEq for (Succ<T>, Succ<U>) where\n (T, U): GreaterThanEq, // x >= y -> x - 1 >= y - 1 {\n  type Greater = <(T, U) as GreaterThanEq>::Greater; } \n```", "```\ntrait Div {\n  type Quotient; }   impl<T> Div for (Zero, T) { // 0 / x = 0\n  type Quotient = Zero; }   impl<T> Div for (Succ<T>, Succ<Zero>) { // x / 1 = x\n  type Quotient = Succ<T>; } \n```", "```\ntype RawQuotient<T, U> = <(\n Succ<Zero>, // 1 <( <(Succ<T>, Succ<Succ<U>>) as Sub>::Diff, Succ<Succ<U>> ) as Div>::Quotient, // (x - y) / y ) as Add>::Sum; \n```", "```\n Case       Boolean of Gte       RawQuotient       Desired +--------+  +----------------+   +-------------+   +---------+ | x >= y |: |       1        | x |   nonzero   | = | nonzero | +--------+  +----------------+   +-------------+   +---------+ | x < y  |: |       0        | x |     ???     | = |    0    | +--------+  +----------------+   +-------------+   +---------+ \n```", "```\nimpl<T, U> Div for (Succ<T>, Succ<Succ<U>>) where\n (T, Succ<U>): Sub, (<(T, Succ<U>) as Sub>::Diff, Succ<Succ<U>>): Div, ( Succ<Zero>, <(<(T, Succ<U>) as Sub>::Diff, Succ<Succ<U>>) as Div>::Quotient, ): Add, ( <(Succ<T>, Succ<Succ<U>>) as GreaterThanEq>::Greater, <( Succ<Zero>, <(<(T, Succ<U>) as Sub>::Diff, Succ<Succ<U>>) as Div>::Quotient, ) as Add>::Sum, ): Mul, (Succ<T>, Succ<Succ<U>>): GreaterThanEq, {\n  // Hi I'm the important part\n  type Quotient = <(\n <(Succ<T>, Succ<Succ<U>>) as GreaterThanEq>::Greater, RawQuotient<T, U>, ) as Mul>::Product; } \n```"]