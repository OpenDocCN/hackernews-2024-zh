- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:28:33'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: RedTeam Pentesting - Blog - Bitwarden Heist - How to Break Into Password Vaults
    Without Using Passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.redteam-pentesting.de/2024/bitwarden-heist/](https://blog.redteam-pentesting.de/2024/bitwarden-heist/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3 January 2024
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bitwarden Heist - How to Break Into Password Vaults Without Using Passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, making particular security design decisions can have unexpected
    consequences. For security-critical software, such as password managers, this
    can easily lead to catastrophic failure: In this blog post, we show how [Bitwarden’s](https://bitwarden.com/)
    Windows Hello implementation allowed us to remotely steal all credentials from
    the vault without knowing the password or requiring biometric authentication.
    When we discovered this during a penetration test it was so unexpected for us
    that we agreed with our client to publish a blog post about it and tell the story.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The underlying issue has been corrected in Bitwarden v2023.4.0 in April 2023**
    (but the story is interesting nonetheless).'
  prefs: []
  type: TYPE_NORMAL
- en: Where We Started
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We recently conducted a penetration test with the goal of compromising the
    internal network of a client in a Windows environment. As usual, we managed to
    get administrative access to the domain controller, however, there was an additional
    hurdle: The backup server, one of the prioritized targets, did not reside within
    the domain. Having already gained access to Domain Administrator accounts, we
    decided to take a look around their Windows workstations in the hopes of uncovering
    information that would grant us access to the backup system. Looking at the workstations,
    we found that passwords seemed to be stored using Bitwarden (the following details
    apply to Version [Desktop v2023.3.0](https://github.com/bitwarden/clients/releases/tag/desktop-v2023.3.0)
    of the software). We made the assumption that credentials to the backup system
    might be found in the Bitwarden vault of the employees in charge of the IT infrastructure.
    After consulting with our client, we got the permission to attempt to retrieve
    the contents of one of these vaults. Since we did not want to potentially disrupt
    the client’s business by using invasive techniques such as key loggers to obtain
    access to the backup system, we looked for an unintrusive way without relying
    on end user interaction if possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first tried to crack the vault using simple credential stuffing attacks,
    however this remained unsuccessful, leading us to ultimately attempt a more creative
    approach. To further analyze the vault, we decided to download the main storage
    file of Bitwarden, in the hopes of finding anything of note. It is located under
    the user’s home directory at `%AppData%\Bitwarden\data.json`. Downloading the
    JSON file and opening it in a text editor already revealed an unexpected finding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It seemed that this Bitwarden vault could be opened using Biometrics, and Windows
    Hello in particular. We had the feeling that it might be worth looking at, so
    we decided to dig deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Biometric Unlock - How Does it Work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if biometrics are enabled, the vault still has a main password (Bitwarden
    calls it [master password](https://bitwarden.com/help/master-password/)), you
    simply do not have to always enter it to unlock the vault. This begs the question
    how the vault is secured if you do not have to enter the master password. Well,
    the vault is not really encrypted with the master password, but with an *account
    encryption key*, which is itself stored in encrypted form within the vault. The
    key to decrypting the *account encryption key* is derived from the *main password*
    chosen during vault creation.
  prefs: []
  type: TYPE_NORMAL
- en: '*In other words:* When a user enters their main password, Bitwarden derives
    a key from the password and this key is then used to decrypt the actual *account
    encryption key* which in turn can decrypt the credentials stored in the vault.'
  prefs: []
  type: TYPE_NORMAL
- en: The key derived from the *main password* will be called *derived key* from now
    on and it is exactly where the biometric unlock comes into play. At this point,
    users can choose to add additional unlock mechanisms, which usually results in
    an encrypted copy of the *derived key* being stored at a (hopefully) safe location
    from which it can be retrieved using biometrics, for example. As a result, whoever
    can retrieve and decrypt the *derived key* does not need a password to access
    the vault.
  prefs: []
  type: TYPE_NORMAL
- en: The already described Biometric unlock is implemented based on Windows Hello
    on Windows machines. Consequently, activating biometric login on Windows means
    that the *derived key* is encrypted locally using a secret which can be retrieved
    after authentication via Windows Hello. So far so good, but as it turns out, it
    is very much worthwhile to take a closer look into how this is actually implemented
    in Bitwarden.
  prefs: []
  type: TYPE_NORMAL
- en: After some digging, we found that Bitwarden stored the encrypted copy of the
    *derived key* using the Windows Credentials API by calling [`windows::win32::Credentials::CredWriteW`](https://learn.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credwritew)
    in the [bitwarden/clients Rust code](https://github.com/bitwarden/clients/blob/7f25f5f6ecc47ae3354b60e6ba6158f8be185a8d/apps/desktop/desktop_native/src/password/windows.rs#L110).
    Unfortunately, the documentation on how these credentials are protected is meager,
    to say the least, which makes it complicated to actually understand what is happening
    when the API is used. It seems, as though `CredWriteW` creates credentials using
    the [Credential Manager](https://stackoverflow.com/a/9228105), which in turn seems
    to invoke the lower-level Data Protection API ([DPAPI](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi)).
    DPAPI provides a convenient way to [store data securely](https://learn.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptprotectdata)
    such that only the given user is able to retrieve the data at a later point in
    time. The differences between protecting credentials via the Credential Manager
    and DPAPI are somewhat unclear, however using the Credential Manager seems to
    provide [additional benefits](https://stackoverflow.com/a/9228105) over using
    the low-level API, for example UI visibility (you can test this yourself by searching
    for the `Credential Manager` application in you Windows Start menu).
  prefs: []
  type: TYPE_NORMAL
- en: So in order to decrypt the Bitwarden vault, we either need to know the main
    password in order to derive the *derived key* on-the-fly or we need to retrieve
    the *derived key* from the depths of the encrypted DPAPI storage. We knew that
    DPAPI has a lot of ties to the Active Directory that are relevant for domain-joined
    workstations and we had already compromised the client’s Active Directory, so
    we chose the latter approach.
  prefs: []
  type: TYPE_NORMAL
- en: Robbing the Vault Remotely - Who Needs a Master Password, Anyway?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We soon learned about an [awfully convenient feature](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi-backup-keys-on-ad-domain-controllers)
    of DPAPI, or rather its newer version [DPAPI-NG](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi)
    on domain-joined workstations:'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, domain users encrypt DPAPI-protected data using keys that are derived
    from their own passwords. However, if the user forgets their password, or if their
    password is administratively reset or reset from another device, the previously
    encrypted data can no longer be decrypted using the new keys derived from the
    user’s new password. When this occurs, the data can still be decrypted using the
    Backup keys stored on the Active Directory domain controllers. They can then be
    re-encrypted with the user’s new password-derived key. This means that anyone
    who has the DPAPI Backup keys for a domain will be able to decrypt DPAPI-encrypted
    data for any domain user, even after the user’s password is changed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means for one that the data is encrypted using the password of the domain
    user and no direct involvement of Windows Hello is needed to decrypt it (as long
    as the user’s password is known). Furthermore, the data can additionally be decrypted
    with a [remote backup key](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-bkrp/)
    stored on the domain controller. What could possibly go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: Since the workstation running Bitwarden was domain-joined and the domain was
    already compromised, we began hunting for DPAPI keys in order to exploit this
    mechanism. First, we need to obtain whatever DPAPI stores on the machine itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We quickly found that two directories were of particular relevance to us: `%AppData%\Microsoft\Protect`,
    which is used to securely store the *DPAPI decryption keys*, and `%AppData%\Microsoft\Credentials`,
    where the *protected data* resides. Note, that we use some simplifications involving
    the creation of session keys in DPAPI since they are of no relevance to this blog
    post; details are available [here](https://learn.microsoft.com/en-us/previous-versions/ms995355(v%3Dmsdn.10)).'
  prefs: []
  type: TYPE_NORMAL
- en: If you open these directories in the Explorer, you won’t see anything because
    they are hidden in a way that Explorer won’t even show them when “Show hidden
    files” is enabled. However, the PowerShell command `Get-ChildItem` or `gci` can
    display them when adding `--force` or `--hidden`. They are also visible via SMB
    and as we already had remote administrator access we chose this path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippets are taken from our lab environment, but are closely
    based on the actual penetration test. First, we obtained the required Bitwarden
    data file using `smbclient` from the [Impacket project](https://github.com/fortra/impacket):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same session, we also downloaded the `Credentials` and `Protected` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Downloading these files made it possible to work on the decryption process
    locally, however it also meant that we did not gain access to the user’s main
    decryption password directly. This is where the handy feature to decrypt DPAPI
    decryption keys using backup keys comes into play, as we know that it is possible
    to decrypt these local secrets with the backup key from the domain controller.
    We could conveniently download it using the `dpapi.py` script from the [Impacket
    project](https://github.com/fortra/impacket):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we renamed the key to `backupkey.pvk`. Using this newly acquired
    key, we could start by decrypting the protected DPAPI decryption key that we took
    from the workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It was now simply a matter of using this key to decrypt the Biometric login
    credentials which are necessary to get into the Bitwarden vault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This revealed the *biometric key* (a copy of the previously described *derived
    key*), which grants access to the Bitwarden vault: `6PN6Y9wkXjrHvDCijM7fhkNrDL8PI/dc70m9XoSqxDE=`'
  prefs: []
  type: TYPE_NORMAL
- en: This means that we don’t need the main password, we don’t need the fingerprint
    for biometrics, we don’t even have to use a keylogger or dump Bitwarden’s process
    memory. This also means that we don’t have to wrestle with endpoint protection
    and we don’t need to wait for the actual user to unlock the vault. We simply have
    to use DPAPI as it was designed. We seriously doubt any user is aware of these
    implications when enabling Windows Hello for their vault.
  prefs: []
  type: TYPE_NORMAL
- en: So far we only have shown the *derived/biometric key*, which is sufficient to
    decrypt the vault. In practice, however, there is still a little legwork we have
    to do. After all, our goal was not to demonstrate that we *could* decrypt the
    vault but to get actual credentials from the vault.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking Into the Vault
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We first had to figure out how to decrypt the Bitwarden *account encryption
    key*, which protects all other information in the vault. Credentials are not always
    encrypted with the *account encryption key* directly since Bitwarden also supports
    usage scenarios where some credentials should be shared in an organization, for
    example. This is solved by adding additional layers of keys (private and organizational
    keys), which are used to encrypt organization credentials, and are also protected
    using the *account encryption key*. Take a look at the figure below if you are
    starting to get confused about all the keys involved in this story.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decryption process therefore consists of three main steps: (1) Decryption
    of the *account encryption key* using the *biometric key*, (2) decryption of the
    second layer of keys using the *account encryption key* and (3) decryption of
    the credentials using either the *account encryption key* or one of the intermediate
    keys. We then set out to write a Python script to automate the decryption. Let’s
    walk through each step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We started by extracting the user object from the Bitwarden data file `data.json`.
    The user object contains the encrypted credentials (in the `data` section) and
    the encryption keys (in the `keys` section), in addition to (unencrypted) information
    about the user account like the email address (`profile`), settings like the online
    vault URL (`settings`) and more. The user section can be identified by searching
    for a UUID which is used as key in the JSON object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since Bitwarden uses different types of encryption for different scenarios,
    all encrypted values are stored using a particular format, which starts with an
    *encryption type* identifier ([from GitHub](https://github.com/bitwarden/clients/blob/master/libs/common/src/platform/enums/encryption-type.enum.ts)):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As indicated by the leading 2, our account encryption key was encrypted using
    AES-CBC-256, and integrity-protected using an HMAC based on SHA-256. Before decrypting
    the account key with the biometric key, it has to be expanded using [HKDF-expand](https://en.wikipedia.org/wiki/HKDF),
    though.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the account encryption key, we were able to decrypt the second layer of
    keys, which were all stored in the `"keys"` part of the user object as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As can be inferred from the encryption type, this key was also encrypted using
    AES-CBC. In our test setup, the private RSA key could be used to decrypt additional
    organizational keys, which were in turn required to access organization-specific
    credentials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Having obtained all intermediate keys, we were finally able to extract the
    desired credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This type of credential could be decrypted using the account key directly (recognizable
    by the empty `organizationId`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Other credentials required intermediate keys (`organizationId` is set):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can see our [vault decryption script](https://github.com/RedTeamPentesting/bitwarden-windows-hello/blob/main/hello-bitwarden.py)
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: As we had hoped, the Bitwarden vault on the Administrator’s workstation did
    indeed include the credentials to access the special backup system, finally granting
    us access to the sought-after backups. You can probably imagine the astonishment
    of our client when we told them about the attack, as they had no idea that domain
    admins can bypass Bitwarden’s vault protections.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we’ve always known attackers with domain admin privileges are quite powerful
    in the first place, but at least the vault is protected against unprivileged attackers
    on the local workstation, right? &mldr;right?
  prefs: []
  type: TYPE_NORMAL
- en: 'But Wait, There’s More: Who Needs Biometrics, Anyway?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the process of trying to understand this whole mechanism, we started playing
    around with DPAPI in our lab setup. For example, we thought that using the API
    itself is probably easier than cobbling together the key files from `%AppData%`.
    To familiarize ourselves with DPAPI, we wrote a tiny Go program to see what credentials
    are stored in DPAPI on the workstation using the [wincred](https://github.com/danieljoos/wincred)
    library. The full script is available [here](https://github.com/RedTeamPentesting/bitwarden-windows-hello/blob/main/dpapidump/main.go),
    but the only interesting lines are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It only calls `windcred.List()` which is a thin Go wrapper around [CredEnumerateW](https://learn.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credenumeratew)
    which simply “enumerates the credentials from the user’s credential set”. However,
    we did not expect that this function immediately spits out Bitwarden’s *derived/biometrics
    key* without prompting for biometric authentication using Windows Hello:'
  prefs: []
  type: TYPE_NORMAL
- en: This means that any process that runs as the low-privileged user session can
    simply ask DPAPI for the credentials to unlock the vault, no questions asked and
    no PIN or fingerprint prompt required and Windows Hello is not even involved at
    all. The only caveat is that this does not work for other user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwarden itself does prompt for biometric authentication when unlocking the
    vault, but it wouldn’t even have to. In fact, you could probably remove a few
    lines from the source code and have it unlock without a prompt. The whole issue
    is likely a result of misunderstanding the details of the `CredWriteW` function,
    or maybe an unawareness of the potential pitfalls of using DPAPI to store encryption
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: A Feature, Not a Bug
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We contacted both Bitwarden and Microsoft about the details of this attack.
    We always make sure to follow industry best practices for responsible disclosure,
    even if it is unclear whether our findings are actual vulnerabilities. For the
    attack explained in this blog post, this was the case as it is not clear whether
    the attack is in scope of either Bitwarden (since the attack already assumes access
    to the workstation of the victim and the Windows domain) or Microsoft (who are
    only involved by providing DPAPI to store the decryption keys). Microsoft indeed
    responded to our report by stating that DPAPI and its backup mechanism were used
    exactly as intended, and that our attack therefore did not indicate any vulnerabilities
    on their side.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwarden also responded, however they agreed that this behavior was unintended,
    and stated that they were already tracking a similar issue internally. As it turns
    out, we were not the first to discover this in March 2023, it had already been
    [reported to Bitwarden through HackerOne](https://hackerone.com/reports/1874155).
    However, we did not know this since it was only disclosed in June 2023\. Since
    then the vulnerability is known as [CVE-2023-27706](https://nvd.nist.gov/vuln/detail/CVE-2023-27706).
  prefs: []
  type: TYPE_NORMAL
- en: Bitwarden has since made changes to their codebase to mitigate this particular
    scenario, which we will quickly summarize in the next section. They have also
    changed the default setting when using Windows Hello as login feature to require
    entering the main password at least once when Bitwarden is started.
  prefs: []
  type: TYPE_NORMAL
- en: Biometrics in Bitwarden Now
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To prepare for this blog post, we also took a look at how credentials are stored
    in the current version of Bitwarden [Desktop v2023.10.1](https://github.com/bitwarden/clients/releases/tag/desktop-v2023.10.1).
    Bitwarden still makes use of Windows Hello and DPAPI, which are still accessible
    using the domain backup key. However the content of the secured data blobs has
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Instead of storing the valuable *derived/biometric key* via DPAPI, Bitwarden
    now stores two secured data blobs, which are encrypted and can no longer be used
    to decrypt the *account encryption key* directly (indicated by the encryption
    type 0). The stored data blobs are now additionally encrypted using the [KeyCredentialManager
    API](https://learn.microsoft.com/en-us/uwp/api/windows.security.credentials.keycredentialmanager)
    which actually requires interaction with Windows Hello to produce a decryption
    key. While it seems to us that this fixes the issue, we have not actually tested
    the new implementation for other vulnerabilities, yet.
  prefs: []
  type: TYPE_NORMAL
