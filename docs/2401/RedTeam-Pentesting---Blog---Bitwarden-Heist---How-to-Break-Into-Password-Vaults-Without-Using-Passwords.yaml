- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分类：未分类
- en: 'date: 2024-05-27 14:28:33'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:28:33'
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: RedTeam Pentesting - Blog - Bitwarden Heist - How to Break Into Password Vaults
    Without Using Passwords
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RedTeam Pentesting - Blog - Bitwarden 抢劫 - 如何在不使用密码的情况下破解密码保险库
- en: 来源：[https://blog.redteam-pentesting.de/2024/bitwarden-heist/](https://blog.redteam-pentesting.de/2024/bitwarden-heist/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://blog.redteam-pentesting.de/2024/bitwarden-heist/](https://blog.redteam-pentesting.de/2024/bitwarden-heist/)
- en: 3 January 2024
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2024 年 1 月 3 日
- en: Bitwarden Heist - How to Break Into Password Vaults Without Using Passwords
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bitwarden 抢劫 - 如何在不使用密码的情况下破解密码保险库
- en: 'Sometimes, making particular security design decisions can have unexpected
    consequences. For security-critical software, such as password managers, this
    can easily lead to catastrophic failure: In this blog post, we show how [Bitwarden’s](https://bitwarden.com/)
    Windows Hello implementation allowed us to remotely steal all credentials from
    the vault without knowing the password or requiring biometric authentication.
    When we discovered this during a penetration test it was so unexpected for us
    that we agreed with our client to publish a blog post about it and tell the story.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，做出特定的安全设计决策可能会带来意想不到的后果。对于像密码管理器这样的安全关键软件，这很容易导致灾难性的失败：在这篇博文中，我们展示了[Bitwarden](https://bitwarden.com/)的
    Windows Hello 实现如何允许我们远程窃取保险库中的所有凭据，而无需知道密码或需要生物识别身份验证。当我们在一次渗透测试中发现这一点时，对我们来说是如此意外，以至于我们同客户商定发表一篇关于此事的博文并讲述这个故事。
- en: '**The underlying issue has been corrected in Bitwarden v2023.4.0 in April 2023**
    (but the story is interesting nonetheless).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个潜在问题已经在 2023 年 4 月的 Bitwarden v2023.4.0 中得到了修正**（但这个故事仍然很有趣）。'
- en: Where We Started
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的起点
- en: 'We recently conducted a penetration test with the goal of compromising the
    internal network of a client in a Windows environment. As usual, we managed to
    get administrative access to the domain controller, however, there was an additional
    hurdle: The backup server, one of the prioritized targets, did not reside within
    the domain. Having already gained access to Domain Administrator accounts, we
    decided to take a look around their Windows workstations in the hopes of uncovering
    information that would grant us access to the backup system. Looking at the workstations,
    we found that passwords seemed to be stored using Bitwarden (the following details
    apply to Version [Desktop v2023.3.0](https://github.com/bitwarden/clients/releases/tag/desktop-v2023.3.0)
    of the software). We made the assumption that credentials to the backup system
    might be found in the Bitwarden vault of the employees in charge of the IT infrastructure.
    After consulting with our client, we got the permission to attempt to retrieve
    the contents of one of these vaults. Since we did not want to potentially disrupt
    the client’s business by using invasive techniques such as key loggers to obtain
    access to the backup system, we looked for an unintrusive way without relying
    on end user interaction if possible.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最近进行了一次渗透测试，旨在入侵 Windows 环境中客户的内部网络。像往常一样，我们设法获得了对域控制器的管理访问权限，但是，还有一个额外的障碍：备份服务器，这是一个优先考虑的目标之一，不在域内。已经获得域管理员帐户访问权限后，我们决定查看他们的
    Windows 工作站，希望发现可以让我们访问备份系统的信息。查看工作站时，我们发现密码似乎是使用 Bitwarden 存储的（以下详细信息适用于软件的版本
    [Desktop v2023.3.0](https://github.com/bitwarden/clients/releases/tag/desktop-v2023.3.0)）。我们假设备份系统的凭据可能在负责
    IT 基础设施的员工的 Bitwarden 保险库中找到。在与客户协商后，我们获得了尝试检索其中一个保险库内容的许可。由于我们不想通过使用侵入性技术（如键盘记录器）来获取访问备份系统的权限而可能干扰客户的业务，因此我们寻找了一种不依赖于最终用户交互的非侵入方式，如果可能的话。
- en: 'We first tried to crack the vault using simple credential stuffing attacks,
    however this remained unsuccessful, leading us to ultimately attempt a more creative
    approach. To further analyze the vault, we decided to download the main storage
    file of Bitwarden, in the hopes of finding anything of note. It is located under
    the user’s home directory at `%AppData%\Bitwarden\data.json`. Downloading the
    JSON file and opening it in a text editor already revealed an unexpected finding:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试使用简单的凭据填充攻击来破解保险库，但是这仍然没有成功，最终导致我们尝试了一种更具创造性的方法。为了进一步分析保险库，我们决定下载 Bitwarden
    的主存储文件，希望能找到任何值得注意的内容。它位于用户的主目录下的 `%AppData%\Bitwarden\data.json`。下载 JSON 文件并在文本编辑器中打开后，我们发现了一个意外的发现：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It seemed that this Bitwarden vault could be opened using Biometrics, and Windows
    Hello in particular. We had the feeling that it might be worth looking at, so
    we decided to dig deeper.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎这个 Bitwarden 保险库可以使用生物识别技术打开，尤其是 Windows Hello。我们觉得值得一看，所以我们决定深入挖掘。
- en: Biometric Unlock - How Does it Work?
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生物识别解锁 - 如何工作？
- en: Even if biometrics are enabled, the vault still has a main password (Bitwarden
    calls it [master password](https://bitwarden.com/help/master-password/)), you
    simply do not have to always enter it to unlock the vault. This begs the question
    how the vault is secured if you do not have to enter the master password. Well,
    the vault is not really encrypted with the master password, but with an *account
    encryption key*, which is itself stored in encrypted form within the vault. The
    key to decrypting the *account encryption key* is derived from the *main password*
    chosen during vault creation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使启用了生物识别技术，保险库仍然有一个主密码（Bitwarden 称之为[主密码](https://bitwarden.com/help/master-password/)），你不必总是输入它来解锁保险库。这引出了一个问题，即如果您不必输入主密码，保险库是如何安全的。嗯，保险库实际上并没有用主密码加密，而是用一个*帐户加密密钥*加密，该密钥本身以加密形式存储在保险库中。解密*帐户加密密钥*的关键是从创建保险库时选择的*主密码*派生的。
- en: '*In other words:* When a user enters their main password, Bitwarden derives
    a key from the password and this key is then used to decrypt the actual *account
    encryption key* which in turn can decrypt the credentials stored in the vault.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*换句话说：* 当用户输入他们的主密码时，Bitwarden 从密码派生一个密钥，然后使用这个密钥来解密实际的*帐户加密密钥*，然后可以解密保险库中存储的凭据。'
- en: The key derived from the *main password* will be called *derived key* from now
    on and it is exactly where the biometric unlock comes into play. At this point,
    users can choose to add additional unlock mechanisms, which usually results in
    an encrypted copy of the *derived key* being stored at a (hopefully) safe location
    from which it can be retrieved using biometrics, for example. As a result, whoever
    can retrieve and decrypt the *derived key* does not need a password to access
    the vault.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从*主密码*派生的密钥从现在开始将被称为*派生密钥*，这正是生物识别解锁发挥作用的地方。在这一点上，用户可以选择添加其他解锁机制，这通常会导致将*派生密钥*的加密副本存储在一个（希望是）安全的位置，从中可以使用生物识别技术检索它，例如。因此，谁可以检索和解密*派生密钥*就不需要密码来访问保险库。
- en: The already described Biometric unlock is implemented based on Windows Hello
    on Windows machines. Consequently, activating biometric login on Windows means
    that the *derived key* is encrypted locally using a secret which can be retrieved
    after authentication via Windows Hello. So far so good, but as it turns out, it
    is very much worthwhile to take a closer look into how this is actually implemented
    in Bitwarden.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 已描述的生物识别解锁是基于 Windows 机器上的 Windows Hello 实现的。因此，在 Windows 上激活生物识别登录意味着使用可以在
    Windows Hello 通过身份验证后检索的秘密对本地加密*派生密钥*。到目前为止，一切都很顺利，但事实证明，非常值得仔细研究这实际上是如何在 Bitwarden
    中实现的。
- en: After some digging, we found that Bitwarden stored the encrypted copy of the
    *derived key* using the Windows Credentials API by calling [`windows::win32::Credentials::CredWriteW`](https://learn.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credwritew)
    in the [bitwarden/clients Rust code](https://github.com/bitwarden/clients/blob/7f25f5f6ecc47ae3354b60e6ba6158f8be185a8d/apps/desktop/desktop_native/src/password/windows.rs#L110).
    Unfortunately, the documentation on how these credentials are protected is meager,
    to say the least, which makes it complicated to actually understand what is happening
    when the API is used. It seems, as though `CredWriteW` creates credentials using
    the [Credential Manager](https://stackoverflow.com/a/9228105), which in turn seems
    to invoke the lower-level Data Protection API ([DPAPI](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi)).
    DPAPI provides a convenient way to [store data securely](https://learn.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptprotectdata)
    such that only the given user is able to retrieve the data at a later point in
    time. The differences between protecting credentials via the Credential Manager
    and DPAPI are somewhat unclear, however using the Credential Manager seems to
    provide [additional benefits](https://stackoverflow.com/a/9228105) over using
    the low-level API, for example UI visibility (you can test this yourself by searching
    for the `Credential Manager` application in you Windows Start menu).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番搜索，我们发现 Bitwarden 使用 Windows 凭据 API 来存储*派生密钥*的加密副本，通过调用[`windows::win32::Credentials::CredWriteW`](https://learn.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credwritew)在
    [bitwarden/clients Rust 代码](https://github.com/bitwarden/clients/blob/7f25f5f6ecc47ae3354b60e6ba6158f8be185a8d/apps/desktop/desktop_native/src/password/windows.rs#L110)中。不幸的是，关于这些凭据如何受保护的文档非常少，可以说是很少，这使得在实际使用
    API 时理解发生了什么变得复杂。看起来，`CredWriteW` 创建凭据时使用 [凭据管理器](https://stackoverflow.com/a/9228105)，而凭据管理器似乎又调用了低级别的数据保护
    API ([DPAPI](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi))。DPAPI
    提供了一种方便的方式来[安全存储数据](https://learn.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptprotectdata)，以便仅有给定用户能在以后的某个时间点检索到数据。通过凭据管理器保护凭据和
    DPAPI 之间的区别有些不清楚，但是使用凭据管理器似乎比使用低级别 API 提供了[额外的好处](https://stackoverflow.com/a/9228105)，例如
    UI 可见性（您可以通过在 Windows 开始菜单中搜索`Credential Manager`应用程序来自行测试这一点）。
- en: So in order to decrypt the Bitwarden vault, we either need to know the main
    password in order to derive the *derived key* on-the-fly or we need to retrieve
    the *derived key* from the depths of the encrypted DPAPI storage. We knew that
    DPAPI has a lot of ties to the Active Directory that are relevant for domain-joined
    workstations and we had already compromised the client’s Active Directory, so
    we chose the latter approach.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解密 Bitwarden 保险库，我们要么需要知道主密码以便即时推导出*派生密钥*，要么我们需要从加密的 DPAPI 存储的深处检索*派生密钥*。我们知道
    DPAPI 与 Active Directory 有很多联系，这对于加入域的工作站很重要，我们已经妥协了客户的 Active Directory，所以我们选择了后一种方法。
- en: Robbing the Vault Remotely - Who Needs a Master Password, Anyway?
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程劫掠保险库 - 谁需要主密码呢？
- en: 'We soon learned about an [awfully convenient feature](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi-backup-keys-on-ad-domain-controllers)
    of DPAPI, or rather its newer version [DPAPI-NG](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi)
    on domain-joined workstations:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快了解到 DPAPI 的一个[非常方便的功能](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi-backup-keys-on-ad-domain-controllers)，或者说它的新版本[DPAPI-NG](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi)，在加入域的工作站上：
- en: Normally, domain users encrypt DPAPI-protected data using keys that are derived
    from their own passwords. However, if the user forgets their password, or if their
    password is administratively reset or reset from another device, the previously
    encrypted data can no longer be decrypted using the new keys derived from the
    user’s new password. When this occurs, the data can still be decrypted using the
    Backup keys stored on the Active Directory domain controllers. They can then be
    re-encrypted with the user’s new password-derived key. This means that anyone
    who has the DPAPI Backup keys for a domain will be able to decrypt DPAPI-encrypted
    data for any domain user, even after the user’s password is changed.
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常，域用户使用从自己密码派生出的密钥加密DPAPI受保护的数据。但是，如果用户忘记了密码，或者他们的密码被管理重置或从其他设备重置，以前加密的数据将无法使用从用户新密码派生的新密钥进行解密。当这种情况发生时，数据仍然可以使用存储在Active
    Directory域控制器上的备份密钥进行解密。然后，可以使用用户的新密码派生的密钥重新加密数据。这意味着任何人只要拥有域的DPAPI备份密钥，即可解密任何域用户的DPAPI加密数据，即使用户的密码已更改。
- en: This means for one that the data is encrypted using the password of the domain
    user and no direct involvement of Windows Hello is needed to decrypt it (as long
    as the user’s password is known). Furthermore, the data can additionally be decrypted
    with a [remote backup key](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-bkrp/)
    stored on the domain controller. What could possibly go wrong?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着数据是使用域用户的密码加密的，而不需要Windows Hello直接参与解密（只要知道用户的密码）。此外，数据还可以使用存储在域控制器上的[远程备份密钥](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-bkrp/)进行解密。可能会出现什么问题呢？
- en: Since the workstation running Bitwarden was domain-joined and the domain was
    already compromised, we began hunting for DPAPI keys in order to exploit this
    mechanism. First, we need to obtain whatever DPAPI stores on the machine itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于运行Bitwarden的工作站已加入域，而域已经受到了威胁，因此我们开始寻找DPAPI密钥以利用此机制。首先，我们需要获取机器上DPAPI存储的任何内容。
- en: 'We quickly found that two directories were of particular relevance to us: `%AppData%\Microsoft\Protect`,
    which is used to securely store the *DPAPI decryption keys*, and `%AppData%\Microsoft\Credentials`,
    where the *protected data* resides. Note, that we use some simplifications involving
    the creation of session keys in DPAPI since they are of no relevance to this blog
    post; details are available [here](https://learn.microsoft.com/en-us/previous-versions/ms995355(v%3Dmsdn.10)).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快发现两个目录对我们特别重要：`%AppData%\Microsoft\Protect`，用于安全存储*DPAPI解密密钥*，以及`%AppData%\Microsoft\Credentials`，其中存放着*受保护的数据*。请注意，我们在DPAPI中使用了一些简化，涉及到会话密钥的创建，因为它们与本博客文章无关；详情请参见[这里](https://learn.microsoft.com/en-us/previous-versions/ms995355(v%3Dmsdn.10))。
- en: If you open these directories in the Explorer, you won’t see anything because
    they are hidden in a way that Explorer won’t even show them when “Show hidden
    files” is enabled. However, the PowerShell command `Get-ChildItem` or `gci` can
    display them when adding `--force` or `--hidden`. They are also visible via SMB
    and as we already had remote administrator access we chose this path.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在资源管理器中打开这些目录，您将看不到任何内容，因为它们被隐藏了，资源管理器甚至不会在启用“显示隐藏文件”时显示它们。但是，PowerShell命令`Get-ChildItem`或`gci`在添加`--force`或`--hidden`时可以显示它们。它们也可以通过SMB可见，因为我们已经具有远程管理员访问权限，所以我们选择了这条路径。
- en: 'The following code snippets are taken from our lab environment, but are closely
    based on the actual penetration test. First, we obtained the required Bitwarden
    data file using `smbclient` from the [Impacket project](https://github.com/fortra/impacket):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段取自我们的实验环境，但与实际的渗透测试密切相关。首先，我们使用[Impacket项目](https://github.com/fortra/impacket)中的`smbclient`获取所需的Bitwarden数据文件：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the same session, we also downloaded the `Credentials` and `Protected` data:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个会话中，我们还下载了`Credentials`和`Protected`数据：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Downloading these files made it possible to work on the decryption process
    locally, however it also meant that we did not gain access to the user’s main
    decryption password directly. This is where the handy feature to decrypt DPAPI
    decryption keys using backup keys comes into play, as we know that it is possible
    to decrypt these local secrets with the backup key from the domain controller.
    We could conveniently download it using the `dpapi.py` script from the [Impacket
    project](https://github.com/fortra/impacket):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, we renamed the key to `backupkey.pvk`. Using this newly acquired
    key, we could start by decrypting the protected DPAPI decryption key that we took
    from the workstation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It was now simply a matter of using this key to decrypt the Biometric login
    credentials which are necessary to get into the Bitwarden vault:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This revealed the *biometric key* (a copy of the previously described *derived
    key*), which grants access to the Bitwarden vault: `6PN6Y9wkXjrHvDCijM7fhkNrDL8PI/dc70m9XoSqxDE=`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This means that we don’t need the main password, we don’t need the fingerprint
    for biometrics, we don’t even have to use a keylogger or dump Bitwarden’s process
    memory. This also means that we don’t have to wrestle with endpoint protection
    and we don’t need to wait for the actual user to unlock the vault. We simply have
    to use DPAPI as it was designed. We seriously doubt any user is aware of these
    implications when enabling Windows Hello for their vault.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: So far we only have shown the *derived/biometric key*, which is sufficient to
    decrypt the vault. In practice, however, there is still a little legwork we have
    to do. After all, our goal was not to demonstrate that we *could* decrypt the
    vault but to get actual credentials from the vault.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Breaking Into the Vault
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We first had to figure out how to decrypt the Bitwarden *account encryption
    key*, which protects all other information in the vault. Credentials are not always
    encrypted with the *account encryption key* directly since Bitwarden also supports
    usage scenarios where some credentials should be shared in an organization, for
    example. This is solved by adding additional layers of keys (private and organizational
    keys), which are used to encrypt organization credentials, and are also protected
    using the *account encryption key*. Take a look at the figure below if you are
    starting to get confused about all the keys involved in this story.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The decryption process therefore consists of three main steps: (1) Decryption
    of the *account encryption key* using the *biometric key*, (2) decryption of the
    second layer of keys using the *account encryption key* and (3) decryption of
    the credentials using either the *account encryption key* or one of the intermediate
    keys. We then set out to write a Python script to automate the decryption. Let’s
    walk through each step:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'We started by extracting the user object from the Bitwarden data file `data.json`.
    The user object contains the encrypted credentials (in the `data` section) and
    the encryption keys (in the `keys` section), in addition to (unencrypted) information
    about the user account like the email address (`profile`), settings like the online
    vault URL (`settings`) and more. The user section can be identified by searching
    for a UUID which is used as key in the JSON object:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从 Bitwarden 数据文件 `data.json` 中提取了用户对象。用户对象包含加密凭据（在`data`部分）和加密密钥（在`keys`部分）以及用户帐户的（未加密）信息，如电子邮件地址（`profile`）、设置如在线保险库
    URL（`settings`）等等。可以通过搜索用作 JSON 对象中键的 UUID 来识别用户部分：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since Bitwarden uses different types of encryption for different scenarios,
    all encrypted values are stored using a particular format, which starts with an
    *encryption type* identifier ([from GitHub](https://github.com/bitwarden/clients/blob/master/libs/common/src/platform/enums/encryption-type.enum.ts)):'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 Bitwarden 对不同的情景使用不同类型的加密，所有加密值都以特定格式存储，该格式以 *加密类型* 标识符开始（[来自 GitHub](https://github.com/bitwarden/clients/blob/master/libs/common/src/platform/enums/encryption-type.enum.ts)）：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As indicated by the leading 2, our account encryption key was encrypted using
    AES-CBC-256, and integrity-protected using an HMAC based on SHA-256. Before decrypting
    the account key with the biometric key, it has to be expanded using [HKDF-expand](https://en.wikipedia.org/wiki/HKDF),
    though.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如前面的 2 所示，我们的账户加密密钥使用 AES-CBC-256 进行加密，并且使用基于 SHA-256 的 HMAC 进行完整性保护。在使用生物特征密钥解密账户密钥之前，必须扩展该密钥，使用
    [HKDF-expand](https://en.wikipedia.org/wiki/HKDF) 进行扩展。
- en: With the account encryption key, we were able to decrypt the second layer of
    keys, which were all stored in the `"keys"` part of the user object as well.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用账户加密密钥，我们能够解密第二层密钥，这些密钥也都存储在用户对象的`"keys"`部分中。
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As can be inferred from the encryption type, this key was also encrypted using
    AES-CBC. In our test setup, the private RSA key could be used to decrypt additional
    organizational keys, which were in turn required to access organization-specific
    credentials.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如可以从加密类型推断的那样，该密钥也使用 AES-CBC 进行了加密。在我们的测试设置中，私有 RSA 密钥可用于解密额外的组织密钥，而这些密钥又被需要来访问特定于组织的凭据。
- en: 'Having obtained all intermediate keys, we were finally able to extract the
    desired credentials:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取了所有中间密钥之后，我们终于能够提取所需的凭据：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This type of credential could be decrypted using the account key directly (recognizable
    by the empty `organizationId`).
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种类型的凭据可以直接使用账户密钥解密（可通过空的`organizationId`进行识别）。
- en: 'Other credentials required intermediate keys (`organizationId` is set):'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他凭据需要中间密钥（`organizationId` 已设置）：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we can see our [vault decryption script](https://github.com/RedTeamPentesting/bitwarden-windows-hello/blob/main/hello-bitwarden.py)
    in action:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们的 [保险库解密脚本](https://github.com/RedTeamPentesting/bitwarden-windows-hello/blob/main/hello-bitwarden.py)
    在执行中：
- en: As we had hoped, the Bitwarden vault on the Administrator’s workstation did
    indeed include the credentials to access the special backup system, finally granting
    us access to the sought-after backups. You can probably imagine the astonishment
    of our client when we told them about the attack, as they had no idea that domain
    admins can bypass Bitwarden’s vault protections.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所希望的那样，管理员工作站上的 Bitwarden 保险库确实包含了访问特殊备份系统的凭据，最终授予了我们访问所需备份的权限。当我们告诉客户有关攻击时，他们可能会感到震惊，因为他们不知道域管理员可以绕过
    Bitwarden 的保险库保护。
- en: Well, we’ve always known attackers with domain admin privileges are quite powerful
    in the first place, but at least the vault is protected against unprivileged attackers
    on the local workstation, right? &mldr;right?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们一直都知道拥有域管理员权限的攻击者本来就很强大，但至少保险库受到了保护，以防止在本地工作站上没有特权的攻击者，对吗？&mldr;对吗？
- en: 'But Wait, There’s More: Who Needs Biometrics, Anyway?'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 但等等，还有更多：谁需要生物识别，不是吗？
- en: 'In the process of trying to understand this whole mechanism, we started playing
    around with DPAPI in our lab setup. For example, we thought that using the API
    itself is probably easier than cobbling together the key files from `%AppData%`.
    To familiarize ourselves with DPAPI, we wrote a tiny Go program to see what credentials
    are stored in DPAPI on the workstation using the [wincred](https://github.com/danieljoos/wincred)
    library. The full script is available [here](https://github.com/RedTeamPentesting/bitwarden-windows-hello/blob/main/dpapidump/main.go),
    but the only interesting lines are these:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在试图理解整个机制的过程中，我们开始在我们的实验室环境中尝试使用 DPAPI。例如，我们认为使用 API 本身可能比从 `%AppData%` 中拼凑密钥文件更容易。为了熟悉
    DPAPI，我们编写了一个小小的 Go 程序，使用 [wincred](https://github.com/danieljoos/wincred) 库来查看工作站上存储在
    DPAPI 中的凭据。完整的脚本可以在[这里](https://github.com/RedTeamPentesting/bitwarden-windows-hello/blob/main/dpapidump/main.go)找到，但是唯一有趣的行是这些：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It only calls `windcred.List()` which is a thin Go wrapper around [CredEnumerateW](https://learn.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credenumeratew)
    which simply “enumerates the credentials from the user’s credential set”. However,
    we did not expect that this function immediately spits out Bitwarden’s *derived/biometrics
    key* without prompting for biometric authentication using Windows Hello:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它只调用了 `windcred.List()`，这是围绕 [CredEnumerateW](https://learn.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credenumeratew)
    的一个薄的 Go 包装器，它简单地“从用户的凭据集中枚举凭据”。然而，我们没有预料到这个函数会立即输出 Bitwarden 的*派生/生物特征密钥*，而不需要使用
    Windows Hello 进行生物识别身份验证：
- en: This means that any process that runs as the low-privileged user session can
    simply ask DPAPI for the credentials to unlock the vault, no questions asked and
    no PIN or fingerprint prompt required and Windows Hello is not even involved at
    all. The only caveat is that this does not work for other user accounts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何以低特权用户会话身份运行的进程都可以简单地请求 DPAPI 来获取解锁保险库的凭据，无需询问，也无需 PIN 码或指纹提示，甚至根本不涉及
    Windows Hello。唯一的注意事项是，这对其他用户账户不起作用。
- en: Bitwarden itself does prompt for biometric authentication when unlocking the
    vault, but it wouldn’t even have to. In fact, you could probably remove a few
    lines from the source code and have it unlock without a prompt. The whole issue
    is likely a result of misunderstanding the details of the `CredWriteW` function,
    or maybe an unawareness of the potential pitfalls of using DPAPI to store encryption
    keys.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Bitwarden 本身在解锁保险库时确实会提示进行生物识别身份验证，但实际上它甚至都不需要。事实上，你可能只需从源代码中删除几行代码就可以让它在没有提示的情况下解锁。整个问题很可能是由于误解
    `CredWriteW` 函数的细节，或者可能是对使用 DPAPI 存储加密密钥的潜在陷阱的无知所致。
- en: A Feature, Not a Bug
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个特性，而不是一个 Bug
- en: We contacted both Bitwarden and Microsoft about the details of this attack.
    We always make sure to follow industry best practices for responsible disclosure,
    even if it is unclear whether our findings are actual vulnerabilities. For the
    attack explained in this blog post, this was the case as it is not clear whether
    the attack is in scope of either Bitwarden (since the attack already assumes access
    to the workstation of the victim and the Windows domain) or Microsoft (who are
    only involved by providing DPAPI to store the decryption keys). Microsoft indeed
    responded to our report by stating that DPAPI and its backup mechanism were used
    exactly as intended, and that our attack therefore did not indicate any vulnerabilities
    on their side.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们联系了 Bitwarden 和微软询问了这次攻击的详细信息。我们始终确保遵循负责任的披露行业最佳实践，即使我们的发现是否是实际漏洞尚不清楚。对于本文中解释的攻击，情况是这样的，因为尚不清楚攻击是否在
    Bitwarden（因为攻击已经假定攻击者已经访问了受害者的工作站和 Windows 域）或者微软（他们只提供 DPAPI 来存储解密密钥）的范围内。微软确实通过声明
    DPAPI 及其备份机制确实按照预期使用，并且我们的攻击因此没有表明他们一方存在任何漏洞而回应了我们的报告。
- en: Bitwarden also responded, however they agreed that this behavior was unintended,
    and stated that they were already tracking a similar issue internally. As it turns
    out, we were not the first to discover this in March 2023, it had already been
    [reported to Bitwarden through HackerOne](https://hackerone.com/reports/1874155).
    However, we did not know this since it was only disclosed in June 2023\. Since
    then the vulnerability is known as [CVE-2023-27706](https://nvd.nist.gov/vuln/detail/CVE-2023-27706).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Bitwarden 也做出了回应，但他们同意这种行为是无意的，并表示他们已经在内部跟踪类似的问题。 结果证明，我们并不是 2023 年 3 月首次发现此问题，已经[通过
    HackerOne 向 Bitwarden 报告](https://hackerone.com/reports/1874155)。 但是，我们不知道这一点，因为直到
    2023 年 6 月才被披露。 自那时起，该漏洞被称为[CVE-2023-27706](https://nvd.nist.gov/vuln/detail/CVE-2023-27706)。
- en: Bitwarden has since made changes to their codebase to mitigate this particular
    scenario, which we will quickly summarize in the next section. They have also
    changed the default setting when using Windows Hello as login feature to require
    entering the main password at least once when Bitwarden is started.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Bitwarden 自那时起已经对他们的代码库进行了更改，以缓解这种特定场景，我们将在下一节中简要总结。 他们还更改了使用 Windows Hello
    作为登录功能时的默认设置，要求在启动 Bitwarden 时至少输入一次主密码。
- en: Biometrics in Bitwarden Now
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bitwarden 现在的生物识别功能
- en: 'To prepare for this blog post, we also took a look at how credentials are stored
    in the current version of Bitwarden [Desktop v2023.10.1](https://github.com/bitwarden/clients/releases/tag/desktop-v2023.10.1).
    Bitwarden still makes use of Windows Hello and DPAPI, which are still accessible
    using the domain backup key. However the content of the secured data blobs has
    changed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这篇博客文章，我们还查看了当前版本的 Bitwarden [Desktop v2023.10.1](https://github.com/bitwarden/clients/releases/tag/desktop-v2023.10.1)中凭证是如何存储的。
    Bitwarden 仍然使用 Windows Hello 和 DPAPI，仍然可以使用域备份密钥访问。 但是，安全数据块的内容已更改：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead of storing the valuable *derived/biometric key* via DPAPI, Bitwarden
    now stores two secured data blobs, which are encrypted and can no longer be used
    to decrypt the *account encryption key* directly (indicated by the encryption
    type 0). The stored data blobs are now additionally encrypted using the [KeyCredentialManager
    API](https://learn.microsoft.com/en-us/uwp/api/windows.security.credentials.keycredentialmanager)
    which actually requires interaction with Windows Hello to produce a decryption
    key. While it seems to us that this fixes the issue, we have not actually tested
    the new implementation for other vulnerabilities, yet.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Bitwarden 不再通过 DPAPI 存储有价值的*派生/生物识别密钥*，而是存储了两个经过加密的安全数据块，这些数据块不能再直接用于解密*账户加密密钥*（表示为加密类型
    0）。 存储的数据块现在还使用[KeyCredentialManager API](https://learn.microsoft.com/en-us/uwp/api/windows.security.credentials.keycredentialmanager)进行了额外加密，实际上需要与
    Windows Hello 交互才能生成解密密钥。 虽然看起来这修复了问题，但我们实际上还没有测试新的实现是否存在其他漏洞。
