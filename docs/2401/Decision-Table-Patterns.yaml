- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:25:07'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Decision Table Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.hillelwayne.com/post/decision-table-patterns/](https://www.hillelwayne.com/post/decision-table-patterns/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Decision tables are easy, simple, and powerful. You can teach them in five minutes
    and write one in half that time. You can look at a table and understand what it’s
    saying, see if it matches your problem, and check for design flaws. So it’s kinda
    weird that there’s basically nothing about them online. I wrote an [introduction](https://www.hillelwayne.com/post/decision-tables/)
    a while back, but I want something a little more formal. So this post will reintroduce
    the core ideas in a more formal way and then talk about some of the techniques
    you can apply to make better tables.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is a theorycrafting post. I haven’t tested all of the content
    in production and can’t guarantee that they work well in practice. Caveat emptor.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A decision table maps finite enumerated inputs to outputs. The outputs can
    be anything: returned values, side effects, whatever, but all possible inputs
    must map to an output. By looking at the table, you know what’s supposed to happen.
    This makes them good for case analysis and examining requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | B | C | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | T | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | F | **3** |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | T | **7** |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | F | **0** |'
  prefs: []
  type: TYPE_TB
- en: '| F | - | - | **2** |'
  prefs: []
  type: TYPE_TB
- en: For all of these examples we’ll assume one output, O, unless otherwise specified.
    There is more technique involved in encoding inputs than outputs.
  prefs: []
  type: TYPE_NORMAL
- en: A decision table is **complete** if every possible combination of inputs is
    represented by a row. It is **sound** if a row of inputs doesn’t appear twice
    with two different outputs. It is **valid** if it is both complete and sound.
    A valid table, then, will have exactly one row for each possible combination of
    inputs. If we have two boolean inputs and one 3-value enumeration, then the table
    will have 12 rows.
  prefs: []
  type: TYPE_NORMAL
- en: Because decision tables must satisfy rules to be considered valid, they are
    considered a form of **formal specification**. By being formalized, 1) we can
    analyze correctness of a table with automated tooling, and 2) errors in the construction
    of the table often map to errors in our design itself.
  prefs: []
  type: TYPE_NORMAL
- en: Decision tables are also called Parnas tables, especially when they’re used
    as part of formal verification.
  prefs: []
  type: TYPE_NORMAL
- en: vs. Pattern Matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common question asked about decision tables is “why not pattern match?” In
    many languages we can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In which case we already have an execution. So why use decision tables if they
    don’t map to execution?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because decision tables are *specification*, not code. Pattern matching
    is good for representing a single decision in the code. Decision tables represent
    a decision at any abstraction level, whether for the code or the entire system.
    They can even represent high-level non-code decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| PR passed review? | PR passed tests? | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | Merge |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | Fix tests |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | Fix review comments |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | Fix tests first |'
  prefs: []
  type: TYPE_TB
- en: Pattern matching is part of the language implementation. Decision tables are
    more to help you with the design.
  prefs: []
  type: TYPE_NORMAL
- en: That said you also see decision tables as a control-flow construct. Decision
    tables are pretty popular in both rules engines and automated QA tools that large
    enterprises use. SAP advertises their automated decision tables. I am much more
    interested in their use as specification tools and will not discuss their use
    as an implementation construct further.
  prefs: []
  type: TYPE_NORMAL
- en: Representing Infinite States
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The system can have an infinite number of states as long as they map to a finite
    number of values. We can do this by grouping the states into “effectively similar
    inputs”, or **equivalence classes**. Then we replace the raw input with the class.
    As an instructive example, we *cannot* make a “naïve” odd-or-even table, as there
    are infinite positive numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| N | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | odd |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | even |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | odd |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | even |'
  prefs: []
  type: TYPE_TB
- en: '| … | … |'
  prefs: []
  type: TYPE_TB
- en: Since not every possible input can be represented, this table is not complete
    and so not valid. What we can do is replace the number N with the equation `N
    % 2`. That has only a finite number of inputs and leads to a valid table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing we can do is partition inputs into **intervals**: giving lower
    and upper bounds for the numbers in each class. Another trite example, “can this
    person drink in the US?”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Intervals can be ambiguous: does `0-21` include 0, 21, or both? If both, how
    do you express the real numbers between 0 and 21, exclusive? We can adapt some
    math notation here: `(0, 21)` excludes both while `[0, 21]` includes both.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Age | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `[0, 21)` | F |'
  prefs: []
  type: TYPE_TB
- en: '| `[21, ∞)` | T |'
  prefs: []
  type: TYPE_TB
- en: Conventionally a missing bound is implied to extend to infinity, so we write
    `[21, ∞)` as `[21, )`.
  prefs: []
  type: TYPE_NORMAL
- en: Aesthetics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are habits that make decision tables more visually pleasing. I have no
    idea if they actually make them better or are just decoration.
  prefs: []
  type: TYPE_NORMAL
- en: Row ordering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rows should be ordered by column value. The leftmost column is the most significant
    key, then the second leftmost, all the way forward. In other words:'
  prefs: []
  type: TYPE_NORMAL
- en: This makes it easier to read the table. If you know your inputs and are looking
    for the output, you can binary search the values.
  prefs: []
  type: TYPE_NORMAL
- en: Values should all be sorted the same way. If one column places T before F, other
    columns shouldn’t place F before T. I strongly prefer to sort with T first.
  prefs: []
  type: TYPE_NORMAL
- en: Column Ordering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order of the columns should match the order someone would naturally reason
    through the decision. If you’re making the table for a login flow, you might have
    conditions for `valid_user?` and `correct_password?`. Since it doesn’t make sense
    to talk about the password before you have the user, most people would think about
    finding the user first. The column for that condition should appear before the
    password column.
  prefs: []
  type: TYPE_NORMAL
- en: A lesser consideration is handling `Any` fields (see below). Columns with `-`
    values matter less in the table and should be placed later.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t think the `-` rule is as aesthetically valuable as the “most important
    columns first” rule, and neither rule is as important as the row rule.
  prefs: []
  type: TYPE_NORMAL
- en: Legends
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If one of your fields isn’t a boolean, explicitly enumerate the possibilities.
    It might be implicitly defined in the table, but that’s too easy to confuse.
  prefs: []
  type: TYPE_NORMAL
- en: Is this table complete? We don’t know. It could be missing the row `|F, Yellow|`!
    The legend doesn’t have to be part of the table itself, as long as the reader
    can infer it from the surrounding context. Let the reader know that Q can have
    values `{red, blue}`.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common problem with decision tables is bloat: if you have five boolean
    columns, your table will have 32 rows. Add a sixth and then you’re at 64\. Most
    techniques are about reducing bloat, such as by compressing rows or decomposing
    tables.'
  prefs: []
  type: TYPE_NORMAL
- en: Any/-
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pretty much everybody does this. `-` means “for any value”. These two tables
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | 3 |'
  prefs: []
  type: TYPE_TB
- en: '`-` is great for simplifying tables. It’s easy to check for completeness, as
    you can map the compact version to the full version. If a table consists of four
    booleans, then `|T - - -|` maps to 8 rows.'
  prefs: []
  type: TYPE_NORMAL
- en: Aesthetically it looks more pleasant when values don’t follow `-`. `|T - - F|`
    just looks funny. Sometimes I shuffle around the columns to make the dashes line
    up. This isn’t always possible, though, and it might obscure the natural flow
    of the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a couple pitfalls to `-`. First, you can accidentally be unsound, as
    each `-` expands to several rows. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: This is complete but unsound, as `|T T|` maps to both 1 and 2\. The other pitfall
    is implicit ordering. We might have
  prefs: []
  type: TYPE_NORMAL
- en: It’s tempting to write this as
  prefs: []
  type: TYPE_NORMAL
- en: Now the order of the rows matters! Someone can figure out what you mean here,
    but now it’s no longer explicit. Prefer to list things out here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notation note: `-` usually means “any”, but that’s not always clear. It’s easy
    to think the symbol means “unknown” or “n/a”. If you have concerns then prefer
    to be explicit. You should probably use a different symbol if you’re using `+`
    as a value.'
  prefs: []
  type: TYPE_NORMAL
- en: Input Elimination
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often by using `-` we find that a column is unnecessary. Given the table
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | 2 |'
  prefs: []
  type: TYPE_TB
- en: We can simplify this as
  prefs: []
  type: TYPE_NORMAL
- en: In this way decision tables can help us determine if some inputs are unnecessary
    for our logic.
  prefs: []
  type: TYPE_NORMAL
- en: Table Decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An output is **dependent** on an input if that input plays “some role” on that
    output. Not all outputs may be dependent on all inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | O1 | O2 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | F | T |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | F | F |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | T | F |'
  prefs: []
  type: TYPE_TB
- en: 'O1 only depends on P and O2 only depends on Q. We can decompose this table
    into two smaller ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Decomposing tables makes them simpler but isn’t always the right choice. If
    O1 and O2 are conceptually related, this might things less clear to the reader.
    Nor does decomposing always reduce the size of your table. An outcome might be
    dependent on one value while the other might be dependent on both.
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | O1 | O2 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | T | F |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | F | F |'
  prefs: []
  type: TYPE_TB
- en: Decomposing this table would give you two tables with a total of six rows. On
    the other hand, if O1 and O2 are totally conceptually distinct it might be clearer
    to break them into separate tables. As always, what’s best is highly context-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: Input Dependence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inputs are dependent if one can restrict the values of another. Take the following
    three business rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If a form doesn’t exist, redirect them to the “start” page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the form exists and hasn’t been submitted, redirect to “continue”.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the form exists and has been submitted, redirect to “review”.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We could write this as two booleans: `form_exists?` and `submitted?`. Submitted
    is only a meaningful boolean if the form already exists. We can instead fold these
    two booleans into a single column, such as `form_status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `form_status` | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `not_started` | “start” |'
  prefs: []
  type: TYPE_TB
- en: '| `incomplete` | “continue” |'
  prefs: []
  type: TYPE_TB
- en: '| `submitted` | “review” |'
  prefs: []
  type: TYPE_TB
- en: 'This breaks down for larger tables. Consider a login table with three values:
    `password_correct?`, `2auth_enabled?`, and `2auth_correct?`. Whether or not you
    have 2auth is irrelevant if you don’t know the password, and asking if you passed
    the 2auth is nonsensical if you have it disabled. There’s a few different ways
    to model this, all awkward. The simplest is probably to use another symbol, like
    `/`, to tell the reader that it’s impossible:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `password-correct?` | `2auth-enabled?` | `2auth-correct?` | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | T | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | F | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | / | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| F | - | / | 1 |'
  prefs: []
  type: TYPE_TB
- en: If you’d prefer to not introduce a new symbol and turn your booleans into trileans
    then another alternative is to use `any`. This is a little deceptive, as it implies
    the column *has* a value, we just don’t care what it is. It works but make logicians
    very sad.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When handling dependent inputs, it matters whether the dependence is a **fact**
    or if it’s an **assertion**. A fact is something that *cannot possibly* be false.
    If we run into a case where it is false, then a software bug is the least of our
    worries. This most often happens when the conditions are incompatible and only
    one of them can be true. In this case, we can fold the columns into an enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: '| `thread1_lock?` | `thread2_lock?` | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| … | … | … |'
  prefs: []
  type: TYPE_TB
- en: '| `lock_held_by` | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| None | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Thread 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Thread 2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: An assertion, by contrast, is something we build the system to guarantee. It
    can, in reality, be false, but ideally it’s never false in our system.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally is a dangerous word. In this case I’d want to be clear that the odd
    combination is not something that *can’t possibly* happen, it’s something that
    *shouldn’t* happen. That means if it *does* happen, there’s something wrong and
    we should stop and figure that out. Perhaps we wrote our own locking mechanism
    and aren’t completely sure it’s correct, maybe we’re worried about cosmic rays,
    whatever. These possibilities should be explicitly enumerated, and the output
    should be clearly marked as unspecified or an error.
  prefs: []
  type: TYPE_NORMAL
- en: '| `thread1_lock?` | `thread2_lock?` | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | **???** |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | **error** |'
  prefs: []
  type: TYPE_TB
- en: '| … | … | … |'
  prefs: []
  type: TYPE_TB
- en: The simplest answer here is to redesign your system to handle it, but that might
    not be feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Subtables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If many inputs or outputs are dependent on a single input, it makes sense to
    break this into a separate table. The two tables should refer to each other. See
    for example [here](https://help.sap.com/viewer/2754875d2d2a403f95e58a41a9c7d6de/1911/en-US/2bccc3ed722d1014a688d77c71096543.html).
    I’ve struggled to find a good teaching example so am only mentioning this for
    completeness.
  prefs: []
  type: TYPE_NORMAL
- en: More difficult situations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Independent Intervals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with intervals we run into a problem where different conditions
    may depend on distinct partitions of the interval into ranges.
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | `[0, 2]` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| T | `(2, 10]` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| F | `[0, 4)` | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| F | `[4, 10]` | 4 |'
  prefs: []
  type: TYPE_TB
- en: This is especially common when working with date intervals, as we saw with the
    [Rose Kata](https://www.hillelwayne.com/requirements/). The problem is ensuring
    completeness. If we have two separate sets of interval covers, we lose our direct
    mapping between the possible values and the total number of rows. It’s also easy
    to accidentally miss something.
  prefs: []
  type: TYPE_NORMAL
- en: A thorough-but-bloaty solution is to combine all of the intervals into one superset
    with no overlaps.
  prefs: []
  type: TYPE_NORMAL
- en: '| P | Q | O |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | `[0, 2]` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| T | `(2, 4)` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| T | `[4, 10]` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| F | `[0, 2]` | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| F | `(2, 4)` | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| F | `[4, 10]` | 4 |'
  prefs: []
  type: TYPE_TB
- en: This makes the table more formalized at the cost of bloat and concealing the
    underlying logic. You also need to watch for mistakes in translating to the new
    partitions, especially at the boundaries of intervals.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Really you should be using transition tables or state machines to formalize
    state, but we can handle small problems with decision tables. If we want a decision
    table to represent a mutation, we need to make explicit the difference between
    the old and new values on the table. The convention is write the variable with
    a prime. If the table mutates `x`, we write the original value as `x` and the
    new value as `x'`.
  prefs: []
  type: TYPE_NORMAL
- en: '| `x % 2 == 0` | `x''` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | `x/2` |'
  prefs: []
  type: TYPE_TB
- en: '| F | `3x+1` |'
  prefs: []
  type: TYPE_TB
- en: 'Each table should only model one step. In the body of the table, `x` always
    refers to the old value and `x''` should not appear at all. Multiple outputs can
    depend on `x`, though, making this useful for representing simultaneous mutations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to represent a more complex update, we can break it down into one
    table that defines `x''` and one that defines `x''''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `x''` | `x''''` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(, 0]` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `[1, 50]` | `x''` |'
  prefs: []
  type: TYPE_TB
- en: '| `[51, )` | 50 |'
  prefs: []
  type: TYPE_TB
- en: Representing state in decision tables gets awkward quickly and it doesn’t quite
    scale to complex state.
  prefs: []
  type: TYPE_NORMAL
- en: More Complex State
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Make a damn state machine
  prefs: []
  type: TYPE_NORMAL
- en: When you’re going too far
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Decision tables have minimal syntax and semantics. They are easy to use. They
    also quickly hit limits.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t like saying “don’t use them when they’re inappropriate”, because that
    sounds like smug avoidance to me. That answer doesn’t give you any insight into
    when they are inappropriate. We want to be specific about when they become inappropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decision tables work best when the entire problem can be modeled as discrete,
    independent inputs. Break that and everything falls apart. Sometimes you can refine
    the problem space like we did with intervals, but that only gets you so far. Other
    signs that decision tables are inappropriate include:'
  prefs: []
  type: TYPE_NORMAL
- en: When you have complex data structures. If one of the inputs is a list of integers,
    your table is going to be huge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the decision is made “over time”, where you have to perform some effects
    in order to complete the decision. DTs model instantaneous decisions. Consider
    a flowchart instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there’s no easy way to encode your data in a way that the table is “obviously”
    complete. If your input is “three events with a ranking”, a complete table will
    still look like it is missing rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the table gets extremely large.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a table layout doesn’t make anything clearer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How strict you need to be about your decision tables depends on what you’re
    using them for. If your goal is to have a specification artifact then you want
    to be as rigorous as possible. You want to be strict if you’re trying to explicitly
    shakeout design issues or plan to high-level project-level decisions based on
    the table. If you’re using the decision table as a mental augmentation tool, then
    taking shortcuts is fine. The goal is to help you think better and excessive formalism
    doesn’t always lead to insight.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decision tables are easy, simple, and powerful. You can teach them in five minutes
    and write one in half that time. And while they have a low expressiveness ceiling,
    there’s no opportunity cost to trying them first. Worst case is you lose a few
    minutes before realizing they’re inappropriate for your problem.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see decision tables used in the wild, two good examples are [here](https://github.com/rails/rails/pull/36795#issuecomment-515914165)
    and [here](https://twitter.com/jesterxl/status/1222728288117972992).
  prefs: []
  type: TYPE_NORMAL
- en: I hope this made decision tables more accessible to you. If you’re interested
    in my other writing, in addition to this site I have a twice-weekly [newsletter](https://buttondown.email/hillelwayne/)
    on software and a [Twitter](https://twitter.com/hillelogram) that’s a mix of tech,
    math, confectioning, and general Twitter inanery.
  prefs: []
  type: TYPE_NORMAL
- en: '*Thanks to [Nicolas Rinaudo](https://nrinaudo.github.io/) for feedback.*'
  prefs: []
  type: TYPE_NORMAL
