- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: æœªåˆ†ç±»'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:30:18'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: How to Control Strict Mode | JavaScript Katas
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: æ¥æºï¼š[https://jskatas.org/blog/2023/10/16-control-strict-mode/](https://jskatas.org/blog/2023/10/16-control-strict-mode/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I was surprised to see that the worker threads run in non-strict mode by default.
    This should rarely happen, because when using ES modules (ESMs), classes or `"use
    strict"` then the engine forces strict mode. I didn't know this in the beginning.
    I have been working on the katas I use for this site in the [javascript-katas
    repo](https://codeberg.org/wolframkriesing/javascript-katas) which uses ESMs and
    `type=module`, my default. This makes the entire nodejs project, any `npm ...`
    command run use strict mode. Escaping from strict mode is not easily possible,
    but one way to run code in non-strict mode is by using a worker thread.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: I always like to understand where things originate, so let's read about strict
    mode.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Strict Mode â€“ When and Why?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strict mode was introduced [in ES5 (in 2009)](https://262.ecma-international.org/5.1/#sec-4.2.2).
    In the specification it says strict mode was added
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: in the interests of security, to avoid what [...] consider to be error-prone
    features, to get enhanced error checking
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: and
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The strict variant also specifies additional error conditions that must be reported
    by throwing error exceptions
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So strict mode was introduced for making JS safer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Strict Mode?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually the worker I used was just a mean to solve my actual problem, which
    was running tests for the `arguments` kata. In order to do that I needed to run
    the tests in non-strict mode, so let's have a look at the strict mode.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Where does the strict mode play a role now? I had been diving deep into the
    "function API", digging in the very first [ES1 spec](https://www.ecma-international.org/wp-content/uploads/ECMA-262_1st_edition_june_1997.pdf)
    and all versions beyond to find out when was what introduced or deprecated (deprecation
    happens rarely in JavaScript). So I came across `arguments` and when I wrote the
    following test:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It failed with "Uncaught SyntaxError: Unexpected eval or arguments in strict
    mode", which was not due to the test code itself, but the rest of the code I ran
    in the worker thread. The above test only got injected and makes only a small
    part of the entire code run in the worker. The code has an `import` in it, which
    turned all the code to be run in strict mode. And as the error says `arguments`
    is not allowed in strict mode.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: So I want to control when to turn on strict mode. But for that let's understand
    strict mode a bit better first.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: What forces Strict Mode?
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned above `"use strict"` turns on strict mode, but in this case there
    was none in the worker code yet, so what turned it on? In the [ES6 spec chapter
    "Strict Mode Code"](https://262.ecma-international.org/6.0/#sec-strict-mode-code)
    the following lines were newly added which force strict mode to turn on:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Module code is always strict mode code.
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All parts of a ClassDeclaration or a ClassExpression are strict mode code.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ClassDeclaration æˆ– ClassExpression çš„æ‰€æœ‰éƒ¨åˆ†éƒ½æ˜¯ä¸¥æ ¼æ¨¡å¼ä»£ç ã€‚
- en: So the `import` turned it on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥`import`æŠŠå®ƒæ‰“å¼€äº†ã€‚
- en: How to Control Strict Mode?
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¦‚ä½•æ§åˆ¶ä¸¥æ ¼æ¨¡å¼ï¼Ÿ
- en: So I rewrote the code to not use `import` and it ran in non-strict mode.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘é‡å†™äº†ä»£ç ï¼Œä¸ä½¿ç”¨`import`ï¼Œå®ƒåœ¨éä¸¥æ ¼æ¨¡å¼ä¸‹è¿è¡Œã€‚
- en: Now I can control strict mode, I just have to add `"use strict"` at the top
    of the code. Even better, I can put `"use strict"` at the beginning of a function
    body, and it makes only this function run in strict mode. It must be the first
    statement in this function, see the code below for some exploration. Oooh, I see
    new katas arising.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘å¯ä»¥æ§åˆ¶ä¸¥æ ¼æ¨¡å¼ï¼Œæˆ‘åªéœ€åœ¨ä»£ç é¡¶éƒ¨æ·»åŠ `"use strict"`ã€‚æ›´å¥½çš„æ˜¯ï¼Œæˆ‘å¯ä»¥æŠŠ`"use strict"`æ”¾åœ¨å‡½æ•°ä½“çš„å¼€å¤´ï¼Œåªæœ‰è¿™ä¸ªå‡½æ•°ä»¥ä¸¥æ ¼æ¨¡å¼è¿è¡Œã€‚å®ƒå¿…é¡»æ˜¯è¿™ä¸ªå‡½æ•°ä¸­çš„ç¬¬ä¸€æ¡è¯­å¥ï¼Œè¯·å‚è§ä¸‹é¢çš„ä»£ç è¿›è¡Œä¸€äº›æ¢ç´¢ã€‚å“¦ï¼Œæˆ‘çœ‹åˆ°äº†æ–°çš„æŒ‘æˆ˜å‡ºç°äº†ã€‚
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The above fails with the error message we know from above "Unexpected eval or
    arguments in strict mode".
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ä»£ç å‡ºé”™äº†ï¼Œæˆ‘ä»¬ä»ä¸Šé¢çŸ¥é“çš„é”™è¯¯æ¶ˆæ¯æ˜¯"åœ¨ä¸¥æ ¼æ¨¡å¼ä¸‹ï¼Œæ„å¤–çš„ eval æˆ– arguments"ã€‚
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The above fails too, for the same reason. Here only the function is run in strict
    mode, but that's also where `arguments` is used, so it fails.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„ä»£ç ä¹Ÿå› ä¸ºåŒæ ·çš„åŸå› å¤±è´¥äº†ã€‚è¿™é‡Œåªæœ‰å‡½æ•°åœ¨ä¸¥æ ¼æ¨¡å¼ä¸‹è¿è¡Œï¼Œä½†è¿™ä¹Ÿæ˜¯ä½¿ç”¨`arguments`çš„åœ°æ–¹ï¼Œæ‰€ä»¥å®ƒå¤±è´¥äº†ã€‚
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Passes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡äº†ã€‚
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And this one passes too, because the `"use strict"` strings are not at the
    beginning of a function. I was irritated in the beginning, because I expected
    it to be at the beginning of a scope, so after the `{`, but I was wrong. The [spec
    also states](https://262.ecma-international.org/5.1/#sec-10.1.1) this explicitly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¹Ÿé€šè¿‡äº†ï¼Œå› ä¸º`"use strict"`å­—ç¬¦ä¸²ä¸åœ¨å‡½æ•°çš„å¼€å¤´ã€‚ä¸€å¼€å§‹æˆ‘å¾ˆçƒ¦æ¼ï¼Œå› ä¸ºæˆ‘æœŸæœ›å®ƒåœ¨ä½œç”¨åŸŸçš„å¼€å¤´ï¼Œå³åœ¨`{`ä¹‹åï¼Œä½†æˆ‘é”™äº†ã€‚[è§„èŒƒä¹Ÿè¯´æ˜äº†](https://262.ecma-international.org/5.1/#sec-10.1.1)è¿™ä¸€ç‚¹ï¼š
- en: if the function code begins with a Directive Prologue that contains a Use Strict
    Directive.
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœå‡½æ•°ä»£ç ä»¥åŒ…å« Use Strict Directive çš„ Directive Prologue å¼€å¤´ã€‚
- en: in human words, this means the function must start with a `"use strict"` string.
    The scope is not mentioned there. The spec defines three more cases in very hard
    to read words. These are 1) the global code, 2) eval code and 3) `Function` code,
    when either starts with a `"use strict"` string, then the entire code is run in
    strict mode.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥äººç±»çš„è¯­è¨€æ¥è¯´ï¼Œè¿™æ„å‘³ç€å‡½æ•°å¿…é¡»ä»¥`"use strict"`å­—ç¬¦ä¸²å¼€å¤´ã€‚ä½œç”¨åŸŸæ²¡æœ‰åœ¨é‚£é‡ŒæåŠã€‚è§„èŒƒç”¨éå¸¸éš¾ä»¥ç†è§£çš„è¯è¯­å®šä¹‰äº†å¦å¤–ä¸‰ç§æƒ…å†µã€‚è¿™äº›æƒ…å†µæ˜¯
    1ï¼‰å…¨å±€ä»£ç ï¼Œ2ï¼‰eval ä»£ç å’Œ 3ï¼‰`Function` ä»£ç ï¼Œå½“å®ƒä»¬ä¸­çš„ä»»ä½•ä¸€ä¸ªä»¥`"use strict"`å­—ç¬¦ä¸²å¼€å§‹æ—¶ï¼Œæ•´ä¸ªä»£ç å°±ä¼šåœ¨ä¸¥æ ¼æ¨¡å¼ä¸‹è¿è¡Œã€‚
- en: With this I did not only learn what strict mode restricts, but also how to control
    it. And all the magic is gone.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äº†è¿™ä¸ªï¼Œæˆ‘ä¸ä»…äº†è§£äº†ä¸¥æ ¼æ¨¡å¼é™åˆ¶äº†ä»€ä¹ˆï¼Œè¿˜å­¦ä¼šäº†å¦‚ä½•æ§åˆ¶å®ƒã€‚æ‰€æœ‰çš„é­”æ³•éƒ½æ¶ˆå¤±äº†ã€‚
- en: ğŸ’¡ **To turn on strict mode, you can use `"use strict"` in the four described
    ways, classes or modules. That's how strict mode can be (manually) turned or forced
    to be on.**
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡ **è¦å¯ç”¨ä¸¥æ ¼æ¨¡å¼ï¼Œæ‚¨å¯ä»¥åœ¨å››ç§æè¿°çš„æ–¹å¼ã€ç±»æˆ–æ¨¡å—ä¸­ä½¿ç”¨`"use strict"`ã€‚è¿™å°±æ˜¯ä¸¥æ ¼æ¨¡å¼å¯ä»¥ï¼ˆæ‰‹åŠ¨ï¼‰æ‰“å¼€æˆ–å¼ºåˆ¶æ‰“å¼€çš„æ–¹å¼ã€‚**
