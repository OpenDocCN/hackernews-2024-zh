<!--yml

category: 未分类

日期：2024-05-27 14:48:39

-->

# SQLite：Wal2 模式备注

> 来源：[`www.sqlite.org/cgi/src/doc/wal2/doc/wal2.md`](https://www.sqlite.org/cgi/src/doc/wal2/doc/wal2.md)

## 激活/停用 Wal2 模式

"Wal2" 模式与 "wal" 模式非常相似。要将数据库更改为 wal2 模式，请使用以下命令：

> ```
>  PRAGMA journal_mode = wal2; 
> ```

不可能直接从 "wal" 模式更改为 "wal2" 模式。相反，它必须首先更改为回滚模式。因此，要将 wal 模式数据库更改为 wal2 模式，可以使用以下两个命令：

> ```
>  PRAGMA journal_mode = delete;
>  PRAGMA journal_mode = wal2; 
> ```

以 wal2 模式的数据库只能通过从此分支编译的 SQLite 版本访问。尝试使用任何其他版本的 SQLite 会导致 SQLITE_NOTADB 错误。使用以下命令可将 wal2 模式数据库改回回滚模式（使其可由所有版本的 SQLite 访问）：

> ```
>  PRAGMA journal_mode = delete; 
> ```

## Wal2 模式的优势

在传统的 wal 模式中，当写入者向数据库写入数据时，它不会直接修改数据库文件。相反，它会将新数据追加到“<数据库>-wal”文件中。读取者从原始数据库文件和“<数据库>-wal”文件中读取数据。在某个时候，数据从“<数据库>-wal”文件复制到数据库文件中，之后可以删除或覆盖 wal 文件。从 wal 文件中复制数据到数据库文件称为“检查点”，可以显式地完成（通过“PRAGMA wal_checkpoint”或 sqlite3_wal_checkpoint_v2()），也可以自动完成（通过配置“PRAGMA wal_autocheckpoint”—这是默认的）。

检查点不会阻塞写入者，写入者也不会阻塞检查点。然而，如果在检查点正在进行时写入者向数据库写入数据，那么新数据会被追加到 wal 文件的末尾。这意味着，即使在检查点之后，wal 文件也不能被覆盖或删除，因此所有后续的事务也必须被追加到 wal 文件。检查点的工作不会被浪费——SQLite 会记住已经被复制到数据库文件的 wal 文件的哪些部分，以便下一个检查点不必再次复制——但这也意味着，如果检查点永远没有机会无障碍地完成而不被写入者追加到 wal 文件，wal 文件可能会无限增长。在繁忙的系统中还有一些情况，长时间运行的读取者可能会阻止检查点将整个 wal 文件检查点——也会导致 wal 文件无限增长。

Wal2 模式不会出现这个问题。在 wal2 模式下，即使检查点永远不能无障碍地完成，wal 文件也不会无限增长。

在 wal2 模式下，系统使用两个 wal 文件而不是一个。文件的命名为“<数据库>-wal”和“<数据库>-wal2”，其中“<数据库>”当然是数据库文件的名称。当数据写入数据库时，写入器首先将新数据追加到第一个 wal 文件中。一旦第一个 wal 文件增长到足够大，写入器就会切换到向第二个 wal 文件追加数据。此时，可以对第一个 wal 文件进行检查点（之后可以覆盖它）。然后，一旦第二个 wal 文件增长到足够大并且第一个 wal 文件已经检查点，写入器就会切换回第一个 wal 文件。依此类推。

## 应用程序编程

从用户的角度看，wal 和 wal2 模式之间的主要区别与检查点有关：

+   在 wal 模式下，可以随时尝试检查点。在 wal2 模式下，检查点器必须等到写入器切换到“另一个”wal 文件后才能进行检查点。

+   在 wal 模式下，wal 钩子（使用 sqlite3_wal_hook() 注册的回调）在事务提交后被调用，并将 wal 文件中的总页数作为参数。在 wal2 模式下，参数是两个 wal 文件中未检查点的总页数，或者如果“另一个” wal 文件为空或已经检查点，则为 0。

建议客户使用与 wal 数据库相同的策略来检查点 wal2 模式数据库 - 通过使用 sqlite3_wal_hook() 注册 wal 钩子，并在参数超过一定阈值时尝试检查点。

但是，应该注意的是，尽管 wal 钩子在每个事务提交到磁盘并释放数据库锁后被调用，但它仍然是在用于执行“COMMIT”命令的 sqlite3_step() 调用内部被调用的。在 BEGIN CONCURRENT 系统中，“COMMIT”通常由应用程序互斥体保护，这可能会降低并发性。在这种系统中，不应该在 wal 钩子内部执行检查点，而是可以在应用程序互斥体释放后再执行此操作。
