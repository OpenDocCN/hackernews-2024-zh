- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 15:00:11'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 15:00:11'
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'PHP: a fractal of bad design / fuzzy notepad'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP：一种糟糕设计的分形 / 模糊的便笺
- en: 来源：[https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/)
- en: '*(This article has been translated into [Spanish](/media/2012-04/PHP%20Anatom%C3%ADa%20del%20mal%20dise%C3%B1o.pdf)
    (PDF, with some additions) by Jorge Amado Soria Ramirez — thanks!)*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*（这篇文章已被[Jorge Amado Soria Ramirez](/media/2012-04/PHP%20Anatom%C3%ADa%20del%20mal%20dise%C3%B1o.pdf)（PDF，带有一些补充）翻译成[西班牙语](/media/2012-04/PHP%20Anatom%C3%ADa%20del%20mal%20dise%C3%B1o.pdf)
    — 感谢！）*'
- en: I’m cranky. I complain about a lot of things. There’s a lot in the world of
    technology I don’t like, and that’s really to be expected—programming is a hilariously
    young discipline, and none of us have the slightest clue what we’re doing. Combine
    with [Sturgeon’s Law](http://en.wikipedia.org/wiki/Sturgeon%27s_Law), and I have
    a lifetime’s worth of stuff to gripe about.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我是个脾气暴躁的人。我抱怨很多事情。在技术世界里有很多我不喜欢的东西，这是可以预料的——编程是一个非常年轻的学科，我们都不知道自己在做什么。再加上[斯特金定律](http://en.wikipedia.org/wiki/Sturgeon%27s_Law)，我有一辈子的事情可以抱怨。
- en: This is not the same. PHP is not merely awkward to use, or ill-suited for what
    I want, or suboptimal, or against my religion. I can tell you all manner of good
    things about languages I avoid, and all manner of bad things about languages I
    enjoy. Go on, ask! It makes for interesting conversation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这不一样。PHP 不仅仅是使用起来笨拙，或者不适合我想要的东西，或者是次优的，或者违背我的信仰。我可以告诉你有关我避开的语言的所有好东西，以及我喜欢的语言的所有坏东西。来吧，问问！这会是一次有趣的交谈。
- en: PHP is the lone exception. Virtually every feature in PHP is broken somehow.
    The language, the framework, the ecosystem, are all just **bad**. And I can’t
    even point out any single damning thing, because the damage is so systemic. Every
    time I try to compile a list of PHP gripes, I get stuck in this depth-first search
    discovering more and more appalling trivia. (Hence, fractal.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 是唯一的例外。PHP 中几乎每个特性都有些问题。语言、框架、生态系统，全部都很**糟糕**。我甚至不能指出任何一个单一的致命问题，因为损害是如此系统化的。每次我试图列出
    PHP 的抱怨清单时，我都会陷入这种深度优先搜索中，发现越来越多令人震惊的琐事。（因此，*分形*。）
- en: PHP is an embarrassment, a blight upon my craft. It’s so broken, but so lauded
    by every empowered amateur who’s yet to learn anything else, as to be maddening.
    It has paltry few redeeming qualities and I would prefer to forget it exists at all.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 让我感到尴尬，它是我的专业的耻辱。它如此破碎，但又被每一个只学会它而没有学到其他东西的有权势的业余爱好者赞扬，以至于令人发狂。它几乎没有什么可取之处，我宁愿忘记它的存在。
- en: But I’ve got to get this out of my system. So here goes, one last try.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但我必须把这些从我的系统中清除出去。所以，这是最后一次尝试。
- en: I just blurted this out to Mel to explain my frustration and she insisted that
    I reproduce it here.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是向 Mel 脱口而出，以解释我的沮丧，她坚持让我在这里复述一下。
- en: I can’t even say what’s *wrong* with PHP, because— okay. Imagine you have uh,
    a toolbox. A set of tools. Looks okay, standard stuff in there.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我甚至无法说出 PHP 有什么*问题*，因为——好吧。想象一下你有一个，嗯，工具箱。一套工具。看起来还不错，在里面有些标准的东西。
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You pull out a screwdriver, and you see it’s one of those weird tri-headed things.
    Okay, well, that’s not very useful to you, but you guess it comes in handy sometimes.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你拿出了一个螺丝刀，你看到它是一个那种奇怪的三头的东西。好吧，那对你来说不是很有用，但你猜它有时还是会派上用场的。
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You pull out the hammer, but to your dismay, it has the claw part on *both*
    sides. Still serviceable though, I mean, you can hit nails with the middle of
    the head holding it sideways.
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你拿出了锤子，但令你沮丧的是，它的爪子部分在*两侧*都有。但还算好用，我的意思是，你可以侧着拿着它，用锤子中间的头打钉子。
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You pull out the pliers, but they don’t have those serrated surfaces; it’s flat
    and smooth. That’s less useful, but it still turns bolts well enough, so whatever.
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你拿出了钳子，但它们没有那些锯齿状的表面；是平的和光滑的。这不太有用，但它仍然可以很好地拧螺丝钉，所以，无所谓了。
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And on you go. Everything in the box is kind of weird and quirky, but maybe
    not enough to make it *completely* worthless. And there’s no clear problem with
    the set as a whole; it still has all the tools.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后你继续。盒子里的每样东西都有点奇怪和古怪，但也许不足以使它*完全*无用。而且整体上没有明显的问题；它仍然拥有所有的工具。
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now imagine you meet millions of carpenters using this toolbox who tell you
    “well hey what’s the problem with these tools? They’re all I’ve ever used and
    they work fine!” And the carpenters show you the houses they’ve built, where every
    room is a pentagon and the roof is upside-down. And you knock on the front door
    and it just collapses inwards and they all yell at you for breaking their door.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在想象一下，你遇到了数百万使用这个工具箱的木匠，他们告诉你“嘿，这些工具有什么问题？这是我一直在用的，而且它们运行良好！” 木匠们向你展示了他们建造的房屋，其中每个房间都是五边形，屋顶倒置。你敲门，前门就坍塌了，他们都对你大喊大叫说你破坏了他们的门。
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That’s what’s wrong with PHP.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这就是 PHP 的问题所在。
- en: I assert that the following qualities are *important* for making a language
    productive and useful, and PHP violates them with wild abandon. If you can’t agree
    that these are crucial, well, I can’t imagine how we’ll ever agree on much.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我断言以下这些品质对于使一门语言具有生产力和实用性是*重要*的，而 PHP 则放任不管地违反了它们。如果你不能同意这些至关重要，那么，我无法想象我们如何能在很多事情上达成一致。
- en: A language must be **predictable**. It’s a medium for expressing human ideas
    and having a computer execute them, so it’s critical that a human’s understanding
    of a program actually be correct.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一门语言必须**可预测**。它是表达人类思想并让计算机执行它们的媒介，因此，人类对程序的理解实际上是*正确*的至关重要。
- en: A language must be **consistent**. Similar things should look similar, different
    things different. Knowing part of the language should aid in learning and understanding
    the rest.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一门语言必须**一致**。相似的事物应该看起来相似，不同的事物则不同。了解语言的一部分应该有助于学习和理解*其余部分*。
- en: A language must be **concise**. New languages exist to reduce the boilerplate
    inherent in old languages. (We *could* all write machine code.) A language must
    thus strive to avoid introducing new boilerplate of its own.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一门语言必须**简洁**。新语言的存在是为了减少旧语言中固有的样板代码。（我们*可以*都写机器码。）因此，一门语言必须努力避免引入新的自己的样板代码。
- en: A language must be **reliable**. Languages are tools for solving problems; they
    should minimize any new problems they introduce. Any “gotchas” are massive distractions.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一门语言必须**可靠**。语言是解决问题的工具；它们应该最小化引入的任何新问题。任何“陷阱”都是巨大的*干扰*。
- en: A language must be **debuggable**. When something goes wrong, the programmer
    *has* to fix it, and we need all the help we can get.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一门语言必须**易于调试**。当出现问题时，程序员*必须*修复它，我们需要尽一切可能的帮助。
- en: 'My position is thus:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我的立场是*如此*：
- en: 'PHP is full of surprises: `mysql_real_escape_string`, `E_ALL`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 充满了惊喜：`mysql_real_escape_string`，`E_ALL`
- en: 'PHP is inconsistent: `strpos`, `str_rot13`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 是不一致的：`strpos`，`str_rot13`
- en: 'PHP requires boilerplate: error-checking around C API calls, `===`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 需要样板代码：围绕 C API 调用的错误检查，`===`
- en: 'PHP is flaky: `==`, `foreach ($foo as &$bar)`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 不可靠：`==`，`foreach ($foo as &$bar)`
- en: 'PHP is opaque: no stack traces by default or for fatals, complex error reporting'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 是不透明的：默认情况下没有堆栈跟踪或者对致命错误的跟踪，复杂的错误*报告*
- en: I can’t provide a paragraph of commentary for every single issue explaining
    why it falls into these categories, or this would be endless. I trust the reader
    to, like, think.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法为每个问题提供一段评论来解释它为什么属于这些类别，否则这将是无休止的。我相信读者会，就像，*思考*。
- en: I’ve been in PHP arguments a *lot*. I hear a lot of very generic counter-arguments
    that are really only designed to halt the conversation immediately. Don’t pull
    these on me, please. :(
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在 PHP 争论中*很多次*。我听到很多非常通用的反对意见，这些反对意见实际上只是为了立即停止对话。请不要对我使用这些，请*:(*
- en: Do not tell me that “good developers can write good code in any language”, or
    bad developers blah blah. That doesn’t *mean* anything. A good carpenter *can*
    drive in a nail with either a rock or a hammer, but how many carpenters do you
    see bashing stuff with rocks? Part of what makes a good developer is the ability
    to *choose* the tools that work best.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要告诉我“优秀的开发者可以用任何语言编写优秀的代码”，或者差劲的开发者之类的。那*没有*任何意义。一个优秀的木匠*可以*用石头或者锤子来钉钉子，但你见过多少木匠用石头乱砸东西？成为优秀开发者的一部分是能够*选择*最适合自己的工具。
- en: Do not tell me that it’s the developer’s responsibility to memorize a thousand
    strange exceptions and surprising behaviors. Yes, this is necessary in any system,
    because computers suck. That doesn’t mean there’s no upper limit for how much
    zaniness is acceptable in a system. PHP is nothing *but* exceptions, and it is
    not okay when wrestling the language takes more effort than actually writing your
    program. My tools should not create net positive work for me to do.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要告诉我，开发者的责任是记住一千个奇怪的异常和令人惊讶的行为。是的，这在任何系统中都是必要的，因为计算机很差劲。这并不意味着系统中可以接受多少荒谬之处是没有上限的。PHP
    只有异常，当与语言搏斗所花费的精力比编写程序实际花费的精力还要多时，这是不可接受的。我的工具不应该给我创造净正的工作。
- en: Do not tell me “that’s how the C API works”. What on Earth is the point of using
    a high-level language if all it provides are some string helpers and a ton of
    verbatim C wrappers? Just write C! Here, there’s even a [CGI library](http://www.boutell.com/cgic/)
    for it.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要告诉我“这就是 C API 的工作方式”。如果高级语言只提供一些字符串帮助程序和大量的直译 C 封装，那么使用它的意义何在？干脆写 C 吧！这里，甚至还有一个[CGI
    库](http://www.boutell.com/cgic/)。
- en: Do not tell me “that’s what you get for doing weird things”. If two features
    exist, someday, someone will find a reason to use them together. And again, this
    isn’t C; there’s no spec, there’s no need for “undefined behavior”.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要告诉我“这就是你因为做奇怪的事情而得到的结果”。如果有两个特性存在，总有一天，会有人找到理由将它们结合起来使用。而且，这不是 C；没有规范，也不需要“未定义的行为”。
- en: Do not tell me that Facebook and Wikipedia are built in PHP. I’m aware! They
    could also be written in Brainfuck, but as long as there are smart enough people
    wrangling the things, they *can* overcome problems with the platform. For all
    we know, development time could be halved or doubled if these products were written
    in some other language; this data point alone means nothing.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要告诉我 Facebook 和 Wikipedia 是用 PHP 构建的。我知道！它们也可以用 Brainfuck 写成，但只要有足够聪明的人来解决问题，他们*可以*克服平台的问题。我们只是了解到，如果这些产品用其他语言编写，开发时间可能会减半或翻倍；这个数据点本身并没有什么意义。
- en: Ideally, don’t tell me anything! This is my one big shot; if this list doesn’t
    hurt your opinion of PHP, *nothing* ever will, so stop arguing with some dude
    on the Internet and go make a cool website in record time to prove me wrong :)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，不要告诉我任何东西！这是我唯一的机会；如果这个列表不能改变你对 PHP 的看法，*没有*什么能够。所以停止在互联网上和某人争论，快去以创纪录的速度制作一个酷炫的网站，证明我是错的
    :)
- en: 'Side observation: I loooove Python. I will also happily talk your ear off complaining
    about it, if you really want me to. I don’t claim it’s *perfect*; I’ve just weighed
    its benefits against its problems and concluded it’s the best fit for things I
    want to do.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 旁观：我超级喜欢 Python。如果你真的想听我唠叨，我也很乐意吐槽它。我不认为它是*完美*的；我只是权衡了它的优点和问题，得出结论它是我想要做的事情的最佳选择。
- en: And I have never met a PHP developer who can do the same with PHP. But I’ve
    bumped into plenty who are quick to apologize for anything and everything PHP
    does. That mindset is terrifying.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我从来没有遇到过一个 PHP 开发者能够像对待 PHP 一样对待其他语言。但我遇到过很多对 PHP 所有行为都快速道歉的人。这种心态令人恐惧。
- en: CPAN has been called the “standard library of Perl”. That doesn’t say much about
    Perl’s standard library, but it makes the point that a solid core can build great things.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: CPAN 曾被称为 Perl 的“标准库”。这并没有多大的意义，但这说明了一个坚实的核心可以构建出伟大的东西。
- en: 'PHP was originally designed explicitly for non-programmers (and, reading between
    the lines, non-programs); it has not well escaped its roots. A choice quote from
    the [PHP 2.0 documentation](http://www.php.net/manual/phpfi2.php#overload), regarding
    `+` and friends doing type conversion:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 最初是专门为非程序员（读者可以自行揣摩）设计的；它并没有很好地摆脱自己的根源。摘自[PHP 2.0 文档](http://www.php.net/manual/phpfi2.php#overload)，关于
    `+` 和其他运算符进行类型转换的选择性引用：
- en: Once you start having separate operators for each type you start making the
    language much more complex. ie. you can’t use ‘==’ for stings [sic], you now would
    use ‘eq’. I don’t see the point, especially for something like PHP where most
    of the scripts will be rather simple and in most cases written by non-programmers
    who want a language with a basic logical syntax that doesn’t have too high a learning curve.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦你开始为每种类型设置单独的运算符，你就会使语言变得更加复杂。即。你不能对字符串使用‘==’，你现在会使用‘eq’。我不明白这样做的意义，特别是对于
    PHP 这样的语言，其中大部分脚本将是相当简单的，而且在大多数情况下是由非程序员编写的，他们希望使用一种具有基本逻辑语法的语言，学习曲线不会太高。
- en: PHP is built to keep chugging along at all costs. When faced with either doing
    something nonsensical or aborting with an error, it will do something nonsensical.
    Anything is better than nothing.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 被构建为不惜一切代价地继续运行。当面临着要么执行一些荒谬的操作，要么中止并显示错误时，它会执行一些荒谬的操作。任何事情都比什么都不做好。
- en: There’s no clear design philosophy. Early PHP was inspired by Perl; the huge
    stdlib with “out” params is from C; the OO parts are designed like C++ and Java.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有明确的设计理念。早期的 PHP 受 Perl 启发；带有“输出”参数的巨大 stdlib 来自 C；面向对象部分设计得像 C++ 和 Java。
- en: PHP takes vast amounts of inspiration from other languages, yet still manages
    to be incomprehensible to anyone who *knows* those languages. `(int)` looks like
    C, but `int` doesn’t exist. Namespaces use `\`. The new array syntax results in
    `[key => value]`, unique among every language with hash literals.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 从其他语言中汲取了大量灵感，但仍然难以理解对那些 *熟悉* 这些语言的人。`(int)` 看起来像 C，但 `int` 不存在。命名空间使用 `\`。新的数组语法导致
    `[key => value]`，在具有哈希字面量的每种语言中都是独一无二的。
- en: Weak typing (i.e., silent automatic conversion between strings/numbers/et al)
    is so complex that whatever minor programmer effort is saved is by no means worth it.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱类型（即字符串/数字/等之间的隐式自动转换）是如此复杂，以至于任何微小的程序员工作节省都绝对不值得。
- en: Little new functionality is implemented as new syntax; most of it is done with
    functions or things that look like functions. Except for class support, which
    deserved a slew of new operators and keywords.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很少有新功能实现为新的语法；大多数都是用函数或类似函数的东西完成的。除了类支持，它应该有一堆新的运算符和关键字。
- en: Some of the problems listed on this page do have first-party solutions—if you’re
    willing to pay Zend for fixes to their open-source programming language.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此页面列出的一些问题确实有第一方解决方案—如果你愿意为他们的开源编程语言向 Zend 支付修复费用的话。
- en: There is a whole lot of action at a distance. Consider this code, taken from
    the PHP docs somewhere.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有很多远程操作。考虑一下这段代码，摘自 PHP 文档的某处。
- en: '|  |'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE0]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: What will it do?
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它会做什么？
- en: If PHP was compiled with `--disable-url-fopen-wrapper`, it won’t work. (Docs
    don’t say what “won’t work” means; returns null, throws exception?) Note that
    this flag was removed in PHP 5.2.5.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 PHP 使用 `--disable-url-fopen-wrapper` 编译，它将不起作用。（文档没有说明“不起作用”是什么意思；返回 null，抛出异常？）请注意，此标志已在
    PHP 5.2.5 中删除。
- en: If `allow_url_fopen` is disabled in php.ini, this still won’t work. (How? No idea.)
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在 php.ini 中禁用了 `allow_url_fopen`，这仍然不起作用。（怎么不起作用？没有想法。）
- en: Because of the `@`, the warning about the non-existent file won’t be printed.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为有 `@`，关于不存在文件的警告将不会被打印出来。
- en: But it will be printed if `scream.enabled` is set in php.ini.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但如果在 php.ini 中设置了 `scream.enabled`，它将被打印出来。
- en: Or if `scream.enabled` is set manually with `ini_set`.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者如果手动使用 `ini_set` 设置了 `scream.enabled`。
- en: But not if the right `error_reporting` level isn’t set.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但如果没有设置正确的 `error_reporting` 等级，就不会做。
- en: If it *is* printed, exactly where it goes depends on `display_errors`, again
    in php.ini. Or `ini_set`.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *被打印出来*，它确切的位置取决于 `display_errors`，同样是在 php.ini 中。或 `ini_set`。
- en: I can’t tell how this innocuous function call will behave without consulting
    compile-time flags, server-wide configuration, and configuration done in my program.
    And this is all *built in* behavior.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我无法确定这个无害的函数调用在不查看编译时标志、服务器范围的配置和程序中的配置的情况下会表现出什么行为。而这一切都是 *内置的* 行为。
- en: The language is full of global and implicit state. `mbstring` uses a global
    character set. `func_get_arg` and friends look like regular functions, but operate
    on the currently-executing function. Error/exception handling have global defaults.
    `register_tick_function` sets a global function to run every tick—what?!
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言充满了全局和隐含的状态。`mbstring` 使用全局字符集。`func_get_arg` 等看起来像常规函数，但是操作的是当前执行的函数。错误/异常处理具有全局默认值。`register_tick_function`
    设置一个全局函数在每个时钟周期运行—什么？！
- en: There is no threading support whatsoever. (Not surprising, given the above.)
    Combined with the lack of built-in `fork` (mentioned below), this makes parallel
    programming extremely difficult.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何线程支持。（考虑到上述情况，这并不奇怪。）再加上缺乏内置的 `fork`（下文提到），这使得并行编程极其困难。
- en: Parts of PHP are practically *designed* to produce buggy code.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 的部分部分实际上 *被设计成* 产生有 bug 的代码。
- en: '`json_decode` returns null for invalid input, even though null is also a perfectly
    valid object for JSON to decode to—this function is *completely unreliable* unless
    you also call `json_last_error` every time you use it.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json_decode` 对于无效输入返回 null，尽管 null 也是 JSON 解码的一个完全有效的对象—除非你每次使用它时也调用 `json_last_error`，否则这个函数是
    *完全不可靠* 的。'
- en: '`array_search`, `strpos`, and similar functions return `0` if they find the
    needle at position zero, but false if they don’t find it at all.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array_search`、`strpos`和类似的函数在找到needle在位置零时返回`0`，但在根本找不到时返回false。'
- en: Let me expand on that last part a bit.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我稍微扩展一下最后一部分。
- en: In C, functions like `strpos` return `-1` if the item isn’t found. If you don’t
    check for that case and try to use that as an index, you’ll hit junk memory and
    your program will blow up. (Probably. It’s C. Who the fuck knows. I’m sure there
    are tools for this, at least.)
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在C中，像`strpos`这样的函数如果找不到该项则返回`-1`。如果你没有检查这种情况并尝试将其用作索引，你将会访问到垃圾内存，导致程序崩溃。（可能。这是C。谁tm知道。至少有一些工具可以做到这一点。）
- en: In, say, Python, the equivalent `.index` methods will raise an exception if
    the item isn’t found. If you don’t check for that case, your program will blow up.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 比如说，在Python中，等效的`.index`方法如果找不到该项会引发一个异常。如果你没有检查这种情况，你的程序将会崩溃。
- en: In PHP, these functions return false. If you use `FALSE` as an index, or do
    much of anything with it except compare with `===`, PHP will silently convert
    it to `0` for you. Your program will not blow up; it will, instead, do the *wrong
    thing* with *no warning*, unless you remember to include the right boilerplate
    around every place you use `strpos` and certain other functions.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在PHP中，这些函数会返回false。如果你把`FALSE`作为索引使用，或者对它做任何事情，除了与`===`比较，PHP会悄悄地把它转换为`0`。你的程序不会崩溃；相反，它会*不带任何警告*地执行*错误的操作*，除非你记得在每次使用`strpos`和某些其他函数的地方包含正确的样板。
- en: This is bad! Programming languages are tools; they’re supposed to work *with*
    me. Here, PHP has actively created a subtle trap for me to fall into, and I have
    to be vigilant even with such mundane things as string operations and equality
    comparison. PHP is a *minefield*.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这很糟糕！编程语言是工具；它们应该与我*协同工作*。在这里，PHP实际上为我设置了一个微妙的陷阱，我必须时刻保持警惕，即使在如字符串操作和相等比较这样的平凡事物上也是如此。PHP是一个*雷区*。
- en: I have heard a great many stories about the PHP interpreter and [its developers](http://en.wikiquote.org/wiki/Rasmus_Lerdorf)
    from a great many places. These are from people who have worked on the [PHP core](http://www.reddit.com/r/lolphp/comments/qeq7k/php_540_ships_with_82_failing_tests_in_the_suite/),
    [debugged PHP](http://perlbuzz.com/2008/09/optimizing-for-the-developer-not-the-user-php-misses-again.html)
    core, interacted with core developers. Not a single tale has been a compliment.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我听过很多关于PHP解释器和[其开发者](http://en.wikiquote.org/wiki/Rasmus_Lerdorf)的故事，来自很多地方。这些来自于曾在[PHP核心](http://www.reddit.com/r/lolphp/comments/qeq7k/php_540_ships_with_82_failing_tests_in_the_suite/)工作过、调试过PHP核心、与核心开发者互动过的人。没有一个故事是表扬的。
- en: 'So I have to fit this in here, because it bears repeating: PHP is a community
    of amateurs. Very few people designing it, working on it, or writing code in it
    seem to know what they’re doing. (Oh, dear reader, *you* are of course a rare
    exception!) Those who *do* grow a clue tend to drift away to other platforms,
    reducing the average competence of the whole. This, right here, is the biggest
    problem with PHP: it is absolutely the blind leading the blind.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我必须在这里说明一下，因为这值得重复：PHP是一个业余社区。设计它、开发它或在其中编写代码的人似乎很少知道他们在做什么。（哦，亲爱的读者，*你*当然是一个罕见的例外！）那些*确实*有点头脑的人往往会漂移到其他平台，从而降低整体的平均能力水平。这，就是PHP最大的问题所在：它绝对是盲人引导盲人。
- en: Okay, back to facts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，回到*事实*上来。
- en: There is no way to declare a variable. Variables that don’t exist are created
    with a null value when first used.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有办法声明一个变量。第一次使用时不存在的变量会被创建为null值。
- en: Global variables need a `global` declaration before they can be used. This is
    a natural consequence of the above, so it would be perfectly reasonable, except
    that globals can’t even be *read* without an explicit declaration—PHP will quietly
    create a local with the same name, instead. I’m not aware of another language
    with similar scoping issues.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量需要在使用之前进行`global`声明。这是上述情况的一个自然结果，所以这是完全合理的，除非全局变量甚至*在没有显式声明的情况下*也无法被*读取*
    — PHP将悄悄地创建一个同名的局部变量。我不知道还有哪种语言存在类似的作用域问题。
- en: There are no references. What PHP calls references are really aliases; there’s
    nothing that’s a step back, like Perl’s references, and there’s no pass-by-object
    identity like in Python.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有引用。PHP所谓的引用实际上是别名；没有任何向后的步骤，就像Perl的引用一样，并且没有像Python中的对象标识那样的传递。
- en: “Referenceness” infects a variable unlike anything else in the language. PHP
    is dynamically-typed, so variables generally have no type… except references,
    which adorn function definitions, variable syntax, and assignment. Once a variable
    is made a reference (which can happen anywhere), it’s stuck as a reference. There’s
    no obvious way to detect this and un-referencing requires nuking the variable entirely.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “引用性” 感染了变量，不像语言中的其他东西那样。PHP 是动态类型的，所以变量通常没有类型……除了引用，它装饰了函数定义、变量语法和赋值。一旦一个变量被设为引用（这可以在任何地方发生），它就会一直保持为引用。没有明显的方法来检测这一点，取消引用需要彻底摧毁变量。
- en: 'Okay, I lied. There are “[SPL types](http://www.php.net/manual/en/book.spl-types.php)”
    which also infect variables: `$x = new SplBool(true); $x = "foo";` will fail.
    This is like static typing, you see.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好吧，我撒了个谎。还有 “[SPL 类型](http://www.php.net/manual/en/book.spl-types.php)” 也会影响变量：`$x
    = new SplBool(true); $x = "foo";` 会失败。这就像静态类型，你 懂的。
- en: A reference can be taken to a key that doesn’t exist within an undefined variable
    (which becomes an array). Using a non-existent array normally issues a notice,
    but this does not.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对未定义变量（变成数组）中不存在的键取引用。通常使用不存在的数组会发出一个通知，但这 并不会。
- en: Constants are defined by a function call taking a string; before that, they
    don’t exist. (This may actually be a copy of Perl’s `use constant` behavior.)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量是通过一个接受字符串的函数调用来定义的；在此之前，它们不存在。（这实际上可能是 Perl 的 `use constant` 行为的一个复制。）
- en: Variable names are case-sensitive. Function and class names are not. This includes
    method names, which makes camelCase a strange choice for naming.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名区分大小写。函数和类名不区分大小写。这包括方法名，这使得驼峰命名法成为一个奇怪的选择。
- en: '`array()` and a few dozen similar constructs are not functions. `array` on
    its own means nothing, `$func = "array"; $func();` doesn’t work.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array()` 和几十个类似的构造不是函数。`array` 本身什么也不表示，`$func = "array"; $func();` 不 起作用。'
- en: Array unpacking can be done with the `list($a, $b) = ...` operation. `list()`
    is function-like syntax just like `array`. I don’t know why this wasn’t given
    real dedicated syntax, or why the name is so obviously confusing.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `list($a, $b) = ...` 操作进行数组解包。`list()` 是类似函数的语法，就像 `array` 一样。我不知道为什么这不是给予真正专用的语法，或者为什么名称如此明显 混淆。
- en: '`(int)` is obviously designed to look like C, but it’s a single token; there’s
    nothing called `int` in the language. Try it: not only does `var_dump(int)` not
    work, it throws a parse error because the argument looks like the cast operator.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(int)` 显然设计成像 C 语言一样，但它是一个单一的标记；语言中没有叫做 `int` 的东西。试试吧：`var_dump(int)` 不仅不起作用，而且抛出一个解析错误，因为参数看起来像是类型转换 运算符。'
- en: '`(integer)` is a synonym for `(int)`. There’s also `(bool)`/`(boolean)` and
    `(float)`/`(double)`/`(real)`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(integer)` 是 `(int)` 的同义词。还有 `(bool)`/`(boolean)` 和 `(float)`/`(double)`/`(real)`。'
- en: 'There’s an `(array)` operator for casting to array and an `(object)` for casting
    to object. That sounds nuts, but there’s almost a use: you can use `(array)` to
    have a function argument that’s either a single item or a list, and treat it identically.
    Except you can’t do that reliably, because if someone passes a single *object*,
    casting it to an array will actually produce an array containing that object’s
    attributes. (Casting to object performs the reverse operation.)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 `(array)` 操作符用于转换为数组，还有一个 `(object)` 用于转换为对象。听起来很疯狂，但几乎有一个用处：你可以使用 `(array)`
    有一个既可以是单个项又可以是列表的函数参数，并且对待它们是相同的。除非你不能可靠地做到这一点，因为如果有人传递一个单一的 *对象*，将其转换为数组将实际上产生包含该对象属性的数组。（转换为对象执行相反的 操作。）
- en: '`include()` and friends are basically C’s `#include`: they dump another source
    file into yours. There is no module system, even for PHP code.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include()` 和相关函数基本上是 C 的 `#include`：它们将另一个源文件倒入你的源文件。甚至对于 PHP 代码也没有模块系统。'
- en: There’s no such thing as a nested or locally-scoped function or class. They’re
    only global. Including a file dumps its variables into the current function’s
    scope (and gives the file access to your variables), but dumps functions and classes
    into global scope.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有嵌套或本地范围的函数或类。它们只是全局的。包含一个文件会将其变量倒入当前函数的作用域（并且给该文件访问你的变量的权限），但是将函数和类倒入全局 作用域。
- en: Appending to an array is done with `$foo[] = $bar`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向数组追加使用 `$foo[] = $bar`。
- en: '`echo` is a statement-y kind of thing, not a function.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`echo` 是一种语句式的东西，不是一个 函数。'
- en: '`empty($var)` is so extremely not-a-function that anything but a variable,
    e.g. `empty($var || $var2)`, is a parse error. Why on Earth does the parser need
    to know about [`empty`](http://phpsadness.com/sad/28)? (Fixed in 5.5.)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty($var)` 完全不是一个函数，所以除了变量以外的任何东西，例如 `empty($var || $var2)`，都是一个语法错误。为什么解析器需要知道
    [`empty`](http://phpsadness.com/sad/28) 是多么不可思议？（在 5.5 中修复）'
- en: 'There’s redundant syntax for blocks: `if (...): ... endif;`, etc.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '代码块有多余的语法：`if (...): ... endif;`，等等。'
- en: PHP’s one unique operator is `@` (actually borrowed from DOS), which *silences* errors.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 的一个独特运算符是 `@`（实际上是从 DOS 借用的），它*抑制*错误。
- en: PHP errors don’t provide stack traces. You have to install a handler to generate
    them. (But you can’t for fatal errors—see below.)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 错误不提供堆栈跟踪。您必须安装一个处理程序来生成它们。（但您不能为致命错误—见下文—安装处理程序。）
- en: PHP parse errors generally just spew the parse state and nothing more, making
    a forgotten quote [terrible to debug](http://phpsadness.com/sad/44).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 的解析错误通常只会输出解析状态，没有更多信息，导致忘记引号的情况[难以调试](http://phpsadness.com/sad/44)。
- en: PHP’s parser refers to e.g. `::` internally as `T_PAAMAYIM_NEKUDOTAYIM`, and
    the `<<` operator as `T_SL`. I say “internally”, but as above, this is what’s
    shown to the programmer when `::` or `<<` appears in the wrong place.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 的解析器在内部将例如 `::` 称为 `T_PAAMAYIM_NEKUDOTAYIM`，将 `<<` 运算符称为 `T_SL`。我说“内部”，但是如上所述，当
    `::` 或 `<<` 出现在错误的地方时，这就是向程序员显示的内容。
- en: Most error handling is in the form of printing a line to a server log nobody
    reads and carrying on.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数错误处理形式是将一行打印到没有人读取的服务器日志中并继续进行。
- en: '`E_STRICT` is a thing, but it doesn’t seem to actually prevent much and there’s
    no documentation on what it actually does.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_STRICT` 是一件事情，但似乎并没有真正阻止很多东西，而且对于它实际上是什么没有文档说明。'
- en: '`E_ALL` includes all error categories—except `E_STRICT`. (Fixed in 5.4.)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E_ALL` 包括所有错误类别 —— 除了 `E_STRICT`。（在 5.4 中修复）'
- en: 'Weirdly inconsistent about what’s allowed and what isn’t. I don’t know how
    `E_STRICT` applies here, but these things are okay:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对允许和不允许的事物非常不一致。我不知道 `E_STRICT` 在这里是如何适用的，但是以下这些事物是*允许的*：
- en: Trying to access a non-existent object property, i.e., `$foo->x`. (warning)
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试访问不存在的对象属性，即 `$foo->x`。（警告）
- en: Using a variable as a function name, or variable name, or class name. (silent)
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量作为函数名、变量名或类名。（无提示）
- en: Trying to use an undefined constant. (notice)
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用未定义的常量。（注意）
- en: Trying to access a property of something that isn’t an object. (notice)
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试访问非对象的属性。（注意）
- en: Trying to use a variable name that doesn’t exist. (notice)
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用不存在的变量名。（注意）
- en: '`2 < "foo"` (silent)'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2 < "foo"`（无提示）'
- en: '`foreach (2 as $foo);` (warning)'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foreach (2 as $foo);`（警告）'
- en: 'And these things are not:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而以下这些事物是*不允许的*：
- en: Trying to access a non-existent class constant, i.e., `$foo::x`. (fatal error)
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试访问不存在的类常量，即 `$foo::x`。（致命错误）
- en: Using a constant string as a function name, or variable name, or class name.
    (parse error)
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用常量字符串作为函数名、变量名或类名。（语法错误）
- en: Trying to call an undefined function. (fatal error)
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试调用一个未定义的函数。（致命错误）
- en: Leaving off a semicolon on the last statement in a block or file. (parse error)
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码块或文件的最后一条语句省略分号。（语法错误）
- en: Using `list` and various other quasi-builtins as method names. (parse error)
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `list` 和其他几个准内置函数作为方法名。（语法错误）
- en: Subscripting the return value of a function, i.e., `foo()[0]`. (parse error;
    okay in 5.4, see above)
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对函数返回值进行下标操作，即 `foo()[0]`。（语法错误；在 5.4 中可以，见上文）
- en: There are a good few examples of other weird parse errors elsewhere in this list.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此列表的其他地方有很多其他奇怪的解析错误示例。
- en: The `__toString` method can’t throw exceptions. If you try, PHP will… er, throw
    an exception. (Actually a fatal error, which would be passable, except…)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__toString` 方法不能抛出异常。如果尝试抛出，PHP 将会…… 嗯，抛出一个异常。（实际上是致命错误，这本来还能接受， 但……）'
- en: PHP errors and PHP exceptions are completely different beasts. They don’t seem
    to interact *at all*.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 错误和 PHP 异常完全是两种不同的东西。它们似乎*完全不*相互作用。
- en: PHP errors (internal ones, and calls to `trigger_error`) cannot be caught with
    `try`/`catch`.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 错误（内部错误和对 `trigger_error` 的调用）不能使用 `try`/`catch` 捕获。
- en: Likewise, exceptions do not trigger error handlers installed by `set_error_handler`.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，异常不会触发由 `set_error_handler` 安装的错误处理程序。
- en: Instead, there’s a separate `set_exception_handler` which handles uncaught exceptions,
    because wrapping your program’s entry point in a `try` block is impossible in
    the `mod_php` model.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，有一个单独的 `set_exception_handler` 处理未捕获的异常，因为在 `mod_php` 模型中无法将程序的入口点包装在 `try`
    块中。
- en: Fatal errors (e.g., `new ClassDoesntExist()`) can’t be caught by anything. A
    *lot* of fairly innocuous things throw fatal errors, forcibly ending your program
    for questionable reasons. Shutdown functions still run, but they can’t get a stack
    trace (they run at top-level), and they can’t easily tell if the program exited
    due to an error or running to completion.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 致命错误（例如，`new ClassDoesntExist()`）无法被任何东西捕获。相当多的相当无害的事情会引发致命错误，以疑问的原因强制结束你的程序。关闭函数仍然运行，但它们无法获得堆栈跟踪（它们在顶层运行），并且它们不能轻松地判断程序是由于错误还是运行到完成而退出。
- en: Trying to `throw` an object that isn’t an `Exception` results in… a fatal error,
    not an exception.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试`throw`一个不是`Exception`的对象会导致… 致命错误，而不是异常。
- en: There is no `finally` construct, making wrapper code (set handler, run code,
    unset handler; monkeypatch, run a test, unmonkeypatch) tedious and difficult to
    write. Despite that OO and exceptions were largely copied from Java, this [is
    deliberate](https://bugs.php.net/bug.php?id=32100), because `finally` “doesn’t
    make much sense in the context of PHP”. Huh? (Fixed in 5.5.)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`finally`结构，使得包装器代码（设置处理程序、运行代码、取消设置处理程序；猴子补丁，运行测试，取消猴子补丁）繁琐且难以编写。尽管OO和异常主要是从Java复制过来的，这[是故意的](https://bugs.php.net/bug.php?id=32100)，因为在PHP的环境中，“finally”“没有多少意义”。嗯？（在 5.5中修复。）
- en: Function calls are apparently rather [expensive](http://www.phpwtf.org/php-function-calls-have-quite-some-overhead).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用显然相当[昂贵](http://www.phpwtf.org/php-function-calls-have-quite-some-overhead)。
- en: Some built-in functions interact with reference-returning functions in, er,
    [a strange way](http://www.phpwtf.org/php-function-calls-returning-references).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些内置函数与返回引用函数交互的方式相当奇怪。 (http://www.phpwtf.org/php-function-calls-returning-references)。
- en: As mentioned elsewhere, a lot of things that look like functions or look like
    they *should* be functions are actually language constructs, so nothing that works
    with functions will work with them.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如其他地方所述，许多看起来像函数或看起来*应该*是函数的东西实际上是语言构造，因此与函数相关的所有东西都不适用于它们。
- en: 'Function arguments can have “type hints”, which are basically just static typing.
    But you can’t require that an argument be an `int` or `string` or `object` or
    other “core” type, even though every builtin function uses this kind of typing,
    probably because `int` is not a thing in PHP. (See above about `(int)`.) You also
    can’t use the special [pseudo-type decorations](http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed)
    used heavily by builtin functions: `mixed`, `number`, or `callback`. (`callable`
    is allowed as of PHP 5.4.)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数可以有“类型提示”，基本上只是静态类型。但是，你不能要求参数是`int`或`string`或`object`或其他“核心”类型，尽管每个内置函数都使用这种类型，可能是因为`int`在PHP中不存在。
    (参见上面关于`(int)`的内容。) 你也不能使用内置函数大量使用的特殊[伪类型修饰符](http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed)：`mixed`、`number`或`callback`。
    (PHP 5.4允许使用`callable`。)
- en: 'As a result, this:'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此， 这个：
- en: '|  |'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE1]'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: 'produces the error:'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 产生错误：
- en: '|  |'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE2]'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: You may notice that the “type hint” given doesn’t actually have to exist; there
    is no `string` class in this program. If you try to use `ReflectionParameter::getClass()`
    to examine the type hint dynamically, *then* it will balk that the class doesn’t
    exist, making it impossible to actually retrieve the class name.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意到，给出的“类型提示”实际上并不一定存在；在这个程序中没有`string`类。如果尝试使用`ReflectionParameter::getClass()`动态检查类型提示，*那么*它会抱怨类不存在，从而无法实际检索类名。
- en: A function’s return value can’t be hinted.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回值不能被提示。
- en: Passing the current function’s arguments to another function (dispatch, not
    uncommon) is done by `call_user_func_array('other_function', func_get_args())`.
    But `func_get_args` throws a fatal error at runtime, complaining that it can’t
    be a function parameter. How and why is this even a *type* of error? (Fixed in
    PHP 5.3.)
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前函数的参数传递给另一个函数（调度，不罕见）是通过`call_user_func_array('other_function', func_get_args())`完成的。但是`func_get_args`在运行时抛出致命错误，抱怨它不能是函数参数。这是如何以及为什么甚至是一种*错误*类型的？（在PHP 5.3中修复。）
- en: Closures require explicitly naming every variable to be closed-over. Why can’t
    the interpreter figure this out? Kind of hamstrings the whole feature. (Okay,
    it’s because using a variable ever, at all, creates it unless explicitly told otherwise.)
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包需要显式命名要封闭的每个变量。为什么解释器不能弄清楚这一点？这在某种程度上束缚了整个功能。 (好吧，因为只要使用一个变量，它就会被创建，除非明确告诉它不这样做。)
- en: Closed-over variables are “passed” by the same semantics as other function arguments.
    That is, arrays and strings etc. will be “passed” to the closure by value. Unless
    you use `&`.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭合的变量与其他函数参数具有相同的语义传递方式。也就是说，数组和字符串等等将按值传递给闭包。除非你使用 `&`。
- en: Because closed-over variables are effectively automatically-passed arguments
    and there are no nested scopes, a closure can’t refer to private methods, even
    if it’s defined inside a class. (Possibly fixed in 5.4? Unclear.)
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为闭合的变量实际上是自动传递的参数，并且没有嵌套作用域，一个闭包不能引用私有方法，即使它是在类内部定义的。（可能在 5.4 版本中修复了？不确定。）
- en: No named arguments to functions. Actually [explicitly rejected](http://www.php.net/~derick/meeting-notes.html#named-parameters)
    by the devs because it “makes for messier code”.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数没有命名参数。实际上，被开发者明确拒绝，因为它“使代码更乱”。
- en: Function arguments with defaults can appear before function arguments without,
    even though the documentation points out that this is both weird and useless.
    (So why allow it?)
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有默认值的函数参数可以出现在没有默认值的函数参数之前，尽管文档指出这既奇怪又无用。（那为什么允许呢？）
- en: Extra arguments to a function are ignored (except with builtin functions, which
    raise an error). Missing arguments are assumed null.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的额外参数将被忽略（除了内置函数，它们会引发错误）。缺少的参数被假定为空。
- en: “Variadic” functions require faffing about with `func_num_args`, `func_get_arg`,
    and `func_get_args`. There’s no syntax for such a thing.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “变长参数”函数需要使用 `func_num_args`、`func_get_arg` 和 `func_get_args` 进行操作。没有这种语法的东西。
- en: The procedural parts of PHP are designed like C, but the objectional (ho ho)
    parts are designed like Java. I cannot overemphasize how jarring this is. The
    class system is designed around the *lower-level* Java language which is naturally
    and deliberately *more limited* than PHP’s contemporaries, and I am baffled.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 的过程部分设计得像 C 语言，但是对象部分设计得像 Java。我无法过分强调这有多令人不适。类系统是围绕 *更低级别* 的 Java 语言设计的，这种语言自然而然地和故意地*比
    PHP 的同时代产品*更受限制，我感到困惑。
- en: I’ve yet to find a global function that even has a capital letter in its name,
    yet [important built-in classes](http://www.php.net/manual/en/class.reflectionfunction.php)
    use camelCase method names and have `getFoo` Java-style accessors.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我还没有找到一个全局函数的名称中甚至有一个大写字母，然而[重要的内置类](http://www.php.net/manual/en/class.reflectionfunction.php)使用驼峰命名法的方法名称，并且具有类似
    Java 的 `getFoo` 访问器。
- en: Perl, Python, and Ruby all have some concept of “property” access via code;
    PHP has only the clunky `__get` and friends. (The documentation inexplicably refers
    to such special methods as “overloading”.)
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perl、Python 和 Ruby 都有通过代码访问“属性”的概念；PHP 只有笨拙的 `__get` 和其它方法。（文档莫名其妙地将这样的特殊方法称为“重载”。）
- en: Classes have something like variable declaration (`var` and `const`) for class
    attributes, whereas the procedural part of the language does not.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类具有类似变量声明的东西（`var` 和 `const`）用于类属性，而语言的过程部分则没有。
- en: Despite the heavy influence from C++/Java, where objects are fairly opaque,
    PHP often treats objects like fancy hashes—for example, the default behavior of
    `foreach ($obj as $key => $value)` is to iterate over every accessible attribute
    of the object.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管受到 C++/Java 的重大影响，其中对象相当不透明，但 PHP 通常将对象视为高级散列——例如，`foreach ($obj as $key =>
    $value)` 的默认行为是遍历对象的每个可访问属性。
- en: Classes are not objects. Any metaprogramming has to refer to them by string
    name, just like functions.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类不是对象。任何元编程都必须通过字符串名称引用它们，就像引用函数一样。
- en: Built-in types are not objects and (unlike Perl) can in no way be made to look
    like objects.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置类型不是对象，并且（不像 Perl）无论如何都不能看起来像对象。
- en: '`instanceof` is an operator, despite that classes were a late addition and
    most of the language is built on functions and function-ish syntax. Java influence?
    Classes not first-class? (I don’t know if they are.)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instanceof` 是一个运算符，尽管类是后来才加入的，并且大部分语言是基于函数和类似函数的语法构建的。受到 Java 的影响？类不是第一类对象吗？（我不知道它们是否是。）'
- en: But there *is* an `is_a` function. With an optional argument specifying whether
    to allow the object to actually be a string naming a class.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是确实有一个 `is_a` 函数。它有一个可选参数，指定是否允许对象实际上是一个命名类的字符串。
- en: '`get_class` is a function; there’s no `typeof` operator. Likewise `is_subclass_of`.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_class` 是一个函数；没有 `typeof` 操作符。同样适用于 `is_subclass_of`。'
- en: This doesn’t work on builtin types, though (again, `int` is not a thing). For
    that, you need `is_int` etc.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是这在内置类型上不起作用（再次强调，`int` 不是东西）。为此，你需要 `is_int` 等函数。
- en: Also the right-hand side has to be a variable or literal string; it can’t be
    an expression. That causes… a parse error.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，右侧必须是一个变量或文字字符串；它不能是一个表达式。这会导致...一个解析错误。
- en: '`clone` is an operator?!'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone`是一个运算符？！'
- en: Object attributes are `$obj->foo`, but class attributes are `Class::$foo`. (`$obj::$foo`
    will try to stringify `$obj` and use it as a class name.) Class attributes can’t
    be accessed via objects; the namespaces are completely separate, making class
    attributes completely useless for polymorphism. Class *methods*, of course, are
    exempt from this rule and can be called like any other method. (I am told C++
    also does this. C++ is not a good example of fine OO.)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象属性是`$obj->foo`，但类属性是`Class::$foo`。（`$obj::$foo`会尝试将`$obj`转换为字符串并将其用作类名。）类属性无法通过对象访问；命名空间完全独立，使得类属性对多态性完全无用。当然，类*方法*不受此规则限制，可以像任何其他方法一样调用。（我被告知C++也这样做。C++不是一个良好的面向对象编程的典范。）
- en: Also, an instance method can still be called statically (`Class::method()`).
    If done so from another method, this is treated like a regular method call on
    the current `$this`. I think.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，实例方法仍然可以静态调用（`Class::method()`）。如果从另一个方法中这样做，这会被视为在当前`$this`上调用常规方法。我想。
- en: '`new`, `private`, `public`, `protected`, `static`, etc. Trying to win over
    Java developers? I’m aware this is more personal taste, but I don’t know why this
    stuff is necessary in a dynamic language—in C++ most of it’s about compilation
    and compile-time name resolution.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`、`private`、`public`、`protected`、`static`等。试图吸引Java开发人员？我知道这更多是个人口味，但我不知道为什么在动态语言中需要这些东西——在C++中，大部分都是关于编译和编译时名称解析的。'
- en: PHP has first-class support for “abstract classes”, which are classes that cannot
    be instantiated. Code in similar languages achieves this by throwing an exception
    in the constructor.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP对“抽象类”有一流的支持，这些类不能被实例化。类似语言中的代码通过在构造函数中抛出异常来实现这一点。
- en: Subclasses cannot override private methods. Subclass overrides of public methods
    can’t even *see*, let alone call, the superclass’s private methods. Problematic
    for, say, test mocks.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类无法覆盖私有方法。子类对公有方法的覆盖甚至*都看不到*，更别说调用超类的私有方法了。对于测试模拟（test mocks）来说是有问题的。
- en: Methods cannot be named e.g. “list”, because `list()` is special syntax (not
    a function) and the parser gets confused. There’s no reason this should be ambiguous,
    and monkeypatching the class works fine. (`$foo->list()` is not a syntax error.)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法不能命名为例如“list”，因为`list()`是特殊语法（不是一个函数），解析器会混淆。这没有理由会造成歧义，而且对类进行猴子补丁（monkeypatching）也可以正常工作。（`$foo->list()`不是一个语法错误。）
- en: If an exception is thrown while evaluating a constructor’s arguments (e.g.,
    `new Foo(bar())` and `bar()` throws), the constructor won’t be called, but the
    *destructor* will be. (This is fixed in PHP 5.3.)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在评估构造函数的参数时抛出异常（例如，`new Foo(bar())`和`bar()`抛出异常），则构造函数不会被调用，但*析构函数*会被调用。（这在PHP
    5.3中得到了修复。）
- en: Exceptions in `__autoload` and destructors cause fatal errors. (Fixed in PHP
    5.3.6\. So now a destructor might throw an exception literally anywhere, since
    it’s called the moment the refcount drops the zero. Hmm.)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__autoload`和析构函数中的异常会导致致命错误。（在PHP 5.3.6中得到修复。所以现在析构函数可能随时抛出异常，因为在引用计数降为零时立即调用。嗯。）'
- en: There are no constructors or destructors. `__construct` is an initializer, like
    Python’s `__init__`. There is no method you can call on a class to allocate memory
    and create an object.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有构造函数或析构函数。`__construct`是一个初始化器，就像Python的`__init__`一样。没有可以在类上调用以分配内存并创建对象的方法。
- en: There is no default initializer. Calling `parent::__construct()` if the superclass
    doesn’t define its own `__construct` is a fatal error.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有默认的初始化器。如果超类没有定义自己的`__construct`，则调用`parent::__construct()`将会导致致命错误。
- en: OO brings with it an iterator interface that parts of the language (e.g., `for...as`)
    respect, but nothing built-in (like arrays) actually implements the interface.
    If you want an array iterator, you have to wrap it in an `ArrayIterator`. There
    are no built-in ways to chain or slice or otherwise work with iterators as first-class objects.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象带来了一个迭代器接口，语言的部分部分（例如`for...as`）尊重该接口，但没有内置的东西（例如数组）实际上实现了该接口。如果你想要一个数组迭代器，你必须将其包装在一个`ArrayIterator`中。没有内置的方法来链接或切片或以其他方式处理迭代器作为一级对象。
- en: Interfaces like `Iterator` reserve a good few unprefixed method names. If you
    want your class to be iterable (without the default behavior of iterating all
    of its attributes), but want to use a common method name like `key` or `next`
    or `current`, well, too bad.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像`Iterator`这样的接口保留了一些未带前缀的方法名。如果你希望你的类可迭代（而不是默认行为迭代所有属性），但想使用像`key`、`next`或`current`这样的常见方法名，那么，很遗憾。
- en: Classes can overload how they convert to strings and how they act when called,
    but not how they convert to numbers or any other builtin type.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以重载如何转换为字符串和在被调用时的行为，但不能重载如何转换为数字或任何其他内置类型。
- en: Strings, numbers, and arrays all have a string conversion; the language relies
    heavily on this. Functions and classes *are* strings. Yet trying to convert a
    built-in or user-defined object (even a Closure) to a string causes an error if
    it doesn’t define `__toString`. Even `echo` becomes potentially error-prone.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '字符串、数字和数组都有字符串转换；语言严重依赖于此。函数和类*都是*字符串。然而，尝试将内置或用户定义的对象（甚至是闭包）转换为字符串，如果它没有定义`__toString`，则会导致错误。即使`echo`也可能出现错误。 '
- en: There is no overloading for equality or ordering.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有关于相等性或排序的重载。
- en: Static variables inside instance methods are global; they share the same value
    across all instances of the class.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法中的静态变量是全局的；它们在类的所有实例之间共享相同的值。
- en: Perl is “some assembly required”. Python is “batteries included”. PHP is “kitchen
    sink, but it’s from Canada and [both faucets are labeled C](http://www.mcguirehimself.com/?p=117)“.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Perl是“需要一些装配”。Python是“电池包含”。PHP是“综合大杂烩，但它来自加拿大，[两个水龙头都标记为C](http://www.mcguirehimself.com/?p=117)“。
- en: There is no module system. You can compile PHP extensions, but which ones are
    loaded is specified by php.ini, and your options are for an extension to exist
    (and inject its contents into your global namespace) or not.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有模块系统。你可以编译PHP扩展，但加载哪些扩展是由php.ini指定的，你的选项是扩展是否存在（并将其内容注入到全局命名空间中）。
- en: As namespaces are a recent feature, the standard library isn’t broken up at
    all. There are thousands of functions in the global namespace.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于命名空间是最近的功能，标准库根本没有被分割。全局命名空间中有数千个函数。
- en: Chunks of the library are wildly inconsistent from one another.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库的部分内容在一致性方面大相径庭。
- en: 'Underscore versus not: `strpos`/`str_rot13`, `php_uname`/`phpversion`, `base64_encode`/`urlencode`,
    `gettype`/`get_class`'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线与否：`strpos`/`str_rot13`，`php_uname`/`phpversion`，`base64_encode`/`urlencode`，`gettype`/`get_class`
- en: '“to” versus 2: `ascii2ebcdic`, `bin2hex`, `deg2rad`, `strtolower`, `strtotime`'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “to”与2：`ascii2ebcdic`，`bin2hex`，`deg2rad`，`strtolower`，`strtotime`
- en: 'Object+verb versus verb+object: `base64_decode`, `str_shuffle`, `var_dump`
    versus `create_function`, `recode_string`'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象+动词与动词+对象：`base64_decode`，`str_shuffle`，`var_dump`与`create_function`，`recode_string`
- en: 'Argument order: `array_filter($input, $callback)` versus `array_map($callback,
    $input)`, `strpos($haystack, $needle)` versus `array_search($needle, $haystack)`'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数顺序：`array_filter($input, $callback)`与`array_map($callback, $input)`，`strpos($haystack,
    $needle)`与`array_search($needle, $haystack)`
- en: 'Prefix confusion: `usleep` versus `microtime`'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀混淆：`usleep`与`microtime`
- en: Case insensitive functions vary on where the `i` goes in the name.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小写不敏感的函数在名称中的`i`放置位置不同。
- en: About half the array functions actually start with `array_`. The others do not.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约一半的数组函数实际上以`array_`开头。其他则不。
- en: '`htmlentities` and `html_entity_decode` are *inverses* of each other, with
    completely different naming conventions.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`htmlentities`和`html_entity_decode`是彼此的*逆*，具有完全不同的命名约定。'
- en: 'Kitchen sink. The library includes:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 综合大杂烩。该库包括：
- en: Bindings to ImageMagick, bindings to GraphicsMagick (which is a fork of ImageMagick),
    and a handful of functions for inspecting EXIF data (which ImageMagick can already do).
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到ImageMagick，绑定到GraphicsMagick（这是ImageMagick的分支），以及一些用于检查EXIF数据的函数（ImageMagick已经可以做到）。
- en: Functions for parsing bbcode, a very specific kind of markup used by a handful
    of particular forum packages.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于解析bbcode的函数，这是一种由少数特定论坛软件包使用的非常特定的标记语言。
- en: Way too many XML packages. `DOM` (OO), `DOM XML` (not), `libxml`, `SimpleXML`,
    “XML Parser”, `XMLReader`/`XMLWriter`, and half a dozen more acronyms I can’t
    identify. There’s surely some kind of difference between these things and you
    are free to go figure out what that is.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太多的XML包。`DOM`（面向对象），`DOM XML`（不是），`libxml`，`SimpleXML`，“XML Parser”，`XMLReader`/`XMLWriter`，还有一些我无法识别的缩写。这些东西肯定有某种区别，你可以自由去找出这是什么。
- en: Bindings for two particular credit card processors, SPPLUS and MCVE. What?
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到两个特定信用卡处理器，SPPLUS和MCVE。什么？
- en: 'Three ways to access a MySQL database: `mysql`, `mysqli`, and the `PDO` abstraction thing.'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 MySQL 数据库的三种方式：`mysql`，`mysqli` 和 `PDO` 抽象物。
- en: 'This deserves its own bullet point, because it’s so absurd yet permeates the
    language. PHP is a high-level, dynamically-typed programming language. Yet a massive
    portion of the standard library is still very thin wrappers around C APIs, with
    the following results:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这值得单独列出来，因为它是如此荒谬却又弥漫于语言之中。PHP 是一种高级、动态类型的编程语言。然而，标准库的一大部分仍然只是对 C API 的非常薄的包装，产生了以下结果：
- en: “Out” parameters, even though PHP can return ad-hoc hashes or multiple arguments
    with little effort.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Out” 参数，即使 PHP 可以在很少的努力下返回临时哈希或多个参数。
- en: At least a dozen functions for getting the last error from a particular subsystem
    (see below), even though PHP has had exceptions for eight years.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少有十几种从特定子系统获取最后错误的函数（见下文），尽管 PHP 已经有了异常八年了。
- en: Warts like `mysql_real_escape_string`, even though it has the same arguments
    as the broken `mysql_escape_string`, just because it’s part of the MySQL C API.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像 `mysql_real_escape_string` 这样的瑕疵，尽管它与已损坏的 `mysql_escape_string` 具有相同的参数，只是因为它是
    MySQL C API 的一部分。
- en: Global behavior for non-global functionality (like MySQL). Using multiple MySQL
    connections apparently requires passing a connection handle on every function call.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对非全局功能的全局行为（比如 MySQL）。显然，使用多个 MySQL 连接需要在每个函数调用中传递一个连接句柄。
- en: The wrappers are really, really, really thin. For example, calling `dba_nextkey`
    without calling `dba_firstkey` will segfault.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些包装器真的非常、非常、非常薄。例如，调用 `dba_nextkey` 而不调用 `dba_firstkey` 将导致段错误。
- en: 'The wrappers are often platform-specific: `fopen(directory, "r")` works on
    Linux but returns false and generates a warning on Windows.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些包装器通常是平台特定的：在 Linux 上，`fopen(directory, "r")` 起作用，但在 Windows 上返回 false 并生成警告。
- en: There’s a set of `ctype_*` functions (e.g. `ctype_alnum`) that map to the C
    character-class detection functions of similar names, rather than, say, `isupper`.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一组 `ctype_*` 函数（比如 `ctype_alnum`），它们映射到类似名称的 C 字符类检测函数，而不是，比如说，`isupper`。
- en: There is none. If a function might need to do two slightly different things,
    PHP just has two functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 没有。如果一个函数可能需要做两件稍微不同的事情，PHP 就有两个函数。
- en: How do you sort backwards? In Perl, you might do `sort { $b <=> $a }`. In Python,
    you might do `.sort(reverse=True)`. In PHP, there’s a separate function called
    `rsort()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如何进行反向排序？在 Perl 中，您可能会执行 `sort { $b <=> $a }`。在 Python 中，您可能会执行 `.sort(reverse=True)`。在
    PHP 中，有一个名为 `rsort()` 的单独函数。
- en: 'Functions that look up a C error: `curl_error`, `json_last_error`, `openssl_error_string`,
    `imap_errors`, `mysql_error`, `xml_get_error_code`, `bzerror`, `date_get_last_errors`, others?'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '查找 C 错误的函数：`curl_error`，`json_last_error`，`openssl_error_string`，`imap_errors`，`mysql_error`，`xml_get_error_code`，`bzerror`，`date_get_last_errors`，其他吗？ '
- en: 'Functions that sort: `array_multisort`, `arsort`, `asort`, `ksort`, `krsort`,
    `natsort`, `natcasesort`, `sort`, `rsort`, `uasort`, `uksort`, `usort`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序函数：`array_multisort`，`arsort`，`asort`，`ksort`，`krsort`，`natsort`，`natcasesort`，`sort`，`rsort`，`uasort`，`uksort`，`usort`
- en: 'Functions that find text: `ereg`, `eregi`, `mb_ereg`, `mb_eregi`, `preg_match`,
    `strstr`, `strchr`, `stristr`, `strrchr`, `strpos`, `stripos`, `strrpos`, `strripos`,
    `mb_strpos`, `mb_strrpos`, plus the variations that do replacements'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文本的函数：`ereg`，`eregi`，`mb_ereg`，`mb_eregi`，`preg_match`，`strstr`，`strchr`，`stristr`，`strrchr`，`strpos`，`stripos`，`strrpos`，`strripos`，`mb_strpos`，`mb_strrpos`，以及执行替换的变体
- en: 'There are a lot of aliases as well, which certainly doesn’t help matters: `strstr`/`strchr`,
    `is_int`/`is_integer`/`is_long`, `is_float`/`is_double`, `pos`/`current`, `sizeof`/`count`,
    `chop`/`rtrim`, `implode`/`join`, `die`/`exit`, `trigger_error`/`user_error`,
    `diskfreespace`/`disk_free_space`…'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有很多别名，这显然不会帮助解决问题：`strstr`/`strchr`，`is_int`/`is_integer`/`is_long`，`is_float`/`is_double`，`pos`/`current`，`sizeof`/`count`，`chop`/`rtrim`，`implode`/`join`，`die`/`exit`，`trigger_error`/`user_error`，`diskfreespace`/`disk_free_space`…
- en: '`scandir` returns a list of files within a given directory. Rather than (potentially
    usefully) return them in directory order, the function returns the files already
    sorted. And there’s an optional argument to get them in *reverse* alphabetical
    order. There were not, apparently, enough sort functions. (PHP 5.4 adds a third
    value for the sort-direction argument that will disable sorting.)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scandir` 返回给定目录中的文件列表。而不是（可能有用地）按目录顺序返回它们，该函数返回已经排序好的文件。并且有一个可选参数以获取它们以 *反向*
    字母顺序排列。显然，没有足够的排序函数。 （PHP 5.4 添加了一个用于排序方向参数的第三个值，它将禁用排序。）'
- en: '`str_split` breaks a string into chunks of equal length. `chunk_split` breaks
    a string into chunks of equal length, then joins them together with a delimiter.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str_split` 将字符串分割成相等长度的块。`chunk_split` 将字符串分割成相等长度的块，然后用分隔符将它们连接起来。'
- en: Reading archives requires a separate set of functions depending on the format.
    There are six separate groups of such functions, all with different APIs, for
    bzip2, LZF, phar, rar, zip, and gzip/zlib.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读归档需要一组独立的函数，具体取决于格式。有六组不同的此类函数，具有不同的 API，用于 bzip2、LZF、phar、rar、zip 和 gzip/zlib。
- en: Because calling a function with an array as its arguments is so awkward (`call_user_func_array`),
    there are some pairings like `printf`/`vprintf` and `sprintf`/`vsprintf`. These
    do the same things, but one function takes arguments and the other takes an array
    of arguments.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为使用数组作为参数调用函数非常麻烦（`call_user_func_array`），所以有一些配对函数如 `printf`/`vprintf` 和 `sprintf`/`vsprintf`。它们做同样的事情，但一个函数接受参数，另一个接受参数数组。
- en: '`preg_replace` with the `/e` (eval) flag will do a string replace of the matches
    into the replacement string, *then eval it*.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `/e`（eval）标志的 `preg_replace` 将匹配的字符串替换为替换字符串，*然后对其进行评估*。
- en: '`strtok` is apparently designed after the equivalent C function, which is already
    a bad idea for various reasons. Nevermind that PHP can easily return an array
    (whereas this is awkward in C), or that the very hack `strtok(3)` uses (modifying
    the string in-place) isn’t used here.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strtok` 显然是根据等效的 C 函数设计的，这本身就是一个坏主意，因为各种各样的原因。别管 PHP 能轻松返回一个数组（而在 C 中这很尴尬），或者
    `strtok(3)` 使用的非常巧妙的 hack（在原地修改字符串）在这里不起作用。'
- en: '`parse_str` parses a *query* string, with no indication of this in the name.
    Also it acts just like `register_globals` and dumps the query into your local
    scope as variables, unless you pass it an array to populate. (It returns nothing,
    of course.)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parse_str` 解析一个*查询*字符串，但其名称并没有体现这一点。此外，它的行为就像 `register_globals` 一样，将查询转储到您的本地作用域中作为变量，除非您传递一个数组来填充它。（当然，它不返回任何东西。）'
- en: '`explode` refuses to split with an empty/missing delimiter. Every other string
    split implementation anywhere does some useful default in this case; PHP instead
    has a totally separate function, confusingly called `str_split` and described
    as “converting a string to an array”.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`explode` 拒绝使用空/缺少的分隔符进行拆分。任何其他地方的字符串拆分实现都会在这种情况下进行一些有用的默认操作；相反，PHP 有一个完全独立的函数，令人困惑地称为
    `str_split`，并描述为“将字符串转换为数组”。'
- en: For formatting dates, there’s `strftime`, which acts like the C API and respects
    locale. There’s also `date`, which has a completely different syntax and only
    works with English.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了格式化日期，有 `strftime`，它的行为类似于 C API 并且支持地区设置。还有 `date`，它有完全不同的语法，只能用于英文。
- en: “[`gzgetss`](http://php.net/manual/en/function.gzgetss.php) — Get line from
    gz-file pointer and strip HTML tags.” I’m dying to know the series of circumstances
    that led to this function’s conception.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “[`gzgetss`](http://php.net/manual/en/function.gzgetss.php) — 从 gz 文件指针获取行并删除
    HTML 标签。”我很想知道是什么一系列情况导致了这个函数的概念。
- en: '`mbstring`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mbstring`'
- en: It’s all about “multi-byte”, when the problem is character sets.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当问题是字符集时，一切都与“多字节”有关。
- en: Still operates on regular strings. Has a single global “default” character set.
    Some functions allow specifying charset, but then it applies to all arguments
    and the return value.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然操作常规字符串。有一个全局的“默认”字符集。一些函数允许指定字符集，但这样会应用于所有参数和返回值。
- en: Provides `ereg_*` functions, but those are deprecated. `preg_*` are out of luck,
    though they can understand UTF-8 by feeding them some PCRE-specific flag.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了 `ereg_*` 函数，但已经弃用了。`preg_*` 则不幸了，虽然它们可以通过输入一些 PCRE 特定的标志来理解 UTF-8。
- en: There are, in general, a whole lot of functions that blur the line between text
    and variables. `compact` and `extract` are just the tip of the iceberg.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般来说，有很多函数模糊了文本和变量之间的界限。`compact` 和 `extract` 只是冰山一角。
- en: There are several ways to actually be dynamic in PHP, and at a glance there
    are no obvious differences or relative benefits. `classkit` can modify user-defined
    classes; `runkit` supersedes it and can modify user-defined anything; the `Reflection*`
    classes can reflect on most parts of the language; there are a great many individual
    functions for reporting properties of functions and classes. Are these subsystems
    independent, related, redundant?
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 PHP 中实际上有几种实现动态性的方式，乍一看并没有明显的差异或相关的好处。`classkit` 可以修改用户定义的类；`runkit` 取代了它，可以修改用户定义的任何东西；`Reflection*`
    类可以反映语言的大部分部分；还有许多用于报告函数和类属性的个别函数。这些子系统是独立的、相关的还是多余的？
- en: '`get_class($obj)` returns the object’s class name. `get_class()` returns the
    name of the class the function is being called in. Setting aside that this one
    function does two radically different things: `get_class(null)`… acts like the
    latter. So you can’t trust it on an arbitrary value. Surprise!'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_class($obj)` 返回对象的类名。`get_class()` 返回调用该函数所在类的名称。撇开这个函数有两个完全不同的功能这一事实不谈：`get_class(null)`…的行为类似后者。因此，你不能在任意值上信任它。令人惊讶！'
- en: The `stream_*` classes allow for implementing custom stream objects for use
    with `fopen` and other fileish builtins. “tell” cannot be implemented for [internal
    reasons](https://bugs.php.net/bug.php?id=30157). (Also there are [A LOT](http://www.php.net/manual/en/book.stream.php)
    of functions involved with this system.)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream_*` 类允许实现自定义流对象，以便与 `fopen` 和其他类似文件的内置函数一起使用。“tell” 无法实现由于[内部原因](https://bugs.php.net/bug.php?id=30157)。（此外，与此系统有关的函数[非常多](http://www.php.net/manual/en/book.stream.php)。）'
- en: '`register_tick_function` will accept a closure object. `unregister_tick_function`
    will not; instead it throws an error complaining that the closure couldn’t be
    converted to a string.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register_tick_function` 将接受闭包对象。`unregister_tick_function` 不会；相反，它会抛出一个错误，抱怨无法将闭包转换为字符串。'
- en: '`php_uname` tells you about the current OS. Unless PHP can’t tell what it’s
    running on; then it tells you about the OS it was *built* on. It doesn’t tell
    you if this has happened.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php_uname` 告诉你当前的操作系统。除非 PHP 无法确定它正在运行的系统；然后它告诉你关于它*构建*在哪个操作系统上的信息。它不会告诉你是否发生了这种情况。'
- en: '`fork` and `exec` are not built in. They come with the pcntl extension, but
    that isn’t included by default. `popen` doesn’t provide a pid.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fork` 和 `exec` 不是内置的。它们随着 pcntl 扩展一起提供，但默认情况下不包括在内。`popen` 不提供进程标识。'
- en: '`stat`‘s return value is cached.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stat` 的返回值被缓存。'
- en: '`session_decode` is for reading an arbitrary PHP session string, but it only
    works if there’s an active session already. And it dumps the result into `$_SESSION`,
    rather than returning it.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session_decode` 用于读取任意的 PHP 会话字符串，但只有在已经存在活动会话时才能工作。而且它将结果转储到 `$_SESSION`
    中，而不是返回它。'
- en: '`curl_multi_exec` doesn’t change `curl_errno` on error, but it does change
    `curl_error`.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl_multi_exec` 在错误时不会改变 `curl_errno`，但会改变 `curl_error`。'
- en: '`mktime`‘s arguments are, in order: hour, minute, second, month, day, year.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mktime` 的参数顺序是：小时、分钟、秒、月份、日期、年份。'
- en: Programs are nothing more than big machines that chew up data and spit out more
    data. A great many languages are designed *around* the kinds of data they manipulate,
    from awk to Prolog to C. If a language can’t handle data, it can’t do anything.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 程序只不过是一些大型机器，它们吞下数据然后吐出更多数据。许多语言都是围绕着它们处理的数据类型设计的，从 awk 到 Prolog 到 C。如果一种语言不能处理数据，它什么也做不了。
- en: Integers are signed and 32-bit on 32-bit platforms. Unlike all of PHP’s contemporaries,
    there is no automatic bigint promotion. So you can end up with surprises like
    negative file sizes, and your math might work differently based on *CPU architecture*.
    Your only option for larger integers is to use the GMP or BC wrapper functions.
    (The developers have proposed [adding a new, separate, 64-bit type](http://www.php.net/~derick/meeting-notes.html#add-a-64bit-integer).
    This is crazy.)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数在 32 位平台上是有符号的且为 32 位。与 PHP 的所有同时代语言不同，没有自动的大整数提升。因此，你可能会遇到意外的负文件大小，而且你的数学运算可能会因为*CPU
    架构*不同而有所不同。你唯一的选择是使用 GMP 或 BC 包装函数来处理更大的整数。（开发人员提出了[添加一个新的、单独的、64 位类型](http://www.php.net/~derick/meeting-notes.html#add-a-64bit-integer)。这太疯狂了。）
- en: PHP supports octal syntax with a leading `0`, so e.g. `012` will be the number
    ten. However, `08` becomes the number zero. The `8` (or `9`) and any following
    digits disappear. `01c` is a syntax error.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 支持以前导 `0` 开头的八进制语法，所以例如 `012` 将是十进制数十。然而，`08` 变成了零。数字 `8`（或 `9`）和之后的任何数字都会消失。`01c`
    是语法错误。
- en: '`0x0+2` produces 4\. The parser considers the `2` as both part of the hex literal
    *and* a separate decimal literal, treating this as `0x002 + 2`. `0x0+0x2` displays
    the same problem. Strangely, `0x0 +2` is still 4, but `0x0+ 2` is correctly 2\.
    (This is fixed in PHP 5.4\. But it’s also re-broken in PHP 5.4, with the new `0b`
    literal prefix: `0b0+1` produces 2.)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x0+2` 会得到 4。解析器将 `2` 视为十六进制文字的一部分，同时也是一个独立的十进制文字，将其视为 `0x002 + 2`。`0x0+0x2`
    显示相同的问题。奇怪的是，`0x0 +2` 仍然是 4，但 `0x0+ 2` 正确地是 2。（这在 PHP 5.4 中已修复。但在 PHP 5.4 中重新出现，使用新的
    `0b` 文字前缀：`0b0+1` 会产生 2。）'
- en: '`pi` is a function. Or there’s a constant, `M_PI`.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pi` 是一个函数。或者有一个常量 `M_PI`。'
- en: There is [no exponentiation operator](https://bugs.php.net/bug.php?id=13756),
    only the `pow` function.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '没有指数运算符，只有 `pow` 函数。 '
- en: No Unicode support. Only ASCII will work reliably, really. There’s the `mbstring`
    extension, mentioned above, but it kinda blows.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持 Unicode。只有 ASCII 才能可靠地使用，真的。上面提到了`mbstring`扩展，但有点糟糕。
- en: Which means that using the builtin string functions on UTF-8 text risks corrupting it.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着在 UTF-8 文本上使用内置字符串函数可能会导致损坏。
- en: Similarly, there’s no concept of e.g. case comparisons outside of ASCII. Despite
    the proliferation of case-insensitive versions of functions, not one of them will
    consider `é` equal to `É`.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样地，在 ASCII 之外没有大小写比较的概念。尽管函数的大小写不敏感版本泛滥成灾，但其中没有一个会认为`é`等于`É`。
- en: You can’t quote keys in variable interpolation, i.e., `"$foo['key']"` is a syntax
    error. You can unquote it (which *would* generate a warning anywhere else!), or
    use `${...}`/`{$...}`.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在变量内插时不能引用键，即`"$foo['key']"`是语法错误。你可以取消引号（在其他地方*可能*会生成警告！），或者使用`${...}`/`{$...}`。
- en: '`"${foo[0]}"` is okay. `"${foo[0][0]}"` is a syntax error. Putting the `$`
    on the inside is fine with both. Bad copy of similar Perl syntax (with radically
    different semantics)?'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"${foo[0]}"`是可以的。`"${foo[0][0]}"`是语法错误。将`$`放在内部对两者都可以。类似 Perl 语法的差劲拷贝（语义却截然不同）？'
- en: Oh, man.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，天哪。
- en: This one datatype acts as a list, ordered hash, ordered set, sparse list, and
    occasionally some strange combination of those. How does it perform? What kind
    of memory use will there be? Who knows? Not like I have other options, anyway.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种数据类型充当列表、有序哈希、有序集、稀疏列表，有时甚至是这些的奇怪组合。它的表现如何？将会有什么样的内存使用？谁知道？反正我也没有其他选择。
- en: '`=>` isn’t an operator. It’s a special construct that only exists inside `array(...)`
    and the `foreach` construct.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=>`不是一个操作符。它是一个特殊的结构，只存在于`array(...)`和`foreach`结构中。'
- en: Negative indexing doesn’t work, since `-1` is just as valid a key as `0`.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负索引不起作用，因为`-1`和`0`一样有效。
- en: Despite that this is the language’s only data structure, there is no shortcut
    syntax for it; `array(...)` *is* shortcut syntax. (PHP 5.4 is bringing “literals”,
    `[...]`.)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这是语言中唯一的数据结构，但没有它的快捷语法；`array(...)`*是*快捷语法。 （PHP 5.4 正在带来“字面量”，`[...]`。）
- en: Similarly baffling, arrays stringify to `Array` with an E_NOTICE.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样令人困惑的是，数组转化为`Array`并引发一个`E_NOTICE`。
- en: The `=>` construct is based on Perl, which allows `foo => 1` without quoting.
    (That is, in fact, why it exists in Perl; otherwise it’s just a comma.) In PHP,
    you can’t do this without getting a warning; it’s the only language in its niche
    that has no vetted way to create a hash without quoting string keys.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=>`结构是基于 Perl 的，它允许`foo => 1`而不引用。 （事实上，这就是它存在于 Perl 中的原因；否则它只是一个逗号。）在 PHP
    中，你不能这样做而不会得到警告；它是其领域中唯一没有经过审查的创建哈希的方法而不引用字符串键。'
- en: Array functions often have confusing or inconsistent behavior because they have
    to operate on lists, hashes, or maybe a combination of the two. Consider `array_diff`,
    which “computers the difference of arrays”.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组函数经常有令人困惑或不一致的行为，因为它们必须在列表、哈希或可能是两者的组合上操作。考虑`array_diff`，它“计算数组的差异”。
- en: '|  |'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE3]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: What will this code do? If `array_diff` treats its arguments as hashes, then
    obviously these are different; the same keys have different values. If it treats
    them as lists, then they’re still different; the values are in the wrong order.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码会做什么？如果`array_diff`将其参数视为哈希，则显然这些是不同的；相同的键有不同的值。如果它将它们视为列表，那么它们仍然不同；值的顺序是错的。
- en: 'In fact `array_diff` considers these equal, because it treats them like *sets*:
    it compares only values, and ignores order.'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上`array_diff`认为这些是相等的，因为它将它们视为*集合*：它只比较值，并忽略顺序。
- en: In a similar vein, `array_rand` has the strange behavior of selecting random
    *keys*, which is not that helpful for the most common case of needing to pick
    from a list of choices.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，`array_rand`有着奇怪的行为，它选择随机的*键*，这对于最常见的需要从一个列表中选择的情况并不是很有帮助。
- en: 'Despite how heavily PHP code relies on preserving key order:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管 PHP 代码严重依赖于保持键的顺序：
- en: '|  |'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE4]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: I leave it to the reader to figure out what happens if the arrays are mixed.
    (I don’t know.)
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我留给读者来想象如果数组被混合会发生什么。（我不知道。）
- en: '`array_fill` cannot create zero-length arrays; instead it will issue a warning
    and return false.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array_fill`不能创建零长度的数组；相反，它会发出警告并返回`false`。'
- en: All of the (many…) sort functions operate in-place and return nothing. There
    is no way to create a new sorted copy; you have to copy the array yourself, then
    sort it, then use the array.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的（很多...）排序函数都是原地操作，不返回任何东西。没有办法创建一个新的排序副本；你必须自己复制数组，然后排序它，然后使用数组。
- en: But `array_reverse` returns a new array.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但`array_reverse`返回一个新数组。
- en: A list of ordered things and some mapping of keys to values sounds kind of like
    a great way to handle function arguments, but no.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列有序的事物和一些键到值的映射听起来有点像处理函数参数的好方法，但*不是*。
- en: The standard library includes “Quickhash”, an OO implementation of “specific
    strongly-typed classes” for implementing hashes. And, indeed, there are four classes,
    each dealing with a different combination of key and value types. It’s unclear
    why the builtin array implementation can’t optimize for these extremely common
    cases, or what the relative performance is.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库包含“Quickhash”，这是一个“特定强类型类”的OO哈希实现。确实，有四个类，每个类处理不同的键和值类型的组合。不清楚为什么内置数组实现不能针对这些极其常见的情况进行优化，或者相对性能如何。
- en: There’s an `ArrayObject` class (which implements *five* different interfaces)
    that can wrap an array and have it act like an object. User classes can implement
    the same interfaces. But it only has a handful of methods, half of which don’t
    resemble built-in array functions, and built-in array functions don’t know how
    to operate on an `ArrayObject` or other array-like class.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个`ArrayObject`类（实现了*五*个不同的接口），可以将数组封装起来，并使其像对象一样操作。用户类可以实现相同的接口。但它只有少数几个方法，其中一半与内置数组函数不太相似，而内置数组函数不知道如何在`ArrayObject`或其他类似数组的类上操作。
- en: Functions are not data. Closures are actually objects, but regular functions
    are not. You can’t even refer to them with their bare names; `var_dump(strstr)`
    issues a warning and assumes you mean the literal string, `"strstr"`. There is
    no way to discern between an arbitrary string and a function “reference”.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数不是数据。闭包实际上是对象，但常规函数不是。你甚至不能仅通过它们的裸名字引用它们；`var_dump(strstr)`会发出警告，并假设你的意思是字面字符串`"strstr"`。没有办法区分任意字符串和函数“引用”之间的差异。
- en: '`create_function` is basically a wrapper around `eval`. It creates a function
    with a regular name and installs it globally (so it will never be garbage collected—don’t
    use in a loop!). It doesn’t actually know anything about the current scope, so
    it’s not a closure. The name contains a NUL byte so it can never conflict with
    a regular function (because PHP’s parser fails if there’s a `NUL` in a file anywhere).'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_function`基本上是`eval`的一个包装器。它创建一个带有常规名称的函数并全局安装它（所以它永远不会被垃圾回收——不要在循环中使用！）。它实际上不知道当前作用域的任何信息，所以它不是闭包。名称包含一个NUL字节，因此它永远不会与常规函数冲突（因为如果文件中有`NUL`，PHP的解析器会失败）。'
- en: Declaring a function named `__lambda_func` will break `create_function`—the
    *actual* implementation is to `eval`-create the function named `__lambda_func`,
    then internally rename it to the broken name. If `__lambda_func` already exists,
    the first part will throw a fatal error.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个名为`__lambda_func`的函数将会破坏`create_function`——*实际*的实现是通过`eval`创建名为`__lambda_func`的函数，然后在内部将其重命名为破损的名称。如果`__lambda_func`已经存在，则第一部分会抛出致命错误。
- en: Incrementing (`++`) a `NULL` produces `1`. Decrementing (`--`) a `NULL` produces
    `NULL`. Decrementing a string likewise leaves it unchanged.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`NULL`进行增量运算（`++`）会产生`1`。对`NULL`进行减量运算（`--`）会产生`NULL`。同样，对字符串进行减量运算会使其保持不变。
- en: There are no generators. (Fixed in 5.5\. Wow. They basically cloned the entire
    Python generator API, too. Impressive. Somehow, though, `$foo = yield $bar;` is
    a syntax error; it has to be `$foo = (yield $bar)`. Sigh.)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有生成器。（在5.5中修复。哇。他们基本上克隆了整个Python生成器API。令人印象深刻。然而，`$foo = yield $bar;`却是一个语法错误；它必须是`$foo
    = (yield $bar)`。叹气。）
- en: A single shared file, `php.ini`, controls *massive* parts of PHP’s functionality
    and introduces complex rules regarding what overrides what and when. PHP software
    that expects to be deployed on arbitrary machines has to override settings anyway
    to normalize its environment, which largely defeats the use of a mechanism like
    `php.ini` anyway.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个共享文件`php.ini`控制着PHP功能的*大*部分，并引入了复杂的规则，关于什么时候覆盖什么以及何时覆盖。期望部署在任意机器上的PHP软件仍然必须覆盖设置以规范化其环境，这在很大程度上抵消了类似`php.ini`这样的机制的使用。
- en: PHP looks for `php.ini` in a variety of places, so it may (or may not…) be possible
    to override your host’s. Only *one* such file will ever be parsed, though, so
    you can’t just override a couple settings and call it a day.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP在各种地方寻找`php.ini`，所以可能（或者可能不会……）有可能覆盖你主机的设置。然而，只会解析一个这样的文件，所以你不能仅仅覆盖几个设置然后就完事了。
- en: PHP basically runs as CGI. Every time a page is hit, PHP recompiles the whole
    thing before executing it. Even dev servers for Python toy frameworks don’t act
    like this.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP基本上作为CGI运行。每次访问页面时，PHP都会在执行之前重新编译整个内容。即使是Python玩具框架的开发服务器也不会这样。
- en: This has led to a whole market of “PHP accelerators” that just compile once,
    accelerating PHP all the way to any other language. Zend, the company behind PHP,
    has made this part of their [business model](http://www.zend.com/products/server/).
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这导致了一个“PHP 加速器”的整个市场，只需编译一次，就可以将 PHP 加速到任何其他语言的速度。PHP 背后的公司 Zend 已经将这一点纳入了他们的[商业模式](http://www.zend.com/products/server/)。
- en: For quite a long time, PHP errors went to the client by default—I guess to help
    during development. I don’t think this is true any more, but I still see the occasional
    mysql error spew at the top of a page.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很长一段时间以来，PHP 错误默认发送到客户端——我想这是为了在开发过程中提供帮助。我认为现在不再是这样了，但我仍然偶尔会在页面顶部看到一些 mysql
    错误。
- en: PHP is full of strange “easter eggs” like [producing the PHP logo with the right
    query argument](http://phpsadness.com/sad/11). Not only is this completely irrelevant
    to building *your* application, but it allows detecting whether you’re using PHP
    (and perhaps roughly guessing what version), regardless of how much `mod_rewrite`,
    FastCGI, reverse proxying, or `Server:` configuration you’re doing.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 充满了奇怪的“彩蛋”，比如[使用正确的查询参数生成 PHP 标志](http://phpsadness.com/sad/11)。这不仅与构建 *你的*
    应用程序完全无关，而且允许检测你是否正在使用 PHP（也许还能大致猜测版本），无论你正在进行多少 `mod_rewrite`、FastCGI、反向代理或 `Server:`
    配置。
- en: Blank lines before or after the `<?php ... ?>` tags, even in libraries, count
    as literal text and is interpolated into the response (or causes “headers already
    sent” errors). Your options are to either strictly avoid extra blank lines at
    the end of every file (the one after the `?>` doesn’t count) or to just leave
    off the `?>` closing token.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `<?php ... ?>` 标签之前或之后的空行，即使在库中，也被视为文字，并插入到响应中（或导致“头已发送”错误）。你的选择要么严格避免每个文件末尾的额外空行（`?>`
    后的那个不算），要么干脆不写 `?>` 结束标记。
- en: 'Deployment is often cited as the biggest advantage of PHP: drop some files
    and you’re done. Indeed, that’s much easier than running a whole process as you
    may have to do with Python or Ruby or Perl. But PHP leaves plenty to be desired.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 部署经常被认为是 PHP 的最大优势：放置一些文件就可以了。确实，这比你可能不得不在 Python 或 Ruby 或 Perl 中运行一个完整的进程要容易得多。但
    PHP 留下了许多不足之处。
- en: 'Across the board, I’m in favor of running Web applications as app servers and
    reverse-proxying to them. It takes minimal effort to set this up, and the benefits
    are plenty: you can manage your web server and app separately, you can run as
    many or few app processes on as many machines as you want without needing more
    web servers, you can run the app as a different user with zero effort, you can
    switch web servers, you can take down the app without touching the web server,
    you can do seamless deployment by just switching where a fifo points, etc. Welding
    your application to your web server is absurd and there’s no good reason to do
    it any more.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在各个方面，我支持将 Web 应用程序作为应用程序服务器运行，并对其进行反向代理。设置这一点所需的工作量很小，而好处很多：你可以分别管理你的 Web 服务器和应用程序，你可以在任意数量的机器上运行任意多或少的应用程序进程而无需更多的
    Web 服务器，你可以零成本地将应用程序作为不同的用户运行，你可以更换 Web 服务器，你可以在不触及 Web 服务器的情况下关闭应用程序，你可以通过只改变一个
    FIFO 指向的位置来实现无缝部署等等。把你的应用程序与你的 Web 服务器绑定在一起是荒谬的，而且没有任何好的理由再这样做了。
- en: PHP is naturally tied to Apache. Running it separately, or with any other webserver,
    requires just as much mucking around (possibly more) as deploying any other language.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 自然与 Apache 绑定在一起。单独运行它，或与任何其他 Web 服务器一起运行，需要和部署任何其他语言一样多的折腾（可能更多）。
- en: '`php.ini` applies to every PHP application run anywhere. There is only one
    `php.ini` file, and it applies globally; if you’re on a shared server and need
    to change it, or if you run two applications that need different settings, you’re
    out of luck; you have to apply the union of all necessary settings and pare them
    down from inside the apps themselves using `ini_set` or in Apache’s configuration
    file or in `.htaccess`. If you can. Also wow that is a lot of places you need
    to check to figure out how a setting is getting its value.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php.ini` 适用于任何地方运行的每个 PHP 应用程序。只有一个 `php.ini` 文件，并且它是全局的；如果你在一个共享服务器上需要更改它，或者如果你运行两个需要不同设置的应用程序，你就没戏了；你必须应用所有必要设置的并集，并通过在应用程序内部使用
    `ini_set` 或在 Apache 的配置文件或 `.htaccess` 中逐步剔除它们。如果你可以的话。还有哇，你需要检查那么多地方才能弄清楚一个设置是如何得到它的值的。'
- en: Similarly, there is no easy way to “insulate” a PHP application and its dependencies
    from the rest of a system. Running two applications that require different versions
    of a library, or even PHP itself? Start by building a second copy of Apache.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样地，没有简单的方法来“隔离”一个 PHP 应用程序及其依赖项与系统的其他部分。运行需要不同版本库或甚至 PHP 本身的两个应用程序？首先构建第二个
    Apache 的副本。
- en: The “bunch of files” approach, besides making routing a huge pain in the ass,
    also means you have to carefully whitelist or blacklist what stuff is actually
    available, because your URL hierarchy is also your entire code tree. Configuration
    files and other “partials” need C-like guards to prevent them from being loaded
    directly. Version control noise (e.g., `.svn`) needs protecting. With `mod_php`,
    *everything* on your filesystem is a potential entry point; with an app server,
    there’s only one entry point, and only the URL controls whether it’s invoked.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “一堆文件”方法不仅使路由变得非常麻烦，还意味着你必须仔细地列出或列出不可用的内容，因为你的 URL 层次结构也是整个代码树。配置文件和其他“局部文件”需要类似
    C 的保护以防止它们被直接加载。版本控制噪声（例如 `.svn`）需要保护。使用 `mod_php`，你文件系统上的 *一切* 都是潜在的入口点；而使用应用服务器，只有一个入口点，只有
    URL 控制是否调用它。
- en: You can’t seamlessly upgrade a bunch of files that run CGI-style, unless you
    want crashes and undefined behavior as users hit your site halfway through the upgrade.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你想让用户在升级过程中访问你的网站，否则无法无缝地升级一堆运行 CGI 风格的文件，因为这会导致崩溃和未定义的行为。
- en: Despite how “simple” it is to configure Apache to run PHP, there are some subtle
    traps even there. While the PHP docs suggest using `SetHandler` to make `.php`
    files run as PHP, `AddHandler` appears to work just as well, and in fact Google
    gives me twice as many results for it. Here’s the problem.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管配置 Apache 以运行 PHP 看起来“简单”，但即使在那里也有一些微妙的陷阱。虽然 PHP 文档建议使用 `SetHandler` 让 `.php`
    文件作为 PHP 运行，但 `AddHandler` 看起来同样有效，实际上谷歌给了我两倍多的结果。这就是问题所在。
- en: When you use `AddHandler`, you are telling Apache that “execute this as php”
    is *one possible* way to handle `.php` files. **But**! Apache doesn’t have the
    same idea of file extensions that every human being on the planet does. It’s designed
    to support, say, `index.html.en` being recognized as both English and HTML. To
    Apache, a file can have *any number* of file extensions simultaneously.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你使用 `AddHandler` 时，你告诉 Apache “执行这个作为 php” 是处理 `.php` 文件的 *一种可能的* 方法。 **但**！Apache
    并不像地球上的每个人那样理解文件扩展名。它设计为支持，比如 `index.html.en` 被同时识别为英语和 HTML。对于 Apache，一个文件可以同时具有
    *任意数量* 的文件扩展名。
- en: Imagine you have a file upload form that dumps files into some public directory.
    To make sure nobody uploads PHP files, you just check that they don’t have a `.php`
    extension. All an attacker has to do is upload a file named `foo.php.txt`; your
    uploader won’t see a problem, but Apache *will* recognize it as PHP, and it will
    happily execute.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想象一下你有一个文件上传表单，它将文件转储到某个公共目录中。为了确保没有人上传 PHP 文件，你只需检查它们是否没有 `.php` 扩展名。攻击者所需做的就是上传一个名为
    `foo.php.txt` 的文件；你的上传程序看不出问题，但 Apache *会* 将其识别为 PHP，并且它会愉快地执行。
- en: The problem here isn’t “using the original filename” or “not validating better”;
    the problem is that your web server is configured to run any old code it runs
    across—precisely the same property that makes PHP “easy to deploy”. CGI required
    `+x`, which was *something*, but PHP doesn’t even do that. And this is no theoretical
    problem; I’ve found multiple live sites with this issue.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的问题不是“使用原始文件名”或“验证不够好”; 问题在于你的 Web 服务器配置为运行任何它遇到的旧代码 —— 这恰恰是 PHP “易于部署”的属性。CGI
    需要 `+x`，这是 *一种*，但 PHP 甚至没有这样做。这不是一个理论上的问题；我发现有多个实际站点存在此问题。
- en: I consider all of these to be varying levels of critical for building a Web
    application. It seems reasonable that PHP, with its major selling point being
    that it’s a “Web language”, ought to have some of them.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为所有这些都是构建 Web 应用程序的关键因素的不同级别。PHP 的主要卖点是它是一种“网络语言”，因此合理的做法是它应该有一些这样的功能。
- en: No template system. There’s PHP itself, but nothing that acts as a big interpolator
    rather than a program.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有模板系统。有 PHP 本身，但没有像一个大的内插器而不是程序那样的东西。
- en: No XSS filter. No, “remember to use `htmlspecialchars`” is not an XSS filter.
    [This is.](http://pypi.python.org/pypi/MarkupSafe)
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有 XSS 过滤器。不，“记得使用 `htmlspecialchars`”不是 XSS 过滤器。[这才是。](http://pypi.python.org/pypi/MarkupSafe)
- en: No CSRF protection. You get to do it yourself.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有 CSRF 保护。你必须自己来做。
- en: No generic standard database API. Stuff like PDO has to wrap every individual
    database’s API to abstract the differences away.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有通用的标准数据库API。像PDO这样的东西必须包装每个单独数据库的API来抽象掉差异。
- en: No routing. Your website looks exactly like your filesystem. Many developers
    have been tricked into thinking `mod_rewrite` (and `.htaccess` in general) is
    an acceptable substitute.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有路由。你的网站看起来就像你的文件系统一样。许多开发人员被骗以为`mod_rewrite`（以及`.htaccess`总体上）是可以接受的替代品。
- en: No authentication or authorization.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有身份验证或授权。
- en: No dev server. (“Fixed” in 5.4\. Led to the `Content-Length` vuln below. Also,
    you have to port all your rewrite rules to a PHP wrapper thing, because there’s
    no routing.)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有开发服务器。（在5.4中“修复”。导致下面的`Content-Length`漏洞。此外，你必须将所有重写规则端口到PHP包装器中，因为没有路由。）
- en: No interactive debugging.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有交互式调试。
- en: No coherent deployment mechanism; only “copy all these files to the server”.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有统一的部署机制；只有“将所有这些文件复制到服务器上”。
- en: PHP’s poor security reputation is largely because it will take arbitrary data
    from one language and dump it into another. This is a bad idea. `"<script>"` may
    not mean anything in SQL, but it sure does in HTML.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的安全声誉很差主要是因为它会将来自一种语言的任意数据转储到另一种语言中。这是一个坏主意。`"<script>"`在SQL中可能没有任何意义，但在HTML中确实有意义。
- en: 'Making this worse is the common cry for “sanitizing your inputs”. That’s completely
    *wrong*; you can’t wave a magic wand to make a chunk of data inherently “clean”.
    What you need to do is speak the language: use placeholders with SQL, use argument
    lists when spawning processes, etc.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，普遍呼吁“清理你的输入”。那完全是*错误*的；你不能挥舞魔杖使一块数据本质上“干净”。你需要做的是说出语言：在SQL中使用占位符，在生成进程时使用参数列表，等等。
- en: 'PHP outright *encourages* “sanitizing”: there’s an entire [data filtering extension](http://www.php.net/manual/en/book.filter.php)
    for doing it.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP直接*鼓励*“清理”：有一个专门的[data过滤扩展](http://www.php.net/manual/en/book.filter.php)来做这个。
- en: All the `addslashes`, `stripslashes`, and other slashes-related nonsense are
    red herrings that don’t help anything.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的`addslashes`，`stripslashes`以及其他与反斜杠相关的废话都是不帮助的干扰信息。
- en: There is, as far as I can tell, no way to safely spawn a process. You can ONLY
    execute a string via the shell. Your options are to escape like crazy and hope
    the default shell uses the right escaping, or `pcntl_fork` and `pcntl_exec` *manually*.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 据我所知，没有安全地生成进程的方法。你只能通过shell执行一个字符串。你的选择是疯狂地转义并希望默认的shell使用正确的转义，或者*手动*使用`pcntl_fork`和`pcntl_exec`。
- en: Both `escapeshellcmd` and `escapeshellarg` exist with roughly similar descriptions.
    Note that on Windows, `escapeshellarg` does not work (because it assumes Bourne
    shell semantics), and `escapeshellcmd` just replaces a bunch of punctuation with
    spaces because nobody can figure out Windows cmd escaping (which may silently
    wreck whatever you’re trying to do).
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`escapeshellcmd`和`escapeshellarg`都存在，描述大致相似。请注意，在Windows上，`escapeshellarg`不起作用（因为它假定Bourne
    shell语义），而`escapeshellcmd`只是将一堆标点符号替换为空格，因为没有人能够弄清楚Windows cmd的转义（这可能会悄悄地破坏你正在尝试的任何事情）。'
- en: The original built-in MySQL bindings, still widely-used, have no way to create
    prepared statements.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的内置MySQL绑定，仍然被广泛使用，没有办法创建准备好的语句。
- en: To this day, the [PHP documentation on SQL injection](http://www.php.net/manual/en/security.database.sql-injection.php)
    recommends batty practices like type-checking, using `sprintf` and `is_numeric`,
    manually using `mysql_real_escape_string` everywhere, or manually using `addslashes`
    everywhere (which “may be useful”!). There is no mention of PDO or paramaterization,
    except in the user comments. I complained about this very specifically *to a PHP
    dev* at least two years ago, he was alarmed, and the page has never changed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 直到今天，[PHP关于SQL注入的文档](http://www.php.net/manual/en/security.database.sql-injection.php)仍然推荐像类型检查、使用`sprintf`和`is_numeric`、到处手动使用`mysql_real_escape_string`或者到处手动使用`addslashes`（这“可能会有用”！）这样疯狂的做法。除了用户评论，没有提到PDO或参数化。至少两年前我向一位PHP开发者*具体*抱怨过这个问题，他感到震惊，但页面从未改变过。
- en: '`register_globals`. It’s been off by default for a while by now, and it’s gone
    in 5.4\. I don’t care. This is an *embarrassment*.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register_globals`。现在已经默认关闭一段时间了，在5.4中已经移除。我不在乎。这是一种*尴尬*。'
- en: '`include` accepting HTTP URLs. Likewise.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`接受HTTP URL。同样地。'
- en: Magic quotes. So close to secure-by-default, and yet so far from understanding
    the concept at all. And, likewise.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔术引号。离默认安全很近，但离完全理解概念还差得很远。同样地。
- en: You can, say, [probe a network](http://www.idontplaydarts.com/2011/02/scanning-the-internal-network-using-simplexml/)
    using PHP’s XML support, by abusing its ubiquitous support for filenames-as-URLs.
    Only `libxml_disable_entity_loader()` can fix this, and the problem is only mentioned
    in the manual comments.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以，比如说，使用 PHP 的 XML 支持来 [探测网络](http://www.idontplaydarts.com/2011/02/scanning-the-internal-network-using-simplexml/)，通过滥用它对文件名作为
    URL 的支持。只有 `libxml_disable_entity_loader()` 可以解决这个问题，而且这个问题只在手册评论中提到过。
- en: (5.5 brings a just-do-it password hashing function, `password_hash`, which should
    hopefully cut down on hand-rolled crypto code.)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: （5.5 带来了一个名为 `password_hash` 的立即执行密码哈希函数，这应该会减少手动编写的加密代码。）
- en: The PHP interpreter itself has had some *fascinating* security problems.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 解释器本身也存在一些 *令人着迷的* 安全问题。
- en: 'In 2007 the interpreter had an integer overflow vulnerability. The fix started
    with `if (size > INT_MAX) return NULL;` and went [downhill from there](http://use.perl.org/use.perl.org/_Aristotle/journal/33448.html).
    (For those not down with the C: `INT_MAX` is the biggest integer that will fit
    in a variable, ever. I hope you can figure out the rest from there.)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2007 年，解释器存在整数溢出漏洞。修复从 `if (size > INT_MAX) return NULL;` 开始，[由此而引发的问题](http://use.perl.org/use.perl.org/_Aristotle/journal/33448.html)
    不断恶化。（对于不熟悉 C 语言的人：`INT_MAX` 是能够容纳的最大整数。我希望你能从中推断出其他的。）
- en: More recently, PHP 5.3.7 managed to include a `crypt()` function that would,
    in effect, [let anyone log in with any password](https://bugs.php.net/bug.php?id=55439).
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更近些时候，PHP 5.3.7 成功地包含了一个 `crypt()` 函数，事实上，它会让 *任何人* 使用 *任何密码* [登录](https://bugs.php.net/bug.php?id=55439)。
- en: PHP 5.4’s dev server is vulnerable to a denial of service, because it takes
    the `Content-Length` header (which anyone can set to anything) and tries to allocate
    that much memory. [This is a bad idea.](http://www.exploit-db.com/exploits/18665/)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 5.4 的开发服务器容易受到拒绝服务攻击，因为它会接受 `Content-Length` 标头（任何人都可以将其设置为任何值）并尝试分配相同数量的内存。
    [这是个糟糕的主意。](http://www.exploit-db.com/exploits/18665/)
- en: I could dig up more but the point isn’t that there are X many exploits—software
    has bugs, it happens, whatever. The *nature* of these is horrifying. And I didn’t
    seek these out; they just happened to land on my doorstep in the last few months.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以挖掘更多，但关键不在于存在多少漏洞——软件存在漏洞，这是正常的，无论如何。而是这些漏洞的 *性质* 令人恐惧。我没有刻意寻找它们；它们只是在过去几个月里不期而至地降临到我门前。
- en: Some commentary has rightfully pointed out that I don’t have a conclusion. And,
    well, I don’t have a conclusion. If you got all the way down here, I assumed you
    agreed with me before you started :)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一些评论正确指出我没有结论。嗯，事实上我没有结论。如果你一路读到这里，我认为你在开始之前就已经同意了我的观点 :)
- en: If you only know PHP and you’re curious to learn something else, give the [Python
    tutorial](http://docs.python.org/tutorial/) a whirl and try [Flask](http://flask.pocoo.org/)
    for the web stuff. (I’m not a huge fan of its template language, but it does the
    job.) It breaks apart the pieces of your app, but they’re still the same pieces
    and should look familiar enough. I might write a real post about this later; a
    whirlwind introduction to an entire language and web stack doesn’t belong down here.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只懂 PHP，并且想学习其他东西，可以试试 [Python 教程](http://docs.python.org/tutorial/) 和 [Flask](http://flask.pocoo.org/)
    用于网络部分。（我不是它的模板语言的铁杆粉丝，但它做了它的工作。）它会拆分你的应用程序的各个部分，但它们仍然是相同的部分，应该看起来足够熟悉。我可能稍后会写一篇真正的文章；对整个语言和网络堆栈的快速介绍不应该放在这里。
- en: Later or for bigger projects you may want [Pyramid](http://www.pylonsproject.org/),
    which is medium-level, or [Django](https://www.djangoproject.com/), which is a
    complex monstrosity that works well for building sites like Django’s.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 更多时候或者对于更大的项目，你可能需要选择 [Pyramid](http://www.pylonsproject.org/)，它是中等级别的，或者 [Django](https://www.djangoproject.com/)，它是一个复杂的怪物，适用于构建像
    Django 这样的站点。
- en: If you’re not a developer at all but still read this for some reason, I will
    not be happy until everyone on the planet has gone through [Learn Python The Hard
    Way](http://learnpythonthehardway.org/) so go do that.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本不是开发人员但仍然因某种原因阅读这篇文章，我只有在全球每个人都完成了 [Learn Python The Hard Way](http://learnpythonthehardway.org/)
    后才会感到满意，所以去做吧。
- en: There’s also Ruby with Rails and some competitors I’ve never used, and Perl
    is still alive and kicking with Catalyst. Read things, learn things, build things,
    go nuts.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 也是一种选择，与 Rails 一起使用，还有一些竞争对手我从未使用过，Perl 仍然与 Catalyst 一起活跃着。阅读、学习、建设，疯狂地去做吧。
- en: 'Thanks to the following for inspiration:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 特别感谢以下内容的 *灵感*：
- en: Let me know if you have any additions, or if I’m (factually!) wrong about something.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有任何补充意见，或者我在某些事情上（事实上！）错误，请告诉我。
