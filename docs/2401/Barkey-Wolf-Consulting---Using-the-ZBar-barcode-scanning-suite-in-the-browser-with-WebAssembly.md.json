["```\ndocker run -v $(pwd):/src -it trzeci/emscripten:1.39.0 /bin/bash \n```", "```\napt-get update && apt-get install autoconf libtool gettext autogen imagemagick libmagickcore-dev -y \n```", "```\n# cd into the mounted host directory\ncd /src\n\n# clone the latest ZBar code from the Github repo\ngit clone https://github.com/ZBar/ZBar\n\n# cd into the directory\ncd ZBar\n\n# Delete all -Werror strings from configure.ac\n# Don't treat warnings as errors!\nsed -i \"s/ -Werror//\" $(pwd)/configure.ac\n\n# Generate automake files\nautoreconf -i\n\n# Configure: disable all unneccesary features\n# This may produce red error messages, but it is safe to ignore them (it assumes that\n# emscripten is GCC and uses invalid parameters on it)\nemconfigure ./configure --without-x --without-jpeg --without-imagemagick --without-npapi --without-gtk --without-python --without-qt --without-xshm --disable-video --disable-pthread\n\n# Compile ZBar\nemmake make \n```", "```\n#include <stdlib.h>  #include <stdio.h>  #include <stdint.h>  #include <zbar.h>  #include \"emscripten.h\"   // External javascript function to pass the retrieved data to. extern void js_output_result(const char *symbolName, const char *data, const int *polygon, const unsigned polysize);\n\nzbar_image_scanner_t *scanner = NULL;\n\nEMSCRIPTEN_KEEPALIVE\nint scan_image(uint8_t *raw, int width, int height)\n{\n\t// create the scanner\n scanner = zbar_image_scanner_create();\n\n    // set the scanner density (function will have nonzero return code on error, check your browser console)\n printf(\"%d \\n\", zbar_image_scanner_set_config(scanner, 0, ZBAR_CFG_X_DENSITY, 1));\n    printf(\"%d \\n\", zbar_image_scanner_set_config(scanner, 0, ZBAR_CFG_Y_DENSITY, 1));\n\n\t// hydrate a zbar image struct with the image data.\n zbar_image_t *image = zbar_image_create();\n    zbar_image_set_format(image, zbar_fourcc('Y', '8', '0', '0'));\n    zbar_image_set_size(image, width, height);\n    zbar_image_set_data(image, raw, width * height, zbar_image_free_data);\n\n\t// scan the image for barcodes\n int n = zbar_scan_image(scanner, image);\n\n\t// Iterate over each detected barcode and extract its data and location\n const zbar_symbol_t *symbol = zbar_image_first_symbol(image);\n    for (; symbol; symbol = zbar_symbol_next(symbol))\n    {\n        // Get the data encoded in the detected barcode.\n zbar_symbol_type_t typ = zbar_symbol_get_type(symbol);\n        const char *data = zbar_symbol_get_data(symbol);\n\n        // get the polygon describing the bounding box of the barcode in the image\n unsigned poly_size = zbar_symbol_get_loc_size(symbol);\n\n        // return the polygon as a flat array.\n // (Parsing two-dimensional arrays from the wesm heap introduces unnecessary upstream code complexity)\n int poly[poly_size * 2];\n        unsigned u = 0;\n        for (unsigned p = 0; p < poly_size; p++)\n        {\n            poly[u] = zbar_symbol_get_loc_x(symbol, p);\n            poly[u + 1] = zbar_symbol_get_loc_y(symbol, p);\n            u += 2;\n        }\n\n        // Output the result to the javascript environment\n js_output_result(zbar_get_symbol_name(typ), data, poly, poly_size);\n    }\n\n\t// clean up\n zbar_image_destroy(image);\n    zbar_image_scanner_destroy(scanner);\n\n    return (0);\n}\n\n// this function can be used from the javascript environment to // allocate a buffer on the WebAssembly heap to accomodate the image that is to be scanned. EMSCRIPTEN_KEEPALIVE\nuint8_t *create_buffer(int width, int height)\n{\n    return malloc(width * height * 4 * sizeof(uint8_t));\n}\n\n// this function can be used from the javascript environment to free an image buffer. EMSCRIPTEN_KEEPALIVE\nvoid destroy_buffer(uint8_t *p)\n{\n    free(p);\n} \n```", "```\nmergeInto(LibraryManager.library, {\n    js_output_result: function (symbol, data, polygon, polygon_size) {\n        // function provided by Emscripten to convert WASM heap string pointers to JS strings.\n const Pointer_stringify = Module[\"UTF8ToString\"];\n\n        // Note: new TypedArray(someBuffer) will create a new view onto the same memory chunk, \n // while new TypedArray(someTypedArray) will copy the data so the original can be freed.\n const resultView = new Int32Array(\n            Module.HEAP32.buffer,\n            polygon,\n            polygon_size * 2\n        );\n        const coordinates = new Int32Array(resultView);\n\n        // call the downstream processing function that should have been set by the client code\n const downstreamProcessor = Module[\"processResult\"];\n        if (downstreamProcessor == null) {\n            throw new Error(\"No downstream processing function set\");\n        }\n        downstreamProcessor(\n            Pointer_stringify(symbol),\n            Pointer_stringify(data),\n            coordinates\n        );\n    }\n}); \n```", "```\nemcc -O3 -s WASM=1 \\ --js-library ./library.js \\ -s EXTRA_EXPORTED_RUNTIME_METHODS='[\"cwrap\", \"UTF8ToString\"]' \\ -I `pwd`/ZBar/include ./scan.c ./ZBar/zbar/.libs/libzbar.a \n```", "```\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>barcode scanner wasm</title>\n</head>\n\n<!-- We create some DOM elements necessary for grabbing webcam frames -->\n<body>\n\t<div>\n\t\t<!-- note that we hide the live video element using 'display:none', that way only the canvas is rendered -->\n\t\t<video id=\"live\" width=\"320\" height=\"240\" autoplay style=\"border:5px solid #000000; display:none;\"> </video>\n\t\t<canvas id=\"canvas\" style=\"border:5px solid #000000\"> </canvas>\n\t</div>\n\n</body>\n\n<!-- Import the javascript bundle produced by Emscripten-->\n<script src=\"/a.out.js\"></script>\n\n<!-- The main 'application code' tying it all together -->\n<script>\n\n// Execute the application code when the WebAssembly module is ready. Module.onRuntimeInitialized = async _ => {\n\n// wrap all C functions using cwrap. Note that we have to provide crwap with the function signature. const api = {\n\tscan_image: Module.cwrap('scan_image', '', ['number', 'number', 'number']),\n\tcreate_buffer: Module.cwrap('create_buffer', 'number', ['number', 'number']),\n\tdestroy_buffer: Module.cwrap('destroy_buffer', '', ['number']),\n};\n\nconst video = document.getElementById(\"live\");\nconst canvas = document.getElementById(\"canvas\");\nconst ctx = canvas.getContext('2d');\nconst desiredWidth = 1280;\nconst desiredHeight = 720;\n\n// settings for the getUserMedia call const constraints = {\n\tvideo: {\n\t\t// the browser will try to honor this resolution, but it may end up being lower.  width: desiredWidth,\n\t\theight: desiredHeight\n\t}\n};\n\n// open the webcam stream navigator.mediaDevices.getUserMedia(constraints).then((stream) => {\n\t// stream is a MediaStream object  video.srcObject = stream;\n\tvideo.play();\n\n\t// tell the canvas which resolution we ended up getting from the webcam  const track = stream.getVideoTracks()[0];\n\tconst actualSettings = track.getSettings();\n\tconsole.log(actualSettings.width, actualSettings.height)\n\tcanvas.width = actualSettings.width;\n\tcanvas.height = actualSettings.height;\n\n\t// every k milliseconds, we draw the contents of the video to the canvas and run the detector.  const timer = setInterval(detectSymbols, 250);\n\n}).catch((e) => {\n\tthrow e\n});\n\nfunction detectSymbols() {\n\t// grab a frame from the media source and draw it to the canvas  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n\t// get the image data from the canvas  const image = ctx.getImageData(0, 0, canvas.width, canvas.height)\n\n\t// convert the image data to grayscale  const grayData = []\n\tconst d = image.data;\n\tfor (var i = 0, j = 0; i < d.length; i += 4, j++) {\n\t\tgrayData[j] = (d[i] * 66 + d[i + 1] * 129 + d[i + 2] * 25 + 4096) >> 8;\n\t}\n\n\t// put the data into the allocated buffer on the wasm heap.  const p = api.create_buffer(image.width, image.height);\n\tModule.HEAP8.set(grayData, p);\n\n\t// call the scanner function  api.scan_image(p, image.width, image.height)\n\n\t// clean up \n //(this is not really necessary in this example as we could reuse the buffer, but is used to demonstrate how you can manage Wasm heap memory from the js environment)  api.destroy_buffer(p);\n\n}\n\nfunction drawPoly(ctx, poly) {\n// drawPoly expects a flat array of coordinates forming a polygon (e.g. [x1,y1,x2,y2,... etc])  ctx.beginPath();\n\tctx.moveTo(poly[0], poly[1]);\n\tfor (item = 2; item < poly.length - 1; item += 2) { ctx.lineTo(poly[item], poly[item + 1]) }\n\n\tctx.lineWidth = 2;\n\tctx.strokeStyle = \"#FF0000\";\n\tctx.closePath();\n\tctx.stroke();\n}\n\n// render the string contained in the barcode as text on the canvas function renderData(ctx, data, x, y) {\n\tctx.font = \"15px Arial\";\n\tctx.fillStyle = \"red\";\n\tctx.fillText(data, x, y);\n}\n\n// set the function that should be called whenever a barcode is detected Module['processResult'] = (symbol, data, polygon) => {\n\tconsole.log(\"Data liberated from WASM heap:\")\n\tconsole.log(symbol)\n\tconsole.log(data)\n\tconsole.log(polygon)\n\n\t// draw the bounding polygon  drawPoly(ctx, polygon)\n\n\t// render the data at the first coordinate of the polygon  renderData(ctx, data, polygon[0], polygon[1] - 10)\n}\n\n}\n</script>\n\n</html> \n```"]