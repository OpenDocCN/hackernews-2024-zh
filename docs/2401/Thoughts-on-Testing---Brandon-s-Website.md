<!--yml

类别：未分类

日期：2024-05-27 14:32:11

-->

# 测试思考 | Brandon's Website

> 来源：[https://www.brandons.me/blog/thoughts-on-testing](https://www.brandons.me/blog/thoughts-on-testing)

# 测试思考 2024年1月4日

1548 Brandon Smith

今天我在思考测试问题。

## 怀疑

我对测试持怀疑态度。我不是*反对*测试（尽管我的同事今天开口就说“我知道你讨厌测试”，我迅速放大声音说“我不讨厌测试！”只是为了确保每个人都知道），但*很多人真的很喜欢测试*，有时我觉得我需要泼些冷水。

## 成本

问题在于*测试就是代码*，*所有代码都是技术债务*，但与普通代码不同，测试可以无限增长，并且它们并不总被视为一种有成本的东西，因为它们不会被部署到生产环境。但是每个测试都是...

当代码需要花费时间编写时

当代码需要花费时间维护时（需求变化、依赖项变化等）

需要在CI中运行的代码时间

而且糟糕的测试可能会给人一种虚假的安全感

因此，我认为可以这样说（尽管有些工程书籍和管理指导）*最佳测试数量不是我们可能提出的那么多*。

## 判断

那么，什么是最佳测试数量呢？这取决于情况，但以下是我喜欢提出问题的一些方式：

### “这是静态分析可以测试的内容吗？”

任何可以通过静态类型、代码检查等进行检查的内容，都比测试更容易被捕捉到。有很多事情是不能被捕捉到的，但这是一个起点。

这不仅仅是个人偏好：静态分析一次性防止了整类错误，而测试则覆盖了个别输入。你可能会忘记为边缘情况编写测试，但类型检查器不会忘记。

但是静态分析并不适用于每种语言，在这些语言中，单元测试变得更加重要，因为它们试图填补这个空白。

### “行为会*有意*改变多少次？”

这个问题告诉我们我们会有多少次假阳性（需要“修复”的测试）。考虑为两个函数编写测试的情况：

第一个是一个[fibonacci](https://en.wikipedia.org/wiki/Fibonacci_sequence)函数。斐波那契序列是有明确定义的，它有一个明确的定义，它永远不会改变。如果我们测试一个给定的输入+输出组合，而我们的测试失败了，那将*始终*意味着我们的代码出了问题。将*永远*不会出现假阳性（测试失败，但实际上实现了我们想要的内容），因为如果我们希望`fib(3)`等于`100`，我们就不再讨论斐波那契函数了。

想象另一个返回包含人名的问候消息的函数（例如。`"Hello, Brandon!"`）。假设我们编写了一个测试，检查`greet("Brandon")`是否返回`"Hello, Brandon!"`：

```
function greet(name) {
  return `Hello, ${name}!`
}

test("greeting is correct", () => {
  expect(greet("Brandon")).toBe("Hello, Brandon!")
}) 
```

现在，假设产品经理有一天来找我们说，"我们有一个新设计，我们现在想让它说`"欢迎Brandon，欢迎来到我们的网站！"`"

```
function greet(name) {
  return `Greetings ${name}, welcome to our website!`
}

test("greeting is correct", () => {
  expect(greet("Brandon")).toBe("Hello, Brandon!") 
}) 
```

我们改变了代码的行为，现在我们的测试失败了！但失败不是因为我们引入了一个错误，而是因为*我们改变了主意*。新消息现在是`greet()`的*正确*行为，因此测试现在是不正确的，需要更新。花在"修复"测试上的时间是纯粹的额外开销。

换句话说：被测试代码的"正确"的定义是什么，以及这个定义有多稳固？

大多数情况并不像这两种情况那样明显，但总的来说：

+   确实，通用的实用工具不太可能需要改变它们的行为。

+   核心业务逻辑不太可能需要改变它的行为（取决于它离特性变化有多近）

+   像用户界面的表面行为（稍后会详细介绍）更有可能有意改变。

### "测试是否只是映射了被测试逻辑的逻辑？"

考虑以下内容：

```
function calculation(n) {
  return n * 2 + 6
}

test("calculation returns correct output", () => {
  const n = 4
  expect(calculation(n)).toBe(n * 2 + 6)
}) 
```

这并没有告诉我们有趣的东西，我们只是把它写了两遍。它会告诉我们`calculation`的行为*改变*，但不会告诉我们它是否*错误*。好的测试检查*意图*而非*行为*。 例如：

```
function isEligible(age) {
  if (age < 18) {
    return false
  } else {
    return true
  }
}

test("isEligible returns correct output", () => {
  expect(isEligible(100)).toBe(true)
  expect(isEligible(22)).toBe(true)
  expect(isEligible(16)).toBe(false)
}) 
```

在这里，我们正在文档化我们测试中的一个*有意义的概念*，这个概念在被测试的代码中并不直接表示，因此它比实现细节更有可能*随时间稳定*。

### "测试是否比实现更简单？"

同样，在相同的线路上，一个很好的测试候选者是代码，其行为复杂到在测试中*难以*简单复制。一个很好的测试函数是一个*看着不确定它是否会通过看来就能正确执行的*函数。

对于这样的代码，测试将比它所测试的内容更简单。"测试意图而非实现细节"；大多数代码的*意图*都比实现要简单，我们希望测试能反映出意图。

### "正在测试的代码与外部世界互动的程度有多大？"

模拟增加了大量的复杂性，并且减少了实际被测试功能的数量。它使得代码既更难测试又更不值得测试。

但是，当你测试与外部系统耦合的代码时，这是不可避免的。依赖外部系统的单元测试从来都不是一个好主意；它们可能会神秘地和不一致地出现故障。

有时可以通过重新构造你的代码来避免模拟，但有时是不可能的。如果不可能，大量模拟的需要是代码可能不值得（单元）测试的一个线索。

### "这段代码有多重要？"

当然，代码越是业务关键，和/或者使用越广泛（例如，在许多地方使用的核心组件），测试的价值就越高。即使实现是微不足道的，即使我们的测试只能确保它不会出现意外变化，也值得测试`coreBusinessRule`。即使我们的测试只能确保它不会出现意外变化，也值得测试`coreBusinessRule`。即使我们的测试只能确保它不会出现意外变化，也值得测试`coreBusinessRule`。即使我们的测试只能确保它不会出现意外变化，也值得测试`coreBusinessRule`。即使我们的测试只能确保它不会出现意外变化，也值得测试`coreBusinessRule`。即使我们的测试只能确保它不会出现意外变化，也值得测试`coreBusinessRule`。一切都是一种判断。一切都是一种判断。

## 集成测试

到目前为止，我一直在谈论单元测试，但集成测试在某些方面有所不同，尤其是在模拟问题上：几乎可以通过定义说你并不真正模拟系统，而是测试它们之间的交互，这些交互否则很难测试。

其他规则仍然适用：编写反映意图的测试（例如，“单击标签为“提交”的按钮”）而不是实现（“单击页面上的第三个`<button>`标签”）会使它们更加稳定。更喜欢检查有价值行为的测试（“用户能否登录？”）而不是检查无价值行为的测试（“提交按钮是蓝色的吗？”）会更好地利用你的努力。等等。

## UI 测试

我在上面暗示过，但是我有一种具有争议的看法，*我认为基于这些启发的 UI 渲染代码很少值得进行单元测试*。用户界面：

+   常常有意改变输出/行为（导致测试不稳定）

+   常常（不总是！）有易于通过查看验证的微不足道的逻辑

+   通常与其框架/平台紧密耦合，需要精心设计的模拟和测试套件插件

*但是*我真正指的只是渲染层，而不是整个前端代码库：

+   与 UI 脱钩的状态管理（React hooks、存储等）可能是一个很好的选择；那是大部分复杂性所在，而且它没有上述大部分问题

+   业务规则如验证也是很好测试的；逻辑通常是纯粹的（这使得测试变得非常容易），它们通常对“正确”和“错误”的定义非常稳定（上次“有效电话号码”的含义改变是什么时候？）

+   任何与面向用户功能变更远的核心实用程序

然后，一个包含在许多地方使用的非常通用的 UI 组件库可能会倾向于进行单元测试。价值更高，成本（模拟等）通常较低，因为它们是可重复使用的。它们也可能比产品特性更少地改变。

## 收尾思考

我不讨厌测试（我保证，Avid！），我只是试图根据具体情况来质疑它们，我还没有遇到过很多这样做的人。

它们有很高的组织成本，作为工程师，我们需要意识到这一点。拥有更多的界面使控制台中的绿色标记变得更多，使覆盖率数字增加，因此增加它们感觉很好。但是像任何东西一样，测试需要考虑周全。
