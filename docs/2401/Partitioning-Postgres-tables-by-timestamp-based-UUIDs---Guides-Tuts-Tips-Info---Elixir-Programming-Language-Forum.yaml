- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:43:39'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning Postgres tables by timestamp based UUIDs - Guides/Tuts/Tips/Info
    - Elixir Programming Language Forum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://elixirforum.com/t/partitioning-postgres-tables-by-timestamp-based-uuids/60916](https://elixirforum.com/t/partitioning-postgres-tables-by-timestamp-based-uuids/60916)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Recently we partitioned a table with 28 million rows by its ULID to improve
    query speeds and reduce query timeouts. To do this I ended up pulling together
    various bits of information across the internet and thought it might be worth
    compressing it into a guide for future reference and discussion on areas I might
    have missed!
  prefs: []
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had a very large table (28 million) rows that we were getting timeouts querying
    on anything other than the primary key. No matter what indexes we threw at the
    table we couldn’t get queries to complete in an acceptable time for use on the
    front end of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The table in question was where we stored and processed payloads from our customers,
    so it needed to be very quick for individual lookups in order to update its state
    as it was processed into the application and fast for broader retrieval to display
    on the front end of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partitioning had always been an option and something we had attempted previously.
    Our original attempt to speed it up had been partitioning the table on the insertion
    time of the record but, if you’ve ever done partitioning before you will know,
    you cannot have a globally unique index.
  prefs: []
  type: TYPE_NORMAL
- en: To create a unique or primary key constraint on a partitioned table, the partition
    keys must not include any expressions or function calls and the constraint’s columns
    must include all of the partition key columns. This limitation exists because
    the individual indexes making up the constraint can only directly enforce uniqueness
    within their own partitions; therefore, the partition structure itself must guarantee
    that there are not duplicates in different partitions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Without the globally unique index for the id of the payload meant that queries
    for a specific payload had to check every partition. This made the individual
    processing of a given payload too slow to make this a workable scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning with ULIDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The solution then was to have the id of the payload be a ULID based on its `inserted_at`
    and partition the tables on the timestamp component of the ULID it generated on
    the database! This means we could retain a global index for quick individual row
    lookups and have a way to ignore irrelevant partitions based on the id.
  prefs: []
  type: TYPE_NORMAL
- en: This took a few different steps…
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Postgres doesn’t with with ULIDs directly but between Ecto and Postgres they
    are cast to a UUID in the database. We needed a method for Postgres to take a
    ULID and convert it to the corresponding UUID that we can work with in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: We added the functions [here](https://github.com/scoville/pgsql-ulid) to a migration
    to make them available on the database.
  prefs: []
  type: TYPE_NORMAL
- en: While you’re on the database it’s worth ensuring that [`enable_partition_pruning`](https://www.postgresql.org/docs/current/ddl-partitioning.html#DDL-PARTITION-PRUNING)
    is enabled as this is how Postgres is able to ignore irrelevant partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions for manipulating ULIDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create the partitions we needed to be able to get the time portion of the
    ULID and get the bounds of any ids possible within the time.
  prefs: []
  type: TYPE_NORMAL
- en: This required slicing the time portion of the ULID and setting either “0” or
    “Z” depending on which bound we needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ensuring that timestamp and ids timestamp match
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not strictly necessary for tables where the insertion time is close
    enough to the autogeneration of the id that you wont get too much drift but if
    there could be drift, or you want to partition on an timestamp that wont necessarily
    correlate with the id here is how. The following is all performed on the schema.
  prefs: []
  type: TYPE_NORMAL
- en: Start by turning off the autogeneration of the id.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Check if the changeset has an id, and if it doesn’t add one based on the timestamp
    you want to use. In the following example I have used `occurred_at`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally add it as part of your changeset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Database migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I cannot take full credit for this as it’s adapted from [Matthew Johnston’s
    work on partitioning](https://mattjohnston.co/posts/postgres-partitions-elixir-migration/),
    changed to work with id’s.
  prefs: []
  type: TYPE_NORMAL
- en: We need to start with a couple of helper functions to help us partition on month.
    You might want something different so feel free to modify to fit your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use the functions above and our ULID functions earlier to have a query that
    will generate the query to make each partition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally we can tie it all together with out table creation!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That’s it you’ve just created your partitioned table based on the timestamp
    based UUID!
  prefs: []
  type: TYPE_NORMAL
- en: Improving your query speeds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now your Ecto queries can utilize the id to only query partitions that contain
    the data they are looking for skipping other partitions that don’t hold any relevant
    data. We use a combination of the database and ULID functions we created earlier
    in the `where` call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we went from queries taking multiple minutes to sub-second, zero timeouts
    and we were also able to retain very quick lookups on individual rows!
  prefs: []
  type: TYPE_NORMAL
- en: I hope that this helps others after me, and if you’ve got any suggestions on
    where you might do something slightly differently let me know! (I’ve only been
    working with Elixir for a little over a year now and I suspect there are some
    code smells etc in the above)
  prefs: []
  type: TYPE_NORMAL
