<!--yml

category: 未分类

date: 2024-05-27 14:56:40

-->

# 从 0 到 1 MB 在 DOS 中 - 作者 Julio Merino - Blog System/5

> 来源：[`blogsystem5.substack.com/p/from-0-to-1-mb-in-dos`](https://blogsystem5.substack.com/p/from-0-to-1-mb-in-dos)

自上次关于[旧文本化 IDE](https://blogsystem5.substack.com/p/the-ides-we-had-30-years-ago-and)的文章以来，我一直想写一篇关于 GCC 移植到 DOS 的文章，即 [DJGPP](https://www.delorie.com/djgpp/)。当我为这个主题起草时，我意识到有很多内容需要涵盖，为了确立背景，我剔除了大部分关于内存管理的内容，写了这篇单独的文章。

本文深入探讨了 DOS 如何运用技巧来最大化 8086 仅有的极其有限的 1 MB 地址空间。这些技巧之所以存在，是因为后来由 80286 和 80386 引入的特性，但这些只是为了掩盖 DOS 无法利用受保护模式提供的真正改进。

这个绕道很长，但我希望您会像我研究这个话题一样喜欢它。我将带您了解 x86 架构随着时间的推移所发生的变化，从 8086 开始，到 80386 结束，以及 DOS 在此过程中的演变。最后我会简要介绍 DOS 自己的 MEM 和 MemMaker 实用程序。为了保持文本的可管理性，我必须省略一些细节，所以请原谅某些领域缺乏细节；只需跟随外部文档的链接以获取更多信息。

*在我们开始之前，我要感谢 [Virtually Fun](https://virtuallyfun.com/) 的 neozeed 对本文的深入审阅。请访问他的博客了解更多有趣和相关的内容！*

回到 20 世纪 80 年代，[Intel 8086](https://en.wikipedia.org/wiki/Intel_8086)是个人计算机的*处理器*（以及它的残废兄弟 8088，在本文中将忽略）。8086 是一个简单的芯片，但具有重大局限性，但它取得了巨大成功，也是我们今天仍在使用的 x86 架构的基础。由于 8086 驱动了个人计算机，而 DOS 是 IBM 选择的个人计算机操作系统，因此 DOS 被设计用于 8086。

对于我们文章的目的，让我们关注两个细节：8086 CPU 具有 20 位地址总线，这意味着它只能寻址 1 MB 的内存，并且它是一款 16 位 CPU，这意味着它的内部寄存器都是 16 位长。这就引出了一个问题：如果寄存器只能表示 `2¹⁶ = 64K` 不同的值，那么代码如何引用 20 位地址空间？

答案是 *分段*。在 8086 中，每个引用内存的指令都通过指定一个地址来完成，该地址由两个独立的 16 位量组成：*段* 和 *段内偏移*。因为段是 16 位长，所以最多可以有 64KB 的段——如果我们将总地址空间的 1 MB 分成 64KB，我们可以推断出各段之间的偏移为 16 字节。

表示分段如何将 8086 1 MB 地址空间切割成 64KB 的重叠段，每个段相对于其他段偏移 16 字节。

图中有两个需要注意的地方。首先，段重叠，意味着单个内存位置可以被许多不同的段/偏移组合引用。其次，在`0xF000`之后的所有段引用不存在的 1 MB 地址空间的内存位置，8086 选择通过忽略地址的第 21 位来绕过。毕竟，在地址总线中不存在第 21 行。

当访问一个地址形式为`段:偏移`的内存片段，比如`81DA:72C3`，8086 将`0x81DA`乘以 16 (一个简单的左移 4 位) 并将`0x72C3`偏移添加到结果中以获取地址`0x89063`。从那里开始，8086 从该内存位置读取或写入并且结束。没有[内存管理单元 (MMU)](https://en.wikipedia.org/wiki/Memory_management_unit)：每个内存访问都可以引用任何地址，所有访问都是合法的（包括环绕访问！）这意味着空指针或悬空指针解引用不会导致任何崩溃。

这种没有 MMU 的分段寻址方式被称为*实模式*，但这个名字直到 80286 才出现，以便将其与*保护模式*区分开来。但在介绍后者之前，让我们先谈谈内存映射。

仅仅因为 8086 处理器可以引用 1 MB 的内存并不意味着 8086 机器配备了 1 MB 的完整 RAM。出于成本考虑，机器通常包含*少于*这个数量的内存，所以理解*地址空间*—即可以被*引用*的地址集—与安装的内存量不同是至关重要的。毫不奇怪：现代 64 位 CPU 也是如此。

这个事实是有利的，因为某些系统设备喜欢将自己作为地址空间的一部分公开。例如：BIOS ROM 可以通过上层内存中的一系列地址访问。又例如：视频卡倾向于将它们的帧缓冲区公开为内存映射设备，这样应用程序就可以直接写入到已知地址以操纵视频内存—绕过独立的 I/O 总线和指令集。

问题是：这些设备存在于地址空间的哪里？选择几乎是任意的，所以 IBM 所做的是将[原始 PC 的地址空间](https://wiki.osdev.org/Memory_Map_(x86))分成两部分。前 640 KB，称为*传统内存*，被映射到可用的 RAM 并且可以被应用程序轻松使用。上面的 384 KB，称为*上层内存*或*上层内存区域 (UMA)*，被保留给内存映射设备。为特定目的对地址空间的部分分配*意义*被称为*内存映射*，这就是原始 PC 的内存映射。

8086 PC 内存映射的表示。实心块对应于映射内存，虚线部分对应于未映射内存。

注意如何可能无法完全使用常规内存：尽管今天听起来可能令人震惊，但 PC 可能甚至只安装了不到 640 KB 的 RAM。对于我们的目的来说更重要的是，上部内存是*稀疏*的：某些地址范围分配给设备，但设备之间可能存在间隙。读取或写入未映射地址时会发生什么是很难确定的，因为这取决于芯片组——而不是 CPU——但请记住，所有访问必须以某种形式有效。

顺便说一下，“所有前 640 KB 都可以供应用程序自由使用”有一个极其微小的例外：RAM 的第一个 1 KB 被保留给中断向量表，当 8086 接收到中断时，它用来查找中断处理程序，再加上一些字节由 BIOS 用于映射易失性数据。我们可以忽略这些。

正如你可以想象的那样，640 KB 的 RAM 很快就*不够用*了。应用程序需要访问更多内存，但 8086 的 20 位地址总线的限制使得这很困难。然而，需要一个立即的解决方案。[扩展内存规范（EMS）](https://en.wikipedia.org/wiki/Expanded_memory)是其中的一个最初的解决方案，并最初由 Lotus 设计，以支持他们的明星应用程序[1-2-3](https://en.wikipedia.org/wiki/Lotus_1-2-3)。

这个想法很简单。记得上部内存是*稀疏*的吗？如果我们能够将该地址空间中的一个窗口映射到内存的不同部分会怎么样？如果我们能够通过软件控制在任何给定时间通过这样的窗口暴露的内存部分，会怎么样？

8086 PC 内存映射的表示以及上部内存中的一个 EMS 窗口映射到由外部 ISA 卡提供的内存部分。

这正是 EMS 所做的。EMS 引入了一个软件 API 的概念，允许应用程序通过将上部内存的 64 KB 窗口映射到另一块内存芯片来选择“其他”内存中的视图。最初，这种其他内存是由像下面这样的扩展 ISA 卡提供的，这意味着 EMS 需要硬件支持和硬件特定的驱动程序来执行窗口重新映射。顺便说一句，这也意味着这种内存可能比标准 RAM 慢得多。

一张 Emulex Persyst ISA 卡提供了 4 MB 额外的内存。这有多么巨大是值得注意的。图片来源于维基百科；[查看原图](https://en.wikipedia.org/wiki/File:EmulexPersyst_4M_ISA.jpeg)。

正如你可以想象的那样，这个技巧提供了在机器上访问*任何*额外 RAM 的理论能力……以在显式（重新）配置窗口的方式来构建你的应用程序为代价。实现这样的应用程序是困难的，而且当应用程序需要更大的地址空间来舒适地运行时，这也是不够的。EMS 是一个有用的权宜之计，但仍然是一个权宜之计。

随着程序和操作系统的需求增长，处理器本身也需要增加更先进的功能。特别是，它们需要获得访问远远超过 1 MB 内存的能力，并且它们需要提供内存保护功能以隔离程序。

80286 仍然是一款 16 位 CPU，将地址空间扩展到 24 位，以支持最多 16 MB 的 RAM。它引入了 MMU 以提供内存隔离。但这里有一个问题：16 位 `段：偏移` 对的 8086 内存寻址模式不允许寻址超出第 1 MB 以外的内存。因此，80286 必须找到一种不同的方式来引用 1 MB 以外的 RAM，也被称为 *扩展内存*，它通过引入一种完全不同的操作模式来实现，即 *保护模式*。

一旦进入保护模式，所有内存访问规则都会改变。首先，MMU 接管所有内存访问，确保它们根据预定义的保护是有效的。另外，`段：偏移` 地址改变了它们的语义。地址的段部分不再是一个缩减的内存地址，而是成为了一个 *索引* [到一个表中](https://wiki.osdev.org/Global_Descriptor_Table)（GDT 或 LDT）的段描述符。每个段描述符描述一个段的基地址作为 32 位量，段的大小作为 20 位量，段的访问保护以及一堆标志。

表示 80286 处理器在硬件上执行的操作的图示，用于解析段：地址内存引用。

在这种模式下，我们可能会看到一个地址，而不是 `81DA:72C3`，而是 `13:72C3`。要访问这个地址，MMU 查找 GDT 中的条目 13，找到一个描述符，说段从地址 `0x81DA` 开始，长度为 `0x7200` 字节，然后得出 `13:72C3` 引用超出范围，引发一个 [General Protection Fault](https://en.wikipedia.org/wiki/General_protection_fault) 硬件异常（你现在可怕的 [“段错误”](https://en.wikipedia.org/wiki/Segmentation_fault) 错误）。

但是，这种访问模型与 DOS 应用程序在实模式下习惯的模型非常不同，而 DOS 本身只设计用于在实模式下运行。因此，DOS 及其整个生态系统都停留在实模式世界中，仅限于在没有访问扩展内存的能力的情况下访问仅 1 MB 的内存… 或者不是吗？

热心的读者可能已经注意到在之前的图片中，在实模式下，有一些段理论上可以允许访问超过 1 MB 标记的地址。取 `FFFF:0010` 为例，这是 `0xFFFF * 0x10 + 0x10 = 0x100000 = 2²⁰` 或者在二进制形式中是 1 后跟着 20 个零的第一个扩展内存地址。8086 能够产生这样的地址，但它们会环绕，因为 8086 没有办法向内存总线发出第 21 位。

由于兼容性原因，80286 必须在实模式下截断这些地址，它通过将地址总线的第 21 条线（A20）连接到零来实现这一点。但是如果地址**没有**回绕会怎样呢？如果我们告诉 80286*不要*截断它们会怎样？事实上，通过启用[A20 门](https://zh.wikipedia.org/wiki/A20 线#A20 门)——需要通过键盘控制器完成的任务。启用 A20 是进入保护模式的先决条件，但如果在实模式下完成，则可以访问额外的 64 KB 内存。这个额外的内存称为[高内存区（HMA）](https://zh.wikipedia.org/wiki/高内存区)。

将 80286 实模式 1 MB 地址空间切片为 64KB 重叠段（相互偏移 16 字节），并展示如何使最后几个段溢出到扩展内存中的分段表示。

HMA（高内存区）的大小并不算大，但是传统内存非常有限，因此任何增加额外内存的技巧都受到欢迎，而 DOS 正是这样做的。通过加载`HIMEM.SYS`驱动程序，并在`CONFIG.SYS`文件中指定`DOS=HIGH`，DOS 会将其部分内容重定位到 HMA 中，以释放多达 64 KB 的传统内存。

不幸的是，额外的 64 KB 内存并不算多。这是一个不错的技巧，但应用程序确实需要更多的内存。

另一种访问扩展内存（超出第 1 MB 的内存可见部分）的技术以[eXtended Memory Specification (XMS)](https://zh.wikipedia.org/wiki/扩展内存)的形式出现。

XMS 的理念是提供一个实模式应用程序可以使用的 API，用于分配扩展内存块的块并通过显式调用复制数据。这与 EMS 不同，因为我们不是在谈论地址空间中引用某些外部内存的固定窗口：我们在谈论一个能够分配任意内存块并返回对它们的引用的 API，就像`malloc`和`free`所做的那样。然后，应用程序使用额外的 API 将这些扩展内存块中的内存复制到传统内存中。

用 XMS 将一个扩展内存块复制到传统内存中的 80286 内存映射的表示。

为了实现[XMS API](http://www.phatcode.net/res/219/files/xms30.txt)，诸如`HIMEM.SYS`之类的驱动程序使用保护模式来操纵扩展内存块，但实模式应用程序永远不必这样做。由于 XMS 需要保护模式，因此该功能仅适用于 80286 及以上处理器，而 EMS 则可以由 8086 在有正确硬件支持的情况下使用。

就像 EMS 一样，XMS 提供了理论上从实模式访问无限扩展内存的能力，但要手动将其小片段转移到有限的 1MB 地址空间中。这并不是一个微不足道的困难，这就是为什么即使像[Cell 处理器](https://en.wikipedia.org/wiki/Cell_(processor))及其[特殊处理元素(SPEs)](https://en.wikipedia.org/wiki/Cell_(processor)#Synergistic_Processing_Elements_(SPE))这样的现代架构，即使有单独且有限的地址空间，也无法成功的原因。

到目前为止还不错，但是……我们仍然可以从实模式分段地址空间中挤出一些额外的内存。特别是，我们仍然有一些上部内存中的空隙没有得到利用。

为了实现进一步的改进，我们需要 80386 所带来的额外处理器功能。与 80286 相比，80386 是一个能够寻址高达 4GB RAM 的 32 位处理器。然而，更有趣的是，80386 增加了分页机制——这是任何现代操作系统的基础——还有一个被称为*[虚拟 8086](https://en.wikipedia.org/wiki/Virtual_8086_mode)*或称为 VM86 的新执行模式。

最初，VM86 的设想是为了解决 80286 的一个主要缺陷：即在受保护模式操作系统中运行*多个*并发的实模式应用程序的能力，因为这正是 Windows 和 OS/2 想要提供的。在今天的术语中，VM86 充当着虚拟机监控程序，为处理器提供了一种进入行为类似于实模式但由受保护模式内存管理单元支持的模式的机制。所有内存访问都经过分页翻译，所有特权操作都陷入受保护模式，这意味着虚拟机监控程序可以在 4GB 内存地址空间中的任何位置放置 VM86 任务， 并且可以在它们之间进行上下文切换。

但是，如果我们的虚拟机监控程序只生成一个 VM86 任务来运行 DOS 呢？那么，虚拟机监控程序可以利用内存管理单元将实模式地址空间的部分重新定位到扩展内存的部分吗？这样，我们就可以在没有专用硬件的情况下模拟 EMS，为应用程序提供一个通过 64 KB 窗口轻松查看扩展内存的方法，或者我们可以使用其他技巧……比如 UMBs。

还记得稀疏的上部内存区域吗？那 384KB 被硬件设备所占用却有间隙的内存？如果我们能够将上部内存中的这些间隙映射到一些扩展内存中，这样就可以直接从实模式中寻址。这正是[上部内存块(UMBs)](https://en.wikipedia.org/wiki/Upper_memory_area)的本质：将上部内存区域的部分重新映射到扩展内存中，通过 VM86 为实模式提供更多内存的透明访问。

举例来说，想象一下原始 PC 规范中的视频内存映射。内存映射为视频保留了地址空间的两个块：一个用于单色显示，一个用于彩色显示。但在任何给定时间只能使用其中一个。因此，无论选择哪种视频模式，另一模式的地址空间都会闲置，因此系统可以将此类地址空间用作 UMB，用于加载驱动程序或放置用户数据。

表示具有两个 UMBs 的 80386 VM86 内存映射，在 MMU 及其分页功能的帮助下，将上部内存映射到扩展内存。

在 DOS 中，`EMM386.EXE` 驱动程序负责提供 UMBs。原则上，芯片组也可以在较早的处理器中实现它们，但是 80386 通过进入 VM86，并利用分页将扩展内存的页面映射到上部内存区域，使这一切成为可能。

当 UMBs 可用时，DOS 通过在 `CONFIG.SYS` 文件中指定 `DOS=UMB`，然后使用 `DEVICEHIGH` 和 `LOADHIGH` 命令，提供了将加载驱动程序和 [TSR 程序](https://en.wikipedia.org/wiki/Terminate-and-stay-resident_program) 移动到 UMBs 中的方法。

总之，我们已经看到随着时间的推移，演变出了四种不同的技术，以从 8086 的极其有限的 1 MB 地址空间中挤取最大的内存。这些限制困扰着 PC 生态系统，直到 Windows 接管，并且可以认为 Windows “胜利” 是因为它使利用 80386 的更大地址空间变得更容易。然而，直到发生这种情况之前，用户不得不忍受 EMS、XMS、HMA 和 UMB 的混乱。

而且，这确实是一团糟，而且它是如此普遍，以至于泄漏给用户。让我们来看看 `MEM` 命令的输出，这是一个非常常见的实用程序，在尝试最大化自由常规内存时运行。在最简单的形式下，`MEM /C`，该命令显示每个程序的内存使用情况摘要，以及它们是加载在常规内存还是上部内存中：

输出 `MEM /C /P` 命令的第一页。

`MEM /D`，我以前不知道的，更有趣。由于控制台大小限制，我必须将其输出显示为三个单独的图像：

输出 `MEM /D /P` 命令的第一页。

输出 `MEM /D /P` 命令的第二页。

输出 `MEM /D /P` 命令的第三页。

`MEM /D` 显示了机器的内存映射以及有关每个程序位置的详细信息。我们还可以看到有关常规与上部地址空间的提及，HMA 是否在使用中以及 XMS 内存的消耗。

但在所有这些输出中，我们看到上部内存根本没有被使用。为什么呢？嗯，因为原装的 MS-DOS 并不尝试将驱动程序加载到其中。为此，我们必须手动修改 `CONFIG.SYS` 和 `AUTOEXEC.BAT`，使用特殊命令并重新排列条目，以最大化上部内存和 HMA 的使用。这是一门黑色的艺术。

这就把我带到了 MemMaker，一个随 MS-DOS 6 一起推出的工具。这个工具试图自动重新配置启动时加载的所有驱动程序和 TSR，以使其中最大部分/大多数适合于上层内存，为应用程序使用留下尽可能多的传统内存。

MemMaker 实用程序的欢迎页面。

尽管它是自动化的，但我要说 MemMaker 只适合专家使用。看看它的高级配置选项页面，我不得不摆弄这些选项，使工具能在运行 MS-DOS 6.22 的 KVM 虚拟机中工作。你真的需要了解实模式内存管理的复杂细节，才能知道每个选项的含义。

MemMaker 实用程序的高级选项。

但如果你成功运行了 MemMaker，它将在重新启动后向你展示一个相当酷的页面。这个页面展示了 MemMaker 所做的更改的详细情况，以及它是如何重新获取传统内存的。

MemMaker 实用程序所做的更改的最终报告。

之后，我们可以看看 MemMaker 应用到 `CONFIG.SYS` 和 `AUTOEXEC.BAT` 文件的更改。我从来没有真正理解所有这些魔法数字的含义，但现在经过了研究和写作这篇文章的麻烦之后，我终于明白了。就在我经常使用 MemMaker 来能在我的多媒体 80386 中玩游戏的 30 年后。

MemMaker 完成更改后 `CONFIG.SYS` 和 `AUTOEXEC.BAT` 文件的内容。

你可以在微软自己的现已存档的[KB-Q9555 文章](https://jeffpar.github.io/kbarchive/kb/095/Q95555/)或者[DOS Beyond 640KB 书籍](https://archive.org/details/DOS_Beyond_640K_2nd_edition)中阅读更多内容。

今天就到这里吧，朋友们。我特意**没有**触及 DPMI——这项技术真正使得 DOS 应用程序摆脱了 1 MB 内存限制——因为我打算留到下一篇文章再详细讲。所以，请务必再回来查看更多内容！
