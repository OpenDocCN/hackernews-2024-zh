- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:39:18'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Soft Deletion Probably Isn't Worth It
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://brandur.org/soft-deletion](https://brandur.org/soft-deletion)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Anyone who’s seen a couple different production database environments is likely
    familiar with the “soft deletion” pattern – instead of deleting data directly
    via `DELETE` statement, tables get an extra `deleted_at` timestamp and deletion
    is performed with an update statement instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The concept behind soft deletion is to make deletion safer, and reversible.
    Once a record’s been hit by a hard `DELETE`, it may technically still be recoverable
    by digging down into the storage layer, but suffice it to say that it’s really
    hard to get back. Theoretically with soft deletion, you just set `deleted_at`
    back to `NULL` and you’re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But this technique has some major downsides. The first is that soft deletion
    logic bleeds out into all parts of your code. All our selects look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And forgetting that extra predicate on `deleted_at` can have dangerous consequences
    as it accidentally returns data that’s no longer meant to be seen.
  prefs: []
  type: TYPE_NORMAL
- en: Some ORMs or ORM plugins make this easier by automatically chaining the extra
    `deleted_at` clause onto every query (see [`acts_as_paranoid`](https://github.com/ActsAsParanoid/acts_as_paranoid)
    for example), but just because it’s hidden doesn’t necessarily make things better.
    If an operator ever queries the database directly they’re even more likely to
    forget `deleted_at` because normally the ORM does the work for them.
  prefs: []
  type: TYPE_NORMAL
- en: Another consequence of soft deletion is that foreign keys are effectively lost.
  prefs: []
  type: TYPE_NORMAL
- en: The major benefit of foreign keys is that they guarantee referential integrity.
    For example, say you have customers in one table that may refer to a number of
    invoices in another. Without foreign keys, you could delete a customer, but forget
    to remove its invoices, thereby leaving a bunch of orphaned invoices that reference
    a customer that’s gone.
  prefs: []
  type: TYPE_NORMAL
- en: 'With foreign keys, trying to remove that customer without removing the invoices
    first is an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As with other relational database features like predefined schemas, types, and
    check constraints, the database is helping to keep data valid.
  prefs: []
  type: TYPE_NORMAL
- en: But with soft deletion, this goes out the window. A customer may be soft deleted
    with its `deleted_at` flag set, but we’re now back to being able to forget to
    do the same for its invoices. Their foreign keys are still valid because the customer
    record is technically still there, but there’s no equivalent check that the invoices
    are also soft deleted, so you can be left with your customer being “deleted”,
    but its invoices still live.
  prefs: []
  type: TYPE_NORMAL
- en: The last few years have seen major advances in terms of consumer data protection
    like the roll out of [GDPR](https://en.wikipedia.org/wiki/General_Data_Protection_Regulation)
    in Europe. As such, it’s generally frowned upon for data to be retained infinitely,
    which by default would be the case for soft deleted rows.
  prefs: []
  type: TYPE_NORMAL
- en: So you may eventually find yourself writing a hard deletion process which looks
    at soft deleted records beyond a certain horizon and permanently deletes them
    from the database.
  prefs: []
  type: TYPE_NORMAL
- en: But the same foreign keys that soft deletion rendered mostly useless now make
    this job more difficult because a record can’t be removed without also making
    sure that all its dependencies are removed as well (`ON DELETE CASCADE` could
    do this automatically, but use of cascade is fairly dangerous and not recommended
    for higher fidelity data).
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, you can still do this in systems that support CTEs like Postgres,
    but you end up with some pretty elaborate queries. Here’s a snippet from one that
    I wrote recently which keeps all foreign keys satisfied by removing everything
    as part of a single operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The unabridged version of this is five times as long and includes a full 30
    separate tables. It’s cool that this works, but is so overly elaborate as to be
    a liability.
  prefs: []
  type: TYPE_NORMAL
- en: And even with liberal testing, this kind of query can still end up being a reliability
    problem because in case a new dependency is added in the future but an update
    to the query is forgotten, it’ll suddenly start failing after a year’s (or whatever
    the hard delete horizon is) delay.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, soft deletion is theoretically a hedge against accidental data loss.
    As a last argument against it, I’d ask you to consider, realistically, whether
    undeletion is something that’s ever actually done.
  prefs: []
  type: TYPE_NORMAL
- en: When I worked at Heroku, we used soft deletion.
  prefs: []
  type: TYPE_NORMAL
- en: When I worked at Stripe, we used soft deletion.
  prefs: []
  type: TYPE_NORMAL
- en: At my job right now, we use soft deletion.
  prefs: []
  type: TYPE_NORMAL
- en: As far as I’m aware, never *once*, in ten plus years, did anyone at any of these
    places ever actually use soft deletion to undelete something.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest reason for this is that almost always, **data deletion also has
    non-data side effects**. Calls may have been made to foreign systems to archive
    records there, objects may have been removed in blob stores, or servers spun down.
    The process can’t simply be reversed by setting `NULL` on `deleted_at` – equivalent
    undos need to exist for all those other operations too, and they rarely do.
  prefs: []
  type: TYPE_NORMAL
- en: We had a couple cases at Heroku where an important user deleted an app by accident
    and wanted to recover it. We had soft deletion, and theoretically other delete
    side effects could’ve been reversed, but we still made the call not to try because
    no one had ever done it before, and trying to do it in an emergency was exactly
    the wrong time to figure it out – we’d almost certainly get something wrong and
    leave the user in a bad state. Instead, we rolled forward by creating a new app,
    and helping them copy environment and data from the deleted app to it. So even
    where soft deletion was theoretically most useful, we still didn’t use it.
  prefs: []
  type: TYPE_NORMAL
- en: Although I’ve never seen an undelete work in practice, soft deletion wasn’t
    completely useless because we would occasionally use it to refer to deleted data
    – usually a manual process where someone wanted to see to a deleted object for
    purposes of assisting with a support ticket or trying to squash a bug.
  prefs: []
  type: TYPE_NORMAL
- en: And while I’d argue against the traditional soft deletion pattern due to the
    downsides listed above, luckily there’s a compromise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of keeping deleted data in the same tables from which it was deleted,
    there can be a new relation specifically for storing all deleted data, and with
    a flexible `jsonb` column so that it can capture the properties of any other table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A deletion then becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This does have a downside compared to `deleted_at` – the process of selecting
    columns into `jsonb` isn’t easily reversible. While it’s possible to do so, it
    would likely involve building one-off queries and manual intervention. But again,
    that might be okay – consider how often you’re really going to be trying to undelete
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique solves all the problems outlined above:'
  prefs: []
  type: TYPE_NORMAL
- en: Queries for normal, non-deleted data no longer need to include `deleted_at IS
    NULL` everywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreign keys still work. Attempting to remove a record without also getting
    its dependencies is an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hard deleting old records for regulatory requirements gets really, really easy:
    `DELETE FROM deleted_record WHERE deleted_at < now() - ''1 year''::interval`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleted data is a little harder to get at, but not by much, and is still kept
    around in case someone needs to look at it.
  prefs: []
  type: TYPE_NORMAL
