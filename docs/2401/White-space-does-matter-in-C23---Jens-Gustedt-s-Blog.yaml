- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:53:29'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: White space does matter in C23 – Jens Gustedt's Blog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://gustedt.wordpress.com/2024/01/16/white-space-does-matter-in-c23/](https://gustedt.wordpress.com/2024/01/16/white-space-does-matter-in-c23/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Usually in C identifiers are not directly followed by strings. But when `U`
    prefixed literals were introduced in C. there still were some rare clashes with
    existing code. This happened were a macro `U` that expanded to a string was used
    to add some sort of leading character sequence to a string. Prior, this usage
    was not sensible to whether or not there was a space between the two. By introducing
    the prefix the two usages (with and without space) became distinct and code changed
    its meaning or became invalid. So for this situation, space is in fact already
    significant.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, it is often assumed that in C spaces don’t contribute much to the
    interpretation of programming text, but for C23 this has become an over-simplification
    that does not reflect the situation anymore.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to problems internal to C, there is a problem of interfacing with
    C++, where some of the rules are different.
  prefs: []
  type: TYPE_NORMAL
- en: '| syntax | meaning, C23 | different meaning, C++ |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `# define X(A)` | function like macro, empty |  |'
  prefs: []
  type: TYPE_TB
- en: '| `# define X (A)` | object macro, expands to `(A)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4''7''a` | hex number with digit separators |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4 ''7''a` | number, character literal, and identifier | number, character
    literal with suffix |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4 ''7'' a` | number, character literal, and identifier |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"%" PRIx64` | valid format string for `printf` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"%"PRIx64` | valid format string for `printf` | string literal with suffix
    |'
  prefs: []
  type: TYPE_TB
- en: '| `R "(hör)"` | identifier followed by multi-byte string |  |'
  prefs: []
  type: TYPE_TB
- en: '| `R"(hör)"` | identifier followed by multi-byte string | raw multi-byte string,
    contains just `hör` |'
  prefs: []
  type: TYPE_TB
- en: '| `R "hör"` | identifier followed by multi-byte string |  |'
  prefs: []
  type: TYPE_TB
- en: '| `R"hör"` | identifier followed by multi-byte string | invalid raw string
    |'
  prefs: []
  type: TYPE_TB
- en: '| `U "hör"` | identifier, followed by multi-byte string |  |'
  prefs: []
  type: TYPE_TB
- en: '| `U"hör"` | UTF-32 string |  |'
  prefs: []
  type: TYPE_TB
- en: It would be good if there could be some coordination here between C and C++
    about such simple questions concerning lexing and the preprocessor.
  prefs: []
  type: TYPE_NORMAL
- en: Any use of identifiers that are adjacent to character and string literals should
    be discouraged; I think that such constructs should just be excluded by the syntax.
    If we want this to be diagnosed it should be before compilation phase 4, in particular
    before macro expansion. Best would be if this is diagnosed in phase 3, lexing.
  prefs: []
  type: TYPE_NORMAL
- en: Compilers and preprocessor implementations could start to warn about such possible
    collision immediately, as of today. I don’t see much of a reason to still allow
    it. Even where there are valid uses, such as for the `printf` format string macros,
    the code becomes much easier to read if these are separated from the surrounding
    format string.
  prefs: []
  type: TYPE_NORMAL
