["```\nrecord Point(int x, int y, int z) { }\n```", "```\nPoint newLoc = new Point(oldLoc.x() * 2, oldLoc.y(), oldLoc.z());\n```", "```\nrecord Point(int x, int y, int z) {\n    Point withX(int newX) { return new Point(newX, y, z); }\n    Point withY(int newY) { return new Point(x, newY, z); }\n    Point withZ(int newZ) { return new Point(x, y, newZ); }\n}\n```", "```\nPoint newLoc = oldLoc.withX(oldLoc.x()*2);\n\n// Double newLoc's y and z components\nPoint nextLoc = newLoc.withY(newLoc.y()*2)\n                      .withZ(newLoc.z()*2);\n```", "```\ne with { ... }\n```", "```\nPoint nextLoc = oldLoc with {\n    x = 0;\n};\n```", "```\nPoint finalLoc = nextLoc with { \n    x *= 2; \n    y *= 2;\n    z *= 2;\n};\n```", "```\nPoint finalLoc = nextLoc\n            with { x *= 2; }\n            with { y *= 2; }\n            with { z *= 2; };\n```", "```\nrecord Marker(Point loc, String label, Icon icon) { }\n\nMarker m = new Marker(new Point(...), ..., ...);\nMarker scaled = m with { loc = loc with { x *= 2; y *= 2; z *= 2; }};\n```", "```\nrecord Complex(double re, double im) {\n    Complex conjugate() { return this with { im = -im; }; }\n    Complex realOnly()  { return this with { im = 0; }; }\n    Complex imOnly()    { return this with { re = 0; }; }\n}\n```", "```\nDerivedRecordCreationExpression:\n  Expression with Block\n```", "```\nfinalLoc with { sideEffectingMethod(); }; // Error\n```", "```\nPoint finalLoc = nextLoc with {\n    x *= 2;\n    y *= 2;\n    z *= 2;\n};\n```", "```\nPoint finalLoc = switch (nextLoc) {\n    case Point(var x, var y, var z) -> {\n        x *= 2;\n        y *= 2;\n        z *= 2;\n        yield new Point(x, y, z);\n    }\n};\n```", "```\nrecord Rational(int num, int denom) {\n    Rational {\n        if (denom == 0)\n            throw new IllegalArgumentException(\"denom must not be zero\");\n    }\n}\n\nRational r = new Rational(3, 1);     // OK\nRational s = r with { denom = 0; };  // throws IllegalArgumentException\n```"]