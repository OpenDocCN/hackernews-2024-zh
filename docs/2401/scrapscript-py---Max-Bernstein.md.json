["```\nfact 5\n. fact =\n  | 0 -> 1\n  | n -> n * fact (n - 1) \n```", "```\nclass Tests(unittest.TestCase):\n    def test_tokenize_binary_sub_no_spaces(self) -> None:\n        self.assertEqual(tokenize(\"1-2\"), [IntLit(1), Operator(\"-\"), IntLit(2)])\n    # ...\n    def test_parse_binary_sub_returns_binop(self) -> None:\n        self.assertEqual(\n            parse([IntLit(1), Operator(\"-\"), IntLit(2)]),\n            Binop(BinopKind.SUB, Int(1), Int(2)),\n        )\n    # ...\n    def test_eval_with_binop_sub(self) -> None:\n        exp = Binop(BinopKind.SUB, Int(1), Int(2))\n        self.assertEqual(eval_exp({}, exp), Int(-1))\n    # ...\n    def test_int_sub_returns_int(self) -> None:\n        self.assertEqual(self._run(\"1 - 2\"), Int(-1)) \n```", "```\n def tokenize(x: str) -> list[str]:\n-    # TODO: Make this a proper tokenizer that handles strings with blankspace.\n-    stripped = re.sub(r\" *--[^\\n]*\", \"\", x).strip()\n-    return re.split(r\"[\\s\\n]+\", stripped) +    lexer = Lexer(x)\n+    tokens = []\n+    while lexer.has_input():\n+        tokens.append(lexer.read_one())\n+    return tokens \n```", "```\ndef eval_exp(env: Env, exp: Object) -> Object:\n    # ...\n    if isinstance(exp, Apply):\n        callee = eval_exp(env, exp.func)\n        arg = eval_exp(env, exp.arg)\n        # ...\n        if isinstance(callee.func, MatchFunction):\n            for case in callee.func.cases:\n                m = match(arg, case.pattern)\n                if m is None:\n                    continue\n                return eval_exp({**callee.env, **m}, case.body)\n            raise MatchError(\"no matching cases\")\n        # ... \n```", "```\n>>> $$[^tab]\n$$add         $$fetch       $$jsondecode  $$listlength  $$serialize\n>>> $$add \n```", "```\n$ docker images ghcr.io/tekknolagi/scrapscript\nREPOSITORY                      TAG    IMAGE ID       CREATED       SIZE\nghcr.io/tekknolagi/scrapscript  trunk  16867189d853   3 hours ago   25.5MB\n$ \n```", "```\nsome-sum-type :\n  #cowboy\n  #ron int\n  #favcolor (#green #blue #other)\n  #friend int\n  #stranger text \n```", "```\nhandler\n. handler =\n  | { path = \"/\" } -> (status 200 <| page \"you're on the index\")\n  | { path = \"/about\" } -> (status 200 <| page \"you're on the about page\")\n  | x -> (status 404 <| page \"not found\")\n. status = code -> content -> { code = code, content = content }\n. page = body -> \"<!doctype html><html><body>\" ++ body ++ \"</body></html>\" \n```", "```\ncompile =\n| {type=\"Int\", value=value} -> $$int_as_str value\n| {type=\"Var\", name=name} -> name\n| {type=\"String\", value=value} -> $$str_as_str value\n| {type=\"Binop\", op=\"++\", left=left, right=right} ->\n    -- Special case string concat\n    (compile left) ++ \"+\" ++ (compile right)\n| {type=\"Binop\", op=op, left=left, right=right} ->\n    (compile left) ++ op ++ (compile right)\n| {type=\"List\", items=items} ->\n    \"[\" ++ (join \", \" (map compile items)) ++ \"]\"\n-- ... \n```"]