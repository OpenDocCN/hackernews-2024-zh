<!--yml

类别：未分类

日期：2024-05-27 14:33:44

-->

# 为什么糟糕的科学代码胜过遵循“最佳实践”的代码

> 来源：[https://yosefk.com/blog/why-bad-scientific-code-beats-code-following-best-practices.html](https://yosefk.com/blog/why-bad-scientific-code-beats-code-following-best-practices.html)

我刚刚读了“[科学代码的低质量](http://techblog.bozho.net/?p=1423)”，该文声称，由科学家编写的代码比如果有“软件工程师”参与会更糟糕。

在一个由数学或物理背景的人主导的环境中工作了十多年，这些人对“软件工程”通常了解不多。

无论如何，最大的混乱总是由那些将自己定义为程序员的少数人造成的。我要承认，我至少也搞过几次大混乱，至今还没清理干净。还有几次大混乱，幸运的是代码最终被抛弃了，这意味着对我的雇主造成的损失仅限于浪费在我的工资上的钱，而没有对其他人的生产力造成负面影响。

我声称我大部分时候已经忏悔了。我很努力地保持事情无聊简单，过去5-6年里，我没有做过让很多人因为我那些误导人的聪明想法而怪异看我的事情。

我认识一些程序员，他们明确地*没有*忏悔过。人们看着他们觉得他们是对的，而是其他人疯了。

与此同时，“不是”程序员但更像数学家、物理学家、算法开发者、科学家等的人犯的罪主要有以下几种：

+   长函数

+   糟糕的名称（m、k、长得看不懂的名称，顺便说一句，程序员经常这样做）

+   到处访问——全局/单例，“上帝对象”等等

+   崩溃（空指针、边界错误），主要由valgrind/大规模测试缓解

+   完全不感兴趣并行性错误（几乎完全由工具缓解）

+   不愿意使用聪明程序员编写的库，包含重载运算符和模板等等

这个我能应付，你知道。如果有人让我帮忙调试什么东西，我很少会遇到问题，弄清楚这些家伙想要做什么。我是说在软件方面。在算法方面可能我不完全理解。但是他们想要传递给什么函数的变量我通常知道。

软件工程师则不然，他们的罪行属于完全不同的类别：

+   多/虚/高度上瘾的继承

+   由主要由薄包装组成的7到14个堆栈帧，其中一些是函数指针/虚函数，可能位于中断处理程序内或其他地方

+   文件散布在无数目录中

+   从地狱中使用动态结构进行查找——名称字典，其中名称在运行时由各种部分连接而成等等。

+   动态加载和其他躲避grep技术

+   一片近乎相同的名称森林，比如DriverController，ControllerManager，DriverManager，ManagerController，controlDriver等等——所有这些都互相调用

+   模板调用重载函数，声明希望在定义模板的地方可见，也许不可见

+   装饰器，元类，代码生成等等

结果是你不知道谁调用了什么或为什么，调试器在最好的情况下也只能起到一点作用，IDE和grep慢慢地死去，等等。在眼泪自由流淌之前，你真的得放弃弄清楚这个东西的想法。

当然，这是一个严重的讽刺，不是每个人都是罪人，而且，像我主要是一个“程序员”而不是“科学家”，我真诚地相信在所有之后有净正的生产率——但你明白我的意思。

科学代码能从更好的“软件工程”中受益吗？也许，但我不会相信软件工程师能带来这些好处！

简单而无忧无虑的近乎无能可能比工业强度的良好意图更好，后者为通往地狱的超级高速公路铺平道路。计算机之外的“现实世界”充满了这样的例子。

哦，还有一个真正刻薄的观察，恐怕是太真实了，不能忽略：懒惰是许多麻烦的根源。科学家有自己的科学要担忧，所以他们没有时间毫无必要地使代码复杂化。许多程序员的工作没有真正的实质性内容——工作是微不足道的——所以他们有太多的空闲时间，他们用这些时间来纠缠于“API设计”，从而产生了怪胎。

（事实上，当工作在技术和/或社交上远非微不足道时，程序员可怕的训练使他们的注意力从他们的直接职责上转移——该死的东西实际上是否在工作，易于使用，高效/便宜等等？——而不是他们宣称自己只负责神圣的API，他们继续使之复杂到难以置信的程度。与此同时，功能上，这个东西几乎不起作用。）
