- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: æœªåˆ†ç±»'
- en: 'date: 2024-05-27 14:36:38'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024-05-27 14:36:38
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: How to stop Linux threads cleanly
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å¦‚ä½•å¹²å‡€åœ°åœæ­¢ Linux çº¿ç¨‹
- en: æ¥æºï¼š[https://mazzo.li/posts/stopping-linux-threads.html](https://mazzo.li/posts/stopping-linux-threads.html)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://mazzo.li/posts/stopping-linux-threads.html](https://mazzo.li/posts/stopping-linux-threads.html)
- en: '*2024-01-07* How to stop Linux threads cleanly'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*2024-01-07* å¦‚ä½•å¹²å‡€åœ°åœæ­¢ Linux çº¿ç¨‹'
- en: Letâ€™s say youâ€™re writing a long running multi-threaded application, on Linux.
    Maybe itâ€™s a database or a server of some sort. Letâ€™s also imagine that youâ€™re
    not running on some managed runtime (maybe the JVM, Go, or BEAM), but rather managing
    threads spawned using the [`clone`](https://man7.org/linux/man-pages/man2/clone.2.html)
    syscall. Think of threads created in C with [`pthread_create`](https://man7.org/linux/man-pages/man3/pthread_create.3.html),
    or using C++â€™s [`std::thread`](https://en.cppreference.com/w/cpp/thread/thread/thread).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ æ­£åœ¨ç¼–å†™ä¸€ä¸ªé•¿æ—¶é—´è¿è¡Œçš„å¤šçº¿ç¨‹åº”ç”¨ç¨‹åºï¼Œåœ¨ Linux ä¸Šã€‚ä¹Ÿè®¸å®ƒæ˜¯ä¸€ä¸ªæ•°æ®åº“æˆ–æŸç§æœåŠ¡å™¨ã€‚è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹ï¼Œä½ ä¸æ˜¯åœ¨ä¸€äº›å—æ§è¿è¡Œæ—¶ï¼ˆä¹Ÿè®¸æ˜¯ JVMã€Go
    æˆ– BEAMï¼‰ä¸Šè¿è¡Œï¼Œè€Œæ˜¯ç®¡ç†ä½¿ç”¨ [`clone`](https://man7.org/linux/man-pages/man2/clone.2.html)
    ç³»ç»Ÿè°ƒç”¨äº§ç”Ÿçš„çº¿ç¨‹ã€‚æƒ³è±¡ä¸€ä¸‹ç”¨ C åˆ›å»ºçš„çº¿ç¨‹ï¼Œä½¿ç”¨ [`pthread_create`](https://man7.org/linux/man-pages/man3/pthread_create.3.html)ï¼Œæˆ–è€…ä½¿ç”¨
    C++ çš„ [`std::thread`](https://en.cppreference.com/w/cpp/thread/thread/thread)ã€‚
- en: Once you get into the business of starting threads, youâ€™re probably also in
    the business of stopping them. However the former is much easier than the latter.
    With â€œstoppingâ€ I mean stopping the thread while giving it a chance to run some
    cleanup operations before fully terminating. Or in other words, we want to terminate
    a thread while ensuring that memory is freed, locks are released, logs are flushed,
    and so on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦ä½ å¼€å§‹åˆ›å»ºçº¿ç¨‹ï¼Œä½ å¯èƒ½ä¹Ÿè¦åœæ­¢å®ƒä»¬ã€‚ä½†å‰è€…æ¯”åè€…è¦å®¹æ˜“å¾—å¤šã€‚æ‰€è°“çš„â€œåœæ­¢â€ï¼Œæ˜¯æŒ‡åœ¨å®Œå…¨ç»ˆæ­¢ä¹‹å‰ç»™çº¿ç¨‹ä¸€ä¸ªè¿è¡Œä¸€äº›æ¸…ç†æ“ä½œçš„æœºä¼šã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ç¡®ä¿é‡Šæ”¾å†…å­˜ã€é‡Šæ”¾é”ã€åˆ·æ–°æ—¥å¿—ç­‰çš„æƒ…å†µä¸‹ç»ˆæ­¢çº¿ç¨‹ã€‚
- en: This task is sadly not as straightforward as it should be, and there definitely
    isnâ€™t a one-size-fits-all solution. This blog post aims to give an overview of
    the problem space and to highlight some pitfalls in an area with no shortage,
    and present [a little magic trick at the end.](#rseq)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä»»åŠ¡é—æ†¾åœ°å¹¶ä¸åƒåº”è¯¥çš„é‚£æ ·ç®€å•ï¼Œä¹Ÿç»å¯¹æ²¡æœ‰ä¸€ç§å¤§å°é€‚åˆæ‰€æœ‰çš„è§£å†³æ–¹æ¡ˆã€‚æœ¬æ–‡æ—¨åœ¨æ¦‚è¿°é—®é¢˜ç©ºé—´ï¼Œå¹¶å¼ºè°ƒä¸€äº›æ²¡æœ‰çŸ­ç¼ºçš„é™·é˜±ï¼Œå¹¶åœ¨æœ€åå±•ç¤ºä¸€ç‚¹[å°é­”æœ¯æŠ€å·§ã€‚](#rseq)
- en: (Quasi-)busy looping [#](#quasi-busy-looping)
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: (å‡†)å¿™ç­‰å¾… [#](#quasi-busy-looping)
- en: 'If you can afford it, you can structure each thread as such:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è´Ÿæ‹…å¾—èµ·çš„è¯ï¼Œå¯ä»¥å°†æ¯ä¸ªçº¿ç¨‹ç»“æ„åŒ–å¦‚ä¸‹ï¼š
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`stop` here is a per-thread boolean. When we want to stop a thread, we set
    `stop` to `true`, and then call [`pthread_join`](https://man7.org/linux/man-pages/man3/pthread_join.3.html)
    or equivalents to ensure that the thread has actually terminated.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop` åœ¨è¿™é‡Œæ˜¯ä¸€ä¸ªæ¯ä¸ªçº¿ç¨‹çš„å¸ƒå°”å€¼ã€‚å½“æˆ‘ä»¬æƒ³è¦åœæ­¢ä¸€ä¸ªçº¿ç¨‹æ—¶ï¼Œæˆ‘ä»¬å°† `stop` è®¾ç½®ä¸º `true`ï¼Œç„¶åè°ƒç”¨ [`pthread_join`](https://man7.org/linux/man-pages/man3/pthread_join.3.html)
    æˆ–å…¶ç­‰ä»·ç‰©ä»¥ç¡®ä¿çº¿ç¨‹å®é™…ä¸Šå·²ç»ç»ˆæ­¢ã€‚'
- en: 'Hereâ€™s a contrived but working example in C++:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä¸€ä¸ªè™šæ„ä½†å¯è¡Œçš„ C++ ç¤ºä¾‹ï¼š
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Which prints:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: è¾“å‡ºï¼š
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you can write or refactor your code to work in such time slices, then terminating
    threads is very easy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å¯ä»¥ç¼–å†™æˆ–é‡æ„ä½ çš„ä»£ç ä»¥åœ¨è¿™æ ·çš„æ—¶é—´ç‰‡æ®µå†…å·¥ä½œï¼Œé‚£ä¹ˆç»ˆæ­¢çº¿ç¨‹å°±éå¸¸å®¹æ˜“ã€‚
- en: Note that the loop body does not need to be fully non blocking â€“ it just needs
    to be terminated as quickly as we want our termination to be quick. For instance,
    if our thread is reading from a socket, we could set `SO_TIMEOUT` to be 100 milliseconds
    so that we know that every iteration of the loop will terminate quickly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œå¾ªç¯ä½“ä¸éœ€è¦å®Œå…¨éé˜»å¡â€”â€”å®ƒåªéœ€è¦åœ¨æˆ‘ä»¬å¸Œæœ›ç»ˆæ­¢è¿…é€Ÿçš„æ—¶é—´å†…è¢«ç»ˆæ­¢ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬çš„çº¿ç¨‹æ­£åœ¨ä»å¥—æ¥å­—è¯»å–æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥å°† `SO_TIMEOUT`
    è®¾ç½®ä¸º 100 æ¯«ç§’ï¼Œè¿™æ ·æˆ‘ä»¬å°±çŸ¥é“å¾ªç¯çš„æ¯æ¬¡è¿­ä»£éƒ½ä¼šè¿…é€Ÿç»ˆæ­¢ã€‚
- en: What if I want to block forever? [#](#what-if-i-want-to-block-forever)
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘æƒ³æ°¸ä¹…é˜»å¡æ€ä¹ˆåŠï¼Ÿ[#](#what-if-i-want-to-block-forever)
- en: Quasi-busy loops are all well and good, but theyâ€™re sometimes not desirable.
    The most common roadblock is foreign code that we donâ€™t control which does not
    fit this pattern â€“ think of a third-party library doing some blocking network
    call.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: å‡†å¿™ç­‰å¾…å¾ˆå¥½ï¼Œä½†æœ‰æ—¶å¹¶ä¸ç†æƒ³ã€‚æœ€å¸¸è§çš„éšœç¢æ˜¯æˆ‘ä»¬æ— æ³•æ§åˆ¶çš„å¤–éƒ¨ä»£ç ï¼Œå®ƒä¸ç¬¦åˆè¿™ç§æ¨¡å¼â€”â€”æ¯”å¦‚ä¸€ä¸ªè¿›è¡Œé˜»å¡ç½‘ç»œè°ƒç”¨çš„ç¬¬ä¸‰æ–¹åº“ã€‚
- en: As weâ€™ll see later, thereâ€™s essentially no clean way to stop a thread running
    code we donâ€™t control, but there are other reasons to not want to write all our
    code with the quasi-busy loop pattern.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬å°†åœ¨åé¢çœ‹åˆ°çš„ï¼Œæ²¡æœ‰å¹²å‡€çš„æ–¹å¼æ¥åœæ­¢ä¸€ä¸ªè¿è¡Œæˆ‘ä»¬æ— æ³•æ§åˆ¶ä»£ç çš„çº¿ç¨‹ï¼Œä½†è¿˜æœ‰å…¶ä»–åŸå› ä¸æƒ³è¦ä»¥å‡†å¿™ç­‰å¾…æ¨¡å¼ç¼–å†™æ‰€æœ‰ä»£ç ã€‚
- en: If we have many threads even relatively slow timeouts might cause significant
    scheduling overhead due to spurious wakeups, especially on an already busy system.
    The timeouts will also make debugging and inspecting the system considerably more
    annoying (e.g.Â imagine what the output of `strace` would look like).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æœ‰å¾ˆå¤šçº¿ç¨‹ï¼Œå³ä½¿ç›¸å¯¹è¾ƒæ…¢çš„è¶…æ—¶ä¹Ÿå¯èƒ½å› ä¸ºè™šå‡å”¤é†’è€Œå¯¼è‡´æ˜¾è‘—çš„è°ƒåº¦å¼€é”€ï¼Œç‰¹åˆ«æ˜¯åœ¨å·²ç»ç¹å¿™çš„ç³»ç»Ÿä¸Šã€‚è¶…æ—¶è¿˜å°†ä½¿è°ƒè¯•å’Œæ£€æŸ¥ç³»ç»Ÿå˜å¾—ç›¸å½“éº»çƒ¦ï¼ˆä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸‹`strace`çš„è¾“å‡ºä¼šæ˜¯ä»€ä¹ˆæ ·å­ï¼‰ã€‚
- en: So it is worth thinking about how to stop a thread while it is blocked on a
    syscall. The most straightforward way to do that is through signals.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå€¼å¾—è€ƒè™‘å¦‚ä½•åœ¨çº¿ç¨‹åœ¨ç³»ç»Ÿè°ƒç”¨æ—¶è¢«é˜»å¡æ—¶åœæ­¢çº¿ç¨‹ã€‚æœ€ç›´æ¥çš„æ–¹æ³•æ˜¯é€šè¿‡ä¿¡å·ã€‚
- en: We need to talk about signals [#](#we-need-to-talk-about-signals)
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦è®¨è®ºä¿¡å· [#](#we-need-to-talk-about-signals)
- en: Signals are the main way to interrupt execution of a thread without explicit
    coordination of the interrupted thread, and are therefore very relevant to the
    topic of this blog post. Theyâ€™re also a bit of a mess. These two facts generate
    unhappiness.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ä¿¡å·æ˜¯ä¸­æ–­çº¿ç¨‹æ‰§è¡Œè€Œæ— éœ€æ˜¾å¼åè°ƒä¸­æ–­çº¿ç¨‹çš„ä¸»è¦æ–¹å¼ï¼Œå› æ­¤ä¸æœ¬åšå®¢æ–‡ç« çš„ä¸»é¢˜éå¸¸ç›¸å…³ã€‚å®ƒä»¬ä¹Ÿæœ‰ç‚¹æ··ä¹±ã€‚è¿™ä¸¤ä¸ªäº‹å®å¼•å‘äº†ä¸å¿«ã€‚
- en: For a good overview on signals I recommend the surprisingly informative [man
    page](https://man7.org/linux/man-pages/man7/signal.7.html), but Iâ€™ll give a sufficient
    overview here. If you already know how signals work, you can skip to [the next
    section](#thread-cancellation).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºä¿¡å·çš„è‰¯å¥½æ¦‚è¿°ï¼Œæˆ‘æ¨èå‡ºä¹æ„æ–™çš„ä¿¡æ¯ä¸°å¯Œçš„[mané¡µé¢](https://man7.org/linux/man-pages/man7/signal.7.html)ï¼Œä½†æˆ‘ä¼šåœ¨è¿™é‡Œç»™å‡ºè¶³å¤Ÿçš„æ¦‚è¿°ã€‚å¦‚æœæ‚¨å·²ç»äº†è§£ä¿¡å·çš„å·¥ä½œåŸç†ï¼Œå¯ä»¥è·³è½¬åˆ°[ä¸‹ä¸€èŠ‚](#thread-cancellation)ã€‚
- en: Signals can arise because of some hardware exception or be initiated by software.
    The most familiar instance of a software-initiated signal is your shell sending
    SIGINT to the foreground process when you press `ctrl-c`. All signals initiated
    by software originate from a handful of syscalls â€“ for instance [`pthread_kill`](https://man7.org/linux/man-pages/man3/pthread_kill.3.html)
    will send a signal to a thread.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ä¿¡å·å¯ä»¥ç”±æŸäº›ç¡¬ä»¶å¼‚å¸¸å¼•å‘ï¼Œä¹Ÿå¯ä»¥ç”±è½¯ä»¶å‘èµ·ã€‚æœ€ç†Ÿæ‚‰çš„è½¯ä»¶å‘èµ·ä¿¡å·çš„å®ä¾‹æ˜¯å½“æ‚¨æŒ‰ä¸‹`ctrl-c`æ—¶ï¼Œæ‚¨çš„shellå‘å‰å°è¿›ç¨‹å‘é€SIGINTã€‚æ‰€æœ‰ç”±è½¯ä»¶å‘èµ·çš„ä¿¡å·éƒ½æºè‡ªäºå°‘æ•°å‡ ä¸ªç³»ç»Ÿè°ƒç”¨
    - ä¾‹å¦‚[`pthread_kill`](https://man7.org/linux/man-pages/man3/pthread_kill.3.html)ä¼šå‘çº¿ç¨‹å‘é€ä¸€ä¸ªä¿¡å·ã€‚
- en: 'Hardware initiated signals are generally handled immediately, while software
    initiated signals are handled when a CPU is about to re-enter user mode after
    the kernel has done some work. In any event, when a signal needs to handled in
    a given thread:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ç¡¬ä»¶å‘èµ·çš„ä¿¡å·é€šå¸¸ä¼šç«‹å³å¤„ç†ï¼Œè€Œè½¯ä»¶å‘èµ·çš„ä¿¡å·ä¼šåœ¨ CPU åœ¨å†…æ ¸å®Œæˆä¸€äº›å·¥ä½œåå³å°†é‡æ–°è¿›å…¥ç”¨æˆ·æ¨¡å¼æ—¶å¤„ç†ã€‚æ— è®ºå¦‚ä½•ï¼Œå½“ä¸€ä¸ªä¿¡å·éœ€è¦åœ¨ç»™å®šçš„çº¿ç¨‹ä¸­å¤„ç†æ—¶ï¼š
- en: If the signal has been blocked by the receiving thread, itâ€™ll wait to be handled
    until it is unblocked;
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¦‚æœä¿¡å·è¢«æ¥æ”¶çº¿ç¨‹é˜»å¡ï¼Œå®ƒå°†ç­‰å¾…å¤„ç†ç›´åˆ°è¢«è§£é™¤é˜»å¡ï¼›
- en: 'If the signal is not blocked, it might be:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¦‚æœä¿¡å·æ²¡æœ‰è¢«é˜»å¡ï¼Œå®ƒå¯èƒ½ä¼šï¼š
- en: ignored;
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¿½ç•¥ï¼›
- en: handled in the â€œdefaultâ€ manner;
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»¥â€œé»˜è®¤â€æ–¹å¼å¤„ç†ï¼›
- en: handled using some custom signal handler.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ä¸€äº›è‡ªå®šä¹‰çš„ä¿¡å·å¤„ç†å™¨è¿›è¡Œå¤„ç†ã€‚
- en: Which signals are blocked is controlled by modifying the *signal mask* using
    [`sigprocmask`](https://man7.org/linux/man-pages/man2/sigprocmask.2.html)/[`pthread_sigmask`](https://man7.org/linux/man-pages/man3/pthread_sigmask.3.html),
    and which action is taken if the thread is not blocked is controlled by [`sigaction`](https://man7.org/linux/man-pages/man2/sigaction.2.html).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å“ªäº›ä¿¡å·è¢«é˜»å¡ç”±ä¿®æ”¹*ä¿¡å·æ©ç *æ¥æ§åˆ¶ï¼Œä½¿ç”¨[`sigprocmask`](https://man7.org/linux/man-pages/man2/sigprocmask.2.html)/[`pthread_sigmask`](https://man7.org/linux/man-pages/man3/pthread_sigmask.3.html)ï¼Œå¦‚æœçº¿ç¨‹æ²¡æœ‰è¢«é˜»å¡ï¼Œåˆ™é‡‡å–çš„æ“ä½œç”±[`sigaction`](https://man7.org/linux/man-pages/man2/sigaction.2.html)æ¥æ§åˆ¶ã€‚
- en: Assuming that the signal is *not* blocked, paths 2.a and 2.b will be managed
    entirely by the kernel, while path 2.c will cause the kernel to pass control to
    a user-space signal handler which will do something with the signal.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ä¿¡å·*æ²¡æœ‰*è¢«é˜»å¡ï¼Œè·¯å¾„ 2.a å’Œ 2.b å°†å®Œå…¨ç”±å†…æ ¸ç®¡ç†ï¼Œè€Œè·¯å¾„ 2.c å°†å¯¼è‡´å†…æ ¸å°†æ§åˆ¶æƒä¼ é€’ç»™ç”¨æˆ·ç©ºé—´ä¿¡å·å¤„ç†ç¨‹åºï¼Œè¯¥å¤„ç†ç¨‹åºå°†å¯¹ä¿¡å·æ‰§è¡ŒæŸäº›æ“ä½œã€‚
- en: Importantly, if some thread is in a syscall (for instance blocked while reading
    from a socket), and a signal needs to be handled, the syscall will return early
    with error code `EINTR` after the signal handler has run.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦çš„æ˜¯ï¼Œå¦‚æœæŸä¸ªçº¿ç¨‹åœ¨ç³»ç»Ÿè°ƒç”¨ä¸­ï¼ˆä¾‹å¦‚åœ¨ä»å¥—æ¥å­—ä¸­è¯»å–æ—¶è¢«é˜»å¡ï¼‰ï¼Œå¹¶ä¸”éœ€è¦å¤„ç†ä¿¡å·ï¼Œåˆ™åœ¨ä¿¡å·å¤„ç†ç¨‹åºè¿è¡Œåï¼Œç³»ç»Ÿè°ƒç”¨å°†æå‰è¿”å›é”™è¯¯ä»£ç `EINTR`ã€‚
- en: The signal handler code is subject [to various constraints](https://man7.org/linux/man-pages/man7/signal-safety.7.html),
    but otherwise it can do as it pleases, including deciding to not give back control
    to the code that was executing before. By default, most signals just cause the
    program to stop abruptly, possibly with a core dump. In the next few sections
    weâ€™re going to explore various ways to use signals to stop our threads.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ä¿¡å·å¤„ç†ç¨‹åºä»£ç å—[å„ç§çº¦æŸ](https://man7.org/linux/man-pages/man7/signal-safety.7.html)çº¦æŸï¼Œä½†é™¤æ­¤ä¹‹å¤–ï¼Œå®ƒå¯ä»¥éšæ„æ“ä½œï¼ŒåŒ…æ‹¬å†³å®šä¸å°†æ§åˆ¶æƒè¿”å›ç»™æ‰§è¡Œä¹‹å‰çš„ä»£ç ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå¤§å¤šæ•°ä¿¡å·åªä¼šå¯¼è‡´ç¨‹åºçªç„¶åœæ­¢ï¼Œå¯èƒ½ä¼šå‡ºç°æ ¸å¿ƒè½¬å‚¨ã€‚åœ¨æ¥ä¸‹æ¥çš„å‡ èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨ä½¿ç”¨ä¿¡å·åœæ­¢çº¿ç¨‹çš„å„ç§æ–¹æ³•ã€‚
- en: Thread cancellation, a false hope [#](#thread-cancellation)
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: çº¿ç¨‹å–æ¶ˆï¼Œä¸€ä¸ªè™šå‡çš„å¸Œæœ› [#](#thread-cancellation)
- en: 'Letâ€™s first examine a way to stop threads, implemented through signals, which
    would seem to do exactly what we want: thread cancellation.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é¦–å…ˆæ£€æŸ¥ä¸€ç§é€šè¿‡ä¿¡å·å®ç°çš„åœæ­¢çº¿ç¨‹çš„æ–¹æ³•ï¼Œè¿™ä¼¼ä¹æ­£æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼šçº¿ç¨‹å–æ¶ˆã€‚
- en: 'The API for thread cancellation is very promising. [`pthread_cancel(tid)`](https://man7.org/linux/man-pages/man3/pthread_cancel.3.html)
    will â€œcancelâ€ thread `tid`. The way `pthread_cancel` works boils down to:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: çº¿ç¨‹å–æ¶ˆçš„APIéå¸¸æœ‰å‰é€”ã€‚[`pthread_cancel(tid)`](https://man7.org/linux/man-pages/man3/pthread_cancel.3.html)ä¼šâ€œå–æ¶ˆâ€çº¿ç¨‹`tid`ã€‚`pthread_cancel`çš„å·¥ä½œæ–¹å¼å½’ç»“ä¸ºï¼š
- en: A special signal is sent to thread `tid`;
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç‰¹æ®Šçš„ä¿¡å·è¢«å‘é€åˆ°çº¿ç¨‹`tid`ï¼›
- en: The libc youâ€™re using (say [glibc](https://en.wikipedia.org/wiki/Glibc) or [musl](https://en.wikipedia.org/wiki/Musl))
    sets up a handler so that when the cancel signal is received the thread winds
    down.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½ æ­£åœ¨ä½¿ç”¨çš„libcï¼ˆæ¯”å¦‚[glibc](https://en.wikipedia.org/wiki/Glibc)æˆ–[musl](https://en.wikipedia.org/wiki/Musl)ï¼‰è®¾ç½®äº†ä¸€ä¸ªå¤„ç†ç¨‹åºï¼Œä»¥ä¾¿åœ¨æ¥æ”¶åˆ°å–æ¶ˆä¿¡å·æ—¶çº¿ç¨‹ä¼šåœæ­¢ã€‚
- en: There are additional details, but thatâ€™s essentially all there is to it. However,
    trouble lies ahead.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰å…¶ä»–ç»†èŠ‚ï¼Œä½†åŸºæœ¬ä¸Šå°±æ˜¯è¿™æ ·äº†ã€‚ç„¶è€Œï¼Œå›°éš¾åœ¨å‰æ–¹ã€‚
- en: Resource management + thread cancellation = ğŸ˜¢ [#](#resource-management-thread-cancellation)
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: èµ„æºç®¡ç† + çº¿ç¨‹å–æ¶ˆ = ğŸ˜¢ [#](#resource-management-thread-cancellation)
- en: Recall that signals can essentially arise anywhere in your code. So if we have
    code such as
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·è®°ä½ï¼Œä¿¡å·å®è´¨ä¸Šå¯ä»¥åœ¨æ‚¨çš„ä»£ç çš„ä»»ä½•åœ°æ–¹å‡ºç°ã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬æœ‰è¿™æ ·çš„ä»£ç 
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: we might get a signal in the critical section. In the case of thread cancellation,
    our thread might get cancelled while weâ€™re holding a lock as above, or with some
    memory to be freed, or in general with some outstanding resource, and our cleanup
    code will never run. This is not good.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½åœ¨å…³é”®éƒ¨åˆ†æ”¶åˆ°ä¸€ä¸ªä¿¡å·ã€‚åœ¨çº¿ç¨‹å–æ¶ˆçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„çº¿ç¨‹å¯èƒ½åœ¨æˆ‘ä»¬æŒæœ‰é”çš„æƒ…å†µä¸‹è¢«å–æ¶ˆï¼Œæˆ–è€…æœ‰ä¸€äº›è¦é‡Šæ”¾çš„å†…å­˜ï¼Œæˆ–è€…æ€»ä¹‹æœ‰ä¸€äº›æœªå®Œæˆçš„èµ„æºï¼Œå¹¶ä¸”æˆ‘ä»¬çš„æ¸…ç†ä»£ç æ°¸è¿œä¸ä¼šè¿è¡Œã€‚è¿™ä¸å¥½ã€‚
- en: 'There are some mitigating circumstances, although none sufficient:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶æœ‰ä¸€äº›ç¼“è§£æƒ…å†µï¼Œä½†éƒ½ä¸è¶³å¤Ÿï¼š
- en: Thread cancellation can be temporarily disabled. So we could disable it any
    time we are in such a critical section.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: çº¿ç¨‹å–æ¶ˆå¯ä»¥è¢«æš‚æ—¶ç¦ç”¨ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨ä»»ä½•æ—¶å€™ç¦ç”¨å®ƒå½“æˆ‘ä»¬å¤„äºè¿™æ ·ä¸€ä¸ªå…³é”®éƒ¨åˆ†ã€‚
- en: However some â€œcritical sectionsâ€ are very long (consider the lifespan of some
    allocated memory), and moreover weâ€™d have to make sure to decorate all relevant
    code by enabling/disabling cancellation at the right time.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä¸€äº›â€œå…³é”®éƒ¨åˆ†â€éå¸¸é•¿ï¼ˆè€ƒè™‘ä¸€äº›åˆ†é…å†…å­˜çš„å¯¿å‘½ï¼‰ï¼Œè€Œä¸”æˆ‘ä»¬è¿˜å¿…é¡»ç¡®ä¿åœ¨æ­£ç¡®çš„æ—¶é—´å¯ç”¨/ç¦ç”¨å–æ¶ˆæ¥è£…é¥°æ‰€æœ‰ç›¸å…³ä»£ç ã€‚
- en: Linux threads include facilities to add/remove global cleanup handlers with
    [`pthread_cleanup_push`](https://man7.org/linux/man-pages/man3/pthread_cleanup_push.3.html)
    and `pthread_cleanup_pop`. These cleanup handlers *are* run when a thread is cancelled.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linuxçº¿ç¨‹åŒ…æ‹¬ä½¿ç”¨[`pthread_cleanup_push`](https://man7.org/linux/man-pages/man3/pthread_cleanup_push.3.html)å’Œ`pthread_cleanup_pop`æ·»åŠ /åˆ é™¤å…¨å±€æ¸…ç†å¤„ç†ç¨‹åºçš„è®¾æ–½ã€‚å½“çº¿ç¨‹è¢«å–æ¶ˆæ—¶ï¼Œè¿™äº›æ¸…ç†å¤„ç†ç¨‹åº*ä¼š*è¿è¡Œã€‚
- en: However to ensure safety using these functions one would have to again decorate
    every critical section with not only with a push/pop, but also temporarily disabling
    cancellations to avoid races as we setup the cleanup.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä¸ºäº†ç¡®ä¿ä½¿ç”¨è¿™äº›å‡½æ•°çš„å®‰å…¨æ€§ï¼Œä¸€ä¸ªäººå¿…é¡»å†æ¬¡ç”¨ä¸ä»…ä»…æ˜¯ä¸€ä¸ªæ¨/å¼¹å‡ºï¼Œè€Œä¸”è¿˜è¦æš‚æ—¶ç¦ç”¨å–æ¶ˆæ¥é¿å…ç«äº‰ï¼Œå› ä¸ºæˆ‘ä»¬è®¾ç½®äº†æ¸…ç†ã€‚
- en: Again, this would be very error prone and would slow down our code considerably.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å†æ¬¡å¼ºè°ƒï¼Œè¿™æ ·åšä¼šéå¸¸å®¹æ˜“å‡ºé”™ï¼Œå¹¶ä¸”ä¼šæ˜¾è‘—å‡æ…¢æˆ‘ä»¬çš„ä»£ç ã€‚
- en: By default the signal sent by thread cancellation is only received at â€œcancellation
    pointsâ€, which to a first approximation are the syscalls that might block â€“ see
    [`pthreads(7)`](https://man7.org/linux/man-pages/man7/pthreads.7.html).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼Œçº¿ç¨‹å–æ¶ˆå‘é€çš„ä¿¡å·åªåœ¨â€œå–æ¶ˆç‚¹â€æ¥æ”¶åˆ°ï¼Œå¤§è‡´ä¸Šæ˜¯å¯èƒ½é˜»å¡çš„ç³»ç»Ÿè°ƒç”¨ - è¯·å‚é˜…[`pthreads(7)`](https://man7.org/linux/man-pages/man7/pthreads.7.html)ã€‚
- en: So really we would only run into trouble if we have such a syscall in the critical
    sections. But again, weâ€™d have to manually ensure that either critical section
    have no cancellation points, or that theyâ€™re made safe otherwise (possibly with
    the two measures described above).
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘ä»¬åªæœ‰åœ¨å…³é”®éƒ¨åˆ†æœ‰è¿™æ ·çš„ç³»ç»Ÿè°ƒç”¨æ—¶æ‰ä¼šé‡åˆ°éº»çƒ¦ã€‚ä½†æ˜¯å†æ¬¡å¼ºè°ƒï¼Œæˆ‘ä»¬å¿…é¡»æ‰‹åŠ¨ç¡®ä¿è¦ä¹ˆå…³é”®éƒ¨åˆ†æ²¡æœ‰å–æ¶ˆç‚¹ï¼Œè¦ä¹ˆé€šè¿‡å…¶ä»–æ–¹å¼ï¼ˆå¯èƒ½æ˜¯ä¸Šè¿°ä¸¤ç§æªæ–½ä¹‹ä¸€ï¼‰ä½¿å…¶å®‰å…¨ã€‚
- en: Thread cancellation is incompatible with modern C++ [#](#thread-cancellation-is-incompatible-with-modern-c)
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: çº¿ç¨‹å–æ¶ˆä¸ç°ä»£ C++ ä¸å…¼å®¹ [#](#thread-cancellation-is-incompatible-with-modern-c)
- en: 'If youâ€™re a C++/Rust programmer, you might have sneered at the explicit locking
    above â€“ youâ€™ve got RAII to handle such cases:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æ˜¯ C++/Rust ç¨‹åºå‘˜ï¼Œä½ å¯èƒ½ä¼šå¯¹ä¸Šé¢çš„æ˜¾å¼é”å®šæ„Ÿåˆ°ä¸å±‘ä¸€é¡¾ - ä½ æœ‰ RAII æ¥å¤„ç†è¿™ç§æƒ…å†µï¼š
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You might have also been wondering what happens if a thread cancellation arrives
    in the RAII-managed critical section here.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½ä¹Ÿåœ¨æƒ³ï¼Œåœ¨è¿™é‡Œç”± RAII ç®¡ç†çš„å…³é”®éƒ¨åˆ†ä¸­å¦‚æœçº¿ç¨‹å–æ¶ˆåˆ°è¾¾ä¼šå‘ç”Ÿä»€ä¹ˆã€‚
- en: The answer is that thread cancellation will trigger a stack unwinding very much
    like throwing an exception would (in fact itâ€™s implemented with a special exception),
    which means that destructors *will* be run on cancellation. This mechanism is
    known as *forced unwinding*. Great, right?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ç­”æ¡ˆæ˜¯çº¿ç¨‹å–æ¶ˆå°†è§¦å‘ç±»ä¼¼äºæŠ›å‡ºå¼‚å¸¸çš„å †æ ˆè§£é™¤çš„æœºåˆ¶ï¼ˆå®é™…ä¸Šå®ƒæ˜¯ç”¨ä¸€ä¸ªç‰¹æ®Šçš„å¼‚å¸¸å®ç°çš„ï¼‰ï¼Œè¿™æ„å‘³ç€ææ„å‡½æ•° *å°†* åœ¨å–æ¶ˆæ—¶è¿è¡Œã€‚è¿™ç§æœºåˆ¶ç§°ä¸º *å¼ºåˆ¶è§£é™¤*ã€‚å¾ˆæ£’ï¼Œå¯¹å§ï¼Ÿ
- en: Well, since thread cancellation is implemented using exceptions, and thread
    cancellation can happen in arbitrary places, [weâ€™re always liable to a cancellation
    happening in a `noexcept` block](https://gcc.gnu.org/legacy-ml/gcc/2017-08/msg00121.html),
    which will cause your program to crash via [`std::terminate`](https://en.cppreference.com/w/cpp/error/terminate).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½å§ï¼Œç”±äºçº¿ç¨‹å–æ¶ˆæ˜¯ä½¿ç”¨å¼‚å¸¸å®ç°çš„ï¼Œå¹¶ä¸”çº¿ç¨‹å–æ¶ˆå¯èƒ½å‘ç”Ÿåœ¨ä»»æ„ä½ç½®ï¼Œ[æˆ‘ä»¬æ€»æ˜¯å¯èƒ½åœ¨ `noexcept` å—ä¸­å‘ç”Ÿå–æ¶ˆ](https://gcc.gnu.org/legacy-ml/gcc/2017-08/msg00121.html)ï¼Œè¿™å°†é€šè¿‡
    [`std::terminate`](https://en.cppreference.com/w/cpp/error/terminate) ä½¿ä½ çš„ç¨‹åºå´©æºƒã€‚
- en: So since C++11, and especially since C++14 where destructors are marked as `noexcept`
    by default, thread cancellation is essentially useless in C++.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è‡ªä» C++11ï¼Œç‰¹åˆ«æ˜¯è‡ªä» C++14 å¼€å§‹ï¼Œåœ¨ C++ ä¸­çº¿ç¨‹å–æ¶ˆåŸºæœ¬ä¸Šæ˜¯æ— ç”¨çš„ï¼Œå› ä¸ºææ„å‡½æ•°é»˜è®¤æ ‡è®°ä¸º `noexcept`ã€‚
- en: Forced unwinding is unsafe anyway [#](#forced-unwinding-is-unsafe-anyway)
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¼ºåˆ¶è§£é™¤æœ¬èº«å°±æ˜¯ä¸å®‰å…¨çš„ [#](#forced-unwinding-is-unsafe-anyway)
- en: 'However note that even if this mechanism worked in C++, itâ€™d still not be safe
    in many situations. Consider situations like:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯è¯·æ³¨æ„ï¼Œå³ä½¿åœ¨ C++ ä¸­è¿™ç§æœºåˆ¶è¿è¡Œè‰¯å¥½ï¼Œå®ƒåœ¨è®¸å¤šæƒ…å†µä¸‹ä»ç„¶ä¸å®‰å…¨ã€‚è€ƒè™‘ä»¥ä¸‹æƒ…å†µï¼š
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we get forcefully unwound after `balance_1 += x`, our invariants go out of
    the window. This is why Javaâ€™s form of forced unwinding, [`Thread.stop`](https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html),
    was deprecated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœåœ¨ `balance_1 += x` ä¹‹åå¼ºåˆ¶è§£å¼€æˆ‘ä»¬çš„ä¸å˜æ€§å°±ä¼šå¤±æ•ˆã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆ Java çš„å¼ºåˆ¶è§£å¼€å½¢å¼ [`Thread.stop`](https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html)
    è¢«åºŸå¼ƒçš„åŸå› ã€‚
- en: You canâ€™t cleanly stop threads running code you donâ€™t control [#](#you-cant-cleanly-stop-threads-running-code-you-dont-control)
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä½ æ— æ³•å¹²å‡€åœ°åœæ­¢è¿è¡Œä½ æ— æ³•æ§åˆ¶çš„ä»£ç çš„çº¿ç¨‹ [#](#you-cant-cleanly-stop-threads-running-code-you-dont-control)
- en: As a brief aside, the nature of signals (and by extension thread cancellation)
    implies that itâ€™s impossible to cleanly stop code that you donâ€™t control. You
    cannot guarantee that memory isnâ€™t leaked, files are closed, global locks are
    released, and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: é¡ºä¾¿è¯´ä¸€å¥ï¼Œä¿¡å·çš„æ€§è´¨ï¼ˆä»¥åŠç”±æ­¤å¼•ç”³å‡ºçš„çº¿ç¨‹å–æ¶ˆï¼‰æ„å‘³ç€æ— æ³•å¹²å‡€åœ°åœæ­¢ä½ æ— æ³•æ§åˆ¶çš„ä»£ç ã€‚ä½ æ— æ³•ä¿è¯å†…å­˜ä¸ä¼šæ³„æ¼ï¼Œæ–‡ä»¶è¢«å…³é—­ï¼Œå…¨å±€é”è¢«é‡Šæ”¾ç­‰ç­‰ã€‚
- en: If you need to interrupt foreign code reliably, itâ€™s better to isolate it in
    its own process. It might still leak temporary files and other such persistent
    resources, but most relevant state would be cleaned up by the operating system
    when the process dies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ éœ€è¦å¯é åœ°ä¸­æ–­å¤–éƒ¨ä»£ç ï¼Œæœ€å¥½å°†å…¶éš”ç¦»åœ¨è‡ªå·±çš„è¿›ç¨‹ä¸­ã€‚å®ƒå¯èƒ½ä»ç„¶ä¼šæ³„æ¼ä¸´æ—¶æ–‡ä»¶å’Œå…¶ä»–æŒä¹…æ€§èµ„æºï¼Œä½†å½“è¿›ç¨‹ç»ˆæ­¢æ—¶ï¼Œæ“ä½œç³»ç»Ÿå°†æ¸…ç†æ‰å¤§éƒ¨åˆ†ç›¸å…³çŠ¶æ€ã€‚
- en: Controlled thread cancellation [#](#controlled-thread-cancellation)
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å—æ§çº¿ç¨‹å–æ¶ˆ [#](#controlled-thread-cancellation)
- en: 'Hopefully youâ€™re now convinced that unrestricted thread cancellation is not
    a great idea in most circumstances. However we can pick the circumstances explicitly
    by enabling thread cancellation only at specific times. So our event loop becomes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: å¸Œæœ›ç°åœ¨ä½ å·²ç»ç¡®ä¿¡åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹æ— é™åˆ¶çš„çº¿ç¨‹å–æ¶ˆå¹¶ä¸æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åªåœ¨ç‰¹å®šæ—¶é—´å¯ç”¨çº¿ç¨‹å–æ¶ˆæ¥æ˜ç¡®é€‰æ‹©æƒ…å†µã€‚å› æ­¤æˆ‘ä»¬çš„äº‹ä»¶å¾ªç¯å˜æˆäº†ï¼š
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We turn off thread cancellation by default, but turn it back on as we do our
    blocking syscall.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é»˜è®¤å…³é—­çº¿ç¨‹å–æ¶ˆï¼Œä½†åœ¨è¿›è¡Œé˜»å¡ç³»ç»Ÿè°ƒç”¨æ—¶é‡æ–°æ‰“å¼€å®ƒã€‚
- en: Refactoring our code to fit this pattern might seem onerous. However many applications
    with long lived threads already contain loops with a blocking syscall at the beginning
    (reading from a socket, sleeping on a timer, and so on), followed by some work
    that will not block indefinitely.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: é‡æ„æˆ‘ä»¬çš„ä»£ç ä»¥é€‚åº”è¿™ç§æ¨¡å¼å¯èƒ½çœ‹èµ·æ¥å¾ˆç¹çã€‚ä½†æ˜¯ï¼Œè®¸å¤šå…·æœ‰é•¿æ—¶é—´è¿è¡Œçº¿ç¨‹çš„åº”ç”¨ç¨‹åºå·²ç»åŒ…å«äº†ä»¥é˜»å¡ç³»ç»Ÿè°ƒç”¨å¼€å§‹çš„å¾ªç¯ï¼ˆä»å¥—æ¥å­—è¯»å–ï¼Œå®šæ—¶å™¨ä¼‘çœ ç­‰ï¼‰ï¼Œç„¶åæ˜¯ä¸€äº›ä¸ä¼šæ— é™æœŸé˜»å¡çš„å·¥ä½œã€‚
- en: Homegrown thread cancellation [#](#homegrown-thread-cancellation)
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è‡ªåˆ¶çº¿ç¨‹å–æ¶ˆ [#](#homegrown-thread-cancellation)
- en: However once weâ€™ve done this, it might be worth getting rid of thread cancellation
    entirely. Relying on the stack unwinding to free resources would not be portable
    to alternative libcs, and weâ€™d need to be [fairly careful](https://udrepper.livejournal.com/21541.html)
    if we wanted to perform some explicit cleanup actions outside destructors.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ä¸€æ—¦æˆ‘ä»¬è¿™æ ·åšäº†ï¼Œæˆ–è®¸å€¼å¾—å®Œå…¨æ‘†è„±çº¿ç¨‹å–æ¶ˆã€‚ä¾èµ–å †æ ˆå±•å¼€æ¥é‡Šæ”¾èµ„æºä¸ä¼šåœ¨å¯é€‰çš„ libcs ä¸Šæ˜¯å¯ç§»æ¤çš„ï¼Œè€Œä¸”å¦‚æœæˆ‘ä»¬æƒ³åœ¨ææ„å‡½æ•°å¤–æ‰§è¡Œä¸€äº›æ˜¾å¼æ¸…ç†æ“ä½œï¼Œæˆ‘ä»¬éœ€è¦[ç›¸å½“å°å¿ƒ](https://udrepper.livejournal.com/21541.html)ã€‚
- en: So instead we can work with signals directly. We can pick SIGUSR1 as our â€œstoppingâ€
    signal, install a handler which sets our stopping variable, and check the variable
    before doing blocking syscalls.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ä¿¡å·ã€‚æˆ‘ä»¬å¯ä»¥é€‰æ‹© SIGUSR1 ä½œä¸ºæˆ‘ä»¬çš„â€œåœæ­¢â€ä¿¡å·ï¼Œå®‰è£…ä¸€ä¸ªè®¾ç½®æˆ‘ä»¬åœæ­¢å˜é‡çš„å¤„ç†ç¨‹åºï¼Œå¹¶åœ¨æ‰§è¡Œé˜»å¡ç³»ç»Ÿè°ƒç”¨ä¹‹å‰æ£€æŸ¥å˜é‡ã€‚
- en: '[Hereâ€™s a worked out example in C++.](https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/7f5a705198f5f9c3c250d24ec085bb75796a4752)
    The interesting parts of the code are setting up the signal handler:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[è¿™æ˜¯ä¸€ä¸ªåœ¨ C++ ä¸­çš„ç¤ºä¾‹ã€‚](https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/7f5a705198f5f9c3c250d24ec085bb75796a4752)
    ä»£ç çš„æœ‰è¶£éƒ¨åˆ†æ˜¯è®¾ç½®ä¿¡å·å¤„ç†ç¨‹åºï¼š'
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the code checking the flag before running the syscall:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œåœ¨è¿è¡Œç³»ç»Ÿè°ƒç”¨ä¹‹å‰æ£€æŸ¥æ ‡å¿—çš„ä»£ç ï¼š
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, the code checking the flag and starting the syscall is racy:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ï¼Œæ£€æŸ¥æ ‡å¿—å¹¶å¯åŠ¨ç³»ç»Ÿè°ƒç”¨çš„ä»£ç å­˜åœ¨ç«äº‰æ¡ä»¶ï¼š
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Thereâ€™s no easy way to check the flag and run the syscall atomically.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰ç®€å•çš„æ–¹æ³•æ¥æ£€æŸ¥æ ‡å¿—å¹¶åŸå­åœ°è¿è¡Œç³»ç»Ÿè°ƒç”¨ã€‚
- en: '[Another approach to this problem](https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/139cc58cbdbba88ef311f7ea1b47a06050f03016)
    would be to have USR1 blocked normally, and unblock it only when the syscall runs,
    similarly to what we did with the temporary thread cancellation. If the syscall
    terminates with `EINTR`, we know that we should quit.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[è§£å†³è¿™ä¸ªé—®é¢˜çš„å¦ä¸€ç§æ–¹æ³•](https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/139cc58cbdbba88ef311f7ea1b47a06050f03016)æ˜¯æ­£å¸¸é˜»æ­¢
    USR1ï¼Œå¹¶ä»…åœ¨ç³»ç»Ÿè°ƒç”¨è¿è¡Œæ—¶è§£é™¤é˜»æ­¢ï¼Œç±»ä¼¼äºæˆ‘ä»¬åœ¨ä¸´æ—¶çº¿ç¨‹å–æ¶ˆæ—¶æ‰€åšçš„ã€‚å¦‚æœç³»ç»Ÿè°ƒç”¨ä»¥ `EINTR` ç»ˆæ­¢ï¼Œæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬åº”è¯¥é€€å‡ºã€‚'
- en: 'Sadly the race is still there, just between the unblocking and running the
    syscall:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œç«äº‰ä»ç„¶å­˜åœ¨ï¼Œåªæ˜¯åœ¨è§£é™¤é˜»å¡å’Œè¿è¡Œç³»ç»Ÿè°ƒç”¨ä¹‹é—´ï¼š
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Changing the sigmask atomically [#](#changing-the-sigmask-atomically)
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: åŸå­åœ°æ›´æ”¹ sigmask [#](#changing-the-sigmask-atomically)
- en: 'However, there often *is* an easy to atomically change the sigmask and run
    a syscall:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œé€šå¸¸æœ‰ä¸€ç§ç®€å•çš„æ–¹æ³•æ¥åŸå­åœ°æ›´æ”¹ sigmask å¹¶è¿è¡Œç³»ç»Ÿè°ƒç”¨ï¼š
- en: '[`select`](https://man7.org/linux/man-pages/man2/select.2.html)/[`poll`](https://man7.org/linux/man-pages/man2/poll.2.html)/[`epoll_wait`](https://man7.org/linux/man-pages/man2/epoll_wait.2.html)
    have `pselect`/`ppoll`/`epoll_pwait` variants which take a `sigmask` argument;'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`select`](https://man7.org/linux/man-pages/man2/select.2.html)/[`poll`](https://man7.org/linux/man-pages/man2/poll.2.html)/[`epoll_wait`](https://man7.org/linux/man-pages/man2/epoll_wait.2.html)æœ‰å¸¦æœ‰
    `sigmask` å‚æ•°çš„ `pselect`/`ppoll`/`epoll_pwait` å˜ä½“ï¼›'
- en: '`read`/`write` and similar syscalls can be replaced by their non-blocking versions
    and a blocking `ppoll`;'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`/`write` å’Œç±»ä¼¼çš„ç³»ç»Ÿè°ƒç”¨å¯ä»¥è¢«å®ƒä»¬çš„éé˜»å¡ç‰ˆæœ¬æ›¿ä»£ï¼Œå¹¶ä½¿ç”¨é˜»å¡çš„ `ppoll`ï¼›'
- en: To sleep one can use [`timerfd`](https://man7.org/linux/man-pages/man2/timerfd_create.2.html)
    or just `ppoll` with no file descriptors but with a timeout;
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯ä»¥ä½¿ç”¨[`timerfd`](https://man7.org/linux/man-pages/man2/timerfd_create.2.html)æˆ–åªæ˜¯ä½¿ç”¨æ²¡æœ‰æ–‡ä»¶æè¿°ç¬¦ä½†æœ‰è¶…æ—¶çš„
    `ppoll` æ¥ç¡çœ ï¼›
- en: The newly added [`io_uring_enter`](https://man7.org/linux/man-pages/man2/io_uring_enter.2.html)
    supports this use case out of the box.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ–°æ·»åŠ çš„[`io_uring_enter`](https://man7.org/linux/man-pages/man2/io_uring_enter.2.html)ç›´æ¥æ”¯æŒè¿™ç§ç”¨ä¾‹ã€‚
- en: The syscalls above already cover a very large footprint.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ç³»ç»Ÿè°ƒç”¨å·²ç»æ¶µç›–äº†éå¸¸å¹¿æ³›çš„èŒƒå›´ã€‚
- en: 'In this style, the [receive loop of the program becomes](https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/9bd6b18f6329a0b07cba5cb38d3c45bbf27ae968):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§é£æ ¼ä¸­ï¼Œç¨‹åºçš„[æ¥æ”¶å¾ªç¯å˜å¾—](https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/9bd6b18f6329a0b07cba5cb38d3c45bbf27ae968)ï¼š
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Making it work with any syscall [#](#rseq)
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ä½¿å…¶ä¸ä»»ä½•ç³»ç»Ÿè°ƒç”¨ä¸€èµ·å·¥ä½œ [#](#rseq)
- en: Sadly, not all syscalls have variants which let us atomically change the sigmask
    as they execute. [`futex`](https://man7.org/linux/man-pages/man2/futex.2.html),
    the main syscall used to implement userspace concurrency primitives, is a notable
    example of a syscall which does *not* include such a facility.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: é—æ†¾çš„æ˜¯ï¼Œå¹¶éæ‰€æœ‰çš„ç³»ç»Ÿè°ƒç”¨éƒ½æœ‰å˜ä½“èƒ½è®©æˆ‘ä»¬åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­åŸå­æ€§åœ°æ”¹å˜sigmaskã€‚[`futex`](https://man7.org/linux/man-pages/man2/futex.2.html)ï¼Œç”¨äºå®ç°ç”¨æˆ·ç©ºé—´å¹¶å‘åŸè¯­çš„ä¸»è¦ç³»ç»Ÿè°ƒç”¨ï¼Œæ˜¯ä¸€ä¸ªä¾‹å­ï¼Œè¯¥ç³»ç»Ÿè°ƒç”¨*æ²¡æœ‰*åŒ…æ‹¬è¿™æ ·çš„è®¾æ–½ã€‚
- en: In the case of `futex` one can interrupt threads through `FUTEX_WAKE`, but it
    turns out we can setup a mechanism to safely check the boolean stop flag atomically
    with starting *any* syscall.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äº`futex`ï¼Œå¯ä»¥é€šè¿‡`FUTEX_WAKE`ä¸­æ–­çº¿ç¨‹ï¼Œä½†äº‹å®è¯æ˜æˆ‘ä»¬å¯ä»¥å»ºç«‹ä¸€ä¸ªæœºåˆ¶ï¼Œå¯ä»¥å®‰å…¨åœ°ç”¨*ä»»ä½•*ç³»ç»Ÿè°ƒç”¨åŸå­æ€§åœ°æ£€æŸ¥å¸ƒå°”åœæ­¢æ ‡å¿—ã€‚
- en: 'To recap, the problematic code [looks like this](https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/7f5a705198f5f9c3c250d24ec085bb75796a4752):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: å›é¡¾ä¸€ä¸‹ï¼Œæœ‰é—®é¢˜çš„ä»£ç [çœ‹èµ·æ¥åƒè¿™æ ·](https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9/7f5a705198f5f9c3c250d24ec085bb75796a4752)ï¼š
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we could know that no signal handler is ran between the flag check and the
    syscall, then weâ€™d be safe.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬èƒ½ç¡®å®šåœ¨æ ‡å¿—æ£€æŸ¥å’Œç³»ç»Ÿè°ƒç”¨ä¹‹é—´æ²¡æœ‰è¿è¡Œä¿¡å·å¤„ç†ç¨‹åºï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¼šå®‰å…¨ã€‚
- en: 'Linux 4.18 introduced a syscall, [`rseq`](../assets/other/rseq.html) (â€œrestartable
    sequencesâ€), which lets us achieve this, although with some effort. The `rseq`
    machinery works as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 4.18å¼•å…¥äº†ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œ[`rseq`](../assets/other/rseq.html)ï¼ˆâ€œå¯é‡å¯åºåˆ—â€ï¼‰ï¼Œè®©æˆ‘ä»¬å¯ä»¥å®ç°è¿™ä¸€ç‚¹ï¼Œå°½ç®¡éœ€è¦ä¸€äº›åŠªåŠ›ã€‚`rseq`æœºåˆ¶çš„å·¥ä½œå¦‚ä¸‹ï¼š
- en: You write some code which you want to run atomically with regards to preemption
    or signals â€“ the critical section.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ‚¨ç¼–å†™ä¸€äº›æ‚¨æƒ³è¦åŸå­è¿è¡Œçš„ä»£ç ï¼Œç”¨äºæŠ¢å æˆ–ä¿¡å· - ä¸´ç•ŒåŒºã€‚
- en: Before the critical section is entered, we inform the kernel that the critical
    section is about to run by writing to a bit of memory shared between the kernel
    and userspace.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨è¿›å…¥ä¸´ç•ŒåŒºä¹‹å‰ï¼Œæˆ‘ä»¬é€šè¿‡åœ¨å†…æ ¸å’Œç”¨æˆ·ç©ºé—´ä¹‹é—´å…±äº«çš„ä¸€å°å—å†…å­˜ä¸­å†™å…¥æ¥é€šçŸ¥å†…æ ¸å³å°†è¿è¡Œä¸´ç•ŒåŒºã€‚
- en: 'This bit of memory contains:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™å—å†…å­˜åŒ…å«ï¼š
- en: '`start_ip`, the instruction pointer which marks the begin of the critical section;'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`start_ip`ï¼Œæ ‡è®°ä¸´ç•ŒåŒºå¼€å§‹çš„æŒ‡ä»¤æŒ‡é’ˆï¼›'
- en: '`post_commit_offset`, the length of the critical section;'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`post_commit_offset`ï¼Œä¸´ç•ŒåŒºçš„é•¿åº¦ï¼›'
- en: '`abort_ip`, the instruction pointer to jump to if the kernel needs to preempt
    the critical section.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`abort_ip`ï¼Œå¦‚æœå†…æ ¸éœ€è¦æŠ¢å ä¸´ç•ŒåŒºï¼Œåˆ™è¦è·³è½¬åˆ°çš„æŒ‡ä»¤æŒ‡é’ˆã€‚'
- en: If the kernel has preempted a thread, or if a signal needs to be delivered to
    the thread, it checks if the thread is in a `rseq` critical section, and if it
    does sets the program counter for the thread to `abort_ip`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœå†…æ ¸æŠ¢å äº†ä¸€ä¸ªçº¿ç¨‹ï¼Œæˆ–è€…éœ€è¦å‘çº¿ç¨‹äº¤ä»˜ä¿¡å·ï¼Œå®ƒä¼šæ£€æŸ¥çº¿ç¨‹æ˜¯å¦å¤„äº`rseq`å…³é”®éƒ¨åˆ†ï¼Œå¹¶ä¸”å¦‚æœè®¾ç½®äº†ç¨‹åºè®¡æ•°å™¨åˆ°`abort_ip`ã€‚
- en: The process above forces the critical section to be a single contiguous block
    (from `start_ip` to `start_ip+post_commit_offset`) which we must know the address
    of. These requirements force us to write it in inline assembly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°è¿‡ç¨‹å¼ºåˆ¶ä¸´ç•ŒåŒºæˆä¸ºä¸€ä¸ªè¿ç»­çš„å—ï¼ˆä»`start_ip`åˆ°`start_ip+post_commit_offset`ï¼‰ï¼Œæˆ‘ä»¬å¿…é¡»çŸ¥é“å…¶åœ°å€ã€‚è¿™äº›è¦æ±‚è¿«ä½¿æˆ‘ä»¬ä»¥å†…è”æ±‡ç¼–çš„æ–¹å¼ç¼–å†™å®ƒã€‚
- en: Note that rather than disabling preemption entirely, `rseq` lets us specify
    some code (the code starting at `abort_ip`) to perform some cleanup if the critical
    section is interrupted. The correct functioning of the critical section therefore
    often depends on a â€œcommit instructionâ€ at the very end of the critical section
    which makes the changes in the critical section visible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œ`rseq`å¹¶éå®Œå…¨ç¦ç”¨æŠ¢å ï¼Œå®ƒè®©æˆ‘ä»¬æŒ‡å®šä¸€äº›ä»£ç ï¼ˆä»`abort_ip`å¼€å§‹çš„ä»£ç ï¼‰åœ¨ä¸´ç•ŒåŒºè¢«ä¸­æ–­æ—¶æ‰§è¡Œä¸€äº›æ¸…ç†å·¥ä½œã€‚å› æ­¤ï¼Œä¸´ç•ŒåŒºçš„æ­£ç¡®å·¥ä½œé€šå¸¸å–å†³äºä¸´ç•ŒåŒºæœ«å°¾çš„â€œæäº¤æŒ‡ä»¤â€ï¼Œä½¿ä¸´ç•ŒåŒºä¸­çš„æ›´æ”¹å¯è§ã€‚
- en: In our case the â€œcommit instructionâ€ is `syscall` â€“ the instruction which will
    invoke the syscall that weâ€™re interested in.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œâ€œæäº¤æŒ‡ä»¤â€æ˜¯`syscall` - å°†è°ƒç”¨æˆ‘ä»¬æ„Ÿå…´è¶£çš„ç³»ç»Ÿè°ƒç”¨çš„æŒ‡ä»¤ã€‚
- en: 'Which leads us to the following x86-64 widget for a 6-argument syscall stub
    which atomically checks a stop flag and executes a `syscall`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¼è‡´äº†ä»¥ä¸‹ç”¨äº6ä¸ªå‚æ•°ç³»ç»Ÿè°ƒç”¨å­˜æ ¹çš„x86-64å°éƒ¨ä»¶ï¼Œç”¨äºåŸå­æ€§åœ°æ£€æŸ¥åœæ­¢æ ‡å¿—å¹¶æ‰§è¡Œ`syscall`ï¼š
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Weâ€™re using glibcâ€™s [recently added support for `rseq`](https://lwn.net/Articles/883104/),
    which provides a `__rseq_offset` variable containing the offset where the critical
    section information lives, relative to the thread pointer. All we need to do in
    the critical section is check the flag, skip the syscall if itâ€™s set, and perform
    the syscall if it is. If the flag is set we pretend the syscall has failed with
    `EINTR`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨ glibc æœ€è¿‘æ·»åŠ çš„å¯¹ `rseq` çš„æ”¯æŒï¼Œå®ƒæä¾›äº†ä¸€ä¸ª `__rseq_offset` å˜é‡ï¼Œå…¶ä¸­åŒ…å«å…³é”®éƒ¨åˆ†ä¿¡æ¯ç›¸å¯¹äºçº¿ç¨‹æŒ‡é’ˆçš„åç§»é‡ã€‚åœ¨å…³é”®éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬åªéœ€æ£€æŸ¥æ ‡å¿—ï¼Œå¦‚æœè®¾ç½®äº†ï¼Œåˆ™è·³è¿‡ç³»ç»Ÿè°ƒç”¨ï¼Œå¦‚æœæœªè®¾ç½®ï¼Œåˆ™æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ã€‚å¦‚æœæ ‡å¿—å·²è®¾ç½®ï¼Œåˆ™å‡è£…ç³»ç»Ÿè°ƒç”¨å¤±è´¥ï¼Œå¹¶æ˜¾ç¤º
    `EINTR`ã€‚
- en: You can find the full code for the previous example using this trick to call
    `recvfrom` [here](https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9).
    Iâ€™m not necessarily advocating the use of this technique, but itâ€™s definitely
    an interesting curiosity.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¯ä»¥åœ¨[è¿™é‡Œ](https://gist.github.com/bitonic/d3281b2d0fd95b4fd788aa7e013d1fb9)æ‰¾åˆ°å…ˆå‰ç¤ºä¾‹çš„å®Œæ•´ä»£ç ï¼Œä½¿ç”¨è¿™ç§æŠ€å·§è°ƒç”¨`recvfrom`ã€‚æˆ‘å¹¶ä¸ä¸€å®šä¸»å¼ ä½¿ç”¨è¿™ç§æŠ€æœ¯ï¼Œä½†å®ƒç»å¯¹æ˜¯ä¸€ä¸ªæœ‰è¶£çš„å¥‡ç‰¹ä¹‹å¤„ã€‚
- en: Wrapping up [#](#wrapping-up)
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç»“æŸ [#](#wrapping-up)
- en: Itâ€™s quite frustrating that thereâ€™s no agreed upon way to interrupt and stack
    unwind a Linux thread and to protect critical sections from such unwinding. There
    are no technical obstacles to such facilities existing, but clean teardown is
    often a neglected part of software.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Linux çº¿ç¨‹ä¸­ï¼Œä¸­æ–­å’Œå †æ ˆå±•å¼€ä»¥åŠä¿æŠ¤å…³é”®éƒ¨åˆ†å…å—æ­¤ç±»å±•å¼€çš„æ–¹å¼å°šæœªè¾¾æˆä¸€è‡´ï¼Œè¿™ä»¤äººç›¸å½“æ²®ä¸§ã€‚è™½ç„¶ä¸å­˜åœ¨æŠ€æœ¯éšœç¢æ¥å®ç°è¿™æ ·çš„åŠŸèƒ½ï¼Œä½†æ˜¯æ¸…ç†æ‹†å¸é€šå¸¸æ˜¯è½¯ä»¶çš„è¢«å¿½è§†çš„éƒ¨åˆ†ã€‚
- en: Haskell is one language where these capabilities do exist in the form of [asynchronous
    exceptions](https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Exception.html#v:throwTo),
    although one still needs to be careful to protect critical sections appropriately.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell æ˜¯ä¸€ç§è¯­è¨€ï¼Œå…¶ä¸­å­˜åœ¨è¿™äº›åŠŸèƒ½ï¼Œä»¥[å¼‚æ­¥å¼‚å¸¸](https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Exception.html#v:throwTo)çš„å½¢å¼å­˜åœ¨ï¼Œå°½ç®¡ä»ç„¶éœ€è¦å°å¿ƒåœ°é€‚å½“åœ°ä¿æŠ¤å…³é”®éƒ¨åˆ†ã€‚
- en: Acknowledgements [#](#acknowledgements)
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è‡´è°¢ [#](#acknowledgements)
- en: '[Peter Cawley](https://twitter.com/corsix) provided input on many details treated
    in this blog post and read its draft. He also suggested `rseq` as a possible solution.
    Many thanks also go to [Niklas HambÃ¼chen](https://nh2.me/), [Alexandru SÃ§vortov](https://scvalex.net/),
    [Alex Sayers](https://www.asayers.com/), and Alex Appetiti for reading drafts
    of this blog post.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[Peter Cawley](https://twitter.com/corsix) åœ¨æœ¬åšå®¢æ–‡ç« ä¸­è®¨è®ºçš„è®¸å¤šç»†èŠ‚ä¸Šæä¾›äº†æ„è§å¹¶é˜…è¯»äº†å…¶è‰ç¨¿ã€‚ä»–è¿˜æå‡ºäº†
    `rseq` ä½œä¸ºå¯èƒ½çš„è§£å†³æ–¹æ¡ˆã€‚è¿˜è¦éå¸¸æ„Ÿè°¢[Niklas HambÃ¼chen](https://nh2.me/)ã€[Alexandru SÃ§vortov](https://scvalex.net/)ã€[Alex
    Sayers](https://www.asayers.com/) å’Œ Alex Appetiti è¯»è¿‡æœ¬åšå®¢æ–‡ç« çš„è‰ç¨¿ã€‚'
