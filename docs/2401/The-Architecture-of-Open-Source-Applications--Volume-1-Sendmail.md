<!--yml

类别：未分类

日期：2024-05-27 14:33:42

-->

# 开源应用程序的架构（卷 1）：Sendmail

> 来源：[`aosabook.org/en/v1/sendmail.html`](https://aosabook.org/en/v1/sendmail.html)

# 开源应用程序的架构（卷 1）

Sendmail

Eric Allman

大多数人认为电子邮件是他们与之交互的程序——他们的邮件客户端，技术上称为邮件用户代理（MUA）。但电子邮件的另一个重要部分是实际将邮件从发送者传输到接收者的软件——邮件传输代理（MTA）。互联网上第一个 MTA，至今仍然是最普遍的，是 sendmail。

Sendmail 是在互联网正式存在之前首次创建的。它取得了非凡的成功，从 1981 年开始，当时还不明显互联网会超出只是一个拥有几百台主机的学术实验，到今天，截至 2011 年 1 月，互联网主机数量已超过 8 亿。Sendmail 仍然是互联网上最常用的 SMTP 实现之一。

## 17.1\. 从前，有一段时光…

该程序的最初版本，后来被称为 sendmail，是在 1980 年编写的。它最初是一个快速的小工具，用于在不同的网络之间转发消息。互联网正在开发中，但当时还没有正式运行。实际上，许多不同的网络已被提议，但没有明显的共识出现。阿帕网在美国使用中，互联网正在被设计为一种升级，但欧洲已经支持 OSI（开放系统互连）的努力，有一段时间看来 OSI 可能会取胜。这两者都使用电话公司的租用线路；在美国，速度是 56 Kbps。

在当时，可能是最成功的网络，从连接的计算机和人数来看，是 UUCP 网络，这是非常不同寻常的，因为它绝对没有中央管理机构。在某种意义上，它是最初的对等网络，它在拨号电话线上运行：一段时间内 9600 bps 是最快的速度。最快的网络（在 3 Mbps）基于施乐的以太网，运行一种叫做 XNS（Xerox Network Systems）的协议，但它在本地安装外部不能使用。

当时的环境与今天存在的环境非常不同。计算机高度异构，甚至没有完全一致使用 8 位字节的协议。例如，其他机器包括 PDP-10（36 位字，9 位字节），PDP-11（16 位字，8 位字节），CDC 6000 系列（60 位字，6 位字符），IBM 360（32 位字，8 位字节），XDS 940，ICL 470 和 Sigma 7。 Unix 是一个崭露头角的平台之一，当时来自贝尔实验室。大多数基于 Unix 的机器具有 16 位地址空间：当时 PDP-11 是主要的 Unix 机器，Data General 8/32 和 VAX-11/780 刚刚出现。线程根本不存在——事实上，动态进程的概念仍然相当新（Unix 有这些，但是“严肃”的系统，如 IBM 的 OS/360 并没有）。Unix 内核不支持文件锁定（但是可以使用文件系统链接进行技巧处理）。

在很大程度上，网络通常是低速的（许多基于 9600 波特的 TTY 线路；真正富裕的人可能已经有了以太网，但仅用于本地使用）。可敬的套接字接口还要多年才会被发明。公钥加密也还没有被发明，因此今天我们所知道的大多数网络安全措施都是不可行的。

Unix 上已经存在网络电子邮件，但是它是使用 hack 创建的。当时的主要用户代理是 `/bin/mail` 命令（今天有时称为 `binmail` 或 `v7mail`），但是一些站点具有其他用户代理，如伯克利的 `Mail`，它实际上知道如何将消息视为单独的项目，而不是作为一个光荣的 `cat` 程序。每个用户代理直接读取（通常是写入！）`/usr/spool/mail`；实际上没有关于消息实际存储方式的抽象化。

将消息路由到网络与本地电子邮件之间的逻辑仅仅是查看地址是否包含感叹号（UUCP）或冒号（BerkNET）。具有 Arpanet 访问权限的人必须使用完全独立的邮件程序，该程序无法与其他网络进行互操作，甚至将本地邮件存储在不同的位置和不同的格式中。

更有趣的是，几乎没有关于消息本身格式的标准化。大家普遍同意消息顶部将有一块头部字段，每个头部字段将位于新的一行上，并且头部字段名称和值之间将用冒号分隔。除此之外，头部字段名称的选择和各个字段的语法几乎没有标准化。例如，一些系统使用`Subj:`而不是`Subject:`，`Date:`字段有不同的语法，一些系统不理解`From:`字段中的全名。除此之外，所记录的内容常常是模糊的或者与实际使用不太一致。特别是，RFC 733（声称描述了 Arpanet 消息的格式）与实际使用的方式略有不同，有时甚至有重要的差异，而消息传输的实际方法根本没有正式记录（尽管有几个 RFC 提到了这种机制，但没有一个定义了它）。结果导致消息系统周围形成了一种神秘的氛围。

1979 年，INGRES 关系数据库管理项目（即我的日常工作）获得了 DARPA 的资助，随之而来的是我们的 PDP-11 连接到 Arpanet 的 9600bps 速度的网络。当时，这是计算机科学部唯一的 Arpanet 连接，因此每个人都想访问我们的机器，以便访问 Arpanet。然而，那台机器已经达到了最大限度，所以我们只能提供两个登录端口供部门内的所有人共享。这引起了相当大的竞争和频繁的冲突。然而，我注意到人们最想要的不是远程登录或文件传输，而是电子邮件。

在这种情况下，sendmail（最初称为 delivermail）成为统一混乱的尝试。每个 MUA（邮件用户代理程序，或邮件客户端）只需调用 delivermail 来传递邮件，而不是想出如何以临时（而且通常是不兼容的）的方式进行操作。Delivermail/sendmail 并没有试图规定本地邮件应该如何存储或传递；它绝对没有做任何事情，只是在其他程序之间传递邮件。（当 SMTP 被添加时，情况发生了变化，我们很快就会看到。）在某种意义上，它只是将各种邮件系统粘在一起的胶水，而不是一个独立的邮件系统。

在 sendmail 的开发过程中，阿帕网转变为互联网。这些变化是广泛的，从低层次的网络数据包到应用层协议，而且并非一蹴而就。Sendmail 与标准同时发展，甚至在某些情况下影响了它们。值得注意的是，sendmail 在“网络”（就我们今天所理解的意义而言）从几百个主机扩展到数亿个主机的过程中存活下来，甚至繁荣起来。

另一个网络

值得一提的是，在当时还提出了另一个完全独立的邮件标准，名为 X.400，它是 ISO/OSI（国际标准化组织/开放系统互连）的一部分。X.400 是一种二进制协议，消息使用 ASN.1（抽象语法表示法 1）进行编码，该协议在今天的一些互联网协议中仍在使用，如 LDAP。LDAP 又是 X.500 的简化版本，X.500 是 X.400 使用的目录服务。Sendmail 并没有试图直接与 X.400 兼容，尽管当时已经存在一些网关服务。尽管当时 X.400 最初被许多商业供应商采用，但是 Internet 邮件和 SMTP 最终在市场上获胜。

## 17.2\. 设计原则

在开发 sendmail 时，我遵循了几项设计原则。所有这些原则在某种程度上都归结为一件事：尽量做得少。这与当时一些具有更广泛目标并需要更大实现的努力形成了鲜明对比。

### 17.2.1\. 接受一个程序员的有限性

我以兼职、无报酬的形式编写了 sendmail 项目。这是为了让 Arpanet 邮件更易于被加州大学伯克利分校的人们所接触。关键在于在现有网络之间转发邮件，所有这些网络都是作为独立程序实现的，它们甚至不知道存在多个网络。只有一位兼职程序员，修改现有软件的大部分内容是不可行的。设计必须将需要修改的现有代码量以及需要编写的新代码量降到最低。这一约束驱动了大部分其他设计原则。事实证明，在大多数情况下，即使有更大的团队可用，它们也应该是正确的做法。

### 17.2.2\. 不要重新设计用户代理

邮件用户代理（MUA）是大多数最终用户认为的“邮件系统”——这是他们用来阅读、写作和回复邮件的程序。它与邮件传输代理（MTA）完全不同，后者将电子邮件从发送方路由到接收方。在编写 sendmail 时，许多实现至少部分地结合了这两个功能，因此它们经常是一起开发的。尝试同时处理两者将会太过繁琐，因此 Sendmail 完全忽略了用户界面的问题：对 MUA 的唯一更改是让它们调用 sendmail 而不是进行自己的路由。特别是，已经有几个用户代理，人们对其如何与邮件交互通常非常情绪化。尝试同时处理两者将会太过繁琐。现在将 MUA 与 MTA 分离开来是被广泛接受的智慧，但在当时远非标准做法。

### 17.2.3\. 不要重新设计本地邮件存储

本地邮箱存储（消息将保存在其中，直到收件人来读取它们）并没有正式标准化。一些站点喜欢将它们存储在一个集中的地方，例如 `/usr/mail`、`/var/mail` 或 `/var/spool/mail`。其他站点喜欢将它们存储在收件人的主目录中（例如，作为一个名为 `.mail` 的文件）。大多数站点以一个以 "From" 开头的行开始每个消息，后面跟着一个空格字符（这是一个非常糟糕的决定，但那时是约定俗成的），但是关注 Arpanet 的站点通常将消息分开存储，中间用包含四个控制字符 A 的行分隔。一些站点尝试锁定邮箱以防止冲突，但它们使用不同的锁定约定（文件锁定原语尚不可用）。简而言之，唯一合理的做法是将本地邮箱存储视为一个黑盒子。

几乎所有站点上，执行本地邮箱存储的实际机制都体现在 `/bin/mail` 程序中。这个程序有一个（非常原始的）用户界面、路由和存储都内建到一个程序中。为了合并 sendmail，路由部分被分离出来，并替换为对 sendmail 的调用。添加了一个 `-d` 标志以强制最终投递，即防止 `/bin/mail` 调用 sendmail 进行路由。后来，将将消息传递到物理邮箱的代码提取到另一个名为 `mail.local` 的程序中。今天，`/bin/mail` 程序仅用于包含脚本发送邮件的最低公共分母。

### 17.2.4\. 使 Sendmail 适应世界，而不是相反

类似 UUCP 和 BerkNET 的协议已经作为独立的程序实现，它们有自己的，有时候很古怪的命令行结构。在某些情况下，它们与 sendmail 一起被积极开发。很明显，重新实现它们（例如将它们转换为标准调用约定）将是痛苦的。这直接导致了一个原则，即 sendmail 应该适应世界其他部分，而不是试图让世界其他部分适应 sendmail。

### 17.2.5\. 尽可能改动少

在 sendmail 的开发过程中，我尽可能地不去触碰我绝对不必触碰的东西。除了没有足够的时间来做，当时在伯克利有一种文化，它避免了大多数正式的代码所有权，而更倾向于一个政策，“最后一个接触代码的人就是该程序的负责人”（或者更简单地说，“你触碰它，你就拥有它”）。尽管在现代标准下，这听起来混乱，但在伯克利，没有人被全职分配到 Unix 工作；个人工作在他们感兴趣并致力于的系统的部分，并且除非在紧急情况下，否则不接触代码库的其余部分。

### 17.2.6\. 提早考虑可靠性

在 sendmail 出现之前的邮件系统（包括大多数传输系统）并不特别关心可靠性。例如，Unix 4.2BSD 之前的版本没有原生文件锁定功能，尽管可以通过创建临时文件然后将其链接到锁定文件来模拟（如果锁定文件已经存在，则链接调用将失败）。然而，有时候不同的程序写入相同的数据文件时无法就如何进行锁定达成一致（例如，它们可能使用不同的锁定文件名称，甚至根本不尝试进行锁定），因此丢失邮件并不罕见。sendmail 的方法是认为丢失邮件不是一个选择（可能是因为我的背景是数据库人员，数据丢失是致命的罪行）。

### 17.2.7\. **被遗漏的部分**

早期版本中有许多未完成的事情。我没有尝试重新设计邮件系统或构建完全通用的解决方案：功能可以根据需要添加。非常早期的版本甚至没有打算在没有访问源代码和编译器的情况下完全可配置（尽管这在相当早的时候就改变了）。通常，sendmail 的操作方式是快速让某些东西工作，然后根据需要和更好地理解问题来增强工作代码。

## 17.3\. 开发阶段

像大多数存在很长时间的软件一样，sendmail 是分阶段开发的，每个阶段都有其自己的基本主题和感觉。

### 17.3.1\. 第一阶段：delivermail

sendmail 的第一个实例被称为 delivermail。它非常简单，甚至可以说过于简单了。它的唯一工作是将邮件从一个程序转发到另一个程序；特别是，它没有 SMTP 支持，因此从未直接建立任何网络连接。不需要排队，因为每个网络已经有了自己的队列，所以该程序实际上只是一个交换机。由于 delivermail 没有直接的网络协议支持，因此没有理由将其作为守护进程运行——每次提交消息时都会调用它进行路由，将其传递给实现下一跳的适当程序，然后终止。此外，也没有尝试重写标头以匹配将消息传递到的网络。这通常会导致转发无法回复的消息。情况如此糟糕以至于有一整本书是关于邮件地址的（适当地称为 *!%@:: 电子邮件地址和网络的目录* [AF94]）。

在 delivermail 中，所有配置都是编译进去的，并且仅基于每个地址中的特殊字符。这些字符具有优先级。例如，主机配置可能会搜索“@”符号，并且如果找到一个，就会将整个地址发送到指定的 Arpanet 中继主机。否则，它可能会搜索冒号，并且如果找到一个，就会将消息发送到指定的主机和用户的 BerkNET，然后可以检查感叹号（“!”）标志着消息应转发到指定的 UUCP 中继。否则，它将尝试本地投递。此配置可能导致以下结果：

| 输入 | 发送至 {net, host, user} |
| --- | --- |
| foo@bar | {Arpanet, bar, foo} |
| foo:bar | {Berknet, foo, bar} |
| foo!bar!baz | {Uucp, foo, bar!baz} |
| foo!bar@baz | {Arpanet, baz, foo!bar} |

注意地址分隔符在其关联性上有所不同，导致只能通过启发式方法解决的歧义。例如，在另一个站点上，最后一个示例可能被合理地解析为 {Uucp, foo, bar@baz}。

几个原因导致配置被编译进去：首先，使用 16 位地址空间和有限内存，解析运行时配置的成本太高。其次，当时的系统已经被高度定制，重新编译是个好主意，只是为了确保你拥有本地版本的库（Unix 第 6 版没有共享库）。

Delivermail 随 4.0 和 4.1 BSD 发行，并且比预期更成功；伯克利远非唯一一个采用混合网络架构的站点。很明显，需要更多的工作。

### 17.3.2\. Wave 2: sendmail 3, 4, 和 5

版本 1 和 2 是以 delivermail 名义发布的。 1981 年 3 月开始制作版本 3，该版本将以 sendmail 名义发布。此时，16 位的 PDP-11 仍然在普遍使用中，但 32 位的 VAX-11 开始流行，因此许多与小地址空间相关的原始限制开始得到放宽。

sendmail 的初始目标是转换为运行时配置，允许修改消息以在转发邮件时提供网络间的兼容性，并具有更丰富的语言来做出路由决策。使用的技术本质上是地址的文本重写（基于标记而不是字符串），这是当时一些专家系统中使用的机制。还有专门的代码来提取和保存任何注释字符串（在括号内），以及在程序化重写完成后重新插入它们。还很重要的是能够添加或增强标头字段（例如，在已知发送者的情况下，添加“日期”标头字段或在“发件人”标头中包含发送者的全名）。

SMTP 开发始于 1981 年 11 月。加州大学伯克利分校的计算机科学研究小组（CSRG）获得了 DARPA 的合同，制造了一个基于 Unix 的平台来支持 DARPA 资助的研究，旨在使项目之间的共享更加容易。在那个时候，TCP/IP 堆栈的初始工作已经完成，尽管套接字接口的细节仍在变化。基本的应用程序协议，如 Telnet 和 FTP 已经完成，但 SMTP 尚未实现。实际上，SMTP 协议在那时甚至还没有最终确定；关于如何使用一个被创造性地命名为邮件传输协议（MTP）发送邮件的巨大辩论正在进行中。随着辩论的激烈，MTP 变得越来越复杂，直到在沮丧中几乎是通过命令（但直到 1982 年 8 月才正式发布）起草了 SMTP（简单邮件传输协议）。正式地说，我当时正在开发 INGRES 关系数据库管理系统，但由于我比当时伯克利周围的任何人都更了解邮件系统，所以我被说服实现 SMTP。

我最初的想法是创建一个独立的 SMTP 邮件程序，它将具有自己的排队和守护进程；该子系统将附加到 sendmail 以执行路由。但是，SMTP 的几个特性使这个问题复杂化。例如，`EXPN`和`VRFY`命令需要访问解析，别名和本地地址验证模块。而且，当时我认为如果地址未知，`RCPT`命令应立即返回，而不是接受消息，然后稍后发送传递失败消息，这被证明是一个有远见的决定。具有讽刺意味的是，后来的 MTA 经常做错了这个，加剧了垃圾邮件回溯问题。这些问题促使将 SMTP 作为 sendmail 的一部分包含在内。

Sendmail 3 与 4.1a 和 4.1c BSD（测试版本）一起分发，sendmail 4 与 4.2 BSD 一起分发，sendmail 5 与 4.3 BSD 一起分发。

### 17.3.3\. 第三阶段：混乱年代

离开伯克利去一家创业公司后，我用于工作在 sendmail 上的时间迅速减少。但是互联网开始严重膨胀，sendmail 被用于各种新（和更大）的环境中。大多数 Unix 系统供应商（特别是 Sun，DEC 和 IBM）创建了他们自己的 sendmail 版本，所有这些版本都是相互不兼容的。也有尝试构建开源版本，特别是 IDA sendmail 和 KJS。

IDA sendmail 来自 Linköping University。IDA 包含扩展，使其更容易在较大环境中安装和管理，以及全新的配置系统。主要的新功能之一是包含了 dbm(3) 数据库映射，以支持高度动态的站点。这些可通过配置文件中的新语法使用，并且用于许多功能，包括将地址映射到和从外部语法（例如，将邮件发送为 john_doe@example.com 而不是 johnd@example.com）和路由。

King James Sendmail（KJS，由 Paul Vixie 制作）是统一各种不同版本的 sendmail 的尝试。不幸的是，它从未真正获得足够的动力来产生预期的效果。这个时代也受到了大量新技术的推动，这些技术反映在邮件系统中。例如，Sun 创建了无盘集群，增加了 YP（后来的 NIS）目录服务和 NFS，即网络文件系统。特别是，YP 必须对 sendmail 可见，因为别名存储在 YP 中而不是本地文件中。

### 17.3.4\. 第四波：sendmail 8

几年后，我作为一名员工回到了伯克利。我的工作是管理一个为计算机科学系周围的研究安装和支持共享基础设施的团队。为了成功，必须以某种合理的方式统一个别研究小组的大部分临时环境。就像互联网的早期一样，不同的研究小组运行在完全不同的平台上，其中一些相当古老。总的来说，每个研究小组都在运行自己的系统，虽然其中一些被很好地管理了，但大多数都遭受了“推迟维护”的困扰。

在大多数情况下，电子邮件也同样支离破碎。每个人的电子邮件地址都是“`person@host.berkeley.edu`”，其中 `host` 是他们办公室工作站或共享服务器的名称（校园甚至没有内部子域），只有少数特殊人员有 `@berkeley.edu` 地址。目标是切换到内部子域（使所有个人主机都在 `cs.berkeley.edu` 子域中）并拥有统一的邮件系统（这样每个人都会有一个 `@cs.berkeley.edu` 地址）。这个目标最容易实现的方式是创建一个新版本的 sendmail，可以在整个部门使用。

我开始研究许多成为流行的 sendmail 变种。我的意图不是从不同的代码库开始，而是了解其他人发现有用的功能。这些想法中的许多都进入了 sendmail 8，通常以修改的方式合并相关的想法或使它们更通用。例如，几个版本的 sendmail 都具有访问外部数据库（如 dbm(3)或 NIS）的能力；sendmail 8 将这些合并为一个可以处理多种类型的数据库（甚至是任意非数据库转换）的“映射”机制。类似地，IDA sendmail 的“通用”数据库（内部到外部名称映射）也被合并进来。

Sendmail 8 还包括一个使用 m4(1)宏处理器的新配置包。这意味着相较于 sendmail 5 配置包而言，sendmail 8 配置包更加声明性，后者基本上是以过程化方式构建的。也就是说，sendmail 5 配置包要求管理员基本上手工布置整个配置文件，而实际上只使用了 m4 的“include”设施作为速记。而 sendmail 8 配置文件允许管理员只声明所需的功能、邮件发送程序等，然后 m4 会布置出最终的配置文件。

第 17.7 节 的大部分内容讨论了 sendmail 8 的增强功能。

### 17.3.5\. Wave 5：商业年代

随着互联网的发展和 sendmail 站点数量的增加，支持越来越庞大的用户群变得更加棘手。有一段时间，我能够通过成立一群志愿者（非正式地称为“Sendmail 联盟”，又称 sendmail.org）来继续提供免费的电子邮件和新闻组支持。但到了 1990 年代末，安装基数已经增长到几乎不可能以志愿者方式支持的程度。我和一个商业头脑更敏锐的朋友一起成立了 Sendmail, Inc.，期望能够获得新的资源来改进代码。

尽管商业产品最初主要基于配置和管理工具，但为了支持商业世界的需求，还添加了许多新功能到开源 MTA 中。值得注意的是，该公司增加了对 TLS（连接加密）、SMTP 身份验证、站点安全增强功能（如防止服务拒绝）以及最重要的邮件过滤插件（下面讨论的 Milter 接口）的支持。

到目前为止，商业产品已经扩展到包括大量基于电子邮件的应用程序，其中几乎所有的应用程序都是在公司创立的最初几年里添加到 sendmail 上的扩展上构建的。

### 17.3.6\. sendmail 6 和 7 发生了什么？

Sendmail 6 本质上是 sendmail 8 的测试版。它从未正式发布，但被相当广泛地分发。Sendmail 7 根本不存在；当 1993 年 6 月发布 4.4 BSD 时，sendmail 直接跳到了版本 8，因为所有其他 BSD 发行版的源文件都被提升到了版本 8。

## 17.4\. 设计决策

一些设计决策是正确的。有些一开始是正确的，随着世界的变化而变得错误。有些是可疑的，而且现在也没有变得更少。

### 17.4.1\. 配置文件的语法

配置文件的语法受到几个问题的驱动。首先，整个应用程序必须适合 16 位地址空间，因此解析器必须很小。其次，早期配置非常简短（不到一页），因此虽然语法晦涩，但文件仍然可以理解。然而，随着时间的推移，越来越多的运行决策从 C 代码移出到配置文件中，文件开始增长。配置文件因晦涩而声名远扬。对许多人特别令人沮丧的是，选择制表符作为活动语法项。这是一个错误，是从当时的其他系统（特别是`make`）中复制过来的。随着窗口系统的出现（因此剪切和粘贴通常不保留制表符），这个特定的问题变得更加严重。

回顾过去，随着文件的不断增大和 32 位机的普及，重新考虑语法是有意义的。有一段时间我考虑过这样做，但最终决定不这么做，因为我不想破坏“庞大”的已安装基础（那时可能只有几百台机器）。回顾起来，这是一个错误；我简单地没有意识到安装基础会增长多么庞大，如果我早些时候改变了语法，将会为我节省多少时间。此外，当标准稳定下来时，部分通用性本可以被推回到 C 代码库中，从而简化配置。

特别值得注意的是，更多功能是如何移入配置文件的。我在 SMTP 标准发展的同时开发 sendmail。通过将运行决策移到配置文件中，我能够在短短不到 24 小时内迅速响应设计变更。我相信这提高了 SMTP 标准，因为可以很快地获得对拟议设计变更的运行经验，但代价是使配置文件难以理解。

### 17.4.2\. 重写规则

当编写 sendmail 时，其中一个困难的决定是如何进行必要的重写，以便在不违反接收网络的标准的情况下在网络之间进行转发。 所需的转换包括更改元字符（例如，BerkNET 使用冒号作为分隔符，在 SMTP 地址中不合法），重新排列地址组件，添加或删除组件等。 例如，在某些情况下需要进行以下重写：

| 从 | 至 |
| --- | --- |
| a:foo | a.foo@berkeley.edu |
| a!b!c | b!c@a.uucp |
| <@a.net,@b.org:user@c.com> | <@b.org:user@c.com> |

正则表达式并不是一个好选择，因为它们不太好地支持单词边界、引用等。 很快就显而易见，几乎不可能编写准确的、更不用说可读的正则表达式。 特别是，正则表达式保留了许多元字符，包括“。”、“*”、“+”、“{[}”和“{]}”，这些字符都可以出现在电子邮件地址中。 这些可以在配置文件中转义，但我认为那样会复杂、混乱，而且有点丑陋。（这是贝尔实验室的 Unix 第八版邮件程序 UPAS 尝试过的方法，但从未流行起来。）相反，扫描阶段是必要的，以产生可以像正则表达式中的字符一样操作的标记。 一组描述“操作符字符”的单一参数足以。 空格分隔标记，但不是标记本身。 重写规则只是被组织成实质上是子程序的模式匹配/替换对。

不再使用大量需要转义以失去其“magic”属性的元字符（如正则表达式中使用的元字符），而是使用一个与普通字符组合在一起表示通配符模式的“转义”字符（例如，匹配任意单词）。 传统的 Unix 方法是使用反斜杠，但反斜杠已经在某些地址语法中用作引号字符。 结果，“$”是少数几个在某些电子邮件语法中还没有用作标点符号的字符之一。

原始的错误决定之一其实讽刺地仅仅是空白符的使用方式。空格字符是分隔符，就像大多数扫描输入中一样，因此可以在模式中的标记之间自由使用。然而，最初分发的配置文件中没有包含空格，导致模式比必要的难以理解得多。考虑以下两个（在语义上相同的）模式之间的区别：

```
$+ + $* @ $+ . $={mydomain}
$++$*@$+.$={mydomain}

```

### 17.4.3\. 使用重写进行解析

一些人建议 sendmail 应该使用传统的基于语法的解析技术来解析地址，而不是重写规则，并将重写规则保留用于地址修改。从表面上看，这似乎是有道理的，因为标准使用语法来定义地址。重用重写规则的主要原因是在某些情况下需要解析标题字段地址（例如，在从没有正式信封的网络接收邮件时从标题中提取发送者信封）。这样的地址不容易使用（比如说）LALR(1) 解析器（如 YACC）和传统扫描器进行解析，因为需要大量的向前看。例如，解析地址：`allman@foo.bar.baz.com <eric@example.com>` 需要扫描器或解析器进行向前看；在看到“<”之前，你不能知道初始的“allman@…”是否是一个地址。由于 LALR(1) 解析器只有一个标记的向前看，这必须在扫描器中完成，这会使其变得复杂。由于重写规则已经具有任意的回溯（即，它们可以向前看任意远），它们就足够了。

第二个原因是，很容易使模式识别并修复损坏的输入。最后，重写功能足以完成任务，并且重用任何代码都是明智的。

有关重写规则的一个不寻常的要点是：在进行模式匹配时，对于输入和模式来说，对它们进行标记化是有用的。因此，相同的扫描器用于输入地址和模式本身。这要求扫描器使用不同的字符类型表来处理不同的输入。

### 17.4.4\. 将 SMTP 和排队嵌入 sendmail

实现出站（客户端）SMTP 的一个“显而易见”的方法是将其构建为外部邮件发送程序，类似于 UUCP，但是这将引发一系列其他问题。例如，排队是在 sendmail 中进行还是在 SMTP 客户端模块中进行？如果在 sendmail 中进行排队，那么要么必须将各个收件人的消息分别发送（即没有“搭便车”，其中可以打开单个连接，然后发送多个 `RCPT` 命令），要么需要更丰富的通信反向路径来传达必要的每个收件人的状态，这是使用简单的 Unix 退出代码无法实现的。如果在客户端模块中进行排队，则存在大量复制的潜力；特别是，当时其他网络（如 XNS）仍然可能是竞争对手。此外，将队列包含到 sendmail 本身中提供了一种更优雅的方法来处理某些类型的故障，尤其是暂时性问题，如资源耗尽。

收件方（服务器）SMTP 涉及不同的决策。当时，我认为实现 `VRFY` 和 `EXPN` SMTP 命令是重要的，这需要访问别名机制。这将再次需要服务器 SMTP 模块与 sendmail 之间比使用命令行和退出码更丰富的协议交换——实际上，这是一种类似于 SMTP 本身的协议。

今天我更倾向于将队列留在核心 sendmail 中，但将 SMTP 实现的两端移至其他进程中。一个原因是为了增强安全性：一旦服务器端有一个打开的 25 号端口的实例，它就不再需要 root 权限。现代扩展例如 TLS 和 DKIM 签名会使客户端部分复杂化（因为私钥不应该对非特权用户可见），但严格来说 root 访问仍然不是必需的。虽然安全问题仍然存在，但如果客户端 SMTP 作为一个非特权用户运行，并且可以读取私钥，那么这个用户根据定义具有特殊权限，因此不应直接与其他站点通信。所有这些问题都可以通过一些工作来解决。

### 17.4.5\. 队列的实现

Sendmail 遵循当时存储队列文件的惯例。事实上，所使用的格式与当时的 lpr 子系统极为相似。每个作业都有两个文件，一个带有控制信息，一个带有数据。控制文件是一个扁平文本文件，每行的第一个字符表示该行的含义。

当 sendmail 想要处理队列时，它必须读取所有控制文件，将相关信息存储在内存中，然后对列表进行排序。这在队列中有相对较少数量的消息时运行良好，但在排队消息达到约 10,000 条时开始出现问题。具体来说，当目录变得足够大以在文件系统中需要间接块时，可能会出现严重的性能问题，这可能会将性能降低一个数量级。通过使 sendmail 理解多个队列目录，可以缓解这个问题，但这充其量是一种破解。

另一种实现方法可能是将所有控制文件存储在一个数据库文件中。这样做的原因是因为当 sendmail 编码开始时，没有普遍可用的数据库包，而当 dbm(3) 可用时，它有几个缺陷，包括无法回收空间、所有散列在一起的键都要适合一个（512 字节）页面以及缺乏锁定。稳健的数据库包在很多年后才出现。

另一种替代实现可能是有一个单独的守护进程，用于将队列的状态保留在内存中，可能会写入日志以实现恢复。考虑到当时的相对低的电子邮件流量、大多数计算机的内存不足、后台进程的相对高成本和实现这种进程的复杂性，这在当时似乎不是一个很好的权衡。

另一个设计决定是将消息头存储在队列控制文件中，而不是数据文件中。其理由是大多数头部需要经过相当多的重写，而这种重写因目的地而异（而且由于消息可能有多个目的地，它们将不得不被多次自定义），并且解析头部的成本似乎很高，因此以预解析格式存储它们似乎是一种节省。回顾来看，这不是一个好决定，就像在 Unix 标准格式（以换行结束）中而不是接收格式中存储消息正文一样（可以使用换行符、回车/换行符、裸回车或换行/回车换行）。随着电子邮件世界的发展和采用的标准，重写的需要减少了，甚至看似无害的重写也存在错误的风险。

### 17.4.6\. 接受和修复虚假输入

由于 sendmail 是在多种协议和令人不安的少量书面标准的世界中创建的，我决定尽可能清理格式不正确的消息。这符合 RFC 793 中阐述的“鲁棒性原则”（又称 Postel's Law）。其中一些更改是显而易见的，甚至是必需的：当向 Arpanet 发送 UUCP 消息时，需要将 UUCP 地址转换为 Arpanet 地址，即使只是为了使“回复”命令能正确运行，行终止需要在各平台使用的约定之间转换，等等。还有一些变化不够明显：如果收到一条消息，其中不包括 Internet 规范中要求的`From:`头字段，应该添加`From:`头字段，传递不包括`From:`头字段的消息，还是拒绝消息？当时，我主要考虑的是互操作性，所以 sendmail 对消息进行了修补，例如添加了`From:`头字段。然而，据称这让其他损坏的邮件系统能够长时间存在，远超过它们应该被修复或淘汰的时间。

我认为当时我的决定是正确的，但今天却存在问题。高度的互操作性对于让邮件无阻地流动很重要。如果我拒绝格式不正确的消息，当时大多数消息都会被拒绝。如果我传递它们而不予修复，收件人将收到他们无法回复的消息，甚至在某些情况下甚至无法确定是谁发送的消息，或者消息将被另一个邮件发送程序拒绝。

今天，标准已经制定，并且在大多数情况下，这些标准是准确和完整的。不再是大多数消息会被拒绝的情况了，但仍然有一些邮件软件会发送出损坏的消息。这不必要地给互联网上的其他软件造成了许多问题。

### 17.4.7\. 配置和 M4 的使用

有一段时间，我既在定期更改 sendmail 配置文件，又在个人支持许多机器。由于不同机器之间的配置文件大部分相同，因此使用工具构建配置文件是可取的。m4 宏处理器包含在 Unix 中。它被设计为编程语言（尤其是 ratfor）的前端。最重要的是，它具有"include"功能，就像 C 语言中的"#include"一样。原始配置文件几乎只使用了这种能力和一些次要的宏扩展。

IDA sendmail 也使用了 m4，但使用方式截然不同。回顾起来，我应该更仔细地研究这些原型。它们包含了许多聪明的想法，特别是它们处理引号的方式。

从 sendmail 6 开始，m4 配置文件被完全重写为更具声明性和更小的样式。这更多地利用了 m4 处理器的能力，但当 GNU m4 的引入以微妙的方式改变了一些语义时，这就成为了问题。

最初的计划是，m4 配置将遵循 80/20 法则：它们将是简单的（因此工作的 20%），并且将涵盖 80%的情况。这很快就崩溃了，有两个原因。次要的原因是，事实证明，至少在开始时，处理绝大多数情况相对容易。随着 sendmail 和世界的发展，特别是在后来引入诸如 TLS 加密和 SMTP 身份验证等功能之后，情况变得更加困难，但这些功能直到相当晚才出现。

一个重要的原因是，人们开始清楚地意识到，原始配置文件对大多数人来说实在是太难管理了。实际上，`.cf`（原始）格式已经变成了汇编代码——原则上可编辑，但实际上相当晦涩。"源代码"是存储在`.mc`文件中的 m4 脚本。

另一个重要的区别是，原始格式的配置文件实际上是一种编程语言。它具有过程性代码（规则集）、子程序调用、参数扩展和循环（但没有 goto 语句）。语法晦涩，但在许多方面类似于`sed`和`awk`命令，至少在概念上是这样。m4 格式是声明性的：尽管可以进入低级原始语言，但在实践中，这些细节对用户是隐藏的。

当时这个决定是否正确并不清楚。我当时感觉（现在仍然感觉）对于复杂系统，实现一种用于构建系统某些部分的特定领域语言（DSL）可能是有用的。然而，将该 DSL 暴露给最终用户作为配置方法实际上将所有配置系统的尝试都转化为了一个编程问题。这样做会带来巨大的力量，但成本并不低廉。

## 17.5\. 其他考虑事项

还有几个其他的架构和开发要点值得一提。

### 17.5.1\. 关于优化互联网规模系统的一些话

在大多数基于网络的系统中，客户端和服务器之间存在紧张关系。对客户端而言的良好策略可能对服务器来说是错误的，反之亦然。例如，服务器希望通过尽可能多地将工作推迟到客户端来最小化其处理成本，而客户端当然也有相同的想法，但方向相反。例如，服务器可能希望在进行垃圾邮件处理时保持连接打开，因为这降低了拒绝消息的成本（这在当今是常见情况），但客户端希望尽快继续进行。从整个系统即整个互联网来看，最佳解决方案可能是平衡这两种需求。

曾经有过一些 MTA 使用明确偏向客户端或服务器的策略的情况。他们之所以能够这样做，只是因为他们的安装基数相对较小。当您的系统在互联网的大部分区域上使用时，您必须设计它以平衡双方的负载，以尝试优化整个互联网。这被事实上总会有 MTA 完全倾向于一边或另一边所复杂化——例如，大规模邮件系统只关心优化外发方面。

在设计涵盖连接两侧的系统时，避免偏袒某一方是很重要的。请注意，这与客户端和服务的通常不对称性形成鲜明对比——例如，Web 服务器和 Web 客户端通常不是由同一组开发者开发的。

### 17.5.2\. Milter

对于 sendmail 最重要的补充之一是 milter（邮件过滤器）接口。Milter 允许使用离板插件（即，它们在单独的进程中运行）进行邮件处理。最初这些设计用于防垃圾邮件处理。milter 协议与服务器 SMTP 协议同步运行。当从客户端接收到每个新的 SMTP 命令时，sendmail 将调用 milters 并提供该命令的信息。milter 有机会接受命令或发送拒绝，拒绝与 SMTP 命令相适应的协议阶段。milter 被建模为回调，因此当 SMTP 命令进入时，会调用适当的 milter 子例程。Milter 是多线程的，对于每个例程都会传递一个每个连接的上下文指针，以允许传递状态。

理论上，milter 可以作为可加载模块在 sendmail 地址空间中工作。我们之所以不这样做有三个原因。首先，安全问题太重要了：即使 sendmail 作为唯一的非根用户 id 运行，该用户也会访问其他消息的所有状态。同样，某些 milter 作者将试图访问内部 sendmail 状态是不可避免的。

第二，我们想在 sendmail 和 milter 之间创建一个防火墙：如果一个 milter 崩溃了，我们希望清楚地知道谁出了问题，并且邮件可以（可能）继续流动。第三，对于一个 milter 作者来说，调试一个独立的进程要比整个 sendmail 容易得多。

很快就清楚地看到，milter 不仅仅对抗垃圾邮件处理有用。事实上，milter.org 网站列出了商业公司和开源项目生产的针对防垃圾邮件、防病毒、归档、内容监控、日志记录、流量整形等许多其他类别的 milter。邮件发送器 postfix 已经使用相同的接口添加了对 milter 的支持。Milter 已被证明是 sendmail 的伟大成功之一。

### 17.5.3\. 发布时间表

"早期频繁发布" 和 "发布稳定系统" 两种思想之间存在着热烈的讨论。Sendmail 在不同的时候都使用过这两种方法。在变化很大的时候，有时我一天会做多次发布。我的一般理念是每次变更后发布。这类似于为源管理系统树提供公共访问。我个人更喜欢发布而不是提供公共源树，至少部分原因是我使用源管理的方式现在被认为是不被认可的方式：对于大的变更，我会在写代码的同时检入不起作用的快照。如果树是共享的，我会为这些快照使用分支，但无论如何它们都是对世界可见的，并且可能会造成相当大的混乱。此外，发布意味着给它一个编号，这样在处理 bug 报告时更容易跟踪变更。当然，这需要发布变得容易生成，这并不总是正确的。

随着 sendmail 被越来越多地用于关键的生产环境，这种情况开始变得棘手起来。对于其他人来说，很难区分我希望大家测试的变更和真正用于实际环境的变更。将发布标记为“alpha”或“beta”可以缓解但不能解决问题。结果是，随着 sendmail 的成熟，发布变得不那么频繁但更大规模。当 sendmail 被并入一个商业公司时，这种情况尤为严重，该公司的客户既想要最新最棒的，又只接受稳定版本，而且不愿意接受这两者是不兼容的事实。

开源开发者需求与商业产品需求之间的紧张关系永远不会消失。及早并频繁发布有许多优点，特别是可能会有庞大的勇敢（有时愚蠢）的测试人员群体，他们以几乎无法在标准开发系统中重现的方式测试系统。但随着项目的成功，它往往会变成一个产品（即使该产品是开源且免费的），而产品与项目有不同的需求。

## 17.6\. 安全

Sendmail 的安全性经历了动荡的生活。其中一些是当之无愧的，但有些则不是，因为我们对“安全性”的概念在我们之下发生了变化。互联网始于几千人的用户群体，主要是学术和研究环境中的用户。在很多方面，这是一个比今天我们所知的更加友善的互联网。网络旨在鼓励共享，而不是建立防火墙（这在早期是不存在的概念）。现在的网络是一个危险、敌对的地方，充满了垃圾邮件发送者和黑客。它越来越被描述为一个战区，在战区中有平民伤亡。

编写网络服务器是困难的，特别是当协议不仅仅是最简单的时候。几乎所有程序都至少有过轻微的问题；甚至常见的 TCP/IP 实现也曾被成功攻击过。更高级的实现语言并没有证明是万灵药，甚至还产生了自己的漏洞。必要的注意点是“不信任所有输入”，无论它来自何处。不信任输入包括来自 DNS 服务器和 milters 等次要输入。与大多数早期网络软件一样，在其早期版本中，sendmail 对此过于信任。

但 sendmail 最大的问题在于早期版本以 root 权限运行。需要 root 权限来打开 SMTP 监听套接字，读取个别用户的转发信息，并将邮件发送到个别用户的邮箱和主目录。但是，在今天的大多数系统中，邮箱名称的概念已与系统用户的概念分离，这实际上消除了除了打开 SMTP 监听套接字之外的 root 访问需求。今天的 sendmail 有能力在处理连接之前放弃 root 权限，消除了对支持它的环境的这种担忧。值得注意的是，在那些不直接发送到用户邮箱的系统上，sendmail 还可以在 chrooted 环境中运行，从而实现进一步的权限隔离。

不幸的是，随着 sendmail 获得恶劣安全记录的声誉，它开始因与 sendmail 无关的问题而受到指责。例如，一位系统管理员将他的 `/etc` 目录设为全局可写，然后当有人替换了 `/etc/passwd` 文件时却责备 sendmail。正是这类事件促使我们大幅加强了安全措施，包括明确检查 sendmail 访问的文件和目录的所有权和模式。这些措施是如此严厉，以至于我们被迫包含 `DontBlameSendmail` 选项以（选择性地）关闭这些检查。

其他安全方面与保护程序地址空间无关。例如，垃圾邮件的增加也导致了地址收集的增加。SMTP 中的 `VRFY` 和 `EXPN` 命令分别专门设计用于验证个别地址和扩展邮件列表的内容。由于这些命令被垃圾邮件发送者滥用，大多数站点现在完全关闭了它们。至少对于 `VRFY` 来说，这是不幸的，因为有时一些反垃圾邮件代理会使用此命令来验证所谓的发送地址。

同样，反病毒保护曾被视为桌面问题，但随着重要性的提高，任何商用级别的 MTA 都必须具备反病毒检查功能。现代设置中与安全相关的其他要求包括对敏感数据的强制加密、数据丢失保护和执行监管要求，例如 HIPPA。

sendmail 早期就将可靠性视为一个原则——每一条消息都应该被投递或者回报给发送者。但是 joe-jobs（许多人视为安全问题的攻击者伪造消息的回报地址）的问题导致许多站点关闭了回报消息的创建。如果在 SMTP 连接仍然打开的情况下可以确定失败，服务器可以通过失败的命令报告问题，但是在 SMTP 连接关闭后，一个错误地址的消息将会悄无声息地消失。公平地说，今天大多数合法邮件都是单跳的，因此问题会被报告，但至少从原则上讲，世界已经决定安全优于可靠性。

## 17.7\. Sendmail 的演变

软件在不断变化的环境中不会存活下来而不适应变化。新的硬件技术出现，推动操作系统的变化，推动库和框架的变化，推动应用程序的变化。如果一个应用程序成功了，它将在越来越有问题的环境中使用。变化是不可避免的；要成功，你必须接受和拥抱变化。本节描述了 sendmail 发展过程中发生的一些更重要的变化。

### 17.7.1\. 配置变得更加冗长

sendmail 的原始配置非常简洁。例如，选项和宏的名称都是单个字符。有三个原因。首先，这样做使得解析非常简单（在 16 位环境中很重要）。其次，选项并不多，因此很容易想出助记名称。第三，单字符约定已经与命令行标志建立了起来。

同样，重写规则集最初是用编号而不是名称命名的。这在规则集数量较少时可能是可以容忍的，但随着规则集数量的增加，拥有更有助记性的名称变得更加重要。

随着 sendmail 运行环境变得更加复杂，并且 16 位环境逐渐消失，更丰富的配置语言的需求变得明显。幸运的是，可以以向后兼容的方式进行这些更改。这些更改大大提高了配置文件的可理解性。

### 17.7.2\. 与其他子系统的更多连接：更大的集成

当 sendmail 被编写时，邮件系统基本上与操作系统的其余部分隔离开来。有一些服务需要集成，例如 `/etc/passwd` 和 `/etc/hosts` 文件。服务开关尚未被发明，目录服务不存在，配置较小且手工维护。

情况很快就改变了。最早的添加之一是 DNS。虽然系统主机查找抽象化（`gethostbyname`）可用于查找 IP 地址，但电子邮件必须使用其他查询，如 MX。稍后，IDA sendmail 包含了使用 dbm(3) 文件的外部数据库查找功能。Sendmail 8 将其更新为通用映射服务，允许其他数据库类型，包括外部数据库和无法使用重写完成的内部转换（例如，解除地址引用）。

如今，电子邮件系统依赖许多通常并非专门为电子邮件的独占使用而设计的外部服务。这导致 sendmail 在代码中更多地使用抽象化。随着更多的“移动部件”被添加，维护邮件系统也变得更加困难。

### 17.7.3\. 适应恶劣环境

Sendmail 是在今天看来完全陌生的世界中发展起来的。早期网络上的用户主要是研究人员，尽管有时存在激烈的学术政治斗争，但他们大多相对温和。Sendmail 反映了它所创建的世界，非常注重尽可能可靠地传递邮件，即使面对用户错误。

如今的世界更加恶劣。绝大多数电子邮件都是恶意的。MTA 的目标已经从通过邮件转发变为阻止垃圾邮件。对于任何 MTA 来说，过滤可能是首要任务。这要求 sendmail 进行了许多更改。

例如，已经添加了许多规则集，允许检查传入 SMTP 命令的参数，以尽早发现问题。在读取信封时拒绝邮件要比读取整个邮件后再拒绝要便宜得多，甚至在接受邮件以便递送后再拒绝也更昂贵。在早期，过滤通常是通过接受邮件、将其传递给过滤程序，然后在邮件通过时将其发送到另一个 sendmail 实例（所谓的“三明治”配置）来完成的。但在今天的世界中，这种方法太过昂贵。

同样，sendmail 已经从一个相当普通的 TCP/IP 连接消费者发展为更加复杂，做一些像“窥视”网络输入以查看发送者是否在之前的命令得到确认之前传输命令的事情。这破坏了一些旨在使 sendmail 适应多种网络类型的先前抽象化。例如，今天要将 sendmail 连接到 XNS 或 DECnet 网络将涉及大量工作，因为对 TCP/IP 的了解已经构建到代码的很多部分中。

添加了许多配置功能以应对敌对世界，例如支持访问表、实时黑洞列表、地址收集缓解、拒绝服务保护和垃圾邮件过滤。这极大地复杂化了配置邮件系统的任务，但绝对有必要适应当今的世界。

### 17.7.4\. 新技术的整合

多年来出现了许多新的标准，这些标准要求对 sendmail 进行重大更改。例如，添加 TLS（加密）需要对大部分代码进行重大更改。SMTP 管道需要查看低级 TCP/IP 流以避免死锁。添加提交端口（587）需要能够监听多个传入端口，并根据到达端口的不同行为。

其他压力是由情况而非标准造成的。例如，添加 milter 接口是对垃圾邮件的直接响应。虽然 milter 不是一个公开的标准，但它是一个重大的新技术。

在所有情况下，这些变化都在某种程度上增强了邮件系统，无论是增加了安全性、提高了性能，还是增加了新功能。然而，它们都伴随着成本，在几乎所有情况下都使代码库和配置文件变得更加复杂。

## 17.8\. 如果今天我再做一次呢？

事后诸葛亮。今天有许多事情我会做得不同。有些在当时是无法预料的（例如，垃圾邮件将如何改变我们对电子邮件的看法，现代工具集会是什么样子等），有些是可以预见的。有些只是在编写 sendmail 的过程中，我对电子邮件、TCP/IP 和编程本身有了很多了解——每个人在编程时都在成长。

但也有许多事情我会做相同的，有些事情与标准智慧相矛盾。

### 17.8.1\. 我会做出不同选择的事情

或许我在 sendmail 上犯的最大错误是没有及早认识到它将会有多重要。我有几次机会来引导世界朝正确的方向发展，但我没有抓住它们；事实上，在某些情况下，我做了损害，例如，当适当时没有让 sendmail 对不良输入更加严格。同样，我很早就意识到需要改进配置文件语法，当时可能只有几百个 sendmail 实例部署了，但我决定不改变事情，因为我不想给已安装的用户群带来不必要的痛苦。回想起来，更好的做法是早点改进事情，引起暂时的痛苦以获得更好的长期结果。

#### 第 7 版邮箱语法

其中一个例子是第 7 版邮箱分隔消息的方式。它们使用以"From␣"开头的行（其中"␣"代表 ASCII 空格字符，0x20）来分隔消息。如果一封消息以"From␣"开头的行进来，本地邮箱软件会将其转换为">From␣"。某些但不是所有系统上的一种改进是需要前置空行，但这不能依赖。直到今天，">From" 出现在极其意想不到的与电子邮件不明显相关的地方（但显然曾经或多或少地被电子邮件处理过）。回顾起来，我可能本可以将 BSD 邮件系统转换为使用新语法。当时人们可能会咒骂我，但我会为世界节省大量麻烦。

#### 配置文件的语法和内容

在配置文件的语法方面，我可能犯的最大错误是在重写规则中使用制表符（HT，0x09）来分隔模式和替换内容。当时我在模仿 make，直到多年后才了解到 make 的作者斯图尔特·费尔德曼认为那是他的一大错误之一。除了在屏幕上查看配置时不明显之外，制表符在大多数窗口系统中无法进行剪切和粘贴。

尽管我认为重写规则是正确的想法（请参见下文），但我会改变配置文件的一般结构。例如，我没有预料到配置中需要层次结构（例如，为不同的 SMTP 监听端口设置不同的选项）。在设计配置文件时，当时没有“标准”格式。如今，我倾向于使用类似 Apache 样式的配置文件——它清晰、整洁，并且具有足够的表达能力——或者甚至嵌入一种语言，比如 Lua。

当 sendmail 被开发时，地址空间较小，协议仍在不断发展。尽可能多地放入配置文件中似乎是个好主意。今天看来，那看起来是个错误：我们有足够的地址空间（对于 MTA 来说），而且标准相对稳定。此外，“配置文件”的一部分实际上是需要在新版本中更新的代码。 `.mc` 配置文件解决了这个问题，但是每次更新软件时都必须重新构建配置文件很麻烦。一个简单的解决方案就是有两个 sendmail 会读取的配置文件，一个隐藏的文件，每次新软件发布时安装，并且另一个暴露出来用于本地配置。

#### 工具的使用

今天有许多新的工具可用，例如，用于配置和构建软件的工具。如果需要，工具可以起到很好的 leverage 作用，但它们也可能过度，使理解系统比必要的更加困难。例如，当你所需的只是 strtok(3)时，绝不应该使用 yacc(1)语法。但是重新发明轮子也不是一个好主意。特别是，尽管有一些保留，但我几乎肯定会今天使用 autoconf。

#### 向后兼容

有了后见之明，并且知道 sendmail 变得多么普遍，我不会在开发早期太担心破坏现有的安装。当现有的做法严重有问题时，应该修复，而不是迁就。也就是说，我仍然不会严格检查所有消息格式；有些问题可以很容易地安全地忽略或修补。例如，我可能仍然会在没有`Message-Id：`头字段的消息中插入一个，但我更倾向于拒绝没有`From：`头字段的消息，而不是尝试从信封中的信息创建一个。

#### 内部抽象

有一些内部抽象我不会再尝试，还有一些我会添加。例如，我不会再使用空终止的字符串，而是选择长度/值对，尽管这意味着大部分标准 C 库变得难以使用。单单这个安全隐患就值得这样做。相反，我不会尝试在 C 中构建异常处理，但我会创建一个一致的状态码系统，该系统将在整个代码中使用，而不是使例程返回`null`，`false`或负数来表示错误。

我肯定会将邮箱名称的概念从 Unix 用户 ID 中抽象出来。在我写 sendmail 的时候，模型是你只能向 Unix 用户发送消息。今天，这几乎从不是这样的情况；即使在使用该模型的系统上，也有一些系统账户不应该接收电子邮件。

### 17.8.2\. 我会做同样的事情

当然，有些事情确实*做得不错*...

#### Syslog

sendmail 的一个成功的副产品之一是 syslog。当时写 sendmail 时，需要记录日志的程序有一个特定的文件，它们会写入。这些文件分散在文件系统中。编写 syslog 当时很困难（UDP 还不存在，所以我使用了一个叫做 mpx 文件的东西），但非常值得。然而，我会做一个具体的改变：我会更加关注使日志消息的语法可机器解析——基本上，我未能预测到日志监视的存在。

#### 重写规则

重写规则曾经受到很多抨击，但我会再次使用它们（尽管可能不会像现在这样用于很多事情）。使用制表符是一个明显的错误，但考虑到 ASCII 的限制和电子邮件地址的语法，可能需要一些转义字符。总的来说，使用模式替换范式的概念效果很好，并且非常灵活。

#### 避免不必要的工具

尽管我上面评论说我会使用更多现有工具，但我不太愿意使用当今许多可用的运行时库。在我看来，其中太多的库太过臃肿，以至于危险。库应该谨慎选择，权衡重用的优点和使用过于强大的工具解决简单问题的问题。我要避免使用的一个特定工具是 XML，至少作为配置语言。我认为它的语法对于它现在所用的很多内容来说过于花哨。XML 有它的用处，但是现在被过度使用了。

#### C 语言中的代码

有人建议更自然的实现语言是 Java 或 C++。尽管 C 存在众所周知的问题，但我仍然会将其作为我的实现语言。部分原因是个人原因：我比了解 Java 或 C++ 更了解 C。但我也对大多数面向对象语言对内存分配的漫不经心的态度感到失望。内存分配有许多性能方面的问题，很难描述。Sendmail 在适当的情况下（例如，映射类的实现）在内部使用面向对象的概念，但在我看来，完全面向对象是浪费的，并且过于限制性。

## 17.9\. 结论

Sendmail MTA 诞生于一个巨大动荡的世界中，一种在电子邮件是临时性的、当前的邮件标准尚未制定时存在的“荒野”环境中。在这 31 年的时间里，“电子邮件问题”已经从仅仅可靠地工作变成了处理大型消息和大量负载，再到保护站点免受垃圾邮件和病毒的侵害，最终演变成今天被用作大量基于电子邮件的应用程序平台的一部分。Sendmail 已经发展成为一个被即使是最不愿冒险的公司所接受的工作马，即使在电子邮件已经从纯文本个人之间的通信演变成为基础设施中基于多媒体的使命关键部分的情况下也是如此。

这种成功的原因并不总是显而易见。在一个只有少数兼职开发人员的快速变化的世界中建立一个能够生存甚至蓬勃发展的程序，无法通过传统的软件开发方法论来实现。我希望我已经提供了一些关于 sendmail 成功的见解。
