["```\nfunc response(input string) (output string) {\n    return \"I'm not sure I understand you fully\"\n}\nfunc main() {\n    fmt.Println(\"How do you do.  Please tell me your problem.\")\n    defer fmt.Println(\"Goodbye.  It was nice talking to you.\")\n    scanner := bufio.NewScanner(os.Stdin)\n    for scanner.Scan() {\n        reply := respond(scanner.Text())\n        if reply == \"\" { // no reply = end of conversation\n break\n        }\n        fmt.Println(reply)\n    }\n} \n```", "```\nvar quit = []string{\"bye\", \"goodbye\", \"done\", \"exit\", \"quit\"}\n\nfunc respond(input string) string {\n  q := strings.ToLower(strings.TrimSpace(input))\n  if contains(q, quit) {\n    return \"\"\n  }\n  ...\n}\n\n// > How do you do.  Please tell me your problem. // : Bye // > Goodbye.  It was nice talking to you. \n```", "```\nkeyword:  \"sorry\"  rules:  - match:  \"*\"   reasmb:   - Please don't apologise.   - Apologies are not necessary.   - I've told you that apologies are not required.   - It did not bother me.  Please continue. \n```", "```\n> How do you do.  Please tell me your problem.\n: Oh sorry\n> Please don't apologise. \n```", "```\nkeyword: \"you\"\nrules:\n- match: \"* you * me\"\n  reasmb:\n  - \"What makes you think I (2) you ?\"\n  - \"You like to think I (2) you -- don't you ?\"\n  - \"Really, I (2) you ?\"\n- match: \"* you are *\"\n  - \"What makes you think I am (2) ?\" \n```", "```\nkeyword: \"i\"\nrules:\n- match: \"* i /belief i *\"\n  reasmb:\n  - \"Do you really think so ?\",\n  - \"But you are not sure you (2).\",\n  - \"Do you really doubt you (2) ?\"), \n```", "```\nkeyword: \"apologise\"\nrules:\n- match: \"*\"\n  reasmb:\n  - \"=sorry\"\nkeyword: \"can\"\nrules:\n- match: \"* can you *\"\n  reasmb:\n  - \"You believe I can (2) don't you ?\"\n  - \"=what\"\nkeyword: \"what\"\nrules:\n- match: \"*\"\n  reamb:\n  - \"Why do you ask ?\"\n  - \"Does that question interest you ?\" \n```", "```\n> How do you do.  Please tell me your problem.\n: My chatbot is misbehaving\n> Lets discuss further why your chatbot is misbehaving.\n: It pretends being intelligent while it's not\n> Lets discuss further why your chatbot is misbehaving.\n: See?\n> Please go on. \n```", "```\ntype Keyword struct {\n  Word   string\n  Rank   int\n  Decomp []Decomp\n}\n\ntype Decomp struct {\n  Match  string\n  Save   bool\n  Reasmb []string\n}\n\nvar keywords = []Keyword{\n  {\n    \"sorry\", // keyword\n 0,       // rank to sort the keywords\n []Decomp{\n      Decomp{\"*\", false,\n        []string{\n          \"Please don't apologise.\",\n          \"Apologies are not necessary.\",\n          ...\n        },\n      },\n    },\n  },\n  ...\n}\n\nvar (\n  pre = map[string]string{\n    \"dont\":       \"don't\",\n     ...\n  }\n    post = map[string]string{\n    \"am\":       \"are\",\n    \"your\":     \"my\",\n    ...\n  }\n  quit = []string{\"bye\", \"goodbye\", \"done\", \"exit\", \"quit\"}\n  syn  = map[string][]string{\n    \"be\":       []string{\"be\", \"am\", \"is\", \"are\", \"was\"},\n    \"belief\":   []string{\"belief\", \"feel\", \"think\", \"believe\", \"wish\"},\n    ...\n  }\n  fallback = []string{\n    \"I'm not sure I understand you fully.\",\n    \"Please go on.\",\n    ...\n  }\n) \n```", "```\nvar (\n  index = map[string]int{}\n  mem   []string\n) \n```", "```\nfunc replace(words []string, mapping map[string]string) (res []string) {\n  for _, w := range words {\n    if s, ok := mapping[w]; ok {\n      res = append(res, strings.Fields(s)...)\n    } else {\n      res = append(res, w)\n    }\n  }\n  return res\n}\n\nreplace(strings.Fields(\"i think you're a machine\"}, pre)\n// -> [\"i\", \"think\", \"you\", \"are\", \"a\", \"computer\"] replace(replace(strings.Fields(\"i think you're a machine\"}, pre), post)\n// -> [\"you\", \"think\", \"i\", \"am\", \"a\", \"computer\"] \n```", "```\nfunc match(pat, words []string) ([]string, bool) {\n  if len(pat) == 0 && len(words) == 0 {\n    // Both, pattern and text are empty: match!\n return nil, true\n  } else if len(pat) == 0 || (len(words) == 0 && (len(pat) != 1 || pat[0] != \"*\")) {\n    // Pattern is empty but some words left, or\n // Words are empty but pattern has some text left: no match!\n return nil, false\n  } else if pat[0] == \"*\" {\n    // Wildcard: be greedy, as long as the \"tails\" match!\n for i := len(words); i >= 0; i-- {\n      if m, ok := match(pat[1:], words[i:]); ok {\n        g := strings.Join(replace(words[:i], post), \" \")\n        return append([]string{g}, m...), true\n      }\n    }\n    return nil, false\n  } else if strings.HasPrefix(pat[0], \"/\") {\n    // Synonym: compare to one of the words in that category\n if slices.Contains(syn[pat[0][1:]], words[0]) {\n      if m, ok := match(pat[1:], words[1:]); ok {\n        return append([]string{words[0]}, m...), true\n      }\n    }\n    return nil, false\n  } else if pat[0] != words[0] {\n    // Literal word in pattern does not match the text: no match!\n return nil, false\n  }\n  // Seems to match so far, compare the rest!\n return match(pat[1:], words[1:])\n}\n\n// // func split(s) []string { ... } // // match(split(\"\"), split(\"\")) -> true // match(split(\"foo\"), split(\"foo\")) -> true // match(split(\"foo\"), split(\"bar\")) -> false // match(split(\"foo\"), split(\"bar\")) -> false // match(split(\"a * b\"), split(\"a b c d e b\")) -> true (1)=\"b c d e\" // match(split(* a * b *), split(\"a b c\")) -> true (1)=\"\", (2)=\"\", (3)=\"c\" \n```", "```\nfunc respond(q string) string {\n  q = strings.ToLower(strings.TrimSpace(q))\n  // Handle stop words\n if slices.Contains(quit, q) {\n    return \"\"\n  }\n  // Split into words and preprocess\n words := replace(strings.Fields(q), pre)\n  // Find a keyword\n for _, k := range keywords {\n    if slices.Contains(words, k.Word) {\n    nextKey:\n      // Find matching transformation rule\n for i, d := range k.Decomp {\n        if m, ok := match(strings.Fields(d.Match), words); ok {\n          // Choose the next reassembly\n id := fmt.Sprintf(\"%s:%d\", k.Word, i)\n          reply := d.Reasmb[index[id]]\n          index[id] = (index[id] + 1) % len(d.Reasmb)\n          // Handle \"goto\" rules\n if strings.HasPrefix(reply, \"=\") {\n            for _, nextk := range keywords {\n              if nextk.Word == reply[1:] {\n                k = nextk\n                goto nextKey\n              }\n            }\n          }\n          // Replace placeholders with phrases from user input\n for i, s := range m {\n            reply = strings.ReplaceAll(reply, fmt.Sprintf(\"(%d)\", i+1), s)\n          }\n          // Memorise the reply, if needed\n if d.Save {\n            mem = append(mem, reply)\n          }\n          return reply\n        }\n      }\n    }\n  }\n  // Try to use memory before admitting that we don't have a clue what a user is talking about\n if len(mem) > 0 {\n    reply := mem[len(mem)-1]\n    mem = mem[:len(mem)-1]\n    return reply\n  }\n  index[\"fallback\"] = (index[\"fallback\"] + 1) % len(fallback)\n  return fallback[index[\"fallback\"]]\n} \n```"]