<!--yml

类别：未分类

日期：2024-05-27 17:09:36

-->

# A*寻路的小技巧 | Tim Mastny

> 来源：[`timmastny.com/blog/a-star-tricks-for-videogame-path-finding/`](https://timmastny.com/blog/a-star-tricks-for-videogame-path-finding/)

这是一些小技巧，可以使算法运行更快，实现更容易。

### 隐式图数据结构

在教科书中，图形由节点列表和邻接矩阵或邻接列表表示。但是，您可以在表示邻接节点方面更加灵活一些。

例如，假设我们的游戏屏幕有 256 * 240 个像素。我们将每个像素的坐标称为一个节点。然后，我们可以说有 8 个相邻像素：上、下、左、右以及 4 个对角线。基本方向的权重为 1，而对角线的权重为根号 2（约 1.4）。

我们不需要创建一个庞大的邻接列表：我们可以动态生成它。此外，并非每个像素都是怪物的有效位置：它可能在墙上或被其他精灵占用。在这种情况下，我们可以动态地从邻接列表中排除该像素。

这可能会是这样的：

```
# suppose current is some data structure with x and y coordinates
neighbors = [current + dir for dir in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]]

for neighbor in neighbors:
    if out_of_bounds(neighbor) or occupied(neighbor):
        continue
    # do something with neighbor
```

因此，我们只需要为我们实际要访问的节点生成邻接列表，而不必使用地图编辑器手动排除相邻节点。

### 基于几何信息的启发式

您还可以根据地图的几何结构手动调整算法的某些方面。

#### 步长

在前面我讨论了将像素用作节点的方法，但在二维基于瓦片的游戏中，您可以将瓦片用作节点。这将大大加速搜索，因为怪物可以在较少的迭代次数内找到通往玩家的路径。

使用这种方法，路径实际上不是一系列精确的步骤：您的怪物很可能不是以每帧 1 个瓦片的速度移动。现在路径是怪物应该走的一系列*方向*。

没问题！正如我在 Dijkstra 部分中所说的，我们的怪物实际上并不关心确切的路径，因为路径每帧都在变化，玩家移动时也在变化。它只需要朝着可能到达玩家的方向移动（即不要直接撞墙）。

#### 迭代深度

A*算法的一个很酷的特性：一旦一个节点从优先队列中移除，我们就知道该节点代表了到目前为止我们见过的最佳路径的最后一步。因此，如果我们在固定的迭代次数内停止算法，我们就会知道得到的路径是到达目的地的最佳猜测路径。因此，即使不运行完整的算法，我们也可以取得合理的进展。

您需要调整这个最大迭代深度以适应关卡的几何形状。例如，如果深度太小，怪物仍然可能被困在墙后面：

![](img/3e5f1df81a892e847c511804471ebf12.png)

当固定迭代深度为`30`个瓷砖时，我们可以将玩家定位在怪物被陷阱困住且无法朝向玩家前进的位置。这是怎么发生的？请记住，每帧都会重新计算 A*。在第一帧达到墙壁时，怪物计算应该向下移动。但在下一帧，它计算应该向上移动。这导致怪物陷入循环。但是，一旦玩家移动到它的范围内，怪物就能够正确地找到通往玩家的路径。

当固定深度为`1`时，您可以看到这种效果被夸大了：

```
 frame 1    frame 2

4
3     | .        | m
2   p | m      p | .
1     |          |
0
```

怪物总是返回到像素 2，因为它是与玩家之间的最短（欧几里得）距离。

如果你想要真正花哨，你可以预先计算 A*需要从地图上任意位置找到路径的最大深度。与预先计算的 Dijkstra 不同，您只需保存该最大值，因为您知道 A*会在实时中找到有效路径，给定该最大深度。
