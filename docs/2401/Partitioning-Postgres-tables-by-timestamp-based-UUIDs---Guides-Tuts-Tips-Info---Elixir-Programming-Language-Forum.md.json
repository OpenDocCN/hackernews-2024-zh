["```\n @doc \"\"\"\n  Slices the time portion of a ULID\n  \"\"\"\n  def ulid_time(ulid), do: String.slice(ulid, 0..9)\n\n  @doc \"\"\"\n  Returns the time based start of a ULID\n  \"\"\"\n  def ulid_start_time(ulid), do: ulid_time(ulid) |> String.pad_trailing(26, \"0\")\n\n  @doc \"\"\"\n  Returns the time based end of a ULID\n  \"\"\"\n  def ulid_end_time(ulid), do: ulid_time(ulid) |> String.pad_trailing(26, \"Z\")\n\n  @doc \"\"\"\n  Returns the time based ULID with bounds from a Date or DateTime\n  \"\"\"\n  def datetime_to_ulid(datetime, bound \\\\ nil)\n\n  def datetime_to_ulid(date = %Date{}, bound),\n    do: DateTime.new!(date, Time.new!(0, 0, 0)) |> datetime_to_ulid(bound)\n\n  def datetime_to_ulid(datetime = %DateTime{}, bound) do\n    case bound do\n      nil -> DateTime.to_unix(datetime, :millisecond) |> Ecto.ULID.generate()\n      :start -> datetime_to_ulid(datetime) |> ulid_start_time()\n      :end -> datetime_to_ulid(datetime) |> ulid_end_time()\n    end\n  end\n\n  def datetime_to_ulid(naive_datetime = %NaiveDateTime{}, bound),\n    do: DateTime.from_naive!(naive_datetime, \"Etc/UTC\") |> datetime_to_ulid(bound) \n```", "```\n@primary_key {:id, ULID, autogenerate: false} \n```", "```\n defp create_id_if_not_exsits(changeset) do\n    case get_change(changeset, :id) do\n      nil ->\n        occurred_at = get_change(changeset, :occurred_at)\n        put_change(changeset, :id, ULIDUtils.datetime_to_ulid(occurred_at))\n\n      _ ->\n        changeset\n    end\n  end \n```", "```\n def changeset(changeset, attrs) do\n    changeset\n    # ...\n    |> create_id_if_not_exsits()\n    # other methods \n```", "```\n defp beginning_of_month(date) do\n    if date.day == 1 do\n      date\n    else\n      Date.add(date, -(date.day - 1))\n    end\n  end\n\n  defp calculate_next_month(date, 0), do: date\n\n  defp calculate_next_month(date, months) do\n    next = Date.add(date, Date.days_in_month(date))\n    calculate_next_month(next, months - 1)\n  end\n\n  def months_from(date, num_months) do\n    start_date = beginning_of_month(date)\n\n    for months <- 0..num_months do\n      calculate_next_month(start_date, months)\n    end\n  end \n```", "```\ndef create_partition_query(table, date) do\n    start_date = date\n\n    stop_date =\n      date\n      |> Date.add(Date.days_in_month(date))\n      |> Date.add(-1)\n\n    month =\n      start_date.month\n      |> Integer.to_string()\n      |> String.pad_leading(2, \"0\")\n\n    stop_datetime = DateTime.new!(stop_date, Time.new!(23, 59, 59, 999_999))\n    end_ulid = datetime_to_ulid(stop_datetime, :end)\n\n    start_ulid = datetime_to_ulid(start_date, :start)\n\n    \"\"\"\n    CREATE TABLE #{table}_p#{start_date.year}#{month}\n    PARTITION OF #{table} FOR VALUES\n    FROM (ulid_to_uuid('#{start_ulid}'))\n    TO (ulid_to_uuid('#{end_ulid}'))\n    \"\"\"\n  end \n```", "```\n create table(:payloads, primary_key: false, options: \"PARTITION BY RANGE(id)\") do\n      add(:id, :binary_id, null: false, primary_key: true)\n\n      # ... other fields and references\n    end\n\n    # Create the default table that will ingest entries that don't match the ranges.\n    # This is not strictly necessary but means that id's that aren't in the ranges we\n    # declared don't create an error\n    execute(\"CREATE TABLE payloads_default PARTITION OF payloads DEFAULT\")\n\n    # Create 48 months worth of partitions starting from 2022-01-01\n    for month <- ULIDUtils.months_from(~D[2022-01-01], 48) do\n      query = ULIDUtils.create_partition_query(\"payloads\", month)\n      execute(query)\n    end \n```", "```\n query\n    |> where(\n        query,\n        [p],\n        fragment(\"? >= ulid_to_uuid(?)\", p.id, ^ULIDUtils.datetime_to_ulid(from, :start))\n    ) \n```"]