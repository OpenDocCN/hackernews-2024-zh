<!--yml
category: 未分类
date: 2024-05-27 14:51:43
-->

# Solving olympiad geometry without human demonstrations | Nature

> 来源：[https://www.nature.com/articles/s41586-023-06747-5](https://www.nature.com/articles/s41586-023-06747-5)

### Geometry representation

General-purpose formal languages such as Lean^([31](/articles/s41586-023-06747-5#ref-CR31 "de Moura, L. & Ullrich, S. in Proc. 28th International Conference on Automated Deduction, CADE 28 (eds Platzer, A. & Sutcliffe, G.) 625–635 (Springer, 2021).")) still require a large amount of groundwork to describe most IMO geometry problems at present. We do not directly address this challenge as it requires deep expertise and substantial research outside the scope of theorem-proving methodologies. To sidestep this barrier, we instead adopted a more specialized language used in GEX^([10](/articles/s41586-023-06747-5#ref-CR10 "Chou, S. C., Gao, X. S. & Zhang, J. Z. A deductive database approach to automated geometry theorem proving and discovering. J. Autom. Reason. 25, 219–246 (2000).")), JGEX^([17](/articles/s41586-023-06747-5#ref-CR17 "Ye, Z., Chou, S. C. & Gao, X. S. in Proc. Automated Deduction in Geometry: 7th International Workshop, ADG 2008 (eds Sturm, T. & Zengler, C.) 189–195 (Springer, 2011).")), MMP/Geometer^([13](/articles/s41586-023-06747-5#ref-CR13 "Gao, X. S. & Lin, Q. in Proc. Automated Deduction in Geometry: 4th International Workshop, ADG 2002 (ed. Winkler, F.) 44–66 (Springer, 2004).")) and GeoLogic^([19](/articles/s41586-023-06747-5#ref-CR19 "Olšák, M. in Proc. 7th International Conference on Mathematical Software – ICMS 2020 (eds Bigatti, A., Carette, J., Davenport, J., Joswig, M. & de Wolff, T.) 263–271 (Springer, 2020).")), a line of work that aims to provide a logical and graphical environment for synthetic geometry theorems with human-like non-degeneracy and topological assumptions. Examples of this language are shown in Fig. [1d,f](/articles/s41586-023-06747-5#Fig1). Owing to its narrow formulation, 75% of all IMO geometry problems can be adapted to this representation. In this type of geometry environment, each proof step is logically and numerically verified and can also be evaluated by a human reader as if it is written by IMO contestants, thanks to the highly natural grammar of the language. To cover more expressive algebraic and arithmetic reasoning, we also add integers, fractions and geometric constants to the vocabulary of this language. We do not push further for a complete solution to geometry representation as it is a separate and extremely challenging research topic that demands substantial investment from the mathematical formalization community.

### Sampling consistent theorem premises

We developed a constructive diagram builder language similar to that used by JGEX^([17](/articles/s41586-023-06747-5#ref-CR17 "Ye, Z., Chou, S. C. & Gao, X. S. in Proc. Automated Deduction in Geometry: 7th International Workshop, ADG 2008 (eds Sturm, T. & Zengler, C.) 189–195 (Springer, 2011).")) to construct one object in the premise at a time, instead of freely sampling many premises that involve several objects, therefore avoiding the generation of a self-contradicting set of premises. An exhaustive list of construction actions is shown in Extended Data Table [1](/articles/s41586-023-06747-5#Tab2). These actions include constructions to create new points that are related to others in a certain way, that is, collinear, incentre/excentre etc., as well as constructions that take a number as its parameter, for example, “construct point X such that given a number *α*, ∠ABX = *α*”. One can extend this list with more sophisticated actions to describe a more expressive set of geometric scenarios, improving both the synthetic data diversity and the test-set coverage. A more general and expressive diagram builder language can be found in ref. ^([32](/articles/s41586-023-06747-5#ref-CR32 "Krueger, R., Han, J. M. & Selsam, D. in Proc. 28th International Conference on Automated Deduction, CADE 28 (eds Platzer, A. & Sutcliffe, G.) 577–588 (Springer, 2021).")). We make use of a simpler language that is sufficient to describe problems in IMO-AG-30 and can work well with the symbolic engine DD.

### The symbolic deduction engine

The core functionality of the engine is deducing new true statements given the theorem premises. Deduction can be performed by means of geometric rules such as ‘If X then Y’, in which X and Y are sets of geometric statements such as ‘A, B, C are collinear’. We use the method of structured DD^([10](/articles/s41586-023-06747-5#ref-CR10 "Chou, S. C., Gao, X. S. & Zhang, J. Z. A deductive database approach to automated geometry theorem proving and discovering. J. Autom. Reason. 25, 219–246 (2000)."),[17](/articles/s41586-023-06747-5#ref-CR17 "Ye, Z., Chou, S. C. & Gao, X. S. in Proc. Automated Deduction in Geometry: 7th International Workshop, ADG 2008 (eds Sturm, T. & Zengler, C.) 189–195 (Springer, 2011).")) for this purpose as it can find the deduction closure in just seconds on standard non-accelerator hardware. To further enhance deduction, we also built into AlphaGeometry the ability to perform deduction through AR. AR enable proof steps that perform angle/ratio/distance chasing. Detailed examples of AR are shown in Extended Data Table [2](/articles/s41586-023-06747-5#Tab3). Such proof steps are ubiquitous in geometry proofs, yet not covered by geometric rules. We expand the Gaussian elimination process implemented in GeoLogic^([19](/articles/s41586-023-06747-5#ref-CR19 "Olšák, M. in Proc. 7th International Conference on Mathematical Software – ICMS 2020 (eds Bigatti, A., Carette, J., Davenport, J., Joswig, M. & de Wolff, T.) 263–271 (Springer, 2020).")) to find the deduction closure for all possible linear operators in just seconds. Our symbolic deduction engine is an intricate integration of DD and AR, which we apply alternately to expand the joint closure of known true statements until expansion halts. This process typically finishes within a few seconds to at most a few minutes on standard non-accelerator hardware.

### Algebraic reasoning

There has not been a complete treatment for algebraic deduction in the literature of geometry theorem proving. For example, in iGeoTutor^([12](/articles/s41586-023-06747-5#ref-CR12 "Wang, K. & Su, Z. in Proc. Twenty-Fourth International Joint Conference on Artificial Intelligence (IJCAI 2015) (ACM, 2015).")), Z3 (ref. ^([33](/articles/s41586-023-06747-5#ref-CR33 "de Moura, L. & Bjørner, N. in Proc. 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS 2008 (eds Ramakrishnan, C. R. & Rehof, J.) 337–340 (Springer, 2008)."))) is used to handle arithmetic inferences but algebraic manipulations are not covered. DD (ref. ^([17](/articles/s41586-023-06747-5#ref-CR17 "Ye, Z., Chou, S. C. & Gao, X. S. in Proc. Automated Deduction in Geometry: 7th International Workshop, ADG 2008 (eds Sturm, T. & Zengler, C.) 189–195 (Springer, 2011)."))) handles algebraic deductions by expressing them under a few limited deduction rules, therefore, it is unable to express more complex manipulations, leaving arithmetic inferences not covered. The most general treatment so far is a process similar that in ref. ^([34](/articles/s41586-023-06747-5#ref-CR34 "Todd, P. A method for the automated discovery of angle theorems. EPTCS 352, 148–155 (2021).")) for angle-only theorem discovery and implemented in GeoLogic^([19](/articles/s41586-023-06747-5#ref-CR19 "Olšák, M. in Proc. 7th International Conference on Mathematical Software – ICMS 2020 (eds Bigatti, A., Carette, J., Davenport, J., Joswig, M. & de Wolff, T.) 263–271 (Springer, 2020).")) for both angle and ratios. We expanded this formulation to cover all reasoning about angles, ratios and distances between points and also arithmetic reasoning with geometric constants such as ‘pi’ or ‘1:2’. Concrete examples of algebraic reasoning are given in Extended Data Table [2](/articles/s41586-023-06747-5#Tab3).

On a high level, we first convert the input linear equations to a matrix of their coefficients. In particular, we create a coefficient matrix *A* ∈ *R*^(*M*×*N*) in which *N* is the number of variables and *M* is the number of input equations. In geometry, any equality is of the form *a* − *b* = *c* − *d* ⇔ *a* − *b* − *c* + *d* = 0\. For example, the angle equality ∠ABC = ∠XYZ is represented as *s*(AB) − *s*(BC) = *s*(XY) − *s*(YZ), in which *s*(AB) is the angle between AB and the x-direction, modulo pi. Similarly, ratios AB:CD = EF:GH are represented as log(AB) − log(CD) = log(EF) − log(GH), in which log(AB) is the log of the length of segment AB. For distances, each variable is a (point, line) pair, representing a specific point on a specific line.

Because all equalities are of the form ‘*a* − *b* − *c* + *d* = 0’, we populate the row for each equality with values +1, −1, −1, +1 at columns corresponding to variables *a*, *b*, *c* and *d*. Running Gaussian elimination on A returns a new matrix with leading 1s at each of the columns, essentially representing each variable as a unique linear combination of all remaining variables. As an example, suppose we have ‘*a* − *b* = *b* − *c*’, ‘*d* − *c* = *a* − *d*’ and ‘*b* − *c* = *c* − *e*’ as input equalities, running the Gaussian elimination process (denoted GE in the following equation) returns the following result:

$$(\begin{array}{ccccc}a & b & c & d & e\\ 1 & -2 & 1 & 0 & 0\\ -1 & 0 & -1 & 2 & 0\\ 0 & 1 & -2 & 0 & 1\end{array})\,\mathop{\to }\limits^{GE}(\begin{array}{ccccc}a & b & c & d & e\\ 1 & 0 & 0 & -1.5 & 0.5\\ 0 & 1 & 0 & -1 & 0\\ 0 & 0 & 1 & -0.5 & -0.5\end{array})\Rightarrow \{\begin{array}{c}a=1.5d-0.5e\\ b=d\\ c=0.5d+0.5e\end{array}$$

From this result, we can deterministically and exhaustively deduce all new equalities by checking if *x*[1] = *x*[2] or *x*[1] − *x*[2] = *x*[2] − *x*[3] or *x*[1] − *x*[2] = *x*[3] − *x*[4], in which {*x*[1], *x*[2], *x*[3], *x*[4]} is any 4-permutation of all variables. In the above Gaussian Elimination, for example, AR deduced that *b* = *d* from the three input equalities. To handle geometric constants such as ‘0.5 pi’ or ‘5:12’, we included ‘pi’ and ‘1’ as default variables to all coefficient matrices.

### Deductive database implementation

Unlike the original implementation of DD, we use a graph data structure to capture the symmetries of geometry, rather than using strings of canonical forms. With a graph data structure, we captured not only the symmetrical permutations of function arguments but also the transitivity of equality, collinearity and concyclicity. This graph data structure bakes into itself some deduction rules explicitly stated in the geometric rule list used in DD. These deduction rules from the original list are therefore not used anywhere in exploration but implicitly used and explicitly spelled out on-demand when the final proof is serialized into text.

#### Traceback to find minimal proofs

Each deduction step needs to be coupled with a traceback algorithm, which returns the minimal set of immediate ancestor statements that is necessary to deduce the conclusion statement of the step. This is the core building block for extracting proof graphs and minimal premises described in the main text. A minimal-premise-extraction algorithm is necessary to avoid superfluous auxiliary constructions that contribute to the proof through unnecessary transitivity. For example, ‘*a* = *b*’ and ‘*b* = *c*’ might not be necessary if ‘*a* = *c*’ can be obtained directly through other reasoning chains.

### Traceback for geometric-rule deduction

To do this, we record the equality transitivity graph. For example, if ‘*a* = *b*’, ‘*b* = *c*’, ‘*c* = *d*’ and ‘*a* = *d*’ are deduced, which results in nodes *a*, *b*, *c* and *d* being connected to the same ‘equality node’ *e*, we maintain a graph within *e* that has edges [(*a*, *b*), (*b*, *c*), (*c*, *d*), (*a*, *d*)]. This allows the traceback algorithm to perform a breadth-first search to find the shortest path of transitivity of equality between any pair of variables among *a*, *b*, *c* and *d*. For collinearity and concyclicity, however, the representation is more complex. In these cases, hypergraphs *G*(*V*, *E*) with 3-edges or 4-edges are used as the equality transitivity graph. The traceback is now equivalent to finding a minimum spanning tree (denoted MST in the following equation) for the target set *S* of nodes (three collinear nodes or four concyclic nodes) whose weight is the cardinality of the union of its hyperedges *e*′:

$${\rm{MST}}(S)={\min }_{T\subset E}| {\bigcup }_{{e}^{{\prime} }\subset T}w({e}^{{\prime} })| \,{\rm{s.t.}}\,S\subset T$$

Such optimization is NP-hard, as it is a reduction from the decision version of vertex cover. We simply use a greedy algorithm in this case to find a best-effort minimum spanning tree.

### Traceback for algebraic deduction

Traceback through Gaussian elimination can be done by recognizing that it is equivalent to a mixed integer linear programming problem. Given the coefficient matrix of input equations *A* constructed as described in the previous sections and a target equation with coefficients vector *b* ∈ *R*^(*N*), we determine the minimal set of premises for *b* by defining non-negative integer decision vectors *x*, *y* ∈ *Z*^(*M*) and solve the following mixed-integer linear programming problem:

$$x,y={\min }_{x,y}{\sum }_{i}\left({x}_{i}+{y}_{i}\right)\,{\rm{s.t.}}\,{A}^{{\rm{T}}}\left(x-y\right)=b$$

The minimum set of immediate parent nodes for the equality represented by *b* will be the *i*th equations (*i*th rows in *A*) whose corresponding decision value (*x*[*i*] − *y*[*i*]) is non-zero.

### Integrating DD and AR

DD and AR are applied alternately to expand their joint deduction closure. The output of DD, which consists of new statements deduced with deductive rules, is fed into AR and vice versa. For example, if DD deduced ‘AB is parallel to CD’, the slopes of lines AB and CD will be updated to be equal variables in AR’s coefficient matrix *A*, defined in the ‘Algebraic reasoning’ section. Namely, a new row will be added to *A* with ‘1’ at the column corresponding to the variable slope(AB) and ‘−1’ at the column of slope(CD). Gaussian elimination and mixed-integer linear programming is run again as AR executes, producing new equalities as inputs to the next iteration of DD. This loop repeats until the joint deduction closure stops expanding. Both DD and AR are deterministic processes that only depend on the theorem premises, therefore they do not require any design choices in their implementation.

### Proof pruning

Although the set of immediate ancestors to any node is minimal, this does not guarantee that the fully traced back dependency subgraph *G*(*N*) and the necessary premise *P* are minimal. Here we define minimality to be the property that *G*(*N*) and *P* cannot be further pruned without losing conclusion reachability. Without minimality, we obtained many synthetic proofs with vacuous auxiliary constructions, having shallow relation to the actual proof and can be entirely discarded. To solve this, we perform exhaustive trial and error, discarding each subset of the auxiliary points and rerunning DD + AR on the smaller subset of premises to verify goal reachability. At the end, we return the minimum proof obtainable across all trials. This proof-pruning procedure is done both during synthetic data generation and after each successful proof search during test time.

### Parallelized data generation and deduplication

We run our synthetic-data-generation process on a large number of parallel CPU workers, each seeded with a different random seed to reduce duplications. After running this process on 100,000 CPU workers for 72 h, we obtained roughly 500 million synthetic proof examples. We reformat the proof statements to their canonical form (for example, sorting arguments of individual terms and sorting terms within the same proof step, etc.) to avoid shallow deduplication against itself and against the test set. At the end, we obtain 100 million unique theorem–proof examples. A total of 9 million examples involves at least one auxiliary construction. We find no IMO-AG-30 problems in the synthetic data. On the set of geometry problems collected in JGEX^([17](/articles/s41586-023-06747-5#ref-CR17 "Ye, Z., Chou, S. C. & Gao, X. S. in Proc. Automated Deduction in Geometry: 7th International Workshop, ADG 2008 (eds Sturm, T. & Zengler, C.) 189–195 (Springer, 2011).")), which consists mainly of problems with moderate difficulty and well-known theorems, we find nearly 20 problems in the synthetic data. This suggests that the training data covered a fair amount of common knowledge in geometry, but the space of more sophisticated theorems is still much larger.

### Language model architecture and training

We use the Meliad library^([35](/articles/s41586-023-06747-5#ref-CR35 "Hutchins, D., Rabe, M., Wu, Y., Schlag, I. & Staats, C. Meliad. Github                    https://github.com/google-research/meliad                                     (2022).")) for transformer training with its base settings. The transformer has 12 layers, embedding dimension of 1,024, eight heads of attention and an inter-attention dense layer of dimension 4,096 with ReLU activation. Overall, the transformer has 151 million parameters, excluding embedding layers at its input and output heads. Our customized tokenizer is trained with ‘word’ mode using SentencePiece^([36](/articles/s41586-023-06747-5#ref-CR36 "Kudo, T. & Richardson, J. SentencePiece: a simple and language independent subword tokenizer and detokenizer for neural text processing. Preprint at                    https://arxiv.org/abs/1808.06226                                     (2018).")) and has a vocabulary size of 757\. We limit the maximum context length to 1,024 tokens and use T5-style relative position embedding^([37](/articles/s41586-023-06747-5#ref-CR37 "Raffel, C. et al. Exploring the limits of transfer learning with a unified text-to-text transformer. J. Mach. Learn. Res. 21, 5485–5551 (2020).")). Sequence packing^([38](/articles/s41586-023-06747-5#ref-CR38 "Kosec, M., Fu, S. & Krell, M. M. Packing: towards 2x NLP BERT acceleration. Preprint at                    https://openreview.net/forum?id=3_MUAtqR0aA                                     (2021)."),[39](/articles/s41586-023-06747-5#ref-CR39 "Krell, M. M., Kosec, M., Perez, S. P. & Iyer, M., Fitzgibbon A. W. Efficient sequence packing without cross-contamination: accelerating large language models without impacting performance. Preprint at                    https://arxiv.org/abs/2107.02027                                     (2022).")) is also used because more than 90% of our sequences are under 200 in length. During training, a dropout^([40](/articles/s41586-023-06747-5#ref-CR40 "Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I. & Salakhutdinov, R. Dropout: a simple way to prevent neural networks from overfitting. J. Mach. Learn. Res. 15, 1929–1958 (2014).")) rate of 5% is applied pre-attention and post-dense. A 4 × 4 slice of TPUv3 (ref. ^([41](/articles/s41586-023-06747-5#ref-CR41 "Norrie, T. et al. The design process for Google’s training chips: TPUv2 and TPUv3\. IEEE Micro. 41, 56–63 (2021) Feb 9."))) is used as its hardware accelerator. For pretraining, we train the transformer with a batch size of 16 per core and a cosine learning-rate schedule that decays from 0.01 to 0.001 in 10,000,000 steps. For fine-tuning, we maintain the final learning rate of 0.001 for another 1,000,000 steps. For the set-up with no pretraining, we decay the learning rate from 0.01 to 0.001 in 1,000,000 steps. We do not perform any hyperparameter tuning. These hyperparameter values are either selected to be a large round number (training steps) or are provided by default in the Meliad codebase.

#### Parallelized proof search

Because the language model decoding process returns *k* different sequences describing *k* alternative auxiliary constructions, we perform a beam search over these *k* options, using the score of each beam as its value function. This set-up is highly parallelizable across beams, allowing substantial speed-up when there are parallel computational resources. In our experiments, we use a beam size of *k* = 512, the maximum number of iterations is 16 and the branching factor for each node, that is, the decoding batch size, is 32\. This is the maximum inference-time batch size that can fit in the memory of a GPU V100 for our transformer size. Scaling up these factors to examine a larger fraction of the search space might improve AlphaGeometry results even further.

For each problem, we used a pool of four GPU workers, each hosting a copy of the transformer language model to divide the work between alternative beams, and a pool of 10,000 CPU workers to host the symbolic solvers, shared across all beams across all 30 problems. This way, a problem that terminates early can contribute its share of computing power to longer-running problems. We record the running time of the symbolic solver on each individual problem, which—by design—stays roughly constant across all beams. We use this and the language model decoding speed to infer the necessary parallelism needed for each problem, in isolation, to stay under different time limits at the IMO in Extended Data Fig. [1](/articles/s41586-023-06747-5#Fig7).

### The effect of data and search

We trained AlphaGeometry on smaller fractions of the original training data (20%, 40%, 60% and 80%) and found that, even at 20% of training data, AlphaGeometry still solves 21 problems, more than the strongest baseline (DD + AR + human-designed heuristics) with 18 problems solved, as shown in Extended Data Fig. [6a](/articles/s41586-023-06747-5#Fig12). To study the effect of beam search on top of the language model, we reduced the beam size and search depth separately during proof search and reported the results in Extended Data Fig. [6c,d](/articles/s41586-023-06747-5#Fig12). We find that, with a beam size of 8, that is, a 64 times reduction from the original beam size of 512, AlphaGeometry still solves 21 problems. A similar result of 21 problems can be obtained by reducing the search depth from 16 to only two, while keeping the beam size constant at 512.

### Evaluation on a larger test set

We evaluated AlphaGeometry and other baselines on a larger test set of 231 geometry problems, curated in ref. ^([17](/articles/s41586-023-06747-5#ref-CR17 "Ye, Z., Chou, S. C. & Gao, X. S. in Proc. Automated Deduction in Geometry: 7th International Workshop, ADG 2008 (eds Sturm, T. & Zengler, C.) 189–195 (Springer, 2011).")). This set covers a wider range of sources outside IMO competitions: textbook examples and exercises, regional olympiads and famous geometry theorems; some are even more complex than typical IMO problems, such as the five circles theorem, Morley’s theorem or Sawayama and Thébault’s theorem. The results are reported in Extended Data Fig. [6b](/articles/s41586-023-06747-5#Fig12). The overall rankings of different approaches remained the same as in Table [1](/articles/s41586-023-06747-5#Tab1), with AlphaGeometry solving almost all problems (98.7%). The strongest baseline DD + AR + human-designed heuristics solves 92.2%, whereas the previous state of the art solves 75%.

#### AlphaGeometry framework and applicability to other domains

The strength of AlphaGeometry’s neuro-symbolic set-up lies in its ability to generate auxiliary constructions, which is an important ingredient across many mathematical domains. In Extended Data Table [3](/articles/s41586-023-06747-5#Tab4), we give examples in four other mathematical domains in which coming up with auxiliary constructions is key to the solution. In Extended Data Table [4](/articles/s41586-023-06747-5#Tab5), we give a line-by-line comparison of a geometry proof and an inequality proof for the IMO 1964 Problem 2, highlighting how they both fit into the same framework.

Our paper shows that language models can learn to come up with auxiliary constructions from synthetic data, in which problem statements and auxiliary constructions are randomly generated together and then separated using the traceback algorithm to identify the dependency difference. Concretely, the AlphaGeometry framework requires the following ingredients:

1.  (1)

    An implementation of the domain’s objects and definitions.

2.  (2)

    A random premise sampler.

3.  (3)

    The symbolic engine(s) that operate within the implementation (1).

4.  (4)

    A traceback procedure for the symbolic engine.

Using these four ingredients and the algorithm described in the main text, one can generate synthetic data for any target domain. As shown in our paper, there are non-trivial engineering challenges in building each ingredient. For example, current formalizations of combinatorics are very nascent, posing challenges to (1) and (2). Also, building powerful symbolic engines for different domains requires deep domain expertise, posing challenges to (3) and (4). We consider applying this framework to a wider scope as future work and look forward to further innovations that tackle these challenges.

### Transformer in theorem proving

Research in automated theorem proving has a long history dating back to the 1950s (refs. ^([6](/articles/s41586-023-06747-5#ref-CR6 "Gelernter, H. L. in Proc. First International Conference on Information Processing (IFIP) 273–281 (UNESCO, 1959)."),[42](/articles/s41586-023-06747-5#ref-CR42 "Gilmore, P. C. A proof method for quantification theory: its justification and realization. IBM J. Res. Dev. 4, 28–35 (1960)."),[43](/articles/s41586-023-06747-5#ref-CR43 "Davis, M. & Putnam, H. A computing procedure for quantification theory. J. ACM. 7, 201–215 (1960)."))), resulting in highly optimized first-order logic solvers such as E (ref. ^([44](/articles/s41586-023-06747-5#ref-CR44 "Schulz, S. E – a brainiac theorem prover. AI Commun. 15, 111–126 (2002)."))) or Vampire^([45](/articles/s41586-023-06747-5#ref-CR45 "Riazanov, A. & Voronkov, A. in Proc. First International Joint Conference on Automated Reasoning, IJCAR 2001 (eds Goré, R., Leitsch, A. & Nipkow, T.) 376–380 (Springer, 2001).")). In the 2010s, deep learning matured as a new powerful tool for automated theorem proving, demonstrating great successes in premise selection and proof guidance^([46](#ref-CR46 "Irving, G. et al. DeepMath - deep sequence models for premise selection. Adv. Neural Inf. Process. Syst.                    https://doi.org/10.48550/arXiv.1606.04442                                     (2016)."),[47](#ref-CR47 "Wang, M., Tang, Y., Wang, J. & Deng, J. Premise selection for theorem proving by deep graph embedding. Adv. Neural Inf. Process. Syst.                    https://doi.org/10.48550/arXiv.1709.09994                                     (2017)."),[48](#ref-CR48 "Loos, S., Irving, G., Szegedy, C. & Kaliszyk, C. Deep network guided proof search. Preprint at                    https://arxiv.org/abs/1701.06972                                     (2017)."),[49](/articles/s41586-023-06747-5#ref-CR49 "Bansal, K., Loos, S., Rabe, M., Szegedy, C. & Wilcox S. in Proc. 36th International Conference on Machine Learning 454–463 (PMLR, 2019).")), as well as SAT solving^([50](/articles/s41586-023-06747-5#ref-CR50 "Selsam, D. et al. Learning a SAT solver from single-bit supervision. Preprint at                    https://doi.org/10.48550/arXiv.1802.03685                                     (2019).")). On the other hand, transformer^([18](/articles/s41586-023-06747-5#ref-CR18 "Vaswani, A. et al. Attention is all you need. Adv. Neural Inf. Process. Syst. 30 (2017).")) exhibits outstanding reasoning capabilities across a variety of tasks^([51](#ref-CR51 "Saxton, D., Grefenstette, E., Hill, F. & Kohli, P. Analysing mathematical reasoning abilities of neural models. Preprint at                    https://doi.org/10.48550/arXiv.1904.01557                                     (2019)."),[52](#ref-CR52 "Lample, G. & Charton F. Deep learning for symbolic mathematics. Preprint at                    https://doi.org/10.48550/arXiv.1912.01412                                     (2019)."),[53](/articles/s41586-023-06747-5#ref-CR53 "Charton, F., Hayat, A. & Lample, G. Learning advanced mathematical computations from examples. Preprint at                    https://doi.org/10.48550/arXiv.2006.06462                                     (2021).")). The first success in applying transformer language models to theorem proving is GPT-f (ref. ^([15](/articles/s41586-023-06747-5#ref-CR15 "Polu, S. & Sutskever, I. Generative language modeling for automated theorem proving. Preprint at                    https://arxiv.org/abs/2009.03393                                     (2020)."))). Its follow up extensions^([2](/articles/s41586-023-06747-5#ref-CR2 "Polu, S. et al. Formal mathematics statement curriculum learning. Preprint at                    https://doi.org/10.48550/arXiv.2202.01344                                     (2023)."),[16](/articles/s41586-023-06747-5#ref-CR16 "Han, J. M., Rute, J., Wu, Y., Ayers, E. W., & Polu, S. Proof artifact co-training for theorem proving with language models. Preprint at                    https://doi.org/10.48550/arXiv.2102.06203                                     (2022).")) further developed this direction, allowing machines to solve some olympiad-level problems for the first time. Innovation in the proof-search algorithm and online training^([3](/articles/s41586-023-06747-5#ref-CR3 "Lample, G. et al. Hypertree proof search for neural theorem proving. Adv. Neural Inf. Process. Syst. 35, 26337–26349 (2022).")) also improves transformer-based methods, solving a total of ten (adapted) IMO problems in algebra and number theory. These advances, however, are predicated on a substantial amount of human proof examples and standalone problem statements designed and curated by humans.

#### Geometry theorem proving

Geometry theorem proving evolves in an entirely separate space. Its literature is divided into two branches, one of computer algebra methods and one of search methods. The former is largely considered solved since the introduction of Wu’s method^([21](/articles/s41586-023-06747-5#ref-CR21 "Wu, W.-T. On the decision problem and the mechanization of theorem-proving in elementary geometry. Sci. Sin. 21, 159–172 (1978).")), which can theoretically decide the truth value of any geometrical statement of equality type, building on specialized algebraic tools introduced in earlier works^([54](/articles/s41586-023-06747-5#ref-CR54 "Collins, G. E. in Proc. 2nd GI Conference on Automata Theory and Formal Languages (ed. Barkhage, H.) 134–183 (Springer, 1975)."),[55](/articles/s41586-023-06747-5#ref-CR55 "Ritt, J. F. Differential Algebra (Colloquium Publications, 1950).")). Even though computer algebra has strong theoretical guarantees, its performance can be limited in practice owing to their large time and space complexity^([56](/articles/s41586-023-06747-5#ref-CR56 "Chou, S. C. Proving Elementary Geometry Theorems Using Wu’s Algorithm. Doctoral dissertation, Univ. Texas at Austin (1985).")). Further, the methodology of computer algebra is not of interest to AI research, which instead seeks to prove theorems using search methods, a more human-like and general-purpose process.

Search methods also started as early as the 1950s (refs. ^([6](/articles/s41586-023-06747-5#ref-CR6 "Gelernter, H. L. in Proc. First International Conference on Information Processing (IFIP) 273–281 (UNESCO, 1959)."),[7](/articles/s41586-023-06747-5#ref-CR7 "Gelernter, H., Hansen, J. R. & Loveland, D. W. in Papers presented at the May 3–5, 1960, western joint IRE-AIEE-ACM computer conference 143–149 (ACM, 1960)."))) and continued to develop throughout the twentieth century^([57](#ref-CR57 "Nevins, A. J. Plane geometry theorem proving using forward chaining. Artif. Intell. 6, 1–23 (1975)."),[58](#ref-CR58 "Coelho, H. & Pereira, L. M. Automated reasoning in geometry theorem proving with Prolog. J. Autom. Reason. 2, 329–390 (1986)."),[59](#ref-CR59 "Quaife, A. Automated development of Tarski’s geometry. J. Autom. Reason. 5, 97–118 (1989)."),[60](/articles/s41586-023-06747-5#ref-CR60 "McCharen, J. D., Overbeek, R. A. & Lawrence, T. in The Collected Works of Larry Wos 166–196 (2000).")). With the introduction of DD^([10](/articles/s41586-023-06747-5#ref-CR10 "Chou, S. C., Gao, X. S. & Zhang, J. Z. A deductive database approach to automated geometry theorem proving and discovering. J. Autom. Reason. 25, 219–246 (2000)."),[17](/articles/s41586-023-06747-5#ref-CR17 "Ye, Z., Chou, S. C. & Gao, X. S. in Proc. Automated Deduction in Geometry: 7th International Workshop, ADG 2008 (eds Sturm, T. & Zengler, C.) 189–195 (Springer, 2011).")), area methods^([61](/articles/s41586-023-06747-5#ref-CR61 "Chou, S. C., Gao, X. S. & Zhang, J. Machine Proofs in Geometry: Automated Production of Readable Proofs for Geometry Theorems (World Scientific, 1994).")) and full-angle methods^([30](/articles/s41586-023-06747-5#ref-CR30 "Chou, S. C., Gao, X. S. & Zhang, J. Z. Automated generation of readable proofs with geometric invariants: II. Theorem proving with full-angles. J. Autom. Reason. 17, 349–370 (1996).")), geometry solvers use higher-level deduction rules than Tarski’s or Hilbert’s axioms and are able to prove a larger number of more complex theorems than those operating in formal languages. Geometry theorem proving of today, however, is still relying on human-designed heuristics for auxiliary constructions^([10](#ref-CR10 "Chou, S. C., Gao, X. S. & Zhang, J. Z. A deductive database approach to automated geometry theorem proving and discovering. J. Autom. Reason. 25, 219–246 (2000)."),[11](#ref-CR11 "Matsuda, N. & Vanlehn, K. GRAMY: a geometry theorem prover capable of construction. J. Autom. Reason. 32, 3–33 (2004)."),[12](#ref-CR12 "Wang, K. & Su, Z. in Proc. Twenty-Fourth International Joint Conference on Artificial Intelligence (IJCAI 2015) (ACM, 2015)."),[13](#ref-CR13 "Gao, X. S. & Lin, Q. in Proc. Automated Deduction in Geometry: 4th International Workshop, ADG 2002 (ed. Winkler, F.) 44–66 (Springer, 2004)."),[14](/articles/s41586-023-06747-5#ref-CR14 "Zhou, M. & Yu, X. in Proc. 2nd International Conference on Artificial Intelligence in Education: Emerging Technologies, Models and Applications, AIET 2021 (eds Cheng, E. C. K., Koul, R. B., Wang, T. & Yu, X.) 151–161 (Springer, 2022).")). Geometry theorem proving falls behind the recent advances made by machine learning because its presence in formal mathematical libraries such as Lean^([31](/articles/s41586-023-06747-5#ref-CR31 "de Moura, L. & Ullrich, S. in Proc. 28th International Conference on Automated Deduction, CADE 28 (eds Platzer, A. & Sutcliffe, G.) 625–635 (Springer, 2021).")) or Isabelle^([62](/articles/s41586-023-06747-5#ref-CR62 "Paulson, L. C. (ed.) Isabelle: A Generic Theorem Prover (Springer, 1994).")) is extremely limited.

#### Synthetic data in theorem proving

Synthetic data has long been recognized and used as an important ingredient in theorem proving^([63](#ref-CR63 "Wu, Y., Jiang, A. Q., Ba, J. & Grosse, R. INT: an inequality benchmark for evaluating generalization in theorem proving. Preprint at                    https://doi.org/10.48550/arXiv.2007.02924                                     (2021)."),[64](#ref-CR64 "Zombori, Z., Csiszárik, A., Michalewski, H., Kaliszyk, C. & Urban, J. in Proc. 30th International Conference on Automated Reasoning with Analytic Tableaux and Related Methods (eds Das, A. & Negri, S.) 167–186 (Springer, 2021)."),[65](#ref-CR65 "Fawzi, A., Malinowski, M., Fawzi, H., Fawzi, O. Learning dynamic polynomial proofs. Adv. Neural Inf. Process. Syst.                    https://doi.org/10.48550/arXiv.1906.01681                                     (2019)."),[66](/articles/s41586-023-06747-5#ref-CR66 "Wang, M. & Deng, J. Learning to prove theorems by learning to generate theorems. Adv. Neural Inf. Process. Syst. 33, 18146–18157 (2020).")). State-of-the-art machine learning methods make use of expert iteration to generate a curriculum of synthetic proofs^([2](/articles/s41586-023-06747-5#ref-CR2 "Polu, S. et al. Formal mathematics statement curriculum learning. Preprint at                    https://doi.org/10.48550/arXiv.2202.01344                                     (2023)."),[3](/articles/s41586-023-06747-5#ref-CR3 "Lample, G. et al. Hypertree proof search for neural theorem proving. Adv. Neural Inf. Process. Syst. 35, 26337–26349 (2022)."),[15](/articles/s41586-023-06747-5#ref-CR15 "Polu, S. & Sutskever, I. Generative language modeling for automated theorem proving. Preprint at                    https://arxiv.org/abs/2009.03393                                     (2020).")). Their methods, however, only generate synthetic proofs for a fixed set of predefined problems, designed and selected by humans. Our method, on the other hand, generates both synthetic problems and proofs entirely from scratch. Aygun et al.^([67](/articles/s41586-023-06747-5#ref-CR67 "Aygün, E. et al. in Proc. 39th International Conference on Machine Learning 1198–1210 (PMLR, 2022).")) similarly generated synthetic proofs with hindsight experience replay^([68](/articles/s41586-023-06747-5#ref-CR68 "Andrychowicz, M. et al. Hindsight experience replay. Adv. Neural Inf. Process. Syst.                    https://doi.org/10.48550/arXiv.1707.01495                                     (2017).")), providing a smooth range of theorem difficulty to aid learning similar to our work. AlphaGeometry, however, is not trained on existing conjectures curated by humans and does not learn from proof attempts on the target theorems. Their approach is thus orthogonal and can be used to further improve AlphaGeometry. Most similar to our work is Firoiu et al.^([69](/articles/s41586-023-06747-5#ref-CR69 "Firoiu, V. et al. Training a first-order theorem prover from synthetic data. Preprint at                    https://doi.org/10.48550/arXiv.2103.03798                                     (2021).")), whose method uses a forward proposer to generate synthetic data by depth-first exploration and trains a neural network purely on these synthetic data. Our work, on the other hand, uses breadth-first exploration, necessary to obtain the minimal proofs and premises, and uses a traceback algorithm to identify auxiliary constructions, thus introducing new symbols and hypotheses that the forward proposer cannot propose.