<!--yml
category: 未分类
date: 2024-05-27 14:52:15
-->

# Some Memories of Niklaus Wirth | Language and Code

> 来源：[https://odersky.github.io/blog/2024-01-04-post.html](https://odersky.github.io/blog/2024-01-04-post.html)

# Some Memories of Niklaus Wirth

Jan 4, 2024

January 2024

Niklaus Wirth passed away on the first day of this year. He was one of the most important pioneers of computer science, probably the one who had the biggest practical impact while maintaining at the same time rigorous scientific and engineering principles. Niklaus described himself as an engineer, and that’s what he was. As an engineer, he applied scientific discoveries and principles in the development of useful products, which included programming languages, compilers and other systems software. But he had to create a large chunk of the science himself, since it did not yet exist at the time.

I was privileged to have worked with him as his PhD student, and to have learned a lot from him. In this note I want to write about some of the ways Niklaus influenced my work and my approach to programming.

In fact, if it was not for Niklaus, it’s doubtful I would have ended up in computer science at all. My first degree was in Mathematics. I got interested in Computer Science because I was fascinated by compilers and programming languages. The first language I deeply appreciated was Pascal. It was simple and clean, and easy to understand from both design and implementation perspectives. Together with Peter Sollich, a fellow student, I then stumbled upon the source code listings of the Pascal to P-Code compiler. It was amazing that a full Pascal compiler could be written in about 5000 lines of easy-to-understand code. This set in motion our project to write our own Pascal compiler for a new Microcomputer, the [Osborne 1](https://en.wikipedia.org/wiki/Osborne_1). This was a year or so before Turbo Pascal came out.

About half-way through the project, Peter discovered another pair of slim yellow-bound research reports from Niklaus Wirth at ETH. One described the language Modula-2, the other the instruction set for the Lilith computer that implemented the language. We were immediately fascinated by both the language and the instruction set, which was both simple and very compact. At the time, saving memory was of paramount importance since our computer had only 54 Kilobytes of usable memory. So we switched the compiled source language to Modula-2 and the intermediate code to a variant of Lilith’s code. This compiler eventually became [Turbo Modula-2](https://github.com/Oric4ever/Turbo-Modula-2-Reloaded) for 8 bit computers. We sold it to Borland, but the company did not distribute it under their own name.

After having experienced and worked with Wirth’s beautiful inventions, it was clear to me that I wanted to continue with PhD studies in programming languages and I applied to his group. I was very happy that my application was accepted and I started working at ETH in 1986.

The work in Wirth’s group was quite special. I realized how different the workplace was only after I had moved on. You see, *everything* we worked with was “homebrew” stuff, but at the same time was advanced way beyond the standard of the time. It started with the computer: A screen that could show a full a A4 page on a bitmapped display, and a mouse for interacting with it. This at least 5 years before a commercial computer with these characteristics came out. It continued with the fonts. Since there were no bitmapped displays there were no fonts for such displays either. So one member of the group was a professional font designer, and another member was a designer for font-designing tools! It continued with the operating system, and the programming tools. We had a simple but powerful text editor which was configurable to be a very productive IDE. We also had a simple and beautiful debugger that showed a thread-dump with full memory exploration in a set of tiled windows. I forgot to mention, of course the windowing system was also developed in house, everything was.

Now you might think that there would have been an army of developers doing these things. But no, it was Niklaus Wirth with 6 doctoral students, as well as some researchers in the associated groups of Jürg Gutknecht and Peter Mössenböck. The best thing was, if you had a question or suggestion, you would just walk into the office next door and talk to the person who wrote the software.

All this was possible only because Niklaus led the way with his approach to ruthless simplicity. Simplicity was mandatory. Every feature had to be justified to be both essential *and* very compact to implement. Famously, compiler optimizations were only added if they increased the speed of bootstrapping the compiler. Niklaus led the way in his own coding and in his teaching to us.

I think of the sequence of languages that Niklaus worked as a kind of culmination of Von Neumann languages. After his thesis project EULER he worked on ALGOL-W, a proposed successor to Algol 60, that was supported by other leading lights of computer science such as Tony Hoare or Edsger Dijkstra, but that was ultimately not accepted as the official next version of Algol. Next came Pascal, with huge success in teaching and on PCs. After Pascal came Modula and then Modula-2, which was the language I personally liked best. It added to Pascal modularity concepts that allowed a team of developers to work on a common code base, as well as concurrency concepts that were cleaner and more powerful than what came 15 years later with Java. The last of the Wirth languages was Oberon, which added a minimalistic construct to support the kind of extensible programs that were the domain of object-orientation and otherwise dropped quite a few features from Modula-2\. It was consequently even easier to implement than Modula-2 and it was therefore possible to develop a complete operating system with GUI and compiler in a small code base and describe it in a single book.

My own thesis was about developing a new kind of attribute grammar and writing a specification of Oberon in it. Towards the end of my stay at ETH, I discovered and fell in love with functional programming, which was quite different from what we used to do at ETH. But the style and values I learned from Niklaus have stayed with me ever since, and I am very, very grateful that I could experience them first-hand.

A couple of specific things I remember:

*   Niklaus was not fond of committees, probably as a result of his experiences on the Algol 68 committee. I was invited to be part of the ISO standardization committee for Modula-2\. Wirth told me I could go if I wanted, but made it clear that he did not think it was a worthwhile endeavor. He would not consider to attend himself. I attended a few sessions of the committee and then dropped out.

*   Niklaus saw his role mostly as a pioneer and a researcher, not so much as a leader of a language community. Shortly before I arrived in Zurich, Modula-2 had a small moment of fame, with a whole issue of the then leading PC Magazine *Byte* devoted to it. With more support, Modula-2 might have become a widespread systems language, it would have certainly deserved it, There was also a successor language proposal called Modula-3 developed by Luca Cardelli, Greg Nelson and others at DEC SRC. This was also a very clean and elegant language design, and more ambitious and powerful than Modula-2\. If Niklaus had joined the effort, who knows, it might have been a popular successor and competitor to C++. But he was already working on his next thing, Oberon.

Niklaus combined theoretical and practical results more deeply than any other person I know. He was one of the fathers of structured programming and pioneered program refinement, beautifully explained in his book “Data Structures + Algorithms = Programs”. Yet he did all that to gain better practical abstractions that helped him design clean operating systems, compilers, and other tools, all in a few kilobytes of memory. Unlike other systems languages such as C, Wirth’s languages never compromised on having tight abstractions. I believe that is his lasting legacy: how theory and abstraction *helps* in day to day programming, but only if it is done right, with a ruthless focus on simplicity.