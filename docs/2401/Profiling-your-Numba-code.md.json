["```\nfrom numba import njit\nimport numpy as np\nfrom skimage import io\nfrom time import time\n\nIMAGE = io.imread(\"hallway.jpg\")\n\n# Code that is decorated with numba.njit looks like Python code,\n# but is actually compiled into machine code, at runtime. This\n# is fast, low-level code! @njit\ndef dither(img):\n    # Allow negative values and wider range than a uint8 has:\n    result = img.astype(np.int16)\n    y_size = img.shape[0]\n    x_size = img.shape[1]\n    last_y = y_size - 1\n    last_x = x_size - 1\n    for y in range(y_size):\n        for x in range(x_size):\n            old_value = result[y, x]\n            if old_value < 0:\n                new_value = 0\n            elif old_value > 255:\n                new_value = 255\n            else:\n                new_value = np.uint8(np.round(old_value / 255.0)) * 255\n            result[y, x] = new_value\n            # We might get a negative value for the error:\n            error = np.int16(old_value) - new_value\n            if x < last_x:\n                result[y, x + 1] += error * 7 // 16\n            if y < last_y and x > 0:\n                result[y + 1, x - 1] += error * 3 // 16\n            if y < last_y:\n                result[y + 1, x] += error * 5 // 16\n            if y < last_y and x < last_x:\n                result[y + 1, x + 1] += error // 16\n\n    return result.astype(np.uint8)\n\n# Run a first time, to compile the code: dither(IMAGE)\n\n# Make sure we run this for long enough that the profiler\n# gets sufficient samples: start = time()\nruns = 0\nwhile time() - start < 5:\n    runs += 1\n    dither(IMAGE)\n\nelapsed = time() - start\nprint(f\"Processed {int(round(runs / elapsed))} images / sec\") \n```", "```\n$ sudo apt-get install -y gdb\n$ pip install profila \n```", "```\n$ python -m profila annotate -- dither.py\nProcessed 255 images / sec\n# Total samples: 805 (37.8% non-Numba samples, 1.9% bad samples)\n\n## File `dither.py`\nLines 14 to 40:\n\n  0.1% |     result = img.astype(np.int16)\n       |     y_size = img.shape[0]\n       |     x_size = img.shape[1]\n       |     last_y = y_size - 1\n       |     last_x = x_size - 1\n       |     for y in range(y_size):\n  0.2% |         for x in range(x_size):\n       |             old_value = result[y, x]\n       |             if old_value < 0:\n       |                 new_value = 0\n  1.0% |             elif old_value > 255:\n       |                 new_value = 255\n       |             else:\n 30.2% |                 new_value = np.uint8(np.round(old_value / 255.0)) * 255\n       |             result[y, x] = new_value\n       |             # We might get a negative value for the error:\n  2.0% |             error = np.int16(old_value) - new_value\n  0.6% |             if x < last_x:\n 11.3% |                 result[y, x + 1] += error * 7 // 16\n       |             if y < last_y and x > 0:\n  0.9% |                 result[y + 1, x - 1] += error * 3 // 16\n       |             if y < last_y:\n  2.4% |                 result[y + 1, x] += error * 5 // 16\n       |             if y < last_y and x < last_x:\n  1.6% |                 result[y + 1, x + 1] += error // 16\n       |\n  0.2% |     return result.astype(np.uint8)\n\n## File `numba/np/arraymath.py`\nLines 3157 to 3157:\n\n  9.8% |                         return _np_round_float(a) \n```", "```\nif old_value < 0:\n    new_value = 0\nelif old_value > 255:\n    new_value = 255\nelse:\n    new_value = np.uint8(np.round(old_value / 255.0)) * 255 \n```", "```\nnew_value = 0 if old_value < 128 else 255 \n```", "```\n$ python -m profila annotate -- dither2.py\nProcessed 758 images / sec\n# Total samples: 713 (30.3% non-Numba samples, 2.2% bad samples)\n\n## File `/home/itamarst/devel/sandbox/numba-profiling-article/dither2.py`\nLines 14 to 35:\n\n  0.1% |     result = img.astype(np.int16)\n       |     y_size = img.shape[0]\n       |     x_size = img.shape[1]\n       |     last_y = y_size - 1\n       |     last_x = x_size - 1\n       |     for y in range(y_size):\n  0.3% |         for x in range(x_size):\n  0.1% |             old_value = result[y, x]\n  4.5% |             new_value = 0 if old_value < 128 else 255\n  2.0% |             result[y, x] = new_value\n       |             # We might get a negative value for the error:\n  5.5% |             error = np.int16(old_value) - new_value\n  5.3% |             if x < last_x:\n 34.9% |                 result[y, x + 1] += error * 7 // 16\n       |             if y < last_y and x > 0:\n  3.6% |                 result[y + 1, x - 1] += error * 3 // 16\n       |             if y < last_y:\n  6.0% |                 result[y + 1, x] += error * 5 // 16\n       |             if y < last_y and x < last_x:\n  4.5% |                 result[y + 1, x + 1] += error // 16\n       |\n  0.6% |     return result.astype(np.uint8) \n```", "```\n@njit\ndef add(arr):\n    result = np.empty_like(arr)\n    for i in range(len(arr)):\n        orig = arr[i]\n        orig += 123_000_000\n        orig += 456_000\n        orig += 789\n        result[i] = orig\n    return result \n```", "```\n## File `combo.py`\nLines 13 to 14:\n\n  2.9% |         orig += 789\n  7.5% |         result[i] = orig \n```", "```\n>>> for line in next(iter(add.inspect_asm().values())).splitlines():\n...     if \"789\" in line: print(line)\n...\n        .long   123456789\n        movl    $123456789, %edi\n        movl    $123456789, %edx \n```", "```\n 5.3% |             if x < last_x:\n 34.9% |                 result[y, x + 1] += error * 7 // 16\n       |             if y < last_y and x > 0:\n  3.6% |                 result[y + 1, x - 1] += error * 3 // 16\n       |             if y < last_y:\n  6.0% |                 result[y + 1, x] += error * 5 // 16\n       |             if y < last_y and x < last_x:\n  4.5% |                 result[y + 1, x + 1] += error // 16 \n```", "```\n |             if y < last_y and x > 0:\n 20.3% |                 result[y + 1, x - 1] += error * 3 // 16\n 14.2% |             if x < last_x:\n  8.8% |                 result[y, x + 1] += error * 7 // 16\n       |             if y < last_y:\n  3.7% |                 result[y + 1, x] += error * 5 // 16\n       |             if y < last_y and x < last_x:\n  3.7% |                 result[y + 1, x + 1] += error // 16 \n```"]