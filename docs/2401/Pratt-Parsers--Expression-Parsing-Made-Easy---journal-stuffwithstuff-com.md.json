["```\nNAME \"from\"\nPLUS \"+\"\nNAME \"offset\"\nLEFT_PAREN \"(\"\nNAME \"time\"\nRIGHT_PAREN \")\" \n```", "```\nclass ConditionalExpression implements Expression {\n  public ConditionalExpression(\n      Expression condition,\n      Expression thenArm,\n      Expression elseArm) {\n    this.condition = condition;\n    this.thenArm   = thenArm;\n    this.elseArm   = elseArm;\n  }\n\n  public final Expression condition;\n  public final Expression thenArm;\n  public final Expression elseArm;\n} \n```", "```\nExpression parseExpression() {\n  if (match(TokenType.NAME))       // Return NameExpression...\n  else if (match(TokenType.PLUS))  // Return prefix + operator...\n  else if (match(TokenType.MINUS)) // Return prefix - operator...\n  else if (match(TokenType.TILDE)) // Return prefix ~ operator...\n  else if (match(TokenType.BANG))  // Return prefix ! operator...\n  else throw new ParseException();\n} \n```", "```\ninterface PrefixParselet {\n  Expression parse(Parser parser, Token token);\n} \n```", "```\nclass NameParselet implements PrefixParselet {\n  public Expression parse(Parser parser, Token token) {\n    return new NameExpression(token.getText());\n  }\n} \n```", "```\nclass PrefixOperatorParselet implements PrefixParselet {\n  public Expression parse(Parser parser, Token token) {\n    Expression operand = parser.parseExpression();\n    return new PrefixExpression(token.getType(), operand);\n  }\n} \n```", "```\nclass Parser {\n  public Expression parseExpression() {\n    Token token = consume();\n    PrefixParselet prefix = mPrefixParselets.get(token.getType());\n\n    if (prefix == null) throw new ParseException(\n        \"Could not parse \\\"\" + token.getText() + \"\\\".\");\n\n    return prefix.parse(this, token);\n  }\n\n  // Other stuff...\n\n  private final Map<TokenType, PrefixParselet> mPrefixParselets =\n      new HashMap<TokenType, PrefixParselet>();\n} \n```", "```\npublic void register(TokenType token, PrefixParselet parselet) {\n  mPrefixParselets.put(token, parselet);\n}\n\npublic void prefix(TokenType token) {\n  register(token, new PrefixOperatorParselet());\n} \n```", "```\nregister(TokenType.NAME, new NameParselet());\nprefix(TokenType.PLUS);\nprefix(TokenType.MINUS);\nprefix(TokenType.TILDE);\nprefix(TokenType.BANG); \n```", "```\ninterface InfixParselet {\n  Expression parse(Parser parser, Expression left, Token token);\n} \n```", "```\nclass Parser {\n  public void register(TokenType token, InfixParselet parselet) {\n    mInfixParselets.put(token, parselet);\n  }\n\n  public Expression parseExpression() {\n    Token token = consume();\n    PrefixParselet prefix = mPrefixParselets.get(token.getType());\n\n    if (prefix == null) throw new ParseException(\n        \"Could not parse \\\"\" + token.getText() + \"\\\".\");\n\n    Expression left = prefix.parse(this, token);\n\n    token = lookAhead(0);\n    InfixParselet infix = mInfixParselets.get(token.getType());\n\n    // No infix expression at this point, so we're done.\n    if (infix == null) return left;\n\n    consume();\n    return infix.parse(this, left, token);\n  }\n\n  // Other stuff...\n\n  private final Map<TokenType, InfixParselet> mInfixParselets =\n      new HashMap<TokenType, InfixParselet>();\n} \n```", "```\nclass BinaryOperatorParselet implements InfixParselet {\n  public Expression parse(Parser parser,\n      Expression left, Token token) {\n    Expression right = parser.parseExpression();\n    return new OperatorExpression(left, token.getType(), right);\n  }\n} \n```", "```\nclass PostfixOperatorParselet implements InfixParselet {\n  public Expression parse(Parser parser, Expression left,\n      Token token) {\n    return new PostfixExpression(left, token.getType());\n  }\n} \n```", "```\nclass ConditionalParselet implements InfixParselet {\n  public Expression parse(Parser parser, Expression left,\n      Token token) {\n    Expression thenArm = parser.parseExpression();\n    parser.consume(TokenType.COLON);\n    Expression elseArm = parser.parseExpression();\n\n    return new ConditionalExpression(left, thenArm, elseArm);\n  }\n} \n```", "```\npublic interface InfixParselet {\n  Expression parse(Parser parser, Expression left, Token token);\n  int getPrecedence();\n} \n```", "```\npublic Expression parseExpression(int precedence) {\n  Token token = consume();\n  PrefixParselet prefix = mPrefixParselets.get(token.getType());\n\n  if (prefix == null) throw new ParseException(\n      \"Could not parse \\\"\" + token.getText() + \"\\\".\");\n\n  Expression left = prefix.parse(this, token);\n\n  while (precedence < getPrecedence()) {\n    token = consume();\n\n    InfixParselet infix = mInfixParselets.get(token.getType());\n    left = infix.parse(this, left, token);\n  }\n\n  return left;\n} \n```", "```\nprivate int getPrecedence() {\n  InfixParselet parser = mInfixParselets.get(\n      lookAhead(0).getType());\n  if (parser != null) return parser.getPrecedence();\n\n  return 0;\n} \n```", "```\npublic class Precedence {\n  public static final int ASSIGNMENT  = 1;\n  public static final int CONDITIONAL = 2;\n  public static final int SUM         = 3;\n  public static final int PRODUCT     = 4;\n  public static final int EXPONENT    = 5;\n  public static final int PREFIX      = 6;\n  public static final int POSTFIX     = 7;\n  public static final int CALL        = 8;\n} \n```"]