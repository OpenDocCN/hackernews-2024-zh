- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:23:29'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Jepsen: RavenDB 6.0.2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://jepsen.io/analyses/ravendb-6.0.2](https://jepsen.io/analyses/ravendb-6.0.2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[RavenDB](https://ravendb.net) is a distributed document database which [repeatedly
    advertises](https://ravendb.net/why-ravendb) its support for ACID transactions.
    It’s intended for OLTP workloads, and offers a variety of [ETL paths](https://ravendb.net/docs/article-page/6.0/csharp/server/ongoing-tasks/etl/basics)
    for exporting data to other systems. Its transactional API revolves around a [session](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work)
    handle, which “represents a single business transaction on a particular database.”
    Users create a session, perform operations like reads and writes, and finally
    call `session.saveChanges()` to commit their writes as an atomic unit.'
  prefs: []
  type: TYPE_NORMAL
- en: RavenDB can [replicate data across a set of nodes with automated failover](https://ravendb.net/why-ravendb/high-availability).
    Sharding is either a [work in progress](https://issues.hibernatingrhinos.com/issue/RavenDB-8115)
    or [ready in 6.0](https://ravendb.net/features/clusters/sharding), depending on
    which part of the documentation you’re reading. RavenDB includes secondary indices
    wrapped with a homegrown [query language](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/querying/how-to-query),
    [multiple revisions of documents](https://ravendb.net/docs/article-page/6.0/csharp/document-extensions/revisions/overview),
    [time series](https://ravendb.net/docs/article-page/6.0/csharp/document-extensions/timeseries/overview)
    datatypes, and [CRDT](https://crdt.tech/)-based [counters](https://ravendb.net/why-ravendb/multi-model).
    In this text, we’ll focus on RavenDB’s transactional key-value operations.
  prefs: []
  type: TYPE_NORMAL
- en: Replication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Per RavenDB’s [High Availability](https://ravendb.net/why-ravendb/high-availability)
    page, the database accepts writes and reads across all nodes in the cluster. It
    uses the [Raft](https://raft.github.io/) consensus algorithm, which should theoretically
    allow RavenDB to provide consistency models up to [Strong Serializability](https://jepsen.io/consistency/models/strict-serializable).
    However, that page goes on to say operators can “easily setup a topology in which
    end points operate … independently in case the network is disrupted.” In a blog
    post, CEO Oren Eini repeats this claim:'
  prefs: []
  type: TYPE_NORMAL
- en: If a node is located in a place where the internet connectivity goes down, that
    node can continue to operate offline, taking in data locally. Once the connection
    is restored, the node will take the data it processed and replicate it throughout
    your cluster.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This would make ACID transactions impossible. The “I” in ACID refers to “Isolation”:
    transactions must appear to execute independently, without interference from other
    transactions. This property is formalized as [Serializability](https://jepsen.io/consistency/models/serializable):
    equivalence to some totally ordered, non-concurrent execution of transactions.
    We know that totally available systems [cannot offer](https://jepsen.io/consistency)
    Serializability or even [Snapshot Isolation](https://jepsen.io/consistency/models/snapshot-isolation).
    RavenDB might offer [Causal](https://jepsen.io/consistency/models/causal) or [Read
    Committed](https://jepsen.io/consistency/models/read-committed), but the stronger
    consistency models are theoretically off-limits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A [second page on high availability](https://ravendb.net/features/clusters/high-availability)
    explains that there are two layers within RavenDB, and that Raft is used only
    for cluster metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the cluster layer is managed by a consensus protocol called Raft. In
    CAP theorem it is CP (consistent and partition tolerant).
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The second layer, the database layer, is AP (it is always available, even if
    there is a partition, and it’s eventually consistent) and is handled by a gossip
    protocol between the databases on different nodes, forming multi-master mesh and
    replicating data between each other.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RavenDB utilizes the different layers for different purposes. At the cluster
    layer, the consensus protocol ensures that operators have the peace of mind of
    knowing that their commands are accepted and followed. At the database layer you
    know that RavenDB will never lose writes and will always keep your data safe.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is also confusing. AP systems are known for availability, not safety; lost
    update is a well-understood problem in AP registers. RavenDB claims to offer transactions
    with ACID guarantees. However, these transactions are apparently routed through
    an eventually-consistent, totally available replication system. There are [databases
    which couple](https://docs.datomic.com/pro/getting-started/brief-overview.html)
    an (e.g.) Sequential transaction coordinator to an eventually-consistent datastore
    to provide Serializability, but it’s not clear from this documentation how RavenDB
    links cluster and database layers together to ensure safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [Inside RavenDB chapter on cluster design](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/6-ravendb-clusters)
    confirms that Raft is used only for cluster metadata. Writes are allowed on every
    node, and are totally available:'
  prefs: []
  type: TYPE_NORMAL
- en: RavenDB uses multi-master replication inside a database, and it’s always able
    to accept writes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, even if the majority of the cluster is down, as long as a single
    node is available, we can still process reads and writes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On the other hand, RavenDB’s [ACID Transactions in NoSQL](https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb)
    post claims the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: As in the single node version, RavenDB commits a transaction with just one round
    of Raft consensus.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If Raft *is* involved in the transactions, RavenDB can offer up to Strong Serializability—but
    transactions cannot be totally available. Indeed, RavenDB’s [clustering documentation](https://ravendb.net/docs/article-page/6.0/Csharp/server/clustering/cluster-transactions)
    clarifies there are actually two separate transaction paths. The default mode
    is called a *single-node* transaction, which allows conflicts “when two clients
    try to modify the same set of documents on two different database nodes.” A *cluster-wide
    transaction* uses Raft to prevent conflicts, allowing transactions to “favor consistency
    over availability.” To execute a cluster-wide transaction, one [must set](https://ravendb.net/docs/article-page/6.0/java/client-api/session/saving-changes#transaction-mode---cluster-wide)
    `TransactionMode = CLUSTER_WIDE`.
  prefs: []
  type: TYPE_NORMAL
- en: What safety properties do these transaction paths guarantee? For this, we need
    to consider RavenDB’s ACID claims in detail.
  prefs: []
  type: TYPE_NORMAL
- en: ACID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RavenDB’s [home page](https://ravendb.net/why-ravendb) prominently advertises
    “ACID database transactions” “across multiple documents and across your entire
    cluster.” Its [ACID Database Transactions](https://ravendb.net/why-ravendb/acid-transactions)
    page explains that a database without transactions is “not much of a database.”
    It boasts that RavenDB “guarantee[s] ACID without sacrificing performance” and
    notes that because of its distributed ACID guarantees, “developers are exempt
    from handling the numerous scenarios of partial data transfers and the intricacies
    of data storage.”
  prefs: []
  type: TYPE_NORMAL
- en: 'RavenDB’s [ACID Transactions in NoSQL](https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb)
    article explains that RavenDB “was capable of multi-document transactions since
    version 1.0”:'
  prefs: []
  type: TYPE_NORMAL
- en: Because it was optimized with this in mind, there wasn’t even a need for a non-ACID
    option. Any combination of database operations can be combined into an ACID transaction.
    As a user you never needed to implement ACID guarantees yourself, and you were
    free to design documents around your own requirements….
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RavenDB was designed to make one and only one round trip to the server per transaction.
    RavenDB’s version of the session object tracks a series of commands, collects
    them as a batch, and sends them all to the server in a single round-trip when
    the method `session.saveChanges()` is called.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Again, [RavenDB claims](https://ravendb.net/articles/acid-cluster-distributed-nonrelational-database)
    to have been “the pioneer database to offer ACID in a nonrelational context. In
    2010, RavenDB offered ACID consistency across multiple documents.” However, these
    guarantees held only on a single node: concurrent clients on different nodes could
    violate isolation. RavenDB 4.0, released in fall 2020, introduced the cluster-wide
    transaction path, which took transactions “from being ACID over multiple documents
    to being ACID over your entire cluster.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [Transaction FAQ](https://ravendb.net/docs/article-page/6.0/csharp/client-api/faq/transaction-support)
    says “all actions performed on documents are fully ACID” but contradicts itself
    immediately, saying “in a single transaction, all operations operate under snapshot
    isolation.” [DBDB](https://dbdb.io/db/ravendb) takes this to mean that RavenDB
    offers Snapshot Isolation by default. In a [2020 webinar](https://www.youtube.com/watch?v=5ZXBR3croMA&t=39m),
    CEO Oren Eini confirmed this position: “RavenDB uses Snapshot Isolation by default,
    and transactions are effectively going to observe Serializable between operations
    that happen on the same node.”'
  prefs: []
  type: TYPE_NORMAL
- en: There are hints that RavenDB might provide something much weaker than Snapshot
    Isolation. Buried in the *Inside RavenDB* book, in the chapter on document modeling,
    is a [section on concurrency control](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#concurrency-control).
    This section explains that RavenDB (at least in version 4.0) performed no concurrency
    control, and instead used Last Write Wins conflict resolution by default.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if two requests are trying to modify the same document at the same
    time? That depends on what, exactly, you asked RavenDB to do. If you didn’t do
    anything, RavenDB will execute those two modifications one at a time, and the
    last one will win. There’s no way to control which would be last. Note that both
    operations will execute.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is the *opposite* of ACID isolation. Isolated transactions appear to execute
    sequentially, not concurrently. It also contradicts claims of Snapshot Isolation:
    Last Write Wins registers allow all kinds of anomalies which would be prohibited
    under Snapshot Isolation, including [lost update](https://dzone.com/articles/conflict-resolution-using-last-write-wins-vs-crdts).
    However, this book is two major releases out of date; it may not apply to 6.0.2.'
  prefs: []
  type: TYPE_NORMAL
- en: What about cluster-wide transactions? The [Cluster Transactions](https://ravendb.net/docs/article-page/6.0/java/server/clustering/cluster-transactions#concurrent-cluster-wide-and-single-node-transactions)
    page seems definitive. “Concurrent cluster-wide transactions are guaranteed to
    appear as if they are run one at a time (`serializable` isolation level).”
  prefs: []
  type: TYPE_NORMAL
- en: From this, Jepsen infers that RavenDB’s default transaction settings should
    ensure Snapshot Isolation by default and Serializability in a single-node system.
    Cluster-wide transactions should ensure Serializability globally.
  prefs: []
  type: TYPE_NORMAL
- en: Test Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2020 RavenDB [wrote their own Jepsen test](https://github.com/ml054/jepsen/)
    and declared in [a webinar](https://www.youtube.com/watch?v=5ZXBR3croMA&) that
    per that test, “everything works.” Their test checked the linearizability of individual
    [reads and writes](https://github.com/ml054/jepsen/blob/08960da98ab9bf7959fce014c63b146b903cbe6c/ravendb/src/jepsen/ravendb.clj#L164-L196)
    against a single document. It did not evaluate multi-operation or multi-document
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: We designed a [new test harness](https://github.com/jepsen-io/ravendb/tree/4431310402f334ffdb18a5a7ec819316847b642b)
    for RavenDB 6.0.2 running on a single Debian Bookworm node. Our test used RavenDB’s
    JVM client library at version 5.0.4\. We did not evaluate multi-node clusters
    or any kind of faults.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote a single list-append workload using [Elle](https://github.com/jepsen-io/elle)
    to verify transactional isolation. This workload performs transactions over lists,
    each list identified by a unique integer ID. Each transaction consists of reads
    and/or appends of unique integers to those lists. Each worker thread in the test
    [opens a single DocumentStore](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/client.clj#L26-L31C15)
    connected to the same node. Each transaction creates a new [session](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/client.clj#L54-L62),
    performs [reads and/or appends](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/append.clj#L25-L41),
    then calls [`session.saveChanges()`](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/client.clj#L90)
    to commit. Reads are encoded as a [single call](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/append.clj#L26-L28)
    to `session.load(java.util.Map, id)`. Appends call `session.load` to read the
    current value, add their integer element to the end of the list, then call [`session.store(map,
    key)`](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/append.clj#L40).
  prefs: []
  type: TYPE_NORMAL
- en: 'RavenDB offers a few knobs for tuning transaction safety: `transactionMode`
    and `optimisticConcurrency`. We ran our tests using the defaults (single-node
    transactions, no optimistic concurrency), with single-node transactions and optimistic
    concurrency, and finally with cluster-wide transactions. Cluster-wide transactions
    cannot be combined with optimistic concurrency.'
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We found surprising safety errors in all three transaction modes.
  prefs: []
  type: TYPE_NORMAL
- en: Lost Update with Single-Node Transactions (#17927)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, RavenDB executes transactions with `transactionMode = SINGLE_NODE`
    and `optimisticConcurrency = false`. One might assume that `SINGLE_NODE` transactions
    are safe on single-node clusters. However, we found the default settings caused
    RavenDB to lose updates constantly, even in single-node clusters without faults.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in this [five-second test run](https://github.com/ravendb/ravendb/files/13794868/20231229T102201.960-0600.zip)
    we performed 12,886 transactions over 975 keys. 81 of those keys exhibited a provable
    lost update. Here are two committed transactions involving key 830:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these transactions read key 830’s value as the list `[1, 2]`. Both
    went on to append a value to key 830: the first transaction appended `3`, and
    the second transaction appended `4`. Neither saw the other’s effects. In a Snapshot
    Isolated system, the *first-committer-wins* rule demands that one of these transactions
    must abort. RavenDB, however, allowed both transactions to commit. This is the
    definition of a lost update anomaly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an isolated transaction system which only ever appends elements to lists,
    every observed version of a single list must be a prefix of the longest version
    of that list. However, 454 of the keys in this test violated this prefix property,
    exhibiting *incompatible orders*. For example, here are all the reads of key 116:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3.01 | 1 | [1 2] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 1 | [1 2] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 0 | [1 2] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 1 | [1 2 3] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 0 | [1 2 4] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 1 | [1 2 4 5] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 0 | [1 2 4] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 1 | [1 2 4 6] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 1 | [1 2 4 6] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 1 | [1 2 4 6 9] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 1 | [1 2 4 6 9 10] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 1 | [1 2 4 6 9 10 11 15] |'
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 0 | [1 2 4 6 9 10 11 15] |'
  prefs: []
  type: TYPE_TB
- en: Just over three seconds into the test, process 1 observed key 116’s state as
    `[1 2 3]`. However, an immediately following read by process 0 saw `[1 2 4]`,
    and the write of `3` never appeared again. Process 1 then observed `[1 2 4 5]`.
    This write of `5` was replaced by `6` and never seen again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our lost update checker is conservative: it only infers an anomaly if two transactions
    read the same version of some key *and* both write to it. However, our `append`
    operations are performed by reading the value, then writing back changes. This
    means these transactions contain reads which are effectively invisible to the
    checker. It seems likely that these cases of incompatible order also represent
    lost updates.'
  prefs: []
  type: TYPE_NORMAL
- en: In total, 481 out of the 975 keys in this test exhibited lost updates or incompatible
    orders. These phenomena are prohibited by Serializability, Snapshot Isolation,
    and Repeatable Read. We’ve reported this as [issue 17927](https://github.com/ravendb/ravendb/issues/17927)
    in RavenDB’s issue tracker.
  prefs: []
  type: TYPE_NORMAL
- en: Fractured Reads with Optimistic Concurrency (#17929)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the *[optimistic concurrency](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/configuration/how-to-enable-optimistic-concurrency)*
    feature enabled, RavenDB promises to “generate a concurrency exception (and abort
    all modifications in the current transaction) when the document has been modified
    on the server side after the client received and modified it.” When running on
    a single node, this setting does appear to prevent lost updates. However, it allows
    fractured reads—as well as various flavors of G-Single, G-nonadjacent, and G2-item.
    Again, these anomalies occurred in a healthy single-node system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider this [ten-second test run](https://s3.amazonaws.com/jepsen.io/analyses/ravendb-6.0.2/20231229T140050.249-0600.zip)
    in which every transaction enabled optimistic concurrency. Our checker found hundreds
    of anomalies like this:'
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram the top transaction *T*[1] appended `3` to key 271, then appended
    `2` to key 279\. The bottom transaction *T*[2] read key 271 and found nothing,
    appended 6 to key 276, and finally read key 279’s value as `[2]`. Because *T*[2]
    failed to observe *T*[1]’s append to key 271, we have a read-write anti-dependency,
    denoted `rw`. Because *T*[2] observed *T*[1]’s append to key 279, we have a write-read
    dependency, denoted `wr`. In short, *T*[2] observed some, but not all, of the
    effects of *T*[1].
  prefs: []
  type: TYPE_NORMAL
- en: 'This anomaly is called *fractured read*, and it is prohibited under Read Atomic,
    Update Atomic, Causal, Prefix, Parallel Snapshot Isolation, Snapshot Isolation,
    Repeatable Read, and Serializable. RavenDB’s [Transaction FAQ](https://ravendb.net/docs/article-page/6.0/csharp/client-api/faq/transaction-support)
    promises Snapshot Isolation: “even if you access multiple documents, you’ll get
    all of their state as it was in the beginning of the request.” In all Snapshot
    Isolated databases Jepsen is familiar with, snapshots extend across multiple reads.
    In RavenDB, it appears each read can observe a different state. We’ve reported
    this as [issue #17929](https://github.com/ravendb/ravendb/issues/17929) to RavenDB.'
  prefs: []
  type: TYPE_NORMAL
- en: Fractured Read with Cluster-Wide Transactions (#17928)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cluster-wide transactions are [supposed to be Serializable](https://ravendb.net/docs/article-page/6.0/csharp/server/clustering/cluster-transactions).
    However, we found that even healthy, single-node clusters in which every transaction
    used `CLUSTER_WIDE` mode routinely exhibited fractured reads, as well as G-single,
    G-nonadjacent, G2-item, and more. Consider this [five second test run](https://s3.amazonaws.com/jepsen.io/analyses/ravendb-6.0.2/20231229T145350.284-0600.zip),
    which contained hundreds of serializability violations. Here is one of those anomalies:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the bottom transaction *T*[2] appended `6` to key 146 and `1` to key 149\.
    The top transaction *T*[1] failed to observe *T*[2]’s append to key 149, but *did*
    observe its append to key 146\. This is another instance of fractured read. As
    before, this behavior appears to be proscribed by RavenDB’s documentation, as
    well as all consistency models above Read Atomic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve reported this to RavenDB as [issue #17928](https://github.com/ravendb/ravendb/issues/17928).'
  prefs: []
  type: TYPE_NORMAL
- en: '| 17927 | Lost update with single-node transactions | None | Unresolved |'
  prefs: []
  type: TYPE_TB
- en: '| 17929 | Fractured read with optimistic concurrency | None | Unresolved |'
  prefs: []
  type: TYPE_TB
- en: '| 17928 | Fractured read with cluster-wide transactions | None | Unresolved
    |'
  prefs: []
  type: TYPE_TB
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RavenDB variously claims to offer “fully ACID” transactions, Serializability,
    or at least Snapshot Isolation. All of these claims appear false. RavenDB 6.0.2’s
    default settings allowed lost updates. Even cluster-wide transactions exhibited
    fractured reads: a serious anomaly prohibited under Snapshot Isolation, as well
    as several weaker models. These behaviors occur even in healthy, single-node,
    single-shard systems, in which all access occurs via primary key.'
  prefs: []
  type: TYPE_NORMAL
- en: RavenDB’s strongest safety settings violate Read Atomic. It therefore cannot
    satisfy Update Atomic, Causal, Prefix, Parallel Snapshot Isolation, Snapshot Isolation,
    Repeatable Read, or Serializable. RavenDB might offer Read Committed or Monotonic
    Atomic View, but without more rigorous testing, Jepsen is hesitant to make this
    claim.
  prefs: []
  type: TYPE_NORMAL
- en: 'RavenDB’s weak default behavior is surprising given RavenDB’s repeated emphasis
    on safety. As CEO Oren Eini [remarked](https://www.youtube.com/watch?v=5ZXBR3croMA&t=850s)
    on MongoDB’s transaction safety settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Default] values matter. They matter quite a lot. Why is that? Because if you
    choose the bad values, you’re absolutely going to get some great numbers in benchmark
    performance. But then you are going to be hitting those [safety] issues in production.
    And then there is this classic response: “Oh, you should have read the docs and
    used the proper configuration.”'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'One wonders: if ACID properties are so important for RavenDB’s users, why do
    the default settings allow lost updates, even on single-key operations? Do users
    realize their updates can be silently discarded? How many are taking care to use
    cluster-wide transactions where lost updates would violate safety? Do they know
    that even cluster-wide transactions allow fractured read?'
  prefs: []
  type: TYPE_NORMAL
- en: 'This report follows a cursory investigation into RavenDB’s behavior—it is by
    no means exhaustive. As always, we caution that Jepsen takes an experimental approach
    to safety verification: we can prove the presence of bugs, but not their absence.
    There may be other anomalies in RavenDB.'
  prefs: []
  type: TYPE_NORMAL
- en: Does RavenDB Even Have Transactions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first sentence of RavenDB’s [cluster transaction documentation](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/cluster-transaction/overview)
    appears quite clear:'
  prefs: []
  type: TYPE_NORMAL
- en: A session represents a single business transaction.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is echoed by the first sentence of RavenDB’s [session documentation](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work):'
  prefs: []
  type: TYPE_NORMAL
- en: The Session, which is obtained from the Document Store, is a Unit of Work that
    represents a single business transaction on a particular database.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '… which goes on to say:'
  prefs: []
  type: TYPE_NORMAL
- en: The batched operations that are sent in the `SaveChanges()` will complete transactionally.
    In other words, either all changes are saved as a Single Atomic Transaction or
    none of them are. So once SaveChanges returns successfully, it is guaranteed that
    all changes are persisted to the database.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RavenDB sessions are clearly not intended to work like sessions in typical databases,
    which are (roughly speaking) [one-to-one with client connections](https://www.postgresql.org/docs/current/tutorial-arch.html).
    They come with a default limit of [30 network requests](https://ravendb.net/docs/article-page/5.4/java/client-api/session/what-is-a-session-and-how-does-it-work#remarks);
    typical database sessions are unbounded. They buffer writes; Jepsen is unaware
    of any other database whose sessions do this. They cache reads; most sessions
    do not. They include concurrency control mechanisms like lost update prevention;
    Jepsen is unaware of any other database which does this at the session level.
    These are all hallmarks of what most databases would call a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'RavenDB’s article [ACID Transactions in NoSQL? RavenDB vs MongoDB](https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb)
    is emphatic: RavenDB has supported ACID transactions over “any combination of
    database operations” for over a decade. It certainly appears as if RavenDB sessions
    are intended for this role!'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in a [response to issue 17927](https://github.com/ravendb/ravendb/issues/17927#issuecomment-1872912239),
    Eini (a.k.a. Ayende Rahien) explained that sessions are *not* in fact transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: Crucially, RavenDB does not attempt to provide transactional semantics over
    the entire session, rather it provide[s] transactions over individual requests.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And in [response to issue #17928](https://github.com/ravendb/ravendb/issues/17928#issuecomment-1872916841),
    Eini affirms:'
  prefs: []
  type: TYPE_NORMAL
- en: A transaction in RavenDB is a request - so TX1 and TX2 above aren’t actually
    single transactions, instead, each of them represent 3 independent transactions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is a striking viewpoint: the point of transactions is generally to provide
    isolation across multiple requests. Moreover, RavenDB’s optimistic concurrency
    and cluster-wide transaction mechanisms are clearly intended to provide transactional
    isolation which spans from a session’s reads to its writes. Furthermore, Eini
    [directly compared RavenDB sessions to MongoDB transactions](https://www.youtube.com/watch?v=5ZXBR3croMA&t=23m40s)
    (which offer typical interactive transaction semantics) and claimed that unlike
    MongoDB, RavenDB sessions actually satisfied Snapshot Isolation. Yet per Eini’s
    comments, RavenDB *does not have interactive transactions at all*.'
  prefs: []
  type: TYPE_NORMAL
- en: Repeatedly advertising “ACID transactions” across “any combination of database
    operations,” telling users that a “session represents a single business transaction,”
    comparing RavenDB sessions to interactive transactions in other databases, offering
    concurrency control mechanisms whose scope extends across an entire session, and
    finally expecting users to realize that sessions are not transactions at all—that
    a transaction is actually limited to a single HTTP request—stretches credulity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jepsen strives to evaluate databases in the context of their marketing and
    documentation. Although RavenDB’s CEO [now states](https://github.com/ravendb/ravendb/issues/17928#issuecomment-1874064897)
    “we don’t support a transaction over more than a single HTTP request,” RavenDB’s
    documentation and marketing give every appearance that a session is intended to
    be a transaction. Jepsen has consulted with several software engineers on their
    interpretation of these claims, and believes typical database users would come
    to the same conclusion: RavenDB sessions are transactions. We continue this interpretation
    throughout this report.'
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RavenDB users should be aware RavenDB transactions are not ACID in any meaningful
    sense. This holds even in single-node, single-shard deployments. The defaults
    allow lost updates: you should expect some of your writes to be silently discarded.
    The strongest safety settings allow fractured read: you might observe some, but
    not all, of another transaction’s effects. You could appear to write “into the
    middle” of another transaction. The two isolation levels RavenDB advertises—Snapshot
    Isolation and Serializable—appear impossible to obtain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Users who designed their applications assuming RavenDB provided interactive
    ACID transactions—or even Snapshot Isolation—should carefully reevaluate their
    transactions to ensure they are safe in the presence of these anomalies. Consider
    writing simple tests to verify application invariants are preserved under concurrent
    execution: the issues in this report are easy to reproduce.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jepsen recommends RavenDB remove claims of “ACID”, “Serializable”, and “Snapshot
    Isolation” from their marketing materials and documentation. RavenDB should instead
    make specific, accurate, and internally consistent claims about safety properties.
    For instance, RavenDB might say “transactions offer Read Committed by default,
    plus internal consistency within the scope of a transaction: once a transaction
    reads a key, subsequent reads and writes of that key observe the originally read
    state, plus the effects of that particular transaction’s writes. Transactions
    allow lost update by default. Enabling cluster-wide transactions prevents lost
    update, but still allows fractured read,” and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'RavenDB’s documentation is remarkably confusing. It repeatedly claims to offer
    [ACID transactions](https://ravendb.net/why-ravendb/acid-transactions), which
    implies Serializability. There are specific claims that RavenDB ensures either
    [Serializability](https://ravendb.net/docs/article-page/6.0/csharp/server/clustering/cluster-transactions#case-1-multiple-concurrent-cluster-transactions)
    or [Snapshot Isolation](https://www.youtube.com/watch?v=5ZXBR3croMA). However,
    the documentation also says that RavenDB’s database layer is an [AP system](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/6-ravendb-clusters)
    based on Last Write Wins, and the marketing material claims isolated nodes can
    operate [independently](https://ravendb.net/why-ravendb/high-availability). This
    is impossible: totally available systems [cannot provide](https://jepsen.io/consistency)
    Serializability or Snapshot Isolation.'
  prefs: []
  type: TYPE_NORMAL
- en: There are systems (like [Riak](https://riak.com/index.html) & [Cassandra](https://cassandra.apache.org/_/index.html))
    which allow clients to execute either totally available operations with weak consistency,
    or majority available operations with stronger guarantees, like Linearizability.
    If RavenDB intends to build a system which supports both modes, they should clearly
    distinguish those modes throughout marketing and documentation. They have completely
    different availability, latency, and safety characteristics. Repeated claims that
    RavenDB provides ACID “[without sacrificing performance](https://ravendb.net/why-ravendb/acid-transactions)”
    are [provably impossible](https://lamport.azurewebsites.net/pubs/lower-bound.pdf),
    and should be rewritten to clearly explain the tradeoffs involved.
  prefs: []
  type: TYPE_NORMAL
- en: ACID transactions are clearly important to RavenDB. It is therefore alarming
    that RavenDB’s documentation and GitHub comments fundamentally disagree on what
    a transaction *is*. In one interpretation, RavenDB offers interactive transactions,
    represented by the session API, which provide relatively weak isolation—certainly
    not ACID. In another interpretation, RavenDB lacks interactive transactions altogether.
    Instead, it offers a sort of micro-transaction which (e.g.) writes multiple documents
    in a single network request. In this world, sessions offer varying, weak consistency
    constraints that extend *between* micro-transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this confusion, RavenDB should pick a single definition of “transaction”
    and stick with it. The equivalence or difference between a transaction and session
    should be clearly explained, and these terms used consistently throughout marketing
    and documentation. RavenDB should provide guidance as to the boundaries of each
    unit: when are multiple calls to `load` performed in a single transaction? What
    about `store`? Can a single transaction encompass both a `load` and `store`? The
    consistency properties of both transactions and sessions should be clearly and
    formally defined. Are transactions Serializable? Do sessions ensure Monotonic
    Atomic View? When does a session preclude lost update, and when does it allow
    it? Above all, do not [tell](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/cluster-transaction/overview)
    [users](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work)
    that sessions “represent a single business transaction” if they are, in point
    of fact, not transactions at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if RavenDB transactions are truly intended to cover only a single network
    request, consider using a different term altogether, and avoid comparisons to
    databases which do have interactive transactions. Some databases call these “mini-”
    or “micro-transactions,” which provides an obvious hint of their limited scope.
  prefs: []
  type: TYPE_NORMAL
- en: Future Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This work evaluated only single-node RavenDB clusters without faults. Future
    research could expand tests across multiple nodes, as well as introducing network,
    process, and disk faults. We dealt only with key-value operations, and did not
    evaluate RavenDB’s secondary indices. These indices are described as eventually
    consistent, which raises questions around the integrity of predicate reads. RavenDB
    also offers [server-side transactions](https://ravendb.net/docs/article-page/6.0/csharp/client-api/operations/patching/single-document)
    using Javascript or a library of built-in patch operations. These might offer
    different safety characteristics than the interactive transactions we used in
    this report. Finally, cross-shard transactions are a notoriously challenging problem
    and deserve careful testing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Jepsen wishes to thank [Irene Kannyo](https://www.irenekannyo.com/) for her
    invaluable editorial support. Thanks as well to C. Scott Andreas, Taber Bain,
    Silvia Botros, Coda Hale, Ben Linsay, Kelly Shortridge, Nathan Taylor, Zach Tellman,
    and Leif Walsh for their comments on early versions of this manuscript. This work
    was performed independently without compensation, in accordance with the [Jepsen
    ethics policy](https://jepsen.io/ethics).*'
  prefs: []
  type: TYPE_NORMAL
