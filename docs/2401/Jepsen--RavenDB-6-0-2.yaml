- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-27 15:23:29'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 15:23:29
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'Jepsen: RavenDB 6.0.2'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jepsen：RavenDB 6.0.2
- en: 来源：[https://jepsen.io/analyses/ravendb-6.0.2](https://jepsen.io/analyses/ravendb-6.0.2)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://jepsen.io/analyses/ravendb-6.0.2](https://jepsen.io/analyses/ravendb-6.0.2)
- en: Background
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景
- en: '[RavenDB](https://ravendb.net) is a distributed document database which [repeatedly
    advertises](https://ravendb.net/why-ravendb) its support for ACID transactions.
    It’s intended for OLTP workloads, and offers a variety of [ETL paths](https://ravendb.net/docs/article-page/6.0/csharp/server/ongoing-tasks/etl/basics)
    for exporting data to other systems. Its transactional API revolves around a [session](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work)
    handle, which “represents a single business transaction on a particular database.”
    Users create a session, perform operations like reads and writes, and finally
    call `session.saveChanges()` to commit their writes as an atomic unit.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[RavenDB](https://ravendb.net)是一个分布式文档数据库，[反复宣传](https://ravendb.net/why-ravendb)其支持ACID事务。它旨在处理OLTP工作负载，并提供各种[ETL路径](https://ravendb.net/docs/article-page/6.0/csharp/server/ongoing-tasks/etl/basics)以将数据导出到其他系统。其事务性API围绕着一个[会话](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work)句柄展开，“代表特定数据库上的单个业务交易。”用户创建会话，执行读取和写入等操作，最后调用`session.saveChanges()`以提交其写入为原子单位。'
- en: RavenDB can [replicate data across a set of nodes with automated failover](https://ravendb.net/why-ravendb/high-availability).
    Sharding is either a [work in progress](https://issues.hibernatingrhinos.com/issue/RavenDB-8115)
    or [ready in 6.0](https://ravendb.net/features/clusters/sharding), depending on
    which part of the documentation you’re reading. RavenDB includes secondary indices
    wrapped with a homegrown [query language](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/querying/how-to-query),
    [multiple revisions of documents](https://ravendb.net/docs/article-page/6.0/csharp/document-extensions/revisions/overview),
    [time series](https://ravendb.net/docs/article-page/6.0/csharp/document-extensions/timeseries/overview)
    datatypes, and [CRDT](https://crdt.tech/)-based [counters](https://ravendb.net/why-ravendb/multi-model).
    In this text, we’ll focus on RavenDB’s transactional key-value operations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: RavenDB可以通过自动故障转移在一组节点之间[复制数据](https://ravendb.net/why-ravendb/high-availability)。分片是[正在进行中](https://issues.hibernatingrhinos.com/issue/RavenDB-8115)或[在6.0中已准备就绪](https://ravendb.net/features/clusters/sharding)，这取决于您正在阅读文档的部分。RavenDB包括与自制[查询语言](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/querying/how-to-query)包装的次要索引，[文档的多个修订版本](https://ravendb.net/docs/article-page/6.0/csharp/document-extensions/revisions/overview)，[时间序列](https://ravendb.net/docs/article-page/6.0/csharp/document-extensions/timeseries/overview)数据类型和基于[CRDT](https://crdt.tech/)的[计数器](https://ravendb.net/why-ravendb/multi-model)。在本文中，我们将重点介绍RavenDB的事务键值操作。
- en: Replication
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制
- en: 'Per RavenDB’s [High Availability](https://ravendb.net/why-ravendb/high-availability)
    page, the database accepts writes and reads across all nodes in the cluster. It
    uses the [Raft](https://raft.github.io/) consensus algorithm, which should theoretically
    allow RavenDB to provide consistency models up to [Strong Serializability](https://jepsen.io/consistency/models/strict-serializable).
    However, that page goes on to say operators can “easily setup a topology in which
    end points operate … independently in case the network is disrupted.” In a blog
    post, CEO Oren Eini repeats this claim:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RavenDB的[高可用性](https://ravendb.net/why-ravendb/high-availability)页面，数据库接受集群中所有节点上的写入和读取。它使用[Raft](https://raft.github.io/)共识算法，理论上应允许RavenDB提供高达[强一致性](https://jepsen.io/consistency/models/strict-serializable)的一致性模型。然而，该页面继续说操作员可以“轻松设置拓扑结构，其中端点在网络中断的情况下可以独立运行”。在一篇博客文章中，首席执行官Oren
    Eini重复了这一说法：
- en: If a node is located in a place where the internet connectivity goes down, that
    node can continue to operate offline, taking in data locally. Once the connection
    is restored, the node will take the data it processed and replicate it throughout
    your cluster.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一个节点位于网络连接中断的地方，该节点可以继续离线操作，本地接收数据。一旦连接恢复，节点将获取其处理的数据并在整个集群中复制。
- en: 'This would make ACID transactions impossible. The “I” in ACID refers to “Isolation”:
    transactions must appear to execute independently, without interference from other
    transactions. This property is formalized as [Serializability](https://jepsen.io/consistency/models/serializable):
    equivalence to some totally ordered, non-concurrent execution of transactions.
    We know that totally available systems [cannot offer](https://jepsen.io/consistency)
    Serializability or even [Snapshot Isolation](https://jepsen.io/consistency/models/snapshot-isolation).
    RavenDB might offer [Causal](https://jepsen.io/consistency/models/causal) or [Read
    Committed](https://jepsen.io/consistency/models/read-committed), but the stronger
    consistency models are theoretically off-limits.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 ACID 事务变得不可能。ACID 中的“I”指的是“隔离”：事务必须看起来是独立执行的，不受其他事务干扰。这个属性被形式化为[可串行化](https://jepsen.io/consistency/models/serializable)：等价于一些完全有序的、非并发的事务执行。我们知道完全可用的系统[无法提供](https://jepsen.io/consistency)可串行化甚至[快照隔离](https://jepsen.io/consistency/models/snapshot-isolation)。RavenDB
    可能提供[因果一致性](https://jepsen.io/consistency/models/causal)或[读取已提交](https://jepsen.io/consistency/models/read-committed)，但更强的一致性模型在理论上是被限制的。
- en: 'A [second page on high availability](https://ravendb.net/features/clusters/high-availability)
    explains that there are two layers within RavenDB, and that Raft is used only
    for cluster metadata:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[高可用性的第二页](https://ravendb.net/features/clusters/high-availability)解释了 RavenDB
    中存在两个层次，而 Raft 仅用于集群元数据：'
- en: First, the cluster layer is managed by a consensus protocol called Raft. In
    CAP theorem it is CP (consistent and partition tolerant).
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，集群层由一种叫做 Raft 的一致性协议管理。在 CAP 定理中它是 CP（一致性和分区容忍）的。
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The second layer, the database layer, is AP (it is always available, even if
    there is a partition, and it’s eventually consistent) and is handled by a gossip
    protocol between the databases on different nodes, forming multi-master mesh and
    replicating data between each other.
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二层，即数据库层，是 AP 的（即使有分区也始终可用，并且最终一致），并且由不同节点上的数据库之间的八卦协议处理，形成多主网状结构，并在彼此之间复制数据。
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RavenDB utilizes the different layers for different purposes. At the cluster
    layer, the consensus protocol ensures that operators have the peace of mind of
    knowing that their commands are accepted and followed. At the database layer you
    know that RavenDB will never lose writes and will always keep your data safe.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RavenDB 利用不同的层次来达到不同的目的。在集群层面，一致性协议确保运算者可以放心知道他们的命令被接受并执行。在数据库层面，你知道 RavenDB
    永远不会丢失写入数据，并且始终保持你的数据安全。
- en: This is also confusing. AP systems are known for availability, not safety; lost
    update is a well-understood problem in AP registers. RavenDB claims to offer transactions
    with ACID guarantees. However, these transactions are apparently routed through
    an eventually-consistent, totally available replication system. There are [databases
    which couple](https://docs.datomic.com/pro/getting-started/brief-overview.html)
    an (e.g.) Sequential transaction coordinator to an eventually-consistent datastore
    to provide Serializability, but it’s not clear from this documentation how RavenDB
    links cluster and database layers together to ensure safety.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这也让人困惑。AP 系统以可用性而闻名，而不是安全性；在 AP 寄存器中，丢失更新是一个被充分理解的问题。RavenDB 声称提供带有 ACID 保证的事务。然而，这些事务显然是通过一个最终一致、完全可用的复制系统路由的。有[数据库将](https://docs.datomic.com/pro/getting-started/brief-overview.html)一个（例如）顺序事务协调器与一个最终一致的数据存储耦合在一起，以提供可串行化，但从这份文档中并不清楚
    RavenDB 如何将集群和数据库层链接在一起以确保安全。
- en: 'The [Inside RavenDB chapter on cluster design](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/6-ravendb-clusters)
    confirms that Raft is used only for cluster metadata. Writes are allowed on every
    node, and are totally available:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[RavenDB 集群设计章节内部](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/6-ravendb-clusters)确认
    Raft 仅用于集群元数据。允许在每个节点上写入，并且完全可用：'
- en: RavenDB uses multi-master replication inside a database, and it’s always able
    to accept writes.
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RavenDB 在数据库内部使用多主复制，并且总是能够接受写入。
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, even if the majority of the cluster is down, as long as a single
    node is available, we can still process reads and writes.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 换句话说，即使大多数集群宕机，只要有一个节点可用，我们仍然可以处理读取和写入。
- en: 'On the other hand, RavenDB’s [ACID Transactions in NoSQL](https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb)
    post claims the opposite:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，RavenDB 的[NoSQL 中的 ACID 事务](https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb)文章则声称相反：
- en: As in the single node version, RavenDB commits a transaction with just one round
    of Raft consensus.
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与单节点版本一样，RavenDB只需一轮Raft共识即可提交事务。
- en: If Raft *is* involved in the transactions, RavenDB can offer up to Strong Serializability—but
    transactions cannot be totally available. Indeed, RavenDB’s [clustering documentation](https://ravendb.net/docs/article-page/6.0/Csharp/server/clustering/cluster-transactions)
    clarifies there are actually two separate transaction paths. The default mode
    is called a *single-node* transaction, which allows conflicts “when two clients
    try to modify the same set of documents on two different database nodes.” A *cluster-wide
    transaction* uses Raft to prevent conflicts, allowing transactions to “favor consistency
    over availability.” To execute a cluster-wide transaction, one [must set](https://ravendb.net/docs/article-page/6.0/java/client-api/session/saving-changes#transaction-mode---cluster-wide)
    `TransactionMode = CLUSTER_WIDE`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Raft*参与*交易，RavenDB可以提供高强度串行化，但交易不能完全可用。实际上，RavenDB的[集群文档](https://ravendb.net/docs/article-page/6.0/Csharp/server/clustering/cluster-transactions)澄清了实际上有两条不同的事务路径。默认模式称为*单节点*事务，允许冲突“当两个客户端尝试在两个不同的数据库节点上修改相同的一组文档时。”
    *集群范围事务*使用Raft来防止冲突，允许事务“偏向一致性而不是可用性。”要执行集群范围事务，必须[设置](https://ravendb.net/docs/article-page/6.0/java/client-api/session/saving-changes#transaction-mode---cluster-wide)`TransactionMode
    = CLUSTER_WIDE`。
- en: What safety properties do these transaction paths guarantee? For this, we need
    to consider RavenDB’s ACID claims in detail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事务路径保证了哪些安全性质？为此，我们需要详细考虑RavenDB的ACID声明。
- en: ACID
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACID
- en: RavenDB’s [home page](https://ravendb.net/why-ravendb) prominently advertises
    “ACID database transactions” “across multiple documents and across your entire
    cluster.” Its [ACID Database Transactions](https://ravendb.net/why-ravendb/acid-transactions)
    page explains that a database without transactions is “not much of a database.”
    It boasts that RavenDB “guarantee[s] ACID without sacrificing performance” and
    notes that because of its distributed ACID guarantees, “developers are exempt
    from handling the numerous scenarios of partial data transfers and the intricacies
    of data storage.”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: RavenDB的[主页](https://ravendb.net/why-ravendb)显眼地宣传“跨多个文档和整个集群的ACID数据库事务。”它的[ACID数据库事务](https://ravendb.net/why-ravendb/acid-transactions)页面解释说，没有事务的数据库“不算得上是数据库。”它自豪地宣称RavenDB“保证ACID而不牺牲性能”，并指出由于其分布式ACID保证，“开发人员无需处理部分数据传输的众多场景和数据存储的复杂性。”
- en: 'RavenDB’s [ACID Transactions in NoSQL](https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb)
    article explains that RavenDB “was capable of multi-document transactions since
    version 1.0”:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: RavenDB的[ACID Transactions in NoSQL](https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb)文章解释说RavenDB“从1.0版本开始就能够进行多文档事务”：
- en: Because it was optimized with this in mind, there wasn’t even a need for a non-ACID
    option. Any combination of database operations can be combined into an ACID transaction.
    As a user you never needed to implement ACID guarantees yourself, and you were
    free to design documents around your own requirements….
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于它是针对这一点进行了优化，甚至没有必要提供非ACID选项。任何数据库操作的组合都可以合并为ACID事务。作为用户，您无需自己实现ACID保证，而且可以根据自己的需求自由设计文档……
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RavenDB was designed to make one and only one round trip to the server per transaction.
    RavenDB’s version of the session object tracks a series of commands, collects
    them as a batch, and sends them all to the server in a single round-trip when
    the method `session.saveChanges()` is called.
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RavenDB的设计旨在每个事务仅进行一次服务器往返。 RavenDB的会话对象版本跟踪一系列命令，将它们收集为一个批处理，并在调用方法`session.saveChanges()`时将它们全部发送到服务器中进行一次往返。
- en: 'Again, [RavenDB claims](https://ravendb.net/articles/acid-cluster-distributed-nonrelational-database)
    to have been “the pioneer database to offer ACID in a nonrelational context. In
    2010, RavenDB offered ACID consistency across multiple documents.” However, these
    guarantees held only on a single node: concurrent clients on different nodes could
    violate isolation. RavenDB 4.0, released in fall 2020, introduced the cluster-wide
    transaction path, which took transactions “from being ACID over multiple documents
    to being ACID over your entire cluster.”'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，[RavenDB 声称](https://ravendb.net/articles/acid-cluster-distributed-nonrelational-database)
    自己是“在非关系上下文中提供 ACID 的先驱数据库。2010 年，RavenDB 在多个文档上提供了 ACID 一致性。” 但是，这些保证仅在单个节点上保持：不同节点上的并发客户端可能违反隔离。在
    2020 年秋季发布的 RavenDB 4.0 中，引入了整个集群的事务路径，将事务“从在多个文档上执行 ACID 到在整个集群上执行 ACID。”
- en: 'The [Transaction FAQ](https://ravendb.net/docs/article-page/6.0/csharp/client-api/faq/transaction-support)
    says “all actions performed on documents are fully ACID” but contradicts itself
    immediately, saying “in a single transaction, all operations operate under snapshot
    isolation.” [DBDB](https://dbdb.io/db/ravendb) takes this to mean that RavenDB
    offers Snapshot Isolation by default. In a [2020 webinar](https://www.youtube.com/watch?v=5ZXBR3croMA&t=39m),
    CEO Oren Eini confirmed this position: “RavenDB uses Snapshot Isolation by default,
    and transactions are effectively going to observe Serializable between operations
    that happen on the same node.”'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[Transaction FAQ](https://ravendb.net/docs/article-page/6.0/csharp/client-api/faq/transaction-support)
    表示“对文档执行的所有操作都是完全 ACID”，但立即自相矛盾地表示“在单个事务中，所有操作都在快照隔离下运行”。[DBDB](https://dbdb.io/db/ravendb)
    认为这意味着 RavenDB 默认提供快照隔离。在 [2020 年的网络研讨会](https://www.youtube.com/watch?v=5ZXBR3croMA&t=39m)
    中，CEO Oren Eini 确认了这一立场：“RavenDB 默认使用快照隔离，事务在同一节点上发生的操作之间实际上会观察到 Serializable。”'
- en: There are hints that RavenDB might provide something much weaker than Snapshot
    Isolation. Buried in the *Inside RavenDB* book, in the chapter on document modeling,
    is a [section on concurrency control](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#concurrency-control).
    This section explains that RavenDB (at least in version 4.0) performed no concurrency
    control, and instead used Last Write Wins conflict resolution by default.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有迹象表明 RavenDB 可能提供的东西比快照隔离要弱。埋藏在 *Inside RavenDB* 书中，在文档建模章节中，有一部分关于[并发控制](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/3-document-modeling#concurrency-control)。该部分解释了
    RavenDB（至少在 4.0 版本中）不执行并发控制，而是默认使用最后写入获胜的冲突解决方案。
- en: What happens if two requests are trying to modify the same document at the same
    time? That depends on what, exactly, you asked RavenDB to do. If you didn’t do
    anything, RavenDB will execute those two modifications one at a time, and the
    last one will win. There’s no way to control which would be last. Note that both
    operations will execute.
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果两个请求同时尝试修改同一文档会发生什么？这取决于您究竟要 RavenDB 做什么。如果您什么都没做，RavenDB 将依次执行这两个修改，最后一个会胜出。没有办法控制哪个会是最后的。请注意，两个操作都会执行。
- en: 'This is the *opposite* of ACID isolation. Isolated transactions appear to execute
    sequentially, not concurrently. It also contradicts claims of Snapshot Isolation:
    Last Write Wins registers allow all kinds of anomalies which would be prohibited
    under Snapshot Isolation, including [lost update](https://dzone.com/articles/conflict-resolution-using-last-write-wins-vs-crdts).
    However, this book is two major releases out of date; it may not apply to 6.0.2.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 ACID 隔离的相反。隔离的事务似乎是顺序执行的，而不是并发执行的。这也与快照隔离的声明相矛盾：最后写入获胜的注册表允许各种各样的异常情况，这些异常情况在快照隔离下将被禁止，包括[丢失更新](https://dzone.com/articles/conflict-resolution-using-last-write-wins-vs-crdts)。然而，这本书已经过时了两个主要版本；可能不适用于
    6.0.2。
- en: What about cluster-wide transactions? The [Cluster Transactions](https://ravendb.net/docs/article-page/6.0/java/server/clustering/cluster-transactions#concurrent-cluster-wide-and-single-node-transactions)
    page seems definitive. “Concurrent cluster-wide transactions are guaranteed to
    appear as if they are run one at a time (`serializable` isolation level).”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么集群范围的事务呢？[Cluster Transactions](https://ravendb.net/docs/article-page/6.0/java/server/clustering/cluster-transactions#concurrent-cluster-wide-and-single-node-transactions)
    页面似乎是最终的答案。“并发的集群范围事务被保证看起来像是一个接一个地运行（`serializable` 隔离级别）。”
- en: From this, Jepsen infers that RavenDB’s default transaction settings should
    ensure Snapshot Isolation by default and Serializability in a single-node system.
    Cluster-wide transactions should ensure Serializability globally.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Test Design
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2020 RavenDB [wrote their own Jepsen test](https://github.com/ml054/jepsen/)
    and declared in [a webinar](https://www.youtube.com/watch?v=5ZXBR3croMA&) that
    per that test, “everything works.” Their test checked the linearizability of individual
    [reads and writes](https://github.com/ml054/jepsen/blob/08960da98ab9bf7959fce014c63b146b903cbe6c/ravendb/src/jepsen/ravendb.clj#L164-L196)
    against a single document. It did not evaluate multi-operation or multi-document
    transactions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: We designed a [new test harness](https://github.com/jepsen-io/ravendb/tree/4431310402f334ffdb18a5a7ec819316847b642b)
    for RavenDB 6.0.2 running on a single Debian Bookworm node. Our test used RavenDB’s
    JVM client library at version 5.0.4\. We did not evaluate multi-node clusters
    or any kind of faults.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: We wrote a single list-append workload using [Elle](https://github.com/jepsen-io/elle)
    to verify transactional isolation. This workload performs transactions over lists,
    each list identified by a unique integer ID. Each transaction consists of reads
    and/or appends of unique integers to those lists. Each worker thread in the test
    [opens a single DocumentStore](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/client.clj#L26-L31C15)
    connected to the same node. Each transaction creates a new [session](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/client.clj#L54-L62),
    performs [reads and/or appends](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/append.clj#L25-L41),
    then calls [`session.saveChanges()`](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/client.clj#L90)
    to commit. Reads are encoded as a [single call](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/append.clj#L26-L28)
    to `session.load(java.util.Map, id)`. Appends call `session.load` to read the
    current value, add their integer element to the end of the list, then call [`session.store(map,
    key)`](https://github.com/jepsen-io/ravendb/blob/8315d6053bf022203a24db74812d2fdfe89b56b7/src/jepsen/ravendb/append.clj#L40).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'RavenDB offers a few knobs for tuning transaction safety: `transactionMode`
    and `optimisticConcurrency`. We ran our tests using the defaults (single-node
    transactions, no optimistic concurrency), with single-node transactions and optimistic
    concurrency, and finally with cluster-wide transactions. Cluster-wide transactions
    cannot be combined with optimistic concurrency.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Results
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We found surprising safety errors in all three transaction modes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Lost Update with Single-Node Transactions (#17927)
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, RavenDB executes transactions with `transactionMode = SINGLE_NODE`
    and `optimisticConcurrency = false`. One might assume that `SINGLE_NODE` transactions
    are safe on single-node clusters. However, we found the default settings caused
    RavenDB to lose updates constantly, even in single-node clusters without faults.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in this [five-second test run](https://github.com/ravendb/ravendb/files/13794868/20231229T102201.960-0600.zip)
    we performed 12,886 transactions over 975 keys. 81 of those keys exhibited a provable
    lost update. Here are two committed transactions involving key 830:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both of these transactions read key 830’s value as the list `[1, 2]`. Both
    went on to append a value to key 830: the first transaction appended `3`, and
    the second transaction appended `4`. Neither saw the other’s effects. In a Snapshot
    Isolated system, the *first-committer-wins* rule demands that one of these transactions
    must abort. RavenDB, however, allowed both transactions to commit. This is the
    definition of a lost update anomaly.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'In an isolated transaction system which only ever appends elements to lists,
    every observed version of a single list must be a prefix of the longest version
    of that list. However, 454 of the keys in this test violated this prefix property,
    exhibiting *incompatible orders*. For example, here are all the reads of key 116:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '| 3.01 | 1 | [1 2] |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 1 | [1 2] |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 0 | [1 2] |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 1 | [1 2 3] |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 0 | [1 2 4] |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 1 | [1 2 4 5] |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| 3.01 | 0 | [1 2 4] |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 1 | [1 2 4 6] |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 1 | [1 2 4 6] |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 1 | [1 2 4 6 9] |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 1 | [1 2 4 6 9 10] |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 1 | [1 2 4 6 9 10 11 15] |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| 3.02 | 0 | [1 2 4 6 9 10 11 15] |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: Just over three seconds into the test, process 1 observed key 116’s state as
    `[1 2 3]`. However, an immediately following read by process 0 saw `[1 2 4]`,
    and the write of `3` never appeared again. Process 1 then observed `[1 2 4 5]`.
    This write of `5` was replaced by `6` and never seen again.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Our lost update checker is conservative: it only infers an anomaly if two transactions
    read the same version of some key *and* both write to it. However, our `append`
    operations are performed by reading the value, then writing back changes. This
    means these transactions contain reads which are effectively invisible to the
    checker. It seems likely that these cases of incompatible order also represent
    lost updates.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In total, 481 out of the 975 keys in this test exhibited lost updates or incompatible
    orders. These phenomena are prohibited by Serializability, Snapshot Isolation,
    and Repeatable Read. We’ve reported this as [issue 17927](https://github.com/ravendb/ravendb/issues/17927)
    in RavenDB’s issue tracker.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Fractured Reads with Optimistic Concurrency (#17929)
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the *[optimistic concurrency](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/configuration/how-to-enable-optimistic-concurrency)*
    feature enabled, RavenDB promises to “generate a concurrency exception (and abort
    all modifications in the current transaction) when the document has been modified
    on the server side after the client received and modified it.” When running on
    a single node, this setting does appear to prevent lost updates. However, it allows
    fractured reads—as well as various flavors of G-Single, G-nonadjacent, and G2-item.
    Again, these anomalies occurred in a healthy single-node system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 启用了*[乐观并发](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/configuration/how-to-enable-optimistic-concurrency)*功能后，RavenDB承诺“在客户端接收并修改文档后，当服务器端修改了文档时，将生成并发异常（并中止当前事务中的所有修改）”。在单节点运行时，该设置似乎确实可以防止丢失更新。但是，它允许出现断裂读取，以及各种G-Single、G-nonadjacent和G2-item的变体。同样，这些异常发生在健康的单节点系统中。
- en: 'For instance, consider this [ten-second test run](https://s3.amazonaws.com/jepsen.io/analyses/ravendb-6.0.2/20231229T140050.249-0600.zip)
    in which every transaction enabled optimistic concurrency. Our checker found hundreds
    of anomalies like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下这个[十秒钟的测试运行](https://s3.amazonaws.com/jepsen.io/analyses/ravendb-6.0.2/20231229T140050.249-0600.zip)，其中每个事务都启用了乐观并发。我们的检查器发现了数百个类似这样的异常：
- en: In this diagram the top transaction *T*[1] appended `3` to key 271, then appended
    `2` to key 279\. The bottom transaction *T*[2] read key 271 and found nothing,
    appended 6 to key 276, and finally read key 279’s value as `[2]`. Because *T*[2]
    failed to observe *T*[1]’s append to key 271, we have a read-write anti-dependency,
    denoted `rw`. Because *T*[2] observed *T*[1]’s append to key 279, we have a write-read
    dependency, denoted `wr`. In short, *T*[2] observed some, but not all, of the
    effects of *T*[1].
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，顶部事务*T*[1]向键271追加了`3`，然后向键279追加了`2`。底部事务*T*[2]读取了键271，但什么也没找到，然后向键276追加了6，并最终读取了键279的值为`[2]`。因为*T*[2]未能观察*T*[1]对键271的追加，我们有一个读-写反依赖，表示为`rw`。因为*T*[2]观察到*T*[1]对键279的追加，我们有一个写-读依赖，表示为`wr`。简而言之，*T*[2]观察到了*T*[1]的一些影响，但不是全部。
- en: 'This anomaly is called *fractured read*, and it is prohibited under Read Atomic,
    Update Atomic, Causal, Prefix, Parallel Snapshot Isolation, Snapshot Isolation,
    Repeatable Read, and Serializable. RavenDB’s [Transaction FAQ](https://ravendb.net/docs/article-page/6.0/csharp/client-api/faq/transaction-support)
    promises Snapshot Isolation: “even if you access multiple documents, you’ll get
    all of their state as it was in the beginning of the request.” In all Snapshot
    Isolated databases Jepsen is familiar with, snapshots extend across multiple reads.
    In RavenDB, it appears each read can observe a different state. We’ve reported
    this as [issue #17929](https://github.com/ravendb/ravendb/issues/17929) to RavenDB.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '这个异常被称为*断裂读取*，在读取原子、更新原子、因果、前缀、并行快照隔离、快照隔离、可重复读和可串行的情况下是被禁止的。RavenDB的[事务常见问题](https://ravendb.net/docs/article-page/6.0/csharp/client-api/faq/transaction-support)承诺了快照隔离：“即使您访问多个文档，您也将得到它们在请求开始时的所有状态。”在所有Jepsen熟悉的快照隔离数据库中，快照跨越多个读取。而在RavenDB中，似乎每个读取都可以观察到不同的状态。我们已经将此问题报告给了RavenDB的[问题编号
    #17929](https://github.com/ravendb/ravendb/issues/17929)。'
- en: Fractured Read with Cluster-Wide Transactions (#17928)
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集群范围事务的断裂读取（#17928）
- en: 'Cluster-wide transactions are [supposed to be Serializable](https://ravendb.net/docs/article-page/6.0/csharp/server/clustering/cluster-transactions).
    However, we found that even healthy, single-node clusters in which every transaction
    used `CLUSTER_WIDE` mode routinely exhibited fractured reads, as well as G-single,
    G-nonadjacent, G2-item, and more. Consider this [five second test run](https://s3.amazonaws.com/jepsen.io/analyses/ravendb-6.0.2/20231229T145350.284-0600.zip),
    which contained hundreds of serializability violations. Here is one of those anomalies:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 集群范围的事务[应该是可串行化的](https://ravendb.net/docs/article-page/6.0/csharp/server/clustering/cluster-transactions)。然而，我们发现，即使是健康的单节点集群，每个事务都使用了`CLUSTER_WIDE`模式，也经常出现了断裂读取，以及G-single、G-nonadjacent、G2-item等情况。考虑一下这个[五秒钟的测试运行](https://s3.amazonaws.com/jepsen.io/analyses/ravendb-6.0.2/20231229T145350.284-0600.zip)，其中包含数百个可串行性违规。这是其中一个异常：
- en: Here, the bottom transaction *T*[2] appended `6` to key 146 and `1` to key 149\.
    The top transaction *T*[1] failed to observe *T*[2]’s append to key 149, but *did*
    observe its append to key 146\. This is another instance of fractured read. As
    before, this behavior appears to be proscribed by RavenDB’s documentation, as
    well as all consistency models above Read Atomic.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，底部事务 *T*[2] 向键 146 添加了`6`，向键 149 添加了`1`。顶部事务 *T*[1] 未观察到 *T*[2] 对键 149 的添加，但观察到了其对键
    146 的添加。这是另一个破碎读取的例子。与以前一样，这种行为似乎被 RavenDB 的文档所禁止，以及所有高于读取原子性的一致性模型。
- en: 'We’ve reported this to RavenDB as [issue #17928](https://github.com/ravendb/ravendb/issues/17928).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将此报告给 RavenDB 作为[问题＃17928](https://github.com/ravendb/ravendb/issues/17928)。
- en: '| 17927 | Lost update with single-node transactions | None | Unresolved |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 17927 | 单节点事务丢失更新 | None | 未解决 |'
- en: '| 17929 | Fractured read with optimistic concurrency | None | Unresolved |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 17929 | 乐观并发下的破碎读取 | None | 未解决 |'
- en: '| 17928 | Fractured read with cluster-wide transactions | None | Unresolved
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 17928 | 带有集群范围事务的破碎读取 | None | 未解决 |'
- en: Discussion
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论
- en: 'RavenDB variously claims to offer “fully ACID” transactions, Serializability,
    or at least Snapshot Isolation. All of these claims appear false. RavenDB 6.0.2’s
    default settings allowed lost updates. Even cluster-wide transactions exhibited
    fractured reads: a serious anomaly prohibited under Snapshot Isolation, as well
    as several weaker models. These behaviors occur even in healthy, single-node,
    single-shard systems, in which all access occurs via primary key.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: RavenDB 各种声称提供“完全 ACID”事务、串行化，或者至少是快照隔离。所有这些声明似乎都是错误的。RavenDB 6.0.2 的默认设置允许丢失更新。即使是集群范围事务也出现了破碎读取：这是快照隔离下严重禁止的异常情况，也是几个较弱模型中的一种。这些行为甚至在健康的、单节点、单片系统中也会发生，在这些系统中所有访问都通过主键进行。
- en: RavenDB’s strongest safety settings violate Read Atomic. It therefore cannot
    satisfy Update Atomic, Causal, Prefix, Parallel Snapshot Isolation, Snapshot Isolation,
    Repeatable Read, or Serializable. RavenDB might offer Read Committed or Monotonic
    Atomic View, but without more rigorous testing, Jepsen is hesitant to make this
    claim.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: RavenDB 的最强安全设置违反了读取原子性。因此它无法满足更新原子性、因果关系、前缀、并行快照隔离、快照隔离、可重复读、或者可序列化。RavenDB
    可能提供读取提交或者单调原子视图，但是没有进行更严格的测试，Jepsen 不愿做出这种断言。
- en: 'RavenDB’s weak default behavior is surprising given RavenDB’s repeated emphasis
    on safety. As CEO Oren Eini [remarked](https://www.youtube.com/watch?v=5ZXBR3croMA&t=850s)
    on MongoDB’s transaction safety settings:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于 RavenDB 一再强调安全性，其弱默认行为令人惊讶。正如首席执行官 Oren Eini 在关于 MongoDB 的事务安全设置的[评论](https://www.youtube.com/watch?v=5ZXBR3croMA&t=850s)中所述：
- en: '[Default] values matter. They matter quite a lot. Why is that? Because if you
    choose the bad values, you’re absolutely going to get some great numbers in benchmark
    performance. But then you are going to be hitting those [safety] issues in production.
    And then there is this classic response: “Oh, you should have read the docs and
    used the proper configuration.”'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认值很重要。它们相当重要。为什么？因为如果你选择了不好的值，你肯定会在基准性能测试中得到一些很好的数字。但是你在生产环境中会遇到一些[安全性]问题。然后有这样一个经典的回答：“哦，你应该读过文档并使用适当的配置。”
- en: 'One wonders: if ACID properties are so important for RavenDB’s users, why do
    the default settings allow lost updates, even on single-key operations? Do users
    realize their updates can be silently discarded? How many are taking care to use
    cluster-wide transactions where lost updates would violate safety? Do they know
    that even cluster-wide transactions allow fractured read?'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 人们不禁要问：如果 ACID 特性对于 RavenDB 的用户如此重要，为什么默认设置允许丢失更新，即使在单键操作上也是如此？用户是否意识到他们的更新可能会被静默丢弃？有多少人会小心使用集群范围事务，以避免丢失更新违反安全性？他们是否知道即使是集群范围事务也允许破碎读取？
- en: 'This report follows a cursory investigation into RavenDB’s behavior—it is by
    no means exhaustive. As always, we caution that Jepsen takes an experimental approach
    to safety verification: we can prove the presence of bugs, but not their absence.
    There may be other anomalies in RavenDB.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此报告是对 RavenDB 行为的一次粗略调查——这绝不是全面的。我们始终建议 Jepsen 对安全验证采取实验性方法：我们可以证明存在错误，但不能证明不存在错误。RavenDB
    中可能还存在其他异常。
- en: Does RavenDB Even Have Transactions?
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RavenDB 是否具有事务？
- en: 'The first sentence of RavenDB’s [cluster transaction documentation](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/cluster-transaction/overview)
    appears quite clear:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: RavenDB的[集群事务文档](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/cluster-transaction/overview)的第一句话显得非常清楚：
- en: A session represents a single business transaction.
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is echoed by the first sentence of RavenDB’s [session documentation](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The Session, which is obtained from the Document Store, is a Unit of Work that
    represents a single business transaction on a particular database.
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '… which goes on to say:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The batched operations that are sent in the `SaveChanges()` will complete transactionally.
    In other words, either all changes are saved as a Single Atomic Transaction or
    none of them are. So once SaveChanges returns successfully, it is guaranteed that
    all changes are persisted to the database.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RavenDB sessions are clearly not intended to work like sessions in typical databases,
    which are (roughly speaking) [one-to-one with client connections](https://www.postgresql.org/docs/current/tutorial-arch.html).
    They come with a default limit of [30 network requests](https://ravendb.net/docs/article-page/5.4/java/client-api/session/what-is-a-session-and-how-does-it-work#remarks);
    typical database sessions are unbounded. They buffer writes; Jepsen is unaware
    of any other database whose sessions do this. They cache reads; most sessions
    do not. They include concurrency control mechanisms like lost update prevention;
    Jepsen is unaware of any other database which does this at the session level.
    These are all hallmarks of what most databases would call a transaction.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'RavenDB’s article [ACID Transactions in NoSQL? RavenDB vs MongoDB](https://ravendb.net/articles/acid-transactions-in-nosql-ravendb-vs-mongodb)
    is emphatic: RavenDB has supported ACID transactions over “any combination of
    database operations” for over a decade. It certainly appears as if RavenDB sessions
    are intended for this role!'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in a [response to issue 17927](https://github.com/ravendb/ravendb/issues/17927#issuecomment-1872912239),
    Eini (a.k.a. Ayende Rahien) explained that sessions are *not* in fact transactions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Crucially, RavenDB does not attempt to provide transactional semantics over
    the entire session, rather it provide[s] transactions over individual requests.
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And in [response to issue #17928](https://github.com/ravendb/ravendb/issues/17928#issuecomment-1872916841),
    Eini affirms:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: A transaction in RavenDB is a request - so TX1 and TX2 above aren’t actually
    single transactions, instead, each of them represent 3 independent transactions.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is a striking viewpoint: the point of transactions is generally to provide
    isolation across multiple requests. Moreover, RavenDB’s optimistic concurrency
    and cluster-wide transaction mechanisms are clearly intended to provide transactional
    isolation which spans from a session’s reads to its writes. Furthermore, Eini
    [directly compared RavenDB sessions to MongoDB transactions](https://www.youtube.com/watch?v=5ZXBR3croMA&t=23m40s)
    (which offer typical interactive transaction semantics) and claimed that unlike
    MongoDB, RavenDB sessions actually satisfied Snapshot Isolation. Yet per Eini’s
    comments, RavenDB *does not have interactive transactions at all*.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个引人注目的观点：事务的目的通常是为了在多个请求之间提供隔离。此外，RavenDB 的乐观并发和集群范围的事务机制明显旨在提供从会话的读取到其写入的事务隔离。此外，Eini
    [直接将 RavenDB 会话与 MongoDB 事务进行了比较](https://www.youtube.com/watch?v=5ZXBR3croMA&t=23m40s)（后者提供典型的交互式事务语义），并声称与
    MongoDB 不同，RavenDB 会话实际上满足了快照隔离。然而根据 Eini 的评论，RavenDB *根本没有交互式事务*。
- en: Repeatedly advertising “ACID transactions” across “any combination of database
    operations,” telling users that a “session represents a single business transaction,”
    comparing RavenDB sessions to interactive transactions in other databases, offering
    concurrency control mechanisms whose scope extends across an entire session, and
    finally expecting users to realize that sessions are not transactions at all—that
    a transaction is actually limited to a single HTTP request—stretches credulity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 反复宣传“ACID 事务”涵盖“任意组合的数据库操作”，告诉用户“会话代表一个单一的业务事务”，将 RavenDB 会话与其他数据库中的交互式事务进行比较，提供跨越整个会话范围的并发控制机制，并最终期望用户意识到会话根本不是事务——事务实际上仅限于单个
    HTTP 请求——这是令人难以置信的。
- en: 'Jepsen strives to evaluate databases in the context of their marketing and
    documentation. Although RavenDB’s CEO [now states](https://github.com/ravendb/ravendb/issues/17928#issuecomment-1874064897)
    “we don’t support a transaction over more than a single HTTP request,” RavenDB’s
    documentation and marketing give every appearance that a session is intended to
    be a transaction. Jepsen has consulted with several software engineers on their
    interpretation of these claims, and believes typical database users would come
    to the same conclusion: RavenDB sessions are transactions. We continue this interpretation
    throughout this report.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Jepsen 努力在其营销和文档的背景下评估数据库。尽管 RavenDB 的首席执行官 [现在表示](https://github.com/ravendb/ravendb/issues/17928#issuecomment-1874064897)
    “我们不支持跨越多个单独 HTTP 请求的事务”，但 RavenDB 的文档和营销给人的印象是会话应该是一个事务。Jepsen 已经与几位软件工程师就对这些声明的解释进行了咨询，并相信典型的数据库用户会得出相同的结论：RavenDB
    会话就是事务。我们在本报告中继续这种解释。
- en: Recommendations
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建议
- en: 'RavenDB users should be aware RavenDB transactions are not ACID in any meaningful
    sense. This holds even in single-node, single-shard deployments. The defaults
    allow lost updates: you should expect some of your writes to be silently discarded.
    The strongest safety settings allow fractured read: you might observe some, but
    not all, of another transaction’s effects. You could appear to write “into the
    middle” of another transaction. The two isolation levels RavenDB advertises—Snapshot
    Isolation and Serializable—appear impossible to obtain.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: RavenDB 用户应该意识到 RavenDB 事务在任何有意义的情况下都不是 ACID 的。即使在单节点、单分片部署中也是如此。默认情况下允许丢失更新：您应该预期一些写操作将被静默丢弃。最强的安全设置允许断裂读取：您可能会观察到另一个事务的一些效果，但不是全部。您可能会看到自己“写入”另一个事务的中间。RavenDB
    宣传的两个隔离级别——快照隔离和串行化——似乎无法实现。
- en: 'Users who designed their applications assuming RavenDB provided interactive
    ACID transactions—or even Snapshot Isolation—should carefully reevaluate their
    transactions to ensure they are safe in the presence of these anomalies. Consider
    writing simple tests to verify application invariants are preserved under concurrent
    execution: the issues in this report are easy to reproduce.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那些假设 RavenDB 提供交互式 ACID 事务（甚至是快照隔离）的用户应该仔细重新评估他们的事务，以确保在存在这些异常情况下它们是安全的。考虑编写简单的测试来验证应用程序不变量在并发执行下是否得以保持：本报告中的问题很容易再现。
- en: 'Jepsen recommends RavenDB remove claims of “ACID”, “Serializable”, and “Snapshot
    Isolation” from their marketing materials and documentation. RavenDB should instead
    make specific, accurate, and internally consistent claims about safety properties.
    For instance, RavenDB might say “transactions offer Read Committed by default,
    plus internal consistency within the scope of a transaction: once a transaction
    reads a key, subsequent reads and writes of that key observe the originally read
    state, plus the effects of that particular transaction’s writes. Transactions
    allow lost update by default. Enabling cluster-wide transactions prevents lost
    update, but still allows fractured read,” and so on.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Jepsen建议RavenDB从其营销材料和文档中删除“ACID”、“Serializable”和“Snapshot Isolation”的声明。相反，RavenDB应该对安全属性进行具体、准确和内部一致的声明。例如，RavenDB可以说“事务默认提供读已提交，加上事务范围内的内部一致性：一旦事务读取一个键，随后对该键的读取和写入都会观察到最初读取的状态，以及该特定事务的写入效果。事务默认允许丢失更新。启用集群范围的事务可以防止丢失更新，但仍允许分段读取”，等等。
- en: 'RavenDB’s documentation is remarkably confusing. It repeatedly claims to offer
    [ACID transactions](https://ravendb.net/why-ravendb/acid-transactions), which
    implies Serializability. There are specific claims that RavenDB ensures either
    [Serializability](https://ravendb.net/docs/article-page/6.0/csharp/server/clustering/cluster-transactions#case-1-multiple-concurrent-cluster-transactions)
    or [Snapshot Isolation](https://www.youtube.com/watch?v=5ZXBR3croMA). However,
    the documentation also says that RavenDB’s database layer is an [AP system](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/6-ravendb-clusters)
    based on Last Write Wins, and the marketing material claims isolated nodes can
    operate [independently](https://ravendb.net/why-ravendb/high-availability). This
    is impossible: totally available systems [cannot provide](https://jepsen.io/consistency)
    Serializability or Snapshot Isolation.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: RavenDB的文档非常令人困惑。它反复声称提供[ACID事务](https://ravendb.net/why-ravendb/acid-transactions)，这意味着可串行化。有具体的声明称RavenDB确保[可串行化](https://ravendb.net/docs/article-page/6.0/csharp/server/clustering/cluster-transactions#case-1-multiple-concurrent-cluster-transactions)或[快照隔离](https://www.youtube.com/watch?v=5ZXBR3croMA)。然而，文档还说RavenDB的数据库层是基于Last
    Write Wins的[AP系统](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/6-ravendb-clusters)，营销材料声称孤立的节点可以[独立运行](https://ravendb.net/why-ravendb/high-availability)。这是不可能的：完全可用的系统[无法提供](https://jepsen.io/consistency)可串行化或快照隔离。
- en: There are systems (like [Riak](https://riak.com/index.html) & [Cassandra](https://cassandra.apache.org/_/index.html))
    which allow clients to execute either totally available operations with weak consistency,
    or majority available operations with stronger guarantees, like Linearizability.
    If RavenDB intends to build a system which supports both modes, they should clearly
    distinguish those modes throughout marketing and documentation. They have completely
    different availability, latency, and safety characteristics. Repeated claims that
    RavenDB provides ACID “[without sacrificing performance](https://ravendb.net/why-ravendb/acid-transactions)”
    are [provably impossible](https://lamport.azurewebsites.net/pubs/lower-bound.pdf),
    and should be rewritten to clearly explain the tradeoffs involved.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有些系统（如[Riak](https://riak.com/index.html)和[Cassandra](https://cassandra.apache.org/_/index.html)）允许客户端执行完全可用但一致性较弱的操作，或者具有更强保证的大多数可用操作，如线性一致性。如果RavenDB打算构建支持两种模式的系统，他们应该在整个营销和文档中清楚地区分这些模式。它们具有完全不同的可用性、延迟和安全特性。反复声称RavenDB提供ACID
    “[而不牺牲性能](https://ravendb.net/why-ravendb/acid-transactions)”是[可证明不可能的](https://lamport.azurewebsites.net/pubs/lower-bound.pdf)，应该重新撰写以清楚解释所涉及的权衡。
- en: ACID transactions are clearly important to RavenDB. It is therefore alarming
    that RavenDB’s documentation and GitHub comments fundamentally disagree on what
    a transaction *is*. In one interpretation, RavenDB offers interactive transactions,
    represented by the session API, which provide relatively weak isolation—certainly
    not ACID. In another interpretation, RavenDB lacks interactive transactions altogether.
    Instead, it offers a sort of micro-transaction which (e.g.) writes multiple documents
    in a single network request. In this world, sessions offer varying, weak consistency
    constraints that extend *between* micro-transactions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ACID 事务对于 RavenDB 来说显然非常重要。因此，令人担忧的是，RavenDB 的文档和 GitHub 评论在“事务”的定义上存在根本性分歧。根据一种解释，RavenDB
    提供了交互式事务，由会话 API 表示，提供相对较弱的隔离性——显然不是 ACID。根据另一种解释，RavenDB 根本没有交互式事务。相反，它提供了一种微事务，例如在单个网络请求中写入多个文档。在这种情况下，会话提供了在微事务之间延伸的各种弱一致性约束。
- en: 'To resolve this confusion, RavenDB should pick a single definition of “transaction”
    and stick with it. The equivalence or difference between a transaction and session
    should be clearly explained, and these terms used consistently throughout marketing
    and documentation. RavenDB should provide guidance as to the boundaries of each
    unit: when are multiple calls to `load` performed in a single transaction? What
    about `store`? Can a single transaction encompass both a `load` and `store`? The
    consistency properties of both transactions and sessions should be clearly and
    formally defined. Are transactions Serializable? Do sessions ensure Monotonic
    Atomic View? When does a session preclude lost update, and when does it allow
    it? Above all, do not [tell](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/cluster-transaction/overview)
    [users](https://ravendb.net/docs/article-page/6.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work)
    that sessions “represent a single business transaction” if they are, in point
    of fact, not transactions at all.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这种混乱，RavenDB 应该选择一个“事务”的单一定义，并坚持下去。事务和会话之间的等价性或差异应该得到清晰解释，并且这些术语在市场营销和文档中应该一致使用。RavenDB
    应该提供关于每个单元边界的指导：在单个事务中何时执行多次`load`调用？`store`呢？一个单一事务能否同时包含`load`和`store`？事务和会话的一致性属性应该得到明确定义。事务是否可串行化？会话是否确保单调原子视图？会话何时排除丢失更新，何时允许它发生？最重要的是，如果事实上会话根本不是事务，请不要告诉用户它们“代表单个业务事务”。
- en: Finally, if RavenDB transactions are truly intended to cover only a single network
    request, consider using a different term altogether, and avoid comparisons to
    databases which do have interactive transactions. Some databases call these “mini-”
    or “micro-transactions,” which provides an obvious hint of their limited scope.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果 RavenDB 事务真的只意味着涵盖一个单一网络请求，考虑完全使用不同的术语，并避免与确实具有交互式事务的数据库进行比较。一些数据库称这些为“微型”或“微”事务，这提供了它们有限范围的明显提示。
- en: Future Work
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来的工作
- en: This work evaluated only single-node RavenDB clusters without faults. Future
    research could expand tests across multiple nodes, as well as introducing network,
    process, and disk faults. We dealt only with key-value operations, and did not
    evaluate RavenDB’s secondary indices. These indices are described as eventually
    consistent, which raises questions around the integrity of predicate reads. RavenDB
    also offers [server-side transactions](https://ravendb.net/docs/article-page/6.0/csharp/client-api/operations/patching/single-document)
    using Javascript or a library of built-in patch operations. These might offer
    different safety characteristics than the interactive transactions we used in
    this report. Finally, cross-shard transactions are a notoriously challenging problem
    and deserve careful testing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作仅评估了没有故障的单节点 RavenDB 集群。未来的研究可以扩展到跨多个节点的测试，并引入网络、进程和磁盘故障。我们仅处理了键值操作，并没有评估
    RavenDB 的二级索引。这些索引被描述为最终一致，这就引发了有关谓词读取完整性的问题。RavenDB 还提供了使用 Javascript 或内置补丁操作库的[服务器端事务](https://ravendb.net/docs/article-page/6.0/csharp/client-api/operations/patching/single-document)。这些可能具有与我们在本报告中使用的交互式事务不同的安全特性。最后，跨
    shard 事务是一个众所周知的难题，值得仔细测试。
- en: '*Jepsen wishes to thank [Irene Kannyo](https://www.irenekannyo.com/) for her
    invaluable editorial support. Thanks as well to C. Scott Andreas, Taber Bain,
    Silvia Botros, Coda Hale, Ben Linsay, Kelly Shortridge, Nathan Taylor, Zach Tellman,
    and Leif Walsh for their comments on early versions of this manuscript. This work
    was performed independently without compensation, in accordance with the [Jepsen
    ethics policy](https://jepsen.io/ethics).*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*Jepsen 感谢[Irene Kannyo](https://www.irenekannyo.com/)对本文的宝贵编辑支持。同时感谢 C. Scott
    Andreas、Taber Bain、Silvia Botros、Coda Hale、Ben Linsay、Kelly Shortridge、Nathan
    Taylor、Zach Tellman 和 Leif Walsh 对本手稿早期版本的评论。本工作是根据[Jepsen 的道德政策](https://jepsen.io/ethics)独立完成的，没有获得任何补偿。*'
