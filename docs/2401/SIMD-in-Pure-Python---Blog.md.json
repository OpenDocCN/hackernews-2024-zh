["```\nimport numpy as np\n\na = np.array([1, 2, 3, 4])\nb = np.array([2, 4, 6, 8])\n\nprint(a + b)  # [ 3  6  9 12] \n```", "```\ndef xor_bytes(a: bytes, b: bytes) -> bytes:\n\tassert(len(a) == len(b))\n\treturn bytes(x ^ y for x, y in zip(a, b)) \n```", "```\ndef xor_bytes_simd(a: bytes, b: bytes) -> bytes:\n\tassert(len(a) == len(b))\n\treturn (\n\t\tint.from_bytes(a, \"little\") ^ int.from_bytes(b, \"little\")\n\t).to_bytes(len(a), \"little\") \n```", "```\nnaive, n=1 0.3557752799242735\nsimd,  n=1 0.21655898913741112\nnumpy, n=1 0.798536550020799\n\nnaive, n=16 0.8749550790525973\nsimd,  n=16 0.23561427788808942\nnumpy, n=16 0.7937424059491605\n\nnaive, n=128 4.5441425608005375\nsimd,  n=128 0.5077524171210825\nnumpy, n=128 0.8012108108960092\n\nnaive, n=1024 34.96425646613352\nsimd,  n=1024 2.811028849100694\nnumpy, n=1024 0.9388492209836841\n\n```", "```\nsimd,  n=1 0.03484031208790839\nnumpy, n=1 0.2326297229155898\n\nsimd,  n=16 0.042713511968031526\nnumpy, n=16 0.23679199093021452\n\nsimd,  n=128 0.046673570992425084\nnumpy, n=128 0.23861141502857208\n\nsimd,  n=1024 0.08742194902151823\nnumpy, n=1024 0.28949279501102865\n\nsimd,  n=32768 0.9535991169977933\nnumpy, n=32768 0.9617231499869376\n\nsimd,  n=131072 4.984845655970275\nnumpy, n=131072 4.609246583888307\n\n```", "```\nfor  (i  =  0;  i  <  size_b;  ++i)\n  z->ob_digit[i]  =  a->ob_digit[i]  ^  b->ob_digit[i]; \n```", "```\n.      00299ec0 01 03 80 d2     mov        x1,#0x18\n       00299ec4 00 00 80 d2     mov        x0,#0x0\n\n  ,->LAB_00299ec8                                    XREF[1]:     00299ee4(j)  \n  |    00299ec8 80 6a e1 3c     ldr        q0,[x20,x1]\n  |    00299ecc 00 04 00 91     add        x0,x0,#0x1\n  |    00299ed0 a1 6a e1 3c     ldr        q1,[x21,x1]\n  |    00299ed4 00 1c 21 6e     eor        v0.16B,v0.16B,v1.16B\n  |    00299ed8 e0 6a a1 3c     str        q0,[x23,x1]\n  |    00299edc 21 40 00 91     add        x1,x1,#0x10\n  |    00299ee0 5f 00 00 eb     cmp        x2,x0\n   \\_  00299ee4 21 ff ff 54     b.ne       LAB_00299ec8\n       00299ee8 61 f6 7e 92     and        x1,x19,#-0x4\n       00299eec 7f 06 40 f2     tst        x19,#0x3\n       00299ef0 e0 02 00 54     b.eq       LAB_00299f4c\n\n     LAB_00299ef4                                    XREF[1]:     0029a2a0(j)  \n       00299ef4 20 f4 7e d3     lsl        x0,x1,#0x2\n       00299ef8 22 04 00 91     add        x2,x1,#0x1\n       00299efc 85 02 00 8b     add        x5,x20,x0\n       00299f00 a4 02 00 8b     add        x4,x21,x0\n       00299f04 e0 02 00 8b     add        x0,x23,x0\n       00299f08 86 18 40 b9     ldr        w6,[x4, #0x18]\n       00299f0c a3 18 40 b9     ldr        w3,[x5, #0x18]\n       00299f10 63 00 06 4a     eor        w3,w3,w6\n       00299f14 03 18 00 b9     str        w3,[x0, #0x18]\n       00299f18 7f 02 02 eb     cmp        x19,x2\n       00299f1c 8d 01 00 54     b.le       LAB_00299f4c\n       00299f20 83 1c 40 b9     ldr        w3,[x4, #0x1c]\n       00299f24 21 08 00 91     add        x1,x1,#0x2\n       00299f28 a2 1c 40 b9     ldr        w2,[x5, #0x1c]\n       00299f2c 42 00 03 4a     eor        w2,w2,w3\n       00299f30 02 1c 00 b9     str        w2,[x0, #0x1c]\n       00299f34 7f 02 01 eb     cmp        x19,x1\n       00299f38 ad 00 00 54     b.le       LAB_00299f4c\n       00299f3c 82 20 40 b9     ldr        w2,[x4, #0x20]\n       00299f40 a1 20 40 b9     ldr        w1,[x5, #0x20]\n       00299f44 21 00 02 4a     eor        w1,w1,w2\n       00299f48 01 20 00 b9     str        w1,[x0, #0x20]\n     LAB_00299f4c\n\n```", "```\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n```", "```\ni = 0\nwords_left_to_xor = size_b\nwhile words_left_to_xor > 3:\n\t# xor 4 words (16 bytes) concurrently using q0, q1 registers\n\tz[i:i+4] = a[i:i+4] ^ b[i:i+4]\n\ti += 4\n\twords_left_to_xor -= 4\n\n# deal with remaining 32-bit words individually\nif words_left_to_xor > 0:\n\tz[i] = a[i] ^ b[i]\nif words_left_to_xor > 1:\n\tz[i+1] = a[i+1] ^ b[i+1]\nif words_left_to_xor > 2:\n\tz[i+2] = a[i+2] ^ b[i+2] \n```", "```\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n```", "```\na = 0x4567 # this represents four 4-bit unsigned integers, [4, 5, 6, 7]\nb = 0x6789 # as does this: [6, 7, 8, 9]\n\nprint(hex(a + b))  # 0xacf0 => [0xa, 0xc, 0xf, 0x0] == [10, 12, 15, 0]\n\n# oh no, that's the wrong answer... 6+8 should be 14, not 15.\n# it's wrong because the result of 9+7 was 16 (0x10), causing carry propagation\n# into the adjacent \"lane\".\n\n# solution: padding and masking:\na = 0x04050607\nb = 0x06070809\nm = 0x0f0f0f0f\n\nprint(hex((a + b) & m)) # 0xa0c0e00 => [0xa, 0xc, 0xe, 0x0] == [10, 12, 14, 0] \n```", "```\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n```", "```\nfor y in range(1, height + 1):\n    for x in range(width):\n        neighbor_count = sum(\n            get_cell(state, (x + dx) % width, y + dy)\n            for dx, dy in [\n                (-1, -1), (0, -1), (1, -1),\n                (-1,  0),          (1,  0),\n                (-1,  1), (0,  1), (1,  1)\n            ]\n        )\n        this_cell = get_cell(state, x, y)\n        next_value = neighbor_count == 3 or (this_cell and neighbor_count == 2)\n        if cfg.drylife: # another opportunity for dead cells to come alive\n            next_value &#124;= (not this_cell) and neighbor_count == 7\n        set_cell(next_state, x, y, next_value) \n```", "```\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n```", "```\n# count neighbors\nsummed = state\nsummed += (summed >> 4) + (summed << 4)\nsummed += (summed >> COLSHIFT) + (summed << COLSHIFT)\n\n# check if there are exactly 3 neighbors\nhas_3_neighbors = summed ^ MASK_NOT_3 # at this point, a value of all 1s means it was initially 3\nhas_3_neighbors &= has_3_neighbors >> 2 # fold in half\nhas_3_neighbors &= has_3_neighbors >> 1 # fold in half again\n\n# check if there are exactly 4 neighbors\nhas_4_neighbors = summed ^ MASK_NOT_4 # at this point, a value of all 1s means it was initially 4\nhas_4_neighbors &= has_4_neighbors >> 2  # fold in half\nhas_4_neighbors &= has_4_neighbors >> 1  # fold in half again\n\nif cfg.drylife:\n    # check if there are exactly 7 neighbors\n    has_7_neighbors = summed ^ MASK_NOT_7 # at this point, a value of all 1s means it was initially 7\n    has_7_neighbors &= has_7_neighbors >> 2  # fold in half\n    has_7_neighbors &= has_7_neighbors >> 1  # fold in half again\n\n    # variable name here is misleading...\n    has_3_neighbors &#124;= (~state) & has_7_neighbors\n\n# apply game-of-life rules\nstate = (has_3_neighbors &#124; (state & has_4_neighbors)) & MASK_CANVAS \n```", "```\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n```", "```\n\"\"\"\n\n┌───────────┐             Graphics Process\n│ ┌────┐    │    ┌───────────────────────────────┐\n│ │  ┌─▼────┴─┐  │  ┌─────────┐  ┌────────────┐  │\n│ │  │  Life  ├─────► Blitter ├──►            │  │\n│ │  └─┬────▲─┘  │  └─────────┘  │            │  │\n▼ │  ┌─▼────┴─┐  │  ┌─────────┐  │            │  │\n│ ▲  │  Life  ├─────► Blitter ├──►            │  │\n│ │  └─┬────▲─┘  │  └─────────┘  │    GUI     │  │\n│ │  ┌─▼────┴─┐  │  ┌─────────┐  │  Renderer  │  │\n│ │  │  Life  ├─────► Blitter ├──►            │  │\n│ │  └─┬────▲─┘  │  └─────────┘  │            │  │\n▼ │  ┌─▼────┴─┐  │  ┌─────────┐  │            │  │\n│ ▲  │  Life  ├─────► Blitter ├──►            │  │\n│ │  └─┬────▲─┘  │  └─────────┘  └────────────┘  │\n│ └────┘    │    └───────────────────────────────┘\n└───────────┘\n\n\"Life\" threads implement the SWAR life algorithm, for a horizontal strip of\nthe overall canvas.\n\nBlitter threads use SDL2 functions to unpack the SWAR buffers into RGBA8888\nsurfaces, which are passed to the main Renderer thread.\n\nThe renderer thread is responsible for uploading the surfaces to a GPU texture,\nand making it show up on the screen. It's also responsible for dealing with SDL\nevents.\n\nEach Life thread lives in its own process, to avoid the GIL. They\ntalk to each other (for overlap/wraparound), and to the Blitter threads (to\nreport their results), using Pipes.\n\nEverything else happens in the main process, so the Blitters can talk to the\nmain thread using standard Queues - the hard work here is done inside SDL2,\nwhich does not hold the GIL (meaning we can use multithreading, as opposed\nto multiprocessing).\n\n\"\"\" \n```"]