<!--yml

类别：未分类。

日期：2024-05-27 14:58:13。

-->

# 为什么小写字母能节省数据 | endtimes.dev

> 来源：[`endtimes.dev/why-lowercase-letters-save-data/`](https://endtimes.dev/why-lowercase-letters-save-data/)

<main class="text-content post-main">

大写字母和小写字母使用相同的数据量 — 每个都是 `1 字节`。

因此，了解将大写字母换成小写字母可以节省数据是令人惊讶的。

例如：我拿了 [Hacker News](https://news.ycombinator.com/) 的首页，并将每篇文章的标题从 `title case` 改写为 `sentence case` — 减少了 `31 字节`。

将几个大写字母改为小写字母能节省数据，这是真的吗？答案是**压缩**。

这不是直观的，但一旦你了解了文本压缩的工作原理，它就会开始变得合乎逻辑。

在本文中，我希望…

+   帮助你理解文本压缩的工作原理，使用**交互式示例**！

+   展示我是如何得出结论的，即在 hacker news 上使用 `title case` 发布的新闻，其**相当于汽车在斯里兰卡宽度上行驶的年碳排放量**。

+   展示一些例子，说明这种知识如何**系统地节省数据**。

## 为什么小写字母能节省数据？ #

文本压缩在以下情况下更有效…

+   文本中字符的种类更少。

+   较不常见的字符使用频率较低。

+   字符或字符组重复出现的频率更高。

用更常见的小写字母替换大写字母有助于这三种情况。

要理解为什么这样做有效，您需要

## 文本压缩如何工作？ #

要解释文本压缩的工作原理，我们将专门看一下通常用于 `zip` 文件的 `deflate` 算法。其他算法的原理也是相同的。

Deflate 使用两种压缩方法 — `Huffman 编码` 和 `LZSS` — 这两种压缩方法都受到用小写字母替换大写字母的影响。

### Huffman 编码 #

Deflate 算法以 `Huffman 编码` 开始。

未压缩文本文件中的每个字符使用相同的数据量。（这并不完全正确，但对于这个解释来说是足够的。）

在 `utf-8` 中，这是 `8 位`。（位是二进制的 `1` 或 `0`）

使用 `utf-8` 对字母进行编码如下：

`B` 是 `01000010`。

`b` 是 `01100010`。

`a` 是 `01100001`。

`o` 是 `01101111`。

现在，拿一个只使用这四个字符的单词，比如 `Baobab`。

使用 `utf-8`，文本 `Baobab` 的编码如下：`010000100110000101101111011000100110000101100010`。

如果我们知道我们不需要其他任何字母，我们可以通过改变编码以使用更少的位来节省大量数据。

我们可以将 `B` 改为 `10`，`b` 改为 `11`，`a` 改为 `00`，`o` 改为 `01`。

文本 `Baobab` 将被压缩为 `100001110011`。

单词`Baobab`包含四个不同的字符，我们能做的最好的就是给它们每个一个`2 位`的序列。

但是如果我们将`B`变成小写，我们只会有三个不同的字符，我们可以再进一步。

我们可以改变编码，使得最频繁使用的字符`b`只用`1 位`表示。将`baobab`的压缩版本减少为`101001011`

我们使用`哈夫曼编码`来做到这一点。

**使用`哈夫曼编码`我们可以用更少的位数表示更频繁使用的字符。**

这里有一个交互式解释它的工作原理。在下面输入文本，查看其未压缩和压缩的二进制形式。

要使用哈夫曼编码压缩我们的文本，我们首先需要构建文本中所有字符的频率表。为此，我们需要…

1.  **计算每个字符的数量**

1.  **按频率排序它们**。

然后我们按照这些规则构建一个**哈夫曼树**：

1.  将每个字符作为我们树中的`叶子`。

1.  取两个频率最低的字符，并将它们连接到一个节点上 —— 给该节点分配两个叶子的组合频率。

1.  从列表中移除这两个叶子 —— 并将它们的连接节点添加到列表中。

1.  重复以上步骤，直到列表中不再有叶子或节点为止。

这有点复杂，但是一旦完成，你就可以制作一个像这样的漂亮图表：

我们可以使用上述树来计算每个字符的新编码。

要确定每个字符的编码，我们从树顶开始向下爬，找到字符的编码。每次向左爬时，我们加`0`，向右爬时加`1`。

在我们的文本中更频繁出现的字符需要在树上向下爬的距离更短 — 因此可以用更少的`1s`和`0s`进行编码。

### 较小的树可以节省更多 #

我们无法在没有树的情况下解码`哈夫曼编码`。所以当我们发送用`哈夫曼编码`压缩的文本时，我们也会发送树。

**在文本中使用较少的大写字母，可以增加没有任何给定大写字母实例的可能性。这意味着我们发送的树也更小。**

例如，如果我们将文本“解压缩是压缩委员会的任务”从`标题大小写`改为`句子大小写`，我们就不需要一个树中的大写`M`和`C`。这使得我们的压缩更有效 —— 但也使`哈夫曼树`更小。

## LZSS #

`Deflate`还使用另一种压缩方法。它首先用`哈夫曼编码`压缩数据，然后再使用`Lempel-Ziv-Storer-Szymanski（LZSS）`算法。

`LZSS`通过找到重复的数据块并用指向它们第一次出现的较短引用替换它们来工作。

引用是通过用`指针`替换重复序列来完成的。这个指针由两个数字组成：

+   第一个数字告诉我们要倒退多远才能找到原始序列

+   第二个数字告诉我们原始序列的长度是多少

这里是 LZSS 算法的简化示例，指针显示为 `<1,2>`。

在下面的输入中尝试一下。看看删除大写字母如何导致更多的重复序列 — 以及更少的字节。

## 小写能节省多少数据？ #

在你开始转换所有字母为小写之前，请记住在线资源浪费中还有更糟糕的例子。*例如，未经优化的图像、自动播放的视频、未使用的 JavaScript。* 首先解决这些问题！

但话虽如此，小写确实非常有效。这里是一个例子：

### 在 Hacker News 上用句子大小写替换标题大小写 #

如介绍中所述 — 我将 Hacker News 的首页标题改写为`sentence case`而不是`title case`。

每个`html`文件的字符数完全相同 — 但压缩成 zip 文件后，`title case`文件为`5,992 字节`，而`sentence case`文件为`5,961 字节`。节省了`31 字节`！

也许不多，但这对于使标题更易于阅读来说是一个不错的副作用。

使用[sustainablewebdesign.org](https://sustainablewebdesign.org/calculating-digital-emissions/)提供的公式告诉我们，如果以`sentence case`编写，则每次访问 Hacker News 将节省`0.00001059642 克`的碳。

假设 Hacker News 每天约有`1000 万`次访问，转换为句子大小写将每天节省`105 克`的碳。这相当于每年燃烧`4.3`加仑的汽油。足够驾驶一辆 Mini Cooper `137.6 英里` — 大约等于斯里兰卡的宽度。

## 对大小写不敏感的代码进行系统转换为小写。 #

一些代码压缩工具会在压缩后自动将一些代码转换为小写，以节省一些字节 — 但这并不常见，也不一直适用。

任何一个来自`压缩工具`的优化可能都属于*不值一提的*类别 — 但它们共同节省了大量数据，使网站更快，消耗的能量更少。

例如，许多`html`文件以大写的 doctype 声明开始，如下所示：

```
<!DOCTYPE html>
```

但是[`HTML5`规范说明不区分大小写](https://html.spec.whatwg.org/multipage/syntax.html#the-doctype)，所以一个`html 压缩工具`可以通过将其更改为以下内容节省一些数据：

```
<!doctype html>
```

这些优化已经被[`html-minifier`](https://github.com/kangax/html-minifier/issues/822)实现，但其他工具未实现。

### 一些可转换为小写的代码示例 #

有许多可以转换为小写以节省数据的代码示例。以下是一些通常大写但不需要的示例。

希望你觉得这很有趣。如果你也有兴趣帮助优化网络以节省能源，你可以帮我收集更多这样的例子，[在这个 git 仓库里](https://github.com/DitheringIdiot/lowercase-able-code)。

发布

2023 年 11 月 25 日

修改

2023 年 11 月 25 日

作者

纳撒尼尔

标签

`posts` `细枝末节` `网络性能` `压缩` `站点速度`

</主要>
