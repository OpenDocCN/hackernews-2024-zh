- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-05-27 15:14:03'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-27 15:14:03
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Vectorizing Unicode conversions on real RISC-V hardware
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实际RISC-V硬件上实现向量化Unicode转换
- en: 来源：[https://camel-cdr.github.io/rvv-bench-results/articles/vector-utf.html](https://camel-cdr.github.io/rvv-bench-results/articles/vector-utf.html)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://camel-cdr.github.io/rvv-bench-results/articles/vector-utf.html](https://camel-cdr.github.io/rvv-bench-results/articles/vector-utf.html)
- en: Vectorizing Unicode conversions on real RISC-V hardware
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实际RISC-V硬件上实现向量化Unicode转换
- en: In this article we'll discuss how to achieve the speedup below for UTF-8 to
    UTF-16 conversion, using the RISC-V Vector extension.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将讨论如何利用RISC-V向量扩展实现UTF-8到UTF-16转换的加速。
- en: 'I excluded the plain ASCII case from the graph above because it made the other
    results less readable, the speedup was: 8x for C908, and 11x for C920\. More comprehensive
    measurements are at the [end](#finbench) of the article.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我从上面的图表中排除了纯ASCII情况，因为这使得其他结果变得不太可读，速度提升为：C908 8倍，C920 11倍。更全面的测量结果在文章的[结尾](#finbench)。
- en: The vast majority of text you'll come across will be encoded in the UTF-8 format,
    but some languages and APIs use UTF-16 as their native format instead (JavaScript,
    Java, Windows, ...). This and other reasons, might cause you to convert between
    different Unicode encodings. As demonstrated by [simdutf](https://github.com/simdutf/simdutf/),
    this conversion process has a lot of optimization potential.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 绝大多数文本都以UTF-8格式编码，但某些语言和API使用UTF-16作为其本机格式（JavaScript、Java、Windows等）。这个和其他原因可能导致你需要在不同的Unicode编码之间进行转换。正如[simdutf](https://github.com/simdutf/simdutf/)所示，这个转换过程具有很多优化潜力。
- en: Here we'll focus on UTF-8 to UTF-16 conversion, and aim to develop an optimized
    RISC-V implementation that can be upstreamed to the [simdutf](https://github.com/simdutf/simdutf/)
    library, which is used among others by Node.js and Bun. ([The changes](https://github.com/simdutf/simdutf/pull/373)
    are now upstream)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将专注于UTF-8到UTF-16转换，并旨在开发一个经过优化的RISC-V实现，可以上游到[simdutf](https://github.com/simdutf/simdutf/)库中，该库被Node.js和Bun等项目使用。（[更改](https://github.com/simdutf/simdutf/pull/373)现已上游）
- en: The RISC-V Vector extension (RVV) adds a set of 32 vector registers that are
    each VLEN bits wide, where VLEN is a power-of-two greater or equal to 128 (in
    the standard V extension). Vector registers can be interpreted as multiple 8/16/32/64
    bit elements, and operated on accordingly, as signed/unsigned integers or single/double
    precision floating point numbers. Since we can operate on multiple elements at
    a time large speedup over scalar code is possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RISC-V向量扩展（RVV）添加了一组32个向量寄存器，每个寄存器的宽度为VLEN位，其中VLEN是大于或等于128的2的幂（在标准V扩展中）。向量寄存器可以解释为多个8/16/32/64位元素，并相应地以有符号/无符号整数或单精度/双精度浮点数进行操作。由于我们可以一次操作多个元素，因此相对于标量代码，可以实现大幅加速。
- en: At the time of writing (early 2024) there is almost no hardware available that
    supports RVV.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时（2024年初），几乎没有硬件支持RVV。
- en: The only hardware with RVV support, regular consumers can buy, is the [Kendryte
    K230](https://www.canaan.io/product/k230). It has a [C908](https://www.t-head.cn/product/%E7%8E%84%E9%93%81C908)
    in-order core from Xuantie running at 1.6GHz with a VLEN of 128 bits. ([C908 benchmark
    page](../canmv_k230/index.html))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一支持RVV的硬件，普通消费者可以购买的是[Kendryte K230](https://www.canaan.io/product/k230)。它具有来自旋铁的1.6GHz的有序核[C908](https://www.t-head.cn/product/%E7%8E%84%E9%93%81C908)，VLEN为128位。（[C908基准测试页面](../canmv_k230/index.html))
- en: You can also buy two other CPUs that support an early incompatible draft version
    (0.7.1) of the vector extension, the [C906](https://www.t-head.cn/product/C906?lang=en)
    and the [C920](https://www.t-head.cn/product/C910?lang=en) (C910 with RVV). Since
    the C906s performance characteristics are very similar to the C908, we won't include
    benchmarks for this one. ([C906 benchmark page](../mangopi_mq_pro/index.html))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以购买另外两款支持早期不兼容草案版本（0.7.1）的向量扩展的CPU，即[C906](https://www.t-head.cn/product/C906?lang=en)和[C920](https://www.t-head.cn/product/C910?lang=en)（C910带有RVV）。由于C906的性能特征与C908非常相似，我们不会为此提供基准测试。([C906基准测试页面](../mangopi_mq_pro/index.html))
- en: The [C920](https://www.t-head.cn/product/c910?lang=en) however is a much faster
    out-of-order core at 2GHz, the results of which are more interesting than the
    ones from C908 for future hardware. Targeting RVV 0.7.1 is a pain, as there is
    no official toolchain support, but I've taken the time to manually translate the
    generated assembly and assemble it with an [older GCC branch](https://github.com/brucehoult/riscv-gnu-toolchain).
    ([C920 benchmark page](../milkv_pioneer/index.html))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，[C920](https://www.t-head.cn/product/c910?lang=en)是一个速度更快的乱序核心，频率为 2GHz，其结果比未来硬件的
    C908 更加有趣。目标是 RVV 0.7.1，这是很困难的，因为没有官方的工具链支持，但我花了时间手动翻译生成的汇编代码，并且用一个[较旧的 GCC 分支](https://github.com/brucehoult/riscv-gnu-toolchain)来汇编它。（[C920
    基准测试页面](../milkv_pioneer/index.html)）
- en: There are [a few open-source RVV implementations](https://github.com/stars/camel-cdr/lists/rvv-implementations),
    but most are still in development/incomplete. The only one that is complete, and
    we could simulate locally is Tenstorrents bobcat (formally ocelot), but it was
    a proof-of-concept design and some instructions we'll be using were explicitly
    not optimized. (we'll discuss that [later](#gather))
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有[一些开源的 RVV 实现](https://github.com/stars/camel-cdr/lists/rvv-implementations)，但大多数仍处于开发中/不完整状态。唯一一个完整的，我们可以在本地模拟的是
    Tenstorrents bobcat（以前是 ocelot），但它是一个概念验证设计，我们将使用的一些指令明确未经过优化。（我们稍后将讨论[此事](#gather)）
- en: Fortunately, I own the Kendryte K230, and have ssh access to a Milk-V Pioneer
    server with 64 C920 cores, thanks to [perfXlab](http://www.perfxlab.com/). The
    development was done via qemu emulation, as that's far simpler than using real
    hardware, for now.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我拥有 Kendryte K230，并且能够通过 [perfXlab](http://www.perfxlab.com/) 获得对拥有 64
    个 C920 核心的 Milk-V Pioneer 服务器的 ssh 访问权限。开发是通过 qemu 模拟完成的，因为这比使用真实硬件要简单得多，目前是这样的。
- en: The next two sections will cover the basics of RVV and Unicode, feel free to
    [skip ahead](#attack) if you are already familiar with the topics.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两节将介绍 RVV 和 Unicode 的基础知识，如果你已经对这些主题很熟悉，可以随意[跳过](#attack)。
- en: 'I''ll try to explain the RVV basics using a short example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我将尝试使用一个简短的例子来解释 RVV 的基础知识：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we're using the C intrinsics API to count the number of UTF-8 characters*
    in the supplied data. The next section will describe this in more detail, but
    to count the number of UTF-8 characters we just need to count the number of bytes
    that don't match the pattern `**0b10xxxxxx**`, assuming the input is valid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 C 内部函数 API 来计算提供数据中的 UTF-8 字符数。下一节将更详细地描述这一点，但是要计算 UTF-8 字符的数量，我们只需要计算不匹配模式`**0b10xxxxxx**`的字节数，假设输入是有效的。
- en: '**From here on out when I refer to a "character" I mean a Unicode code point.
    This doesn''t directly map into a single character on screen, for example, this
    emoji "🧙‍♀️" is built with three Unicode code points: 🧙 + Zero Width Joiner +
    ♀️ = 🧙‍♀️*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**从现在开始，当我提到“字符”时，我指的是一个 Unicode 代码点。这并不直接映射到屏幕上的单个字符，例如，这个表情符号 "🧙‍♀️" 由三个
    Unicode 代码点构成：🧙 + 零宽度连接器 + ♀️ = 🧙‍♀️*'
- en: As mentioned above RVV supports different vector lengths. To facilitate having
    the same code work on machines with different vector lengths RVV has the `vsetvl*`
    instruction. You give it the element count of your input, an element width, and
    it will give you a count smaller or equal to your supplied count that it can fit
    into a vector register.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，RVV 支持不同的向量长度。为了使相同的代码能够在具有不同向量长度的机器上运行，RVV 提供了`vsetvl*`指令。你需要给出你的输入元素的数量和元素宽度，它将给你一个小于或等于你提供的数量的计数，以便将其装入一个向量寄存器中。
- en: The code above uses this to iterate over the input, `vl = vsetvl_e8m8(len)`
    represents the of number elements one iteration processes. Next `vle8_v_u8m8()`
    loads `vl` 8-bit integer elements from our input into a vector register.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用了这个功能来迭代输入，`vl = vsetvl_e8m8(len)`代表一次迭代处理的元素数量。接下来的`vle8_v_u8m8()`从我们的输入中加载`vl`个8位整数元素到一个向量寄存器中。
- en: Then a mask is created where each active element (element where the coresponding
    bit in the mask is set) doesn't match the pattern `**0b10xxxxxx**`. vsrl stands
    for *shift right logical*, and vmsne for *not equal to*, so `vmsne(vsrl(v, **6**,
    vl), **0b10**, vl)` does `(x >> **6**) != **0b10**` on each element. RVV doesn't
    have separate mask registers, instead, masks are stored in the lower bits of a
    vector register, the intrinsics API adds the `vboolN_t` types to give this more
    type safety. Finally, we use `vcpop` to count the number of active elements in
    our mask and add that to our sum.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个掩码，其中每个活动元素（掩码中对应位设置的元素）与模式`**0b10xxxxxx**`不匹配。vsrl代表*右移逻辑*，vmsne代表*不等于*，所以`vmsne(vsrl(v,
    **6**, vl), **0b10**, vl)`在每个元素上执行`(x >> **6**) != **0b10**`。RVV没有单独的掩码寄存器，而是将掩码存储在向量寄存器的低位中，内置API添加了`vboolN_t`类型以提供更多的类型安全性。最后，我们使用`vcpop`来计算我们的掩码中活动元素的数量，并将其加到我们的总和中。
- en: You might be wondering what the "m8" means, I've omitted that so far. RVV has
    32 VLEN bits wide vector registers, but with `vsetvl` you can also configure the
    LMUL (length multiplier), and cause the processor to group these registers. This
    means that subsequent instructions will act on a register group, and `vsetvl`
    will return a `vl` corresponding to LMUL.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道"m8"是什么意思，到目前为止我还没有提到过。RVV有32个VLEN位宽的向量寄存器，但是通过`vsetvl`你也可以配置LMUL（长度乘数），并使处理器将这些寄存器分组。这意味着后续指令将在一个寄存器组上执行，并且`vsetvl`将返回与LMUL对应的`vl`。
- en: When LMUL=1 we've got 32 VLEN bits wide registers, for LMUL=2 they now act like
    16 VLEN*2 bit wide registers, so for "m8" (LMUL=8), we've got 4 VLEN*8 bit wide
    registers. Here we use less than five vector registers, so using LMUL=8 gives
    us essentially free loop unrolling, which makes the scalar- and mask operations
    less expensive. Unrolling isn't the only advantage of LMUL, it also allows us
    to easily work with mixed-width data, we'll be heavily using this later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当LMUL=1时，我们有32个VLEN位宽的寄存器，当LMUL=2时，它们现在就像是16个VLEN*2位宽的寄存器，所以对于"m8"（LMUL=8），我们有4个VLEN*8位宽的寄存器。在这里，我们使用少于五个向量寄存器，所以使用LMUL=8基本上就给了我们免费的循环展开，这使得标量和掩码操作的成本降低了。展开不是LMUL的唯一优势，它还允许我们轻松地处理混合宽度的数据，我们稍后将大量使用它。
- en: This also explains why masks are stored in a vector register, more specifically
    in an LMUL=1 vector register, even though they only store one bit per element
    they are referring to. For LMUL=8 and 8-bit elements you need a full LMUL=1 register
    to have enough bits to represent its mask.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这也解释了为什么掩码存储在向量寄存器中，更具体地说是存储在LMUL=1向量寄存器中，即使它们每个元素只存储一个比特，它们所指的。对于LMUL=8和8位元素，你需要一个完整的LMUL=1寄存器来存储足够的比特来表示其掩码。
- en: 'Apart from the RVV feature discussed already, the other features we''ll be
    using are:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经讨论过的RVV功能之外，我们将使用的其他功能包括：
- en: '**reductions** over elements: Applies an operation to all elements to produce
    a scalar result. E.g. sum all elements.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少**元素：对所有元素应用操作以产生一个标量结果。例如，对所有元素求和。'
- en: '**narrowing/widening** arithmetic operations: Operation that decreases/increases
    element width and LMUL.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窄化/扩展**算术运算: 减小/增加元素宽度和LMUL的操作。'
- en: '**permutations**: Instructions to move elements, RVV supports slides, merge
    (blend), compress, and gather (shuffle)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排列**: 移动元素的指令，RVV支持滑动、合并（混合）、压缩和聚集（洗牌）。'
- en: 'I hope this wasn''t too confusing, here are some more in-depth references on
    RVV if you don''t feel prepared to follow along with the rest of the article:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这不会让你太困惑，如果你觉得自己还不够准备好跟上文章的后续内容，这里有一些关于RVV更深入的参考资料：
- en: 'Unicode defines a set of ~150,000 characters and assigns them a unique 32-bit
    number, called code point. Storing just the code points themself is called UTF-32\.
    This isn''t done in practice, because lower code points occur more often, and
    this wastes a lot of space. There are two other encoding schemes: UTF-8, and UTF-16.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode定义了一组约150,000个字符，并为它们分配了一个唯一的32位数字，称为代码点。仅存储代码点本身称为UTF-32。实际上不这样做，因为较低的代码点更常见，这会浪费大量空间。还有两种其他的编码方案：UTF-8和UTF-16。
- en: 'UTF-8 uses one- to four-bytes to represent a code point using the format visualized
    below:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8使用一到四个字节来表示一个代码点，使用下面可视化的格式：
- en: Notice the small Invalid range. Code points between 0xD800-0xDFFF are unassigned
    and invalid, this is used to allow for the UTF-16 encoding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意小的无效范围。代码点在0xD800-0xDFFF之间是未分配和无效的，这用于允许UTF-16编码。
- en: UTF-16 encodes the code points from 1, 2 and 3 byte UTF-8 characters directly
    as a single 16-bit character. Four-byte UTF-8 code points are encoded in two 16-bit
    characters by leveraging part of the invalid character range to signal that it's
    a multi-word UTF-16 character.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16直接将1、2和3字节的UTF-8字符的代码点直接编码为单个16位字符。四字节UTF-8代码点通过利用部分无效字符范围来信号化为多字节UTF-16字符的两个16位字符进行编码。
- en: '16-bit words in the range 0xD800-0xDBFF are called high surrogates and in the
    range 0xDC00-0xDFFF low surrogates. A high surrogate is always followed by a low
    surrogate, the code points are encoded as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在范围0xD800-0xDBFF内的16位字称为高代理，而在范围0xDC00-0xDFFF内的字称为低代理。高代理总是后跟低代理，编码如下：
- en: 'Lastly, here is a side-by-side comparison of the encodings for the string "rνṿ🧙",
    which includes all UTF-8 character lengths:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是字符串"rνṿ🧙"的编码的对比，其中包括所有UTF-8字符长度：
- en: Our goal is to implement a fast vectorized validating UTF-8 to UTF-16 conversion
    routine, but let's tackle non-validating general UTF-8 to UTF-32 conversion first
    and see where that leads us. We might end up simply converting the Unicode code
    point (UTF-32) to UTF-16, or figure out a use of some intermediate variables to
    get to UTF-16.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是实现一个快速的矢量化验证UTF-8到UTF-16的转换例程，但让我们首先解决非验证通用UTF-8到UTF-32的转换，看看这会带给我们什么。我们可能最终会简单地将Unicode代码点（UTF-32）转换为UTF-16，或者找出一些中间变量的用法来得到UTF-16。
- en: 'So, this leaves us with a few things to do:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这给我们留下了一些事情要做：
- en: identify character positions
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定字符位置
- en: remove prefixes
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除前缀
- en: combine to UTF-32 code point
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合到UTF-32代码点
- en: The most important question seems to be, how we deal with the different character
    sizes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的问题似乎是，我们如何处理不同的字符大小。
- en: 'Initially, I had two ideas on how to approach this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我有两个想法来解决这个问题：
- en: '**vdecompress:** Skimming through the specification, the first instruction
    that seemed to fit the bill was vdecompress. Although it isn''t really an instruction,
    but rather a combination of the `viota` and `vrgather` instructions to synthesize
    a `vcompress` inverse. It uses a mask to move every nth element of a vector to
    the nth active element in the source register. This could allow us to widen every
    UTF-8 character to four bytes long, so we can work on the different-sized characters
    uniformly.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vdecompress:** 浏览规范，看起来符合条件的第一条指令是vdecompress。尽管它实际上并不是一条指令，而是`viota`和`vrgather`指令的组合，用于合成一个`vcompress`的逆过程。它使用一个掩码将向量的每个第n个元素移动到源寄存器中的第n个活动元素。这可以使我们将每个UTF-8字符扩展为四个字节长，这样我们就可以统一处理不同大小的字符。'
- en: '**vcompress:** Alternatively we could also `vcompress` every nth byte of all
    UTF-8 characters into the nth of four separate vector registers. Then we could
    also write code that operates on all character sizes uniformly, but we''d need
    to recombine the registers to store the final code point.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vcompress:** 或者我们也可以`vcompress`每个UTF-8字符的第n个字节到四个单独的向量寄存器的第n个字节。然后我们也可以编写操作所有字符大小的代码，但我们需要重新组合寄存器以存储最终的代码点。'
- en: The first approach seemed quite promising to me, so I sketched out the creation
    of the decompress-mask but got stuck on how to proceed from there. The problem
    is, that now you go from an input register of, let's for now assume LMUL=1, to
    an LMUL=4 register, and still need to do all of the logic to remove prefixes and
    shift the bits into place. That makes every operation we do four times slower,
    and we'd need to quite a few operations. Add to that, that `vrgather` is slow
    with larger LMULs (see [later discussion](#gather)), and this doesn't seem like
    that good of an idea anymore.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法对我来说似乎很有前途，所以我草绘了创建解压缩掩码的过程，但卡在了如何继续的地方。问题是，现在你从一个输入寄存器转到了，暂时假设LMUL=1，到一个LMUL=4寄存器，仍然需要做所有去除前缀并将位移动到位的逻辑。这使得我们进行的每个操作都慢了四倍，而且我们需要进行相当多的操作。加上`vrgather`对于较大的LMUL的速度较慢（见[后续讨论](#gather)），这似乎不再是一个好主意了。
- en: Let's consider the `vcompress` approach again. Once we've removed the prefixes
    from our four registers, we get the "shifting the bits into the right position"
    part basically for free, because we need to recombine them anyway. Using a widening
    multiply makes combining them while shifting by six bits even easier than interleaving
    the bytes (shifting by eight bits), because we can't multiply by `**1**<<**8**`
    since it doesn't fit into 8-bits.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑 `vcompress` 方法。一旦我们从四个寄存器中移除了前缀，我们基本上就可以免费获得“将位移动到正确位置”的部分，因为无论如何我们都需要重新组合它们。使用扩展乘法使得在移位六位的同时组合它们变得更容易，甚至比交错字节（移位八位）还要容易，因为我们无法用
    `**1**<<**8**` 乘以 8 位。
- en: I was hoping to use masked widening adds and multiplies, but that didn't end
    up being worth it, as we need to specify a destination operand that is already
    widened. Another complication is that combining the first two bytes with the last
    two bytes needs to shift the first two by 0, 6 or 12 bits, which doesn't nicely
    translate into a masked operation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我本来希望使用掩码扩展加法和乘法，但结果证明并不值得，因为我们需要指定一个已经扩展的目标操作数。另一个复杂之处在于，将前两个字节与后两个字节组合需要将前两个字节左移
    0、6 或 12 位，这并不能很好地转换为掩码操作。
- en: We can however always act like we have a four-byte UTF-8 character and later
    calculate and apply a correction right shift amount. This also removes the need
    to mask the add operations, as any residual bits are shifted away.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们总是可以假装我们有一个四字节的 UTF-8 字符，然后计算并应用一个正确的右移量。这也消除了需要屏蔽加法操作的必要性，因为任何剩余的位都会被移位掉。
- en: 'So here is the game plan:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的游戏计划如下：
- en: 'We want to process the input in chunks, but if we were to load the data directly
    into a single vector register, we''d need to figure out where the last full character
    ends in the register. Instead of doing that we can always lookahead three bytes,
    and only consider them as continuation bytes, you''ll see why that works out quite
    well later. Here is the framework we''ll be building on top of:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要以块的形式处理输入，但是如果我们直接将数据加载到单个矢量寄存器中，我们需要弄清楚寄存器中最后一个完整字符的结束位置。我们可以始终向前看三个字节，只将它们视为连续字节，稍后你会看到为什么这样做非常合适。以下是我们将要构建的框架：
- en: '[PRE2]``'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]``'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*/* IMPL: extract b1/b2/b3/b4 */*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* IMPL: 提取 b1/b2/b3/b4 */*'
- en: vuint8m2_t v1 = __riscv_vslide1down(v0, src[vl+**0**], vl);
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t v1 = __riscv_vslide1down(v0, src[vl+**0**], vl);
- en: vuint8m2_t v2 = __riscv_vslide1down(v1, src[vl+**1**], vl);
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t v2 = __riscv_vslide1down(v1, src[vl+**1**], vl);
- en: vuint8m2_t v3 = __riscv_vslide1down(v2, src[vl+**2**], vl);
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t v3 = __riscv_vslide1down(v2, src[vl+**2**], vl);
- en: '*/* mask of non-continuation bytes */*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 非连续字节的掩码 */*'
- en: vbool4_t m = __riscv_vmsne(__riscv_vsrl(v0, **6**, vl), **0b10**, vl);
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: vbool4_t m = __riscv_vmsne(__riscv_vsrl(v0, **6**, vl), **0b10**, vl);
- en: '*/* extract third and fourth bytes */*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 提取第三和第四个字节 */*'
- en: vuint8m2_t b1 = __riscv_vcompress(v0, m, vl);
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t b1 = __riscv_vcompress(v0, m, vl);
- en: vuint8m2_t b2 = __riscv_vcompress(v1, m, vl);
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t b2 = __riscv_vcompress(v1, m, vl);
- en: vuint8m2_t b3 = __riscv_vcompress(v2, m, vl);
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t b3 = __riscv_vcompress(v2, m, vl);
- en: vuint8m2_t b4 = __riscv_vcompress(v3, m, vl);
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t b4 = __riscv_vcompress(v3, m, vl);
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*/* IMPL: remove prefixes */*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* IMPL: 移除前缀 */*'
- en: '*/* remove prefix from trailing bytes */*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 移除尾部字节的前缀 */*'
- en: vlOut = __riscv_vcpop(m, vl);
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: vlOut = __riscv_vcpop(m, vl);
- en: b2 = __riscv_vand(b2, **0b00111111**, vlOut);
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: b2 = __riscv_vand(b2, **0b00111111**, vlOut);
- en: b3 = __riscv_vand(b3, **0b00111111**, vlOut);
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: b3 = __riscv_vand(b3, **0b00111111**, vlOut);
- en: b4 = __riscv_vand(b4, **0b00111111**, vlOut);
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: b4 = __riscv_vand(b4, **0b00111111**, vlOut);
- en: '*/* TODO: remove prefix from leading bytes */*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* TODO: 移除前导字节的前缀 */*'
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*/* IMPL: remove prefix from leading bytes */*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* IMPL: 移除前导字节的前缀 */*'
- en: vuint8m2_t shift = __riscv_vsrl(b1, **4**, vlOut);
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: vuint8m2_t shift = __riscv_vsrl(b1, **4**, vlOut);
- en: shift = __riscv_vmerge(__riscv_vssubu(shift, **10**, vlOut), **3**,
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: shift = __riscv_vmerge(__riscv_vssubu(shift, **10**, vlOut), **3**,
- en: __riscv_vmseq(shift, **12**, vlOut), vlOut);
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vmseq(shift, **12**, vlOut), vlOut);
- en: b1 = __riscv_vsll(b1, shift, vlOut);
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: b1 = __riscv_vsll(b1, shift, vlOut);
- en: b1 = __riscv_vsrl(b1, shift, vlOut);
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: b1 = __riscv_vsrl(b1, shift, vlOut);
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*/* IMPL: combine to b1234 */*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* IMPL: 合并到 b1234 */*'
- en: '*/* unconditionally widen and combine to b1234 */*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 无条件地扩展和合并到 b1234 */*'
- en: vuint16m4_t b34   = __riscv_vwaddu_wv(__riscv_vwmulu(b3,  **1**<<**6**,  vlOut),
    b4,  vlOut);
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: vuint16m4_t b34   = __riscv_vwaddu_wv(__riscv_vwmulu(b3,  **1**<<**6**,  vlOut),
    b4,  vlOut);
- en: vuint16m4_t b12   = __riscv_vwaddu_wv(__riscv_vwmulu(b1,  **1**<<**6**,  vlOut),
    b2,  vlOut);
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: vuint16m4_t b12   = __riscv_vwaddu_wv(__riscv_vwmulu(b1,  **1**<<**6**,  vlOut),
    b2,  vlOut);
- en: vuint32m8_t b1234 = __riscv_vwaddu_wv(__riscv_vwmulu(b12, **1**<<**12**, vlOut),
    b34, vlOut);
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: vuint32m8_t b1234 = __riscv_vwaddu_wv(__riscv_vwmulu(b12, **1**<<**12**, vlOut),
    b34, vlOut);
- en: '*/* TODO: compute shift amount */*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* TODO: 计算移位量 */*'
- en: b1234 = __riscv_vsrl(b1234, __riscv_vzext_vf4(shift, vlOut), vlOut);
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: b1234 = __riscv_vsrl(b1234, __riscv_vzext_vf4(shift, vlOut), vlOut);
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*/* IMPL: compute shift amount */*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* IMPL: 计算移位量 */*'
- en: '*/* derive required right-shift amount from `shift` to reduce*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 从 `shift` 派生所需的右移量以减少 */'
- en: '** b1234 to the required number of bytes */*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '** b1234 到所需的字节数 */*'
- en: shift = __riscv_vmul(__riscv_vrsub(__riscv_vssubu(shift, **2**, vlOut), **3**,
    vlOut), **6**, vlOut);
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: shift = __riscv_vmul(__riscv_vrsub(__riscv_vssubu(shift, **2**, vlOut), **3**,
    vlOut), **6**, vlOut);
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#define VRGATHER_u8m1x2(tbl, idx) \'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#define VRGATHER_u8m1x2(tbl, idx) \'
- en: __riscv_vset(__riscv_vlmul_ext_u8m2( \
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vset(__riscv_vlmul_ext_u8m2( \
- en: __riscv_vrgather(tbl, __riscv_vget_u8m1(idx, **0**), vl8m1)), **1**, \
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vrgather(tbl, __riscv_vget_u8m1(idx, **0**), vl8m1)), **1**, \
- en: __riscv_vrgather(tbl, __riscv_vget_u8m1(idx, **1**), vl8m1));
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vrgather(tbl, __riscv_vget_u8m1(idx, **1**), vl8m1));
- en: '`static const uint64_t err1m[] = { **0x0202020202020202**, **0x4915012180808080**
    };`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`static const uint64_t err1m[] = { **0x0202020202020202**, **0x4915012180808080**
    };`'
- en: '`static const uint64_t err2m[] = { **0xCBCBCB8B8383A3E7**, **0xCBCBDBCBCBCBCBCB**
    };`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`static const uint64_t err2m[] = { **0xCBCBCB8B8383A3E7**, **0xCBCBDBCBCBCBCBCB**
    };`'
- en: '`static const uint64_t err3m[] = { **0x0101010101010101**, **0x01010101BABAAEE6**
    };`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`static const uint64_t err3m[] = { **0x0101010101010101**, **0x01010101BABAAEE6**
    };`'
- en: '`const vuint8m1_t err1tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err1m,
    **2**));`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`const vuint8m1_t err1tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err1m,
    **2**));`'
- en: '`const vuint8m1_t err2tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err2m,
    **2**));`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`const vuint8m1_t err2tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err2m,
    **2**));`'
- en: '`const vuint8m1_t err3tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err3m,
    **2**));`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`const vuint8m1_t err3tbl = __riscv_vreinterpret_u8m1(__riscv_vle64_v_u64m1(err3m,
    **2**));`'
- en: '`const size_t vl8m1 = __riscv_vsetvlmax_e8m1();`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`const size_t vl8m1 = __riscv_vsetvlmax_e8m1();`'
- en: '`const size_t vl16m2 = __riscv_vsetvlmax_e16m2();`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`const size_t vl16m2 = __riscv_vsetvlmax_e16m2();`'
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*...*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*...*'
- en: '*vuint8m2_t v3 = __riscv_vslide1down(v2, src[vl+2], vl);*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*vuint8m2_t v3 = __riscv_vslide1down(v2, src[vl+2], vl);*'
- en: '`vuint8m2_t s1 = __riscv_vreinterpret_u8m2(__riscv_vsrl(__riscv_vreinterpret_u16m2(v2),
    **4**, vl16m2));`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t s1 = __riscv_vreinterpret_u8m2(__riscv_vsrl(__riscv_vreinterpret_u16m2(v2),
    **4**, vl16m2));`'
- en: '`vuint8m2_t s3 = __riscv_vreinterpret_u8m2(__riscv_vsrl(__riscv_vreinterpret_u16m2(v3),
    **4**, vl16m2));`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t s3 = __riscv_vreinterpret_u8m2(__riscv_vsrl(__riscv_vreinterpret_u16m2(v3),
    **4**, vl16m2));`'
- en: '``vuint8m2_t idx2 = __riscv_vand(v2, **0xF**, vl);`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t idx2 = __riscv_vand(v2, **0xF**, vl);`'
- en: '`vuint8m2_t idx1 = __riscv_vand(s1, **0xF**, vl);`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t idx1 = __riscv_vand(s1, **0xF**, vl);`'
- en: '`vuint8m2_t idx3 = __riscv_vand(s3, **0xF**, vl);`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t idx3 = __riscv_vand(s3, **0xF**, vl);`'
- en: '``vuint8m2_t err1 = VRGATHER_u8m1x2(err1tbl, idx1);`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t err1 = VRGATHER_u8m1x2(err1tbl, idx1);`'
- en: '`vuint8m2_t err2 = VRGATHER_u8m1x2(err2tbl, idx2);`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t err2 = VRGATHER_u8m1x2(err2tbl, idx2);`'
- en: '`vuint8m2_t err3 = VRGATHER_u8m1x2(err3tbl, idx3);`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuint8m2_t err3 = VRGATHER_u8m1x2(err3tbl, idx3);`'
- en: '`vint8m2_t  errs = __riscv_vreinterpret_i8m2(`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`vint8m2_t  errs = __riscv_vreinterpret_i8m2(`'
- en: '`__riscv_vand(__riscv_vand(err1, err2, vl), err3, vl));`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`__riscv_vand(__riscv_vand(err1, err2, vl), err3, vl));`'
- en: '`*/* TODO: detect 3/4 byte errors */*[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`*/* TODO: 检测 3/4 字节错误 */*[PRE10]'
- en: '``To check for 3/4 byte errors, we check if the previous input had a 3 or 4
    byte character, which should be followed by two continuation bytes. There is no
    error, if we expect two continuations and get them, and if we don''t expect two
    continuations and don''t get them, this maps perfectly to an XOR operation. We
    use the fact, that the upper bit of our error bit set indicates the expectation
    of two continuations. Interpreting the byte as a signed number, lets us easily
    check if the MSB bit is set (`x < 0`) and if any of the other bits are set (`x
    > 0`).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`检查 3/4 字节错误，我们检查前一个输入是否有 3 或 4 字节的字符，其后应该是两个继续字节。如果我们期望两个继续字节并且得到它们，没有错误，如果我们不期望两个继续字节并且没有得到它们，这就完美地映射到异或操作。我们利用了错误位集的最高位指示了期望的两个继续字节。将字节解释为有符号数，让我们轻松地检查
    MSB 位是否设置（`x < 0`），以及是否有其他位被设置（`x > 0`）。`'
- en: Finally, we test if our error mask contains an error, and exit the function
    with an error code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试错误掩码是否包含错误，并使用错误代码退出函数。
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Lastly, we can''t forget about the first three bytes. They could e.g. be all
    continuation bytes, which would cause our loop to ignore them. Before the start
    of our loop, we find the end of the thired UTF-8 character and pass that to a
    scalar validation routine, here we reuse `utf8_to_utf32_scalar` for simplicity:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`最后，我们不能忘记前三个字节。它们可以是全部继续字节，这将导致我们的循环忽略它们。在我们的循环开始之前，我们找到第三个 UTF-8 字符的结尾并将其传递给标量验证例程，这里我们为简单起见重用
    `utf8_to_utf32_scalar`：`'
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now for the fun part, making things faster.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到了有趣的部分，让事情变得更快。
- en: 'If we read an all ASCII vector, then we can skip the validation pass, and simply
    widen and store the vector. We use a max reduction to determine if we have only
    ASCII bytes, the result of which we can also use for our other fast paths:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们读取了全 ASCII 向量，则可以跳过验证过程，直接扩展和存储向量。我们使用最大归约来确定是否只有 ASCII 字节，其结果我们还可以用于其他快速路径：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`This fast path needs to happen after validation. We are only concerned with
    creating b12 from b1 and b2, which allows us to simplify the code from the general
    case a lot.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`这个快速路径需要在验证之后发生。我们只关心从 b1 和 b2 创建 b12，这使我们可以大大简化代码，从而简化了一般情况。'
- en: We don't need to bother with shifting to remove the prefix from b1, there are
    only two possibilities, and one is to do nothing, hence a masked and fits perfectly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为了从 b1 中移除前缀而进行位移，只有两种可能性，而且其中一种是不进行任何操作，因此掩码和适合得很好。
- en: We still can't use a masked widening multiply without first widening the destination
    operand, but we can use a simple `vmerge` to select between the two possible shift
    values. The addition can then be done using a masked widening add because the
    destination is already widened.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展目标操作数之前，我们仍然不能使用掩码扩展乘法，但是我们可以使用简单的`vmerge`来在两个可能的位移值之间进行选择。由于目的地已经扩展了，因此可以使用掩码扩展加法来进行加法。
- en: 'Now we need to zero extend again and we are done:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要再次进行零扩展，然后就完成了：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`I''ll leave understanding this one as an exercise to the reader, note that
    the code points of all three and below byte UTF-8 characters fit into 16 bytes.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`我将这个留给读者去理解，注意所有三字节及以下字节的 UTF-8 字符的代码点都适合于 16 个字节。'
- en: '[PRE15]`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]`'
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: size_t vl8m4 = __riscv_vsetvlmax_e8m4();
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: size_t vl8m4 = __riscv_vsetvlmax_e8m4();
- en: const vbool2_t m2even = __riscv_vmseq(__riscv_vand(__riscv_vid_v_u8m4(vl8m4),
    **1**, vl8m4), **0**, vl8m4);
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: const vbool2_t m2even = __riscv_vmseq(__riscv_vand(__riscv_vid_v_u8m4(vl8m4),
    **1**, vl8m4), **0**, vl8m4);
- en: '#define DOWN __riscv_vreinterpret_u16m8'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#define DOWN __riscv_vreinterpret_u16m8'
- en: '#define UP __riscv_vreinterpret_u32m8'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#define UP __riscv_vreinterpret_u32m8'
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*...*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*...*'
- en: '*b1234 = __riscv_vsrl(b1234, ...);*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*b1234 = __riscv_vsrl(b1234, ...);*'
- en: '*/* convert [000000000000aaaa|aaaaaabbbbbbbbbb]*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 转换为 [000000000000aaaa|aaaaaabbbbbbbbbb]*'
- en: '** to      [110111bbbbbbbbbb|110110aaaaaaaaaa] */*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '** 转换为      [110111bbbbbbbbbb|110110aaaaaaaaaa] */*'
- en: vuint32m8_t sur = __riscv_vsub(b1234, **0x10000**, vlOut);
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: vuint32m8_t sur = __riscv_vsub(b1234, **0x10000**, vlOut);
- en: sur = __riscv_vor(__riscv_vsll(sur, **16**, vlOut),
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: sur = __riscv_vor(__riscv_vsll(sur, **16**, vlOut),
- en: __riscv_vsrl(sur, **10**, vlOut), vlOut);
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vsrl(sur, **10**, vlOut), vlOut);
- en: sur = __riscv_vand(sur, **0x3FF03FF**, vlOut);
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: sur = __riscv_vand(sur, **0x3FF03FF**, vlOut);
- en: sur = __riscv_vor(sur, **0xDC00D800**, vlOut);
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: sur = __riscv_vor(sur, **0xDC00D800**, vlOut);
- en: '*/* merge 1 byte b1234 and 2 byte sur */*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 合并 1 字节 b1234 和 2 字节 sur */*'
- en: vbool4_t m4 = __riscv_vmsgtu(b1234, **0xFFFF**, vlOut);
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: vbool4_t m4 = __riscv_vmsgtu(b1234, **0xFFFF**, vlOut);
- en: b1234 = __riscv_vmerge(b1234, sur, m4, vlOut);
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: b1234 = __riscv_vmerge(b1234, sur, m4, vlOut);
- en: '*/* swap b1234 two byte pairs */*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 交换 b1234 的两个字节对 */*'
- en: '*/* compress and store */*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 压缩并存储 */*'
- en: vbool2_t mOut = __riscv_vmor(__riscv_vmsne(DOWN(b1234), **0**, vlOut***2**),
    m2even, vlOut***2**);
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: vbool2_t mOut = __riscv_vmor(__riscv_vmsne(DOWN(b1234), **0**, vlOut***2**),
    m2even, vlOut***2**);
- en: b1234 = UP(__riscv_vcompress(DOWN(b1234), mOut, vlOut***2**));
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: b1234 = UP(__riscv_vcompress(DOWN(b1234), mOut, vlOut***2**));
- en: size_t vlDest = __riscv_vcpop(mOut, vlOut***2**);
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: size_t vlDest = __riscv_vcpop(mOut, vlOut***2**);
- en: __riscv_vse16_v_u16m8(dest, DOWN(b1234), vlDest);
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: __riscv_vse16_v_u16m8(dest, DOWN(b1234), vlDest);
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*/* reparse last character + tail */*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 重新解析最后一个字符 + 尾巴 */*'
- en: '*if (count > tail) {*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*if (count > tail) {*'
- en: '*if ((src[0] >> 6) == 0b10) --dest;*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*if ((src[0] >> 6) == 0b10) --dest;*'
- en: '*while ((src[0] >> 6) == 0b10 && tail < count)*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*while ((src[0] >> 6) == 0b10 && tail < count)*'
- en: '*--src, ++tail;*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*--src, ++tail;*'
- en: '*/* go back one more, when on high surrogate */*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*/* 在高代理时再回退一个 */*'
- en: if (dest[-**1**] >= **0xD800** && dest[-**1**] <= **0xDBFF**)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: if (dest[-**1**] >= **0xD800** && dest[-**1**] <= **0xDBFF**)
- en: --dest;
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: --dest;
- en: '*}*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*}*'
- en: '[PRE19][PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19][PRE20]'
