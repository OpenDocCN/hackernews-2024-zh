<!--yml

category: 未分类

date: 2024-05-27 14:55:17

-->

# 2024 年 Xilem 后端路线图 - Linebender

> 来源：[`linebender.org/blog/xilem-backend-roadmap/`](https://linebender.org/blog/xilem-backend-roadmap/)

# 2024 年 Xilem 后端路线图

### Olivier Faure，2024 年 1 月 19 日

正如你现在可能已经听说的那样，Google Fonts 今年资助我来开发 Xilem。

我并不孤单：Aaron Muir Hamilton、Daniel McNab 和 Matt Campbell 也获得了资金来工作于生态系统的各个部分。我相信这是 Matt 第三年从 Google Fonts 获得资金支持。

现在，*我*被雇佣来做什么可能对你来说不太清楚。我们商定的范围相当广泛，表述为“为 Xilem 的视图树和开发者体验做出贡献”，但这可能意味着很多事情。

我想做的第一件事是传达一个更清晰的画面。我对 Xilem 有很多计划，它们涉及从当前架构进行重大更改，这些更改可能令整个社区甚至 Raph Levien 感到担忧。我当然不想给人们一种我是为了谷歌的利益而将项目从 Linebender 社区抢走的印象，这意味着及早和经常透明地谈论我想要重新设计的事情。

## 我对 Xilem 的期望

Xilem 是一个研究和开发项目，是系列中的最新项目（Xi-Core、Druid、Crochet、Lasagna、Idiopath），旨在探索如何将 UI 开发与 Rust 兼容。

这可能现在感觉有点平淡，因为 Rust GUI 框架正在随处涌现并开始采用类似的模式，但这些模式在 2019 年并不明显！Xilem 与 Druid 非常不同，到达当前架构已经是一个过程。

自 2022 年 5 月起，Xilem 一直处于永久实验状态。一旦启动，主要的德鲁伊维护者几乎完全停止贡献，期望 Xilem 一旦准备好就会取代德鲁伊。不幸的是，它仍然没有取得足够的进展，与德鲁伊相比还有差距，但德鲁伊仍然被抛弃了，这对于已经开始依赖它的人们来说并不理想。

这可以避免多少还是值得商榷的。正如我之前所指出的，Rust GUI 生态系统受到了大量的[剃毛](https://seths.blog/2005/03/dont_shave_that/)的影响：我们中的许多人来到这里是因为我们想要构建一个文本编辑器，现在我们都在学习[文本渲染](https://faultlore.com/blah/text-hates-you/)、[文本编辑](https://lord.io/text-editing-hates-you-too/)、[合成](https://raphlinus.github.io/ui/graphics/2020/09/13/compositor-is-evil.html)、[可访问性树](https://accesskit.dev/accesskit-integration-makes-bevy-the-first-general-purpose-game-engine-with-built-in-accessibility-support/)、[使用单子在 GPU 上实现功能](https://raphlinus.github.io/gpu/2021/05/13/stack-monoid-revisited.html)、[ECS](https://www.leafwing-studios.com/blog/ecs-gui-framework/)，以及我绝对确定 Raph 捏造的一些概念，比如[贝塞尔路径](https://raphlinus.github.io/curves/2023/04/18/bezpath-simplify.html)和[C++](https://raphlinus.github.io/rust/2023/04/01/rust-to-cpp.html)。

在某种程度上，剃毛是好事！“我要比 X 做得更好，而不学习 X 如何运作”是孩子的态度。这是我们所有人起步的态度，它充满了勇气，但这种勇气是天真的。真正的改进来自于在花费数年学习问题空间的巨大程度后保持这种勇气，并保持信心，相信可以做得更好。Rust 社区不仅重视从零开始做事，而且重视从过去中学习以做对事情。

这很好，但“做对它们”这一部分需要很多时间，与此同时，我认为我们有点忽视了最终用户。在 Xilem 准备好作为替代品之前，我们放弃了 Druid，然后我们致力于基础性和实验性项目，这些项目将使 Xilem 在长期内变得更强大和更稳固，但与此同时却让项目处于尴尬的状态（除了 Web 后端，它取得了很大的进展）。

在我链接的[基于 ECS 的 GUI 框架](https://www.leafwing-studios.com/blog/ecs-gui-framework/)文章中，Bevy 的维护者有这样的话：

> 不想过于苛刻，但现有的 Rust GUI 解决方案……实在不是很好。有很多还过得去的选择，但它们都有非常明显的缺点。没有一个真正脱颖而出，成为明显的赢家。[...] 在心底，我们都知道我们可以做得更好，而且我们应该这样做。

我的志向是在年底之前让这段文字过时。我希望 Xilem 能够在未来几年里被提及，就像 Iced 和 SlintUI 一样。在未来的几年里，我希望整个生态系统能够达到一个程度，在那里人们讨论 Rust GUI 就像他们谈论 ripgrep 或 rustls 一样。

举个具体的例子：我的个人目标是在 2024 年底之前为 Xilem 实现无缝热重载。我相信这是可行的，我相信这样做将从根本上改变人们对 Rust GUI 的看法，同时也希望解锁[随着时间推移希望实现的其他改进](https://poignardazur.github.io/2023/02/02/masonry-01-and-my-vision-for-rust-ui/)。

短期内，我的计划是专注于基本功能、小部件和样式选项，以便人们可以通过在过去一年中 Raph 在 Vello 上的工作基础上进行实验。[John Skottis 的 Xilem UX 笔记](https://gist.github.com/giannissc/172c6c591997ee14f6120134a7990697)很好地描述了我将要处理的工作类型。

另一个短期内的重大优先事项将是文档编写。我们看到很多人抱怨 Linebender 项目的文档编写不足，难以理解；这是对我们[2024 年公告](https://linebender.org/blog/xilem-2024/)的最普遍的反应，但它回应了我们以前看到的观点。我们意识到了问题，并打算着手解决。

中期内，我还计划着重处理 Xilem 的性能方面。来自 Google Fonts 的人们对我们能从 Rust UI 中获得多少性能表示出了兴趣。虽然我的任务不仅限于性能工作，但这将是一个持续关注的重点，特别是因为 Rust 语言在这方面带来了独特的机会。我将在以后的文章中更详细地介绍 Rust 的性能和功耗效率。

## 我想尽快实施的重大变化

这些是我希望尽快处理的重大变化。实际上，“尽快”是相对的，因为其中一些变化会引起争议，而工作的一部分将是说服人们它们的价值。

### 切换到 Masonry 作为后端

好吧，这个让我有点害羞。

我是 Masonry 的唯一维护者，这是一个 GitHub 上星数仅仅超过 300 颗且外部兴趣不大的 GUI 创建。我真的能够理直气壮地接受 Google 支付我来改进 Xilem 的资金，并把我的时间花在 Masonry 上吗？

请注意，这个选择并不是随意的：Masonry 是从 Druid 分叉出来的，而 Druid 是 Xilem 的祖先，实际上，目前 Xilem 和 Masonry 共享很多代码。

事实上，我会认为 Masonry 的代码库质量比 Xilem 当前的本地后端要好。这并不是要贬低 Xilem 维护者的工作；相反，这是因为优先级的不同所导致的结果。没人对 Xilem 的本地后端很感兴趣（尽管 Raph 意识到了它的重要性，这也是我被付费撰写这篇文章的原因），而很多人对前端和网络后端非常感兴趣，因此前端和网络后端看到了最多的工作。

来自我们的[RFC#0001](https://github.com/linebender/rfcs/pull/1)：

> 结果，Xilem 的本地后端处于糟糕的状态：

Masonry 的后端代码库是一个更健康的起点。 Masonry 还带有一些内置的好处，比如强大的单元测试和结构化小部件图表。

我们是否要导入 Masonry 代码库、crate 还是整个存储库尚不清楚，并且最终的品牌名称也不明确。RFC 概述了不同的可能性，讨论仍在进行中，因此社区可以在进行更多工作（包括可能根本不使用 Masonry）之前达成共识。

如果我们决定继续进行这项工作，那么 Masonry 将需要一些移植工作：

+   使用 Vello 和 Parley 而不是 Piet。

+   使用 Glazier 而不是 druid-shell。

+   集成 AccessKit。

+   去除对 GTK 的依赖。

AccessKit 支持现在是基本操作。Rust 生态系统正在趋于认为可访问性（或者至少是屏幕阅读器支持）应该在 GUI 框架设计的早期阶段集成，而不是在最后添加。

Xilem 在 Druid 上增加了其他功能（尤其是虚拟列表和异步支持），但我认为 Masonry 不需要立即实现它们以达到平衡。两者对于最终性能工作都将非常重要。

Raph 告诉我这是一个“燃烧弹”，嗯，公平。

我们应该在 Xilem 的后端代码库中假设库的最终用户（包括 Xilem 前端）很少会创建自己的小部件。相反，他们通常会像在浏览器中组合 DOM 元素一样组合给他们的基元。会有逃逸口，从一个固定大小的画布表面，最终用户可以使用任意绘图基元到完全定制的小部件代码，但我们应该设计框架，假设人们几乎永远不会*需要*这些逃逸口。

显然，这是一个激进的举措。**在我们决定是否承诺之前，将会有一个原型阶段**，以及用于详细阐述的 RFC。我相信这将会有所回报。

业余 GUI 框架的开发者往往会提供一组非常有限的基元，他们假设如果有人想要他们的小部件中的其他功能，则可以自行实现。 Druid 和 Xilem 都受此影响。

在另一端，网络已经表明，通过给定丰富但刚性的基元集合，您可以实现复杂的自定义 UI。

更重要的是，网络正朝着一种强大的范式发展：声明式 UI。随着时间的推移，人们意识到通过描述事物应该如何看起来并将它们组合起来，而不是通过命令式地使它们执行任务，可以获得更好的性能和组合性。

其中一部分是本机代码比 JS 更高效，但部分原因是声明性代码比命令式代码更易于处理：它的边界更清晰，让你可以[致力于限制](https://developer.mozilla.org/en-US/docs/Web/CSS/contain)，这使得引擎的工作更加容易，而且更容易分析。

一组名为[CSS Houdini](https://developer.mozilla.org/en-US/docs/Web/API/Houdini)的提案出现了，它们完全朝着相反的方向发展：推动布局引擎朝着更多定制化和 JavaScript 代码的方向发展。自 2021 年以来，该提案没有见到太多进展，我认为最可能给命令式代码带来最大权力的部分，即布局 API，在任何浏览器中都没有稳定下来，这并非巧合。

底线是，虽然实现自定义小部件*始终是可能的*，但我希望鼓励开发者尽可能地组合声明性元素，并看看使用这些构建块可以走多远。

#### 更多关于具有观点的布局

我想要在 Xilem 中限制的一个主要定制点是布局。

如今，所有的 Rust GUI 框架都会提供自己的布局算法，但它们中没有一个是基于布局算法竞争的。通常，布局算法只是一个手段；那些确实希望使用先进布局引擎的开发者会在像[Morphorm](https://github.com/vizia/morphorm)和[Taffy](https://github.com/DioxusLabs/taffy)这样的模块化包中提供它。

这就是事实：现实中，大多数布局引擎并不那么有创意。我所知道的每个 Rust 框架和每个主要的 GUI 框架都使用的布局基本上都可以归结为"有些微差异的 FlexBox"。有意义地完成 GUI 布局的不同方式的数量可以慷慨地用双手来计算。

我会说我们只需要 CSS Flow、FlexBox、CSS Grid，也许还有 Morphorm 来满足大多数人的需求。方便的是，这正是 Taffy 的目标。在 Xilem 中已经有了一个实验性的 Taffy 集成，我希望将其加深。

也就是说，不会有一组硬编码的布局算法。相反，布局将依赖于小部件之间的一种受 web 启发的协议（换句话说，trait 方法），而且这种协议将持有强烈的观点，以使这些布局算法的实现更容易。

更多关于这个的内容将在后续的博客文章中进行阐述。

#### 不使用盒子

拥有半固定的小部件集意味着你可以避免使用`Box<dyn Widget>`，这对性能有一些有趣的影响。

这意味着你可以在 Widget trait 中添加很多方法，而不必担心膨胀虚方法表。而且你可以在假设它们会被内联的前提下编写方法，这打开了有趣的 DX 改进。

### 使用 ECS，也许，有点像

在当前的 Xilem 代码中，如果你希望你的 FlexWidget 有子元素，它必须有一个`Vec<Pod<ChildWidget>>`成员。每个 Pod 直接拥有一个 Widget。

我认为这是 Rust GUI 的一个有趣的特点，直接与 Rust 的所有权语义联系在一起。非 Rust 框架通常使用指向子小部件的指针，没错，但它们通常与框架共享，理解为框架负责跟踪有多少个小部件以及哪个是哪个的子部件。例如，在 Qt 中，最好（但不是强制性的）让父项调用 `delete_later()` 而不是 `delete`，因为它在事件处理方面更有效。

Xilem 的“你拥有你的孩子”的方法有点定制化。这意味着该框架在迭代整个小部件树时（比如，作为 DOM 检查器的一部分），除非每个小部件都明确实现了迭代方法，否则会遇到困难。这也意味着，如果你想将事件定位到特定的小部件（比如，具有键盘焦点的小部件），你需要穿过整个所有权链，使用一些启发式方法来避免访问太多小部件。

我认为小部件应该由库拥有。如果你的容器有子部件，那么容器实际拥有的唯一事物就是一个结构的键（可能是一个 slotmap），其中存储了小部件。这使得很多事情更容易，比如序列化和调试，但它对整个后端有影响。这是一项基础设施投资。

最近，我看到越来越多的讨论通过 ECS 实现 GUI。很多这样的讨论来自 Bevy，这是很自然的，因为 Bevy 社区~~由无情的狂热者组成，他们努力向 ECS 神献上越来越多的祭品，直到它吞噬地球~~非常熟悉 ECS 模式，并且已经进入了 UI 工作得到了很多关注的阶段。但我也在 Linebender 社区看到了相关讨论。

我们是否真的想使用 ECS 还需要进一步研究。

我理解，ECS 的最大吸引力在于“S”部分，即 Systems：它是关于一次处理大量类似数据的任意顺序。这就是为什么 Bevy 中的原型很有用：你将具有相同组件的实体组合在一起，这样你就可以说“对具有组件 X 和组件 Y 的所有实体执行此代码”，并且可以在数组值上执行此代码，最小限度地进行间接或分支。而“任意顺序”部分使它们与 slotmaps 非常配合：因为你可以从 slotmap 的开头直接读取，所以你不会付出双重间接的代价。

换句话说，ECS 的理想用例是类型为 `for (entity in entities) entity.position += entity.speed` 的代码。

GUI 与理想用例相去甚远：更新稀疏，只应在少量更改的小部件上运行。顺序往往很重要。我不确定原型是否适用于具有大量不同小部件和不同属性的框架。

我认为你真正想要从 Rust 的 ECS 库中获得的两件事情是：slotmaps，以及以高效的方式向实体添加和删除组件。

实现这些将是一个重大的任务，我们将不得不将其分成小实验，但我预计将有多次回报。

## 社区参与和更多即将到来

我想要真正强调一点：以上所有内容都没有被确定下来。

今年 Raph 想要实现的一部分是让 Xilem 更像一个社区项目，这意味着更多的决定需要经过社区讨论。

我已经为此创建了[一个 RFC 仓库](https://github.com/linebender/rfcs/)，上述每个部分都将有自己的 RFC，我将在其中更详细地阐述我的理由。

这也不是一个橡皮图章式的过程：我想要实现这些想法，但如果社区认为它们不好，那么我们将选择另一种方向。

还有其他我还没有讨论的想法，我想回来谈谈：

+   **声明性样式：** 给小部件提供类似于 CSS 属性的属性，带有用于动画、伪类、媒体查询和容器查询的修饰符。虽然受 CSS 启发，但不涉及任何 CSS 解析、选择器解析、特异性解析等。

+   **合成：** Xilem 正朝着“一切在 GPU 中完成”的方向发展。这对性能来说是有利的，但是在我们之前走过这条路的 Firefox 工程师警告我们要小心许多陷阱，特别是关于电池寿命的问题。一般来说，在布局和绘制之后，如果可能的话，你真的希望有一个 `composite()` 阶段来处理滚动和一些简单的动画，而完全不触及 GPU。[这是一个复杂的主题](https://raphlinus.github.io/ui/graphics/2020/09/13/compositor-is-evil.html)，如果我们能够向应用开发者隐藏大部分复杂性，同时仍然给他们良好的性能，那就太好了。

+   **资源加载：** 这是另一个我们可能需要从游戏引擎中借鉴的领域。至少，我们希望能够询问“加载这个纹理/着色器/字体等”，而不必在用户代码中编写磁盘 I/O。然后我们可以开始考虑渐进式加载、回退、共享等。

这些想法很可能成为不久的将来的更多文章和/或 RFC 的主题。

### 与其他项目的关系

展示 Rust GUI 生态系统的当前状态可能需要一篇专门的文章。

事情发展迅速，我现在写的任何东西可能在两周后就已经过时了。我们目前最感兴趣的项目是 Winit 和 Bevy，与 Servo 合作的潜力也有一些。COSMIC 生态系统看起来很酷，但目前看来我们与他们分享的内容较少。

来自并行项目的人们正在交流和交换的比 2022 年多得多。在 Vello、Parley、wgpu、Taffy、COSMIC-Text 等项目之间，项目正在收敛，维护者正在更努力地与其他人的代码集成和交流。

敬请关注更多信息！

## 嘿，这真的很酷！

在我与 Raph 的讨论中提到的一点是，很容易因为繁琐的工作而忽略了全局。在所有的文书工作、博客撰写、RFC 写作中，我们可能会太过专注于流程，以至于忘记了自己有多么兴奋。

所以，我在此刻提醒自己：这真的是非常令人兴奋的！

尽管我有一些批评、保留意见和对我们需要克服的问题的现实评估，但我对此仍然感到非常棒！

我非常感谢 Raph 让我们走到了这一步，感谢 Google Fonts 赞助我们，也感谢所有为 Linebender 生态系统做出贡献的人。我觉得我们可以做出一些了不起的事情，而且说实话，我对自己能够达到这个位置感到有点吃惊。

重申我之前说过的：在接下来的几年里，我希望整个生态系统能够达到一个程度，人们会像谈论 ripgrep 或 rustls 一样谈论 Rust GUI。

我真诚地认为 Rust 有潜力成为最优秀的 GUI 框架，现在是证明这一点的时候了。
