<!--yml

category: 未分类

date: 2024-05-27 15:19:58

-->

# 两个方便的 GDB 断点技巧

> 来源：[https://nullprogram.com/blog/2024/01/28/](https://nullprogram.com/blog/2024/01/28/)

2024 年 1 月 28 日

nullprogram.com/blog/2024/01/28/

在过去的几个月里，我发现了一些处理 GDB 断点的方便技巧。这些技巧是我自己发现的，我没有看到其他地方讨论过，所以我真的应该分享它们。

### 可继续的断言

典型的 C 实现中的`assert`宏[留下了很多问题](/blog/2022/06/26/)，`raise` 和 `abort` 也是如此，所以我建议了行为在调试器下更好的替代定义：

```
#define assert(c)  while (!(c)) __builtin_trap()
#define assert(c)  while (!(c)) __builtin_unreachable()
#define assert(c)  while (!(c)) *(volatile int *)0 = 0 
```

每个都有稍微[不同的目的](/blog/2023/10/08/#macros)，但仍然具有最重要的属性：*直接在缺陷上立即停止程序*。没有一个具有偶尔有用的次要属性：可选择允许程序通过缺陷继续执行。如果程序达到这些宏的任何一个的主体，那么就没有可靠的继续执行。即使手动将指令指针移到断言上方也不够。编译器假定程序无法通过条件继续执行，并相应地生成代码。

MSVC 生态系统在 x86 上有一个解决方案：`int3`。可移植名称是 `__debugbreak`，一个名称[我曾经在其他地方借用过](/blog/2022/07/31/)。

```
#define assert(c)  do if (!(c)) __debugbreak(); while (0) 
```

在 x86 上，它插入一个 `int3` 指令，触发中断，陷入附加调试器，或者以其他异常方式终止程序。因为它是一个中断，所以预计程序可能会继续执行。它甚至将指令指针留在下一条指令上。截至撰写本文时，GCC 没有相匹配的内部函数，但是 Clang 最近添加了 `__builtin_debugtrap`。在 GCC 中，您需要一些不太便携的内联汇编：`asm ("int3")`。

但是，无论您如何在程序中获得`int3`，GDB 目前都不理解它。问题在于我提到的特性：指令指针不指向`int3`，而是指向下一条指令。这使得 GDB 困惑，导致它在错误的位置断开，甚至可能在错误的范围内断开。例如：

```
for (int i = 0; i < n; i++) {
    // ...
    int3_assert(...);
} 
```

将`int3`放在循环的最后，GDB 将在下一个循环迭代的*顶部*断开，因为这是 GDB 参与时指令指针所在的位置。当放置在函数的末尾时，情况类似，留下 GDB 在调用者处断开的情况。为了解决这个问题，我们需要在中断触发后仍然使指令指针“位于”断点内。简单！添加一个`nop`：

```
#define breakpoint()  asm ("int3; nop") 
```

这个行为非常好，消除了 GDB 对普通`int3`的所有问题。这不仅是一个可继续的断言的坚实基础，而且作为一个快速的条件断点也很有用，传统的条件断点速度太慢了。

```
for (int i = 0; i < 1000000000; i++) {
    if (/* rare condition */) breakpoint();
    // ...
} 
```

GDB能更好地处理`int3`吗？是的！比如，Visual Studio就不需要`nop`指令。据我所知，没有与GDB（甚至LLDB）兼容的ARM等效指令。最接近的指令，`brk #0x1`，不会表现出所需的行为。

### 命名位置

GDB的内置用户界面了解三种断点位置的类别：符号、无上下文的行号和绝对地址。当在GDB下设置一些断点并重新启动程序时，每种断点的处理方式是不同的：

+   解析每个符号，在其运行时地址上设置断点。

+   将每个文件+行号元组映射到运行时地址，并在该地址上放置一个断点。如果该行不存在（即文件较短），则跳过它。

+   将断点准确地放在每个绝对地址上。如果不是映射地址，请不要启动程序。

第一种情况是最好的，因为它可以适应程序的更改。修改代码，重新编译，断点通常仍然放在您想要的位置上。

第三种情况最不实用。这些断点很少能在重建后保存下来，有时甚至在重新运行后也不行。

第二种情况介于有用和无用之间。如果您编辑了源文件，其中有断点——很可能是因为您放置了断点——那么该行号可能已不再正确。相反它会漂移，需要手动替换。这是繁琐的，GDB应该做得更好。认为这是不合理的吗？Visual Studio调试器正是[非常有效地](https://lists.sr.ht/~skeeto/public-inbox/%3C2d3d7662a361ddd049f7dc65b94cecdd%40disroot.org%3E#%3C20240112210447.mxhvo7bg4mjp4jyz@nullprogram.com%3E)通过外部代码编辑处理这些情况！GDB前端在处理这些情况时更好，尤其是当它们也是代码编辑器直接观察所有编辑时。

作为一种变通方法，我们可以通过临时*命名*行号来获得第一种。这需要编辑源代码，但请记住，我们需要这样做的原因正是因为涉及的源代码正在积极变化。如何给一行命名？C和C++标签给程序位置命名：

```
void example(double *nums, int n, ...)
{
    for (int i = 0; i < n; i++) {
        loop:  // named position at the start of the loop
        // ...
    }
} 
```

名称`loop`是局部的`example`，但限定的`example:loop`是一个全局名，与其他符号一样合适。我可以，比如，可靠地追踪该循环的进度，尽管它在源代码中的位置发生了变化。

```
(gdb) dprintf example:loop,"nums[%d] = %g\n",i,nums[i] 
```

一个不利之处是处理`-Wunused-label`（开启了`-Wall`），因此我考虑在[我的默认设置](/blog/2023/04/29/)中禁用该警告。**更新**:马修·费尔南德斯指出，`unused`标签属性消除了警告，解决了我的问题：

```
 for (int i = 0; i < n; i++) {
        loop: __attribute((unused))
        // ...
    } 
```

我更经常使用一个汇编标签，通常方便地命名为`b`：

```
 for (int i = 0; i < n; i++) {
        asm ("b:");
        // ...
    } 
```

像`int3`一样，有时需要给它一个`nop`，以便GDB有东西可以中断。随时“启用”它速度很快：

因为它不是[`.globl`](https://sourceware.org/binutils/docs/as/Global.html)，它是一个弱符号，我可以在每个翻译单元中放置最多一个，都由相同的GDB断点项目覆盖（听起来没有那么有用）。我实际上还没有检查，但我可能更经常使用`dprintf`来命名这样的行，而不是实际的断点。

如果你有自己的类似技巧，我很想学习！
