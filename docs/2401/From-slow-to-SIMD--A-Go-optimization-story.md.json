["```\nfunc DotNaive(a, b []float32) float32 {\n sum := float32(0)\n for i := 0; i < len(a) && i < len(b); i++ {\n sum += a[i] * b[i]\n }\n return sum\n}\n```", "```\nfunc DotUnroll4(a, b []float32) float32 {\n sum := float32(0)\n for i := 0; i < len(a); i += 4 {\n s0 := a[i] * b[i]\n s1 := a[i+1] * b[i+1]\n s2 := a[i+2] * b[i+2]\n s3 := a[i+3] * b[i+3]\n sum += s0 + s1 + s2 + s3\n }\n return sum\n}\n```", "```\nfunc DotUnroll4(a, b []float32) float32 {\n sum := float32(0)\n for i := 0; i < len(a); i += 4 {\n if i >= cap(b) {\n panic(\"out of bounds\")\n }\n s0 := a[i] * b[i]\n if i+1 >= cap(a) || i+1 >= cap(b) {\n panic(\"out of bounds\")\n }\n s1 := a[i+1] * b[i+1]\n if i+2 >= cap(a) || i+2 >= cap(b) {\n panic(\"out of bounds\")\n }\n s2 := a[i+2] * b[i+2]\n if i+3 >= cap(a) || i+3 >= cap(b) {\n panic(\"out of bounds\")\n }\n s3 := a[i+3] * b[i+3]\n sum += s0 + s1 + s2 + s3\n }\n return sum\n}\n```", "```\nfunc DotBCE(a, b []float32) float32 {\n if len(a) != len(b) {\n panic(\"slices must have equal lengths\")\n }\n\n if len(a)%4 != 0 {\n panic(\"slice length must be multiple of 4\")\n }\n\n sum := float32(0)\n for i := 0; i < len(a); i += 4 {\n aTmp := a[i : i+4 : i+4]\n bTmp := b[i : i+4 : i+4]\n s0 := aTmp[0] * bTmp[0]\n s1 := aTmp[1] * bTmp[1]\n s2 := aTmp[2] * bTmp[2]\n s3 := aTmp[3] * bTmp[3]\n sum += s0 + s1 + s2 + s3\n }\n return sum\n}\n```", "```\nfunc DotInt8BCE(a, b []int8) int32 {\n if len(a) != len(b) {\n panic(\"slices must have equal lengths\")\n }\n\n sum := int32(0)\n for i := 0; i < len(a); i += 4 {\n aTmp := a[i : i+4 : i+4]\n bTmp := b[i : i+4 : i+4]\n s0 := int32(aTmp[0]) * int32(bTmp[0])\n s1 := int32(aTmp[1]) * int32(bTmp[1])\n s2 := int32(aTmp[2]) * int32(bTmp[2])\n s3 := int32(aTmp[3]) * int32(bTmp[3])\n sum += s0 + s1 + s2 + s3\n }\n return sum\n}\n```", "```\n#include \"textflag.h\"\n TEXT ·DotAVX2(SB), NOSPLIT, $0-52\n // Offsets based on slice header offsets.\n // To check, use `GOARCH=amd64 go vet`\n MOVQ a_base+0(FP), AX\n MOVQ b_base+24(FP), BX\n MOVQ a_len+8(FP), DX\n XORQ R8, R8 // return sum\n // Zero Y0, which will store 8 packed 32-bit sums\n VPXOR Y0, Y0, Y0\n // In blockloop, we calculate the dot product 16 at a time\nblockloop:\n CMPQ DX, $16\n JB reduce\n // Sign-extend 16 bytes into 16 int16s\n VPMOVSXBW (AX), Y1\n VPMOVSXBW (BX), Y2\n // Multiply words vertically to form doubleword intermediates,\n // then add adjacent doublewords.\n VPMADDWD Y1, Y2, Y1\n // Add results to the running sum\n VPADDD Y0, Y1, Y0\n ADDQ $16, AX\n ADDQ $16, BX\n SUBQ $16, DX\n JMP blockloop\n reduce:\n // X0 is the low bits of Y0.\n // Extract the high bits into X1, fold in half, add, repeat.\n VEXTRACTI128 $1, Y0, X1\n VPADDD X0, X1, X0\n VPSRLDQ $8, X0, X1\n VPADDD X0, X1, X0\n VPSRLDQ $4, X0, X1\n VPADDD X0, X1, X0\n // Store the reduced sum\n VMOVD X0, R8\n end:\n MOVL R8, ret+48(FP)\n VZEROALL\n RET\n```", "```\n#include \"textflag.h\"\n // DotVNNI calculates the dot product of two slices using AVX512 VNNI\n// instructions The slices must be of equal length and that length must be a\n// multiple of 64.\nTEXT ·DotVNNI(SB), NOSPLIT, $0-52\n // Offsets based on slice header offsets.\n // To check, use `GOARCH=amd64 go vet`\n MOVQ a_base+0(FP), AX\n MOVQ b_base+24(FP), BX\n MOVQ a_len+8(FP), DX\n ADDQ AX, DX // end pointer\n // Zero our accumulators\n VPXORQ Z0, Z0, Z0 // positive\n VPXORQ Z1, Z1, Z1 // negative\n // Fill Z2 with 128\n MOVD $0x80808080, R9\n VPBROADCASTD R9, Z2\n blockloop:\n CMPQ AX, DX\n JE reduce\n VMOVDQU8 (AX), Z3\n VMOVDQU8 (BX), Z4\n // The VPDPBUSD instruction calculates of the dot product 4 columns at a\n // time, accumulating into an i32 vector. The problem is it expects one\n // vector to be unsigned bytes and one to be signed bytes. To make this\n // work, we make one of our vectors unsigned by adding 128 to each element.\n // This causes us to overshoot, so we keep track of the amount we need\n // to compensate by so we can subtract it from the sum at the end.\n //\n // Effectively, we are calculating SUM((Z3 + 128) · Z4) - 128 * SUM(Z4).\n VPADDB Z3, Z2, Z3   // add 128 to Z3, making it unsigned\n VPDPBUSD Z4, Z3, Z0 // Z0 += Z3 dot Z4\n VPDPBUSD Z4, Z2, Z1 // Z1 += broadcast(128) dot Z4\n ADDQ $64, AX\n ADDQ $64, BX\n JMP blockloop\n reduce:\n // Subtract the overshoot from our calculated dot product\n VPSUBD Z1, Z0, Z0 // Z0 -= Z1\n // Sum Z0 horizontally. There is no horizontal sum instruction, so instead\n // we sum the upper and lower halves of Z0, fold it in half again, and\n // repeat until we are down to 1 element that contains the final sum.\n VEXTRACTI64X4 $1, Z0, Y1\n VPADDD Y0, Y1, Y0\n VEXTRACTI128 $1, Y0, X1\n VPADDD X0, X1, X0\n VPSRLDQ $8, X0, X1\n VPADDD X0, X1, X0\n VPSRLDQ $4, X0, X1\n VPADDD X0, X1, X0\n // Store the reduced sum\n VMOVD X0, R8\n end:\n MOVL R8, ret+48(FP)\n VZEROALL\n RET\n```"]