["```\nlong inc_impl(long num) {\n    return num + 1;\n}\n\nPyObject* inc(PyObject* obj) {\n    long num = PyLong_AsLong(obj);\n    if (num < 0 && PyErr_Occurred()) {\n        return NULL;\n    }\n    long result = inc_impl(num);\n    return PyLong_FromLong(result);\n} \n```", "```\nstruct PyPyTypedMethodMetadata {\n  int arg_type;\n  int ret_type;\n  void* underlying_func;\n};\ntypedef struct PyPyTypedMethodMetadata PyPyTypedMethodMetadata; \n```", "```\nstruct PyMethodDef {\n    const char  *ml_name;   /* The name of the built-in function/method */\n    PyCFunction  ml_meth;   /* The C function that implements it */\n    int          ml_flags;  /* Combination of METH_xxx flags, which mostly\n                               describe the args expected by the C func */\n    const char  *ml_doc;    /* The __doc__ attribute, or NULL */\n};\ntypedef struct PyMethodDef PyMethodDef; \n```", "```\nstruct PyPyTypedMethodMetadata {\n  int arg_type;\n  int ret_type;\n  void* underlying_func;\n  const char ml_name[100];  // New field!\n};\ntypedef struct PyPyTypedMethodMetadata PyPyTypedMethodMetadata;\n\nPyPyTypedMethodMetadata*\nGetTypedSignature(PyMethodDef* def)\n{\n  assert(def->ml_flags & METH_TYPED);  // A new type of flag!\n  return (PyPyTypedMethodMetadata*)(def->ml_name - offsetof(PyPyTypedMethodMetadata, ml_name));\n} \n```", "```\n#include <Python.h>  \nlong inc_impl(long arg) {\n  return arg+1;\n}\n\nPyObject* inc(PyObject* module, PyObject* obj) {\n  (void)module;\n  long obj_int = PyLong_AsLong(obj);\n  if (obj_int == -1 && PyErr_Occurred()) {\n    return NULL;\n  }\n  long result = inc_impl(obj_int);\n  return PyLong_FromLong(result);\n}\n\nstatic PyMethodDef mytypedmod_methods[] = {\n    {\"inc\", inc, METH_O, \"Add one to an int\"},\n    {NULL, NULL, 0, NULL}};\n\nstatic struct PyModuleDef mytypedmod_definition = {\n    PyModuleDef_HEAD_INIT, \"mytypedmod\",\n    \"A C extension module with type information exposed.\", -1,\n    mytypedmod_methods,\n    NULL,\n    NULL,\n    NULL,\n    NULL};\n\nPyMODINIT_FUNC PyInit_mytypedmod(void) {\n  PyObject* m = PyState_FindModule(&mytypedmod_definition);\n  if (m != NULL) {\n    Py_INCREF(m);\n    return m;\n  }\n  return PyModule_Create(&mytypedmod_definition);\n} \n```", "```\ncpdef int add(int a, int b):\n    return a + b \n```", "```\nstatic int add(int __pyx_v_a, int __pyx_v_b) {\n  return __pyx_v_a + __pyx_v_b;\n} \n```", "```\nstatic PyObject *add_and_box(CYTHON_UNUSED PyObject *__pyx_self,\n                             int __pyx_v_a,\n                             int __pyx_v_b) {\n  int result = add(__pyx_v_a, __pyx_v_b, 0);\n  // Check if an error occurred (unnecessary in this case)\n  if (result == ((int)-1) && PyErr_Occurred()) {\n    return NULL;\n  }\n  // Wrap result in PyObject*\n  return PyLong_FromLong(result);\n}\n\nstatic PyObject *add_python(PyObject *__pyx_self,\n                            PyObject *const *__pyx_args,\n                            Py_ssize_t __pyx_nargs,\n                            PyObject *__pyx_kwds) {\n  // Check how many arguments were given\n  PyObject* values[2] = {0,0};\n  if (__pyx_nargs == 2) {\n    values[1] = __pyx_args[1];\n    values[0] = __pyx_args[0];\n  } else if (__pyx_nargs == 1) {\n    values[0] = __pyx_args[0];\n  }\n  // Check if any keyword arguments were given\n  Py_ssize_t kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);\n  // Match up mix of position/keyword args to parameters\n  if (__pyx_nargs == 0) {\n    // ...\n  } else if (__pyx_nargs == 1) {\n    // ...\n  } else if (__pyx_nargs == 2) {\n    // ...\n  } else {\n    // ...\n  }\n  // Unwrap PyObject* args into C int\n  int __pyx_v_a = PyLong_AsLong(values[0]);\n  // Check for error (unnecessary if we know it's an int)\n  if ((__pyx_v_a == (int)-1) && PyErr_Occurred()) {\n    return NULL;\n  }\n  int __pyx_v_b = PyLong_AsLong(values[1]);\n  // Check for error (unnecessary if we know it's an int)\n  if ((__pyx_v_b == (int)-1) && PyErr_Occurred()) {\n    return NULL;\n  }\n  // Call generated C implementation of add\n  return add_and_box(__pyx_self, __pyx_v_a, __pyx_v_b);\n} \n```", "```\n# bench.py import mytypedmod\n\ndef main():\n    i = 0\n    while i < 10_000_000:\n        i = mytypedmod.inc(i)\n    return i\n\nif __name__ == \"__main__\":\n    print(main()) \n```", "```\n$  python3.10 setup.py build\n$  time python3.10 bench.py\n10000000\n846.6ms $ \n```", "```\n$  pypy3.10 setup.py build\n$  time pypy3.10 bench.py\n10000000\n2.269s $ \n```", "```\ndiff --git a/tmp/cext.c b/tmp/cext-typed.c\nindex 8f5b31f..52678cb 100644 --- a/tmp/cext.c +++ b/tmp/cext-typed.c @@ -14,8 +14,15 @@ PyObject* inc(PyObject* module, PyObject* obj) {\n   return PyLong_FromLong(result);\n }\n\n+PyPyTypedMethodMetadata inc_sig = {\n+  .arg_type = T_C_LONG,\n+  .ret_type = T_C_LONG,\n+  .underlying_func = inc_impl,\n+  .ml_name = \"inc\",\n+};\n+\n static PyMethodDef mytypedmod_methods[] = {\n-    {\"inc\", inc, METH_O, \"Add one to an int\"}, +    {inc_sig.ml_name, inc, METH_O | METH_TYPED, \"Add one to an int\"},\n     {NULL, NULL, 0, NULL}};\n\n static struct PyModuleDef mytypedmod_definition = { \n```", "```\n$  pypy3.10-patched setup.py build\n$  time pypy3.10-patched bench.py\n10000000\n168.1ms $ \n```", "```\ndiff --git a/tmp/interp.py b/tmp/typed-interp.py\nindex 900fa9c..b973f13 100644 --- a/tmp/interp.py +++ b/tmp/typed-interp.py @@ -1,7 +1,17 @@\n def make_c_call(meth, args):\n     if meth.ml_flags & METH_O:\n         assert len(args) == 1\n+        if meth.ml_flags & METH_TYPED:\n+            return handle_meth_typed(meth, args[0])\n         return handle_meth_o(meth, args[0])\n     if meth.ml_flags & METH_FASTCALL:\n         return handle_meth_fastcall(meth, args)\n     # ...\n+\n+def handle_meth_typed(meth, arg):\n+    sig = call_scary_c_function_to_find_sig(meth)\n+    if isinstance(arg, int) and sig.arg_type == int and sig.ret_type == int:\n+        unboxed_arg = convert_to_unboxed(arg)\n+        unboxed_result = call_f_func(sig.underlying_func, unboxed_arg)\n+        return convert_to_boxed(unboxed_result)\n+    # ... \n```"]