- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:32:11'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Thoughts on Testing | Brandon's Website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.brandons.me/blog/thoughts-on-testing](https://www.brandons.me/blog/thoughts-on-testing)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thoughts on Testing January 4, 2024
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1548 Brandon Smith
  prefs: []
  type: TYPE_NORMAL
- en: Today I was thinking about tests.
  prefs: []
  type: TYPE_NORMAL
- en: Skepticism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'm skeptical of tests. I'm not *against* tests (even though my coworker opened
    a conversation today with "I know you hate tests" and I quickly projected my voice
    across the office as I said "I don't hate tests!" just to make sure everyone knew),
    but *a lot of people really love tests* and I sometimes feel like I have to pour
    some cold water on that.
  prefs: []
  type: TYPE_NORMAL
- en: Cost
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The thing is that *tests are code*, and *all code is technical debt*, but unlike
    normal code tests can grow without bounds, and they don't always get seen as a
    something with a cost because they don't get shipped to production. But every
    test is...
  prefs: []
  type: TYPE_NORMAL
- en: Code that takes time to write
  prefs: []
  type: TYPE_NORMAL
- en: Code that takes time to maintain (when requirements change, dependencies change,
    etc)
  prefs: []
  type: TYPE_NORMAL
- en: Code that takes time running in CI
  prefs: []
  type: TYPE_NORMAL
- en: And bad tests can give a false sense of security
  prefs: []
  type: TYPE_NORMAL
- en: So I think it's fair to say that (despite certain engineering books and management
    directives) *the optimal number of tests isn't as many as we can possibly come
    up with*.
  prefs: []
  type: TYPE_NORMAL
- en: Judgement calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So what is the optimal number of tests? It depends, but here are some ways I
    like to frame the question
  prefs: []
  type: TYPE_NORMAL
- en: '"Is this something static analysis can test?"'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anything that can be checked by static types, linting, etc, is better caught
    by those than by tests. A whole lot of things can't, but this is a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not just personal preference: static analysis prevents entire classes
    of bugs at once, while tests cover individual inputs. You always might forget
    to write a test for an edge case, but a type checker won''t.'
  prefs: []
  type: TYPE_NORMAL
- en: But static analysis isn't available in every language, and in those unit tests
    become more important as they try to fill that gap.
  prefs: []
  type: TYPE_NORMAL
- en: '"How often will the behavior *intentionally* change?"'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This question tells us how often we''ll get false-positives (tests that need
    to "be fixed"). Consider two functions having tests written for them:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is a [fibonacci](https://en.wikipedia.org/wiki/Fibonacci_sequence)
    function. The fibonacci sequence is well-defined, it has a clear definition, it
    will never change. If we test a given input + output combination, and our test
    fails, it will *always* mean our code is broken. There will *never* be a false-positive
    (failed test when the implementation is actually doing what we want it to do),
    because if we ever wanted `fib(3)` to equal `100`, we're no longer talking about
    a fibonacci function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine another function that returns a greeting message containing a person''s
    name (eg. `"Hello, Brandon!"`). Suppose we write a test that checks that `greet("Brandon")`
    returns `"Hello, Brandon!"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, suppose that the product manager comes to us one day and says, "We have
    a new design, we'd now like it to say `"Greetings Brandon, welcome to our website!"`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We change the code behavior, and now our test fails! But the failure isn't because
    we introduced a bug, it's because *we changed our mind*. The new message is now
    the *correct* behavior of `greet()`, and so the test is now incorrect and needs
    to be updated. Time spent "fixing" the test is pure overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put differently: what''s the definition of "correct" for the code being tested,
    and how durable is that definition?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most cases aren''t as clear-cut as these two, but in general:'
  prefs: []
  type: TYPE_NORMAL
- en: Really general utilities are unlikely to need their behavior changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core business logic is unlikely to need its behavior changed (depending on how
    close it is to feature churn)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Surface behaviors like user interfaces (more on this later) are more likely
    to intentionally change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Does the test just mirror the logic being tested?"'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This hasn''t told us anything interesting about the logic being tested, we''re
    just writing it twice. It''ll tell us if `calculation`''s behavior *changed*,
    but not if it''s *wrong*. Good tests check against *intent* instead of *behavior*.
    Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we're documenting a *meaningful concept* in our test that isn't directly
    represented in the code being tested, and so it's more likely to be *stable over
    time* than implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: '"Is the test simpler than the implementation?"'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Along the same lines, a good candidate for testing is code that's complicated
    enough for its behavior to be *hard* to just copy in a test. A great function
    to test is one where *you're not sure it's going to do the right thing just by
    looking at it*.
  prefs: []
  type: TYPE_NORMAL
- en: For code like this, the test will be simpler than what it's testing. "Test intent
    instead of implementation"; the *intent* of most code will be simpler than the
    implementation, and we want the test to reflect the intent.
  prefs: []
  type: TYPE_NORMAL
- en: '"How much does the code being tested interact with the outside world?"'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mocking adds a ton of complexity and reduces the amount of functionality actually
    being tested. It makes code both harder to test and less valuable to test.
  prefs: []
  type: TYPE_NORMAL
- en: But it's unavoidable when you're testing code that's coupled to external systems.
    Unit tests that rely on outside systems are never a good idea; they can break
    mysteriously and inconsistently.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes mocking can be avoided by re-structuring your code, but sometimes
    it can't be. If it can't be, the need for lots of mocking is one clue that a piece
    of code might not be worth (unit) testing.
  prefs: []
  type: TYPE_NORMAL
- en: '"How important is this code?"'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, the more business-critical a piece of code is, and/or the more widespread
    its use is (eg. a core component used in lots of places), the more valuable it
    is to test. It may be worth testing `coreBusinessRule` even if the implementation
    is trivial, even if our test can only make sure it doesn't change by surprise.
    It may be worth dealing with a ton of mocking just to make sure the testable part
    of an auth flow prevents illegal operations. Everything is a judgement call.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far I''ve been talking about unit tests, but integration tests are different
    in certain ways, especially the mocking question: almost by definition you aren''t
    really mocking systems, you''re testing the interactions between them that are
    otherwise hard to test.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other rules still apply though: writing tests that reflect intent (eg, "click
    the button with the label ''Submit''") instead of implementation ("click the third
    `<button>` tag on the page") will make them less fragile. Favoring tests that
    check valuable behavior ("can the user log in?") over tests that check unvaluable
    behavior ("is the submit button blue?") makes the best use of your effort. Etc.'
  prefs: []
  type: TYPE_NORMAL
- en: UI tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I hinted above, but my controversial take is that *I think UI rendering code
    is rarely worth unit-testing* based on these heuristics. User interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Often change output/behavior intentionally (leading to flaky tests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often (not always!) have trivial logic that's easy to verify by looking at it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are usually tightly coupled to their framework/platform, requiring elaborate
    mocking and test suite plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*But* I really only mean the rendering layer, not the entire front-end codebase:'
  prefs: []
  type: TYPE_NORMAL
- en: State management decoupled from the UI (React hooks, stores, etc) can be a great
    candidate; that's where most of the complexity is, and it doesn't have most of
    the problems above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business rules like validation are also great to test; the logic is often pure
    (which makes it super easy to test), and they often have really stable definitions
    of "correct" and "incorrect" (when was the last time the meaning of "valid phone
    number" changed?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other core utilities that are far away from user-facing feature churn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And then, a library of UI components that are really general and used in a bunch
    of places may tip the scales towards unit testing. The value is higher, and the
    cost (of mocking, etc) is usually lower because they're meant to be reusable.
    They may also change less often than product features.
  prefs: []
  type: TYPE_NORMAL
- en: Closing thoughts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I don't hate tests (I promise, Avid!), I just try to question them on a case
    by case basis, and I haven't met a lot of people who do.
  prefs: []
  type: TYPE_NORMAL
- en: They have a very real organizational cost, which as engineers we need to be
    aware of. Having more of them makes more little green things light up in the console
    and makes that coverage number go up, so it feels good to add them. But like anything,
    testing needs to be done with consideration.
  prefs: []
  type: TYPE_NORMAL
