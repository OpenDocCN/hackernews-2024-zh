<!--yml

类别：未分类

日期：2024-05-27 14:35:26

-->

# 使用 L* 算法学习正则语言

> 来源：[https://rahul.gopinath.org/post/2024/01/04/lstar-learning-regular-languages/](https://rahul.gopinath.org/post/2024/01/04/lstar-learning-regular-languages/)

TLDR；本教程是 Dana Angluin 的 L* 算法的完整实现，使用 Python 进行推断黑盒程序的输入语法（即不使用等价查询）。这种语法通常对于对此类程序进行模糊测试非常有用。Python 解释器被嵌入其中，以便您可以逐步完成实现步骤。

在许多以前的帖子中，我已经讨论了如何[解析](/post/2023/11/03/matching-regular-expressions/)、[模糊测试](/post/2021/10/22/fuzzing-with-regular-expressions/)和操作正则和上下文无关语法。然而，在许多情况下，这些语法可能不可用。如果您得到一个黑盒程序，在该程序以某种方式指示输入是否被接受，我们该怎么办才能学习到黑盒的实际输入规范呢？在这种情况下，最好的选择是尝试学习输入规范。

这个特定的研究领域探讨了如何学习黑盒程序的输入规范，被称为黑盒*语法推断*或*语法推理*（有关其他名称的讨论，请参见结尾处的**注释**）。在这篇文章中，我将讨论一种经典算法，用于学习输入规范，称为 L*。L* 算法是由 Dana Angluin 在 1987 年发明的^(. 虽然最初的算法使用了所谓的等价查询，假设您可以单独检查学习到的语法的正确性，而不需要使用 yes/no oracle，但在同一篇论文中，Angluin 也谈到了如何更新该算法，以利用 Valiant 的 PAC（*Probably Approximately Correct*）框架^(. Angluin 在 1988 年进一步展开了这一内容^.))

## 内容

1.  [先决条件](#prerequisites)

1.  [语法推断](#grammar-inference)

    1.  [观察表](#observationtable)

        1.  [将表格转换为语法](#convert-table-to-grammar)

        1.  [清理语法](#cleanup-grammar)

        1.  [已关闭](#closed)

        1.  [添加前缀](#add-prefix)

        1.  [一致](#consistent)

        1.  [添加后缀](#add-suffix)

    1.  [老师](#teacher)

        1.  [PAC 学习](#pac-learning)

    1.  [检查语法等价性](#check-grammar-equivalence)

    1.  [L* 主循环](#l-star-main-loop)

    1.  [F1 分数](#the-f1-score)

1.  [定义](#definitions)

1.  [备注](#notes)

    1.  [上下文无关语言](#context-free-languages)

    1.  [文物](#artifacts)

**重要提示：** [Pyodide](https://pyodide.readthedocs.io/en/latest/) 的初始化需要一些时间。初始化完成时，*运行所有* 按钮周围会出现红色边框。

<details><summary>可用包</summary>这些包要么是指向我的以前的帖子，要么是我编译的纯 Python 包，并且位于以下位置。与之前一样，如果需要在机器上直接运行程序，请安装它们。要安装，只需下载轮文件（`pkg.whl`），然后使用`pip install pkg.whl`进行安装。

1.  [simplefuzzer-0.0.1-py2.py3-none-any.whl](https://rahul.gopinath.org/py/simplefuzzer-0.0.1-py2.py3-none-any.whl)来自"[世界上最简单的语法模糊测试器](/post/2019/05/28/simplefuzzer-01/)"。

1.  [rxfuzzer-0.0.1-py2.py3-none-any.whl](https://rahul.gopinath.org/py/rxfuzzer-0.0.1-py2.py3-none-any.whl)来自"[使用正则表达式进行模糊测试](/post/2021/10/22/fuzzing-with-regular-expressions/)"。

1.  [earleyparser-0.0.1-py2.py3-none-any.whl](https://rahul.gopinath.org/py/earleyparser-0.0.1-py2.py3-none-any.whl)来自"[Earley 解析器](/post/2021/02/06/earley-parsing/)"。

1.  [cfgrandomsample-0.0.1-py2.py3-none-any.whl](https://rahul.gopinath.org/py/cfgrandomsample-0.0.1-py2.py3-none-any.whl)来自"[上下文无关文法的均匀随机抽样](/post/2021/07/27/random-sampling-from-context-free-grammar/)"。

1.  [cfgremoveepsilon-0.0.1-py2.py3-none-any.whl](https://rahul.gopinath.org/py/cfgremoveepsilon-0.0.1-py2.py3-none-any.whl)来自"[从上下文无关文法中去除空（ε）规则](/post/2021/09/29/remove-epsilons/)"。

1.  [gatleastsinglefault-0.0.1-py2.py3-none-any.whl](https://rahul.gopinath.org/py/gatleastsinglefault-0.0.1-py2.py3-none-any.whl)来自"[专门化上下文无关语法以引入故障](/post/2021/09/09/fault-inducing-grammar/)"。

1.  [hdd-0.0.1-py2.py3-none-any.whl](https://rahul.gopinath.org/py/hdd-0.0.1-py2.py3-none-any.whl)来自"[分层增量调试](/post/2019/12/04/hdd/)"。

1.  [ddset-0.0.1-py2.py3-none-any.whl](https://rahul.gopinath.org/py/ddset-0.0.1-py2.py3-none-any.whl)来自"[简单的 DDSet](/post/2020/08/03/simple-ddset/)"。</details>

#### 先决条件

我们需要模糊测试器生成输入以进行解析，并提供一些实用工具，例如将正则表达式转换为语法，从语法中随机抽样等。因此，我们导入所有这些内容。

# 语法推断

让我们假设黑盒程序接受[正则语言](https://en.wikipedia.org/wiki/Regular_language)。通过 *接受*，我指的是该程序对给定的输入进行一些处理而不是报错。例如，如果黑盒实际上包含一个 URL 解析器，它将 *接受* 一个看起来像 URL 的字符串，并 *拒绝* 不符合 URL 格式的字符串。

那么，给定这样一个程序，且你不被允许窥视程序源代码，你如何找出程序接受什么？假设该程序接受一个正则语言，我们可以从构建一个[DFA](https://en.wikipedia.org/wiki/Deterministic_finite_automaton)（确定有限状态机）开始。

有限状态机当然是计算机科学的基础。其思想是给定程序可以表示为一组离散状态，并在它们之间进行转换。确定有限自动机（DFA）初始化为起始状态。当给定输入符号时，一个状态会转移到另一个状态。一些状态被标记为*接受状态*。也就是说，从起始状态开始，消耗了输入中的所有符号后，达到的状态是接受状态之一，那么我们说该输入被机器*接受*了。

有了这些信息，我们将如何重建这台机器？一种直观的方法是认识到一个状态由恰好两组字符串表示。第一组字符串（前缀）是从起始状态到该状态的到达方式。第二组字符串是当前状态输入的延续，可以区分此状态与所有其他状态。也就是说，当且仅当有至少一个后缀字符串时，这两个状态可以由DFA区分，将其输入到状态对中时，会产生不同的答案-即对于其中一个，机器接受（或达到接受状态之一），而对于另一个，机器被拒绝（或结束状态不是接受状态）。

有了这些信息，一个用于跟踪我们实验的数据结构就呈现出来了 - 观察表，我们将前缀字符串作为行，将后缀字符串作为列。单元格内容简单地标记程序是否接受了前缀+后缀字符串。因此，这是我们的数据结构。

## 观察表

我们用字母表初始化观察表。我们将表本身保留为内部字典 `_T`。我们还将前缀保留在 `P` 中，将后缀保留在 `S` 中。我们将前缀集合 `P` 初始化为 \({\epsilon}\)，将后缀集合 `S` 也初始化为 \({\epsilon}\)。我们还添加了一些实用函数。

使用观察表和一些预先准备的数据。

### 将表转换为文法

给定观察表，我们可以从该表中恢复出文法（对应于DFA）。行的唯一单元格内容是状态。在许多情况下，多个行可能对应于相同的状态（因为单元格内容相同）。*起始状态*由对应于 \(\epsilon\) 行的状态给出。如果一个状态在查询 \(\epsilon\) 即 `''` 时返回 1，则它是接受的。

正式的符号如下所示。符号 \([p]\) 表示与前缀 \(p\) 对应的状态。符号 \([[p,s]]\) 表示前缀 \(p\) 和后缀 \(s\) 的oracle结果。符号 \([p](a)\) 表示通过将输入符号 \(a\) 提供给状态 \([p]\) 而获得的状态。我们将导致特定状态的第一个前缀作为其*访问前缀*，并将状态 \(s\) 的访问前缀表示为 \(\lfloor{}s\rfloor\)（这在此帖子中未使用）。以下是我们表格的DFA。

+   状态集：\(Q = {[p] : p \in P}\)

+   起始状态：\(q0 = [\epsilon]\)

+   转移函数：\([p](a) \rightarrow [p.a]\)

+   接受状态：\(F = {[p] : p \in P : [[p,\epsilon]] = 1}\)

为了从表中构建语法，我们首先识别所有区分状态。接下来，我们识别起始状态，接着是接受状态。最后，我们将状态与它们之间的转移连接起来。

让我们尝试将观察转换为文法，对应于识别字符串 `a` 的观察表。我们将使用字母 `a`、`b`。

### 清理语法

这样我们得到一个可以接受字符串 `a` 的语法，但它也存在问题。问题在于键 `<00>` 没有一个规则不包含 `<00>` 在其扩展中。也就是说，`<00>` 是一个无限循环，一旦机器进入其中，就无法退出。我们需要删除这样的规则。我们使用 LimitFuzzer 的 `compute_cost()` 函数来做到这一点。思路是如果一个非终结符的所有规则的成本都为 `inf`，那么该非终结符产生了一个无限循环，因此必须递归地删除该非终结符以及引用该非终结符的任何规则。

我们可以将所有事情都封装在一个方法中。

再一次

现在我们确信我们可以从表中生成一个 DFA 或语法，让我们继续检查如何生成这个表。

我们从表中的起始状态开始，因为我们确定它存在，并且由行和列中的空字符串表示，这两者（前缀 + 后缀）都是空字符串 `''` 或 \(\epsilon\)。我们询问程序是否接受空字符串，如果接受，我们将表中对应的单元格标记为*接受*（或 `1`）。

对于 DFA 中的任何给定状态，我们应该能够说当输入符号被输入到该状态的机器中时会发生什么。因此，我们可以扩展表格，说明每个输入符号被输入到起始状态时会发生什么。这意味着我们扩展表格，使其包含与输入字母表中的每个符号相对应的行。

因此，我们可以初始化表格如下。首先，我们检查空字符串是否在语言中。然后，我们使用成员查询将表格 `T` 扩展到 `(P u P.A).S`。这在 `update_table()` 中给出。

更新表格有两个部分。首先，它获取当前的前缀集合（`rows`）并确定要基于当前行与字母表中的符号的扩展来计算的辅助行（`auxrows`）。这给出了表格的完整行集合。然后，对于 `S` 中的每个后缀，确保表格具有单元格，并且更新为预期结果。

使用 init_table 和 update_table

由于我们想要知道当我们将输入符号提供给起始状态时我们到达了哪个状态，我们向表中添加了一组聪明选择的后缀（列），确定了机器对这些后缀的响应（通过为每个组合提供机器前缀+后缀），并检查是否识别了除起始状态以外的任何新状态。通过某个后缀，可以将通过前缀到达的新状态与起始状态区分开来，如果在消耗特定前缀后，接着特定后缀，机器转移到 *接受*，但是当将机器放在起始状态时提供相同的后缀时，终止状态不是*接受*。（即机器接受前缀 + 后缀，但不接受单独的后缀）。对称地，如果机器不接受字符串前缀 + 后缀，但接受字符串后缀，则这也将状态与起始状态区分开来。一旦我们确定了一个新状态，我们就可以扩展DFA以包含从这个新状态开始的转换，并检查是否可以识别更多状态。

在执行此操作时，有一个要求我们需要确保。每个字母的每个状态转换的结果都需要定义。确保观察表具有此属性的属性称为*闭合性*，或者等价地说，如果表具有以下属性，则观察表是*闭合的*。

### 闭合

思想是对于我们拥有的每个前缀，在集合\(P\)中，我们需要为每个\(a \in A\)找到到达的状态。然后，我们需要确保由该前缀表示的*状态*存在于\(P\)中。（如果在P中不存在这样的状态，则意味着我们已经找到了一个新状态）。

形式上：如果对于每个\(t \in P·A\)，存在\(p \in P\)使得\([t] = [p]\)，则观察表\(P \times S\)是封闭的。

使用闭合。

### 添加前缀

使用 add_prefix

这基本上是大多数语法推理算法背后的直觉，而聪明之处在于后缀的选择方式。在L*的情况下，当我们发现从当前状态的一个转换导致一个新状态时，我们将导致从当前状态进行转换的字母和区分新状态的后缀添加到后缀中（即，将 a + 后缀添加到列中）。

这个特定的方面受到观察表的*一致性*属性的控制。

### 一致

如果观察表\(P \times S\)是一致的，则每当\(p1\)和\(p2\)是P的元素，使得\([p1] = [p2]\)时，对于每个\(a \in A\)，\([p1.a] = [p2.a]\)。*如果*表的顶部有两行重复，则相应的后缀结果应该相同。如果不是，则我们找到了一个反例。因此，我们报告区分行的字母和后缀。然后，我们将新字符串（a + 后缀）作为新后缀添加到表中。

### 添加后缀

使用 add_suffix

（当然，读者很快就会注意到，表格并不是这里最好的数据结构，并且仅仅因为一个后缀区分了两个特定状态，并不意味着评估相同后缀在所有其他状态上都是一个好主意。这些是稍后算法将要探讨的想法）。

最后，L*也依赖于*教师*，以便它提出可以将未识别状态与当前状态区分开的新后缀。

## 教师

现在我们构建我们的教师。我们对教师有两个要求。第一个是它应该满足Oracle的要求。也就是说，它应该回答`is_member()`查询。其次，它还应该回答`is_equivalent()`查询。首先，我们定义Oracle接口。

正如我所承诺的，我们将使用PAC框架而不是等价物或者预言机。

我们根据正则表达式定义了一个简单的教师。也就是说，如果你给它一个正则表达式，它将会将其转换为基于[解析器](/post/2021/02/06/earley-parsing/)的接受器和基于[随机抽样器](/post/2021/07/27/random-sampling-from-context-free-grammar/)的生成器，并将用于验证假设语法。

### PAC 学习

PAC学习是由Valiant于1984年提出的，^(作为一种思考计算语言学和机器学习中推断模型的方法。基本思想是，鉴于一个黑盒模型，我们需要能够生成样本，然后对模型进行测试以构建推断模型（即训练模型）。在训练期间进行抽样，我们必须假设一些抽样过程，因此需要一个用于训练的分布。根据PAC学习，我们只能保证对使用来自同一分布的样本进行测试的学习模型的性能。鉴于我们从分布中抽样，由于非确定性的存在，有可能数据的分布不如我们所希望的那样广泛，因此训练数据以一定概率不是最优的。这反映了所学模型的质量。这通过置信区间的概念来表示，并由\(\delta\)参数表示。也就是说，\(1 - \delta\)量化了我们对模型的信心。接下来，鉴于任何训练数据，由于训练数据是有限的，我们学习的语法是实际语法的近似，并且将始终存在一个错误项。这个错误由\(\epsilon\)参数量化。鉴于所需的\(\delta\)和\(\epsilon\)，Angluin提供了一个公式来计算在第\(i^{th}\)等价查询中调用成员预言的次数。）

\[n=\lceil\frac{1}{\epsilon}\times log(\frac{1}{\delta}+i\times log(2))\rceil\]

本质上，PAC框架表明，模型学习的正确性将以\(1 - \delta\)的概率近似正确。也就是说，它将以小于\(\epsilon\)的错误率对样本进行分类。

我们输入PAC参数delta以获得置信度和epsilon以获得准确性

我们可以定义成员查询`is_member()`如下：

给定一个语法，检查它是否等价于给定的语法。PAC保证是我们只需要`num_calls`对于第`i`个等价查询。在这里等价检查，我们检查长度为1的字符串，然后长度为2的字符串等等，它们的总和应该是`num_calls`。我们采用了简单的方法，只是将`num_calls`作为每个字符串长度的调用次数。我们有一个称为*合作老师*，试图以尽可能短的反例回答。我们#也采用了简单的方法，只检查最大长度为10的情况。（如果有兴趣扩展此内容，我将重新审视这一点）。

由于我们随机抽样工具的限制，我们需要从除了开始规则之外的地方删除epsilon标记。

接下来，我们有一个用于生成随机采样器的辅助程序，以及用于简单比较的解析器。

## 检查语法等价性

检查两个语法是否等价于字符串长度为n的计数。

让我们测试一下。

## L星主循环

给定观察表和老师，算法本身很简单。L*算法循环执行以下操作。（1）保持表封闭，（2）保持表一致，如果封闭和一致（3）询问老师相应的假设语法是否正确。

使用它

我们为将语法错误转换为布尔值定义了一个匹配函数

## F1得分。

当然，这里还有一个额外的问题。从软件工程语言学习的角度来看，*我们是如何学习的*比*我们学到了什么*更不重要。也就是说，我们学到的模型的精确度和召回率很重要。我已经讨论了如何计算精确度和召回率，以及F1得分[之前](/post/2021/01/28/grammar-inference/)。因此，我们可以如下计算精确度和召回率。

# 定义

+   输入符号：由机器消耗的单个符号，可以将其从一个状态移动到另一个状态。这些符号的集合称为字母表，用\(A\)表示。

+   成员查询：传递给黑盒子的字符串。黑盒子回答是或否。

+   等价查询：作为目标语言假设的语法传递给老师。老师回答是或者在黑盒子和假设语法上表现不同的反例。

+   前缀封闭：如果集合的任何元素的所有前缀也在同一集合中，则集合是前缀封闭的。

+   后缀封闭：如果集合的任何元素的所有后缀也在同一集合中，则集合是后缀封闭的。

+   观察表：其行对应于*候选状态*的表。行由可以到达给定状态的前缀字符串组成——通常表示为\(S\)，但在这里我们将这些表示为\(P\)表示前缀——列由用于区分这些状态的后缀字符串组成——通常表示为\(E\)表示扩展，但我们将在此处使用\(S\)表示后缀。该表包含辅助行，用于扩展每个项目\(p \in P\)与每个字母\(a \in A\)，如我们稍后在*闭合性*中讨论的那样。该表定义了算法推断的语言。表的内容是来自于一个由行和列标签组成的字符串的答案——前缀+后缀。即\(T[s,e] = O(s.e)\)。表具有两个属性：*闭合性*和*一致性*。如果任何时候这些属性没有得到满足，我们将采取措施解决它。

+   状态：DFA中的状态由观察表中的前缀表示，并由单元格内容中1和0的模式命名。我们将与前缀\(p\)对应的状态表示为\([p]\)。

+   观察表的闭合性意味着对于每个\(p \in P\)和每个\(a \in A\)，由辅助行\([p.a]\)（即其内容）表示的状态存在于\(P\)中。也就是说，存在某个\(p' \in P\)使得\([p.a] == [p']\)。其思想是，与\([p]\)对应的状态接受字母\(a\)并转移到状态\([p']\)，而\(p'\)必须在主行集\(P\)中。

+   观察表的一致性意味着如果两个前缀表示相同的状态（即两行的内容相等），即\([p1] = [p2]\)，那么对于所有字母\([p1 . a] = [p2 . a]\)。其思想是，如果两个前缀达到状态，则当输入任何字母时，这两个前缀应该转移到相同的下一个状态（由后缀产生的模式表示）。

+   候选状态`P`是前缀闭合的，而后缀集合`S`是后缀闭合的。

# 注意事项

尽管关于语法归纳、推理、识别和学习没有严格的规范，但根据[Higuera](http://videolectures.net/mlcs07_higuera_giv/)的说法，语法推理是关于在提供有关某种语言的信息时学习**语法**（即表示），并侧重于目标，即语法。也就是说，你假设目标语法存在。然后，尝试根据你的观察来猜测那个语法。另一方面，如果你不相信某个特定的目标语法存在，但想尽最大努力学习底层原理，或者找到一个能解释数据的语法，那么这就是语法归纳。（这也在Higuera的书《语法推理》的前言中提到）也就是说，它侧重于给定数据的最佳可能语法。密切相关的领域是语法挖掘、语法恢复和语法提取，它们都是基于程序或相关工件分析的白盒方法。语言习得是另一个相关术语。

## 无上下文语言

在这里，我们讨论了如何推断正则语法。在许多情况下，黑匣子可能接受超出正则语言范围的语言，例如，它可能是上下文无关的。关于L*的好处是它可以为我们提供一个接近这种上下文无关语言的正则语法的近似值。然后，可以取得的正则语法，然后尝试并识别基于识别重复结构的DFA中的上下文无关结构。如何从这样的DFA中恢复上下文无关结构仍然是一个悬而未决的问题。

## 人工制品

本笔记本的可运行Python源代码在[这里](https://github.com/rahulgopinath/rahulgopinath.github.io/blob/master/notebooks/2024-01-04-lstar-learning-regular-languages.py)可用。
