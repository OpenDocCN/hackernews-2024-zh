<!--yml

类别：未分类

日期：2024-05-27 15:12:20

-->

# 有趣且有损的 CSS 压缩（或盈利）

> 来源：[`blog.danieljanus.pl/2024/01/26/lossy-css-compression/`](https://blog.danieljanus.pl/2024/01/26/lossy-css-compression/)

## 什么

去年底，我有了一个想法，这个想法一直在我的脑海中酝酿。最近我有了一些空闲时间（碰巧正好是假期），我拼凑了一些概念验证代码。无论它是否真的证明了这个概念我不太确定，但结果还是有些有趣的，而且我相信这个想法是新颖的（我没有在其他地方找到任何其他实现）。所以至少值得写一篇博客文章。

我写了`cssfact`，一个有损的 CSS 压缩器。也就是说，这是一个程序，它接受一些 CSS，并输出一些其他 CSS，希望保留输入中的一些（大部分）信息，但包含的规则比原始规则少。它生成的规则数量是可配置的，并且损失取决于该数量。

该程序仅适用于样式规则（构成典型 CSS 的大部分内容）。它不会更改非样式规则。

[这是源代码](https://github.com/nathell/cssfact)。要让它运行起来并不是特别简单，但也不应该太难。这非常简单 - 程序本身不包含任何花哨的逻辑；输出将包含什么内容的实际决定是由外部程序做出的。

如果你只想看一些结果，这里有一个示例，以[我的主页](https://danieljanus.pl)作为患者躺在手术台上。它的 CSS 很小 - 有 55 个样式规则，`cssfact` 可以处理 - 这是页面在不同设置下的外观：

+   原始：[页面](https://danieljanus.pl)，[CSS](https://danieljanus.pl/css/nhp.css)，[源 SASS](https://github.com/nathell/nhp/blob/master/src/sass/nhp.sass)

+   1 个样式规则：[页面](https://danieljanus.pl/index1.html)，[CSS](https://danieljanus.pl/css/nhp1.css)（93% 信息丢失）

+   5 个样式规则：[页面](https://danieljanus.pl/index5.html)，[CSS](https://danieljanus.pl/css/nhp5.css)（74% 信息丢失）

+   10 个样式规则：[页面](https://danieljanus.pl/index10.html)，[CSS](https://danieljanus.pl/css/nhp10.css)（55% 信息丢失）

+   20 个样式规则：[页面](https://danieljanus.pl/index20.html)，[CSS](https://danieljanus.pl/css/nhp20.css)（31% 信息丢失）

+   30 个样式规则：[页面](https://danieljanus.pl/index30.html)，[CSS](https://danieljanus.pl/css/nhp30.css)（17% 信息丢失）

我的主页和我的两个博客都使用相同的 CSS，所以你可以尝试在其他网站的浏览器开发工具中替换 CSS，看看效果如何。

## 如何

三个词：[二进制矩阵分解](https://cs.uef.fi/~pauli/bmf_tutorial/material.html)（在布尔代数中称为 BMF）。

我想我可以在这里停下，但我会详细说明，以防不清楚。

考虑一个简单的 CSS 片段：

```
h1, h2 {
   padding: 0;
   margin-bottom: 0.5em;
}

h1 {
   font-size: 32px;
   font-weight: bold;
}

h2 {
   font-size: 24px;
   font-weight: bold;
} 
```

第一条规则告诉你，对于所有与 `h1` 或 `h2` 选择器匹配的元素，这两个声明都应该适用。

你可以将这个 CSS 可视化为一个 5x2 的二进制矩阵 *A^T*，其中 *n* 列对应于简单选择器（即没有逗号的选择器），*m* 行对应于声明：

|  | `h1` | `h2` |
| --- | --- | --- |
| `padding: 0` | 1 | 1 |
| `margin-bottom: 0.5em` | 1 | 1 |
| `font-size: 32px` | 1 | 0 |
| `font-size: 24px` | 0 | 1 |
| `font-weight: bold` | 1 | 1 |

你还可以转置矩阵，得到 *m* 行表示选择器，*n* 列表示声明的矩阵 *A*。对于我的主页 CSS，*m* = 60，*n* = 81；对于更大的样式表，每个方向上都有几千个都不是罕见的。

现在，线性代数给了我们一些算法，可以找到一个矩阵 *A′ ≈ A*，使得存在一个分解 *A′ = B × C*，其中 *B* 的维度为 *m × r*，*C* 的维度为 *r × n*，而 *r* 很小——通常比 *m* 或 *n* 小得多。因此，这是一种降维的方式。

在实数代数中，没有保证 *B* 或 *C* 本身将是二进制矩阵——实际上，它们很可能不是。但是如果我们改用布尔代数（即其中 1 + 1 = 1），那么 *B* 和 *C* 都将是二进制的。反过来，布尔 BMF 问题是 NP 难的，所以在实际中找到的算法执行的是近似分解，不能保证是最优的。

但这没关系，因为损失性在我们正在做的事情中是固有的，并且二进制矩阵 *B* 和 *C* 可以很容易地解释。再看一下上面的 CSS 矩阵：为什么左上角的单元格中有一个 1？因为至少有一个 CSS 规则规定了选择器 `h1` 的声明 `padding: 0`。

这正是布尔代数中矩阵乘法的定义。矩阵 *A′* 中的坐标 [*i, j*] 上将有一个 1，当且仅当存在一个 *k* ∈ {1, …, *r*}，使得 *B*[*i*, *k*] = 1 并且 *C*[*k*, *j*] = 1。因此，*B* 的列和 *C* 的行实际上对应于 CSS 规则！每次你写 CSS 时，实际上都在编写二进制矩阵——浏览器正在将它们相乘以得到实际的行为。

嗯，并不完全是这样，但这是一种思考方式。这并不完美——它完全忽略了规则之间的重叠和优先级，并将它们视为同等重要——但它有点起作用！

你可以将任何 BMF 算法插入到这个方法中。对于 cssfact，我选择了 [Barahona 和 Goncalves 2019](https://github.com/IBM/binary-matrix-factorization/) 的代码——可惜我找不到实际的论文——不是因为它表现得特别好（在较大的样式表上实际上非常慢），而是因为我很容易让它工作并与之接口。

## 为什么

为什么不呢？

探索的纯粹快乐已经足够理由，但我相信有潜在的实际应用。 CSS 代码库往往会有有机增长的趋势，并最终开始因为自身的重量而崩溃，必须非常谨慎地维护才能防止这种情况发生。在许多野生的 CSS 丑陋代码中，有许多更清洁、更精简、更能捕捉本质的核心正在努力脱颖而出。

这个工具可能不会自动为您提取它们 - 所以不要将其放入您的 CI 流水线中 - 但通过查看它生成的 CSS 并与输入进行交叉检查，您可能会遇到关于您的样式中存在冗余的提示。诸如“这些组件实际上非常相似，所以可能应该合并”之类的东西可能会更加明显。
