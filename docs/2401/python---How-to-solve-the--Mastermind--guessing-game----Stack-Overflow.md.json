["```\nfrom __future__ import division # No need to cast to float when dividing\nimport collections, itertools, math \n```", "```\nPegs = collections.namedtuple('Pegs', 'black white')\ndef mastermindScore(g1,g2):\n  matching = len(set(g1) & set(g2))\n  blacks = sum(1 for v1, v2 in itertools.izip(g1,g2) if v1 == v2)\n  return Pegs(blacks, matching-blacks) \n```", "```\ndef mastermind(colours, holes):\n  return dict(\n    G           = set(itertools.product(colours,repeat=holes)),\n    V           = set(itertools.permutations(colours, holes)),\n    score       = mastermindScore,\n    endstates   = (Pegs(holes, 0),))\n\ndef mediumGame():\n    return mastermind((\"Yellow\", \"Blue\", \"Green\", \"Red\", \"Orange\", \"Purple\"), 4) \n```", "```\ndef partition(S, func, *args, **kwargs):\n  partition = collections.defaultdict(set)\n  for v in S: partition[func(v, *args, **kwargs)].add(v)\n  return partition \n```", "```\ndef entropy(P):\n  total = sum(P)\n  return -sum(p*math.log(p, 2) for p in (v/total for v in P if v)) \n```", "```\ndef decisionEntropy(V, g, score):\n  return entropy(collections.Counter(score(gi, g) for gi in V).values()) \n```", "```\ndef bestDecision(V, G, score):\n  return max((decisionEntropy(V, g, score), g in V, g) for g in G)[2] \n```", "```\nNode = collections.namedtuple('Node', 'decision branches')\nBranch = collections.namedtuple('Branch', 'result subtree')\ndef lazySolutionTree(G, V, score, endstates, **kwargs):\n  decision = bestDecision(V, G, score)\n  branches = (Branch(result, None if result in endstates else\n                   lazySolutionTree(G, pV, score=score, endstates=endstates))\n              for (result, pV) in partition(V, score, decision).iteritems())\n  yield Node(decision, branches) # Lazy evaluation \n```", "```\ndef solver(scorer, **kwargs):\n  lazyTree = lazySolutionTree(**kwargs)\n  steps = []\n  while lazyTree is not None:\n    t = lazyTree.next() # Evaluate node\n    result = scorer(t.decision)\n    steps.append((t.decision, result))\n    subtrees = [b.subtree for b in t.branches if b.result == result]\n    if len(subtrees) == 0:\n      raise Exception(\"No solution possible for given scores\")\n    lazyTree = subtrees[0]\n  assert(result in endstates)\n  return steps \n```", "```\ndef allSolutions(**kwargs):\n  def solutions(lazyTree):\n    return ((((t.decision, b.result),) + solution\n             for t in lazyTree for b in t.branches\n             for solution in solutions(b.subtree))\n            if lazyTree else ((),))\n  return solutions(lazySolutionTree(**kwargs)) \n```", "```\ndef worstCaseSolution(**kwargs):\n  return max((len(s), s) for s in allSolutions(**kwargs)) [1] \n```", "```\ndef solutionLengthDistribution(**kwargs):\n  return collections.Counter(len(s) for s in allSolutions(**kwargs)) \n```", "```\ndef solutionExists(maxsteps, G, V, score, **kwargs):\n  if len(V) == 1: return True\n  partitions = [partition(V, score, g).values() for g in G]\n  maxSize = max(len(P) for P in partitions) ** (maxsteps - 2)\n  partitions = (P for P in partitions if max(len(s) for s in P) <= maxSize)\n  return any(all(solutionExists(maxsteps-1,G,s,score) for l,s in\n                 sorted((-len(s), s) for s in P)) for i,P in\n             sorted((-entropy(len(s) for s in P), P) for P in partitions)) \n```", "```\ndef lowerBoundOnWorstCaseSolution(**kwargs):\n  for steps in itertools.count(1):\n    if solutionExists(maxsteps=steps, **kwargs):\n      return steps \n```", "```\nComparison = collections.namedtuple('Comparison', 'less greater equal')\ndef twoDScorer(x, y):\n  return Comparison(all(r[0] <= r[1] for r in zip(x, y)),\n                    all(r[0] >= r[1] for r in zip(x, y)),\n                    x == y)\ndef twoD():\n  G = set(itertools.product(xrange(5), repeat=2))\n  return dict(G = G, V = G, score = twoDScorer,\n              endstates = set(Comparison(True, True, True))) \n```"]