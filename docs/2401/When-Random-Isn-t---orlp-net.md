<!--yml

分类：未分类

date: 2024-05-27 14:45:56

-->

# 随机值不是 | orlp.net

> 来源：[https://orlp.net/blog/when-random-isnt/](https://orlp.net/blog/when-random-isnt/)

2024-01-10

这篇文章讲述了十多年前的一个趣事，对于其中真正的代码我已经遗失了。因此，请原谅我如果我没有准确记得所有的细节。有些细节也被简化了，以便喜欢计算机安全的每个人都可以享受这篇文章，而不仅仅是那些玩过《魔兽世界》的人（尽管这两个群体的[维恩图](https://en.wikipedia.org/wiki/Venn_diagram)可能有一个很大的重叠部分）。

当我大约14岁时，我发现了由暴雪游戏开发的[《魔兽世界》](https://en.wikipedia.org/wiki/World_of_Warcraft)，并立刻着迷。不久之后，我发现了插件，可以修改游戏用户界面的外观和功能。然而，并非所有我下载的插件都能完全满足我的需求。我想要更多。所以我开始探究它们是如何制作的。

转折怪事的是，我认为是《魔兽世界》让我系统地学习编程。结果证明，它们是用[Lua](https://www.lua.org/)编程语言制作的。插件仅仅是一些 `.lua` 源文件，直接放在游戏的一个文件夹中进行加载。进入门槛非常低：只需编辑一个文件，保存并重新加载界面。游戏加载*你的*源代码并且你可以看到它运行，这仿佛是魔术一样！

我极其喜欢它，不知不觉间我只是在编写插件，几乎不再玩游戏本身了。在接下来的两年里，我发布了[相当多的插件](https://www.wowinterface.com/downloads/author-207710.html)，其中大部分是复制其他人的代码并进行了一些重构/重组/调整以满足我的需求。

你可能认为让玩家在游戏中拥有完全可编程的插件是一个非常糟糕的主意，免得你会遇到机器人。然而，暴雪为防止任意可编程行为所制定的系统相当巧妙。当然，它对于防止实际的机器人作用毫无帮助，但至少那些遵守规则的普通玩家在根本上是受到暴雪允许的自动化的限制的。

大多数你可以创建的用户界面元素都是严格装饰性的或者信息性的。这些是完全无限制的，大多数 API 用于收集信息也是如此。例如，您可以使用两个框架制作一个血条显示，一个做背景，一个做前景，并使用 API 调用来获取你的角色的生命值来调整前景框的大小。

然而，并非所有的 API 调用都对你开放。有些是受保护的，因此只能从官方暴雪代码中调用。这些通常涉及 API 调用，比如移动你的角色、施法、使用物品等，总的来说，任何可以让你在游戏中做出实际动作的都是受保护的。

然而，一些用户界面元素确实需要与游戏本身进行交互，例如，如果我想要创建一个按钮来施放某个法术。为此，您可以构造一种特殊类型的按钮，当点击时在安全环境中执行代码。只有在非战斗状态下才允许创建/销毁/移动这样的按钮，因此您不能简单地在战斗期间有条件地将这些按钮放在鼠标指针下以自动执行操作。

情况是这样的，这个[安全环境](https://wowwiki-archive.fandom.com/wiki/RestrictedEnvironment)确实允许您以编程方式设置要施放的法术，但不允许您收集进行任意自动化所需的信息。所有来自安全环境外部的状态访问都被阻止了。有一些信息收集的 API 调用可用于匹配更易访问的游戏内宏系统，但没有像获取技能冷却时间或单位生命值那样的复杂功能，从而使自动施法变得更加优化。

所以有两个环境：一个是不安全的环境，在这个环境中你可以获得所有的信息，但不能对其进行操作；另一个是安全的环境，在这个环境中你可以进行操作，但不能获取自动化所需的信息。

几年后，我基本上停止了游戏。我的兴趣主要转向了更“严肃”的编程，我只是偶尔玩一下，大多数时间都在玩一些插件的想法。但是这个安全环境一直在我的脑海中挥之不去；我想要打破它。

当然，有第三方软件完全可以彻底关闭暴雪公司的安全限制，但那有什么乐趣呢？我想要“合法地”使用技术上允许的工具来挑战。

所以我扫描了安全环境允许的功能列表，看看是否可以将外部的任何信息走私到安全环境中去。一切看起来都相当绝望，直到我看到一个微小的、无辜的函数：`random`。

一个邪恶的想法突然在我的脑海中闪现：计算机中使用的随机数生成器（RNGs）几乎总是带有（隐藏）内部状态的[伪随机数生成器](https://en.wikipedia.org/wiki/Pseudorandom_number_generator)。如果我能操纵这个状态，也许我就能利用它将信息传递到安全环境中去。

结果发现 `random` 只是 C 的[`rand`](https://en.cppreference.com/w/c/numeric/random/rand) 的一个小包装。我兴奋极了！这意味着有一个单一的全局随机状态在进程中共享。此外，`rand` 的实现倾向于比较薄弱。由于《魔兽世界》是使用 MSVC 编译的，`rand` 的实际实现如下：

```
uint32_t state;   int rand() {
 state = state * 214013 + 2531011;
  return (state >> 16) & 0x7fff; } 
```

这个随机数生成器（RNG）可以用另一个更好的词来形容，那就是糟糕。它是一个裸露的[线性同余生成器](https://en.wikipedia.org/wiki/Linear_congruential_generator)，而且是一个很弱的生成器。在我的情况下，这是一件好事。

让我们来破解这个东西。因为状态是如此地微小，你可以直接看到状态的15位，你可以保持一个包含与RNG单个输出一致的所有可能状态的完整列表，并利用对RNG的进一步调用来消除可能性，直到仅剩下一个。但我们可以更聪明地做。

首先，我们注意到 `state` 的最高位永远不会影响这个RNG中的任何东西。`(state >> 16) & 0x7fff` 掩盖掉15位，在移除底部16位后有效地对 $2^{31}$ 取模。由于在任何更新中，新状态都是前一个状态的线性函数，我们可以将这种模形式一直传递到初始状态，即对于任何线性 $f$，都有 $$f(x) \equiv f(x \bmod m) \mod m$$

让 $a = 214013$ 且 $b = 2531011$。我们观察两次RNG调用的15位输出 $r_0, r_1$。我们将分别称之为第一次和第二次调用后隐藏在移位中的16位RNG状态为 $h_0, h_1$。这意味着第一次调用后RNG的状态是 $2^{16} r_0 + h_0$，第二次调用后类似地为 $2^{16} r_1 + h_1$。然后我们有以下等式：

$$a\cdot (2^{16}r_0 + h_0) + b \equiv 2^{16}r_1 + h_1 \mod 2^{31},$$

$$ah_0 \equiv h_1 + 2^{16}(r_1 - ar_0) - b \mod 2^{31}.$$

现在让 $c \geq 0$ 为已知常数 $(2^{16}(r_1 - ar_0) - b) \bmod 2^{31}$, 然后对于一些整数 $k$ 我们有

$$ah_0 = h_1 + c + 2^{31} k.$$

注意左边范围为 $0$ 到 $a (2^{16} - 1) \approx 2^{33.71}$。因此我们必须有 $-1 \leq k \leq 2^{2.71} < 7$。重排得到 $h_0$ 的以下表达式：$$h_0 = \frac{c + 2^{31} k}{a} + h_1/a.$$ 由于 $a > 2^{16}$ 而 $0 \leq h_1 < 2^{16}$，我们注意到项 $0 \leq h_1/a < 1$。因此，假设存在解，我们必须有 $$h_0 = \left\lceil\frac{c + 2^{31} k}{a}\right\rceil.$$

所以对于 $-1 \leq k < 7$ 我们计算首次调用后RNG状态的隐含部分的上述猜测。这给我们8个猜测，之后我们可以使用对RNG的后续调用拒绝错误的猜测，直到仅剩下一个唯一的答案。

这个过程在Python中的一个示例实现：

```
import random   A = 214013 B = 2531011   class MsvcRng:
  def __init__(self, state):
 self.state = state   def __call__(self):
 self.state = (self.state * A + B) % 2**32
  return (self.state >> 16) & 0x7fff   # Create a random RNG state we'll reverse engineer. hidden_rng = MsvcRng(random.randint(0, 2**32))   # Compute guesses for hidden state from 2 observations. r0 = hidden_rng() r1 = hidden_rng() c = (2**16 * (r1 - A * r0) - B) % 2**31 ceil_div = lambda a, b: (a + b - 1) // b h_guesses = [ceil_div(c + 2**31 * k, A) for k in range(-1, 7)]   # Validate guesses until a single guess remains. guess_rngs = [MsvcRng(2**16 * r0 + h0) for h0 in h_guesses] guess_rngs = [g for g in guess_rngs if g() == r1] while len(guess_rngs) > 1:
 r = hidden_rng() guess_rngs = [g for g in guess_rngs if g() == r]
  # The top bit can not be recovered as it never affects the output, # but we should have recovered the effective hidden state. assert guess_rngs[0].state % 2**31 == hidden_rng.state % 2**31 
```

虽然我使用了 `while` 循环编写了上述过程，但它似乎只需要最多三次输出就能缩小到一个猜测。

一旦我们可以逆向工程随机数发生器的内部状态，我们就可以在被认为是安全的环境中做出任意自动决定。它的工作原理如下：

1.  注册了一个不安全的钩子，这个钩子会在安全环境代码运行之前执行。

1.  在这个钩子中，我们可以完全访问信息，并决定应采取哪种行动（例如施放特定的咒语）。这个行动在硬编码列表中查找以获取索引。

1.  使用上述过程逆向工程RNG的当前状态。

1.  我们预测下一个RNG调用的结果。如果这个结果（对我们动作列表的长度取模）不符合我们的期望结果，我们就推进RNG并重试。这个过程一直重复，直到下一个随机数对应我们期望的动作。

1.  钩子回来了，并且安全环境开始运行。它生成一个“随机”数字，索引我们硬编码的动作列表，并执行“随机”动作。

就是这样！通过能够模拟随机数生成器（RNG）并向前看一步，我们可以将其用作信息通道，选择恰到好处的时刻在安全环境中调用`random`。现在，如果你想支持一个$n$个动作的列表，平均需要$n$步的RNG才能得到正确的数字来传递，但在实践中这并不是问题。

我不知道暴雪是什么时候修复了RNG状态如此脆弱且共享的问题，或者他们是否意识到这是一个问题。在我写下这段代码几年后，出于好奇，我再次尝试了一下，但它不再起作用了。也许他们换了一种不同的算法，或者为安全环境有了一个正确分离的RNG状态。

总的来说，这对于一个我甚至不想使用的视频游戏中的一个小众漏洞来说是相当大的努力。但是，把一个据说是随机的东西操纵成完全符合你的意愿的事情确实有一种魔力，就像一个魔术师从洗过的牌堆中抽出四张A牌一样。
