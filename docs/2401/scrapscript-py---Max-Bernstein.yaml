- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:07:34'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: scrapscript.py | Max Bernstein
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://bernsteinbear.com/blog/scrapscript/](https://bernsteinbear.com/blog/scrapscript/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Scrapscript](https://scrapscript.org/) is a small, pure, functional, content-addressable,
    network-first programming language. It’s designed to allow creating small, simply
    shareable programs. The language was created by [Taylor Troesh](https://taylor.town/)
    and the main implementation was created by me and [Chris](https://www.chrisgregory.me/).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I’m not going to fill out the [usual checklist](https://www.mcmillen.dev/language_checklist.html)—that’s
    not the point of the post, and a lot of it is answered on the website. This post
    is more about the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In April of 2023, I saw scrapscript posted on Hacker News and sent it to Chris.
    We send each other new programming languages and he’s very into functional programming,
    so I figured he would enjoy it. He did!
  prefs: []
  type: TYPE_NORMAL
- en: But we didn’t see any links to download or browse an implementation, so we were
    a little bummed. We love trying stuff out and getting a feel for how it works.
    A month or two passed and there still was not an implementation, so we decided
    to email Taylor and ask if we could help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subject: Chris and I would like to help you with scrapscript'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hi Taylor,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: My friend Chris (cc’ed) and I are excited about scrapscript. This is the kind
    of project we have talked about building for years. He’s an ML guy with an unreasonable
    interest in Haskell and I’m a PL/compilers guy (not as much into Haskell) and
    would be very interested in chipping in, or at least trying early betas.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Chris: https://www.chrisgregory.me/'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Me: https://bernsteinbear.com/'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cheers,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Max
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Taylor was very gracious about the whole thing and shared his [small JavaScript
    implementation of scrapscript](https://github.com/tekknolagi/scrapscript/blob/71d1afecc32879aed9c80a3ed17cb81fe1c010d6/scrapscript.ts).
    For such a little file, it implemented an impressive featureset.
  prefs: []
  type: TYPE_NORMAL
- en: Chris nor I are particularly good at JavaScript and we figured more implementations
    couldn’t hurt, so we decided to make a parallel implementation with the same features.
    While Taylor’s primary design constraint was implementation size, ours was some
    combination of readability and correctness. This meant that we wrote a lot of
    tests along the way to pin down the expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Two days into this little hackathon, we told Taylor and he was pretty happy
    about it, so we started having semi-regular chats and continued hacking. Three
    weeks later, we opened up [the repo](https://github.com/tekknolagi/scrapscript)
    to the public. Please take a look around! Most of it is in one file, `scrapscript.py`.
    This was one of our early design decisions…
  prefs: []
  type: TYPE_NORMAL
- en: Implementation design decisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While we weren’t explicitly trying to keep the implementation size down like
    Taylor was, we did want to keep it self-contained. That led to a couple of implicit
    and explicit design choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No external dependencies for core features.** Keep the core understandable
    without needing to go off and refer to some other library.'
  prefs: []
  type: TYPE_NORMAL
- en: As a sort of corollary, **try to limit dependencies on unusual or fancy features
    of the host programming language (Python).** We wanted to make sure that porting
    the implementation to another programming language was as easy as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test features at the implementation level and end-to-end.** Write functions
    that call `tokenize` and `parse` and `eval_exp` explicitly so that we catch errors
    and other behavior as close to the implementation as possible. Also write full
    integration tests, because those can be used as a feature showcase and are easily
    portable to other implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Choosing Python was mostly a quirk. Python is not in general special; it just
    happens to be a language that Chris and I have worked with a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences of our testing strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making sure to test early and test thoroughly had some excellent consequences.
    It meant that we could keep a record of the expected behavior we discovered in
    `scrapscript.js` as we ported it and have that record continuously checked. It
    also meant that as we [gutted and re-built it](https://github.com/tekknolagi/scrapscript/commit/082e30375225394f30fd270ffdcee7f5d63173ae),
    we felt very confident that we weren’t breaking everything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All the tests continued to pass and we could even enable a new one!
  prefs: []
  type: TYPE_NORMAL
- en: Why is this interpreter different from all other interpreters?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not. It’s a pretty bog-standard tree-walking interpreter for a juiced-up
    lambda calculus^(. Perhaps we’ll eventually generate bytecode or some other IR
    and compile it, but we do not have any performance problems (yet). And scrapscript
    doesn’t feel like an “industrial strength” language; nobody is writing large applications
    in it and the language is expressly not designed for that.)
  prefs: []
  type: TYPE_NORMAL
- en: It’s a little different *for me*, though, because it has features that I have
    never implemented before! In particular, scrapscript supports some pretty extensive
    pattern matching, which we had to learn how to implement from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It’s also different because it’s the first from-scratch language implementation
    I have worked on with someone else (I think). Chris has been an excellent co-implementor,
    which is very impressive considering it his first programming language implementation
    *ever*!
  prefs: []
  type: TYPE_NORMAL
- en: Some neat implementation features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why have a little programming project if you don’t get to try out some new tricks
    and techniques?
  prefs: []
  type: TYPE_NORMAL
- en: The REPL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have seen [my recent blog post](/blog/simple-python-repl/) about building
    a featureful REPL using a nice library that Python gives you. I wrote that post
    while learning about all that stuff for scrapscript. Scrapscript’s REPL implementation
    is pretty short but it has `readline` support, tab completion, line continuation,
    and more. Thanks, Python!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An actually portable executable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We build scrapscript as an Actually Portable Executable using [Cosmopolitan](https://justine.lol/cosmopolitan/)
    by Justine Tunney. This means that it is packaged with a small libc implementation
    and Python runtime into one (reasonably) small, self-contained executable. This
    executable is theoretically runnable on all major platforms without fuss. And
    the Docker container that we build with it is ~~36MB~~ 25.5MB in total (!) because
    it does not need to have a bunch of operating system stuff in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Check out [build-com](https://github.com/tekknolagi/scrapscript/blob/e38210f7aa8ce375a7e615b301922bd7b9710d37/build-com)
    and [the Dockerfile](https://github.com/tekknolagi/scrapscript/blob/e38210f7aa8ce375a7e615b301922bd7b9710d37/Dockerfile)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The web REPL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We wanted to have an interactive playground like a bunch of other programming
    languages do. I, however, didn’t feel like implementing scrapscript a second time.
    So instead I wrote a little stateless server program in Python that is a function
    `(env, exp) -> (env', result)` and a JS program to drive the web requests. What
    you get is [the web REPL](https://scrapscript.fly.dev/repl). Building this required
    being able to serialize objects and environments so that they could be stored
    on the client as opaque blobs. That’s mostly working, but I don’t have a full
    solution for objects with cycles. Yet. It’s in progress!
  prefs: []
  type: TYPE_NORMAL
- en: In progress features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned before, serializing objects with cycles is a work in progress.
    This requires adding support for fake `ref` types inside the serializer and resolving
    them in the deserializer. It should be ready to ship soon enough, though.
  prefs: []
  type: TYPE_NORMAL
- en: We also don’t have full support for alternates as described on the main website.
    It shouldn’t be particularly difficult but nobody has implemented it yet. We did
    get symbols working, though, so we have `#true` and `#false` implemented inside
    scrapscript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re also working on the first implementations of scrapyards. We’re not sure
    exactly what design direction to go yet so Taylor and I have each prototyped it
    in different ways. My implementation uses Git as a versioned blob store to be
    very lazy about it and re-use a bunch of existing infrastructure. That’s one of
    my personal goals for this implementation: minimal implementation first.'
  prefs: []
  type: TYPE_NORMAL
- en: Scrapscript comes with a notion of platforms—different sets of APIs given to
    a scrap by the host running it. It’s not really built in yet but I did prototype
    a “web platform”. This was a little Python shell around a scrap that fed it web
    requests as scrap records. Then the scrap could use pattern matching to route
    the request and build up a request. As Taylor says on the website, scrapscript
    is pretty decent for an HTML DSL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the future I think it could be fun to—similar to the web REPL—write a function
    `(db, request) -> (db', response)` and have a stateless webserver kernel that
    can still store data if the outside world applies the delta to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Chris and I also talked about building out a graphics API or graphics platform.
    We’re not sure what this looks like, but he is into cellular automata and it would
    be neat to be able to write pixels directly from scrap without going through PPM
    or something.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but certainly not least, we are working on a scrapscript compiler. The
    neat thing, though, is that this compiler is written *in scrapscript*. The goal
    is to port scrapscript to the browser not by writing a new interpreter in JS,
    but by compiling the compiler to JS (on top of the Python interpreter), then running
    the compiler (now JS code) on the web.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Thanks for reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well first, play with [the web REPL](https://scrapscript.fly.dev/repl). Then
    take a look at [the repo](https://github.com/tekknolagi/scrapscript) and start
    contributing! Since we don’t have a huge backlog of well-scoped projects just
    yet, I recommend posting in the [discourse group](https://scrapscript.discourse.group/)
    first to get an idea of what would be most useful and also interesting to you.
  prefs: []
  type: TYPE_NORMAL
