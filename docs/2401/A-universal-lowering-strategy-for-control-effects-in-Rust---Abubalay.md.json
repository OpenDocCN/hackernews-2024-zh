["```\neffect my_effect {\n    operation_x(A) -> B;\n} \n```", "```\nfn my_computation() -> C {\n    let b: B = operation_x(A { ... });\n\n    C { ... }\n}\n\nfn main() {\n    handle my_computation() {\n        // The computation has performed an operation:\n        operation_x(resume, a) => { resume(B { ... }) }\n\n        // The computation has completed:\n        return(c) => {}\n    }\n} \n```", "```\neffect gen<Item> {\n    yield(Item) -> ();\n} \n```", "```\nfor item in some_iter() {\n    loop_body(item);\n} \n```", "```\nhandle some_iter() {\n    yield(resume, item) => {\n        loop_body(item);\n        resume(())\n    }\n    return(()) => {}\n} \n```", "```\neffect try<E> {\n    throw(E) -> !;\n} \n```", "```\nhandle try_work() {\n    // Propagate the `try` effect by forwarding `throw` operations in `try_work`.\n    throw(resume, e) => { throw(e) }\n    return(x) => { x }\n} \n```", "```\neffect async {\n    read(File, &mut [u8]);\n    write(File, &[u8]);\n    // ...\n} \n```", "```\neffect async {\n    sleep(impl FnOnce(&Waker)) -> ();\n} \n```", "```\nhandle async_work() {\n    // Propagate the `async` effect by forwarding `sleep` operations in `async_work`.\n    sleep(resume, schedule) => { resume(sleep(schedule)) }\n    return(x) => { x }\n} \n```", "```\nfor await item in some_async_iter() {\n    loop_body(item);\n} \n```", "```\nhandle (handle some_async_iter() {\n    yield(resume, item) => {\n        loop_body(item);\n        resume(())\n    }\n    return(()) => {}\n}) {\n    sleep(resume, schedule) => { resume(sleep(schedule)) }\n    return(()) => {}\n} \n```", "```\nhandle (handle some_async_iter() {\n    sleep(resume, schedule) => {\n        /* ... block_on ... */\n        resume(())\n    }\n    return(()) => {}\n}) {\n    yield(resume, item) => { resume(yield(item)) }\n    return(()) => {}\n} \n```", "```\nhandle (handle f.read(buf) {\n    throw(resume, e) => { resume(throw(e)) }\n    return(len) => { len }\n}) {\n    sleep(resume, schedule) => { resume(sleep(schedule)) }\n    return(len) => { len }\n} \n```", "```\ntrait Iterator {\n    type Item;\n\n    // isomorphic to Either<Item, ()>\n    fn next(&mut self) -> Option<Self::Item>;\n} \n```", "```\ntrait Future {\n    type Output;\n\n    // isomorphic to Either<impl FnOnce(&Waker), Output>\n    fn poll(Pin<&mut Self>, &mut Context<'_>) -> Poll<Self::Output>;\n} \n```", "```\n// isomorphic to Either<E, Output>\nfn /* ... */ -> Result<Output, E>; \n```", "```\neffect eff1 { op1(A) -> B; }\neffect eff2 { op2(C) -> D; }\n// ...\n\ntrait /* ... */ {\n    type Output;\n    fn resume(Pin<&mut Self>, Either<(), B, D>) -> Either<A, C, Self::Output>;\n} \n```", "```\ntrait AsyncIterator {\n    type Item;\n    fn poll_next(Pin<&mut Self>, &mut Context<'_>) -> Poll<Option<Self::Item>>;\n} \n```", "```\neffect gen<Item> {\n    yield(Item) -> (&mut resume, ());\n} \n```", "```\neffect gen<Item<'a>> {\n    yield<'a>(Item<'a>) -> (Pin<&'a mut resume>, ());\n} \n```", "```\ntrait Coroutine {\n    type Resume...;\n    type Yield...;\n    type Output;\n    fn resume(Pin<&mut Self>, () + Self::Resume) -> Self::Yield + Self::Output;\n}\n\nimpl<I: Coroutine, F, B> Coroutine for Map<I, F> where\n    F: FnMut(I::Item) -> B,\n{\n    type Resume = I::Resume;\n    type Yield = Option<B>::Some + I::Yield;\n    type Output = I::Output;\n\n    fn resume(self: Pin<&mut Self>, r: () + Self::Resume) -> Self::Yield + Self::Output {\n        match self.project().iter.resume(r) {\n            Some(item) => { Some((self.f)(item)) }\n            y => { y }\n        }\n    }\n} \n```", "```\nimpl<I: Iterator, F, B: Coroutine> Coroutine for Map<I, F> where\n    F: FnMut(I::Item) -> B,\n{\n    type Resume = () + B::Resume;\n    type Yield = Option<B::Output>::Some + B::Yield;\n    type Output = Option<B::Output>::None;\n\n    fn resume(self: Pin<&mut Self>, r: () + Self::Resume) -> Self::Yield + Self::Output {\n        let state = self.project().state;\n        match state {\n            State::Done => { panic!() }\n            State::Iter => match self.project().iter.next() {\n                None => { *state = State::Done; None }\n                Some(item) => { *state = State::Call(f(item)); self.resume(()) }\n            }\n            State::Call(c) => match c.resume(r) {\n                item: B::Output => { *state = State::Iter; Some(item) }\n                y => { y }\n            }\n        }\n    }\n} \n```", "```\ngen do {\n    for do item in /* ... */ {\n        yield f(item).do;\n    }\n} \n```", "```\nhandle /* ... */ {\n    yield(resume, item) => handle f(item) {\n        eff(resume, x) => { resume(eff(x)) }\n        return(x) => { resume(yield(x)) }\n    }\n    eff(resume, x) => { resume(eff(x)) }\n    return(x) => { x }\n} \n```"]