<!--yml

分类：未分类

日期：2024-05-27 14:26:26

-->

# blog/entries/parallelising_hnsw.md at main · GavinMendelGleason/blog · GitHub

> 来源：[`github.com/GavinMendelGleason/blog/blob/main/entries/parallelising_hnsw.md`](https://github.com/GavinMendelGleason/blog/blob/main/entries/parallelising_hnsw.md)

HNSW（Hierarchical Navigable Small World graphs）是在一篇极好且非常易读的论文中引入的[Yu A. Malkov, D. A. Yashunin](https://arxiv.org/abs/1603.09320)，这篇论文产生了许多流行向量数据库核心中的实现。

HNSW 是一种在数据集中搜索与给定查询向量*接近*的向量的方法。HNSW 的基本思想是制作一系列接近图，这些图被组织成一个堆栈，允许我们随着接近越来越近的邻域而缩小范围。

HNSW 的顶层具有相对较少的元素，我们可以贪心地快速在这一层中找到我们的最佳匹配，然后向下钻取到下一层。每一层下来都是数量级更大，但包含了上层的所有点。在这个过程中，我们可以对一个更接近的替代方案进行更深入的探索，并向下再钻取一层。

最后，当我们到达底部时，我们在附近搜索一下候选对象，并最终得到一个按距离排序的候选对象的优先队列。

HNSW 方法本质上是概率性的。我们尝试通过随机选择候选对象来匹配，希望通过超级节点之间的相当良好连接，我们不会远离我们本地最小值的匹配。

从增量索引的角度来看，这使得这种结构非常吸引人。我们只需掷骰子来确定我们首先插入的层级，采用一种将所有内容放入最低层的分布，并逐渐将其放入以对数方式递增的更高层的方式。希望这样做，随着新向量进入系统，我们将它们随机地提升为树的超级节点以进行路由，这应该是一种自我平衡的过程。

这种创建分层接近图的方法显著减少了必须在添加新元素时进行完全距离计算所需的计算量。当向量数量很大时，如嵌入中存在的大向量，向量距离计算可能会非常昂贵。

## 并行化该方法

[](#parallelising-the-approach)

Malkov, Yashunin 论文中提出的算法对并行化不太适用。它依赖于先前构建的索引来搜索优良的邻居。在并行化时，如果简单地进行并行化（正如作者所发现的那样），资源之间可能存在很多争用的机会。

但是，如果我们有大量同时添加的向量批处理作业，则可以使用并行方法更快地构建索引。这可以与上述增量方法很好地配合。此外，我们还可以考虑混合增量批处理作业，该作业介于两种方法之间。

### 逐层构建

[](#逐层构建)

最简单的批处理并行方法假设我们正在*从无到有*地创建一个索引，逐层构建 HNSW。

我们首先根据输入索引数据*N*选择层数。这可以通过计算以邻域中的元素数量为基数的 M 的对数来完成。

接下来，我们将输入分成重叠的片段，每个片段包括长度为`M^i`的数据前缀，其中`i`表示层级，从`i=0`开始。在每一层，我们使用单层生成方法。

按层生成方法更加适合并行处理，特别是随着层大小的增加。但是，它也更加敏感于数据被摄取的顺序。因此，必须确保输入批处理的随机化，否则可能会得到一个构造不良的层。

（生锈的）伪代码可以写为：

```
let n = input.len();
let layer_count = input.log(n, M);
let layers = Vec::new();
for i in 0..layer_count {
  let size = M.pow(i);
  layer = generate_single_layer(layers, input[0..size])
  layers.push(layer)
}
```

此单层生成包括以下步骤：

1.  并行地，对该层中的所有向量进行迭代，寻找它们在上一层中的最接近匹配项。

1.  根据这些超邻域划分集合。如果我们是第一层构建的，这只是一个分区。

1.  逐个分区节点遍历，从该分区和下一个最佳分区，以及接下来的下一个最佳分区中选择候选邻居，按指数衰减的概率。将此截断为邻域大小（M）。这将构建此节点的初始邻域距离集。

1.  遍历每个节点并使邻域成为双向的（除非因为我们的距离超出了邻域最大大小的最坏情况而被驱逐）。

1.  对于每个节点，可以并行地将邻域写入邻域向量。这可以并行进行，因为每个邻域是独立的且大小固定。

不幸的是，上述算法可能会使一些东西无法到达。我们发现在小数据集上，召回率相当高，通常超过 0.999，但一旦达到数百万，该算法可能会使向量变成孤立的，并且召回率可能会下降至 0.90 以下（取决于搜索队列的大小）。

幸运的是，有一种处理滞留者的策略，使用以下算法：

1.  从零层开始，向上进行，找到所有与超节点断开连接或距离较远的点。

1.  将这些分段为邻域，并选择一个代表性的超节点进行提升，然后将其添加到上一层中。

1.  对上一层重复此过程。

使用此策略可确保所有向量都可通过*某些*路径进行路由，尽管贪婪路由可能导致一些召回损失。

搜索机制与 HNSW 完全相同，只是我们不需要构建所有的层。我们只需要在到达已构建的最后一层时停止搜索。这样一来，我们就可以利用上面层的预先存在的路由来构建邻域。

### 逐步扩展索引

[](#incrementally-extending-the-index)

从零开始构建并不是你想要在实践中构建索引的唯一方式。HNSW 算法的一个重要优势是其增量性质。实际上，我们可以只需重复使用原始算法来扩展结构，它也可以完美地工作。

然而，还有另一种常见的操作模式，即批量更新——我们进行插入、更新和删除操作。

我们可以在两种算法之间创建一种折中方案，其中两种算法都是极端情况，具体如下：

1.  从由邻域大小 M 定义的指数分布中抽样，共抽样 N 次，其中 N 是新向量的数量。创建这些箱的计数，并将其用作向量每层的前缀计数。

1.  使用上述 generate_layer 算法中的前缀（如果存在）创建任何新层（高于之前的层）。

1.  使用上面的 generate_layer 算法的修改版本，仅为新节点执行所有步骤。

1.  将新节点和新邻域追加到现有层的末尾。

HNSW 创建了一种非常好的索引结构，但构建方法不需要采取渐进式方法。完全可以分批执行步骤，从而能够利用更大的并行性。
