<!--yml

分类：未分类

日期：2024-05-27 15:08:37

-->

# 软件测试的两面：检查与探索 | 敏捷连接

> 来源：[https://www.agileconnection.com/article/two-sides-software-testing-checking-and-exploring](https://www.agileconnection.com/article/two-sides-software-testing-checking-and-exploring)

许多年前，在一次会议的走廊交谈中，一位测试经理和我讨论了我们各自的测试方法。

“如果他们不能告诉我软件应该做什么，我就无法测试它，”测试经理弗朗西娜皱着眉说道。“所以，我告诉他们我不会开始测试，直到他们提供详细的需求文档。”

我的眉毛突然拱起。当时，我正在一家硅谷的软件供应商工作，他们制作消费类应用程序。如果我等待全面的规格说明才开始测试，我将永远等不到。而且，我会因为未能对项目做出有意义的贡献而被解雇。我大致说了这样的话，弗朗西娜只是摇了摇头。她无法想象没有详细的规格说明。我无法想象在没有文档的情况下才开始项目。

无法看到彼此观点的一方，我们互相祝对方有个愉快的一天，然后各自朝不同的方向走去。

**永恒的激烈辩论**

那次走廊谈话代表了测试界一个熟悉的辩论：良好的测试是否涉及根据系统的需求或规格系统性地执行一套全面的脚本测试？或者，测试是否应该采用探索性方法来探索风险？对这些问题的答案历来分裂了测试界。这场辩论有时变得非常激烈，双方互相指责对方采取的不负责任的做法增加了风险，降低了质量。

在过去，我坚定地站在使用探索性方法的一边。在我的大部分职业生涯中，我为偏爱轻量级文档的组织工作，因此我们通常不会制作详细的测试脚本。即使那些组织想要厚厚的步骤详细测试用例册，我也同意詹姆斯·巴赫的观点，认为坚持测试脚本就像玩二十个问题游戏，你必须提前问出所有问题。

然而，随着我开始与重视各种测试形式的敏捷团队合作，我对这场辩论的看法在过去的几年里发生了变化。我意识到，关于“好的测试”是预先定义的、详细的测试脚本还是探索性测试的旧讨论就像是在盐与胡椒、胶水与订书钉、皮带与吊带之间展开较量。

这是一个伪问题，也是一个无意义的辩论。

**检查**

像大多数敏捷团队一样，我工作的团队使用轻量级故事作为对需求进行讨论的占位符。团队在准备实施故事时进行讨论。在那时，团队会捕获有关期望和验收标准的详细信息。在我们称故事为“完成”之前，我们需要检查实施的故事是否符合产品所有者的意图。

回想起我和弗朗辛多年前的对话，我仍然能听到她的话：“直到他们告诉我软件应该做什么，我才能测试它。”

如果我们稍微重新构想一下这个说法，我们会得到：“直到他们告诉我软件应该做什么，我才能检查它是否实现了。”这是有道理的。在我们能够实施和检查产品所有者期望的软件之前，我们必须知道他们的期望，因此我们需要讨论用户故事以获得对期望的共享理解。

一些敏捷团队已经采用了在具体示例中捕获这些讨论结果的做法。例如：

假设我没有登录

当我访问编辑个人资料页面时

然后我应该被重定向到登录页面

当我登录时

然后我应该被重定向到编辑个人资料页面

(此示例采用了行为驱动开发（BDD）社区推广的Given/When/Then风格，并与Cucumber等BDD工具相关联。)

您可能会注意到，当我们以此类期望的具体示例形式捕获验收标准时，它们看起来很像脚本化测试。我们也像脚本化测试一样使用它们；我们不仅在首次发布功能时检查这些期望是否得到满足，还在后续的回归测试中验证系统是否仍然满足这些期望。由于敏捷团队重视快速反馈并且需要频繁运行这些测试，我们自动化这些检查以将回归测试的负担控制在可管理的水平。

当团队采用以测试形式捕获验收标准时，这进一步重新定义了弗朗辛的立场：“除非我们知道我们将如何检查这个功能，否则我们还不知道足够多的信息来构建它。”这是一个微妙但关键的转变，将测试放在首要位置，而不是将其归类为周期结束时的事项。这种转变的结果是，测试不仅与需求相关联；它们成为需求的表达。它们是规范-它们规定了系统的期望行为。一旦自动化，它们就成为可执行的规范。

**探索**

无论我们实现一个给定的故事时有多么小心，只检查故事是否符合期望并不足以确保我们已经覆盖了一切。总是存在我们没有预料到可能导致不良行为的某些条件或交互的风险。

探索性测试——特别是由詹姆斯和乔恩·巴赫定义的基于会话的探索性测试——为我们提供了一种有组织的方式来调查系统，寻找风险和漏洞。作为熟练的测试人员，我们使用测试设计技术和分析技能来进行一个又一个的小实验，利用我们从上一个小实验中发现的信息来指导下一个实验。当我们对系统进行操作时，我们会改变配置、权限和数据。我们执行不同的操作，按不同的顺序执行相同的操作，以及在意想不到的时间执行操作。

在进行过程中，我们会仔细观察是否有迹象表明我们已经碰到了系统无法正确处理的情况。像“ORA-01400: cannot insert NULL”这样的显眼、未处理的异常错误消息就是这样的一个迹象。然而，我们也在寻找潜在问题的小提示，比如反应时间滞后。每一个小小的惊喜都可能指向一个需要进一步调查的潜在风险。

例如，在一个项目中，我在我的探索中发现，一个应该是只读的表单字段实际上是可编辑的。这是一种微小的异常迹象，但它指向了一个更大的问题。该字段代表了用户所属的组。通过改变字段中的值，而不需要系统管理权限，我发现我可以使自己成为管理员。显然，这是一个问题。

如果它保持未被捕获，我们的应用程序将存在一个严重的安全漏洞。

**测试过的 = 检查和探索**

敏捷方法强调在每个迭代或冲刺中至少每月生产完成的功能。在我们称故事“完成”之前，它必须经过测试。

记住弗朗辛和我的对话，考虑我们对测试的不同方法。弗朗辛强调检查；我强调探索。我们的方法是测试方程式的两个方面：

+   检查：系统是否执行其预期的功能？

+   探索：还有其他我们尚未考虑的风险或漏洞吗？

事后看来，我可以看到，弗朗辛和我都是对的。而且，我们两个都错了。我们每个人都确定了测试的一个重要方面，但我们都没有看到整个画面。为了有足够的信息来声明一个故事“完成”，我们必须检查它并探索它。测试的两个方面——检查和探索——对于发布高质量的软件至关重要。

***附加资源***
