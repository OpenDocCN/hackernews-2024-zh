- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:35:23'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Stream to chromecast with resolved, vlc and bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://linderud.dev/blog/stream-to-chromecast-with-resolved-vlc-and-bash/](https://linderud.dev/blog/stream-to-chromecast-with-resolved-vlc-and-bash/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Chromecast is one of those devices I just generally use a lot. They are small
    practical and enables me to stream video or music to my TV from multiple devices.
    But it also requires you to have a supported browser or video player. This is
    obviously a bit boring.
  prefs: []
  type: TYPE_NORMAL
- en: There has been multiple command line chromecast streamers through the years.
    But their ffmpeg usage has been shoddy at best with no hardware decoding support
    and usually quite bad implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using these tools I have wound up with two bash scripts that pipes
    together a command line program to stream towards chromecasts and it works surprisingly
    well.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of this is how we stream towards the chromecast. This is easily
    solveable with `vlc` luckily. You can just open `vlc file://....`, select `Playback
    -> Renderer` and generally find the correct chromecast there. But this is boring.
    We have to manually open the GUI and select the device!
  prefs: []
  type: TYPE_NORMAL
- en: I can peak into the app on my phone and learn that the local IP of my chromecast
    is `192.168.1.231`. With `clvc` you can also pass `sout` and `sout-chromecast-ip`
    to auto-start a headless VLC players that will connect towards your chromecast.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This works really well on it’s own. You can also pipe `yt-dlp` into `clvc` and
    support most media websites like youtube or twitch. This allows you to quickly
    write up some scripts to stream from these sites and is fairly flexible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is one issue though, that IP is not static. If the chromecast reconnects
    to the network it might change it’s IP, and I’m never going to bother setting
    a static device.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily chromecast announces itself over [DNS Service Discovery](http://www.dns-sd.org/)
    which allows devices to announce themself over the network through DNS names.
    To query for these devices we will be using `systemd-resolved` and `resolvectl`.
    You can probably use another DNS query tool, but `systemd-resolved` also supports
    `mDNS` which is useful for finding services on the network.
  prefs: []
  type: TYPE_NORMAL
- en: First you need to enable `systemd-resolved` through `systemctl enable --now
    systemd-resolved`. Your mileage might wary but in some distributions this comes
    enabled by default. It’s also important to note that you don’t need to make `resolved`
    your default stub resolver for any of this to work.
  prefs: []
  type: TYPE_NORMAL
- en: If you do read the [`resolvctl(1)` man page](https://man.archlinux.org/man/resolvectl.1#COMMANDS)
    you will see it has native support for dns-sd through `resolvectl service`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However I have not gotten this to work as it seems like it will try to send
    a combined DNS query to your network DNS resolver, and this doesn’t seem supported
    depending on the router you have. So we have to implement this ourself. So we
    will be using the `PTR+SRV+TXT` process as outlined in [RFC6763](https://www.ietf.org/rfc/rfc6763.txt).
  prefs: []
  type: TYPE_NORMAL
- en: To find available chromecasts on the network we’ll first query for PTR records
    on `_googlecast._tcp.local`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here I see one Chromecast. Then we need to query for the service record it self,
    SRV is defined as part of [RFC2782](https://tools.ietf.org/html/rfc2782).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And finally we can just query the TXT record of the service for the IP of the
    device itself, which is the correct IP we started out with :)!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To make this easier in the future we can easily parse this space limited output
    with `read` in a bash script^.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And we can make our `chromecast` script as well which calls `dns-sd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this we have a neat way to stream web content to our chromecast without
    having to go through a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bonus content: qutebrowser'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you, like me, enjoy qutebrowser but find the lack of chromecast support annoying
    we can resolve that with the script above.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the current chromecast script from qutebrowser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/qutebrowser/qutebrowser/blob/main/misc/userscripts/cast](https://github.com/qutebrowser/qutebrowser/blob/main/misc/userscripts/cast)'
  prefs: []
  type: TYPE_NORMAL
- en: And apply the diff here, which just removes code we don’t really need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then add a keybind into `config.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Ta-da, chromecast support with our script.
  prefs: []
  type: TYPE_NORMAL
- en: '[Back to posts](https://linderud.dev/blog/)'
  prefs: []
  type: TYPE_NORMAL
