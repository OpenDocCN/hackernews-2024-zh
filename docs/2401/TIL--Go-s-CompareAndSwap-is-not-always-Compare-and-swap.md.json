["```\nfunc CAS(ptr *T, old, new T) bool {\n    if (*ptr != old) {\n        return false\n    }\n    *ptr = new\n    return true\n}\n```", "```\nTEXT ·Cas64(SB), NOSPLIT, $0-25\n  MOVQ  ptr+0(FP), BX\n  MOVQ  old+8(FP), AX\n  MOVQ  new+16(FP), CX\n  LOCK\n  CMPXCHGQ  CX, 0(BX)\n  SETEQ ret+24(FP)\n  RET \n```", "```\nTEXT ·Cas64(SB), NOSPLIT, $0-25\n  MOVD  ptr+0(FP), R0\n  MOVD  old+8(FP), R1\n  MOVD  new+16(FP), R2\n\n// Check support for LSE atomics\n  MOVBU internal∕cpu·ARM64+const_offsetARM64HasATOMICS(SB), R4\n  CBZ   R4, load_store_loop\n\n// LSE supported, use CASAL\n  MOVD  R1, R3\n  CASALD  R3, (R0), R2\n  CMP   R1, R3\n  CSET  EQ, R0\n  MOVB  R0, ret+24(FP)\n  RET\n\n// LSE not supported, use LDAXR/STLXR\nload_store_loop:\n  LDAXR (R0), R3\n  CMP R1, R3\n  BNE ok\n  STLXR R2, (R0), R3\n  CBNZ  R3, load_store_loop\nok:\n  CSET  EQ, R0\n  MOVB  R0, ret+24(FP)\n  RET \n```", "```\nTEXT ·Cas64(SB), NOSPLIT, $0-25\n  MOV ptr+0(FP), A0\n  MOV old+8(FP), A1\n  MOV new+16(FP), A2\ncas_again:\n  LRD  (A0), A3\n  BNE  A3, A1, cas_fail\n  SCD  A2, (A0), A4\n  BNE  A4, ZERO, cas_again\n  MOV  $1, A0\n  MOVB A0, ret+24(FP)\n  RET\ncas_fail:\n  MOVB  ZERO, ret+24(FP)\n  RET \n```"]