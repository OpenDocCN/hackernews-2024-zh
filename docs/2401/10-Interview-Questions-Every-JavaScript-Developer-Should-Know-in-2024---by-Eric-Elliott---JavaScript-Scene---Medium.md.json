["```\nconst createSecret = (secret) => {\n  return {\n    getSecret: () => secret,\n    setSecret: (newSecret) => {\n      secret = newSecret;\n    },\n  };\n};\n\nconst mySecret = createSecret(\"My secret\");\nconsole.log(mySecret.getSecret()); // My secret\n\nmySecret.setSecret(\"My new secret\");\nconsole.log(mySecret.getSecret()); // My new secret\n```", "```\n// Data privacy\nconst createCounter = () => {\n  let count = 0;\n  return {\n    increment: () => ++count,\n    decrement: () => --count,\n    getCount: () => count,\n  };\n};\n```", "```\n // A curried function takes multiple arguments one at a time.\nconst add = (a) => (b) => a + b;\n\n// A partial application is a function that has been applied to some,\n// but not yet all of its arguments.\nconst increment = add(1); // partial application\n\nincrement(2); // 3\n```", "```\nconst compose = (f, g) => (x) => f(g(x));\n\nconst g = (num) => num + 1;\nconst f = (num) => num * 2;\n\nconst h = compose(f, g);\n\nh(20); // 42\n```", "```\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"Success!\");\n    // You could also reject with a new error on failure.\n  }, 1000);\n});\n\npromise\n  .then((value) => {\n    console.log(value); // Success!\n  })\n  .catch((error) => {\n    console.log(error);\n  });\n```", "```\nconst processData = async () => {\n  try {\n    const data = await fetchData(); // Waits until the Promise is resolved\n    console.log(\"Processed:\", data); // Process and display the data\n  } catch (error) {\n    console.error(\"Error:\", error); // Handle any errors\n  }\n};\n```", "```\ninterface User {\n  id: number;\n  name: string;\n}\n\ntype GetUser = (userId: number) => User;\n\nconst getUser: GetUser = (userId) => {\n  // Fetch user data from a database or API\n  return {\n    id: userId,\n    name: \"John Doe\",\n  };\n};\n```", "```\n<!-- Defining a simple Web Component -->\n<script>\n  // Define a class that extends HTMLElement\n  class SimpleGreeting extends HTMLElement {\n    // Define a constructor that attaches a shadow root\n    constructor() {\n      super();\n      const shadowRoot = this.attachShadow({ mode: \"open\" });\n      // Use a template literal for the shadow root's innerHTML\n      shadowRoot.innerHTML = `\n        <style>\n          /* Style the web component using a style tag */\n          p {\n            font-family: Arial, sans-serif;\n            color: var(--color, black); /* Use a CSS variable for the color */\n          }\n        </style>\n        <!-- The <slot> element is a placeholder for user-provided content. -->\n        <!-- If no content is provided, it displays its own default content. -->\n        <p><slot>Hello, Web Components!</slot></p>\n      `;\n    }\n\n    // Define a static getter for the observed attributes\n    static get observedAttributes() {\n      return [\"color\"]; // Observe the color attribute\n    }\n\n    // Define a callback for when an attribute changes\n    attributeChangedCallback(name, oldValue, newValue) {\n      // Update the CSS variable when the color attribute changes\n      if (name === \"color\") {\n        this.style.setProperty(\"--color\", newValue);\n      }\n    }\n  }\n\n  // Register the custom element with a tag name\n  customElements.define(\"simple-greeting\", SimpleGreeting);\n</script>\n\n<!-- Using the Web Component -->\n<!-- Pass a custom greeting message using the slot -->\n<simple-greeting>Hello, reader!</simple-greeting>\n<!-- Pass a custom color using the attribute -->\n<simple-greeting color=\"blue\">Hello, World!</simple-greeting>\n```", "```\nimport React, { useState } from \"react\";\n\nconst ClickCounter = () => {\n  const [count, setCount] = useState(0); // Initialize count to 0\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount((count) => count + 1)}>Click me</button>\n    </div>\n  );\n};\n\nexport default ClickCounter;\n```"]