["```\ncreate table txn_iso (ival int);\ninsert into txn_iso (ival) values(1); \n```", "```\nimport { Pool, Transaction } from 'https://deno.land/x/postgres/mod.ts';\n\nconst pool = new Pool({\n  user: 'postgres',\n  hostname: 'localhost',\n  database: 'postgres',\n  port: 5433,\n  password: 'test1234',\n}, 10);\n\nasync function runQuery(\n  txn: Transaction,\n  query: string,\n  args: (string | number)[],\n  beforeMsg: string,\n  afterMsg: (result: any) => string\n) {\n  console.log(beforeMsg);\n  const result = await txn.queryObject(query, args);\n  console.log(afterMsg(result));\n}\n\nasync function readTransaction() {\n  const query = 'select ival from txn_iso';\n  const printResult = (result: any) => `Read result: ${result.rows[0].ival}`;\n\n  const client = await pool.connect();\n  const txn = client.createTransaction();\n\n  await txn.begin();\n\n  await runQuery(txn, query, [], 'Executing first read...',  printResult);\n\n  // Wait for concurrent write to occur\n  await new Promise(resolve => setTimeout(resolve, 2000));\n\n  await runQuery(txn, query, [], 'Executing second read...', printResult);\n\n  await txn.commit();\n\n  await client.release();\n}\n\nasync function writeTransaction() {\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  const client = await pool.connect();\n  const txn = client.createTransaction();\n\n  await txn.begin();\n\n  const updateVal = Math.floor(Math.random() * 1000);\n  const updateMsgBefore = `Updating ival to ${updateVal}...`;\n  const query = 'update txn_iso set ival = $1';\n  await runQuery(txn, query, [updateVal], updateMsgBefore, () => 'ival updated');\n\n  await txn.commit();\n\n  await client.release();\n}\n\nawait Promise.allSettled([readTransaction(), writeTransaction()]); \n```", "```\nExecuting first read...\nRead result: 839\nUpdating ival to 79...\nival updated\nExecuting second read...\nRead result: 79 \n```", "```\ninterface BalanceRepository {\n  getBalance(txn: Transaction): Promise<number>;\n  updateBalance(txn: Transaction, amount: number): Promise<void>;\n}\n\nasync function checkOverdraftProtection(txn: Transaction, balanceRepo: BalanceRepository, amount: number) {\n  const balance =  await balanceRepo.getBalance(txn);\n  if (balance >= amount) {\n    return;\n  }\n\n  balanceRepo.updateBalance(txn, balance + 100);\n}\n\nasync function applyFundTransfer(txn: Transaction, balanceRepo: BalanceRepository, amount: number) {\n  const balance = await balanceRepo.getBalance(txn);\n  if (balance < amount) {\n    console.error(\"Insufficient funds\");\n    return;\n  }\n\n  await balanceRepo.updateBalance(txn, balance - amount);\n}\n\nasync function transferFunds(balanceRepo: BalanceRepository, amount: number) {\n  const client = await pool.connect();\n  const txn = client.createTransaction();\n\n  await txn.begin();\n\n  await checkOverdraftProtection(txn, balanceRepo, amount);\n  await applyFundTransfer(txn, balanceRepo, amount);\n\n  await txn.commit();\n\n  await client.release();\n}\n\nconst protectedBalanceRepo = {\n  balance: 90,\n  async getBalance(txn: Transaction) {\n    return this.balance;\n  },\n  async updateBalance(txn: Transaction, amount: number) {\n    this.balance = amount;\n  }\n}\n\nawait transferFunds(protectedBalanceRepo, 100);\nconsole.assert(protectedBalanceRepo.balance === 90); \n```", "```\nconst concurrentWriteRepo = {\n  currBalance: 0,\n  balances: [100, 90],\n  async getBalance(txn: Transaction) {\n    return this.balances[this.currBalance++];\n  },\n  async updateBalance(txn: Transaction, amount: number) {\n  }\n}\n\n...\n\nawait transferFunds(concurrentWriteRepo, 100); \n```", "```\nasync function transferFunds(balanceRepo: BalanceRepository, amount: number) {\n  const client = await pool.connect();\n  const txn = client.createTransaction();\n\n  await txn.begin();\n\n  const balance = await balanceRepo.getBalance(txn);\n  const protectedBalance = await checkOverdraftProtection(txn, balance, balanceRepo, amount);\n  await applyFundTransfer(txn, protectedBalance, balanceRepo, amount);\n\n  await txn.commit();\n\n  await client.release();\n} \n```", "```\ncreate table accounts (balance int);\ninsert into accounts (balance) values (100); \n```", "```\nasync function transferFunds(balanceRepo: BalanceRepository, amount: number, writeDelay?: number) {\n  const client = await pool.connect();\n  const txn = client.createTransaction();\n\n  await txn.begin();\n\n  const balance = await balanceRepo.getBalance(txn);\n\n  if (writeDelay) {\n    await new Promise(resolve => setTimeout(resolve, writeDelay));\n  }\n\n  const protectedBalance = await checkOverdraftProtection(txn, balance, balanceRepo, amount);\n  await applyFundTransfer(txn, protectedBalance, balanceRepo, amount);\n\n  await txn.commit();\n\n  await client.release();\n}\n\nconst postgresBalanceRepo = {\n  async getBalance(txn: Transaction): Promise<number> {\n    const result = await txn.queryObject('select balance from accounts');\n    return result.rows[0].balance;\n  },\n  async updateBalance(txn: Transaction, amount: number) {\n    await txn.queryObject('update accounts set balance = $1', [amount]);\n  }\n}\n\nasync function runInTransaction<T>(f: (txn: Transaction) => Promise<T>) {\n  const conn = await pool.connect()\n  const txn = conn.createTransaction()\n  await txn.begin();\n\n  const result = await f(txn);\n\n  await txn.commit();\n  await conn.release();\n\n  return result\n}\n\n// Setup\nawait runInTransaction((txn) => {\n  return postgresBalanceRepo.updateBalance(txn, 100);\n});\n\n// Run two concurrent fund transfers\nawait Promise.allSettled([transferFunds(postgresBalanceRepo, 80, 2000), transferFunds(postgresBalanceRepo, 60)]);\n\nconst balance = await runInTransaction((txn) => {\n  return postgresBalanceRepo.getBalance(txn)\n});\n\nconsole.assert(balance === 60); \n```", "```\nconst postgresBalanceRepo = {\n  async getBalance(txn: Transaction): Promise<number> {\n    const result = await txn.queryObject('select balance from accounts FOR UPDATE');\n    return result.rows[0].balance;\n  },\n  ...\n} \n```"]