- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:29:06'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Cassette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://cassette-lang.com](https://cassette-lang.com)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Cassette is a small, Lisp-like programming language. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I made Cassette as a simple language for “playful programming”. Playful programming
    is writing something for the sake of writing it. It’s making a software 3D renderer
    or a GIF reader, even though better implementations of those already exist. It’s
    making generative art programs and drawing them with a pen plotter. Cassette itself
    is playful programming—there are certainly other scripting languages that may
    be better for personal projects like these, but this one is mine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the design goals of Cassette:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplicity over efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Few dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s some future work for Cassette:'
  prefs: []
  type: TYPE_NORMAL
- en: Bignum support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generational garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler & VM optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support other backends (WebAssembly, LLVM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring assignment (v2?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern-based function dispatch (v2?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This project requires a C build toolchain and SDL2. The source code can be found
    [here](https://git.sr.ht/~zjm/Cassette).
  prefs: []
  type: TYPE_NORMAL
- en: Get the project’s dependencies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On macOS with Homebrew, run `brew install llvm git sdl2 sdl2_ttf`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Debian, run `apt install build-essential clang git libsdl2-dev libsdl2-ttf-dev
    libfontconfig-dev`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clone the repo with `git clone https://git.sr.ht/~zjm/Cassette`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make` to build the project. This creates the executable `cassette`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, run `make install` to install the Cassette executable. You can set
    the install folder in the Makefile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try the example with `./cassette test/test.ct`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a little script and run it with `./cassette script.ct`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cassette has two number types, integers and floats. Integers can be written
    in decimal, hexadecimal, or as a character. The normal infix arithmetic operations
    work on numbers, and bitwise operations work on integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Cassette has symbols, which represent an arbitrary value. `true` and `false`
    are symbols. In boolean operations, all values are truthy except `false` and `nil`.
    Comparison operators only work on numbers, but equality operators work on any
    type. The `and` and `or` operators are short-circuiting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Strings are UTF-8 encoded binaries. You can find the length of a string, concatenate
    two binaries, and test if one string or byte is present in another string. Binaries
    also represent other arbitrary byte sequences, such as the contents of a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Cassette has Lisp-style cons pairs, which form linked lists. Pairs are formed
    with the `|` operator, and can be used to easily prepend values to a list. `nil`
    is the empty list. You can find the length of a list, concatenate two lists, and
    test if a value is in a list. Lists can be accessed with an integer index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Cassette has tuples, which are fixed-length arrays of values. Tuples are less
    flexible than lists, but use less memory and are a little faster to access. You
    can find the length of a tuple, concatenate two tuples, and test if a value is
    in a tuple. Tuples can be accessed with an integer index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Cassette has maps (a.k.a. dictionaries), which can be written like tuples with
    symbol keys. Map literals can only have symbol keys, but other functions can get
    and set keys of other types. You can find the number of key/value pairs in a map,
    merge two maps, and test if a map contains a key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables are defined with `let`. A `do` block can introduce a new scope, and
    can be used to combine a group of expressions into one. Cassette has lexical scoping.
    A variable must start with a letter or underscore, but may contain any characters
    afterward except for whitespace and these reserved characters: `;,.:()[]{}`. This
    means that if you want to write an infix expression, you must often include space
    around the operator to disambiguate it from its operands.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Cassette has `if`/`else` blocks and `cond` blocks for conditionals. A `cond`
    block will evaluate each predicate until one is true, then evaluate that clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Lambdas can be created with a backslash, argument list, and an arrow. The `def`
    syntax is syntactic sugar for defining a lambda as a variable, with the distinction
    that `def`-declared functions have block scope, so they can be called recursively.
    Functions are called with parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Cassette programs can be split up into different modules, one per file. Modules
    can be imported directly into a file’s scope, or aliased as a map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For more information about Cassette, check out some of these other documents.
    Stay tuned for future articles.
  prefs: []
  type: TYPE_NORMAL
