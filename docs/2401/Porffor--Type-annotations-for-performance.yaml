- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»åˆ«ï¼šæœªåˆ†ç±»
- en: 'date: 2024-05-27 15:16:08'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024å¹´05æœˆ27æ—¥ 15:16:08
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'Porffor: Type annotations for performance'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Porfforï¼šæ€§èƒ½çš„ç±»å‹æ³¨é‡Š
- en: æ¥æºï¼š[https://goose.icu/porffor-types/](https://goose.icu/porffor-types/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://goose.icu/porffor-types/](https://goose.icu/porffor-types/)
- en: My JS engine [Porffor](https://porffor.goose.icu) can now parse TypeScript,
    as I added pluggable parser support which includes Babelâ€™s parser (which can parse
    TS). This itself isnâ€™t that interesting, however I can now use those type annotations
    as compiler hints to optimize!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘çš„JSå¼•æ“[Porffor](https://porffor.goose.icu)ç°åœ¨å¯ä»¥è§£æTypeScriptï¼Œå› ä¸ºæˆ‘æ·»åŠ äº†å¯æ’æ‹”çš„è§£æå™¨æ”¯æŒï¼Œå…¶ä¸­åŒ…æ‹¬Babelçš„è§£æå™¨ï¼ˆå¯ä»¥è§£æTSï¼‰ã€‚è¿™æœ¬èº«å¹¶ä¸é‚£ä¹ˆæœ‰è¶£ï¼Œä½†æˆ‘ç°åœ¨å¯ä»¥å°†è¿™äº›ç±»å‹æ³¨é‡Šç”¨ä½œç¼–è¯‘å™¨æç¤ºæ¥è¿›è¡Œä¼˜åŒ–ï¼
- en: Basic example
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åŸºæœ¬ç¤ºä¾‹
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the above JS, Porffor has to do several checks of the type of `a`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºä¸Šé¢çš„JSï¼ŒPorfforå¿…é¡»å¯¹`a`çš„ç±»å‹è¿›è¡Œå‡ æ¬¡æ£€æŸ¥ï¼š
- en: '`if (a) {`'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if (a) {`'
- en: If string, true if non-blank (not `''`)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œå¦‚æœéç©ºï¼Œåˆ™ä¸ºçœŸï¼ˆä¸æ˜¯`''`ï¼‰
- en: If undefined, false
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæœªå®šä¹‰ï¼Œåˆ™ä¸ºå‡
- en: '&mldr;'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '&mldr;'
- en: '**If number, true if not zero**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å¦‚æœæ˜¯æ•°å­—ï¼Œä¸ºçœŸï¼Œå¦‚æœä¸æ˜¯é›¶**'
- en: '`typeof a`'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`typeof a`'
- en: If string, `'string'`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œ`'string'`
- en: If object, `'object'`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ˜¯å¯¹è±¡ï¼Œ`'object'`
- en: '&mldr;'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '&mldr;'
- en: '**If number, `''number''`**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å¦‚æœæ˜¯æ•°å­—ï¼Œ`''number''`**'
- en: I already optimize out types which are completely unused in the file. For example,
    all the string checks are removed if the file has 0 strings used in it. But if
    there were any strings, all string checks remain. Porffor could try to infer the
    type automatically but this is tricky and could break. JIT engines can sometimes
    do this by presuming the type of something once it has been ran with that type
    several times, etc. But since we are compiling AOT and not JIT, we cannot de-opt/undo
    that guess if it becomes wrong - instead we would just crash.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å·²ç»ä¼˜åŒ–äº†æ–‡ä»¶ä¸­å®Œå…¨æœªä½¿ç”¨çš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ–‡ä»¶ä¸­æ²¡æœ‰ä½¿ç”¨å­—ç¬¦ä¸²ï¼Œåˆ™ä¼šåˆ é™¤æ‰€æœ‰å­—ç¬¦ä¸²æ£€æŸ¥ã€‚ä½†å¦‚æœæœ‰ä»»ä½•å­—ç¬¦ä¸²ï¼Œåˆ™æ‰€æœ‰å­—ç¬¦ä¸²æ£€æŸ¥éƒ½å°†ä¿ç•™ã€‚Porfforå¯ä»¥å°è¯•è‡ªåŠ¨æ¨æ–­ç±»å‹ï¼Œä½†è¿™å¾ˆæ£˜æ‰‹ï¼Œå¯èƒ½ä¼šå‡ºé”™ã€‚JITå¼•æ“æœ‰æ—¶å¯ä»¥é€šè¿‡å‡å®šæŸä¸ªä¸œè¥¿çš„ç±»å‹æ¥æ¨æ–­ç±»å‹ï¼Œä¸€æ—¦å®ƒä»¥è¯¥ç±»å‹å¤šæ¬¡è¿è¡Œï¼Œç­‰ç­‰ã€‚ä½†ç”±äºæˆ‘ä»¬æ˜¯AOTç¼–è¯‘è€Œä¸æ˜¯JITï¼Œå¦‚æœç±»å‹çŒœæµ‹å‡ºé”™ï¼Œæˆ‘ä»¬æ— æ³•å–æ¶ˆçŒœæµ‹
    - ç›¸åï¼Œæˆ‘ä»¬å°†ä¼šå´©æºƒã€‚
- en: But we could define the type using type annotations (TS)!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç±»å‹æ³¨é‡Šï¼ˆTSï¼‰å®šä¹‰ç±»å‹ï¼
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have to do **0 checks of the type of `a`**, since we already know it
    at compile-time. This can allow for some big speedups :)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬ä¸å¿…å¯¹`a`çš„ç±»å‹è¿›è¡Œ**ä»»ä½•æ£€æŸ¥**ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ç¼–è¯‘æ—¶å·²ç»çŸ¥é“äº†å®ƒã€‚è¿™å¯ä»¥å®ç°ä¸€äº›å¾ˆå¤§çš„é€Ÿåº¦æå‡ :)
- en: Progressive types
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ¸è¿›ç±»å‹
- en: Porffor does not type check itself. You can use your own (with your own config
    too) if you want that. The input also does not have to be completely typed, allowing
    â€œprogressive typesâ€. Types which exist can help speed things up, and untyped things
    will just be treated regularly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Porfforæœ¬èº«ä¸è¿›è¡Œç±»å‹æ£€æŸ¥ã€‚å¦‚æœä½ æƒ³è¦çš„è¯ï¼Œä½ å¯ä»¥ä½¿ç”¨ä½ è‡ªå·±çš„ï¼ˆè¿˜æœ‰ä½ è‡ªå·±çš„é…ç½®ï¼‰ã€‚è¾“å…¥ä¹Ÿä¸å¿…å®Œå…¨ç±»å‹åŒ–ï¼Œå…è®¸â€œæ¸è¿›ç±»å‹â€ã€‚å­˜åœ¨çš„ç±»å‹å¯ä»¥å¸®åŠ©åŠ å¿«é€Ÿåº¦ï¼Œè€Œæœªç±»å‹åŒ–çš„å†…å®¹å°†è¢«æ­£å¸¸å¤„ç†ã€‚
- en: Benchmark
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åŸºå‡†æµ‹è¯•
- en: 'Iâ€™m using [a basic Brainf&mldr; interpreter I wrote in JS (`bf.js`)](https://github.com/CanadaHonk/porffor/blob/main/bench/bf.js),
    plus [a typed version (`bf.ts`)](https://github.com/CanadaHonk/porffor/blob/main/bench/bf.ts).
    Here are the times running BF which draws the Mandelbrot set, with different commands
    (`porf` = Porffor):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘åœ¨[æˆ‘å†™çš„åŸºæœ¬çš„Brainf&mldr;è§£é‡Šå™¨ï¼ˆ`bf.js`ï¼‰](https://github.com/CanadaHonk/porffor/blob/main/bench/bf.js)ä¸Šä½¿ç”¨äº†åŠ ä¸Š[ä¸€ä¸ªå¸¦ç±»å‹çš„ç‰ˆæœ¬ï¼ˆ`bf.ts`ï¼‰](https://github.com/CanadaHonk/porffor/blob/main/bench/bf.ts)ã€‚è¿™é‡Œæ˜¯è¿è¡Œç»˜åˆ¶æ›¼å¾·å‹ƒç½—é›†çš„BFçš„æ—¶é—´ï¼Œä½¿ç”¨ä¸åŒçš„å‘½ä»¤ï¼ˆ`porf`
    = Porfforï¼‰ï¼š
- en: '`porf bf.js`: 272s'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`porf bf.js`ï¼š272ç§’'
- en: This just runs the JS file regularly, with default options.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åªæ˜¯æ­£å¸¸è¿è¡ŒJSæ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤é€‰é¡¹ã€‚
- en: '`porf bf.ts -parse-types`: 274s'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`porf bf.ts -parse-types`ï¼š274ç§’'
- en: This runs the TS file, but only parses the types without using them for optimization.
    About the same time as regular JS, within error.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¼šè¿è¡ŒTSæ–‡ä»¶ï¼Œä½†ä»…è§£æç±»å‹è€Œä¸ä½¿ç”¨å®ƒä»¬è¿›è¡Œä¼˜åŒ–ã€‚ä¸å¸¸è§„JSå‡ ä¹ç›¸åŒçš„æ—¶é—´ï¼Œæœ‰ä¸€äº›è¯¯å·®ã€‚
- en: '`porf bf.ts -parse-types -opt-types`: 184s'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`porf bf.ts -parse-types -opt-types`ï¼š184ç§’'
- en: '`-opt-types` tells Porffor to use the type annotations as compiler hints. 1.5x
    speedup, just from using types!'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`-opt-types`å‘Šè¯‰Porfforå°†ç±»å‹æ³¨é‡Šç”¨ä½œç¼–è¯‘å™¨æç¤ºã€‚ä»…ä»…é€šè¿‡ä½¿ç”¨ç±»å‹å°±æé€Ÿäº†1.5å€ï¼'
- en: '`porf bf.ts -parse-types -opt-types -valtype=i32`: 84s'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`porf bf.ts -parse-types -opt-types -valtype=i32`ï¼š84ç§’'
- en: '`-valtype=i32` also tells Porffor to use `i32`s (32 bit integers) as `number`
    instead of `f64`s. In the future I plan to add a special type to do this instead
    of changing `number` for everything, but the compiler isnâ€™t that smart yet heh.
    Another 2.2x speedup compared to last, or 3.2x in total!'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`-valtype=i32`ä¹Ÿå‘Šè¯‰Porfforä½¿ç”¨`i32`ï¼ˆ32ä½æ•´æ•°ï¼‰ä½œä¸º`number`ï¼Œè€Œä¸æ˜¯`f64`ã€‚åœ¨æœªæ¥ï¼Œæˆ‘è®¡åˆ’æ·»åŠ ä¸€ä¸ªç‰¹æ®Šç±»å‹æ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼Œè€Œä¸æ˜¯ä¸ºæ‰€æœ‰å†…å®¹æ›´æ”¹`number`ï¼Œä½†ç¼–è¯‘å™¨è¿˜ä¸å¤Ÿæ™ºèƒ½å‘¢ã€‚ä¸ä¸Šæ¬¡ç›¸æ¯”ï¼Œåˆæé€Ÿäº†2.2å€ï¼Œæ€»å…±æé€Ÿäº†3.2å€ï¼'
- en: '`porf bf.ts -parse-types -opt-types -valtype=i32 -funsafe-zero-proto-checks=charcodeat`:
    67s'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`porf bf.ts -parse-types -opt-types -valtype=i32 -funsafe-zero-proto-checks=charcodeat`ï¼š67ç§’'
- en: '`-funsafe-zero-proto-checks=charcodeat` additionally informs the compiler to
    do no input out of bounds/etc checks for `String.prototype.charCodeAt`. In the
    future, this should also be able to be automatically detected and done for you.
    Mild 1.3x speedup compared to previously, resulting in 4x compared to original.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`-funsafe-zero-proto-checks=charcodeat` è¿˜å‘Šè¯‰ç¼–è¯‘å™¨ä¸å¯¹ `String.prototype.charCodeAt`
    è¿›è¡Œä»»ä½•è¾“å…¥è¶…å‡ºç•Œé™ç­‰æ£€æŸ¥ã€‚åœ¨æœªæ¥ï¼Œè¿™ä¹Ÿåº”è¯¥èƒ½å¤Ÿè¢«è‡ªåŠ¨æ£€æµ‹å¹¶æ‰§è¡Œã€‚ä¸ä»¥å‰ç›¸æ¯”ï¼Œè½»å¾®çš„1.3å€åŠ é€Ÿï¼Œå¯¼è‡´ç›¸å¯¹äºåŸå§‹å€¼çš„4å€ã€‚'
- en: '`node bf.js`: 66s'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`node bf.js`: 66ç§’'
- en: For comparison, Node running the same JS file. Obviously, Node is JIT compiled
    so has a big advantage compared to compiling AOT to bytecode. Yet, we still roughly
    match it with the right options! ğŸš€
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæ¯”è¾ƒï¼ŒNode è¿è¡Œç›¸åŒçš„ JS æ–‡ä»¶ã€‚æ˜¾ç„¶ï¼ŒNode æ˜¯ JIT ç¼–è¯‘çš„ï¼Œå› æ­¤ä¸ç¼–è¯‘ AOT åˆ°å­—èŠ‚ç ç›¸æ¯”å…·æœ‰å¾ˆå¤§çš„ä¼˜åŠ¿ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä»ç„¶ä½¿ç”¨æ­£ç¡®çš„é€‰é¡¹å¤§è‡´ä¸å…¶åŒ¹é…ï¼
    ğŸš€
- en: '`quickjs bf.js`: 1812s'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`quickjs bf.js`: 1812ç§’'
- en: For comparison, a traditional interpreter running the same benchmark.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæ¯”è¾ƒï¼Œä¸€ä¸ªä¼ ç»Ÿçš„è§£é‡Šå™¨è¿è¡Œç›¸åŒçš„åŸºå‡†æµ‹è¯•ã€‚
- en: Conclusion
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: The best part of this for me is that [the main diff for this feature was small,
    only +131 -25](https://github.com/CanadaHonk/porffor/commit/a6a92e01ac1e09383f5c3f24e55f2648ff714b7a),
    and only took me ~an evening to do; thanks to the great foundation from [the rewrite](/porffor-rewrite/).
    Please note both regular JS and typed will likely speedup even more in the near
    future! This is just today. I havenâ€™t compared to many other engines as Iâ€™m saving
    that for a later post when Iâ€™ve done more benchmarking and testing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹æˆ‘æ¥è¯´æœ€å¥½çš„éƒ¨åˆ†æ˜¯ï¼Œ[è¿™ä¸ªåŠŸèƒ½çš„ä¸»è¦å·®å¼‚å¾ˆå°ï¼Œåªæœ‰ +131 -25](https://github.com/CanadaHonk/porffor/commit/a6a92e01ac1e09383f5c3f24e55f2648ff714b7a)ï¼Œè€Œä¸”åªèŠ±äº†æˆ‘å¤§çº¦ä¸€ä¸ªæ™šä¸Šçš„æ—¶é—´æ¥å®Œæˆï¼›æ„Ÿè°¢[é‡å†™](/porffor-rewrite/)æä¾›çš„è‰¯å¥½åŸºç¡€ã€‚è¯·æ³¨æ„ï¼Œå¸¸è§„
    JS å’Œç±»å‹åŒ– JS å¾ˆå¯èƒ½åœ¨ä¸ä¹…çš„å°†æ¥ä¼šæ›´å¿«ï¼è¿™åªæ˜¯ä»Šå¤©ã€‚æˆ‘è¿˜æ²¡æœ‰ä¸è®¸å¤šå…¶ä»–å¼•æ“è¿›è¡Œæ¯”è¾ƒï¼Œå› ä¸ºæˆ‘æŠŠå®ƒç•™åˆ°äº†ä»¥åï¼Œå½“æˆ‘åšæ›´å¤šçš„åŸºå‡†æµ‹è¯•å’Œæµ‹è¯•æ—¶ã€‚
- en: 'Also for comedic relief, this makes the full description of Porffor even more
    complicated:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å¢åŠ å–œå‰§æ•ˆæœï¼Œè¿™ä½¿å¾— Porffor çš„å®Œæ•´æè¿°å˜å¾—æ›´åŠ å¤æ‚ï¼š
- en: A from-scratch experimental AOT optimizing JS/TS -> Wasm/C engine/compiler/runtime
    in JS
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªä»é›¶å¼€å§‹çš„å®éªŒæ€§çš„ AOT ä¼˜åŒ– JS/TS -> Wasm/C å¼•æ“/ç¼–è¯‘å™¨/è¿è¡Œæ—¶åœ¨ JS ä¸­
- en: Thanks for reading! :)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: æ„Ÿè°¢é˜…è¯»ï¼ :)
