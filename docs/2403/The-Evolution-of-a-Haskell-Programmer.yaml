- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:40:35'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: The Evolution of a Haskell Programmer
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://pages.cpsc.ucalgary.ca/~robin/class/449/Evolution.htm](https://pages.cpsc.ucalgary.ca/~robin/class/449/Evolution.htm)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Evolution of a <it>Haskell</it> Programmer
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fritz Ruehr, Willamette University
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: Freshman Haskell programmer
  id: totrans-split-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-9
  prefs: []
  type: TYPE_PRE
- en: Sophomore Haskell programmer, at MIT
  id: totrans-split-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (studied Scheme as a freshman)
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-12
  prefs: []
  type: TYPE_PRE
- en: Junior Haskell programmer
  id: totrans-split-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (beginning Peano player)
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
- en: Another junior Haskell programmer
  id: totrans-split-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (read that n+k patterns are a disgusting part of Haskell
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: '[[1]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: and joined the Ban n+k patterns-movement
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: '[[2]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
- en: Senior Haskell programmer
  id: totrans-split-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (voted for   ~~Nixon~~   ~~Buchanan~~   Bush leans right)
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
- en: Another senior Haskell programmer
  id: totrans-split-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (voted for   ~~McGovern~~   ~~Biafra~~   Nader leans left)
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
- en: Yet another senior Haskell programmer
  id: totrans-split-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (leaned so far right he came back left again!)
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
- en: Memoizing Haskell programmer
  id: totrans-split-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (takes Ginkgo Biloba daily)
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-34
  prefs: []
  type: TYPE_PRE
- en: ~~Pointless~~ *(ahem) Points-free* Haskell programmer
  id: totrans-split-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (studied at Oxford)
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
- en: Iterative Haskell programmer
  id: totrans-split-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (former Pascal programmer)
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-40
  prefs: []
  type: TYPE_PRE
- en: Iterative one-liner Haskell programmer
  id: totrans-split-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (former APL and C programmer)
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-43
  prefs: []
  type: TYPE_PRE
- en: Accumulating Haskell programmer
  id: totrans-split-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (building up to a quick climax)
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-46
  prefs: []
  type: TYPE_PRE
- en: Continuation-passing Haskell programmer
  id: totrans-split-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (raised RABBITS in early years, then moved to New Jersey)
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-49
  prefs: []
  type: TYPE_PRE
- en: Boy Scout Haskell programmer
  id: totrans-split-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (likes tying knots; always reverent, he
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: belongs to the
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: '*Church of the Least Fixed-Point* [[8]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
- en: Combinatory Haskell programmer
  id: totrans-split-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (eschews variables, if not obfuscation;
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: all this curryings just a phase, though it seldom hinders)
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
- en: List-encoding Haskell programmer
  id: totrans-split-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (prefers to count in unary)
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-split-62
  prefs: []
  type: TYPE_PRE
- en: Interpretive Haskell programmer
  id: totrans-split-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (never met a language he didn't like)
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-split-65
  prefs: []
  type: TYPE_PRE
- en: Static Haskell programmer
  id: totrans-split-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (he does it with class, hes got that fundep Jones!
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: After Thomas Hallgrens Fun with Functional Dependencies
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: '[[7]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-split-71
  prefs: []
  type: TYPE_PRE
- en: Beginning graduate Haskell programmer
  id: totrans-split-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (graduate education tends to liberate one from petty concerns
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: about, e.g., the efficiency of hardware-based integers)
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-split-75
  prefs: []
  type: TYPE_PRE
- en: Origamist Haskell programmer
  id: totrans-split-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (always starts out with the basic Bird fold)
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-split-78
  prefs: []
  type: TYPE_PRE
- en: Cartesianally-inclined Haskell programmer
  id: totrans-split-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (prefers Greek food, avoids the spicy Indian stuff;
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: inspired by Lex Augusteijns Sorting Morphisms
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: '[[3]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-split-84
  prefs: []
  type: TYPE_PRE
- en: Ph.D. Haskell programmer
  id: totrans-split-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (ate so many bananas that his eyes bugged out, now he needs new lenses!)
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-split-87
  prefs: []
  type: TYPE_PRE
- en: Post-doc Haskell programmer
  id: totrans-split-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (from Uustalu, Vene and Pardos Recursion Schemes from Comonads
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
- en: '[[4]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-split-92
  prefs: []
  type: TYPE_PRE
- en: Tenured professor
  id: totrans-split-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (teaching Haskell to freshmen)
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-split-95
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
- en: Background
  id: totrans-split-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On 19 June 2001, at the [OGI PacSoft Tuesday Morning Seminar Series](http://www.cse.ogi.edu/~magnus/SeminarSeries/)
    , [Iavor Diatchki](http://www.cse.ogi.edu/~diatchki/) presented the paper Recursion
    Schemes from Comonads by Uustalu, Vene and Pardo [[4]](https://willamette.edu/~fruehr/haskell/evolution.html#references).
    I attended Iavors excellent presentation and remarked that I found the end of
    the paper rather anti-climactic: after much categorical effort and the definition
    of several generalized recursion combinators, the main examples were the factorial
    and Fibonacci functions. (Of course, I offered no better examples myself, so this
    was rather unfair carping.)'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
- en: Some time later, I came across Iavors "jokes" page, including a funny bit called
    [The Evolution of a Programmer](http://www.cse.ogi.edu/~diatchki/jokes/programmer.html)
    in which the traditional imperative "Hello, world" program is developed through
    several variations, from simple beginnings to a ridiculously complex extreme.
    A moments thought turned up the factorial function as the best functional counterpart
    of "Hello, world". Suddenly the Muse struck and I knew I must write out these
    examples, culminating (well, almost) in the heavily generalized categorical version
    of factorial provided by Uustalu, Vene and Pardo.
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
- en: I suppose this is what youd have to call small-audience humour.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
- en: '**PS:** Ive put all the code into a [better-formatted text file](https://willamette.edu/~fruehr/haskell/evolution.hs)
    for those who might like to experiment with the different variations (you could
    also just cut and paste a section from your browser).'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
- en: '**PPS:** As noted above, Iavor is not the original author of The Evolution
    of a Programmer. A quick web search suggests that there are thousands of copies
    floating around and it appears (unattributed) in humor newsgroups as far back
    as 1995\. But I suspect some version of it goes back much further than that. Of
    course, if anyone does know who wrote the original, please let me know so that
    I may credit them here.'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
- en: But seriously, folks, ...
  id: totrans-split-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On a more serious note, I think that the basic idea of the joke (successive
    variations on a theme, building in complexity) can serve a good pedagogical purpose
    as well as a humorous one. To that end, and for those who may not be familiar
    with all of the ideas represented above, I offer the following comments on the
    variations:'
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
- en: The [first version](https://willamette.edu/~fruehr/haskell/evolution.html#freshman)
    (straight recursion with conditionals) is probably familiar to programmers of
    all stripes; fans of LISP and Scheme will find the [sophomore version](https://willamette.edu/~fruehr/haskell/evolution.html#freshman)
    especially readable, except for the funny spelling of lambda and the absence of
    define (or defun). The use of [patterns](https://willamette.edu/~fruehr/haskell/evolution.html#junior)
    may seem only a slight shift in perspective, but in addition to mirroring mathematical
    notation, patterns encourage the view of data types as initial algebras (or as
    inductively defined).
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of more structural recursion combinators (such as [foldr](https://willamette.edu/~fruehr/haskell/evolution.html#senior-right)
    and [foldl](https://willamette.edu/~fruehr/haskell/evolution.html#senior-left))
    is square in the spirit of functional programming: these higher-order functions
    abstract away from the common details of different instances of recursive definitions,
    recovering the specifics through function arguments. The [points-free](https://willamette.edu/~fruehr/haskell/evolution.html#points-free)
    style (defining functions without explicit reference to their formal parameters)
    can be compelling, but it can also be over-done; here the intent is to foreshadow
    similar usage in some of the later, more stridently algebraic variations.'
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
- en: The [accumulating-parameter](https://willamette.edu/~fruehr/haskell/evolution.html#accumulating)
    version illustrates a traditional technique for speeding up functional code. It
    is the second fastest implementation here, at least as measured in terms of number
    of reductions reported by Hugs, with the [iterative](https://willamette.edu/~fruehr/haskell/evolution.html#iterative)
    versions coming in third. Although the latter run somewhat against the spirit
    of functional programming, they do give the flavor of the functional simulation
    of state as used in denotational semantics or, for that matter, in monads. (Monads
    are woefully un-represented here; I would be grateful if someone could contribute
    a few (progressive) examples in the spirit of the development above.) The [continuation-passing](https://willamette.edu/~fruehr/haskell/evolution.html#continuation)
    version recalls a denotational account of control (the references are to Steeles
    RABBIT compiler for Scheme and the SML/NJ compiler).
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
- en: The [fixed-point version](https://willamette.edu/~fruehr/haskell/evolution.html#boyscout)
    demonstrates that we can isolate recursion in a general Y combinator. The [combinatory](https://willamette.edu/~fruehr/haskell/evolution.html#combinatory)
    version provides an extreme take on the points-free style inspired by Combinatory
    Logic, isolating dependence on variable names to the definitions of a few combinators.
    Of course we could go further, defining the Naturals and Booleans in combinatory
    terms, but note that the predecessor function will be a bit hard to accomodate
    (this is one good justification for algebraic types). Also note that we cannot
    define the Y combinator in terms of the others without running into typing problems
    (due essentially to issues of self-application). Interestingly, this is the fastest
    of all of the implementations, perhaps reflecting the underlying graph reduction
    mechanisms used in the implementation.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The [list-encoded](https://willamette.edu/~fruehr/haskell/evolution.html#listencoding)
    version exploits the simple observation that we can count in unary by using lists
    of arbitrary elements, so that the length of a list encodes a natural number.
    In some sense this idea foreshadows later versions based on recursive type definitions
    for Peanos naturals, since lists of units are isomorphic to naturals. The only
    interesting thing here is that multiplication (numeric product) is seen to arise
    naturally out of combination (Cartesian product) by way of cardinality. Typing
    issues make it hard to express this correspondence as directly as wed like: the
    following definition of listprod would break the definition of the facl function
    due to an occurs-check/infinite type:'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
- en: '`listprod xs ys = [ (x,y) | x<-xs, y<-ys ]`'
  id: totrans-split-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Of course we could also simplify as follows, but only at the expense of obscuring
    the relationship between the two kinds of products:'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
- en: '`listprod xs ys = [ arb | x<-xs, y<-ys ]`'
  id: totrans-split-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The [interpretive](https://willamette.edu/~fruehr/haskell/evolution.html#interpretive)
    version implements a small object language rich enough to express factorial, and
    then implements an interpreter for it based on a simple environment model. Exercises
    along these lines run all through the latter half of the Friedman, Wand and Haynes
    text ([[6]](https://willamette.edu/~fruehr/haskell/evolution.html#references)),
    albeit expressed there in Scheme. We used to get flack from students at [Oberlin](http://www.cs.oberlin.edu/)
    when we made them implement twelve interpreters in a single week-long lab, successively
    exposing more of the implementation by moving the real work from the meta-language
    to the interpreter. This implementation leaves a whole lot on the shoulders of
    the meta-language, corresponding to about Tuesday or Wednesday in their week.
    Industrious readers are invited to implement a compiler for a Squiggol-like language
    of polytypic folds and unfolds, targeting (and simulating) a suitable categorical
    abstract machine (see [[9]](https://willamette.edu/~fruehr/haskell/evolution.html#references)),
    and then to implement factorial in that setting (but don't blame me if it makes
    you late for lunch ...).
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
- en: The [statically-computed](https://willamette.edu/~fruehr/haskell/evolution.html#fundep)
    version uses type classes and *functional dependencies* to facilitate computation
    at compile time (the latter are recent extensions to the Haskell 98 standard by
    Mark Jones, and are available in Hugs and GHC). The same kinds of techniques can
    also be used to encode behaviors more often associated with dependent types and
    polytypic programming, and are thus a topic of much recent interest in the Haskell
    community. The code shown here is based on an account by Thomas Hallgren (see
    [[7]](https://willamette.edu/~fruehr/haskell/evolution.html#references)), extended
    to include factorial. Prolog fans will find the definitions particularly easy
    to read, if a bit backwards.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
- en: The first of the [graduate](https://willamette.edu/~fruehr/haskell/evolution.html#peano)
    versions gets more serious about recursion, defining natural numbers as a recursive
    algebraic datatype and highlighting the difference between iteration and primitive
    recursion. The [origamist](https://willamette.edu/~fruehr/haskell/evolution.html#origami)
    and [cartesian](https://willamette.edu/~fruehr/haskell/evolution.html#cartesian)
    variations take a small step backwards in this regard, as they return to the use
    of internal integer and list types. They serve, however, to introduce anamorphic
    and hylomorphic notions in a more familiar context.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
- en: The [Ph.D](https://willamette.edu/~fruehr/haskell/evolution.html#categorical)
    example employs the categorical style of BMF/Squiggol in a serious way (we could
    actually go a bit further, by using co-products more directly, and thus eliminate
    some of the overt dependence on the internal sums of the data type definition
    mechanism).
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
- en: By the time we arrive at the pice de rsistance, the [comonadic](https://willamette.edu/~fruehr/haskell/evolution.html#comonadic)
    version of Uustalu, Vene and Pardo, we have covered most of the underlying ideas
    and can (hopefully) concentrate better on their specific contributions. The [final](https://willamette.edu/~fruehr/haskell/evolution.html#tenured)
    version, using the Prelude-defined product function and ellipsis notation, is
    how I think the function is most clearly expressed, presuming some knowledge of
    the language and Prelude definitions. (This definition also dates back at least
    to David Turners KRC* language [[5]](https://willamette.edu/~fruehr/haskell/evolution.html#references).)
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
- en: It is comforting to know that the Prelude ultimately uses a recursion combinator
    (foldl', the strict version of foldl) to define product. I guess we can all hope
    to see the day when the Prelude will define gcatamorphic, zygomorphic and paramorphic
    combinators for us, so that factorial can be defined both conveniently *and* with
    greater dignity :) .
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
- en: '* *KRC may or may not be a trademark of Research Software, Ltd.,'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
- en: but you can bet your sweet bippy that* Miranda *is!*
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
- en: Revision history
  id: totrans-split-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Sometime in the 2010s*: corrected the attribution for the *Church of the LFP*
    creed, which is due to Calvin Ostrum (and added a link to an illuminated version;
    see above). Also added a link to a Serbo-Croatian version of this page, although
    I was later told that this kindly-provided service is some sort of click-bait
    scheme. I dont know what to make of all that: if the translation itself is somehow
    horribly wrong, I suppose I could cut the link back out. But perhaps the whole
    incident merely suggests that I am deteriorating into a clueless old fart who
    cant make sense of all these new-fangled Internet scams, which is probably becoming
    more true all the time. (Extra points to anyone who combines Dynamic Logic with
    Denotational Semantics and Fuzzy Logic to develop a system in which to explore
    the notion of propositions becoming true slowly, over time. I can also see potential
    applications to sorities paradoxes involving greying hair ... .)'
  id: totrans-split-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*20 August 01*: added the [interpretive](https://willamette.edu/~fruehr/haskell/evolution.html#interpretive)
    version, based on an environment model of a small object language (no, not in
    *that* sense of object ...). Im thinking about re-arranging the order of the examples,
    so that longer ones that are not part of the main line of development don''t intrude
    so much. I also advertised the page on [the Haskell Caf](http://haskell.org/mailman/listinfo/haskell-cafe)
    mailing list and requested that a link be added to the [Haskell humor page.](http://www.haskell.org/humor)
    Finally, I have an interesting new example in the works that may actually have
    some original research value; more on this soon.'
  id: totrans-split-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*14 August 01 (afternoon)*: added the [combinatory](https://willamette.edu/~fruehr/haskell/evolution.html#combinatory)
    version, now the fastest of the bunch, as measured in number of reductions reported
    by Hugs.'
  id: totrans-split-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*14 August 01 (morning)*: adjusted the [sophomore/Scheme](https://willamette.edu/~fruehr/haskell/evolution.html#sophomore)
    version to use an explicit "lambda" (though we spell it differently in Haskell
    land) and added the [fixed-point](https://willamette.edu/~fruehr/haskell/evolution.html#boyscout)
    version.'
  id: totrans-split-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*10 August 01*: added the [list-encoding](https://willamette.edu/~fruehr/haskell/evolution.html#listencoding)
    and [static computation](https://willamette.edu/~fruehr/haskell/evolution.html#fundep)
    versions (the latter uses type classes and functional dependencies to compute
    factorial during type-checking; it is an extended version of code from Thomas
    Hallgrens Fun with Functional Dependencies [[7]](https://willamette.edu/~fruehr/haskell/evolution.html#references)).'
  id: totrans-split-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*1 August 01*: added [accumulating-parameter](https://willamette.edu/~fruehr/haskell/evolution.html#accumulating)
    and [continuation-passing](https://willamette.edu/~fruehr/haskell/evolution.html#continuation)
    versions (the latter is a revised transliteration from Friedman, Wand and Haynes
    Essentials of Programming Languages [[5]](https://willamette.edu/~fruehr/haskell/evolution.html#references)).'
  id: totrans-split-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*11 July 01*: date of the original posting.'
  id: totrans-split-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-split-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Highlights from nhc - a Space-efficient Haskell Compiler,* Niklas Rjemo. In
    the **FPCA 95 proceedings**. ACM Press, 1995 (see also [CiteSeer](http://citeseer.nj.nec.com/nbib/5076458)
    or [Chalmers ftp archive](ftp://ftp.cs.chalmers.se/pub/users/rojemo/fpca95.ps.gz))'
  id: totrans-split-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*n+k patterns,* Lennart Augustsson. Message to the haskell mailing list, Mon,
    17 May 93 (see [the mailing list archive](http://www.mail-archive.com/haskell@haskell.org/msg01261.html))'
  id: totrans-split-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Sorting Morphisms,*Lex Augusteijn. In **Advanced Functional Programming**,
    (LNCS 1608). Springer-Verlag, 1999 (see also [CiteSeer](http://citeseer.nj.nec.com/augusteijn99sorting.html)).'
  id: totrans-split-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Recursion Schemes from Comonads,* T. Uustalu, V. Vene and A. Pardo. **Nordic
    Journal of Computing**, to appear (see also [Tarmo Uustalus papers page](http://www.cs.ioc.ee/~tarmo/papers/)).'
  id: totrans-split-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Recursion Equations as a Programming Language,* D. A. Turner. In **Functional
    Programming and its Applications**. Cambridge University Press, 1982.'
  id: totrans-split-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Essentials of Programming Languages,* D. Friedman, M. Wand and C. Haynes.
    MIT PRess and McGraw-Hill, 1994.'
  id: totrans-split-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Fun with Functional Dependencies,* Thomas Hallgren. **Joint Winter Meeting
    of the Departments of Science and Computer Engineering**, Chalmers University
    of Technology and Gteborg University, Varberg, Sweden, 2001 (available at [the
    authors web archive](http://www.cs.chalmers.se/~hallgren/Papers/wm01.html)).'
  id: totrans-split-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*The Church of the Least Fixed-Point,* ~~authour unknown~~ by Calvin Ostrum,
    Feburary 1983\. A bit of lambda calculus humor which circulated in the mid-1980s
    (at least thats when I saw it), probably from the comp.lang.functional newsgroup
    or somesuch. (Thanks to Ron, and perhaps another few kind souls, for bringing
    the correct attribution to my attention. I apparently created the following [illuminated
    manuscript version of the *Church of the LFP* creed](http://www.willamette.edu/~fruehr/haskell/ChurchLFP.jpg)
    somewhere along the way.)'
  id: totrans-split-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Categorical Combinators, Sequential Algorithms and Functional Programming,*
    Pierre-Louis Curien. Springer Verlag (2nd edition), 1993.'
  id: totrans-split-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
