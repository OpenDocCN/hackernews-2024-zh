- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:40:35'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: The Evolution of a Haskell Programmer
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://pages.cpsc.ucalgary.ca/~robin/class/449/Evolution.htm](https://pages.cpsc.ucalgary.ca/~robin/class/449/Evolution.htm)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Evolution of a <it>Haskell</it> Programmer
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fritz Ruehr, Willamette University
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: Freshman Haskell programmer
  id: totrans-split-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Sophomore Haskell programmer, at MIT
  id: totrans-split-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (studied Scheme as a freshman)
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Junior Haskell programmer
  id: totrans-split-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (beginning Peano player)
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another junior Haskell programmer
  id: totrans-split-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (read that n+k patterns are a disgusting part of Haskell
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: '[[1]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: and joined the Ban n+k patterns-movement
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: '[[2]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Senior Haskell programmer
  id: totrans-split-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (voted for   ~~Nixon~~   ~~Buchanan~~   Bush leans right)
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another senior Haskell programmer
  id: totrans-split-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (voted for   ~~McGovern~~   ~~Biafra~~   Nader leans left)
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Yet another senior Haskell programmer
  id: totrans-split-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (leaned so far right he came back left again!)
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Memoizing Haskell programmer
  id: totrans-split-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (takes Ginkgo Biloba daily)
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ~~Pointless~~ *(ahem) Points-free* Haskell programmer
  id: totrans-split-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (studied at Oxford)
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Iterative Haskell programmer
  id: totrans-split-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (former Pascal programmer)
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Iterative one-liner Haskell programmer
  id: totrans-split-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (former APL and C programmer)
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Accumulating Haskell programmer
  id: totrans-split-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (building up to a quick climax)
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Continuation-passing Haskell programmer
  id: totrans-split-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (raised RABBITS in early years, then moved to New Jersey)
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Boy Scout Haskell programmer
  id: totrans-split-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (likes tying knots; always reverent, he
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: belongs to the
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: '*Church of the Least Fixed-Point* [[8]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Combinatory Haskell programmer
  id: totrans-split-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (eschews variables, if not obfuscation;
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: all this curryings just a phase, though it seldom hinders)
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: List-encoding Haskell programmer
  id: totrans-split-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (prefers to count in unary)
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-split-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Interpretive Haskell programmer
  id: totrans-split-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (never met a language he didn't like)
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-split-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Static Haskell programmer
  id: totrans-split-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (he does it with class, hes got that fundep Jones!
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: After Thomas Hallgrens Fun with Functional Dependencies
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: '[[7]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-split-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Beginning graduate Haskell programmer
  id: totrans-split-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (graduate education tends to liberate one from petty concerns
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: about, e.g., the efficiency of hardware-based integers)
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-split-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Origamist Haskell programmer
  id: totrans-split-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (always starts out with the basic Bird fold)
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-split-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Cartesianally-inclined Haskell programmer
  id: totrans-split-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (prefers Greek food, avoids the spicy Indian stuff;
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: inspired by Lex Augusteijns Sorting Morphisms
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: '[[3]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-split-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ph.D. Haskell programmer
  id: totrans-split-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (ate so many bananas that his eyes bugged out, now he needs new lenses!)
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-split-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Post-doc Haskell programmer
  id: totrans-split-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (from Uustalu, Vene and Pardos Recursion Schemes from Comonads
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
- en: '[[4]](https://willamette.edu/~fruehr/haskell/evolution.html#references)'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-split-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tenured professor
  id: totrans-split-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (teaching Haskell to freshmen)
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-split-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '* * *'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
- en: Background
  id: totrans-split-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On 19 June 2001, at the [OGI PacSoft Tuesday Morning Seminar Series](http://www.cse.ogi.edu/~magnus/SeminarSeries/)
    , [Iavor Diatchki](http://www.cse.ogi.edu/~diatchki/) presented the paper Recursion
    Schemes from Comonads by Uustalu, Vene and Pardo [[4]](https://willamette.edu/~fruehr/haskell/evolution.html#references).
    I attended Iavors excellent presentation and remarked that I found the end of
    the paper rather anti-climactic: after much categorical effort and the definition
    of several generalized recursion combinators, the main examples were the factorial
    and Fibonacci functions. (Of course, I offered no better examples myself, so this
    was rather unfair carping.)'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 2001年6月19日，在[OGI PacSoft周二早晨研讨会系列](http://www.cse.ogi.edu/~magnus/SeminarSeries/)上，[Iavor
    Diatchki](http://www.cse.ogi.edu/~diatchki/)介绍了Uustalu、Vene和Pardo的论文《从共模子代数到递归方案》[[4]](https://willamette.edu/~fruehr/haskell/evolution.html#references)。我参加了Iavors出色的演讲，并评论道，我觉得论文的结尾相当没趣：经过大量范畴化的努力和几个广义递归组合子的定义之后，主要的例子是阶乘和斐波那契函数。（当然，我自己也没有提供更好的例子，所以这有点不公平的挖苦。）
- en: Some time later, I came across Iavors "jokes" page, including a funny bit called
    [The Evolution of a Programmer](http://www.cse.ogi.edu/~diatchki/jokes/programmer.html)
    in which the traditional imperative "Hello, world" program is developed through
    several variations, from simple beginnings to a ridiculously complex extreme.
    A moments thought turned up the factorial function as the best functional counterpart
    of "Hello, world". Suddenly the Muse struck and I knew I must write out these
    examples, culminating (well, almost) in the heavily generalized categorical version
    of factorial provided by Uustalu, Vene and Pardo.
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，我找到了Iavors的“笑话”页面，其中包括一个有趣的部分称为[程序员的进化](http://www.cse.ogi.edu/~diatchki/jokes/programmer.html)，其中传统的命令式“Hello,
    world”程序通过几种变体从简单的开始发展到极其复杂的极端。稍加思考后，我发现阶乘函数是“Hello, world”最佳函数对应物。突然，灵感如泉涌般涌现，我知道我必须写出这些例子，达到（好吧，几乎）由Uustalu、Vene和Pardo提供的广义范畴化阶乘版本。
- en: I suppose this is what youd have to call small-audience humour.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这应该是你必须称之为小众幽默。
- en: '**PS:** Ive put all the code into a [better-formatted text file](https://willamette.edu/~fruehr/haskell/evolution.hs)
    for those who might like to experiment with the different variations (you could
    also just cut and paste a section from your browser).'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**附言2：** 我已将所有代码放入[更好格式的文本文件](https://willamette.edu/~fruehr/haskell/evolution.hs)，供那些可能想尝试不同变体的人使用（您也可以直接从浏览器中剪切和粘贴部分）。'
- en: '**PPS:** As noted above, Iavor is not the original author of The Evolution
    of a Programmer. A quick web search suggests that there are thousands of copies
    floating around and it appears (unattributed) in humor newsgroups as far back
    as 1995\. But I suspect some version of it goes back much further than that. Of
    course, if anyone does know who wrote the original, please let me know so that
    I may credit them here.'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**附言：** 正如上文所述，Iavor并非《程序员的进化》的原始作者。快速的网络搜索表明，有数千份副本流传，而且（未署名地）出现在1995年以来的幽默新闻组中。但我怀疑某个版本的起源可能比那更早。当然，如果有人知道谁是原始作者，请告诉我，以便我在这里为他们署名。'
- en: '* * *'
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: But seriously, folks, ...
  id: totrans-split-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但说真的，朋友们，……
- en: 'On a more serious note, I think that the basic idea of the joke (successive
    variations on a theme, building in complexity) can serve a good pedagogical purpose
    as well as a humorous one. To that end, and for those who may not be familiar
    with all of the ideas represented above, I offer the following comments on the
    variations:'
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更严肃地说，我认为笑话的基本思想（主题的连续变化，复杂度逐步增加）不仅可以起到幽默的作用，而且可以在教学上发挥良好的作用。为此，对于那些可能不熟悉以上所有观念的人，我对这些变化提供以下评论：
- en: The [first version](https://willamette.edu/~fruehr/haskell/evolution.html#freshman)
    (straight recursion with conditionals) is probably familiar to programmers of
    all stripes; fans of LISP and Scheme will find the [sophomore version](https://willamette.edu/~fruehr/haskell/evolution.html#freshman)
    especially readable, except for the funny spelling of lambda and the absence of
    define (or defun). The use of [patterns](https://willamette.edu/~fruehr/haskell/evolution.html#junior)
    may seem only a slight shift in perspective, but in addition to mirroring mathematical
    notation, patterns encourage the view of data types as initial algebras (or as
    inductively defined).
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一个版本](https://willamette.edu/~fruehr/haskell/evolution.html#freshman)（带有条件的直接递归）可能对各类程序员来说都很熟悉；LISP和Scheme的粉丝会发现[第二个版本](https://willamette.edu/~fruehr/haskell/evolution.html#freshman)尤其易读，尽管lambda的拼写有些奇怪，而且没有定义（或者defun）。使用[模式](https://willamette.edu/~fruehr/haskell/evolution.html#junior)可能只是视角略微的转变，但除了反映数学符号外，模式还鼓励将数据类型视为初始代数（或归纳定义）。'
- en: 'The use of more structural recursion combinators (such as [foldr](https://willamette.edu/~fruehr/haskell/evolution.html#senior-right)
    and [foldl](https://willamette.edu/~fruehr/haskell/evolution.html#senior-left))
    is square in the spirit of functional programming: these higher-order functions
    abstract away from the common details of different instances of recursive definitions,
    recovering the specifics through function arguments. The [points-free](https://willamette.edu/~fruehr/haskell/evolution.html#points-free)
    style (defining functions without explicit reference to their formal parameters)
    can be compelling, but it can also be over-done; here the intent is to foreshadow
    similar usage in some of the later, more stridently algebraic variations.'
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更多结构递归组合子（如[foldr](https://willamette.edu/~fruehr/haskell/evolution.html#senior-right)和[foldl](https://willamette.edu/~fruehr/haskell/evolution.html#senior-left)）完全符合函数式编程的精神：这些高阶函数将递归定义的不同实例的共同细节抽象出来，通过函数参数恢复具体细节。[点自由](https://willamette.edu/~fruehr/haskell/evolution.html#points-free)风格（定义函数而无需显式引用其形式参数）可能非常引人入胜，但有时也会被滥用；这里的目的是预示稍后更为强调代数变体中的类似用法。
- en: The [accumulating-parameter](https://willamette.edu/~fruehr/haskell/evolution.html#accumulating)
    version illustrates a traditional technique for speeding up functional code. It
    is the second fastest implementation here, at least as measured in terms of number
    of reductions reported by Hugs, with the [iterative](https://willamette.edu/~fruehr/haskell/evolution.html#iterative)
    versions coming in third. Although the latter run somewhat against the spirit
    of functional programming, they do give the flavor of the functional simulation
    of state as used in denotational semantics or, for that matter, in monads. (Monads
    are woefully un-represented here; I would be grateful if someone could contribute
    a few (progressive) examples in the spirit of the development above.) The [continuation-passing](https://willamette.edu/~fruehr/haskell/evolution.html#continuation)
    version recalls a denotational account of control (the references are to Steeles
    RABBIT compiler for Scheme and the SML/NJ compiler).
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[累积参数](https://willamette.edu/~fruehr/haskell/evolution.html#accumulating)版本展示了一种加速函数式代码的传统技术。这是这里第二快的实现，至少按照Hugs报告的减少次数来衡量，[迭代](https://willamette.edu/~fruehr/haskell/evolution.html#iterative)版本排名第三。尽管后者有些违背函数式编程的精神，它们确实展示了作为表征语义或单子中使用的状态函数式模拟的风味。（在这里，单子显得非常缺乏；如果有人能贡献一些（渐进）示例，按照上面的开发精神，我将不胜感激。）[传递延续](https://willamette.edu/~fruehr/haskell/evolution.html#continuation)版本回忆起对控制的表征式解释（参考Steeles
    RABBIT编译器的Scheme和SML/NJ编译器的引用）。'
- en: The [fixed-point version](https://willamette.edu/~fruehr/haskell/evolution.html#boyscout)
    demonstrates that we can isolate recursion in a general Y combinator. The [combinatory](https://willamette.edu/~fruehr/haskell/evolution.html#combinatory)
    version provides an extreme take on the points-free style inspired by Combinatory
    Logic, isolating dependence on variable names to the definitions of a few combinators.
    Of course we could go further, defining the Naturals and Booleans in combinatory
    terms, but note that the predecessor function will be a bit hard to accomodate
    (this is one good justification for algebraic types). Also note that we cannot
    define the Y combinator in terms of the others without running into typing problems
    (due essentially to issues of self-application). Interestingly, this is the fastest
    of all of the implementations, perhaps reflecting the underlying graph reduction
    mechanisms used in the implementation.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[固定点版本](https://willamette.edu/~fruehr/haskell/evolution.html#boyscout)显示出我们可以通过通用的Y组合子孤立递归。[组合](https://willamette.edu/~fruehr/haskell/evolution.html#combinatory)版本提供了一种极端的无点式风格，灵感来源于组合逻辑，将对变量名的依赖隔离到少数几个组合子的定义中。当然，我们可以进一步定义自然数和布尔值，但请注意前驱函数将会有些难以适应（这是代数类型的一个很好的理由）。还要注意，我们不能在不遇到类型问题（主要是自我应用问题）的情况下，用其他组合子来定义Y组合子。有趣的是，这是所有实现中最快的，也许反映了在实现中使用的底层图还原机制。'
- en: 'The [list-encoded](https://willamette.edu/~fruehr/haskell/evolution.html#listencoding)
    version exploits the simple observation that we can count in unary by using lists
    of arbitrary elements, so that the length of a list encodes a natural number.
    In some sense this idea foreshadows later versions based on recursive type definitions
    for Peanos naturals, since lists of units are isomorphic to naturals. The only
    interesting thing here is that multiplication (numeric product) is seen to arise
    naturally out of combination (Cartesian product) by way of cardinality. Typing
    issues make it hard to express this correspondence as directly as wed like: the
    following definition of listprod would break the definition of the facl function
    due to an occurs-check/infinite type:'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表编码](https://willamette.edu/~fruehr/haskell/evolution.html#listencoding)版本利用了一个简单的观察：我们可以通过使用任意元素的列表来以一元方式计数，因此列表的长度编码了一个自然数。从某种意义上说，这个想法预示了基于递归类型定义Peanos自然数的后续版本，因为单位列表与自然数同构。这里唯一有趣的是，乘法（数值乘积）被看作是通过基数的组合（笛卡尔积）自然而然地产生。由于类型问题，很难像我们希望的那样直接表达这种对应关系：下面对listprod的定义将会由于出现检查/无限类型而破坏facl函数的定义。'
- en: '`listprod xs ys = [ (x,y) | x<-xs, y<-ys ]`'
  id: totrans-split-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`listprod xs ys = [ (x,y) | x<-xs, y<-ys ]`'
- en: 'Of course we could also simplify as follows, but only at the expense of obscuring
    the relationship between the two kinds of products:'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以简化如下，但这样做只会模糊两种产品之间的关系：
- en: '`listprod xs ys = [ arb | x<-xs, y<-ys ]`'
  id: totrans-split-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`listprod xs ys = [ arb | x<-xs, y<-ys ]`'
- en: The [interpretive](https://willamette.edu/~fruehr/haskell/evolution.html#interpretive)
    version implements a small object language rich enough to express factorial, and
    then implements an interpreter for it based on a simple environment model. Exercises
    along these lines run all through the latter half of the Friedman, Wand and Haynes
    text ([[6]](https://willamette.edu/~fruehr/haskell/evolution.html#references)),
    albeit expressed there in Scheme. We used to get flack from students at [Oberlin](http://www.cs.oberlin.edu/)
    when we made them implement twelve interpreters in a single week-long lab, successively
    exposing more of the implementation by moving the real work from the meta-language
    to the interpreter. This implementation leaves a whole lot on the shoulders of
    the meta-language, corresponding to about Tuesday or Wednesday in their week.
    Industrious readers are invited to implement a compiler for a Squiggol-like language
    of polytypic folds and unfolds, targeting (and simulating) a suitable categorical
    abstract machine (see [[9]](https://willamette.edu/~fruehr/haskell/evolution.html#references)),
    and then to implement factorial in that setting (but don't blame me if it makes
    you late for lunch ...).
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[解释型](https://willamette.edu/~fruehr/haskell/evolution.html#interpretive)版本实现了一个足够丰富以表达阶乘的小型对象语言，并基于简单的环境模型实现了其解释器。沿这些线路的练习贯穿于弗里德曼、旺德和海恩斯的后半部分文本（[[6]](https://willamette.edu/~fruehr/haskell/evolution.html#references)），尽管在那里是用Scheme表达的。我们曾在[奥伯林](http://www.cs.oberlin.edu/)的学生中引起反感，当我们让他们在一个星期的实验室中实现十二个解释器时，逐步通过将真正的工作从元语言移动到解释器来暴露更多的实现细节。这个实现把很多事情留给了元语言，相当于他们一周中的周二或周三。勤奋的读者被邀请在类似于多态折叠和展开的Squiggol语言上实现一个编译器，目标是（并模拟）一个合适的范畴抽象机（参见[[9]](https://willamette.edu/~fruehr/haskell/evolution.html#references)），然后在该环境中实现阶乘（但如果这让你迟到吃午饭，请不要怪我…）。'
- en: The [statically-computed](https://willamette.edu/~fruehr/haskell/evolution.html#fundep)
    version uses type classes and *functional dependencies* to facilitate computation
    at compile time (the latter are recent extensions to the Haskell 98 standard by
    Mark Jones, and are available in Hugs and GHC). The same kinds of techniques can
    also be used to encode behaviors more often associated with dependent types and
    polytypic programming, and are thus a topic of much recent interest in the Haskell
    community. The code shown here is based on an account by Thomas Hallgren (see
    [[7]](https://willamette.edu/~fruehr/haskell/evolution.html#references)), extended
    to include factorial. Prolog fans will find the definitions particularly easy
    to read, if a bit backwards.
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[静态计算](https://willamette.edu/~fruehr/haskell/evolution.html#fundep)版本使用类型类和*功能依赖*在编译时促进计算（后者是马克·琼斯最近对Haskell
    98标准的扩展，并在Hugs和GHC中可用）。同样类型的技术也可以用于编码更常见于依赖类型和多态编程的行为，因此是Haskell社区近期很感兴趣的主题。这里展示的代码基于托马斯·霍尔格伦的描述（见[[7]](https://willamette.edu/~fruehr/haskell/evolution.html#references)，扩展以包括阶乘。Prolog爱好者将发现这些定义特别易读，尽管有些有些“反向”。'
- en: The first of the [graduate](https://willamette.edu/~fruehr/haskell/evolution.html#peano)
    versions gets more serious about recursion, defining natural numbers as a recursive
    algebraic datatype and highlighting the difference between iteration and primitive
    recursion. The [origamist](https://willamette.edu/~fruehr/haskell/evolution.html#origami)
    and [cartesian](https://willamette.edu/~fruehr/haskell/evolution.html#cartesian)
    variations take a small step backwards in this regard, as they return to the use
    of internal integer and list types. They serve, however, to introduce anamorphic
    and hylomorphic notions in a more familiar context.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个[研究生](https://willamette.edu/~fruehr/haskell/evolution.html#peano)版本更加严肃地对递归进行了定义，将自然数定义为递归代数数据类型，并突出了迭代和原始递归之间的区别。[折纸](https://willamette.edu/~fruehr/haskell/evolution.html#origami)和[笛卡尔](https://willamette.edu/~fruehr/haskell/evolution.html#cartesian)变体在这方面略有退步，因为它们回到了使用内部整数和列表类型。然而，它们在更熟悉的背景下引入了解扭曲和半解构的概念。
- en: The [Ph.D](https://willamette.edu/~fruehr/haskell/evolution.html#categorical)
    example employs the categorical style of BMF/Squiggol in a serious way (we could
    actually go a bit further, by using co-products more directly, and thus eliminate
    some of the overt dependence on the internal sums of the data type definition
    mechanism).
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[博士](https://willamette.edu/~fruehr/haskell/evolution.html#categorical)示例在BMF/Squiggol的范畴风格中严肃地应用了（我们实际上可以更进一步，通过更直接地使用余积，从而消除一些对数据类型定义机制内部和的依赖）。'
- en: By the time we arrive at the pice de rsistance, the [comonadic](https://willamette.edu/~fruehr/haskell/evolution.html#comonadic)
    version of Uustalu, Vene and Pardo, we have covered most of the underlying ideas
    and can (hopefully) concentrate better on their specific contributions. The [final](https://willamette.edu/~fruehr/haskell/evolution.html#tenured)
    version, using the Prelude-defined product function and ellipsis notation, is
    how I think the function is most clearly expressed, presuming some knowledge of
    the language and Prelude definitions. (This definition also dates back at least
    to David Turners KRC* language [[5]](https://willamette.edu/~fruehr/haskell/evolution.html#references).)
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到达**巅峰之作**时，我们已经涵盖了大部分基本思想，并且（希望能够）更好地集中精力在它们的具体贡献上。使用了[共摄](https://willamette.edu/~fruehr/haskell/evolution.html#comonadic)版本的Uustalu，Vene和Pardo之后，是我认为这个函数在语言和Prelude定义方面最为清晰表达的**最终**版本，使用了Prelude定义的乘积函数和省略号表示法（这一定义至少可以追溯到David
    Turners的KRC*语言[[5]](https://willamette.edu/~fruehr/haskell/evolution.html#references)）。
- en: It is comforting to know that the Prelude ultimately uses a recursion combinator
    (foldl', the strict version of foldl) to define product. I guess we can all hope
    to see the day when the Prelude will define gcatamorphic, zygomorphic and paramorphic
    combinators for us, so that factorial can be defined both conveniently *and* with
    greater dignity :) .
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 安慰的是，我们可以放心地知道Prelude最终使用了一个递归组合子（foldl'，foldl的严格版本）来定义乘积。我想我们都可以希望看到Prelude为我们定义gcatamorphic、zygomorphic和paramorphic组合子的那一天，这样阶乘既可以方便地定义，*又*更有尊严
    :)。
- en: '* * *'
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* *KRC may or may not be a trademark of Research Software, Ltd.,'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: '* *KRC可能是Research Software公司的商标，也可能不是。'
- en: but you can bet your sweet bippy that* Miranda *is!*
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可以打赌你的甜蜜的Bippy，*Miranda *就是！
- en: '* * *'
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Revision history
  id: totrans-split-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修订历史
- en: '*Sometime in the 2010s*: corrected the attribution for the *Church of the LFP*
    creed, which is due to Calvin Ostrum (and added a link to an illuminated version;
    see above). Also added a link to a Serbo-Croatian version of this page, although
    I was later told that this kindly-provided service is some sort of click-bait
    scheme. I dont know what to make of all that: if the translation itself is somehow
    horribly wrong, I suppose I could cut the link back out. But perhaps the whole
    incident merely suggests that I am deteriorating into a clueless old fart who
    cant make sense of all these new-fangled Internet scams, which is probably becoming
    more true all the time. (Extra points to anyone who combines Dynamic Logic with
    Denotational Semantics and Fuzzy Logic to develop a system in which to explore
    the notion of propositions becoming true slowly, over time. I can also see potential
    applications to sorities paradoxes involving greying hair ... .)'
  id: totrans-split-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2010年代某个时间*：更正了*LFPP信条*的归属，这是Calvin Ostrum的贡献（并添加了一个照明版本的链接；请参见上文）。还添加了一个塞尔维亚克罗地亚语版本的链接，尽管后来有人告诉我，这个友好提供的服务是某种点击诱饵计划。我对这一切一窍不通：如果翻译本身出了什么问题，我想我可以将链接删掉。但或许整个事件只是表明我正在变成一个毫无头绪的老家伙，无法理解所有这些新潮的互联网骗局，这可能正在变得越来越真实。
    （给任何结合了动态逻辑、指称语义和模糊逻辑以开发一个系统来探索命题随时间缓慢变为真实的人额外加分。我也能看到涉及变灰发的SORITES悖论的潜在应用……。）'
- en: '*20 August 01*: added the [interpretive](https://willamette.edu/~fruehr/haskell/evolution.html#interpretive)
    version, based on an environment model of a small object language (no, not in
    *that* sense of object ...). Im thinking about re-arranging the order of the examples,
    so that longer ones that are not part of the main line of development don''t intrude
    so much. I also advertised the page on [the Haskell Caf](http://haskell.org/mailman/listinfo/haskell-cafe)
    mailing list and requested that a link be added to the [Haskell humor page.](http://www.haskell.org/humor)
    Finally, I have an interesting new example in the works that may actually have
    some original research value; more on this soon.'
  id: totrans-split-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*01年8月20日*：增加了基于小型对象语言环境模型的[解释性](https://willamette.edu/~fruehr/haskell/evolution.html#interpretive)版本（不，不是那种*对象*的意思……）。我在考虑重新排列示例的顺序，以便那些不属于主要开发路线的更长示例不会过多干扰。我还在[Haskell咖啡馆](http://haskell.org/mailman/listinfo/haskell-cafe)邮件列表上宣传了这个页面，并请求将链接添加到[Haskell幽默页面](http://www.haskell.org/humor)上。最后，我正在制作一个有一定原创研究价值的有趣新示例；关于这个的更多内容即将发布。'
- en: '*14 August 01 (afternoon)*: added the [combinatory](https://willamette.edu/~fruehr/haskell/evolution.html#combinatory)
    version, now the fastest of the bunch, as measured in number of reductions reported
    by Hugs.'
  id: totrans-split-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*01 年 08 月 14 日 (下午)*: 添加了 [combinatory](https://willamette.edu/~fruehr/haskell/evolution.html#combinatory)
    版本，目前是由 Hugs 报告的减少数量最快的版本。'
- en: '*14 August 01 (morning)*: adjusted the [sophomore/Scheme](https://willamette.edu/~fruehr/haskell/evolution.html#sophomore)
    version to use an explicit "lambda" (though we spell it differently in Haskell
    land) and added the [fixed-point](https://willamette.edu/~fruehr/haskell/evolution.html#boyscout)
    version.'
  id: totrans-split-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*01 年 08 月 14 日 (早晨)*：调整了 [大二/方案](https://willamette.edu/~fruehr/haskell/evolution.html#sophomore)
    版本，使用了明确的 "lambda" (尽管在 Haskell 领域中我们的拼写有所不同)，并添加了 [fixed-point](https://willamette.edu/~fruehr/haskell/evolution.html#boyscout)
    版本。'
- en: '*10 August 01*: added the [list-encoding](https://willamette.edu/~fruehr/haskell/evolution.html#listencoding)
    and [static computation](https://willamette.edu/~fruehr/haskell/evolution.html#fundep)
    versions (the latter uses type classes and functional dependencies to compute
    factorial during type-checking; it is an extended version of code from Thomas
    Hallgrens Fun with Functional Dependencies [[7]](https://willamette.edu/~fruehr/haskell/evolution.html#references)).'
  id: totrans-split-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*01 年 08 月 10 日*: 添加了 [list-encoding](https://willamette.edu/~fruehr/haskell/evolution.html#listencoding)
    和 [static computation](https://willamette.edu/~fruehr/haskell/evolution.html#fundep)
    版本 (后者在类型检查期间使用类型类和功能依赖计算阶乘；这是从 Thomas Hallgrens 的 "Fun with Functional Dependencies"
    [[7]](https://willamette.edu/~fruehr/haskell/evolution.html#references) 中扩展的版本).'
- en: '*1 August 01*: added [accumulating-parameter](https://willamette.edu/~fruehr/haskell/evolution.html#accumulating)
    and [continuation-passing](https://willamette.edu/~fruehr/haskell/evolution.html#continuation)
    versions (the latter is a revised transliteration from Friedman, Wand and Haynes
    Essentials of Programming Languages [[5]](https://willamette.edu/~fruehr/haskell/evolution.html#references)).'
  id: totrans-split-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*01 年 08 月 1 日*: 添加了 [accumulating-parameter](https://willamette.edu/~fruehr/haskell/evolution.html#accumulating)
    和 [continuation-passing](https://willamette.edu/~fruehr/haskell/evolution.html#continuation)
    版本 (后者是从 Friedman, Wand 和 Haynes 的 "编程语言的基本要素" [[5]](https://willamette.edu/~fruehr/haskell/evolution.html#references)
    中修改的转录).'
- en: '*11 July 01*: date of the original posting.'
  id: totrans-split-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*01 年 07 月 11 日*: 最初发布日期.'
- en: '* * *'
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: References
  id: totrans-split-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: '*Highlights from nhc - a Space-efficient Haskell Compiler,* Niklas Rjemo. In
    the **FPCA 95 proceedings**. ACM Press, 1995 (see also [CiteSeer](http://citeseer.nj.nec.com/nbib/5076458)
    or [Chalmers ftp archive](ftp://ftp.cs.chalmers.se/pub/users/rojemo/fpca95.ps.gz))'
  id: totrans-split-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*从 nhc 中的亮点 - 一个高效的 Haskell 编译器,* Niklas Rjemo. 在 **FPCA 95 会议论文集** 中. ACM
    出版社, 1995 (参见[CiteSeer](http://citeseer.nj.nec.com/nbib/5076458) 或 [Chalmers ftp
    档案](ftp://ftp.cs.chalmers.se/pub/users/rojemo/fpca95.ps.gz)).'
- en: '*n+k patterns,* Lennart Augustsson. Message to the haskell mailing list, Mon,
    17 May 93 (see [the mailing list archive](http://www.mail-archive.com/haskell@haskell.org/msg01261.html))'
  id: totrans-split-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*n+k 模式,* Lennart Augustsson. 发送至 Haskell 邮件列表的消息，1993 年 5 月 17 日 (参见[邮件列表档案](http://www.mail-archive.com/haskell@haskell.org/msg01261.html)).'
- en: '*Sorting Morphisms,*Lex Augusteijn. In **Advanced Functional Programming**,
    (LNCS 1608). Springer-Verlag, 1999 (see also [CiteSeer](http://citeseer.nj.nec.com/augusteijn99sorting.html)).'
  id: totrans-split-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*排序态射,* Lex Augusteijn. 在 **高级函数编程** (LNCS 1608). Springer-Verlag, 1999 (参见[CiteSeer](http://citeseer.nj.nec.com/augusteijn99sorting.html)).'
- en: '*Recursion Schemes from Comonads,* T. Uustalu, V. Vene and A. Pardo. **Nordic
    Journal of Computing**, to appear (see also [Tarmo Uustalus papers page](http://www.cs.ioc.ee/~tarmo/papers/)).'
  id: totrans-split-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Comonad 中的递归方案,* T. Uustalu, V. Vene 和 A. Pardo. **北欧计算期刊**, 即将发表 (参见[Tarmo
    Uustalu 的论文页面](http://www.cs.ioc.ee/~tarmo/papers/)).'
- en: '*Recursion Equations as a Programming Language,* D. A. Turner. In **Functional
    Programming and its Applications**. Cambridge University Press, 1982.'
  id: totrans-split-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*递归方程作为一种编程语言,* D. A. Turner. 在 **函数式编程及其应用** 中. 剑桥大学出版社, 1982.'
- en: '*Essentials of Programming Languages,* D. Friedman, M. Wand and C. Haynes.
    MIT PRess and McGraw-Hill, 1994.'
  id: totrans-split-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*编程语言的基本要素,* D. Friedman, M. Wand 和 C. Haynes. MIT 出版社和 McGraw-Hill, 1994.'
- en: '*Fun with Functional Dependencies,* Thomas Hallgren. **Joint Winter Meeting
    of the Departments of Science and Computer Engineering**, Chalmers University
    of Technology and Gteborg University, Varberg, Sweden, 2001 (available at [the
    authors web archive](http://www.cs.chalmers.se/~hallgren/Papers/wm01.html)).'
  id: totrans-split-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*功能依赖的乐趣,* Thomas Hallgren. **科学与计算机工程系联合冬季会议**, 瑞典 Chalmers 科技大学和 Gteborg
    大学, Varberg, 2001 (可在[作者的网络档案](http://www.cs.chalmers.se/~hallgren/Papers/wm01.html)找到).'
- en: '*The Church of the Least Fixed-Point,* ~~authour unknown~~ by Calvin Ostrum,
    Feburary 1983\. A bit of lambda calculus humor which circulated in the mid-1980s
    (at least thats when I saw it), probably from the comp.lang.functional newsgroup
    or somesuch. (Thanks to Ron, and perhaps another few kind souls, for bringing
    the correct attribution to my attention. I apparently created the following [illuminated
    manuscript version of the *Church of the LFP* creed](http://www.willamette.edu/~fruehr/haskell/ChurchLFP.jpg)
    somewhere along the way.)'
  id: totrans-split-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*最小不动点教堂*，~~作者未知~~，作者为 Calvin Ostrum，1983 年 2 月。lambda 演算的一点幽默，传播于 1980 年代中期（至少我是那时看到的），可能来自于
    comp.lang.functional 新闻组或类似的地方。（感谢 Ron，也许还有其他一些善良的人，提醒我正确的归属。显然我在某个时候创作了下面的[最小不动点教堂信条的彩绘手稿版本](http://www.willamette.edu/~fruehr/haskell/ChurchLFP.jpg)。）'
- en: '*Categorical Combinators, Sequential Algorithms and Functional Programming,*
    Pierre-Louis Curien. Springer Verlag (2nd edition), 1993.'
  id: totrans-split-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*分类组合子、顺序算法和函数式编程*，Pierre-Louis Curien 著。Springer Verlag（第二版），1993 年。'
- en: '* * *'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
