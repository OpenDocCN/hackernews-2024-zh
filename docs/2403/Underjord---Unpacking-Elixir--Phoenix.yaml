- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:43:36'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Underjord | Unpacking Elixir: Phoenix'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://underjord.io/unpacking-elixir-phoenix.html](https://underjord.io/unpacking-elixir-phoenix.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Unpacking Elixir: Phoenix'
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2024-01-22'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: Underjord is a [tiny, wholesome team](/team.html) doing Elixir consulting and
    contract work. If you like the writing you should really try the code. See our
    [services](/services.html) for more information.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: In this series I’ve been unpacking various facets of [Elixir](https://elixir-lang.org/).
    Mostly this has meant trying to explain Erlang and the BEAM through the lens of
    Elixir. Now we are moving into the domain of the web framework. This is where
    I dare say that Elixir has much more to say than Erlang. Erlang has to my understanding
    never landed fully on a canonical preferred web framework. Elixir has [Phoenix](https://www.phoenixframework.org/)
    and this post will be unpacking Phoenix. The Elixir web framework.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: As for Erlang [this Awesome Erlang list](https://github.com/uhub/awesome-erlang)
    has a ton of web frameworks. There have been many but I have never detected a
    consensus on what one “should” use. Actually, when I spoke to [Robert Virding](https://www.wikidata.org/wiki/Q107596747)
    over beers at a conference I asked something about this and he more or less said
    that Elixir and Phoenix should be the preferred web framework for the BEAM. The
    exact question and the exact answer are muddled by time and memory. My understanding
    is that he much prefers Erlang for everything else but really wishes that people
    would just use LfE ;)
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: This should not be taken as a criticism of Erlang, rather a kudos to Elixir
    for establishing and maintaining this useful cohesion. The Elixir ecosystem has
    always had a fair bit of focus on the web in a way which Erlang has not.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: People have built other web frameworks in Elixir. Phoenix remains the major
    player. It is the Rails/Django/Laravel of the Elixir ecosystem though I would
    argue it is more lightweight. In good ways and possibly bad.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: Plug
  id: totrans-split-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We shouldn’t start on Phoenix. That’s the high-level framework. The fundamentals
    of dealing with web requests and creating responses are handed to [Plug](https://hexdocs.pm/plug/readme.html).
    Plug deals with headers, bodies, query params, URLs, paths and all of that by
    providing the concept of composable plugs. A very simple plug:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: elixir
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-16
  prefs: []
  type: TYPE_PRE
- en: Plug also provides a module for routing and building up routes based on path
    and method. This example is from the docs.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: elixir
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-19
  prefs: []
  type: TYPE_PRE
- en: A plug which does not halt continues to the next plug specified. This means
    every step of authentication, authorization, parsing and so on can be layered.
    Similar to a middleware approach. They all work with the `Plug.Conn` struct.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: Plug is a rather elegant way of getting web stuff done. Good building blocks.
    I stole some code from Frank Hunleth and Connor Rigby of the Nerves project when
    I wanted to do [my live visitor counter in an image](https://underjord.io/live-server-push-without-js.html)
    (also [the Plug](https://github.com/lawik/mjpeg/blob/master/lib/mjpeg.ex) and
    [the project](https://github.com/lawik/mjpeg_example)) to do chunking and produce
    an MJPEG. It didn’t need the rest of Phoenix. A good case for straight Plug. But
    also, a Phoenix Controller is just a Plug and could do it just as well.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: Web servers
  id: totrans-split-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically Phoenix has leaned on a web server called [Cowboy](https://ninenines.eu/docs/en/cowboy/2.10/guide/)
    written in Erlang. It has been a very reliable workhorse for a long time and has
    done well in that role. It connects to Plug via the `plug_cowboy` library. Increasingly
    I see projects pick up [Bandit](https://hexdocs.pm/bandit/Bandit.html) which is
    intended to be a replacement written in Elixir. This allows the community a lower
    barrier to contribution as more people in the Elixir space know Elixir than Erlang.
    There is more to it as well. We covered some of that in [an episode of BEAM Radio](https://www.beamrad.io/53)
    if you are curious. Supposedly Bandit also benchmarks as a bit faster than Cowboy
    which is of course a nice perk.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: Something these web servers have in common is that they are not your Ruby or
    Python application web servers. No reverse proxy required unless you want one.
    They can actually be trusted to do real frontline work. Erlang was built for it.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: Phoenix
  id: totrans-split-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now I think we can tackle Phoenix. Ah yes, the “Rails of Elixir”. But not nearly
    so similar. Now I don’t have any significant experience with Rails but I talk
    to people who do. I have experience in Django. Both Django and Rails work hard
    to help the developer be productive for the common case. The Pareto Principle,
    80/20 rule, all that. And beyond.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: In Django this is achieved through “magic”. Mostly inheritance of classes that
    introspect what you put in them and do things based off of that. They also take
    metaprogramming very literally and you end up putting a bunch of things in a class-within-a-class
    called Meta as I recall.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: These are super-dynamic languages where monkey-patching and other fun stuff
    is incredibly available. This of course means you should limit how much you use
    this fun stuff as much as possible. A code-base without discipline can get very
    messy on top of these languages and frameworks.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: Phoenix tries not to rely on “magic”. We call them [macros](https://hexdocs.pm/elixir/macros.html)
    instead.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: I kid. Macros are among the more confusing parts of Phoenix as well as Plug
    but they are generally there to manage some inherent complexity for you and they
    are much of the time still in “your” code.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: Typically you start a Phoenix project using `mix phx.new my_app` which generates
    a project that you then own. Sure, you have dependencies, the code of which you
    don’t own, but your MyAppWeb module has macros for bringing in the necessary functions
    for Controllers or LiveView and you can adapt that to your way.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: I’ve heard multiple people go “that’s a lot of files” when generating a Phoenix
    project and I agree, that’s the impression you’ll get. But most of the files have
    fairly clear purpose once you get to know them and they are there to make things
    explicit and hand you the reins instead of mysteriously and magically inheriting
    things at you. There are also hygiene things like gettext that you might not use
    in your first few projects that are there because they just ought to include it.
    And you’d be pissed if it was not there when you needed it.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: Opinionated design, or a lack thereof
  id: totrans-split-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We often talk about opinionated design in web frameworks. The reason is generally
    that an opinionated design makes significant trade-offs for some cases in order
    to support the common case. Pareto principle, 80/20 rule, all that, again. By
    providing an opinionated design you eliminate the need for many decisions and
    ideally provide well-proven good-enough solutions or at least helpful simplifications.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: Phoenix is not deeply opinionated. I think comes with the developers driving
    Phoenix had more experience and wanted to focus on good primitives. Also, I Functional
    Programming achieves abstraction quite differently from the OOP style of Python
    and Ruby. FP tends to achieve complex things with simple parts.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: Erlang is incredibly opinionated at a fundamental level. It makes a ton of choices
    in the service of building services and Elixir inherited those opinions. We’ve
    traded off a number of things we don’t care about to get a fantastic foundation
    for a web framework. We get trivial concurrency and parallelism but have traded
    off small binaries and number crunching. We have consistent latencies but don’t
    get the speed of mutable state.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: I started out considering Phoenix as an opinionated framework in the vein of
    Django. I don’t know what gave me that idea aside from them both being web frameworks.
    Sure, it brings in some opinions such as “specifying routers in a central place
    is nice” and “this is how you should bring in your helper functions for doing
    controllers”. It also abstracts away connection pools and supervision trees and
    there are opinions enshrined there but that’s usually not what people mean when
    talking about opinionated framework designs.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: If you come from Django or Rails you will likely miss the extremely convenient
    derive-everything-from-the-model typ of schema-driven development. If you want
    more of that the currently most interesting option is [Ash Framework](https://ash-hq.org/)
    which is very opinionated and quite fascinating.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: There are some opinionated parts outside the core of Phoenix’s web capabilities.
    Channels is an opinion on top of WebSockets, Presence as well. Phoenix LiveView
    is heavily opinionated and makes fairly aggressive trade-offs for great wins in
    productivity.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: Phoenix also brings in [Ecto](https://hexdocs.pm/ecto/Ecto.html) by default
    and Ecto is a fairly opinionated approach to relational databases. [Changesets](https://hexdocs.pm/ecto/Ecto.Changeset.html)
    and the [Query DSL](https://hexdocs.pm/ecto/Ecto.Query.html) are both quite flexible
    but they push you towards a particular way of working that the library believes
    is best.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: The most contentious part of Phoenix seems to be [Contexts](https://hexdocs.pm/phoenix/contexts.html).
    Which is the connective tissue between a Controller, Channel or LiveView and the
    Ecto-driven data layer. There is an approach generated by default but it is much
    discussed and will generally require you to apply your own designs and ideas.
    It it very open ended. There is no special Context code. There is an opinion coming
    from the Phoenix generators but it seems very softly held and it is not really
    in the bones of the framework.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: Overall I think Phoenix has been layered well and I find this restraint of opinion
    in the base framework means that there isn’t a big desire for a lightweight microframework
    alternative to Phoenix (see Flask, FastAPI in Python) because if you just ask
    it to not add a database or skip the HTML bits or whatever configuration you need
    you will get your minimal API service or you full-trim HTML-spitting machine.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: The Phoenix feature set
  id: totrans-split-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I will try to capture the things that make up Phoenix. Major features as it
    were.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: Project generation
  id: totrans-split-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Phoenix does a bit of inversion of ownership and as I’ve mentioned, produces
    a bunch of files that you can then own and evolve. I run `mix phx.new` on something
    like a weekly basis as I try a new hack of some sort. The generator has a bunch
    of options, choose database (postgres, mysql, sqlite) or skip Ecto and database
    details entirely. HTML or not. LiveView or not. Assets or not. This is the normal
    starting point.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: There are other starter templates. Legendary, Petal Pro and some others. I can’t
    vouch for them. I’ve worked on a Petal Pro project, it was fine, it certainly
    brought more opinion around templating and layouts.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: Ecto
  id: totrans-split-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The database layer. Not locked to Phoenix in any particular way but it does
    ship by default.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: Ecto provides relational database functionality to your app and stops you from
    making a bunch of mistakes that could lead to SQL injection attacks and the like.
    This informs Ecto’s design in unusual ways. It relies a decent bit on compile-time
    macros for building queries. There are also escape hatches pretty much wherever
    you might need them.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: A repo is an abstraction over a supervision tree that manages database connection
    pooling. A typical app deals with one Repo named `MyApp.Repo` and it provides
    all the query functions and such.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: If you are dealing with two separate databases you can easily set up and additional
    repo. And if you are dealing with multi-tenancy or some other multi-database situation
    you have “dynamic repos” functionality which will let you work that way as well.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: The Schema module exposes a DSL for specifying database tables, mostly. It can
    also be used to specify schemas that are not backed by a database for various
    purposes. But mainly, this correlates with Django or Rails models while being
    significantly less magical in nature. They boil down to Elixir Structs.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: A way to define validation rules for schemas (and other data). This will help
    you produce good errors, integrate actual errors returned from the database gracefully
    and many other things. Changesets are used in and around inserts and updates.
    They are a large topic and well worth reading up on because they are quite and
    interesting and useful design.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: Web stuff
  id: totrans-split-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This module is generated for you but when added to your supervision tree it
    starts a Phoenix Endpoint which contains a supervision tree for starting any Phoenix-owned
    process. Whether you use the Plug integration for Cowboy or Bandit it will set
    up your web server to listen for inbound requests and route them to Plug and the
    Endpoint. The Endpoint defines a bunch of fundamental plugs and config. It then
    typically defers to the Router for further handling of requests.
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: The router module is where you use a combination of Phoenix and Plug plugs to
    handle requests and delegate them to Controllers and LiveViews. It is a nice central
    place for structuring this and also allows you to define pipelines for other plugs
    that need to be applied, such as checking authentication and authorization.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: MyAppWeb
  id: totrans-split-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This holds your macros for controllers, channels and liveviews. These macros
    mostly bring in other Phoenix functionality but they are in your file and you
    can and should use them as an extension point for bringing in your own tools.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: A controller handles a request. The Controller might produce JSON API responses,
    HTML, file chunks or whatever else. Doesn’t matter. If you are rendering HTML
    you get into templating and components. A controller is actually also just a Plug.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: Templating ([Heex](https://hexdocs.pm/phoenix/components.html))
  id: totrans-split-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Heex is an evolution of the regular Eex templating that ships with Elixir. Heex
    is HTML-aware and will tell you when you screw up your closing tags. It also has
    nice syntax for arguments beyond basic string interpolation and such.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: elixir
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-64
  prefs: []
  type: TYPE_PRE
- en: Innovations
  id: totrans-split-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I want to shine some light on the bits that I think offer capabilities beyond
    what we typically see in web frameworks or that do things better than most web
    frameworks.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: Functionality used as an underpinning for Phoenix Channels. PubSub is a publish/subscribe
    mechanism for loose coupling of communication across your application. It uses
    Erlang’s process groups and Erlang distribution. Unless you are on Heroku in which
    case you need the Redis adapter. You should be clustering or Chris McCord will
    be upset with you.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: Phoenix PubSub is incredibly practical for letting processes track a topic and
    receive messages when things happen on that. And as GenServers, Channels and LiveViews
    are processes that can handle messages you can use these for many niceties. A
    common one is informing a LiveView that content it is showing has in fact changed.
    It can then do whatever it considers appropriate to inform the user.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: Built to support usage in Channels but usable as a more general tool. Phoenix
    Presence lets you track the ephemeral presence of things (usually users). Are
    they online? Busy? Away with a small message? Are they on mobile only? It uses
    a CRDT approach to minimize how much data it needs to keep around while creating
    an eventually consistent model of the world without requiring a separate storage
    backend.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: An abstraction, intended to go on top of WebSockets though it will do long polling
    if necessary, it provides an abstraction for connecting to channels and joining
    rooms within them. Each WebSocket is backed by a GenServer on the server side
    and will let you keep state about the connected user. Typically you connect to
    it with a JavaScript client which handles failures, reconnects and provides some
    API niceties.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally the most important bits are WebSockets and server-side actors.
    But the rest is nice too.
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: The belle of the ball for most of us. The point of LiveView is to eliminate
    the need to write JavaScript for most web development tasks. It allows driving
    highly interactive web UI based on server state. This typically happens over a
    Channels-style WebSocket. You can annotate your Heex templates and components
    with attributes such as `phx-click` and similar to allow sending events to the
    server. The event is processed to update server state and a minimal diff is calculated
    and passed back to the browser which can then patch the DOM using morphdom.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: 'You would have a very hard time getting payloads this lean using a SPA with
    your own API implementation. It also leans hard on an Erlangism: consistently
    low latencies.'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: There is also support for driving certain simpler JS/CSS updates without a server
    round-trip, animation support, streamed listings, functional stateless component,
    stateful components and more that I’m forgetting.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: It is also trivial to push server-side changes to relevant LiveViews, thanks
    to the BEAM and Phoenix PubSub.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: Here we have a very opinionated design. It sacrifices offline support for not
    needing to write as much code or maintain as many interfaces. It is an immense
    time-saver. There are many more posts about LiveView out there. We can leave it
    at this point.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: Asset pipeline
  id: totrans-split-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once upon a time Phoenix shipped brunch I think. Then they switched to the
    industry standard: Webpack. Then they grew sick of the massive support burden
    it was to help people keep their node and npm setups working. Phoenix switched
    to [Esbuild](https://esbuild.github.io/) delivered through an Elixir library via
    Hex.pm.'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: I think this was a very good move. I have so many fewer asset problems now.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: Phoenix ships with Swoosh which is an abstraction for email. It has plug-ins
    for many popular transactional email providers. So once you go into production
    you have an easy time doing password resets or magic links.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: It also has a very nice little dev tool that lets you check a mailbox for the
    mail that has been “sent”.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Under-promoted cool thing. It is an observability dashboard web UI that you
    can ship by default in your admin and do simple things like:'
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: Investigate your running processes
  id: totrans-split-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See breakdowns of memory usage
  id: totrans-split-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See OS metrics
  id: totrans-split-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See ETS table usage
  id: totrans-split-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture request logs
  id: totrans-split-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And more. For no effort you get a practical first-look tool for investigating
    a misbehaving system. This is very Elixir. All the primitives and possibilities
    come from the BEAM and have been possible in Erlang since forever. But Elixir
    made it nice, simple and for most of us it is there by default (because Phoenix).
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: Your app is not just “web”
  id: totrans-split-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most systems have more duties than just serving web traffic. Often this is delegated
    to queues/brokers, workers, other services, Redis, databases, cloud functions
    or whatever else. A Phoenix app is a BEAM application first. You can run many
    other workloads in it. You are building a system and it doesn’t have to be several
    applications under this runtime.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: Importantly Phoenix does not infect your system in any particular weird way.
    It doesn’t warp the application away from normal Elixir application conventions.
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating infrastructure
  id: totrans-split-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have touched on this throughout. But fundamentally a Phoenix application is
    only really expected to need a backing relational database. Typically Postgres.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
- en: No Redis. No mail workers. No separate task-runners. It can all occur from your
    application.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  id: totrans-split-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Phoenix is very much the canonical web framework for Elixir and it has massive
    gravity in the community and ecosystem. I think we benefit a lot from that. There
    is a lot of common, directed effort centering on Phoenix and Ecto.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
- en: It is a very solid web framework, on top a legendary runtime. And you build
    inside it with a very approachable language.
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
- en: We get the system design and development possibilities afforded by our runtime
    where we have very few things limiting us in what we want to do.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
- en: And then we get the innovations that have been built in a way that is essentially
    unique. Other ecosystems have copied LiveView, as they should. But their variants
    can’t do everything that LiveView can and they will have challenges getting there
    if they try. And that disregards all the practicalities of making an application
    be live.
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
- en: Underjord is a [4 people team](/team.html) doing Elixir consulting and contract
    work. If you like the writing you should really try the code. See our [services](/services.html)
    for more information.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Or try the videos on [the YouTube channel](https://youtube.com/c/underjord).'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
