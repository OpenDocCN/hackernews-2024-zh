<!--yml

category: 未分类

date: 2024-05-29 12:40:57

-->

# 谁杀死了网络交换机？ - Cliffle

> 来源：[https://cliffle.com/blog/who-killed-the-network-switch/](https://cliffle.com/blog/who-killed-the-network-switch/)

# 谁杀死了网络交换机？

一个Hubris Bug的故事

2024-03-24

我们本周在[傲慢](https://hubris.oxide.computer/)中发现了一个很棒的bug。像许多bug一样，当它最初编写时并不是一个bug —— 随着其周围环境的改变，正确的代码*变成了*一个bug。

我认为这个bug本身以及找到和修复它的过程为我们围绕Hubris的开发过程提供了一个有趣的窗口。在Hubris内核中找到bug对我们来说非常罕见，主要是因为它非常小。因此，我抓住了机会把它写下来。

这是一个讲述两个本来各自有用的功能如何结合成为一个bug的故事。继续阅读了解详情。

## 什么是Hubris？

Hubris是专为深度嵌入式系统设计的操作系统 —— 所有你不认为是“计算机”的计算机，比如键盘内部的计算机。我们设计它来处理启动Oxide机架中的*大*处理器所需的所有任务。

Hubris相当奇怪。我将在下面解释与这个故事相关的部分。如果您想了解更多背景信息，我建议阅读以下内容之一

## 犯罪现场

就像任何一部好的侦探小说，让我们从受害者开始。

我的同事Arjen Roodselaar主要负责在Oxide的网络交换机上运行的固件。他在测试他对电源顺序和时钟配置所做的更改时 —— 这些非常重要的部分负责开启其他所有设备。在一次看似无害的更改后，突然间，交换机无法启动。

有趣的是，*固件的某些部分*会响应查询，但真正重要的部分 —— 电源供应顺序控制器 —— 似乎已经无法运行。没有电源，网络交换机只是一个相当大且非常沉重的纸砖。

搞乱电源顺序可能会彻底损坏硬件。交换机是死了还是只是不响应？那么，一个显然与系统的其他部分无关的代码更改是如何导致电源顺序问题的？

一个谜！

好了，舞台已经设定好了，现在让我们回溯一下，谈一谈Hubris设计的一些细节。

## 在有限RAM中挤出更多内容

在我们使用Hubris的相对廉价的微控制器上，挑战之一是RAM（以及用于存储代码的flash）非常有限。例如，我们有一个内部板子，作为一个有用的I2C调试探针，并拥有8 kiB的RAM和32 kiB的flash。而您当前使用的系统，即使是一部廉价的手机，可能有百万倍的资源。

Hubris 在我们这个小众操作系统中面临的挑战比其他更多一些，因为使用 Hubris 的固件由许多单独编译的程序（称为*任务*）组成。每个任务都有其自己所需的所有内容，包括通用的标准库代码。这意味着我们的系统倾向于具有比其他系统更高的资源需求（尽管并不多到你可能期望的程度 —— 这将是另一篇文章的主题）。

我们使用硬件内存保护单元将任务彼此隔离，以防止它们相互崩溃或损坏。尽管如此，这也给我们的 RAM 和闪存需求增加了一些压力。在我们主要使用的 ARM 微控制器上运行 Hubris —— Cortex-M 家族的较老成员，也就是 ARMv7-M 架构 —— 任何受保护的内存区域都必须是*二的幂*大小，并根据其大小对齐。这意味着如果你当前有一个大小为 1024 字节的区域，而你需要一个额外的字节，你不能简单地将它增长到 1025 字节 —— 不管你喜不喜欢，它现在是 2048 字节。

最初，Hubris 使用一个内存保护区域来存放任务的 RAM，另一个用于存放其闪存。简单，但浪费。这鼓励了[碎片化](https://zh.wikipedia.org/wiki/%E7%A2%8E%E7%89%87%E5%8C%96_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))，实际上意味着通常存在未使用的 RAM 和闪存，它们之间的对齐并不完美。这些未使用的内存基本上是浪费的。当你一开始就不够用的时候，这真的很令人沮丧！

我的同事 [Matt Keeter](https://www.mattkeeter.com/blog/) 最近通过使系统更智能来解决了这个问题：现在它尝试使用多个二次幂区域来打包任务。("在可能的情况下"很重要，因为硬件限制每个任务总共不能超过八个区域。) 在我们的一些固件镜像中，这节省了 30% 的 RAM！我们最小的设备从以前几乎被挤满了以至于我经常需要对代码进行优化，变成了有多余空间可用。

这太令人兴奋了，他已经写了[一篇完整的文章](https://www.mattkeeter.com/blog/2024-03-25-packing/)讲解这个。但这与我们的主题有什么关系？我马上会解释。但首先：

## 关键线索

Arjen 拿起了谦卑（[Humility](https://www.example.org/humility)），我们的 Hubris 调试器，轻轻探查了失败的网络开关。负责电源顺序的服务处理器看起来是活跃且运行良好，所以硬件问题不太可能。

当我们想要了解运行中的 Hubris 系统状态时，我们通常会首先使用的命令是 `humility tasks`。这会打印出在处理器上运行的任务列表，以及它们的状态信息。当 Arjen 运行 `humility tasks` 时，特别引人注目的是 `sequencer` 任务的一行，这个任务负责电源顺序，状态如下：

```
mem fault (precise: 0x801bffd) in syscall (was: wait: reply from i2c_driver/gen0) 
```

这个任务还表明，它已经重新启动了115次。由于我们几乎只在任务崩溃时重新启动它们，这表明这个故障 — 无论是什么！ — 每次时序器试图启动系统时都会发生。

因此，任务被杀死了。但是是谁扣动了扳机？

答案涉及Hubris IPC的一个重要方面。

## 在Hubris IPC中跨任务扩展Rust借用

Hubris任务可以使用*消息*在进程间通信方案或IPC中相互通信。每个消息看起来和行为都非常像一个函数调用：发送消息的任务停止，接收它的任务控制CPU，并最终返回一些结果，导致发送方重新唤醒。

我们选择这个方案有很多原因 — 毕竟，还有很多其他选择！ — 但其中一个最有用的原因之一是它与Rust的资源所有权模型非常兼容。正如一个函数可以向其调用的函数借用一些它控制的内存，并在函数返回时可靠地收回所有权一样，Hubris上的任务可以向另一个任务借用一些其内存以及一个IPC消息。

这个特性在基于Hubris的固件中被广泛使用。例如，希望与I2C设备交互的任务将它们的内存部分借给I2C总线驱动程序，然后在原地读取和/或写入它们。这样一来，总线驱动程序本身就不需要内部的缓冲池或类似的资源，并且减少了数据从一个地方移动到另一个地方所需的复制次数。

如果实现不正确，这也是潜在的安全漏洞。Hubris的可靠性很大程度上来自于任务的*隔离*；任务不共享任何内存，因此一个任务可以在其自己的空间中做任意愚蠢的事情而不会伤害其他任务。因此，通过IPC借用内存不会让任务突破其隔离的容器是非常重要的。

因此，试图借用实际上*不拥有*的内存是不好的。具体来说，Hubris内核禁止这样做。

如果调用者试图向服务器借用它无法访问的内存，一旦发现这一点，内核会向服务器提供一个道歉性错误代码，而客户端会收到一个故障。对服务器来说，这永远不是致命的；对客户端来说，这总是致命的。我们假设访问违规表明发送任务中存在错误、损坏或利用漏洞，因此我们立即关闭它，而不给它回应的机会。

当内核执行此操作时，它会记录有关触发事件的信息，这（当格式化为人类可读格式时）产生了类似Arjen在时序器任务上找到的状态。让我们来详细看看：

```
mem fault (precise: 0x801bffd) in syscall (was: wait: reply from i2c_driver/gen0) 
```

这意味着：

+   `mem fault`，因为任务由于错误处理内存而出现故障；

+   `precise`，因为我们可以确定处理错误的具体地址；

+   `in syscall`，因为在发生故障时任务实际上并未*运行*；

+   `was: wait: reply from i2c_driver/gen0`，因为在故障发生时，任务不是在运行，而是在等待来自其发送给I2C驱动程序的消息的回复。我们总是尝试记录故障发生*之前*的任务状态，以帮助调试。

（如果您感兴趣，`gen0`表示`i2c_driver`位于第0代，这意味着它从未崩溃过。`sequencer`位于第115代！）

内核区分*真实*故障和*合成*故障。真实故障发生在任务做了简单且错误的事情时，比如解引用空指针，或者试图写入其代码区域。真实故障由硬件（在本例中是内存保护单元）响应任务执行的操作而生成。因此，它们只能在任务实际运行并执行错误操作时发生。

与*硬件*规则不同，合成故障表示*软件*规则的违反。处理器没有“IPC”或“跨任务借用内存”的概念，这些都是Hubris添加到系统中的概念。它们有自己的规则，如果任务违反了这些规则，我们将其视为空指针解引用或其他“真实”硬件故障 — 只是使用了标记它为合成故障的不同故障信息集。

因此，从这份相当密集的状态报告中，我们学到了以下几点：

+   `sequencer`任务违反了内核对内存访问的规则。

+   它在地址`0x801bffd`处执行了此操作，这是处理器中闪存中的一个不寻常但有效的地址。

+   它是作为发送给I2C驱动程序的IPC的一部分做的。

这看起来真的很糟糕！内存访问违规通常表示非常严重的程序错误或数据损坏。尽管这个任务最近没有做过太多更改，但在序列控制器任务中发生了这种情况，这表明我们可能存在某种长期隐藏的数据损坏 bug！

这将是非常不寻常的 — 因为我们的固件几乎完全是安全的Rust，数据损坏 bug 在我们的系统中极其罕见。但所有迹象都指向这里存在数据损坏。

…或者它们？

## 当特性攻击

报告的内存违规地址是`0x801bffd`。

当阿尔杰为了帮助我而叫我过去时，这看起来很奇怪。这是一个有效的闪存地址，没错，但它比一个2的幂次方边界低三个字节。我们知道这不是地址计算中意外整数溢出的结果，因为Hubris系统启用了运行时整数溢出检查 — 任务会崩溃并报告问题。

就在这时，我想起了马特的打包更改。

请回忆，我们处理器上的MPU要求内存区域大小为2的幂次方并且对齐。我使用`humility mem`打印了镜像的内存布局，果然，在`0x801c000`结束了一个区域，并且在同一地址开始了另一个区域。

它们都属于*同一个任务*。

```
LOW         HIGH           SIZE ATTR   ID TASK 0x08018000 - 0x0801bfff   16kiB r-x--- 17 sequencer 0x0801c000 - 0x0801dfff    8kiB r-x--- 17 sequencer 
```

一切都很好，除非它不好。

访问权限检查代码是Hubris内核中最重要的安全关键部分之一。我们尽量保持最重要的代码尽可能简单。正如我在上面提到的，Hubris早期 —— 就是我编写内核这部分时 —— 任务有一个用于RAM和一个用于Flash的单一区域，就是这样。

我简化了内核检查代码以反映这一点。它是：

```
self.region_table().iter().any(|region| {  region.covers(slice) && region.attributes.contains(desired) && !region.attributes.intersects(forbidden) }) 
```

访问只有在任务的区域表中存在任何单一区域时才被允许。

1.  完全覆盖了被借出的内存片段，

1.  具备了所有所需的属性（例如，如果IPC要求可写，则该内存是可写的），以及

1.  没有任何“禁止”属性，比如包含内存映射寄存器或用于硬件DMA。 (这种内存目前不能被借出，原因微妙，超出本文的范围。)

在编写那段代码时，它是正确的，但它体现了一个假设，即任何借出的内存都能适合*一个*区域。

当Matt实施任务打包时，这种假设立即变得过时，但我们没有注意到。这段代码仍然简单易读，但现在也*是错误的*。

关键是，此代码仅用于检查借出的内存。运行程序的正常访问直接由硬件内存保护单元检查，而硬件没有这个漏洞。这意味着任务可能根本没有任何问题访问跨越此区域边界的内存…直到它尝试借出它。

## 两个无辜的特性如何合谋杀死网络交换机

在我们的构建系统中，任务打包操作*机会主义*。因为MPU硬件限制每个任务最多8个区域，并且因为许多任务代表硬件驱动程序，其中一些驱动可以通过其中一些区域访问各种内存映射寄存器，我们并不总是有足够的8个区域表中的剩余区域槽位来聪明地布局任务。

但每当我们*可以*时，我们尝试使用多个区域来打包任务。

这的净效果是现在在任务Flash和RAM区域的中间引入了区域边界。关键是，它们出现在*任务作者自身难以预测的地方*。内存中任务的布局以及边界位置的出现，取决于每个任务所需的大小。

这意味着，如果任务A中一个明显无害的变更，稍微改变了任务A的大小，现在可能会移动MPU区域边界在不相关的任务B中的位置。

现在很明显，这种行为是有问题的。显然，当你添加一些调试代码时，偶发的崩溃就会消失，这是*最糟糕的一种*崩溃，但这正是我们面对的情况 —— 因为向系统添加任何代码都会改变分配决策和区域边界，潜在地激怒内核。

Matt立即关闭了构建系统中的任务打包功能，使得Arjen可以构建出一个工作的固件镜像，并继续他的网络交换机黑客活动。同时，我[开始撰写关于一个缺陷报告的分析](https://github.com/oxidecomputer/hubris/issues/1672)，并准备面对我四年前无意中创造的这个杀手。

## 呼叫是从屋内发出的！

由于内核现在正试图通过误导的方式来执行内存保护，因此内存保护算法需要更改。以前吸引人的*简化*现在成了*过度简化*。

算法的基本*意图*，自我在2020年最初编写时保持不变：

1.  让任务通过消息指定它们想要借用的内存段。

1.  要求任务*确实具有*它声称拥有的那些内存的访问权限。例如，如果尝试借用一些可写内存，它最好能够自己写入内存！否则，机制可能会让任务获取它们不应该具有的权限。

唯一不同的是，现在我们需要容忍借用的内存跨越MPU区域，只要这些区域正好相邻。

[替代算法](https://github.com/oxidecomputer/hubris/blob/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6/sys/kerncore/src/lib.rs#L103)比原来复杂得多，因为它努力在区域表上执行单次遍历。在Hubris中，我们努力不暴露*由任务控制的时间复杂度*的操作。我们做得不完美，但我们努力。因此，对我来说，算法的性能仅取决于*区域表*的大小 —— 固定为8 —— 而不是被借用内存的数量。如果您事先知道表按排序地址顺序排列，可以在一次遍历中完成此操作；我修改了构建系统以确保这一点始终成立。如果您想要详细了解，可以阅读[提交记录](https://github.com/oxidecomputer/hubris/commit/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6#diff-0270185909262248f95c960a9fdd6074669172623c61f59781ee47b50ddc9c69R156)，但重要的是：

```
 regions.sort_by_key(|i| region_table.get_index(*i).unwrap().1.base); 
```

…添加到内核的`build.rs`文件中。

因为新算法更复杂，我的同事[Eliza Weissman](https://elizas.website/)推动我将其从核心Hubris内核中分离出来，放入[一个更可移植的crate](https://github.com/oxidecomputer/hubris/tree/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6/sys/kerncore)，这样可以更容易进行单元测试。目前已对我们最关注的边界情况进行了单元测试；按照Kent Beck的话说，我们计划再添加几个测试，直到"恐惧转为无聊"。

当我说代码“更加复杂”时，我是指相对于Hubris原始的执行相同功能的代码而言；它仍然比大多数操作系统中等效的代码要简单得多。以下是所有内容，包括原始的注释。（请注意，`slice`在这里不是内核中的Rust切片，而是表示地址和大小的*任务建议切片*的结构体。）

```
let mut scan_addr = slice.base_addr(); let end_addr = slice.end_addr();   for region in table {  if region.contains(scan_addr) {  if !region_ok(region) {   break;  }   if end_addr <= region.end_addr() {    return true;  }    scan_addr = region.end_addr();  } else if region.base_addr() > scan_addr {    break;  } }   false 
```

有了这段新代码，我们可以重新启用任务打包，而不会将潜在的问题交给任务开发人员。

总的来说，从阿尔延注意到网络交换机故障到内核错误修复，大约已经过去了三个小时。第二天早上我对单元测试进行了修改。

## 使用Hubris失败

对我来说，这个故事有趣的地方是没有发生的事情。更具体地说，系统失败的方式，以及它没有失败的方式。

我们从“网络交换机无法使用新固件开机”到两位分别位于3000英里之外的工程师分析失败快照，再到修复内核错误，大约用了三个小时。在其他固件中，我很容易花费更长的时间来追踪*单个*内存损坏错误。我认为差异在于以下几点。

**故障隔离。** 我们在非常复杂的硬件上电顺序期间遇到了崩溃。但只有系统的一部分崩溃了。网络交换机固件由23个隔离的组件（任务）组成。其中一些在它们的生命周期中的各个时刻都依赖于电源顺序，当然——电源顺序非常重要！——但大部分时间它们通过*一百一十五次崩溃和重新启动尝试*继续工作。这包括：

+   系统内固件更新系统。

+   IP网络堆栈提供管理和控制接口。

+   多个网络服务，从基本的`echo`协议实现，直至我们的机架控制面板接口。

+   I2C、SMBus和PMBus到所有传感器、风扇和监视系统资源使用和物理健康的杂项设备。

+   驱动程序支持32个位于交换机正面的QSFP 100G光纤收发器。

…还有更多。它们之所以能继续工作，是因为Hubris提供的故障隔离，在这里表现出两种方式。首先，定序任务能够崩溃而不会影响任何其他任务、硬件外围设备或内核的状态。其次，Hubris的IPC机制专门设计为假设其他任务可能会失败，并允许标记为“幂等”的操作透明地重试，让客户端能够与崩溃的服务器解耦。

**向安全失败。** 在 Hubris 中，无论是实现还是 API，都试图维持*单边错误* — 阻止某些正确的程序，而不是允许某些不正确的程序。原始的内存访问检查算法会阻止正确程序的访问，*而不是*接受错误或恶意程序的无效访问。这意味着这是一个罕见的内核内存访问检查错误，没有安全影响。我们试图在整个堆栈中保持这一点，通过全面地将所有输入解析为不受信任的内容，并使任何未定义的使用成为故障。因此，当系统失败时，它倾向于以不可利用的方式失败。

**更安全的共享内存。** 由于我们设计的 IPC 内存借用机制，尽管时序任务和 I2C 驱动器在时序任务崩溃时有效地共享内存，但 I2C 驱动器不会有损坏的风险，并且可以继续其业务。（最终它从未重新启动。）这是因为我们假设作为服务器的任务（比如这里的 I2C 驱动器）通常会为多个客户提供服务，因此需要尽可能做得对客户的任意错误都足够强健。包括在这种情况下（表面上的）内存访问违规。

**内核调试器的代码签名。** 我的同事 Bryan Cantrill 在我编写即将成为 Hubris 内核的代码的同时，编写了成为我们调试器 Humility 的代码。这两个程序一起成长和变化，我也希望没有其他方式。由于 Humility，Arjen 能够在几分钟内识别出崩溃代码（到行号），并且获取服务处理器的自包含快照，他在聊天频道中发布供 Matt 和我查阅。

**固件崩溃转储真的很棒。** 我从未有过物理访问崩溃的网络交换机，实际上我并不确定它位于国家的哪个位置。这并不重要；Humility 可以在至少有一个人有物理访问权限时转储我们的嵌入式系统的一致快照，而 Hubris 本身将崩溃任务的压缩核心转储记录到 RAM 中，我们可以通过网络检索它们。这意味着我们可以获取崩溃转储，尽管没有可写的持久存储，比如闪存。

**设计和实现的简单性。** Hubris 内核提供的概念非常简单 — 实际上，它们如此简单，以至于我最初担心它们无法用于制作有用的生产固件。（幸运的是我错了！）IPC 机制仅有三种操作，并且没有可选或花哨的部分，因此当故障指向 IPC 时，你可能需要搜索问题的地方并不多。

但是，如果你必须在许多地方搜索问题，Hubris 内核中与架构无关的部分目前有 1,789 行代码。大约相当于这篇帖子的四倍。在紧急情况下，一个人可以阅读整个内核以寻找错误。

我们还没有必须这样做的情况，但知道如果必须的话我们是可以的！

**团队紧密的非层级化整合。** 这不是傲慢的特征，但很难将傲慢与构建它的团队分开。Oxide 的工程团队基本上没有内部的壁垒。我们的文化鼓励开放、好奇和沟通，阻止防御性、帝国主义和守门人行为。我们努力创造和捍卫这种文化，我认为这在我们跨团队边界水平组织解决问题的方式上表现出来。

如果那天我不在办公室，别人也会找到并修复这个 bug — 如果不是我，可能是马特、劳拉·阿博特、伊丽莎、阿尔杰恩、布莱恩或其他几个人之一。对我来说，这真的很重要。他们会毫无畏惧地做到这一点；最多，他们可能做得稍微慢一些，因为我写了最初有 bug 的代码，知道问题出在哪里 — 但并不会慢得太多。保持关键代码简单、注释良好、易于理解和可访问确实有很大好处 — 保持团队文化，*每个人*都能从中受益，这也是一个真正的好处。

顺便说一句，我们需要更多的帮助；在撰写本文时，我们正在招聘更多的软件工程师。详情请参阅[我们网站上的职位描述](https://oxide.computer/careers/software-engineer)。

[#api-design](https://cliffle.com/tags/api-design/) [#dayjob](https://cliffle.com/tags/dayjob/) [#embedded](https://cliffle.com/tags/embedded/) [#rust](https://cliffle.com/tags/rust/) [#security](https://cliffle.com/tags/security/)
