["````\nfac n = if n == 0 \n           then 1\n           else n * fac (n-1)\n\n````", "````\nfac = (\\(n) ->\n        (if ((==) n 0)\n            then 1\n            else ((*) n (fac ((-) n 1)))))\n\n````", "````\nfac  0    =  1\nfac (n+1) = (n+1) * fac n\n\n````", "````\nfac 0 = 1\nfac n = n * fac (n-1)\n\n````", "````\nfac n = foldr (*) 1 [1..n]\n\n````", "````\nfac n = foldl (*) 1 [1..n]\n\n````", "````\n-- using foldr to simulate foldl\n\nfac n = foldr (\\x g n -> g (x*n)) id [1..n] 1\n\n````", "````\nfacs = scanl (*) 1 [1..]\n\nfac n = facs !! n\n\n````", "````\nfac = foldr (*) 1 . enumFromTo 1\n\n````", "````\nfac n = result (for init next done)\n        where init = (0,1)\n              next   (i,m) = (i+1, m * (i+1))\n              done   (i,_) = i==n\n              result (_,m) = m\n\nfor i n d = until d n i\n\n````", "````\nfac n = snd (until ((>n) . fst) (\\(i,m) -> (i+1, i*m)) (1,1))\n\n````", "````\nfacAcc a 0 = a\nfacAcc a n = facAcc (n*a) (n-1)\n\nfac = facAcc 1\n\n````", "````\nfacCps k 0 = k 1\nfacCps k n = facCps (k . (n *)) (n-1)\n\nfac = facCps id\n\n````", "````\ny f = f (y f)\n\nfac = y (\\f n -> if (n==0) then 1 else n * f (n-1))\n\n````", "````\ns f g x = f x (g x)\n\nk x y   = x\n\nb f g x = f (g x)\n\nc f g x = f x g\n\ny f     = f (y f)\n\ncond p f g x = if p x then f x else g x\n\nfac  = y (b (cond ((==) 0) (k 1)) (b (s (*)) (c b pred)))\n\n````", "````\narb = ()    -- \"undefined\" is also a good RHS, as is \"arb\" :)\n\nlistenc n = replicate n arb\nlistprj f = length . f . listenc\n\nlistprod xs ys = [ i (x,y) | x<-xs, y<-ys ]\n                 where i _ = arb\n\nfacl []         = listenc  1\nfacl n@(_:pred) = listprod n (facl pred)\n\nfac = listprj facl\n\n````", "````\n-- a dynamically-typed term language\n\ndata Term = Occ Var\n          | Use Prim\n          | Lit Integer\n          | App Term Term\n          | Abs Var  Term\n          | Rec Var  Term\n\ntype Var  = String\ntype Prim = String\n\n-- a domain of values, including functions\n\ndata Value = Num  Integer\n           | Bool Bool\n           | Fun (Value -> Value)\n\ninstance Show Value where\n  show (Num  n) = show n\n  show (Bool b) = show b\n  show (Fun  _) = \"\"\n\nprjFun (Fun f) = f\nprjFun  _      = error \"bad function value\"\n\nprjNum (Num n) = n\nprjNum  _      = error \"bad numeric value\"\n\nprjBool (Bool b) = b\nprjBool  _       = error \"bad boolean value\"\n\nbinOp inj f = Fun (\\i -> (Fun (\\j -> inj (f (prjNum i) (prjNum j)))))\n\n-- environments mapping variables to values\n\ntype Env = [(Var, Value)]\n\ngetval x env =  case lookup x env of\n                  Just v  -> v\n                  Nothing -> error (\"no value for \" ++ x)\n\n-- an environment-based evaluation function\n\neval env (Occ x) = getval x env\neval env (Use c) = getval c prims\neval env (Lit k) = Num k\neval env (App m n) = prjFun (eval env m) (eval env n)\neval env (Abs x m) = Fun  (\\v -> eval ((x,v) : env) m)\neval env (Rec x m) = f where f = eval ((x,f) : env) m\n\n-- a (fixed) \"environment\" of language primitives\n\ntimes = binOp Num  (*)\nminus = binOp Num  (-)\nequal = binOp Bool (==)\ncond  = Fun (\\b -> Fun (\\x -> Fun (\\y -> if (prjBool b) then x else y)))\n\nprims = [ (\"*\", times), (\"-\", minus), (\"==\", equal), (\"if\", cond) ]\n\n-- a term representing factorial and a \"wrapper\" for evaluation\n\nfacTerm = Rec \"f\" (Abs \"n\" \n              (App (App (App (Use \"if\")\n                   (App (App (Use \"==\") (Occ \"n\")) (Lit 0))) (Lit 1))\n                   (App (App (Use \"*\")  (Occ \"n\"))\n                        (App (Occ \"f\")  \n                             (App (App (Use \"-\") (Occ \"n\")) (Lit 1))))))\n\nfac n = prjNum (eval [] (App facTerm (Lit n))) \n````", "````\n-- static Peano constructors and numerals\n\ndata Zero\ndata Succ n\n\ntype One   = Succ Zero\ntype Two   = Succ One\ntype Three = Succ Two\ntype Four  = Succ Three\n\n-- dynamic representatives for static Peanos\n\nzero  = undefined :: Zero\none   = undefined :: One\ntwo   = undefined :: Two\nthree = undefined :: Three\nfour  = undefined :: Four\n\n-- addition, a la Prolog\n\nclass Add a b c | a b -> c where\n  add :: a -> b -> c\n\ninstance              Add  Zero    b  b\ninstance Add a b c => Add (Succ a) b (Succ c)\n\n-- multiplication, a la Prolog\n\nclass Mul a b c | a b -> c where\n  mul :: a -> b -> c\n\ninstance                           Mul  Zero    b Zero\ninstance (Mul a b c, Add b c d) => Mul (Succ a) b d\n\n-- factorial, a la Prolog\n\nclass Fac a b | a -> b where\n  fac :: a -> b\n\ninstance                                Fac  Zero    One\ninstance (Fac n k, Mul (Succ n) k m) => Fac (Succ n) m\n\n-- try, for \"instance\" (sorry):\n-- \n--     :t fac four\n\n````", "````\n-- the natural numbers, a la Peano\n\ndata Nat = Zero | Succ Nat\n\n-- iteration and some applications\n\niter z s  Zero    = z\niter z s (Succ n) = s (iter z s n)\n\nplus n = iter n     Succ\nmult n = iter Zero (plus n)\n\n-- primitive recursion\n\nprimrec z s  Zero    = z\nprimrec z s (Succ n) = s n (primrec z s n)\n\n-- two versions of factorial\n\nfac  = snd . iter (one, one) (\\(a,b) -> (Succ a, mult a b))\nfac' = primrec one (mult . Succ)\n\n-- for convenience and testing (try e.g. \"fac five\")\n\nint = iter 0 (1+)\n\ninstance Show Nat where\n  show = show . int\n\n(zero : one : two : three : four : five : _) = iterate Succ Zero\n\n````", "````\n-- (curried, list) fold and an application\n\nfold c n []     = n\nfold c n (x:xs) = c x (fold c n xs)\n\nprod = fold (*) 1\n\n-- (curried, boolean-based, list) unfold and an application\n\nunfold p f g x = \n  if p x \n     then [] \n     else f x : unfold p f g (g x)\n\ndownfrom = unfold (==0) id pred\n\n-- hylomorphisms, as-is or \"unfolded\" (ouch! sorry ...)\n\nrefold  c n p f g   = fold c n . unfold p f g\n\nrefold' c n p f g x = \n  if p x \n     then n \n     else c (f x) (refold' c n p f g (g x))\n\n-- several versions of factorial, all (extensionally) equivalent\n\nfac   = prod . downfrom\nfac'  = refold  (*) 1 (==0) id pred\nfac'' = refold' (*) 1 (==0) id pred\n\n````", "````\n-- (product-based, list) catamorphisms and an application\n\ncata (n,c) []     = n\ncata (n,c) (x:xs) = c (x, cata (n,c) xs)\n\nmult = uncurry (*)\nprod = cata (1, mult)\n\n-- (co-product-based, list) anamorphisms and an application\n\nana f = either (const []) (cons . pair (id, ana f)) . f\n\ncons = uncurry (:)\n\ndownfrom = ana uncount\n\nuncount 0 = Left  ()\nuncount n = Right (n, n-1)\n\n-- two variations on list hylomorphisms\n\nhylo  f  g    = cata g . ana f\n\nhylo' f (n,c) = either (const n) (c . pair (id, hylo' f (c,n))) . f\n\npair (f,g) (x,y) = (f x, g y)\n\n-- several versions of factorial, all (extensionally) equivalent\n\nfac   = prod . downfrom\nfac'  = hylo  uncount (1, mult)\nfac'' = hylo' uncount (1, mult)\n\n````", "````\n-- explicit type recursion based on functors\n\nnewtype Mu f = Mu (f (Mu f))  deriving Show\n\nin      x  = Mu x\nout (Mu x) = x\n\n-- cata- and ana-morphisms, now for *arbitrary* (regular) base functors\n\ncata phi = phi . fmap (cata phi) . out\nana  psi = in  . fmap (ana  psi) . psi\n\n-- base functor and data type for natural numbers,\n-- using a curried elimination operator\n\ndata N b = Zero | Succ b  deriving Show\n\ninstance Functor N where\n  fmap f = nelim Zero (Succ . f)\n\nnelim z s  Zero    = z\nnelim z s (Succ n) = s n\n\ntype Nat = Mu N\n\n-- conversion to internal numbers, conveniences and applications\n\nint = cata (nelim 0 (1+))\n\ninstance Show Nat where\n  show = show . int\n\nzero = in   Zero\nsuck = in . Succ       -- pardon my \"French\" (Prelude conflict)\n\nplus n = cata (nelim n     suck   )\nmult n = cata (nelim zero (plus n))\n\n-- base functor and data type for lists\n\ndata L a b = Nil | Cons a b  deriving Show\n\ninstance Functor (L a) where\n  fmap f = lelim Nil (\\a b -> Cons a (f b))\n\nlelim n c  Nil       = n\nlelim n c (Cons a b) = c a b\n\ntype List a = Mu (L a)\n\n-- conversion to internal lists, conveniences and applications\n\nlist = cata (lelim [] (:))\n\ninstance Show a => Show (List a) where\n  show = show . list\n\nprod = cata (lelim (suck zero) mult)\n\nupto = ana (nelim Nil (diag (Cons . suck)) . out)\n\ndiag f x = f x x\n\nfac = prod . upto\n\n````", "````\n-- explicit type recursion with functors and catamorphisms\n\nnewtype Mu f = In (f (Mu f))\n\nunIn (In x) = x\n\ncata phi = phi . fmap (cata phi) . unIn\n\n-- base functor and data type for natural numbers,\n-- using locally-defined \"eliminators\"\n\ndata N c = Z | S c\n\ninstance Functor N where\n  fmap g  Z    = Z\n  fmap g (S x) = S (g x)\n\ntype Nat = Mu N\n\nzero   = In  Z\nsuck n = In (S n)\n\nadd m = cata phi where\n  phi  Z    = m\n  phi (S f) = suck f\n\nmult m = cata phi where\n  phi  Z    = zero\n  phi (S f) = add m f\n\n-- explicit products and their functorial action\n\ndata Prod e c = Pair c e\n\noutl (Pair x y) = x\noutr (Pair x y) = y\n\nfork f g x = Pair (f x) (g x)\n\ninstance Functor (Prod e) where\n  fmap g = fork (g . outl) outr\n\n-- comonads, the categorical \"opposite\" of monads\n\nclass Functor n => Comonad n where\n  extr :: n a -> a\n  dupl :: n a -> n (n a)\n\ninstance Comonad (Prod e) where\n  extr = outl\n  dupl = fork id outr\n\n-- generalized catamorphisms, zygomorphisms and paramorphisms\n\ngcata :: (Functor f, Comonad n) =>\n           (forall a. f (n a) -> n (f a))\n             -> (f (n c) -> c) -> Mu f -> c\n\ngcata dist phi = extr . cata (fmap phi . dist . fmap dupl)\n\nzygo chi = gcata (fork (fmap outl) (chi . fmap outr))\n\npara :: Functor f => (f (Prod (Mu f) c) -> c) -> Mu f -> c\npara = zygo In\n\n-- factorial, the *hard* way!\n\nfac = para phi where\n  phi  Z             = suck zero\n  phi (S (Pair f n)) = mult f (suck n)\n\n-- for convenience and testing\n\nint = cata phi where\n  phi  Z    = 0\n  phi (S f) = 1 + f\n\ninstance Show (Mu N) where\n  show = show . int\n\n````", "````\nfac n = product [1..n]\n\n````"]