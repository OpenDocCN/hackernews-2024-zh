- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 14:30:03'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:30:03'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Where Is Noether's Principle in Machine Learning?
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诺特定理在机器学习中的位置？
- en: 来源：[https://cgad.ski/blog/where-is-noethers-principle-in-machine-learning.html](https://cgad.ski/blog/where-is-noethers-principle-in-machine-learning.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://cgad.ski/blog/where-is-noethers-principle-in-machine-learning.html](https://cgad.ski/blog/where-is-noethers-principle-in-machine-learning.html)
- en: Where Is Noether's Principle in Machine Learning?
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诺特定理在机器学习中的位置？
- en: '*This post accompanies a [poster](/math/mlss_poster.pdf) presented at the [MLSS
    2024](http://mlss.cc/).*'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文附带了一份 [海报](/math/mlss_poster.pdf)，在 [MLSS 2024](http://mlss.cc/) 上展示。*'
- en: Physics likes optimization! Subject to its boundary conditions, the time evolution
    of a physical system is a critical point for a quantity called an **action.**
    This point of view sets the stage for **Noether's principle**, a remarkable correspondence
    between continuous invariances of the action and conservation laws of the system.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学喜欢优化！在其边界条件下，物理系统的时间演化是一个称为**作用量**的量的临界点。这种观点为**诺特定理**奠定了基础，这是作用量的连续不变性与系统守恒定律之间的显著对应关系。
- en: 'In machine learning, we often deal with discrete "processes" whose control
    parameters are chosen to minimize some quantity. For example, we can see a deep
    residual network as a process where the role of "time" is played by depth. We
    may ask:'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，我们经常处理离散的 "过程"，其控制参数被选择以最小化某些量。例如，我们可以将深度残差网络视为一个过程，其中 "时间" 的角色由深度扮演。我们可能会问：
- en: Does Noether's theorem apply to these processes?
  id: totrans-split-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 诺特定理适用于这些过程吗？
- en: Can we find meaningful conserved quantities?
  id: totrans-split-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能找到有意义的守恒量吗？
- en: 'Our answers: "yes," and "not sure!"'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的答案是："是" 和 "不确定"！
- en: Noether's Principle in Physics
  id: totrans-split-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理学中的诺特定理
- en: In 1630, Fermat observed that the trajectory a beam of light takes through a
    lens is a path of least time. Formally, where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">v(q)</annotation></semantics></math>v(q) gives the
    velocity of light at a point <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">q,</annotation></semantics></math>q,
    a trajectory <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo
    stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">q(t)</annotation></semantics></math>q(t) taken by
    a beam of light between two points <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo
    stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">q(t_0)</annotation></semantics></math>q(t0​) and
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo
    stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">q(t_1)</annotation></semantics></math>q(t1​) will
    be a stationary point for <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo
    stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo><mo>=</mo><msubsup><mo>∫</mo><msub><mi>t</mi><mn>0</mn></msub><msub><mi>t</mi><mn>1</mn></msub></msubsup><mfrac><mn>1</mn><mrow><mi>v</mi><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow></mfrac><mo
    stretchy="false">∥</mo><mover accent="true"><mi>q</mi><mo>˙</mo></mover><mo stretchy="false">∥</mo><mi>d</mi><mi>t</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">S[q] =
    \int_{t_0}^{t_1} \frac{1}{v(q)} \lVert \dot q \rVert \, dt,</annotation></semantics></math>S[q]=∫t0​t1​​v(q)1​∥q˙​∥dt,
    in the sense that <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>ϵ</mi></mrow></mfrac><mi>S</mi><mo
    stretchy="false">[</mo><mi>q</mi><mo>+</mo><mi>ϵ</mi><mi>h</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\frac{d}{d \epsilon} S[q + \epsilon h] = 0</annotation></semantics></math>dϵd​S[q+ϵh]=0
    for any "perturbation" <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation
    encoding="application/x-tex">h</annotation></semantics></math>h verifying <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">h(t_0)
    = h(t_1) = 0.</annotation></semantics></math>h(t0​)=h(t1​)=0. Furthermore, this
    condition turns out to characterize the paths that light can take.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 1630年，费马观察到光束通过透镜的轨迹是最短时间的路径。形式上，其中<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">v(q)</annotation></semantics></math>v(q)给出了点<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">q,</annotation></semantics></math>q处光的速度，轨迹<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>t</mi><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(t)</annotation></semantics></math>q(t)由光束在两点<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(t_0)</annotation></semantics></math>q(t0​)和<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(t_1)</annotation></semantics></math>q(t1​)之间取得，将是<math
    xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo
    stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo><mo>=</mo><msubsup><mo>∫</mo><msub><mi>t</mi><mn>0</mn></msub><msub><mi>t</mi><mn>1</mn></msub></msubsup><mfrac><mn>1</mn><mrow><mi>v</mi><mo
    stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow></mfrac><mo
    stretchy="false">∥</mo><mover accent="true"><mi>q</mi><mo>˙</mo></mover><mo stretchy="false">∥</mo><mi>d</mi><mi>t</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">S[q] =
    \int_{t_0}^{t_1} \frac{1}{v(q)} \lVert \dot q \rVert \, dt,</annotation></semantics></math>S[q]=∫t0​t1​​v(q)1​∥q˙​∥dt，在这个意义上<math
    xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>ϵ</mi></mrow></mfrac><mi>S</mi><mo
    stretchy="false">[</mo><mi>q</mi><mo>+</mo><mi>ϵ</mi><mi>h</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\frac{d}{d \epsilon} S[q + \epsilon h] = 0</annotation></semantics></math>dϵd​S[q+ϵh]=0对于任何“扰动”<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation
    encoding="application/x-tex">h</annotation></semantics></math>h验证<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo
    stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo
    stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0.</mn></mrow><annotation
    encoding="application/x-tex">h(t_0) = h(t_1) = 0.</annotation></semantics></math>
- en: In fact, all fundamental physical theories can be written in the form <math
    xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>δ</mi><mi>S</mi><mo>=</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\delta S = 0</annotation></semantics></math>δS=0
    for a suitable "action" <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">S,</annotation></semantics></math>S,
    where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation
    encoding="application/x-tex">\delta</annotation></semantics></math>δ denotes a
    (variational) derivative with respect to the process trajectory. Such an equation
    is called a **stationary action principle**.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，所有基础物理理论都可以写成形式为 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>δ</mi><mi>S</mi><mo>=</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\delta S = 0</annotation></semantics></math> δS=0
    的适当“作用量” <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">S,</annotation></semantics></math>
    S，其中 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation
    encoding="application/x-tex">\delta</annotation></semantics></math> δ 表示对过程轨迹的（变分）导数。这样的方程称为**稳定作用量原理**。
- en: Given a physical system, a function <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo
    stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mover accent="true"><mi>q</mi><mo>˙</mo></mover><mo
    separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mo>…</mo><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">F(q, \dot q, t, \dots)</annotation></semantics></math>F(q,q˙​,t,…)
    of the system state is called a conserved quantity when its value is constant
    over any given physical trajectory. For dynamics expressed by a stationary action
    principle, **Noether's principle** gives a remarkable correspondence between **conserved
    quantities** and certain **invariances** of the action <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">S.</annotation></semantics></math>S.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 针对一个物理系统，系统状态的函数 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo
    stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mover accent="true"><mi>q</mi><mo>˙</mo></mover><mo
    separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mo>…</mo><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">F(q, \dot q, t, \dots)</annotation></semantics></math>
    F(q,q˙​,t,…) 被称为在任何给定的物理轨迹上其值保持恒定时的守恒量。对于通过稳定作用量原理表达的动力学，**诺特定理**提供了作用量 <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi mathvariant="normal">.</mi></mrow><annotation
    encoding="application/x-tex">S.</annotation></semantics></math> S 的某些**不变量**与**守恒量**之间显著的对应关系。
- en: For the purposes of this article, we will not give more details on Noether's
    principle. The interested reader is invited to seek out Chapter 4 of Arnold's
    *Mathematical Methods of Classical Mechanics* for a concise description from the
    point of view of Lagrangian mechanics. (For a much more complete reference, including
    the more subtle "off-shell" version applicable to local gauge transformations,
    see Chapter 5 of Olver's *Application of Lie Groups to Differential Equations*.)
    However, as a guide for the imagination, we illustrate two examples.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本文，我们不会详细介绍**诺特定理**。有兴趣的读者可以查阅阿诺德的《经典力学的数学方法》第四章，从拉格朗日力学的角度得到简明的描述。（更详细的参考资料，包括适用于局部规范变换的更微妙的“离壳”版本，请参阅奥尔弗的《李群在微分方程中的应用》第五章。）不过，作为想象的指南，我们举例说明两个例子。
- en: In physics, the famous two-body problem is described by the action <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="block"><semantics><mrow><mi>S</mi><mo>=</mo><mo>∫</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo
    stretchy="false">(</mo><msub><mi>m</mi><mn>1</mn></msub><msubsup><mover accent="true"><mi>q</mi><mo>˙</mo></mover><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msub><mi>m</mi><mn>2</mn></msub><msubsup><mover
    accent="true"><mi>q</mi><mo>˙</mo></mover><mn>2</mn><mn>2</mn></msubsup><mo stretchy="false">)</mo><mo>−</mo><mfrac><mrow><msub><mi>m</mi><mn>1</mn></msub><msub><mi>m</mi><mn>2</mn></msub><mi>G</mi></mrow><mrow><mo
    stretchy="false">∥</mo><msub><mi>q</mi><mn>1</mn></msub><mo>−</mo><msub><mi>q</mi><mn>2</mn></msub><mo
    stretchy="false">∥</mo></mrow></mfrac><mi>d</mi><mi>t</mi><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">S = \int \frac{1}{2} (m_1 \dot q_1^2 + m_2 \dot q_2^2)
    - \frac{m_1 m_2 G}{\lVert q_1 - q_2 \rVert} \, dt,</annotation></semantics></math>S=∫21​(m1​q˙​12​+m2​q˙​22​)−∥q1​−q2​∥m1​m2​G​dt,
    where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub></mrow><annotation
    encoding="application/x-tex">q_1</annotation></semantics></math>q1​ and <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>2</mn></msub></mrow><annotation
    encoding="application/x-tex">q_2</annotation></semantics></math>q2​ are the positions
    of our two bodies and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>1</mn></msub></mrow><annotation
    encoding="application/x-tex">m_1</annotation></semantics></math>m1​ and <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>2</mn></msub></mrow><annotation
    encoding="application/x-tex">m_2</annotation></semantics></math>m2​ are their
    masses. The integrand does not change if the trajectories <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">q_1(t)</annotation></semantics></math>q1​(t) and
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">q_2(t)</annotation></semantics></math>q2​(t) are
    translated or rotated, so these transformations are *invariants* for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">S.</annotation></semantics></math>S.
    Applying Noether's theorem gives us three conserved quantities—one for each degree
    of freedom in our group of transformations—which turn out to be horizontal, vertical,
    and angular momentum.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理学中，著名的两体问题由动作<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo>=</mo><mo>∫</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo
    stretchy="false">(</mo><msub><mi>m</mi><mn>1</mn></msub><msubsup><mover accent="true"><mi>q</mi><mo>˙</mo></mover><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msub><mi>m</mi><mn>2</mn></msub><msubsup><mover
    accent="true"><mi>q</mi><mo>˙</mo></mover><mn>2</mn><mn>2</mn></msubsup><mo stretchy="false">)</mo><mo>−</mo><mfrac><mrow><msub><mi>m</mi><mn>1</mn></msub><msub><mi>m</mi><mn>2</mn></msub><mi>G</mi></mrow><mrow><mo
    stretchy="false">∥</mo><msub><mi>q</mi><mn>1</mn></msub><mo>−</mo><msub><mi>q</mi><mn>2</mn></msub><mo
    stretchy="false">∥</mo></mrow></mfrac><mi>d</mi><mi>t</mi><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">S = \int \frac{1}{2} (m_1 \dot q_1^2 + m_2 \dot q_2^2)
    - \frac{m_1 m_2 G}{\lVert q_1 - q_2 \rVert} \, dt,</annotation></semantics></math>S=∫21​(m1​q˙​12​+m2​q˙​22​)−∥q1​−q2​∥m1​m2​G​dt，其中<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub></mrow><annotation
    encoding="application/x-tex">q_1</annotation></semantics></math>q1​和<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>2</mn></msub></mrow><annotation
    encoding="application/x-tex">q_2</annotation></semantics></math>q2​是我们两个物体的位置，<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>1</mn></msub></mrow><annotation
    encoding="application/x-tex">m_1</annotation></semantics></math>m1​和<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>2</mn></msub></mrow><annotation
    encoding="application/x-tex">m_2</annotation></semantics></math>m2​是它们的质量。如果轨迹<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">q_1(t)</annotation></semantics></math>q1​(t)和<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">q_2(t)</annotation></semantics></math>q2​(t)被平移或旋转，积分因子不变，因此这些变换对于<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi mathvariant="normal">.</mi></mrow><annotation
    encoding="application/x-tex">S.</annotation></semantics></math>S是*不变量*。应用诺特定理给出了三个守恒量，分别对应我们变换群中的每个自由度，它们被证明是水平、垂直和角动量。
- en: In the illustration above, we consider two bodies with equal mass. Conservation
    of linear momentum means that the sum of the arrows is constant, while conservation
    of angular momentum means that the sum of highlighted areas is constant.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的插图中，我们考虑了两个质量相等的物体。线动量守恒意味着箭头的总和是恒定的，而角动量守恒意味着突出显示的区域的总和是恒定的。
- en: For a less familiar example of a conservation law, consider a ray of light passing
    through a rotationally symmetric lens. Rotating a trajectory about the center
    of the lens does not affect the time needed to traverse it. What conserved quantity
    does this symmetry produce?
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个不太熟悉的守恒定律的例子，考虑光线穿过一个具有旋转对称透镜的情况。围绕透镜中心旋转轨迹不影响穿过轨迹所需的时间。这种对称性产生了什么守恒量？
- en: At each instant, let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation
    encoding="application/x-tex">p</annotation></semantics></math>p be a vector pointing
    in the direction of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover
    accent="true"><mi>q</mi><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">\dot
    q</annotation></semantics></math>q˙​ with norm equal to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi
    mathvariant="normal">/</mi><mi>v</mi><mo stretchy="false">(</mo><mi>q</mi><mo
    stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">1/v(q).</annotation></semantics></math>1/v(q).
    (We've drawn this vector in the widget above.) This vector can be seen as the
    gradient of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation
    encoding="application/x-tex">S</annotation></semantics></math>S with respect to
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo
    separator="true">;</mo></mrow><annotation encoding="application/x-tex">q;</annotation></semantics></math>q;
    it gives the marginal price we would pay to move <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation
    encoding="application/x-tex">q</annotation></semantics></math>q in a certain direction
    at a particular instant. Noether's principle tells us that <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="block"><semantics><mrow><mi>p</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mi>c</mi><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p \wedge
    (q - c)</annotation></semantics></math>p∧(q−c) is conserved, where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation
    encoding="application/x-tex">c</annotation></semantics></math>c is the center
    of the lens. In our illustration, this conserved quantity is represented by the
    area of the triangle.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每时每刻，让 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation
    encoding="application/x-tex">p</annotation></semantics></math>p 是一个指向 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover
    accent="true"><mi>q</mi><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">\dot
    q</annotation></semantics></math>q˙​ 方向的向量，其范数等于 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi
    mathvariant="normal">/</mi><mi>v</mi><mo stretchy="false">(</mo><mi>q</mi><mo
    stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">1/v(q).</annotation></semantics></math>1/v(q)。（我们在上面的小部件中绘制了这个向量。）这个向量可以看作是
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation
    encoding="application/x-tex">S</annotation></semantics></math>S 对 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo
    separator="true">;</mo></mrow><annotation encoding="application/x-tex">q;</annotation></semantics></math>q
    的梯度，它给出了我们在特定时刻沿特定方向移动 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation
    encoding="application/x-tex">q</annotation></semantics></math>q 所需支付的边际价格。诺特定理告诉我们，守恒量是
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo>∧</mo><mo
    stretchy="false">(</mo><mi>q</mi><mo>−</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">p \wedge (q - c)</annotation></semantics></math>p∧(q−c)，其中
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation
    encoding="application/x-tex">c</annotation></semantics></math>c 是透镜的中心。在我们的插图中，这个守恒量被表示为三角形的面积。
- en: 'Noether''s Principle in ML: A Toy Example'
  id: totrans-split-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习中的诺特定理：一个玩具例子
- en: In machine learning, we routinely deal with processes whose control parameters
    are chosen to minimize some quantity. For example, say we are trying to solve
    a supervised learning problem by choosing parameters <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo
    separator="true">,</mo><msub><mi>θ</mi><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">(\theta_1, \dots, \theta_N)</annotation></semantics></math>(θ1​,…,θN​)
    so that a composition <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo>=</mo><msub><mi>φ</mi><mi>N</mi></msub><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mi>N</mi></msub><mo stretchy="false">)</mo><mo>∘</mo><mo>⋯</mo><mo>∘</mo><msub><mi>φ</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∘</mo><msub><mi>φ</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">F = \varphi_N(\theta_N) \circ \dots \circ \varphi_2(\theta_2)
    \circ \varphi_1(\theta_1)</annotation></semantics></math>F=φN​(θN​)∘⋯∘φ2​(θ2​)∘φ1​(θ1​)
    minimizes some expected loss <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo
    stretchy="false">[</mo><mi>L</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo
    stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E[L(F(x),
    y)]</annotation></semantics></math>E[L(F(x),y)] with respect to some random variables
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">y.</annotation></semantics></math>y.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，我们经常处理那些其控制参数被选择来最小化某些量的过程。例如，假设我们正在尝试通过选择参数 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo
    separator="true">,</mo><msub><mi>θ</mi><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">(\theta_1, \dots, \theta_N)</annotation></semantics></math>
    (θ1​,…,θN​) 来解决一个监督学习问题，以便一个组合 <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="block"><semantics><mrow><mi>F</mi><mo>=</mo><msub><mi>φ</mi><mi>N</mi></msub><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mi>N</mi></msub><mo stretchy="false">)</mo><mo>∘</mo><mo>⋯</mo><mo>∘</mo><msub><mi>φ</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∘</mo><msub><mi>φ</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">F = \varphi_N(\theta_N) \circ \dots \circ \varphi_2(\theta_2)
    \circ \varphi_1(\theta_1)</annotation></semantics></math> F=φN​(θN​)∘⋯∘φ2​(θ2​)∘φ1​(θ1​)
    以最小化某些期望损失 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo
    stretchy="false">[</mo><mi>L</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo
    stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E[L(F(x),
    y)]</annotation></semantics></math> E[L(F(x),y)] 相对于一些随机变量 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math> x 和 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">y.</annotation></semantics></math>
- en: Let's view the sequence of random variables <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left"
    columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>x</mi><mn>0</mn></msub></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><msub><mi>x</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>φ</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo
    stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mi><mi mathvariant="normal">⋮</mi><mpadded
    voffset="0em"><mspace mathbackground="black"></mspace></mpadded></mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><msub><mi>x</mi><mi>N</mi></msub></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>φ</mi><mi>N</mi></msub><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mi>N</mi></msub><mo stretchy="false">)</mo><mo
    stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mo
    stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    x_0 &= x \\ x_1 &= \varphi_1(\theta_1)(x_0) \\ & \vdots \\ x_N &= \varphi_N(\theta_N)(x_{N
    - 1}) \end{align*}</annotation></semantics></math>x0​x1​xN​​=x=φ1​(θ1​)(x0​)⋮=φN​(θN​)(xN−1​)​
    as the states of a discrete-time "process." After optimization, the trajectory
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo
    separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, \dots,
    x_N)</annotation></semantics></math>(x0​,…,xN​) is approximately a **critical
    point for a loss function**. As we saw above, physical trajectories are also characterized
    as critical points of certain functions. Can we think about our trajectory of
    intermediate values <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">x_i</annotation></semantics></math>xi​ from a physical
    point of view?
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看随机变量序列<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable
    rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><msub><mi>x</mi><mn>0</mn></msub></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><msub><mi>x</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>φ</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo
    stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mi><mi mathvariant="normal">⋮</mi><mpadded
    voffset="0em"><mspace mathbackground="black"></mspace></mpadded></mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><msub><mi>x</mi><mi>N</mi></msub></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>φ</mi><mi>N</mi></msub><mo
    stretchy="false">(</mo><msub><mi>θ</mi><mi>N</mi></msub><mo stretchy="false">)</mo><mo
    stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mo
    stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    x_0 &= x \\ x_1 &= \varphi_1(\theta_1)(x_0) \\ & \vdots \\ x_N &= \varphi_N(\theta_N)(x_{N
    - 1}) \end{align*}</annotation></semantics></math>作为离散时间"过程"的状态。在优化后，轨迹<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>…</mo><mo
    separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">(x_0, \dots, x_N)</annotation></semantics></math>(x0​,…,xN​)大致是一个**损失函数的临界点**。正如我们上面看到的，物理轨迹也被表征为某些函数的临界点。我们可以从物理角度思考中间值轨迹<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">x_i</annotation></semantics></math>xi​吗？
- en: Of course, several things are different. Most obviously, "time" is now discrete
    rather than continuous. Furthermore, our trajectory of intermediate values is
    constrained in a different way. In physics, we specified boundary conditions and
    allowed the intermediate states of the process to vary, but in machine learning
    we specify an initial condition and constrain the trajectory <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>…</mo><mo
    separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">(x_0, \dots, x_N)</annotation></semantics></math>(x0​,…,xN​)
    to be driven by some parameters <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>i</mi></msub><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\theta_i.</annotation></semantics></math>θi​.
    Fortunately, Noether's principle continues to apply!
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有几件事情是不同的。最明显的是，“时间”现在是离散的而不是连续的。此外，我们的中间值轨迹以不同的方式受限。在物理学中，我们指定了边界条件并允许过程的中间状态变化，但在机器学习中，我们指定了一个初始条件并约束轨迹
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo
    separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, \dots,
    x_N)</annotation></semantics></math>(x0​,…,xN​) 由一些参数 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>i</mi></msub><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\theta_i.</annotation></semantics></math>θi​
    驱动。幸运的是，诺特定理仍然适用！
- en: To see how, let's consider a toy example that's easy to visualize. First, we'll
    define a family of "deformations" of the plane, as depicted below. (Click the
    screen or drag the sldier to change the parameters of the deformation.)
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看清楚，让我们考虑一个容易可视化的玩具例子。首先，我们将定义平面的一组“变形”，如下所示。（点击屏幕或拖动滑块以更改变形的参数。）
- en: Next, we'll set up some simple optimization problems. In each case, we'll try
    to find a sequence of small deformations that work together to send some "clusters"
    to their corresponding "destinations." This is easy to do by initializing randomly
    and optimizing our parameters with gradient descent. In the following widget,
    a composition of 50 maps is able to swap the positions of three clusters.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置一些简单的优化问题。在每种情况下，我们将尝试找到一系列小的变形，这些变形共同作用以将一些“簇”发送到它们对应的“目标”位置。通过随机初始化并使用梯度下降优化我们的参数，这是很容易做到的。在以下小部件中，50个映射的组合能够交换三个簇的位置。
- en: Now, observe that our family <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="script">F</mi></mrow><annotation encoding="application/x-tex">\Fc</annotation></semantics></math>F
    of deformations is **invariant** under conjugation by translations and rotations.
    This means that, where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation
    encoding="application/x-tex">Q</annotation></semantics></math>Q is a translation
    or rotation, we have an equality <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="block"><semantics><mrow><mi mathvariant="script">F</mi><mo>=</mo><mo
    stretchy="false">{</mo><mi>Q</mi><mo>∘</mo><mi>f</mi><mo>∘</mo><msup><mi>Q</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∣</mo><mi>f</mi><mo>∈</mo><mi
    mathvariant="script">F</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Fc
    = \{ Q \circ f \circ Q^{-1} \mid f \in \Fc \}</annotation></semantics></math>F={Q∘f∘Q−1∣f∈F}
    of sets. In other words, our family <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="script">F</mi></mrow><annotation encoding="application/x-tex">\Fc</annotation></semantics></math>F
    "looks the same" from a translated or rotated coordinate system. Moreover, conjugating
    a map <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation
    encoding="application/x-tex">f</annotation></semantics></math>f by a transformation
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation
    encoding="application/x-tex">Q</annotation></semantics></math>Q near the identity
    can be realized by making a small change to the parameters that define <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f.</annotation></semantics></math>f.
    As it turns out, this is the right notion of invariance to apply Noether's principle.
    What conserved quantity do we get?
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，观察我们的变形**族（family）**<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="script">F</mi></mrow><annotation encoding="application/x-tex">\Fc</annotation></semantics></math>在平移和旋转的共轭作用下是**不变（invariant）**的。这意味着，对于平移或旋转<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation
    encoding="application/x-tex">Q</annotation></semantics></math>Q，我们有等式<math xmlns="http://www.w3.org/1998/Math/MathML"
    display="block"><semantics><mrow><mi mathvariant="script">F</mi><mo>=</mo><mo
    stretchy="false">{</mo><mi>Q</mi><mo>∘</mo><mi>f</mi><mo>∘</mo><msup><mi>Q</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∣</mo><mi>f</mi><mo>∈</mo><mi
    mathvariant="script">F</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Fc
    = \{ Q \circ f \circ Q^{-1} \mid f \in \Fc \}</annotation></semantics></math>。换句话说，我们的**族（family）**<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi></mrow><annotation
    encoding="application/x-tex">\Fc</annotation></semantics></math>在一个平移或旋转后的坐标系中看起来是“相同的”。此外，通过接近单位的变换<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation
    encoding="application/x-tex">Q</annotation></semantics></math>Q将一个映射<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation
    encoding="application/x-tex">f</annotation></semantics></math>f共轭化，可以通过对定义<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi mathvariant="normal">.</mi></mrow><annotation
    encoding="application/x-tex">f.</annotation></semantics></math>f参数的小变化来实现。事实证明，这是应用诺特定理的正确不变性概念。我们得到了什么守恒量？
- en: For each data point, let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><msub><mi>g</mi><mi>i</mi></msub><msubsup><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup></mrow><annotation
    encoding="application/x-tex">(g_i)_{i = 1}^N</annotation></semantics></math>(gi​)i=1N​
    be the backpropagated gradients of the loss function with respect to the intermediate
    positions <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><msubsup><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup></mrow><annotation
    encoding="application/x-tex">(x_i)_{i = 1}^N</annotation></semantics></math>(xi​)i=1N​
    that this data point takes through our "process." Applying a certain discrete
    Noether's principle, detailed at the end of this post, will turn invariance of
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi></mrow><annotation
    encoding="application/x-tex">\Fc</annotation></semantics></math>F under translations
    into conservation of the *expected value* <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo
    stretchy="false">[</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation
    encoding="application/x-tex">E[g_i]</annotation></semantics></math>E[gi​] from
    one layer to the next. (You can display the individual vectors <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">g_i</annotation></semantics></math>gi​ in the widget
    above.) Invariance under rotation gives a conserved quantity reminiscent of angular
    momentum, namely <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo
    stretchy="false">[</mo><msub><mi>g</mi><mi>i</mi></msub><mo>∧</mo><msub><mi>x</mi><mi>i</mi></msub><mo
    stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">E[g_i
    \wedge x_i].</annotation></semantics></math>E[gi​∧xi​].
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个数据点，让<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><msub><mi>g</mi><mi>i</mi></msub><msubsup><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup></mrow><annotation
    encoding="application/x-tex">(g_i)_{i = 1}^N</annotation></semantics></math>(gi)i=1N是损失函数对中间位置<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false>(</mo><msub><mi>x</mi><mi>i</mi></msub><msubsup><mo
    stretchy="false">)</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup></mrow><annotation
    encoding="application/x-tex">(x_i)_{i = 1}^N</annotation></semantics></math>(xi)i=1N的反向传播梯度，该数据点通过我们的“过程”采取。应用某个特定的离散诺特定理，在这篇文章末尾详细说明，将使<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi></mrow><annotation
    encoding="application/x-tex">\Fc</annotation></semantics></math>F在平移下的不变性转化为从一层到下一层的*期望值*<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">[</mo><msub><mi>g</mi><mi>i</mi></msub><mo
    stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E[g_i]</annotation></semantics></math>E[gi]的保持不变。（您可以在上述小部件中显示单个向量<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">g_i</annotation></semantics></math>gi。）旋转下的不变性给出了类似于角动量的保守数量，即<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">[</mo><msub><mi>g</mi><mi>i</mi></msub><mo>∧</mo><msub><mi>x</mi><mi>i</mi></msub><mo
    stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">E[g_i
    \wedge x_i].</annotation></semantics></math>E[gi∧xi]。
- en: In this particular example, it turns out that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo
    stretchy="false">[</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation
    encoding="application/x-tex">E[g_i]</annotation></semantics></math>E[gi​] is also
    approximately conserved (and nearly zero) over each individual *cluster*. In the
    next widget, we add some examples where the per-cluster gradient is not conserved.
    (Each cluster now has its average gradient drawn with a single arrow. For simplicity,
    we are not visualizing "angular gradient.")
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，事实证明<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo
    stretchy="false">[</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation
    encoding="application/x-tex">E[g_i]</annotation></semantics></math>E[gi]在每个*群集*中也近似保持不变（几乎为零）。在下一个小部件中，我们添加了一些例子，其中每个群集的梯度不是保持不变的。（现在每个群集都用单箭头绘制其平均梯度。为简单起见，我们不可视化“角度梯度”。）
- en: In the physical world, interactions are often accompanied by transfers of conserved
    quantities. Think, for example, of particles in a gas exchanging momentum and
    energy. Conversely, if two systems are not interacting with one another, then
    conservation laws will hold for each system in isolation. In mechanics, this is
    known as Newton's first law.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理世界中，相互作用常伴随着守恒量的转移。例如，想象一下气体中的粒子交换动量和能量。相反地，如果两个系统彼此不交互，则守恒定律将对各个孤立系统成立。在力学中，这被称为牛顿第一定律。
- en: In our first toy example, the subgoals of bringing each cluster to its respective
    destination could be achieved without compromise between clusters, meaning that
    each cluster acted like an independent subsystem. This lack of interaction explains
    the conservation of gradient within each cluster. (In other words, we can apply
    Newton's first law.) In our next examples, "transfers" of average gradient indicate
    "interactions" between clusters, meaning that the trajectory of our process is
    no longer a stationary point for each subgoal considered in isolation. On the
    other hand, we can sometimes identify *subset* of clusters over which gradient
    is approximately conserved.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，将每个集群带到其各自目的地的子目标可以在不妥协集群之间的情况下实现，这意味着每个集群都像一个独立的子系统。这种缺乏交互解释了每个集群内梯度的守恒。（换句话说，我们可以应用牛顿第一定律。）在接下来的例子中，平均梯度的“转移”表明集群之间存在“交互”，这意味着我们的过程轨迹不再是每个子目标在孤立考虑中的稳定点。另一方面，我们有时可以识别出*子集*，在其中梯度近似守恒。
- en: In general, if the layers of a deep model have meaningful "Noether equivariances,"
    then we can build conserved quantities and perhaps study a physically-inspired
    notion of "interaction." However, I don't know if this idea works in practice!
    Can you think of interesting equivariances that we might find on real-world machine
    learning models? (Keep in mind that they might only be valid near the actual parameters
    of the model.)
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果深度模型的层具有有意义的“诺特等变性”，那么我们可以建立守恒量，或许研究一种受物理启发的“相互作用”概念。然而，我不知道这个想法在实践中是否奏效！你能想到我们在真实世界的机器学习模型中可能找到的有趣等变性吗？（请记住，它们可能仅在模型的实际参数附近有效。）
- en: Proof of a Discrete Noether's Principle
  id: totrans-split-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离散诺特定理的证明
- en: In the above, we've been intentionally vague about the details of Noether's
    principle and how it applied to our toy example. We end this post with a general
    proof of our "discrete" Noether's principle.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上文中，我们故意对诺特定理的细节及其在我们的示例中的应用进行了模糊描述。我们以一般化的证明来结束本文的“离散”诺特定理。
- en: 'We''ll focus on a single step of an "optimized process." '
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于“优化过程”的单一步骤。
- en: 'Let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mtext> ⁣</mtext><mo
    lspace="0em" '
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: '让 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mtext> ⁣</mtext><mo
    lspace="0em" '
- en: 'rspace="0em">:</mo><mi mathvariant="normal">Θ</mi><mo>×</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation
    encoding="application/x-tex">\varphi \colon \Theta \times X \to Y</annotation></semantics></math>φ:Θ×X→Y
    describe some family of functions parameterized over <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">Θ</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\Theta,</annotation></semantics></math>Θ,
    and define the action <math xmlns="http://www.w3.org/1998/Math/MathML" '
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: rspace="0em">:</mo><mi mathvariant="normal">Θ</mi><mo>×</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation
    encoding="application/x-tex">\varphi \colon \Theta \times X \to Y</annotation></semantics></math>φ:Θ×X→Y
    描述了某些以 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">\Theta,</annotation></semantics></math>Θ
    参数化的函数族，并定义了操作。
- en: 'display="block"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo
    separator="true">,</mo><mi>x</mi><mo stretchy="false">⟩</mo><mo>−</mo><mo stretchy="false">⟨</mo><msub><mi>g</mi><mi>y</mi></msub><mo
    separator="true">,</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>−</mo><mi>y</mi><mo stretchy="false">⟩</mo></mrow><annotation
    encoding="application/x-tex">S = \langle g_x, x \rangle - \langle g_y, \varphi_\theta(x)
    - y \rangle</annotation></semantics></math>S=⟨gx​,x⟩−⟨gy​,φθ​(x)−y⟩ where <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation
    encoding="application/x-tex">y</annotation></semantics></math>y are understood
    to be random variables, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>x</mi></msub></mrow><annotation
    encoding="application/x-tex">g_x</annotation></semantics></math>gx​ and <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>y</mi></msub></mrow><annotation
    encoding="application/x-tex">g_y</annotation></semantics></math>gy​ are their
    associated loss gradients, and inner products are taken in expectation. '
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 'display="block"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo
    separator="true">,</mo><mi>x</mi><mo stretchy="false">⟩</mo><mo>−</mo><mo stretchy="false">⟨</mo><msub><mi>g</mi><mi>y</mi></msub><mo
    separator="true">,</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>−</mo><mi>y</mi><mo stretchy="false">⟩</mo></mrow><annotation
    encoding="application/x-tex">S = \langle g_x, x \rangle - \langle g_y, \varphi_\theta(x)
    - y \rangle</annotation></semantics></math>S=⟨gx​,x⟩−⟨gy​,φθ​(x)−y⟩ where <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation
    encoding="application/x-tex">y</annotation></semantics></math>y are understood
    to be random variables, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>x</mi></msub></mrow><annotation
    encoding="application/x-tex">g_x</annotation></semantics></math>gx​ and <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>y</mi></msub></mrow><annotation
    encoding="application/x-tex">g_y</annotation></semantics></math>gy​ are their
    associated loss gradients, and inner products are taken in expectation. '
- en: 'In the typical context of supervised learning, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation
    encoding="application/x-tex">\varphi</annotation></semantics></math>φ will parameterize
    a layer of a deep model, and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>x</mi><mo
    stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle
    g_x, x \rangle</annotation></semantics></math>⟨gx​,x⟩ (for example) stands for
    a sum <math xmlns="http://www.w3.org/1998/Math/MathML" '
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: In the typical context of supervised learning, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation
    encoding="application/x-tex">\varphi</annotation></semantics></math>φ will parameterize
    a layer of a deep model, and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>x</mi><mo
    stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle
    g_x, x \rangle</annotation></semantics></math>⟨gx​,x⟩ (for example) stands for
    a sum <math xmlns="http://www.w3.org/1998/Math/MathML
- en: display="block"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo
    stretchy="false">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\frac{1}{n}
    \sum_{i = 1}^n \langle g_x(i), x(i) \rangle</annotation></semantics></math>n1​i=1∑n​⟨gx​(i),x(i)⟩
    where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i indexes over a
    dataset and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo
    separator="true">,</mo><msub><mi>g</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x(i),
    g_x(i))</annotation></semantics></math>(x(i),gx​(i)) are activation and gradient
    vectors for the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>ith data point.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: display="block"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo
    stretchy="false">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\frac{1}{n}
    \sum_{i = 1}^n \langle g_x(i), x(i) \rangle</annotation></semantics></math>n1​i=1∑n​⟨gx​(i),x(i)⟩
    where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i 索引数据集，并且 <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>g</mi><mi>x</mi></msub><mo
    stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">(x(i), g_x(i))</annotation></semantics></math>(x(i),gx​(i))
    是第 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math> 个数据点的激活和梯度向量。
- en: The "forward pass" <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">y = \varphi_\theta(x)</annotation></semantics></math>y=φθ​(x)
    and "backward pass" <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>x</mi></msub><mo>=</mo><mo
    stretchy="false">(</mo><mi mathvariant="normal">∂</mi><mi>φ</mi><mi mathvariant="normal">/</mi><mi
    mathvariant="normal">∂</mi><mi>x</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><msub><mi>g</mi><mi>y</mi></msub></mrow><annotation
    encoding="application/x-tex">g_x = (\partial \varphi / \partial x)^T g_y</annotation></semantics></math>gx​=(∂φ/∂x)Tgy​
    are encoded by the stationarity of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation
    encoding="application/x-tex">S</annotation></semantics></math>S with respect to
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>y</mi></msub></mrow><annotation
    encoding="application/x-tex">g_y</annotation></semantics></math>gy​ and <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">x,</annotation></semantics></math>x, since <math
    xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>g</mi><mi>y</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>y</mi><mo
    separator="true">,</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mo>=</mo><msub><mi>g</mi><mi>x</mi></msub><mo>−</mo><msup><mrow><mo
    fence="true">(</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>φ</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mo fence="true">)</mo></mrow><mi>T</mi></msup><msub><mi>g</mi><mi>y</mi></msub><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial
    S}{\partial g_y} = \varphi_\theta(x) - y, \quad \frac{\partial S}{\partial x}
    = g_x - \left( \frac{\partial \varphi}{\partial x}\right)^T g_y.</annotation></semantics></math>∂gy​∂S​=φθ​(x)−y,∂x∂S​=gx​−(∂x∂φ​)Tgy​.
    Similarly, first-order optimality of the parameter <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation
    encoding="application/x-tex">\theta</annotation></semantics></math>θ can be expressed
    as <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>θ</mi></mrow></mfrac><mo>=</mo><mn>0.</mn></mrow><annotation
    encoding="application/x-tex">\frac{\partial S}{\partial \theta} = 0.</annotation></semantics></math>∂θ∂S​=0.
    In practice, this will hold only approximately, so our conservation law will also
    be approximate. We ignore this detail for simplicity.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: “前向传播” <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">y = \varphi_\theta(x)</annotation></semantics></math>y=φθ​(x)
    和 “反向传播” <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>x</mi></msub><mo>=</mo><mo
    stretchy="false">(</mo><mi mathvariant="normal">∂</mi><mi>φ</mi><mi mathvariant="normal">/</mi><mi
    mathvariant="normal">∂</mi><mi>x</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><msub><mi>g</mi><mi>y</mi></msub></mrow><annotation
    encoding="application/x-tex">g_x = (\partial \varphi / \partial x)^T g_y</annotation></semantics></math>gx​=(∂φ/∂x)Tgy​
    由于在 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation
    encoding="application/x-tex">S</annotation></semantics></math>S 的稳定性方面编码，与 <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>y</mi></msub></mrow><annotation
    encoding="application/x-tex">g_y</annotation></semantics></math>gy​ 和 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">x,</annotation></semantics></math>x
    相关。因为 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>g</mi><mi>y</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>y</mi><mo
    separator="true">,</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mo>=</mo><msub><mi>g</mi><mi>x</mi></msub><mo>−</mo><msup><mrow><mo
    fence="true">(</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>φ</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mo fence="true">)</mo></mrow><mi>T</mi></msup><msub><mi>g</mi><mi>y</mi></msub><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial
    S}{\partial g_y} = \varphi_\theta(x) - y, \quad \frac{\partial S}{\partial x}
    = g_x - \left( \frac{\partial \varphi}{\partial x}\right)^T g_y.</annotation></semantics></math>∂gy​∂S​=φθ​(x)−y,∂x∂S​=gx​−(∂x∂φ​)Tgy​。类似地，参数
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation
    encoding="application/x-tex">\theta</annotation></semantics></math>θ 的一阶最优性可以表示为
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>θ</mi></mrow></mfrac><mo>=</mo><mn>0.</mn></mrow><annotation
    encoding="application/x-tex">\frac{\partial S}{\partial \theta} = 0.</annotation></semantics></math>∂θ∂S​=0。在实践中，这只是近似成立，因此我们的守恒定律也将是近似的。为简单起见，我们忽略了这一细节。
- en: Now, suppose that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>θ</mi><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y,
    \theta)</annotation></semantics></math>(x,y,θ) are made to depend on a real-valued
    parameter <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation
    encoding="application/x-tex">\epsilon</annotation></semantics></math>ϵ and that
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable
    rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mfrac><mi mathvariant="normal">∂</mi><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo
    stretchy="false">⟨</mo><msub><mi>g</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>y</mi><mo
    stretchy="false">⟩</mo><mo>=</mo><mn>0.</mn></mrow></mstyle></mtd></mtr></mtable><annotation
    encoding="application/x-tex">\begin{align*} \frac{\partial}{\partial \epsilon}
    \langle g_y, \varphi_\theta(x) - y \rangle = 0.\tag{1} \end{align*}</annotation></semantics></math>∂ϵ∂​⟨gy​,φθ​(x)−y⟩=0.​(1)​
    For example, when we have a Lie group <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation
    encoding="application/x-tex">G</annotation></semantics></math>G acting on <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">X,</annotation></semantics></math>X, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math>Θ
    and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation
    encoding="application/x-tex">Y</annotation></semantics></math>Y such that <math
    xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>φ</mi><mrow><mi>g</mi><mo>⋅</mo><mi>θ</mi></mrow></msub><mo
    stretchy="false">(</mo><mi>g</mi><mo>⋅</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo>⋅</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">\varphi_{g \cdot \theta}(g \cdot x) = g \cdot \varphi_\theta(x),</annotation></semantics></math>φg⋅θ​(g⋅x)=g⋅φθ​(x),
    then any one-parameter subgroup of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation
    encoding="application/x-tex">G</annotation></semantics></math>G gives rise to
    such a variation of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>θ</mi><mo
    stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(x,
    y, \theta).</annotation></semantics></math>(x,y,θ). This is the case for our toy
    example, where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation
    encoding="application/x-tex">G</annotation></semantics></math>G is the group <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">SE</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">\operatorname{SE}(2)</annotation></semantics></math>SE(2)
    of translations and rotations of the plane. I'm calling this kind of symmetry
    a **Noether equivariance**.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo
    separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">(x, y, \theta)</annotation></semantics></math>(x,y,θ)依赖于一个实值参数<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation
    encoding="application/x-tex">\epsilon</annotation></semantics></math>ϵ，并且<math
    xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable
    rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mfrac><mi mathvariant="normal">∂</mi><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo
    stretchy="false">⟨</mo><msub><mi>g</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>y</mi><mo
    stretchy="false">⟩</mo><mo>=</mo><mn>0.</mn></mrow></mstyle></mtd></mtr></mtable><annotation
    encoding="application/x-tex">\begin{align*} \frac{\partial}{\partial \epsilon}
    \langle g_y, \varphi_\theta(x) - y \rangle = 0.\tag{1} \end{align*}</annotation></semantics></math>∂ϵ∂​⟨gy​,φθ​(x)−y⟩=0.​(1)​。例如，当我们有一个Lie群<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation
    encoding="application/x-tex">G</annotation></semantics></math>G作用于<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">X,</annotation></semantics></math>X，<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation
    encoding="application/x-tex">\Theta</annotation></semantics></math>Θ和<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation
    encoding="application/x-tex">Y</annotation></semantics></math>Y，使得<math xmlns="http://www.w3.org/1998/Math/MathML"
    display="block"><semantics><mrow><msub><mi>φ</mi><mrow><mi>g</mi><mo>⋅</mo><mi>θ</mi></mrow></msub><mo
    stretchy="false">(</mo><mi>g</mi><mo>⋅</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo>⋅</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">\varphi_{g \cdot \theta}(g \cdot x) = g \cdot \varphi_\theta(x),</annotation></semantics></math>φg⋅θ​(g⋅x)=g⋅φθ​(x)，那么<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo
    separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(x,
    y, \theta).</annotation></semantics></math>(x,y,θ)也随之变化。这就是我们玩具示例的情况，其中<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation
    encoding="application/x-tex">G</annotation></semantics></math>G是平面的平移和旋转的群<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">SE</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">\operatorname{SE}(2)</annotation></semantics></math>SE(2)。我称这种对称性为**诺特等变性**。
- en: 'Let''s compute <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">∂</mi><mi>S</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>ϵ</mi><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\partial
    S / \partial \epsilon.</annotation></semantics></math>∂S/∂ϵ. '
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi><mi>S</mi><mi
    mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>ϵ</mi><mi mathvariant="normal">.</mi></mrow><annotation
    encoding="application/x-tex">\partial S / \partial \epsilon.</annotation></semantics></math>∂S/∂ϵ.
- en: 'Applying <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">(1),</annotation></semantics></math>(1), we find
    <math xmlns="http://www.w3.org/1998/Math/MathML" '
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: '应用<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">(1),</annotation></semantics></math>(1)，我们找到<math
    xmlns="http://www.w3.org/1998/Math/MathML" '
- en: 'display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo>=</mo><mrow><mo fence="true">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo
    separator="true">,</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo fence="true">⟩</mo></mrow><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial
    S}{\partial \epsilon} = \left\langle g_x, \frac{\partial x}{\partial \epsilon}
    \right\rangle.</annotation></semantics></math>∂ϵ∂S​=⟨gx​,∂ϵ∂x​⟩. '
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo>=</mo><mrow><mo fence="true">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo
    separator="true">,</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo fence="true">⟩</mo></mrow><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial
    S}{\partial \epsilon} = \left\langle g_x, \frac{\partial x}{\partial \epsilon}
    \right\rangle.</annotation></semantics></math>∂ϵ∂S​=⟨gx​,∂ϵ∂x​⟩.
- en: 'On the other hand, if <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation
    encoding="application/x-tex">S</annotation></semantics></math>S is stationary
    with respect to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">\theta,</annotation></semantics></math>θ,
    then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi><mi>S</mi><mi
    mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow><annotation
    encoding="application/x-tex">\partial S / \partial \epsilon</annotation></semantics></math>∂S/∂ϵ
    can be explained entirely by the variation of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">y,</annotation></semantics></math>y,
    which is <math xmlns="http://www.w3.org/1998/Math/MathML" '
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: '另一方面，如果<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation
    encoding="application/x-tex">S</annotation></semantics></math>S相对于<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x和<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">\theta,</annotation></semantics></math>θ是静止的，则<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi><mi>S</mi><mi
    mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow><annotation
    encoding="application/x-tex">\partial S / \partial \epsilon</annotation></semantics></math>∂S/∂ϵ可以完全由<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">y,</annotation></semantics></math>y的变化来解释，即<math
    xmlns="http://www.w3.org/1998/Math/MathML" '
- en: 'display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow></mfrac><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo>=</mo><mrow><mo
    fence="true">⟨</mo><msub><mi>g</mi><mi>y</mi></msub><mo separator="true">,</mo><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo
    fence="true">⟩</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial
    S}{\partial \epsilon} = \frac{\partial S}{\partial y} \frac{\partial y}{\partial
    \epsilon} = \left\langle g_y, \frac{\partial y}{\partial \epsilon} \right\rangle.</annotation></semantics></math>∂ϵ∂S​=∂y∂S​∂ϵ∂y​=⟨gy​,∂ϵ∂y​⟩. '
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>S</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow></mfrac><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo>=</mo><mrow><mo
    fence="true">⟨</mo><msub><mi>g</mi><mi>y</mi></msub><mo separator="true">,</mo><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo
    fence="true">⟩</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial
    S}{\partial \epsilon} = \frac{\partial S}{\partial y} \frac{\partial y}{\partial
    \epsilon} = \left\langle g_y, \frac{\partial y}{\partial \epsilon} \right\rangle.</annotation></semantics></math>∂ϵ∂S​=∂y∂S​∂ϵ∂y​=⟨gy​,∂ϵ∂y​⟩。
- en: 'Overall, we conclude that <math xmlns="http://www.w3.org/1998/Math/MathML" '
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: '总体而言，我们得出结论，符合哈密顿系统下一族正则变换不变的情况下，**诺特定理**意味着 <math xmlns="http://www.w3.org/1998/Math/MathML" '
- en: 'display="block"><semantics><mrow><mrow><mo fence="true">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo
    separator="true">,</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo fence="true">⟩</mo></mrow><mo>=</mo><mrow><mo
    fence="true">⟨</mo><msub><mi>g</mi><mi>y</mi></msub><mo separator="true">,</mo><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo
    fence="true">⟩</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\left\langle
    g_x, \frac{\partial x}{\partial \epsilon} \right\rangle = \left\langle g_y, \frac{\partial
    y}{\partial \epsilon} \right\rangle.</annotation></semantics></math>⟨gx​,∂ϵ∂x​⟩=⟨gy​,∂ϵ∂y​⟩. '
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: display="block"><semantics><mrow><mrow><mo fence="true">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo
    separator="true">,</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo fence="true">⟩</mo></mrow><mo>=</mo><mrow><mo
    fence="true">⟨</mo><msub><mi>g</mi><mi>y</mi></msub><mo separator="true">,</mo><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo
    fence="true">⟩</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\left\langle
    g_x, \frac{\partial x}{\partial \epsilon} \right\rangle = \left\langle g_y, \frac{\partial
    y}{\partial \epsilon} \right\rangle.</annotation></semantics></math>⟨gx​,∂ϵ∂x​⟩=⟨gy​,∂ϵ∂y​⟩。
- en: 'This is quite analogous to the conservation law <math xmlns="http://www.w3.org/1998/Math/MathML" '
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: '这相当于 <math xmlns="http://www.w3.org/1998/Math/MathML" '
- en: display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mrow><mo
    fence="true">⟨</mo><mi>p</mi><mo separator="true">,</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>q</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo fence="true">⟩</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\frac{d}{dt} \left\langle p, \frac{\partial q}{\partial
    \epsilon} \right\rangle = 0</annotation></semantics></math>dtd​⟨p,∂ϵ∂q​⟩=0 that
    Noether's principle implies for a Hamiltonian system invariant under a family
    of canonical transformations.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mrow><mo
    fence="true">⟨</mo><mi>p</mi><mo separator="true">,</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>q</mi></mrow><mrow><mi
    mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo fence="true">⟩</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\frac{d}{dt} \left\langle p, \frac{\partial q}{\partial
    \epsilon} \right\rangle = 0</annotation></semantics></math>dtd​⟨p,∂ϵ∂q​⟩=0。这与**守恒定律**相当类似，它表明对于哈密顿系统，一族正则变换下的不变性。
- en: One simple kind of Noether equivariance is a relationship like <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="block"><semantics><mrow><msub><mi>φ</mi><mrow><mi>g</mi><mo>⋅</mo><mi>θ</mi></mrow></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo>⋅</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">\varphi_{g \cdot \theta}(x) = g \cdot\varphi_\theta(x),</annotation></semantics></math>φg⋅θ​(x)=g⋅φθ​(x),
    meaning that our family of maps is expressive enough to be closed under the action
    of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation
    encoding="application/x-tex">G</annotation></semantics></math>G on its outputs.
    In this case, since the action on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x is trivial, <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi><mi>x</mi><mi
    mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>ϵ</mi><mo>=</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\partial x / \partial \epsilon = 0</annotation></semantics></math>∂x/∂ϵ=0
    and the "conservation law" associated with any one-parameter subgroup of <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation
    encoding="application/x-tex">G</annotation></semantics></math>G simply reads <math
    xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mo>=</mo><mrow><mo
    fence="true">⟨</mo><msub><mi>g</mi><mi>y</mi></msub><mo separator="true">,</mo><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo
    fence="true">⟩</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">0
    = \left\langle g_y, \frac{\partial y}{\partial \epsilon} \right\rangle.</annotation></semantics></math>0=⟨gy​,∂ϵ∂y​⟩.
    Indeed, this inner product is exactly the derivative of the loss with respect
    to the transformation of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation
    encoding="application/x-tex">y</annotation></semantics></math>y by a given one-parameter
    subgroup of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">G.</annotation></semantics></math>G.
    If variations to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation
    encoding="application/x-tex">\theta</annotation></semantics></math>θ can produce
    these transformations and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation
    encoding="application/x-tex">\theta</annotation></semantics></math>θ is chosen
    optimally, the inner product must be <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.</mn></mrow><annotation
    encoding="application/x-tex">0.</annotation></semantics></math>0. (Informally,
    this explains why the average gradients in our toy example are approximately <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.</mn></mrow><annotation
    encoding="application/x-tex">0.</annotation></semantics></math>0.)
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的Noether等变性的一种类型是像<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>φ</mi><mrow><mi>g</mi><mo>⋅</mo><mi>θ</mi></mrow></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo>⋅</mo><msub><mi>φ</mi><mi>θ</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation
    encoding="application/x-tex">\varphi_{g \cdot \theta}(x) = g \cdot\varphi_\theta(x),</annotation></semantics></math>φg⋅θ​(x)=g⋅φθ​(x)，这意味着我们的映射族足够表达，在其输出上对<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation
    encoding="application/x-tex">G</annotation></semantics></math>G的作用下封闭。在这种情况下，由于对<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x的作用是平凡的，<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">∂</mi><mi>x</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>ϵ</mi><mo>=</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\partial x / \partial \epsilon = 0</annotation></semantics></math>∂x/∂ϵ=0，与<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation
    encoding="application/x-tex">G</annotation></semantics></math>G的任一参数子群相关联的“守恒定律”简单地表示为<math
    xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mo>=</mo><mrow><mo
    fence="true">⟨</mo><msub><mi>g</mi><mi>y</mi></msub><mo separator="true">,</mo><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo
    fence="true">⟩</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">0
    = \left\langle g_y, \frac{\partial y}{\partial \epsilon} \right\rangle.</annotation></semantics></math>0=⟨gy​,∂ϵ∂y​⟩。事实上，这个内积正是关于<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation
    encoding="application/x-tex">y</annotation></semantics></math>y通过给定<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation
    encoding="application/x-tex">G</annotation></semantics></math>G的一个参数子群的变换的损失的导数。如果对<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation
    encoding="application/x-tex">\theta</annotation></semantics></math>θ的变动能产生这些变换，并且<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation
    encoding="application/x-tex">\theta</annotation></semantics></math>θ被最佳选择，内积必须是<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.</mn></mrow><annotation
    encoding="application/x-tex">0.</annotation></semantics></math>0。（非正式地讲，这解释了为什么我们的示例中的平均梯度大约是<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.</mn></mrow><annotation
    encoding="application/x-tex">0.</annotation></semantics></math>0.
- en: The same idea applies to a group acting only on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">\theta,</annotation></semantics></math>θ,
    in which case we get <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo
    fence="true">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo separator="true">,</mo><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>x</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo
    fence="true">⟩</mo></mrow><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">\left\langle
    g_x, \frac{\partial x}{\partial \epsilon} \right\rangle = 0.</annotation></semantics></math>⟨gx​,∂ϵ∂x​⟩=0.
    For example, if <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msup><mi
    mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x
    \in \R^n</annotation></semantics></math>x∈Rn is the input to a linear layer, we
    get a "Noether equivariance" in the form of an action of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">GL</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\GL(n)</annotation></semantics></math>GL(n)
    on <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x and the layer
    parameters. Letting <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">∂</mi><mi>x</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow><annotation
    encoding="application/x-tex">\partial x / \partial \epsilon</annotation></semantics></math>∂x/∂ϵ
    range over all linear functions of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x in the equation
    above—which we get from the action of one-parameter subgroups of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">GL</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\GL(n)</annotation></semantics></math>GL(n)—shows
    that the tensor product <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>x</mi></msub><mo>⊗</mo><mi>x</mi></mrow><annotation
    encoding="application/x-tex">g_x \otimes x</annotation></semantics></math>gx​⊗x
    will vanish in expectation if the loss is stationary with respect to the parameters
    of the linear layer. The general principle we proved above can be understood as
    the "two-sided" extension of these kinds of observations.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对仅对<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x和<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo
    separator="true">,</mo></mrow><annotation encoding="application/x-tex">\theta,</annotation></semantics></math>θ进行作用的群体采用相同的思想，此时我们得到<math
    xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo
    fence="true">⟨</mo><msub><mi>g</mi><mi>x</mi></msub><mo separator="true">,</mo><mfrac><mrow><mi
    mathvariant="normal">∂</mi><mi>x</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow></mfrac><mo
    fence="true">⟩</mo></mrow><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">\left\langle
    g_x, \frac{\partial x}{\partial \epsilon} \right\rangle = 0.</annotation></semantics></math>⟨gx​,∂ϵ∂x​⟩=0。例如，如果<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msup><mi
    mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x
    \in \R^n</annotation></semantics></math>x∈Rn是线性层的输入，我们在动作<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">GL</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\GL(n)</annotation></semantics></math>GL(n)在<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x和层参数上的作用下，得到“诺伊特等变性”。让<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi><mi>x</mi><mi
    mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>ϵ</mi></mrow><annotation
    encoding="application/x-tex">\partial x / \partial \epsilon</annotation></semantics></math>∂x/∂ϵ涵盖上述方程中<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation
    encoding="application/x-tex">x</annotation></semantics></math>x的所有线性函数，这是我们从<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">GL</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">\GL(n)</annotation></semantics></math>GL(n)的一参数子群的作用中得到的——显示出如果损失对线性层的参数是稳定的，则张量积<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>x</mi></msub><mo>⊗</mo><mi>x</mi></mrow><annotation
    encoding="application/x-tex">g_x \otimes x</annotation></semantics></math>gx​⊗x在期望中将消失。我们上面证明的一般原则可以理解为这些观察的“双面”扩展。
