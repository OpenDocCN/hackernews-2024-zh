- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 14:55:16'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:55:16'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Proof of the Singular Value Decomposition
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奇异值分解的证明
- en: 来源：[https://gregorygundersen.com/blog/2018/12/20/svd-proof/](https://gregorygundersen.com/blog/2018/12/20/svd-proof/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://gregorygundersen.com/blog/2018/12/20/svd-proof/](https://gregorygundersen.com/blog/2018/12/20/svd-proof/)
- en: 'The existence claim for the singular value decomposition (SVD) is quite strong:
    “Every matrix is diagonal, provided one uses the proper bases for the domain and
    range spaces” [(Trefethen & Bau III, 1997)](#trefethen1997numerical). MIT professor
    Gilbert Strang has a [wonderful lecture](https://www.youtube.com/watch?v=Nx0lRBaXoz4)
    on the SVD, and he includes an existence proof for the SVD. The goal of this post
    is to force myself to walk through his proof carefully. For legibility, I break
    the proof into two sections: an overview and details. I hope this allows the reader
    to get the big picture of the proof while consulting details as needed.'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 奇异值分解（SVD）的存在性断言非常强烈：“每个矩阵都是对角化的，只要在定义域和值域空间中使用适当的基向量” [(Trefethen & Bau III,
    1997)](#trefethen1997numerical)。麻省理工学院教授Gilbert Strang在奇异值分解的演讲中包含了奇异值分解的存在性证明。本文的目标是迫使我仔细研究他的证明。为了易读性，我将证明分为两部分：概述和详细内容。我希望这样可以让读者在需要时获得证明的整体图景。
- en: Note that while the SVD holds for complex matrices, we restrict ourselves to
    real-valued matrices in this proof. Trefethen and Bau have a proof for the existence
    and uniqueness of the SVD for complex matrices, but I found Strang’s proof more
    instructive.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，虽然奇异值分解适用于复杂矩阵，但在本证明中我们限制为实值矩阵。Trefethen和Bau对复杂矩阵的奇异值分解的存在性和唯一性有一个证明，但我认为Strang的证明更具教育意义。
- en: If you’re unfamiliar with the SVD, please see my previous post on a [geometrical
    interpretation of it](/blog/2018/12/10/svd/).
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对奇异值分解不熟悉，请参阅我以前的一篇关于其[几何解释的文章](/blog/2018/12/10/svd/)。
- en: Proof
  id: totrans-split-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证明
- en: 'Consider an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation
    encoding="application/x-tex">m \times n</annotation></semantics></math>m×n matrix
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A with rank <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation
    encoding="application/x-tex">r</annotation></semantics></math>r. The matrix <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A is therefore symmetric and positive semi-definite
    (PSD) ([Details, Section 1](#1-gram-matrices-as-positive-semi-definite)). This
    means the matrix is diagonalizable with an eigendecomposition of the form:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation
    encoding="application/x-tex">m \times n</annotation></semantics></math>m×n矩阵<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A，其秩为<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation
    encoding="application/x-tex">r</annotation></semantics></math>r。因此矩阵<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A是对称的，并且是半正定（PSD）（[详情，请参见第1节](#1-gram-matrices-as-positive-semi-definite)）。
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><mo>=</mo><mi>V</mi><mi mathvariant="normal">Λ</mi><msup><mi>V</mi><mi
    mathvariant="normal">⊤</mi></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>λ</mi><mi>i</mi></msub><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi
    mathvariant="normal">⊤</mi></msubsup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo
    stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi
    mathvariant="normal">⊤</mi></msubsup></mrow> <annotation encoding="application/x-tex">A^{\top}
    A = V \Lambda V^{\top} = \sum_{i=1}^{n} \lambda_i \textbf{v}_i \textbf{v}_i^{\top}
    = \sum_{i=1}^{n} (\sigma_i)^2 \textbf{v}_i \textbf{v}_i^{\top}</annotation></semantics></math>
    A⊤A=VΛV⊤=i=1∑n​λi​vi​vi⊤​=i=1∑n​(σi​)2vi​vi⊤​
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><mo>=</mo><mi>V</mi><mi mathvariant="normal">Λ</mi><msup><mi>V</mi><mi
    mathvariant="normal">⊤</mi></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>λ</mi><mi>i</mi></msub><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi
    mathvariant="normal">⊤</mi></msubsup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo
    stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi
    mathvariant="normal">⊤</mi></msubsup></mrow> <annotation encoding="application/x-tex">A^{\top}
    A = V \Lambda V^{\top} = \sum_{i=1}^{n} \lambda_i \textbf{v}_i \textbf{v}_i^{\top}
    = \sum_{i=1}^{n} (\sigma_i)^2 \textbf{v}_i \textbf{v}_i^{\top}</annotation></semantics></math>
    A⊤A=VΛV⊤=i=1∑n​λi​vi​vi⊤​=i=1∑n​(σi​)2vi​vi⊤​
- en: where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation
    encoding="application/x-tex">V</annotation></semantics></math>V is an orthonormal
    matrix whose columns are the eigenvectors of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A and where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>≤</mo><mi>n</mi></mrow><annotation
    encoding="application/x-tex">r \leq n</annotation></semantics></math>r≤n and <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mtext>rank</mtext><mo
    stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>rank</mtext><mo
    stretchy="false">(</mo><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r = \text{rank}(A)
    = \text{rank}(A^{\top} A)</annotation></semantics></math>r=rank(A)=rank(A⊤A) ([Details,
    Section 2](#2-a-and-atop-a-have-the-same-rank)). The second equality above, which
    is a sum of matrices, holds [because <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math>Λ
    is diagonal](https://math.stackexchange.com/a/2306159/159872).
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation
    encoding="application/x-tex">V</annotation></semantics></math>V 是一个列为<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A的特征向量的正交矩阵，并且<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>≤</mo><mi>n</mi></mrow><annotation
    encoding="application/x-tex">r \leq n</annotation></semantics></math>r≤n，<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mtext>rank</mtext><mo
    stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>rank</mtext><mo
    stretchy="false">(</mo><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r = \text{rank}(A)
    = \text{rank}(A^{\top} A)</annotation></semantics></math>r=rank(A)=rank(A⊤A) ([Details,
    Section 2](#2-a-and-atop-a-have-the-same-rank))。上述第二个相等式，即矩阵的和，是因为<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math>Λ是对角线矩阵（[因为](https://math.stackexchange.com/a/2306159/159872)）。
- en: We have defined a quantity <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\sigma_i</annotation></semantics></math>σi​ (the
    *singular values*) as the square root of the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i-th eigenvalue;
    we know we can take the square root of our eigenvalues because PSD matrices can
    be equivalently characterized as matrices with non-negative eigenvalues ([Details,
    Section 3](#3-the-eigenvalues-of-psd-matrices-are-all-non-negative)).
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个量<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\sigma_i</annotation></semantics></math>σi​（*奇异值*），它是<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i-th特征值的平方根；我们知道可以取特征值的平方根，因为半正定矩阵可以等效地表征为具有非负特征值的矩阵（[详细信息，第3节](#3-the-eigenvalues-of-psd-matrices-are-all-non-negative)）。
- en: For the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i-th eigenvector-eigenvalue
    pair, we have
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i个特征向量-特征值对，我们有
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><mo>=</mo><mo
    stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub><mi mathvariant="normal">.</mi></mrow>
    <annotation encoding="application/x-tex">A^{\top} A \textbf{v}_i = (\sigma_i)^2
    \textbf{v}_i.</annotation></semantics></math> A⊤Avi​=(σi​)2vi​.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><mo>=</mo><mo
    stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub><mi mathvariant="normal">.</mi></mrow>
    <annotation encoding="application/x-tex">A^{\top} A \textbf{v}_i = (\sigma_i)^2
    \textbf{v}_i.</annotation></semantics></math> A⊤Avi​=(σi​)2vi​.
- en: Next comes what is, at least in my mind, the critical step in the proof. For
    now, assume that we have a full-rank matrix (<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub><mo>></mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\sigma_i > 0</annotation></semantics></math>σi​>0
    for all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i). Define a new
    vector <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​
    such that,
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我看来至关重要的证明步骤。现在假设我们有一个满秩矩阵（<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub><mo>></mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\sigma_i > 0</annotation></semantics></math>σi​>0对于所有<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i）。定义一个新向量<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​如下，
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mi>A</mi><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac><mi
    mathvariant="normal">.</mi></mrow> <annotation encoding="application/x-tex">\textbf{u}_i
    = \frac{A \textbf{v}_i}{\sigma_i}.</annotation></semantics></math> ui​=σi​Avi​​.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mi>A</mi><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac><mi
    mathvariant="normal">.</mi></mrow> <annotation encoding="application/x-tex">\textbf{u}_i
    = \frac{A \textbf{v}_i}{\sigma_i}.</annotation></semantics></math> ui​=σi​Avi​​.
- en: 'By construction, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​
    is a unit eigenvector of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤
    ([Details, Section 4](#4-textbfu_i-is-a-unit-eigenvector-of-aatop)). Now let <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation
    encoding="application/x-tex">V</annotation></semantics></math>V be an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation
    encoding="application/x-tex">n \times n</annotation></semantics></math>n×n matrix—because
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A is <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation
    encoding="application/x-tex">n \times n</annotation></semantics></math>n×n—where
    the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i-th column is <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​;
    let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation
    encoding="application/x-tex">U</annotation></semantics></math>U be an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>m</mi></mrow><annotation
    encoding="application/x-tex">m \times m</annotation></semantics></math>m×m matrix—because
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A
    \textbf{v}_i</annotation></semantics></math>Avi​ is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation
    encoding="application/x-tex">m</annotation></semantics></math>m-vector—where the
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i-th column is <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​;
    and let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>Σ
    be a diagonal matrix whose <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i-th element is
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\sigma_i</annotation></semantics></math>σi​. Then
    we can express the relationships we have so far in matrix form as:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造，<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​
    是 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤
    的单位特征向量（[详情，请见第4节](#4-textbfu_i-is-a-unit-eigenvector-of-aatop)）。现在，让 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation
    encoding="application/x-tex">V</annotation></semantics></math>V 是一个 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation
    encoding="application/x-tex">n \times n</annotation></semantics></math>n×n 矩阵——因为
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A 是 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation
    encoding="application/x-tex">n \times n</annotation></semantics></math>n×n ——
    其中第 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i 列是 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​；让
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation
    encoding="application/x-tex">U</annotation></semantics></math>U 是一个 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>m</mi></mrow><annotation
    encoding="application/x-tex">m \times m</annotation></semantics></math>m×m 矩阵——因为
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A
    \textbf{v}_i</annotation></semantics></math>Avi​ 是一个 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation
    encoding="application/x-tex">m</annotation></semantics></math>m-向量 —— 其中第 <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i 列是 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​；让
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation
    encoding="application/x-tex">\Sigma</annotation></semantics></math>Σ 是一个对角矩阵，其第
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i 元素是 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\sigma_i</annotation></semantics></math>σi​。因此，我们可以将迄今为止的关系用矩阵形式表示为：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mi>U</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><mi>V</mi><msup><mi
    mathvariant="normal">Σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mi>U</mi><mi mathvariant="normal">Σ</mi></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><mi>V</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mi>A</mi></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mi>U</mi><mi mathvariant="normal">Σ</mi><msup><mi>V</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow></mstyle></mtd></mtr></mtable> <annotation
    encoding="application/x-tex">\begin{aligned} U &= A V \Sigma^{-1} \\ U \Sigma
    &= A V \\ A &= U \Sigma V^{\top} \end{aligned}</annotation></semantics></math>
    UUΣA​=AVΣ−1=AV=UΣV⊤​
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mi>U</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><mi>V</mi><msup><mi
    mathvariant="normal">Σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mi>U</mi><mi mathvariant="normal">Σ</mi></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><mi>V</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mi>A</mi></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mi>U</mi><mi mathvariant="normal">Σ</mi><msup><mi>V</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow></mstyle></mtd></mtr></mtable> <annotation
    encoding="application/x-tex">\begin{aligned} U &= A V \Sigma^{-1} \\ U \Sigma
    &= A V \\ A &= U \Sigma V^{\top} \end{aligned}</annotation></semantics></math>
- en: where we use the fact that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><msup><mi>V</mi><mi
    mathvariant="normal">⊤</mi></msup><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">VV^{\top}
    = I</annotation></semantics></math>VV⊤=I and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi
    mathvariant="normal">Σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation
    encoding="application/x-tex">\Sigma^{-1}</annotation></semantics></math>Σ−1 is
    a diagonal matrix where the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>i-th value is the
    reciprocal of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\sigma_i</annotation></semantics></math>σi​. And
    we’re done. Note that the first <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation
    encoding="application/x-tex">r</annotation></semantics></math>r columns of <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation
    encoding="application/x-tex">V</annotation></semantics></math>V are an orthonormal
    basis for the row space of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A, while the first
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation
    encoding="application/x-tex">r</annotation></semantics></math>r columns of <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation
    encoding="application/x-tex">U</annotation></semantics></math>U are an orthonormal
    basis for the column space of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用了事实，即<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><msup><mi>V</mi><mi
    mathvariant="normal">⊤</mi></msup><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">VV^{\top}
    = I</annotation></semantics></math>，以及<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi
    mathvariant="normal">Σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation
    encoding="application/x-tex">\Sigma^{-1}</annotation></semantics></math>是一个对角矩阵，其中<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation
    encoding="application/x-tex">i</annotation></semantics></math>值是<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\sigma_i</annotation></semantics></math>的倒数。我们已经完成了。请注意，<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation
    encoding="application/x-tex">r</annotation></semantics></math>列的<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation
    encoding="application/x-tex">V</annotation></semantics></math>是<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>的行空间的标准正交基，而<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation
    encoding="application/x-tex">U</annotation></semantics></math>的<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation
    encoding="application/x-tex">r</annotation></semantics></math>列是<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>的列空间的标准正交基。
- en: In the low-rank scenario, some <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\sigma_i = 0</annotation></semantics></math>σi​=0.
    Provided the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\sigma_i</annotation></semantics></math>σi​ are sorted,
    we can complete <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation
    encoding="application/x-tex">U</annotation></semantics></math>U by adding additional
    column vectors that span <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi
    mathvariant="double-struck">R</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^m</annotation></semantics></math>Rm
    and then add rows of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation
    encoding="application/x-tex">0</annotation></semantics></math>0-vectors to <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation
    encoding="application/x-tex">\Sigma</annotation></semantics></math>Σ. See Figure
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation
    encoding="application/x-tex">7</annotation></semantics></math>7 [here](http://gregorygundersen.com/blog/2018/12/10/svd/).
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在低秩场景中，某些<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\sigma_i = 0</annotation></semantics></math>σᵢ =
    0。假设<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\sigma_i</annotation></semantics></math>σᵢ已排序，我们可以通过添加跨越<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>m</mi></msup></mrow><annotation
    encoding="application/x-tex">\mathbb{R}^m</annotation></semantics></math>ℝᵐ的额外列向量来完成<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation
    encoding="application/x-tex">U</annotation></semantics></math>U，然后将<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation
    encoding="application/x-tex">0</annotation></semantics></math>0向量的行添加到<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi
    mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>Σ中。详见图<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation
    encoding="application/x-tex">7</annotation></semantics></math>7 [这里](http://gregorygundersen.com/blog/2018/12/10/svd/)。
- en: Details
  id: totrans-split-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详情
- en: 1\. Gram matrices as positive semi-definite
  id: totrans-split-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1\. 格拉姆矩阵是半正定
- en: 'Gram matrices are PSD. Consider an arbitrary Gram matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><msup><mi>M</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>M</mi></mrow><annotation encoding="application/x-tex">G
    = M^{\top} M</annotation></semantics></math>G=M⊤M. Then we have:'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 格拉姆矩阵是半正定的。考虑任意的格拉姆矩阵<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><msup><mi>M</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>M</mi></mrow><annotation encoding="application/x-tex">G
    = M^{\top} M</annotation></semantics></math>G = MᵀM。那么我们有：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><mi>G</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><msup><mtext mathvariant="bold">x</mtext><mi
    mathvariant="normal">⊤</mi></msup><msup><mi>M</mi><mi mathvariant="normal">⊤</mi></msup><mi>M</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mtext
    mathvariant="bold">x</mtext><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup><mi>M</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mtext
    mathvariant="bold">x</mtext><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} \textbf{x}^{\top} G \textbf{x}
    &= \textbf{x}^{\top} M^{\top} M \textbf{x} \\ &= (M \textbf{x})^{\top} M \textbf{x}
    \\ &= (M \textbf{x})^2 \\ &\geq 0 \end{aligned}</annotation></semantics></math>
    x⊤Gx​=x⊤M⊤Mx=(Mx)⊤Mx=(Mx)2≥0​
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><mi>G</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><msup><mtext mathvariant="bold">x</mtext><mi
    mathvariant="normal">⊤</mi></msup><msup><mi>M</mi><mi mathvariant="normal">⊤</mi></msup><mi>M</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mtext
    mathvariant="bold">x</mtext><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup><mi>M</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mtext
    mathvariant="bold">x</mtext><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} \textbf{x}^{\top} G \textbf{x}
    &= \textbf{x}^{\top} M^{\top} M \textbf{x} \\ &= (M \textbf{x})^{\top} M \textbf{x}
    \\ &= (M \textbf{x})^2 \\ &\geq 0 \end{aligned}</annotation></semantics></math>
    x⊤Gx​=x⊤M⊤Mx=(Mx)⊤Mx=(Mx)2≥0​
- en: If that last step is not obvious, let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext
    mathvariant="bold">z</mtext><mo>=</mo><mi>M</mi><mtext mathvariant="bold">x</mtext></mrow><annotation
    encoding="application/x-tex">\textbf{z} = M \textbf{x}</annotation></semantics></math>z=Mx
    and note that
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一步不明显，请让 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext
    mathvariant="bold">z</mtext><mo>=</mo><mi>M</mi><mtext mathvariant="bold">x</mtext></mrow><annotation
    encoding="application/x-tex">\textbf{z} = M \textbf{x}</annotation></semantics></math>z=Mx
    并注意到
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext
    mathvariant="bold">z</mtext><mi mathvariant="normal">⊤</mi></msup><mtext mathvariant="bold">z</mtext><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mo
    stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mi
    mathvariant="normal">.</mi></mrow> <annotation encoding="application/x-tex">\textbf{z}^{\top}
    \textbf{z} = \sum_{i=1}^{N} (z_i)^2.</annotation></semantics></math> z⊤z=i=1∑N​(zi​)2.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext
    mathvariant="bold">z</mtext><mi mathvariant="normal">⊤</mi></msup><mtext mathvariant="bold">z</mtext><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mo
    stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mi
    mathvariant="normal">.</mi></mrow> <annotation encoding="application/x-tex">\textbf{z}^{\top}
    \textbf{z} = \sum_{i=1}^{N} (z_i)^2.</annotation></semantics></math> z⊤z=i=1∑N​(zi​)2.
- en: In general, positive-definiteness is required for any operation to be an inner
    product.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，正定性对于任何操作都是内积所必需的。
- en: 2\. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A have the same rank
  id: totrans-split-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2\. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A 和 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A 具有相同的秩
- en: To show that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>rank</mtext><mo
    stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>rank</mtext><mo
    stretchy="false">(</mo><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{rank}(A)
    = \text{rank}(A^{\top} A)</annotation></semantics></math>rank(A)=rank(A⊤A), it
    is sufficient to show that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext
    mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation
    encoding="application/x-tex">A \textbf{x} = \textbf{0}</annotation></semantics></math>Ax=0
    and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext
    mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A^{\top}
    A \textbf{x} = \textbf{0}</annotation></semantics></math>A⊤Ax=0 have the same
    solutions, i.e. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext
    mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext><mo>⟺</mo><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext
    mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A
    \textbf{x} = \textbf{0} \iff A^{\top} A \textbf{x} = \textbf{0}</annotation></semantics></math>Ax=0⟺A⊤Ax=0.
    This makes sense because *rank* is just the maximal number of linearly independent
    columns, and a set of vectors <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mtext
    mathvariant="bold">x</mtext><mn>1</mn></msub><mo separator="true">,</mo><msub><mtext
    mathvariant="bold">x</mtext><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mtext
    mathvariant="bold">x</mtext><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\\{\textbf{x}_1,
    \textbf{x}_2, \dots \textbf{x}_k\\}</annotation></semantics></math>x1​,x2​,…xk​
    are linearly *dependent* if there exists scalars <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo
    separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo
    separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_1,
    a_2, \dots, a_k</annotation></semantics></math>a1​,a2​,…,ak​, not all zero, such
    that
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>rank</mtext><mo
    stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>rank</mtext><mo
    stretchy="false">(</mo><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{rank}(A)
    = \text{rank}(A^{\top} A)</annotation></semantics></math>rank(A)=rank(A⊤A)，只需证明<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext
    mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A
    \textbf{x} = \textbf{0}</annotation></semantics></math>Ax=0和<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext
    mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A^{\top}
    A \textbf{x} = \textbf{0}</annotation></semantics></math>A⊤Ax有相同的解，即<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext
    mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext><mo>⟺</mo><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext
    mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A
    \textbf{x} = \textbf{0} \iff A^{\top} A \textbf{x} = \textbf{0}</annotation></semantics></math>Ax=0⟺A⊤Ax=0。这是因为*rank*仅仅是线性无关列的最大数目，且向量组<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mtext
    mathvariant="bold">x</mtext><mn>1</mn></msub><mo separator="true">,</mo><msub><mtext
    mathvariant="bold">x</mtext><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mtext
    mathvariant="bold">x</mtext><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\\{\textbf{x}_1,
    \textbf{x}_2, \dots \textbf{x}_k\\}</annotation></semantics></math>x1​,x2​,…xk​如果存在标量<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo
    separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo
    separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_1,
    a_2, \dots, a_k</annotation></semantics></math>a1​,a2​,…,ak​，不全为零，使得
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mtext
    mathvariant="bold">x</mtext><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mtext
    mathvariant="bold">x</mtext><mn>2</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><mi>k</mi></msub><msub><mtext
    mathvariant="bold">x</mtext><mi>k</mi></msub><mo>=</mo><mtext mathvariant="bold">0</mtext><mi
    mathvariant="normal">.</mi></mrow> <annotation encoding="application/x-tex">a_1
    \textbf{x}_1 + a_2 \textbf{x}_2 + \dots + a_k \textbf{x}_k = \textbf{0}.</annotation></semantics></math>
    a1​x1​+a2​x2​+⋯+ak​xk​=0.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mtext
    mathvariant="bold">x</mtext><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mtext
    mathvariant="bold">x</mtext><mn>2</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><mi>k</mi></msub><msub><mtext
    mathvariant="bold">x</mtext><mi>k</mi></msub><mo>=</mo><mtext mathvariant="bold">0</mtext><mi
    mathvariant="normal">.</mi></mrow> <annotation encoding="application/x-tex">a_1
    \textbf{x}_1 + a_2 \textbf{x}_2 + \dots + a_k \textbf{x}_k = \textbf{0}.</annotation></semantics></math>
    a1​x1​+a2​x2​+⋯+ak​xk​=0.
- en: Now if <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext
    mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation
    encoding="application/x-tex">A \textbf{x} = \textbf{0}</annotation></semantics></math>Ax=0,
    then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mo stretchy="false">(</mo><mi>A</mi><mtext
    mathvariant="bold">x</mtext><mo stretchy="false">)</mo><mo>=</mo><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mtext mathvariant="bold">0</mtext><mo>=</mo><mtext
    mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A^{\top}
    (A \textbf{x}) = A^{\top} \textbf{0} = \textbf{0}</annotation></semantics></math>A⊤(Ax)=A⊤0=0.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: Now if <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext
    mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation
    encoding="application/x-tex">A \textbf{x} = \textbf{0}</annotation></semantics></math>Ax=0,
    then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mo stretchy="false">(</mo><mi>A</mi><mtext
    mathvariant="bold">x</mtext><mo stretchy="false">)</mo><mo>=</mo><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mtext mathvariant="bold">0</mtext><mo>=</mo><mtext
    mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A^{\top}
    (A \textbf{x}) = A^{\top} \textbf{0} = \textbf{0}</annotation></semantics></math>A⊤(Ax)=A⊤0=0.
- en: If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext
    mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A^{\top}
    A \textbf{x} = \textbf{0}</annotation></semantics></math>A⊤Ax=0, then
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext
    mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A^{\top}
    A \textbf{x} = \textbf{0}</annotation></semantics></math>A⊤Ax=0, then
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><msup><mi>x</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>A</mi><mtext
    mathvariant="bold">x</mtext><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mtext mathvariant="bold">0</mtext><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} A^{\top} A \textbf{x}
    &= \textbf{0} \\ x^{\top} A^{\top} A \textbf{x} &= \textbf{0} \\ (A \textbf{x})^{\top}
    A \textbf{x} &= \textbf{0}. \end{aligned}</annotation></semantics></math> A⊤Axx⊤A⊤Ax(Ax)⊤Ax​=0=0=0.​
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><msup><mi>x</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>A</mi><mtext
    mathvariant="bold">x</mtext><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mtext mathvariant="bold">0</mtext><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} A^{\top} A \textbf{x}
    &= \textbf{0} \\ x^{\top} A^{\top} A \textbf{x} &= \textbf{0} \\ (A \textbf{x})^{\top}
    A \textbf{x} &= \textbf{0}. \end{aligned}</annotation></semantics></math> A⊤Axx⊤A⊤Ax(Ax)⊤Ax​=0=0=0.​
- en: Note that for any vector <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext
    mathvariant="bold">v</mtext></mrow><annotation encoding="application/x-tex">\textbf{v}</annotation></semantics></math>v,
    by definition of the inner product, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext
    mathvariant="bold">v</mtext><mi mathvariant="normal">⊤</mi></msup><mtext mathvariant="bold">v</mtext><mo>=</mo><mn>0</mn><mo>⟺</mo><mtext
    mathvariant="bold">v</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation
    encoding="application/x-tex">\textbf{v}^{\top} \textbf{v} = 0 \iff \textbf{v}
    = \textbf{0}</annotation></semantics></math>v⊤v=0⟺v=0.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对于任意向量 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext
    mathvariant="bold">v</mtext></mrow><annotation encoding="application/x-tex">\textbf{v}</annotation></semantics></math>v，根据内积的定义，<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">v</mtext><mi
    mathvariant="normal">⊤</mi></msup><mtext mathvariant="bold">v</mtext><mo>=</mo><mn>0</mn><mo>⟺</mo><mtext
    mathvariant="bold">v</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation
    encoding="application/x-tex">\textbf{v}^{\top} \textbf{v} = 0 \iff \textbf{v}
    = \textbf{0}</annotation></semantics></math>v⊤v=0⟺v=0.
- en: 3\. The eigenvalues of PSD matrices are all non-negative
  id: totrans-split-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3\. PSD 矩阵的特征值全部为非负数。
- en: 'An equivalent characterization of a PSD matrix is that all its eigenvalues
    are non-negative. First, consider a real symmetric matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A. Since it is real
    and symmetric, it has an eigendecomposition of the form:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: PSD 矩阵的一个等价特征是其所有特征值均为非负数。首先考虑一个实对称矩阵 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A。由于它是实对称的，它具有以下形式的特征分解：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>Q</mi><mi
    mathvariant="normal">Λ</mi><msup><mi>Q</mi><mi mathvariant="normal">⊤</mi></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mtext
    mathvariant="bold">q</mtext><mi>n</mi></msub><msub><mi>λ</mi><mi>n</mi></msub><msubsup><mtext
    mathvariant="bold">q</mtext><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup></mrow>
    <annotation encoding="application/x-tex">A = Q \Lambda Q^{\top} = \sum_{n=1}^{N}
    \textbf{q}_n \lambda_n \textbf{q}_n^{\top}</annotation></semantics></math> A=QΛQ⊤=n=1∑N​qn​λn​qn⊤​
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>Q</mi><mi
    mathvariant="normal">Λ</mi><msup><mi>Q</mi><mi mathvariant="normal">⊤</mi></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mtext
    mathvariant="bold">q</mtext><mi>n</mi></msub><msub><mi>λ</mi><mi>n</mi></msub><msubsup><mtext
    mathvariant="bold">q</mtext><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup></mrow>
    <annotation encoding="application/x-tex">A = Q \Lambda Q^{\top} = \sum_{n=1}^{N}
    \textbf{q}_n \lambda_n \textbf{q}_n^{\top}</annotation></semantics></math> A=QΛQ⊤=n=1∑N​qn​λn​qn⊤​
- en: 'And therefore:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><msup><mtext mathvariant="bold">x</mtext><mi
    mathvariant="normal">⊤</mi></msup><mo fence="false">(</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mtext
    mathvariant="bold">q</mtext><mi>n</mi></msub><msub><mi>λ</mi><mi>n</mi></msub><msubsup><mtext
    mathvariant="bold">q</mtext><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup><mo
    fence="false">)</mo><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>λ</mi><mi>n</mi></msub><msup><mtext
    mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><msub><mtext
    mathvariant="bold">q</mtext><mi>n</mi></msub><msubsup><mtext mathvariant="bold">q</mtext><mi>n</mi><mi
    mathvariant="normal">⊤</mi></msubsup><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>λ</mi><mi>n</mi></msub><mo
    stretchy="false">(</mo><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><msub><mtext
    mathvariant="bold">q</mtext><mi>n</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} \textbf{x}^{\top} A \textbf{x}
    &= \textbf{x}^{\top} \Big( \sum_{n=1}^{N} \textbf{q}_n \lambda_n \textbf{q}_n^{\top}
    \Big) \textbf{x} \\ &= \sum_{n=1}^{N} \lambda_n \textbf{x}^{\top} \textbf{q}_n
    \textbf{q}_n^{\top} \textbf{x} \\ &= \sum_{n=1}^{N} \lambda_n (\textbf{x}^{\top}
    \textbf{q}_n)^2 \end{aligned}</annotation></semantics></math> x⊤Ax​=x⊤(n=1∑N​qn​λn​qn⊤​)x=n=1∑N​λn​x⊤qn​qn⊤​x=n=1∑N​λn​(x⊤qn​)2​
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext
    mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><msup><mtext mathvariant="bold">x</mtext><mi
    mathvariant="normal">⊤</mi></msup><mo fence="false">(</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mtext
    mathvariant="bold">q</mtext><mi>n</mi></msub><msub><mi>λ</mi><mi>n</mi></msub><msubsup><mtext
    mathvariant="bold">q</mtext><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup><mo
    fence="false">)</mo><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>λ</mi><mi>n</mi></msub><msup><mtext
    mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><msub><mtext
    mathvariant="bold">q</mtext><mi>n</mi></msub><msubsup><mtext mathvariant="bold">q</mtext><mi>n</mi><mi
    mathvariant="normal">⊤</mi></msubsup><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>λ</mi><mi>n</mi></msub><mo
    stretchy="false">(</mo><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><msub><mtext
    mathvariant="bold">q</mtext><mi>n</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} \textbf{x}^{\top} A \textbf{x}
    &= \textbf{x}^{\top} \Big( \sum_{n=1}^{N} \textbf{q}_n \lambda_n \textbf{q}_n^{\top}
    \Big) \textbf{x} \\ &= \sum_{n=1}^{N} \lambda_n \textbf{x}^{\top} \textbf{q}_n
    \textbf{q}_n^{\top} \textbf{x} \\ &= \sum_{n=1}^{N} \lambda_n (\textbf{x}^{\top}
    \textbf{q}_n)^2 \end{aligned}</annotation></semantics></math> x⊤Ax​=x⊤(n=1∑N​qn​λn​qn⊤​)x=n=1∑N​λn​x⊤qn​qn⊤​x=n=1∑N​λn​(x⊤qn​)2​
- en: This final expression is greater or equal to zero if all the eigenvalues <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>n</mi></msub></mrow><annotation
    encoding="application/x-tex">\lambda_n</annotation></semantics></math>λn​ are
    non-negative. So *if* that is true, the matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A is PSD.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: '-   如果所有的特征值 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>n</mi></msub></mrow><annotation
    encoding="application/x-tex">\lambda_n</annotation></semantics></math>λn​ 都是非负的，那么最终的表达式大于或等于零。因此
    *如果* 是真的，矩阵 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A 是半正定的。'
- en: 'Next, consider a matrix that is PSD, so:'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: '-   下一步，考虑一个半正定矩阵，所以：'
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext
    mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext
    mathvariant="bold">x</mtext><mo>≥</mo><mn>0</mn></mrow> <annotation encoding="application/x-tex">\textbf{x}^{\top}
    A \textbf{x} \geq 0</annotation></semantics></math> x⊤Ax≥0
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: '-   <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext
    mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext
    mathvariant="bold">x</mtext><mo>≥</mo><mn>0</mn></mrow> <annotation encoding="application/x-tex">\textbf{x}^{\top}
    A \textbf{x} \geq 0</annotation></semantics></math> x⊤Ax≥0'
- en: 'Now consider an arbitrary eigenvector of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​.
    Since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A is PSD, we know:'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: '-   现在考虑矩阵 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A 的任意特征向量 <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​。由于矩阵
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A 是半正定的，我们知道：'
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi
    mathvariant="normal">⊤</mi></msubsup><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi
    mathvariant="normal">⊤</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>λ</mi><mi>i</mi></msub><msubsup><mtext
    mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} \textbf{v}_i^{\top} A
    \textbf{v}_i &= \textbf{v}_i^{\top} \lambda_i \textbf{v}_i \\ &= \lambda_i \textbf{v}_i^{\top}
    \textbf{v}_i \\ &\geq 0 \end{aligned}</annotation></semantics></math> vi⊤​Avi​​=vi⊤​λi​vi​=λi​vi⊤​vi​≥0​
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi
    mathvariant="normal">⊤</mi></msubsup><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi
    mathvariant="normal">⊤</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>λ</mi><mi>i</mi></msub><msubsup><mtext
    mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} \textbf{v}_i^{\top} A
    \textbf{v}_i &= \textbf{v}_i^{\top} \lambda_i \textbf{v}_i \\ &= \lambda_i \textbf{v}_i^{\top}
    \textbf{v}_i \\ &\geq 0 \end{aligned}</annotation></semantics></math> vi⊤​Avi​​=vi⊤​λi​vi​=λi​vi⊤​vi​≥0​
- en: Since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mtext
    mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i^{\top}
    \textbf{v}_i</annotation></semantics></math>vi⊤​vi​ is necessarily non-negative,
    then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\lambda_i</annotation></semantics></math>λi​ must
    be non-negative for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><msubsup><mtext
    mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\lambda_i \textbf{v}_i^{\top} \textbf{v}_i \geq 0</annotation></semantics></math>λi​vi⊤​vi​≥0
    to hold.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mtext
    mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i^{\top}
    \textbf{v}_i</annotation></semantics></math>vi⊤​vi​必定是非负的，则<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\lambda_i</annotation></semantics></math>λi​必须是非负的，以满足<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><msubsup><mtext
    mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation
    encoding="application/x-tex">\lambda_i \textbf{v}_i^{\top} \textbf{v}_i \geq 0</annotation></semantics></math>λi​vi⊤​vi​≥0。
- en: 4\. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​
    is a unit eigenvector of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤
  id: totrans-split-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4\. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​是<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤的单位特征向量。
- en: To see that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​
    is an eigenvector of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤,
    note that
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​是<math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤的特征向量，请注意
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mo fence="false">(</mo><mfrac><mrow><mi>A</mi><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac><mo
    fence="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub><mfrac><mn>1</mn><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><mfrac><mn>1</mn><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} AA^{\top} \textbf{u}_i
    &= AA^{\top} \Big( \frac{A \textbf{v}_i}{\sigma_i} \Big) \\ &= AA^{\top} A \textbf{v}_i
    \frac{1}{\sigma_i} \\ &= A (\sigma_i)^2 \textbf{v}_i \frac{1}{\sigma_i} \\ &=
    (\sigma_i)^2 \textbf{u}_i \end{aligned}</annotation></semantics></math> AA⊤ui​​=AA⊤(σi​Avi​​)=AA⊤Avi​σi​1​=A(σi​)2vi​σi​1​=(σi​)2ui​​
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mo fence="false">(</mo><mfrac><mrow><mi>A</mi><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac><mo
    fence="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><mo>=</mo><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub><mfrac><mn>1</mn><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><mfrac><mn>1</mn><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} AA^{\top} \textbf{u}_i
    &= AA^{\top} \Big( \frac{A \textbf{v}_i}{\sigma_i} \Big) \\ &= AA^{\top} A \textbf{v}_i
    \frac{1}{\sigma_i} \\ &= A (\sigma_i)^2 \textbf{v}_i \frac{1}{\sigma_i} \\ &=
    (\sigma_i)^2 \textbf{u}_i \end{aligned}</annotation></semantics></math>
- en: where step 2-3 applies the definition of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​
    as an eigenvector of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A and step 3-4 applies the definition of <math
    xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation
    encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 2-3 应用 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​
    是 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A 的特征向量定义，而步骤 3-4 应用 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​
    的特征向量定义。
- en: To see that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​
    is unit, note that
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到 <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​
    是单位向量，注意到
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em"
    columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><mrow><msubsup><mtext mathvariant="bold">u</mtext><mi>i</mi><mi
    mathvariant="normal">⊤</mi></msubsup><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mo fence="false">(</mo><mfrac><mrow><mi>A</mi><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac><msup><mo
    fence="false">)</mo><mi mathvariant="normal">⊤</mi></msup><mfrac><mrow><mi>A</mi><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mo fence="false">(</mo><mfrac><mrow><msubsup><mtext
    mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac><mo
    fence="false">)</mo><mfrac><mrow><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mfrac><mrow><msubsup><mtext
    mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><mrow><mo
    stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mfrac><mrow><msubsup><mtext
    mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><mo
    stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><mrow><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo
    stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi
    mathvariant="normal">⊤</mi></msubsup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable>
    <annotation encoding="application/x-tex">\begin{aligned} \textbf{u}_i^{\top} \textbf{u}_i
    &= \Big(\frac{A \textbf{v}_i}{\sigma_i} \Big)^{\top} \frac{A \textbf{v}_i}{\sigma_i}
    \\ &= \Big( \frac{\textbf{v}_i^{\top} A^{\top}}{\sigma_i} \Big) \frac{A \textbf{v}_i}{\sigma_i}
    \\ &= \frac{\textbf{v}_i^{\top} A^{\top} A \textbf{v}_i}{(\sigma_i)^2} \\ &= \frac{\textbf{v}_i^{\top}
    (\sigma_i)^2 \textbf{v}_i}{(\sigma_i)^2} \\ &= \textbf{v}_i^{\top} \textbf{v}_i
    \\ &= 1 \end{aligned}</annotation></semantics></math> ui⊤​ui​​=(σi​Avi​​)⊤σi​Avi​​=(σi​vi⊤​A⊤​)σi​Avi​​=(σi​)2vi⊤​A⊤Avi​​=(σi​)2vi⊤​(σi​)2vi​​=vi⊤​vi​=1​
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: where the last step is because <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext
    mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​
    is a unit vector as well.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-split-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I found this proof instructive. Importantly, it makes it clear where the relationship
    between singular values and eigenvalues comes from. The right singular vectors
    of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A, the columns of
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation
    encoding="application/x-tex">V</annotation></semantics></math>V, are the set of
    orthonormal eigenvectors of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}
    A</annotation></semantics></math>A⊤A. The left singular vectors of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A, the columns of
    <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation
    encoding="application/x-tex">U</annotation></semantics></math>U, are the set of
    orthonormal eigenvectors of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤.
    And the non-zero singular values of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation
    encoding="application/x-tex">A</annotation></semantics></math>A are the square
    roots of the eigenvalues of both <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}A</annotation></semantics></math>A⊤A
    and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi
    mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgements
  id: totrans-split-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I thank James D., Carl A., and José M. for pointing out a few mistakes in earlier
    drafts.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
