<!--yml

类别: 未分类

日期: 2024-05-29 12:38:22

-->

# Notion灵活性背后的数据模型

> 来源：[https://www.notion.so/blog/data-model-behind-notion](https://www.notion.so/blog/data-model-behind-notion)

[先驱的一代](https://www.notion.so/about)（道格·英格尔巴特、泰德·尼尔森、艾伦·凯等）认为计算机是一种工具，通过赋予人们对信息的控制权，增强人类解决问题的能力。

如今，信息大多数仍然孤立地分布在各种工具中。以云端文档编辑器为例，页面是它们最小的原子单位。信息被锁在页面、文件和文件夹中 —— 这与一个世纪前的做法很类似。

我们建立Notion的框架使得信息能够自由地独立存在，摆脱任何约束或容器，而是将权力交到用户手中的细粒度级别。这个框架建立在块之上。

在Notion中，你所见的每一样东西都是一个块。文本、图片、列表、数据库中的一行，甚至页面本身 —— 这些都是块，信息的动态单元，可以转换成其他类型的块或自由移动在Notion内部。它们就像我们用来构建和建模信息的乐高积木一样。而当这些块放在一起时，它们就像乐高积木套装一样，创造出比部件总和更伟大的东西。

这种灵活性是Notion使命的核心。虽然块要求我们的工程团队在结构化信息时极其严谨，但我们希望提供一种原子的、类似图形的数据模型，让用户能够自定义他们的信息如何被移动、组织和共享。

块模型使Notion独特，是Notion思考计算作为媒介可能发展成什么的基础。

就像乐高积木在乐高套装中一样，Notion的块代表了Notion编辑器中所有信息单元。块的属性决定了如何渲染和组织这些信息。

每个块都有以下属性：

+   **ID** — 每个块都通过其ID唯一标识。您可以在浏览器中的URL末尾看到页面块的ID。在Notion中，我们使用随机生成的UUID（UUID v4）作为ID。

+   **属性** — 包含有关特定块的自定义属性的数据结构。最常见的属性是`标题`，它存储段落、列表等块类型的文本内容，当然还包括页面的标题。更复杂的块类型需要更多或不同的属性，例如数据库中带有[用户定义属性](https://www.notion.so/notion/Intro-to-databases-fd8cd2d212f74c50954c11086d85997e#6b755095caf3419fb544f2cc996fe926)的页面块。

+   **类型** — 每个块都有一种类型，定义了块如何显示以及如何解释块的属性。Notion支持许多类型的块，大多数可以在按下`+`按钮或在`/`菜单时出现的“新块”菜单中看到：

除了描述块本身的属性之外，每个块还具有定义它们与其他块关系的属性：

+   **内容** — 一个数组（或有序集合）的块ID，代表此块内部的内容，如项目符号列表中的嵌套项目或展开块内部的文本。

+   **父级** — 块的父级块ID。父级块仅用于权限。

像乐高积木一样，Notion块可以与其他块组合在一起，创造出更强大的东西 — 比如一个完全定制为您团队流程的路线图，跟踪进展并将所有项目信息集中在一个地方。我们组织所有块的方面，确保它们执行正确的任务并位于正确的位置，使用户能够连接它们并进一步调整Notion以解决他们的问题。

块类型决定了在Notion的UI中如何呈现块 — 根据不同的类型，我们会不同解析块的属性和内容。如果你使用过Notion中的`Turn into`功能，你可能对此很熟悉，它允许你将一个块类型转换为另一个块类型。

更改块的类型不会改变块的属性或内容 — 它仅改变类型属性。信息只是以不同方式渲染，甚至如果该属性未被该块类型使用，则可能会被忽略。

例如，您可以在这里看到一个`待办事项`块被转换为几种其他块类型。我们还检查了`待办事项`项目。当将块转换回`标题`和`Callout`块类型时，“已选中”属性将被忽略 — 但当我们最终将块转回`待办事项`块时，它仍然被选中。

将属性存储与块类型解耦，可以有效实现转换和改变我们的渲染逻辑。但对于协作而言同样重要，因为我们尽可能保留用户意图。

### 内容和渲染树

块模型的灵活性还允许块嵌套在其他块内部，例如在展开块内部的文本或在页面内部无限嵌套的子页面。块的内容属性存储了一个数组，其中包含了指向这些嵌套块的块ID（或指针）。

在待办事项列表示例中，我们有一个`待办事项`块（“撰写关于块的博客文章”），其内容数组中包含三个块ID。我们将这些ID称为“向下指针”，并称它们指向的块为“内容”或“渲染子节点”。

每个块定义了其内容块渲染的位置和顺序。我们称之为块与其渲染子节点之间的层次关系为“渲染树”。但它并不像树一样有分支 — 不同的块类型以不同的方式渲染其子节点。

以下是几个示例，展示了不同块类型如何渲染内容属性：

+   **列表块** — `Text`、`Bulleted list` 和 `To-do list`。列表块会将它们的内容显示为缩进。

+   **折叠块** — `Toggle list` 块仅在展开时显示内容。否则，它们只显示标题属性。

+   **页面** — `Page` 块会将它们的内容显示在新页面中，而不是在当前页面中缩进渲染。要查看此内容，您需要点击进入新页面。

在结构上，这继续通过允许您在最粒度的级别操作块来增强信息的能力。这是一个保留用户意图的概念，在处理其他信息时，这种意图规定了信息的组织和显示方式。

您是否曾对 Notion 中缩进的工作方式感到惊讶？在传统的文字处理器中，缩进是呈现性的：它只影响文本与边缘的间距。在 Notion 中，缩进是结构性的：它反映了呈现树的结构。换句话说，当您在 Notion 中缩进时，您正在操纵块及其内容之间的关系，而不仅仅是添加样式。

例如，在内容块中按下缩进键会尝试将该块添加到内容树中最近的同级块的内容中。

大多数情况下，缩进的工作方式与传统文档编辑器中的方式相同——当前选定的块将移动到前面块的内容数组中，并在其中缩进渲染。但是，当前面的块不是列表（或根本没有前面的块）时，缩进将不会生效，因为没有地方可以将块移入其中。Notion 中文档的视觉表现反映了它包含的信息的结构。

到目前为止，我们已经解释了如何将块组合起来以组织和结构化您的信息。理解这种结构如何保护您的信息，以便只有合适的人可以阅读或更改它，也非常重要。

块根据它们所在的块（即在树中位于它们上面的块）继承权限。考虑一个页面 —— 要阅读其内容，您必须能够阅读该页面内的块。然而，有两个原因我们不能使用内容数组来构建这种权限系统：

1.  最初，我们允许多个内容数组引用块，以简化我们的协作和并发模型。但是因为一个块可以在多个地方被引用，所以不清楚它将继承哪个块的权限。在权限系统中，模棱两可是不可接受的。

1.  第二个原因是机械性的。为了为一个块实现权限检查，我们需要向上查找树，获取该块的祖先，直到树的根（即工作空间）。试图通过搜索所有块的内容数组来找到这个祖先路径，在客户端上是低效的。

相反，我们使用一个“向上指针” —— 父属性 —— 用于权限系统。向上的父指针和向下的内容指针彼此镜像（在我们正在清理的一些边缘情况之外）。

一个块的生命周期始于客户端。

当你在用户界面上执行操作 —— 在编辑器中输入文字，或者在页面上拖动块 —— 这些更改会表现为操作，创建或更新单个记录。我们团队把“记录”指的是 Notion 中任何类型的持久化数据，比如块、用户、工作空间等。因为许多操作通常会更改多个记录，所以操作会被批量处理成事务，由服务器作为一组进行提交（或者拒绝）。

比如说，你和朋友在一个页面上工作，分别使用不同的电脑编辑一个待办列表。在幕后会发生什么呢？

### 创建和更新块

你按下回车键 —— 这样就创建了一个新的 `To-do` 块。

首先，客户端定义块的所有初始属性，生成一个新的唯一 ID，设置适当的块类型（`to_do`），并填写块的属性（一个空的 `title`，和 `checked: [["No"]]`）。它构建操作来表示使用这些属性创建一个新块。

新块并不是孤立创建的：块也会被添加到其父块的内容数组中，所以它们会在内容树中处于正确的位置。因此，客户端也会生成一个相应的操作。所有这些单独的变更操作都会被组合成一个事务。

然后，客户端将事务中的操作应用于其本地状态。新的块对象在内存中被创建，现有的块被修改。在我们的原生应用程序中，我们使用一个称为 RecordCache 的 LRU（最近最少使用）缓存，在 [SQLite](https://www.notion.so/blog/faster-page-load-navigation) 或 IndexedDB 上存储所有你访问的记录。当你在原生应用上更改记录时，我们也会更新 RecordCache 中的本地副本。编辑器重新渲染以将新创建的块绘制到屏幕上。这在你按键后的几毫秒内完成。

同时，事务也会保存到 TransactionQueue 中，这是客户端的一部分，负责将所有事务发送到 Notion 的服务器，以便将数据持久化并与协作者共享。TransactionQueue 会安全地将事务存储在 IndexedDB 或 SQLite 中（根据平台不同），直到它们被服务器持久化或被拒绝。

### 在服务器上保存更改

这就是你的块如何安全地保存在服务器上，以便你的朋友可以看到它。

通常，TransactionQueue 是空的，因此创建块的事务会立即发送到 Notion 的服务器中，以 API 请求的形式。事务数据被序列化为 JSON，并发布到 `/saveTransactions` API 端点。

SaveTransaction 的主要工作是将你的数据存入我们的源数据数据库中，该数据库存储 Notion 中的所有块数据，以及所有其他持久化记录。

一旦请求到达 Notion API 服务器：

1.  我们加载涉及交易的所有区块和父级。这为我们提供了内存中的“之前”图片。例如，记住我们正在创建一个区块的示例。因此，我们至少需要加载页面区块，以便我们可以将新创建的区块 ID 插入页面内容数组中。

1.  我们复制了刚刚在内存中加载的“之前”数据。然后，我们将交易中的操作应用于新副本，创建了“之后”数据。

1.  然后，我们使用“之前”和“之后”的数据来验证权限和数据的一致性变更。如果一切正常（通常情况下都是这样），所有创建或更改的记录都将提交到数据库中 —— 这意味着您的区块现在正式创建完成。

1.  此时，原始 API 请求接收到了“成功”HTTP 响应。这证实了您的客户端知道交易已成功保存，并且可以继续保存 TransactionQueue 中的下一个交易。

1.  在后台，我们根据您的交易所做的更改类型安排额外的工作。例如，我们为[版本历史](https://www.notion.so/Version-history-eec3af1f5bc64ba0a712ee5794e12a9c)快照和索引区块文本进行安排[Quick Find](https://www.notion.so/Searching-with-Quick-Find-af945b6e69b64437afba2d143e4b546f)。重要的是，我们还通知 MessageStore —— Notion 的实时更新服务 —— 您所做的更改。

在下一节中，我们将介绍数据如何传输到您朋友的屏幕上。

您按下回车键，创建了一个新的区块，现在您的朋友的屏幕上显示出了您的区块。这是如何运作的呢？

每个客户端都与 MessageStore 持久的 WebSocket 连接连接，这是 Notion 的实时更新服务。当 Notion 客户端渲染一个区块（或页面或任何其他类型的记录）时，客户端使用此 WebSocket 连接订阅来自 MessageStore 的该记录的更改。当您的朋友打开与您相同的页面时，他们将订阅所有这些区块的更改。

当您的更改通过保存交易流程后，API 通知 MessageStore 记录了新的版本。 MessageStore 找到已订阅这些变更记录的客户端连接，并通过它们的 WebSocket 连接将新版本传递给它们。

当您朋友的客户端从 MessageStore 接收到版本更新通知时，它会验证其本地缓存中该区块的版本。由于通知中的版本和本地区块的版本不同，它会向服务器发送一个`syncRecordValues`API 请求，带有过时客户端记录的列表。服务器响应新的记录数据。客户端使用此响应数据更新本地缓存，显示最新的区块数据。

您的朋友打了个盹，但您继续处理待办事项清单。为了让他们知道您已对清单进行了一些更改，您向他们发送了一个链接到您共同工作的 Notion 页面。

在你的朋友醒来并点击链接的前几毫秒内，我们首先尝试仅使用本地数据加载页面。在 Web 上，这意味着内存中的块数据。在我们的原生应用上，我们尝试从 RecordCache 持久化存储中加载不在内存中的块。但是如果需要的块数据缺失，我们会停止操作，并从 API 请求页面数据。

用于加载页面数据的 API 方法称为 `loadPageChunk` — 它从一个起始点（通常是页面块的块 ID）开始向下遍历内容树，并返回内容树中的块以及正确渲染这些块所需的任何相关记录。我们为 `loadPageChunk` 使用了几层缓存，但在最坏的情况下，这个 API 可能需要多次访问数据库，因为它递归地向下遍历树，追踪块及其记录依赖关系。

由 `loadPageChunk` 载入的所有数据都存入内存（如果你在使用该应用，还会保存在 RecordCache 中）。数据一旦进入内存，我们会使用 React 对页面进行布局和渲染。

## 为未来构建基础模块

块是 Notion 使任何人或企业能够根据自己的问题定制软件的最基础组件。这种架构为 Notion 的未来铺平了道路 — 新的块类型、自动化（[比如 API](http://developers.notion.so)）、工作流以及能够帮助你创建更强大工具的功能。

尽管我们知道 Notion 这款产品还有很大的提升空间，比如提高效率、性能、离线功能以及编辑器中特定块的怪癖。当你使用 Notion 时，看到的只是浮在水面上的冰山一角。希望通过阅读本文，你能稍微了解底层的一些内容。

我们正在[寻找帮助](https://www.notion.so/careers)来建设 Notion 的未来。你感兴趣吗？
