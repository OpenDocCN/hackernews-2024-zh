<!--yml

分类：未分类

日期：2024-05-27 14:52:19

-->

# [Go, Python, Rust, and production AI applications – Sameer Ajmani](https://ajmani.net/2024/03/11/go-python-rust-and-production-ai-applications/)是由**Sameer Ajmani**所著。

> 来源：[https://ajmani.net/2024/03/11/go-python-rust-and-production-ai-applications/](https://ajmani.net/2024/03/11/go-python-rust-and-production-ai-applications/)

本文将讨论Go、Python和Rust在构建基于AI的应用程序中的角色。

**Python是我最喜欢的第一种编程语言，Go是第二种**。但让我们从头开始……

我在高中线性代数课上发现了编程的力量。我们正在学习线性规划的单纯形法，并期望为考试记住算法。这些步骤完全是机械的，但很繁琐且容易出错。我注意到我们的TI-81计算器支持编程，所以我问老师是否可以用它来实现算法。她同意了。我花了几个小时在计算器上编写程序，但借助它，我在5分钟内完成了原本需要45分钟的考试，并且非常轻松地走出考场。

Pascal是我正式学习的第一门语言，然后是Scheme、C和C++。作为研究生，我学习了Java，并迷恋上了它的安全性、内存管理以及动态加载字节码的能力。作为MIT软件工程课程6.170的助教，我使用Java的动态类加载自动测试和评分学生的编程作业。

然后我发现了Python，它真的很特别。**Python如此简单，页面上如此轻巧，如此可读——感觉就像用自然语言编程**。我开始无论何时都使用Python。甚至在谷歌面试时，我使用Python回答编程问题，以至于面试官要求我写一个双端队列的头文件，以证明我确实了解C++。

一旦我在2004年加入Google，我又开始大部分时间写C++。这也还好，但并不是*愉悦的*。我错过了Python的简洁和轻松，但我理解在“Google规模”所需的效率。但是，[2010年，我发现了Go](https://www.linkedin.com/pulse/gos-early-growth-2012-2016-sameer-ajmani-oxtjc/)，感觉就像有人终于给了我最好的两个世界：一个简单、轻松、愉悦的语言，同时还提供了出色的性能、可靠性和规模化。我非常激动。

我并不孤单。虽然Go被设计为构建网络服务的C++替代品，但其早期采用主要来自动态语言用户，特别是来自Python和Ruby的用户。[Jeremy Manson的文章](https://www.linkedin.com/pulse/language-policy-google-lets-go-jeremy-manson-ffmac/)描述了Google在生产中运行Python时遇到的挑战以及Go如何提供了一种前进的方式。在Google之外也发生了同样的事情，许多Python和Ruby开发者采用Go以实现更高的可靠性和效率，同时保留快速的内部循环。

与此同时，Python正在经历一场复兴。尽管Python在Web后端的使用正在下降，但在数据科学领域的使用却在*蓬勃发展*。科学家们发现了我发现的东西：一种轻便简洁的语言，易于迭代，在Python能够将繁重的数值计算委托给C库时运行效率足够高。科学计算和“大数据”之后是ML开发，现在是LLM应用程序开发。Python是所有这些领域的默认语言，其生态系统丰富而庞大。

但是存在一个问题。Python非常适合处理数据、开发模型和原型应用程序，但不擅长扩展。静态语言的特性——类型检查、编译到机器码等——是实现**大型程序、大型开发团队和大型系统扩展**的关键。而生产系统需要自己的库和工具生态系统，以使开发人员和操作员能够有效地在规模化环境下工作。

我们一直在与正在运行AI驱动应用程序的人们交谈，听到的一直是同样的事情：这些应用程序是用Python编写的，但这些组织不想在生产环境中支持Python。虽然Python可能随着时间的推移在生产环境中变得更好，但AI革命正在此刻发生，人们希望有一种替代方案。我认为这个替代方案就是Go。**LLM驱动的应用程序主要是关于编排**：调用一个或多个模型，顺序或并行地进行，并合成结果——并且在规模化时，对生产操作员提供强大的支持。Go在这方面表现出色。

这里还有几种其他语言可能声称适用，但我想重点介绍一种：Rust。**Rust是一门** ***令人惊叹的*** **语言**。我不会说我*喜欢*它（至少现在不会），但我*尊重*它。Rust提供了毫不妥协的安全性和速度，在并发环境中也是如此。代价是前期程序员的努力：Rust要求程序员提供足够的信息，以便编译器理解对象的生命周期和共享情况，而“管理语言”如Go则为您解决这些问题。Go和Rust团队成员在2021年的文章“[Rust vs. Go: Why They’re Better Together](https://thenewstack.io/rust-vs-go-why-theyre-better-together/)”中探讨了这种权衡。

想象一下Python、Go和Rust在语言光谱上的位置：从Python到Go再到Rust，我们得到了越来越高的安全性和效率。反过来，从Rust到Go再到Python，我们得到了越来越大的便利性和可访问性。此外，每种语言都有丰富但*不同*的库和工具生态系统，使它们适用于不同类型的应用程序。

Python、Go 和 Rust 都有各自的优势，**每种语言在构建以人工智能为驱动的系统中都有其作用**。Python 在开发 AI 模型和原型应用的迭代探索过程中表现出色。Go 在大规模生产这些应用时非常出色。Rust 在速度至关重要时（例如提供 AI 模型服务时）表现极佳。

我们可以注意到，我并没有谈论哪种语言最“高效”。那是因为**你对一种语言或工具的效率取决于工具适合的任务**。用螺丝刀拧螺丝比用锤子更“高效”。选择合适的工具来完成任务。

因此，如果我们相信“在 Python 中原型设计，在 Go 中投入生产”，我们如何使这一切变得简单？我们正在积极研究这个领域。用户告诉我们的头等大事是，他们需要**Go 中相当于用于构建 AI 应用程序的 Python 库**。Python 有一个*庞大*的生态系统（pandas、numpy、Pytorch、tensorflow、JAX、notebook 集成等等）—但我们不需要在 Go 中提供*全部*。我们专注于构建生产 AI 应用所需的库子集，首先从[LangChainGo](https://github.com/tmc/langchaingo)开始。我们急切期待社区的反馈，看看您还需要什么。

我们的目标是让 Go *与* Python *互补*，造福*双方*社区。**让我们搭建起生态系统和社区之间的桥梁，让 Go 和 Python “更好地协作”**。我们将共同推动开发人员创建新一代的生产级 AI 驱动应用程序。
