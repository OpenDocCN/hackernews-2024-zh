- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:41:26'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Chris''s Wiki :: blog/unix/XWindowsAllTheWayDown'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://utcc.utoronto.ca/~cks/space/blog/unix/XWindowsAllTheWayDown](https://utcc.utoronto.ca/~cks/space/blog/unix/XWindowsAllTheWayDown)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Every window system has windows, as an entity. Usually we think of these as
    being used for, well, windows and window like things; application windows, those
    extremely annoying pop-up modal dialogs that are always interrupting you at the
    wrong time, even perhaps things like pop-up menus. In its original state, X has
    more windows than that. Part of how and why it does this is that X allows windows
    to nest inside each other, in a window tree, which you can still see today with
    '`xwininfo -root -tree`'.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons that X has copious nested windows is that X was designed
    with a particular model of writing X programs in mind, and that model made everything
    into a (nested) window. Seriously, everything. In an old fashioned X application,
    windows are everywhere. Buttons are windows (or several windows if they're radio
    buttons or the like), text areas are windows, menu entries are each a window of
    their own within the window that is the menu, visible containers of things are
    windows (with more windows nested inside them), and so on.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: This copious use of windows allows a lot of things to happen on the server side,
    because various things (like mouse cursors) are defined on a per-window basis,
    and also [windows can be created with things like server-set borders](https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html#requests:CreateWindow).
    So the X server can render sub-window borders to give your buttons an outline
    and automatically change the cursor when the mouse moves into and out of a sub-window,
    all without the client having to do anything. And often input events like mouse
    clicks or keys can be specifically tied to some sub-window, so your program doesn't
    have to hunt through its widget geometry to figure out what was clicked. There
    are more tricks; for example, you can get 'enter' and 'leave' events when the
    mouse enters or leaves a (sub)window, which programs can use to highlight the
    current thing (ie, subwindow) under the cursor without the full cost of constantly
    tracking mouse motion and working out what widget is under the cursor every time.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: The old, classical X toolkits like [Xt](https://en.wikipedia.org/wiki/X_Toolkit_Intrinsics)
    and [the Athena widget set (Xaw)](https://en.wikipedia.org/wiki/X_Athena_Widgets)
    heavily used this 'tree of nested windows' approach, and you can still see large
    window trees with '`xwininfo`' when you apply it to old applications with lots
    of visible buttons; one example is 'xfontsel'. Even the venerable xterm normally
    contains a nested window (for the scrollbar, which I believe it uses partly to
    automatically change the X cursor when you move the mouse into the scrollbar).
    However, this doesn't seem to be universal; when I look at [one Xaw-based application](/~cks/space/blog/sysadmin/ToolsXrun)
    I have handy, it doesn't seem to use subwindows despite having [a list widget
    of things to click on](https://www.x.org/releases/current/doc/libXaw/libXaw.html#List_Widget).
    Presumably in Xaw and perhaps Xt it depends on what sort of widget you're using,
    with some widgets using sub-windows and some not. [Another program](/~cks/space/blog/sysadmin/ToolsPyhosts),
    written using [Tk](https://www.tcl.tk/), does use subwindows for its buttons (with
    them clearly visible in '`xwininfo -tree`').
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: This approach fell out of favour for various reasons, but certainly one significant
    one is that it's strongly tied to [X's server side rendering](/~cks/space/blog/unix/XRenderingVsWaylandRendering).
    Because these subwindows are 'on top of' their parent (sub)windows, they have
    to be rendered individually; otherwise they'll cover what was rendered into the
    parent (and naturally they clip what is rendered to them to their visible boundaries).
    If you're sending rendering commands to the server, this is just a matter of what
    windows they're for and what coordinates you draw at, but if you render on the
    client, you have to ship over a ton of little buffers (one for each sub-window)
    instead of one big one for your whole window, and in fact you're probably sending
    extra data (the parts of all of the parent windows that gets covered up by child
    windows).
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: So in modern toolkits, the top level window and everything in it is generally
    only one X window with no nested subwindows, and all buttons and other UI elements
    are drawn by the client directly into that window (usually with client side drawing).
    The client itself tracks the mouse pointer and sends 'change the cursors to <X>'
    requests to the server as the pointer moves in and out of UI elements that should
    have different mouse cursors, and when it gets events, the client searches its
    own widget hierarchy to decide what should handle them (possibly including [client
    side window decorations (CSD)](https://en.wikipedia.org/wiki/Client-side_decoration)).
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: (I think toolkits may create some invisible sub-windows for event handling reasons.
    Gnome-terminal and other Gnome applications appear to create a 1x1 sub-window,
    for example.)
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, another place you can still find this many-window style is in
    some old fashioned X window managers, such as [fvwm](https://fvwm.org/). When
    fvwm puts a frame around a window (such as the ones visible on windows on [my
    desktop](/~cks/space/blog/sysadmin/MyDesktopTour)), the specific elements of the
    frame (the title bar, any buttons in the title bar, the side and corner drag-to-resize
    areas, and so on) are all separate X sub-windows. One thing I believe this is
    used for is to automatically show an appropriate mouse cursor when the mouse is
    over the right spot. For example, if your mouse is in the right side 'grab to
    resize right' border, the mouse cursor changes to show you this.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，你仍然可以在一些老式的X窗口管理器中找到这种多窗口风格，比如[fvwm](https://fvwm.org/)。当fvwm在窗口周围放置一个框架（比如在[我的桌面](/~cks/space/blog/sysadmin/MyDesktopTour)上可见的窗口），框架的特定元素（标题栏、标题栏中的任何按钮、侧边和角落的可调整大小的区域等）都是独立的X子窗口。我相信其中的一个用途是当鼠标悬停在合适的位置时自动显示适当的鼠标指针。例如，如果你的鼠标在右侧的‘调整大小右侧’边框上，鼠标指针会改变以显示给你这一点。
- en: (The window managers for modern desktops, like Cinnamon, don't handle their
    window manager decorations like this; they draw everything as decorations and
    handle the 'widget' nature of title bar buttons and so on internally.)
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: （现代桌面的窗口管理器，比如Cinnamon，不会像这样处理它们的窗口管理器装饰；它们会将所有东西都绘制为装饰，并在内部处理标题栏按钮等的‘小部件’性质。）
