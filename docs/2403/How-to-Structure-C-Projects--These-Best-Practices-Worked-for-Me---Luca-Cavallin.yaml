- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:44:30'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'How to Structure C Projects: These Best Practices Worked for Me | Luca Cavallin'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.lucavall.in/blog/how-to-structure-c-projects-my-experience-best-practices](https://www.lucavall.in/blog/how-to-structure-c-projects-my-experience-best-practices)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I recently worked on two different C projects, and I wanted to structure them
    in a way that would make them easy to maintain and understand. I also wanted to
    make sure that the projects were easy to build and test. In this post, I will
    share my experience and the best practices I found for structuring C projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code for the projects I worked on in the following
    repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: Because of my limited experience with C - I hadn't written any in 10 years -
    I had to do a lot of research to find out what the current consensus is when it
    comes to directory layout. I found a lot of useful information on GitHub, Reddit,
    and Stack Overflow. I also looked at the source code of some popular open-source
    C projects to see how they were structured. I found that most of the projects
    I looked at followed a similar layout, and I decided to use that as a starting
    point.
  prefs: []
  type: TYPE_NORMAL
- en: '[](#what-the-internet-people-say)What The Internet People Say'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you Google for "c project structure best practices" you''ll get about 583.000.000
    results - no need to worry about doing your own research - I read all of those
    pages, twice. While opinions vary, there are some common themes that come up again
    and again. Two approaches are particularly popular:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The "modular" approach**: This is the most common approach for large projects.
    The idea is to split the project into multiple directories, each containing a
    different module of the project. Each module has its own header files, source
    files, and tests. This approach makes it easy to find the code you''re looking
    for and makes it easy to test individual modules in isolation. This is the way
    the [Linux kernel](https://github.com/torvalds/linux) is structured, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The "flat" approach**: This approach is more common for small projects and
    it focuses on keeping the project as simple as possible and yet well-organized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the projects I worked on were relatively small, I decided to use the "flat"
    approach, which I am going to describe next.
  prefs: []
  type: TYPE_NORMAL
- en: '[](#my-approach-to-structuring-c-projects)My Approach to Structuring C Projects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After going through all the 583.000.000 results twice, I settled on the following
    directory layout for my projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's dive deeper into this layout. We can ignore `.devcontainer`, `.github`,
    `.vscode` and `scripts` for now, as they are specific to my development environment
    and not relevant to the project structure. The files `.clang-format` and `.clang-tidy`
    are configuration files for the [Clang](https://clang.llvm.org/) formatter and
    linter, respectively. The `compile_commands.json` file is a compilation database
    for Clang tools. These files are not strictly necessary, but they can be useful
    if you want to use Clang tools in your project. `LICENSE` and `README.md` are
    self-explanatory, and `Makefile` needs no introduction either, although you can
    read more about how I wrote mine in [Crafting a Clean, Maintainable, and Understandable
    Makefile for a C Project](/blog/crafting-clean-maintainable-understandable-makefile-for-c-project).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the more important details, let''s get a few more directories
    out-of-the-way:'
  prefs: []
  type: TYPE_NORMAL
- en: The `bin` directory contains the executable that is created when you run `make`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `build` directory contains the intermediate build files, such as `.o` files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docs` directory contains the documentation for the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's spend some time on the `src`, `include`, `lib`, and `tests` directories.
  prefs: []
  type: TYPE_NORMAL
- en: '[](#the-src-directory)The `src` Directory'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `src` directory contains the C source files for the project, and you will
    spend most of your time here. I decided to keep it simple using a flat layout.
    Besides the `main.c` file which works as the entry file of the program, I split
    the rest of the code based on "concerns" and data-structures. For example, in
    the `gnaro` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`btree.c`: contains the implementation of a B-tree data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cursor.c`: contains the implementation of a cursor for reading and writing
    to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`database.c`: contains the implementation of the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pager.c`: contains the implementation of the pager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`row.c`: contains the implementation of a row in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input.c`, `meta.c` and `statement.c`: contain logic needed to parse and prepare
    user input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I found this simple layout to be easy to understand and navigate. It also makes
    it easy to find the code you're looking for, as long as you make an active effort
    to keep the files small and focused. The downside of this approach is that you
    will need to keep the `Makefile` updated with the new files you add to the project
    so that they are compiled and linked correctly. Given the small size of the projects
    I worked on, I didn't find this to be a problem, but it could be a problem for
    others.
  prefs: []
  type: TYPE_NORMAL
- en: '[](#the-include-directory)The `include` Directory'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `include` directory contains the header files for the project. Most if not
    all of the `.c` files in the `src` directory will have a corresponding `.h` file
    in the `include` directory. The header files should contain the public API for
    the module, and the source files should contain the implementation. This makes
    it easy to see what the module does without having to look at the implementation.
    It also makes it easy to test the module in isolation, as you can just include
    the header file in your test file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, using the `gnaro` project as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`btree.h`: included in `src/btree.c`, defines the public API for the B-tree
    data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cursor.h`: included in `src/cursor.c`, defines the public API for the cursor
    used to read and write from and to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`database.h`: included in `src/database.c`, defines the public API for the
    database implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pager.h`: included in `src/pager.c`, defines the public API for the paging
    logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`row.h`: included in `src/row.c`, defines the public API for the database''s
    row structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input.h`, `meta.h` and `statement.h`: included in `src/input.c` and in `src/meta.c`
    and in `src/statement.c`, defines the public API for handling user input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like the `src` directory, the downside of this layout is that header files
    should be referenced in the `Makefile` so that they are included in the compilation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '[](#the-lib-directory)The `lib` Directory'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `lib` directory contains third-party libraries that the project depends
    on. For example, [lucavallin/gnaro](https://github.com/lucavallin/gnaro) makes
    use of the [argtable](https://www.argtable.org) and [log.c](https://github.com/rxi/log.c)
    libraries for parsing CLI arguments and logging, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There is not much to say about this directory. It's just a place to put your
    dependencies. Again, don't forget to include these in the `Makefile` as well,
    by the way.
  prefs: []
  type: TYPE_NORMAL
- en: '[](#the-tests-directory)The `tests` Directory'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `tests` directory contains the tests for the project. I used the [CUnit](https://cunit.sourceforge.net)
    library for testing, and I found it to be a good fit for my needs. The `tests`
    directory contains a test file for each module in the `src` directory. For example,
    in the `gnaro` project, the `tests` directory cointains `gnaro_test.c` file which
    is meant to test whatever logic defined in `src/gnaro.c`.
  prefs: []
  type: TYPE_NORMAL
- en: At this time, in pratice, the file only contains the code needed to setup the
    tests as recommended by the [CUnit](https://cunit.sourceforge.net) documentation.
    While the tests run, I actually never followed-up on writing useful checks for
    `gnaro` and `barco` since they're just side-, hobby-projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[](#conclusion)Conclusion'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks for reading this far! I hope you found this article useful. I know that
    the project layout I've described is not the only way to organize a C project,
    but it's the way that I've found to be the most effective for me. The `bin`, `build`,
    `docs`, `script`, and ".something" directories are helpful for development purposes,
    but it is in the `src`, `include`, `lib`, and `tests` directories where the real
    work happens.
  prefs: []
  type: TYPE_NORMAL
- en: '`src`: contains the C source files for the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: contains the header files for the project, included by `.c` files
    in `src`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib`: contains third-party libraries that the project depends on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests`: contains the tests for the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Makefile` is the glue that holds everything together and it must be updated
    to include new files and dependencies. While more modern build systems like CMake
    and Meson are available, I found that a simple `Makefile` was sufficient for my
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you can take some of the ideas I've presented here and apply them
    to your own projects. If you have any questions or comments, feel free to reach
    out!
  prefs: []
  type: TYPE_NORMAL
