["```\ntype Operation int\n\nconst (\n\tEscalated Operation = iota\n\tArchived\n\tDeleted\n\tCompleted\n) \n```", "```\nconst (\n\tEscalated Operation = 0\n\tArchived  Operation = 1\n\tDeleted   Operation = 2\n\tCompleted Operation = 3\n) \n```", "```\ntype Operation int\n\nconst (\n\tUnknown Operation = iota\n\tEscalated \n\tArchived\n\tDeleted\n\tCompleted\n)\n\nfunc (o Operation) IsValid() bool {\n\tif o == Unknown {\n\t\treturn false\n\t}\n\treturn true\n} \n```", "```\n const (\n\tunknownStr = \"Unknown\"\n\tescalatedStr = \"Escalated\"\n\tarchivedStr = \"Archived\"\n\tdeletedStr = \"Deleted\"\n\tcompletedStr = \"Completed\"\n)\n\nvar (\n    opsToStrings = map[Operation]string{\n        Escalated: escalatedStr,\n        Archived:  archivedStr,\n        Deleted:   deletedStr,\n        Completed: completedStr,\n    }\n    stringsToOps = map[string]Operation{\n        escalatedStr: Escalated,\n        archivedStr:  Archived,\n        deletedStr:   Deleted,\n        completedStr: Completed,\n    }\n) \n```", "```\nfunc (o Operation) String() string {\n    if s, ok := opsToStrings[o]; ok {\n        return s\n    }\n    return unknownStr\n}\n\nfunc ParseOperation(o any) Operation {\n    switch o := o.(type) {\n    case Operation:\n        return o\n    case int:\n        return Operation(o)\n    case string:\n        return stringToOp(o)\n    case fmt.Stringer:\n        return stringToOp(o.String())\n    }\n    return Unknown\n}\n\n  func (o Operation) IsValid() bool {\n    _, ok := opsToStrings[o]\n\treturn ok\n}\n\n  func stringToOp(o string) Operation {\n    if op, ok := stringsToOps[o]; ok {\n        return op\n    }\n    return Unknown\n} \n```", "```\nfunc (o Operation) MarshalJSON() ([]byte, error) {\n    return []byte(`\"` + t.String() + `\"`), nil\n}\n\nfunc (t *Operation) UnmarshalJSON(b []byte) error {\n    *t = Parse(string(b))\n    return nil\n} \n```", "```\ntype operationContainer struct {\n\tUNKNOWN:   Operation\n\tESCALATED: Operation\n\tARCHIVED:  Operation\n\tDELETED:   Operation\n\tCOMPLETED: Operation\n }\n\nvar Operations = operationContainer {\n\tUNKNOWN: Unknown,\n\tESCALATED: Escalated,\n\tARCHIVED: Archived,\n\tDELETED: Deleted,\n\tCOMPLETED: Completed,\n} \n```", "```\ncmdOp := cmd.Operations.COMPLETED \n```", "```\nfunc (c operationsContainer) All() []Operation {\n    return []Operation{\n        c.ESCALATED,\n        c.ARCHIVED,\n        c.DELETED,\n        c.COMPLETED,\n    }\n} \n```", "```\nopCompleted := cmd.Completed\nenumCompleted := cmd.Operations.COMPLETED \n```", "```\ntype Operation struct {\n    operation\n}\n\ntype operation int\n\nconst (\n    unknown operation = iota\n    escalated\n    archived\n    deleted\n    completed\n) \n```", "```\ntype operationsContainer struct {\n    UNKNOWN   Operation\n    ESCALATED Operation\n    ARCHIVED  Operation\n    DELETED   Operation\n    COMPLETED Operation\n}\n\nvar Operations = operationsContainer{\n    UNKNOWN:   Operation{unknown},\n    ESCALATED: Operation{escalated},\n    ARCHIVED:  Operation{archived},\n    DELETED:   Operation{deleted},\n    COMPLETED: Operation{completed},\n} \n```", "```\nfunc Parse(a any) Operation {\n    switch v := a.(type) {\n    case Operation:\n        return v\n    case string:\n        return Operation{stringToOperation(v)}\n    case fmt.Stringer:\n        return Operation{stringToOperation(v.String())}\n    case int:\n        return Operation{operation(v)}\n    case int64:\n        return Operation{operation(int(v))}\n    case int32:\n        return Operation{operation(int(v))}\n    }\n    return Operation{unknown}\n} \n```", "```\n{\n  \"enums\": [\n     {\n      \"package\": \"cmd\",\n      \"type\": \"operation\",\n      \"values\": [\n        \"Escalated\",\n        \"Archived\",\n        \"Deleted\",\n        \"Completed\"\n      ]\n    }\n  ]\n} \n```", "```\npackage cmd\n\nimport \"fmt\"\n\ntype Operation struct {\n    operation\n}\n\ntype operation int\n\nconst (\n    unknown operation = iota\n    escalated\n    archived\n    deleted\n    completed\n)\n\nvar (\n    strOperationMap = map[operation]string{\n        escalated: \"ESCALATED\",\n        archived:  \"ARCHIVED\",\n        deleted:   \"DELETED\",\n        completed: \"COMPLETED\",\n    }\n\n    typeOperationMap = map[string]operation{\n        \"ESCALATED\": escalated,\n        \"ARCHIVED\":  archived,\n        \"DELETED\":   deleted,\n        \"COMPLETED\": completed,\n    }\n)\n\nfunc (t operation) String() string {\n    return strOperationMap[t]\n}\n\nfunc Parse(a any) Operation {\n    switch v := a.(type) {\n    case Operation:\n        return v\n    case string:\n        return Operation{stringToOperation(v)}\n    case fmt.Stringer:\n        return Operation{stringToOperation(v.String())}\n    case int:\n        return Operation{operation(v)}\n    case int64:\n        return Operation{operation(int(v))}\n    case int32:\n        return Operation{operation(int(v))}\n    }\n    return Operation{unknown}\n}\n\nfunc stringToOperation(s string) operation {\n    if v, ok := typeOperationMap[s]; ok {\n        return v\n    }\n    return unknown\n}\n\nfunc (t operation) IsValid() bool {\n    _, ok := strOperationMap[s]\n    return ok\n}\n\ntype operationsContainer struct {\n    UNKNOWN   Operation\n    ESCALATED Operation\n    ARCHIVED  Operation\n    DELETED   Operation\n    COMPLETED Operation\n}\n\nvar Operations = operationsContainer{\n    UNKNOWN:   Operation{unknown},\n    ESCALATED: Operation{escalated},\n    ARCHIVED:  Operation{archived},\n    DELETED:   Operation{deleted},\n    COMPLETED: Operation{completed},\n}\n\nfunc (c operationsContainer) All() []Operation {\n    return []Operation{\n        c.ESCALATED,\n        c.ARCHIVED,\n        c.DELETED,\n        c.COMPLETED,\n    }\n}\n\nfunc (t Operation) MarshalJSON() ([]byte, error) {\n    return []byte(`\"` + t.String() + `\"`), nil\n}\n\nfunc (t *Operation) UnmarshalJSON(b []byte) error {\n    *t = Parse(string(b))\n    return nil\n} \n```"]