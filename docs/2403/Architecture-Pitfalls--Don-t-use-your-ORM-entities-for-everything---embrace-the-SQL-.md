<!--yml

category: 未分类

date: 2024-05-29 12:46:19

-->

# 架构陷阱：不要把你的ORM实体用于一切 —— 接受SQL吧！

> 来源：[https://www.blackparrotlabs.io/post/architecture-pitfalls-dont-use-your-orm-entities-for-everything](https://www.blackparrotlabs.io/post/architecture-pitfalls-dont-use-your-orm-entities-for-everything)

当设计一个应用程序时，使用JPA/Hibernate时，我遇到了一个常见的模式，建议开发人员尽可能通过它们的持久性实体和ORM与他们的数据库进行交互，尽量避免编写SQL。

‍

这主要源于一种信念，即这种方法将最大化模型的灵活性和数据库的可移植性。有时这也是对学习SQL的厌恶。

‍

关于可移植性的论点有一定的真实性，但实际上，因为几个原因，将自己限制得如此严格通常是一个不好的决定，我将在这篇文章中详细阐述。

‍

### **你真的需要在完全不同的数据库技术之间切换吗？**

‍

通过调查项目的几个商业和技术方面，看看你可以给自己多大的自由度可能会有所帮助。

‍

验证一下你是否真的需要在SQL和NoSQL数据库之间实现可移植性。如果你评估出关系数据模型与你的需求非常匹配，那么很可能你不会在以后完全转换到一个完全不同的模型。

‍

通常情况下，花费过多的精力来保留切换到替代存储技术的能力是不值得的（除非你非常确定你需要它）。

‍

在这一领域的决策可能会由你的技术架构师和产品管理来决定。你应该让他们意识到，他们对这些要求所施加的负担。

‍

更常见的实际需求是在不同的SQL数据库和版本之间实现可移植性 —— 特别是如果你是一个拥有多个客户可能更喜欢使用不同数据库的应用程序供应商。稍后再详细讨论。

‍

顺便说一句，良好的架构实践（如使用[六边形架构](https://jmgarridopaz.github.io/content/hexagonalarchitecture.html)）将使您能够在将来对新的存储技术进行重构而不会破坏公共接口，这几乎肯定比试图完全将实现代码从其底层持久性技术抽象出来要好得多。

‍

### **不要逃避SQL，拥抱它吧！**

‍

我怀疑在Web应用程序开发中曾经讲过的最大谎言之一是，如果你使用ORM，你可以避免编写和理解SQL，“这只是一个实现细节”。起初这可能是真的，但一旦你超越基础知识，这个说法很快就会不复存在。

‍

举例来说，我经常看到*findAll*加过滤器反模式。这是当你从集合中获取所有记录，然后使用应用程序执行一些简单的过滤以包含/排除记录时。

‍

更好的做法是让数据库执行这种类型的过滤。毕竟，所有致力于数据库工作的聪明人花了大量时间和精力来优化这个过程。

‍

对于大多数 ORM，你可以选择编写类似于 SQL 的语言，这可以让你走得更远。例如，JPA 有 JPQL，Hibernate 有 HQL。它们允许你构建抽象的查询，在所有 ORM 支持的数据库上都能工作。

‍

这意味着你的团队需要接受 SQL，并理解如何使用它，而不是通过应用程序代码来避免它。

‍

要消除这种普遍的焦虑源：你并不需要成为 SQL 大师才能开始并熟悉你在大多数实现需求中需要的内容。还有很多优秀的资源和书籍可供参考，下面我会提供一些链接。

‍

与过去一些夸张的说法相反，SQL 并没有消失，也不仅仅是传统技术。掌握基础的 SQL 知识对你的职业生涯是一个良好的投资，在很多地方你会发现它非常有用。

‍

### **避免陷入本地 SQL 陷阱**

‍

ORM SQL 类似语言如 JPQL 只能帮你走得更远，一旦你开始做更复杂的事情，你会发现你超出了 ORM 和版本所支持的范围（这取决于你使用的 ORM 和版本，结果可能有所不同）。

‍

例如，如果你想创建一个物化视图、触发器、更复杂的查询结构等，你通常在 ORM 中找不到这些功能。

‍

一般有两种合理的解决方案：

‍

1) 严格遵守标准的本地 SQL 编写。对于较简单的情况，这可能效果还不错，但许多数据库并不完全符合 SQL 标准，因此你可能会遇到一些意想不到的问题，需要重构以找到最低公共分母。

‍

2) 使用像[jOOQ](https://www.jooq.org)这样的流畅 SQL 构建工具来代表你处理“这个语句应该生成什么 SQL”。这样你可以按照自己喜欢的方式编写查询，而 jOOQ 将为你的目标数据库和版本找到正确的 SQL 语句。其他语言也存在类似的替代品。

‍

我认为如果可能的话，后一种方法更好 —— 如果你可以朝这个方向发展的话。维护本地 SQL 可能会很麻烦，特别是如果你需要支持多个数据库。如果可能，让像 jOOQ 这样的库来处理吧！

‍

### **编程式查询构建**

‍

这与 Java 相关，但我强烈建议避免使用 JPA Criteria API。按现代标准来看，这个查询构建器的设计复杂且难以理解和维护。

‍

幸运的是，现在有一些很棒的替代方案，不会让你头疼。我可以亲自推荐的两个解决方案是：[jOOQ](https://www.jooq.org) 和 [BlazePersistence](https://persistence.blazebit.com)。

‍

这两者都为你提供了现代、流畅的API，让你无需麻烦地编程构建查询。

‍

BlazePersistence是面向Hibernate的，但对所有数据库免费，而jOOQ具有更广泛的功能集，但对某些非免费企业数据库需要适度的开发者费用。我认为jOOQ是值得付费的，但你可能需要与你公司的财务人员争取批准。如果你使用常见的免费和开源数据库如Postgres，jOOQ是免费的。

‍

### **投影是你的朋友**

‍

我经常看到的一种模式是始终在查询中返回完整的ORM实体，然后仅复制到DTOs中所需的字段（然后返回给调用者）。

‍

对于更简单的用例，这通常是可以接受的，但对于更大和/或更昂贵的查询，它可能会对性能产生显著影响。换句话说，这会在数据库、序列化、反序列化和网络流量中引起显著的额外工作，只是为了丢弃大部分数据。你可能还会注意到，“真正的”ORM实体可能会有相当多的开销；这是因为你的ORM提供的关键功能需要注入代理、拦截器、包装器等。

‍

相反，你应该考虑使用投影。本质上，这只是一个SQL查询，返回你需要的数据，并将结果映射到专门设计用于保存该数据的对象中。这通常会比你的数据模型更简化和扁平化。好处是它轻量级并且消除了不必要的开销。缺点是这些通常不是“真正”的实体，因此你不能使用它们进行写操作 —— 通常你也不想这样做！

‍

就我目前的经验而言，我发现JPA/Hibernate处理投影的内置方式非常不方便和难以维护（例如冗长的基于构造函数的语法）。我怀疑这可能是为什么那么多人使用效率低下的“应用投影”方式的原因之一。

‍

相反，我建议使用[BlazePersistence的Entity View](https://persistence.blazebit.com/documentation/1.6/entity-view/manual/en_US/)模块或[jOOQ的DTOs/projections。](https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos/)这两者都提供更方便的映射方式，通常包括代码生成，以消除保持Java类与投影查询“同步”的要求。

‍

经验告诉我们，在返回大量数据和复杂查询时使用投影很快就会得到回报，所以不要犹豫！

‍

顺便说一句，如果你在使用较新版本的Java，你也可以利用[records](https://docs.oracle.com/en/java/javase/19/language/records.html)进一步减少样板噪音。

‍

一个潜在的注意点是，如果您正在使用ORM的二级缓存，则可能需要有选择地清除它以避免陈旧问题。关于ORM中的二级缓存，人们有很强的意见，我这里不打算深入讨论这个领域！

‍

‍

让我们快速运行一个示例。

‍

假设您有一个列表端点，返回一个实体，该实体又与另外两个实体相关联。您只想返回总字段的一个子集（用红色突出显示）。通过使用投影*ApiVersionSearchResult*，您可以获得一个简单而紧凑的表示形式，而无需更改其余API。而且使用仅选择所需字段的查询，您的数据库会感谢您。

‍

在实践中，要实现这一点，您将创建一个简单的查询，并将其“投射”到您的*ApiVersionSearchResult*中。具体的实现细节取决于您选择的方法。以下是一些流行的方法：

‍

‍

顺便说一句，我还见过一些系统使用现有的*@entity*对象返回“投影”，其中包含空字段，并使用Jackson的*Include.NON_NULL*，这意味着空字段不会出现在序列化的载荷中；一种穷人版的投影。通过这样做，你未来可能会遇到问题，所以我建议避免这种模式（/post/dont-let-your-persistence-layer-bleed-into-your-presentation-layer）。

‍

### **不要害怕混合和匹配**

‍

对于基本功能，请使用您的ORM（通常是您所需的大部分内容），并在超出其能力范围时使用其他方法。不要觉得自己必须完全采用单一的方法。

‍

### **但是，这一切都是显而易见的！**

‍

更有经验的开发人员通常会说这一切都很显而易见。然而，我已经多次见过所有这些错误，所以显然还需要重复。作为一个行业，我怀疑我们在这些主题上向年轻开发人员传递机构知识方面并不是很好。

‍

此外，在软件工程中，我们喜欢丢弃正统观念，直到我们发现我们之前的做法有其原因。例如，2012年左右开始的“SQL已死”潮流，后来SQL复兴时，我们意识到它实际上在很多方面都做得很好（并吸收了NoSQL存储的一些想法，比如JSON支持）。
