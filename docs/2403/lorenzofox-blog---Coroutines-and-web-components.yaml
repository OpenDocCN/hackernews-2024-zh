- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:43:21'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: lorenzofox blog | Coroutines and web components
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://lorenzofox.dev/posts/component-as-infinite-loop/](https://lorenzofox.dev/posts/component-as-infinite-loop/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <main id="main">
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: In the [previous article](/posts/coroutine) we learned what coroutines are and
    saw some patterns they can help implement. In this article, we will see how coroutines
    can be used to model web components in a different way, and why you might like
    it.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Among other things, coroutines have a few properties that we will use in this
    short essay:'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: They are primarily **functions** and can benefit from the whole functional arsenal
    of Javascript (composition, higher order function, delegation, etc.).
  id: totrans-split-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are **stateful**.
  id: totrans-split-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can inject pretty much any kind of data when they are paused. For example,
    an infinite loop within the body of the routine can be considered as a public
    API function.
  id: totrans-split-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot, by design, call the `next` function concurrently.
  id: totrans-split-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following generator:'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-14
  prefs: []
  type: TYPE_PRE
- en: 'It takes a `$host` DOM element and has a rendering loop. You can wrap this
    generator with a function that produces a `render` function:'
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-16
  prefs: []
  type: TYPE_PRE
- en: 'For now, the rendering loop is a piece of imperative code, but it can use any
    rendering library you want (react and so on). The first point above says that
    functions (and therefore coroutines) are very versatile in Javascript. We could
    easily go back to a known paradigm if we wanted to. For example, we use [lit-html](./todo)
    to have a declarative view instead of a bunch of imperative code:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-18
  prefs: []
  type: TYPE_PRE
- en: 'you can draw the template into a function:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-20
  prefs: []
  type: TYPE_PRE
- en: 'And compose with a new higher order function:'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
- en: 'All right, we are on familiar ground: our component is now a simple function
    of the state'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-24
  prefs: []
  type: TYPE_PRE
- en: 'Having an infinite rendering loop to model our component can actually be more
    interesting than it seems at first: you can have a state in the closure of that
    loop.'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: 'If we first modify the higher-level `createComponent` function a little to
    bind the `render` function to the host element:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-27
  prefs: []
  type: TYPE_PRE
- en: 'We can now make the component trigger its own rendering:'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-29
  prefs: []
  type: TYPE_PRE
- en: In frameworks like React, where you only have access to the equivalent of what
    is inside the loop, you rely on the framework extension points (the hooks in the
    case of React) to build this sort of mechanism, and have very little control over
    rendering scheduling.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The component embeds its view and some logic at the same time. Again, we can
    easily decouple them so that we can reuse either the view or the logic: All we
    need to do is take advantage of the third property of coroutines mentioned in
    the introduction, and a simple delegation mechanism inherent to generators: `yield*`.'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-32
  prefs: []
  type: TYPE_PRE
- en: 'This type of mixin is responsible for holding the state and triggering the
    rendering of any *view*. Rendering is left to the view thanks to **delegation**,
    while the state is passed whenever the view coroutine is paused and requires a
    new render:'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-34
  prefs: []
  type: TYPE_PRE
- en: 'Neat ! You can now use the “clickable” behaviour independently, on different
    views. In the same way, you can plug the view into a different controller logic,
    as long as it passes the expected data interface (`{ count: number | string}`):
    note how the data comes from the `yield` assignation.'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: We will see more patterns like this in future articles.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: So far we have designed our component to be a function of the host. We can go
    further and ensure that the rendering routine is actually private to the host,
    so that the rendering code is encapsulated inside along with any potential behaviour
    enhancements (the `countClickable` mixin for example), while both remain reusable.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another way of modelling [custom elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements).
    To enhance your HTML document, you can teach the browser new ones using its registry
    and the `define` method.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-39
  prefs: []
  type: TYPE_PRE
- en: And then use the `hello-world` tag in the markup like any other regular HTML
    tag.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-41
  prefs: []
  type: TYPE_PRE
- en: Instead of using a class that extends the `HTMLElement` class (or any other
    valid built-in element class), we want the second argument to be a generator function.
    This means our custom `define` would need to turn the generator into a class.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-43
  prefs: []
  type: TYPE_PRE
- en: Using a class expression, we create the custom element class on the fly. The
    `#loop` rendering routine is instantiated inside the constructor and advanced
    to its first `yield` point. Note that we pass the host as a parameter to the routine,
    although the routine is specifically bound to the host so that we could just use
    `this` inside the generator to refer to the host. This is a personal preference
    as I find the use of `this` in Javascript very error-prone.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: When the `connectedCallback` is called (this happens when the component is mounted
    into the DOM). We call `next` again, which in our previous example corresponds
    to the first iteration of the loop. Then, whenever the component needs to be rendered
    (when `render` is called) again, we continue the loop.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very interesting because we are able to match the different component
    lifecycles to a location within the generator function:'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-split-47
  prefs: []
  type: TYPE_PRE
- en: Yet, one important lifecycle remains to be implemented. When the component is
    unmounted, the `disconnectedCallbak` of the class definition is normally called,
    allowing us to run cleanup code and avoid memory leaks for example.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: In the generator we can force the exit of the loop into a `finally` clause.
    This is as simple as calling the loop’s `return` function instead of the usual
    `next`.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Altogether:'
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-split-51
  prefs: []
  type: TYPE_PRE
- en: 'This “linear” representation of the component and its lifetime makes things
    easier to reason about: there are no surprises when a callback or a hook is called,
    everything is read from top to bottom!'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we conclude, we can illustrate the fourth point mentioned in the introduction:
    if you try to advance a generator function while it is already advancing, you
    will get an error. In the component world, this means that concurrent rendering
    is impossible by design!'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: 'This code:'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
- en: 'will trigger an error `Uncaught TypeError: already executing generator`.'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: We have seen throughout this article that the functional nature of a generator
    combined with its intrinsic properties can be useful to build a very flexible
    and simple abstraction of UI component, with the ability to split behaviour and
    view into reusable bits, to maintain internal state or to have at reach all component
    lifecycles in the same place.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: In [the next article](/posts/reactive-attributes), we will see how we can further
    improve and optimise our generator-to-class conversion.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: </main>
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
