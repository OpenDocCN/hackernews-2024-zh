["```\nlet areEqual = (1, true, \"hello\") == (1, false, \"hello\")\nprint(areEqual)\n// false \n```", "```\nfunc == (lhs: (), rhs: ()) -> Bool\n\nfunc == <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A: Equatable, B: Equatable\n\nfunc == <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A: Equatable, B: Equatable, C: Equatable\n\n// and so on, up to 6-element tuples \n```", "```\nfunc == <each Element: Equatable>(lhs: (repeat each Element), rhs: (repeat each Element)) -> Bool \n```", "```\nlet areEqual = (1, true, \"hello\") == (1, false, \"hello\")\nprint(areEqual)\n// false \n```", "```\nstruct NotEqual: Error {}\n\nfunc == <each Element: Equatable>(lhs: (repeat each Element), rhs: (repeat each Element)) -> Bool {\n  // Local throwing function for operating over each element of a pack expansion.\n  func isEqual<T: Equatable>(_ left: T, _ right: T) throws {\n    if left == right {\n      return\n    }\n\n    throw NotEqual()\n  }\n\n  // Do-catch statement for returning false as soon as two tuple elements are not equal.\n  do {\n    repeat try isEqual(each lhs, each rhs)\n  } catch {\n    return false\n  }\n\n  return true\n} \n```", "```\nfunc == <each Element: Equatable>(lhs: (repeat each Element), rhs: (repeat each Element)) -> Bool {\n\n  for (left, right) in repeat (each lhs, each rhs) {\n    guard left == right else { return false }\n  }\n  return true\n} \n```", "```\nfunc allEmpty<each T>(_ array: repeat [each T]) -> Bool {\n  for a in repeat each array {\n    guard a.isEmpty else { return false }\n  }\n\n  return true\n} \n```", "```\nprint(allEmpty([\"One\", \"Two\"], [1], [true, false], []))\n// False \n```", "```\nprotocol ValueProducer {\n  associatedtype Value: Codable\n  func evaluate() -> Value\n} \n```", "```\nfunc evaluateAll<each V: ValueProducer, each E: Error>(result: repeat Result<each V, each E>) -> [any Codable] {\n  var evaluated: [any Codable] = []\n  for case .success(let valueProducer) in repeat each result {\n    evaluated.append(valueProducer.evaluate())\n  }\n\n  return evaluated\n} \n```", "```\nstruct IntProducer: ValueProducer {\n\n  let contained: Int\n\n  init(_ contained: Int) {\n    self.contained = contained\n  }\n\n  func evaluate() -> Int {\n    return self.contained\n  }\n}\n\nstruct BoolProducer: ValueProducer {\n\n  let contained: Bool\n\n  init(_ contained: Bool) {\n    self.contained = contained\n  }\n\n  func evaluate() -> Bool {\n    return self.contained\n  }\n}\n\nstruct SomeError: Error {}\n\nprint(evaluateAll(result:\n                    Result<SomeValueProducer, SomeError>.success(SomeValueProducer(5)),\n                    Result<SomeValueProducer, SomeError>.failure(SomeError()),\n                    Result<BoolProducer, SomeError>.success(BoolProducer(true))))\n\n// [5, true] \n```"]