["```\nbash -c 'echo \"bye dad\"' \n```", "```\nbash -c '(sleep 10; echo \"bye grandpa\") & exit' \n```", "```\n/* If we still have a PTY, or data to process, defer emitting the signals\n * until we have EOF on the PTY, so that we can process all pending data.\n */\nif (pty() || !m_incoming_queue.empty()) {\n        m_child_exit_status = status;\n        m_child_exited_after_eos_pending = true;\n\n        m_child_exited_eos_wait_timer.schedule_seconds(2); // FIXME: better value?\n} else {\n        m_child_exited_after_eos_pending = false;\n\n        if (widget())\n                widget()->emit_child_exited(status);\n} \n```", "```\nif (widget())\n        widget()->emit_child_exited(status); \n```", "```\n/* If we still have a PTY, or data to process, defer emitting the signals\n * until we have EOF on the PTY, so that we can process all pending data.\n */\nif (pty()) {\n        /* Read and process about 64k synchronously, up to EOF or EAGAIN\n         * or other error, to make sure we consume the child's output.\n         * See https://gitlab.gnome.org/GNOME/vte/-/issues/2627 */\n        pty_io_read(pty()->fd(), G_IO_IN, 65536);\n        if (!m_incoming_queue.empty()) {\n                process_incoming();\n        }\n\n        /* Stop processing data. Optional. Keeping processing data from grandchildren and\n         * other writers would also be a reasonable choice. It makes a difference if the\n         * terminal is held open after the child exits. */\n        unset_pty();\n}\n\nif (widget())\n        widget()->emit_child_exited(status); \n```", "```\nxfce4-terminal -e fortune \n```", "```\nxfce4-terminal --hold -e fortune \n```", "```\n--- a/src/vte.cc\n+++ b/src/vte.cc\n@@ -3265,9 +3265,6 @@ Terminal::child_watch_done(pid_t pid,\n\n         m_pty_pid = -1;\n\n-        /* Close out the PTY. */\n-        unset_pty();\n-\n         /* Tell observers what's happened. */\n         if (m_real_widget)\n                 m_real_widget->emit_child_exited(status); \n```", "```\n/* If we still have a PTY, or data to process, defer emitting the signals\n * until we have EOF on the PTY, so that we can process all pending data.\n */\nif (pty()) {\n        /* Read and process about 64k synchronously, up to EOF or EAGAIN\n         * or other error, to make sure we consume the child's output.\n         * See https://gitlab.gnome.org/GNOME/vte/-/issues/2627 */\n        pty_io_read(pty()->fd(), G_IO_IN, 65536);\n        if (!m_incoming_queue.empty()) {\n                process_incoming();\n        }\n\n        /* Stop processing data. Optional. Keeping processing data from grandchildren and\n         * other writers would also be a reasonable choice. It makes a difference if the\n         * terminal is held open after the child exits. */\n        unset_pty();\n}\n\nif (widget())\n        widget()->emit_child_exited(status); \n```", "```\n/* Close out the PTY. */\nunset_pty();\n\n/* Tell observers what's happened. */\nif (widget())\n        widget()->emit_child_exited(status); \n```", "```\n/* If we still have a PTY, or data to process, defer emitting the signals\n * until we have EOF on the PTY, so that we can process all pending data.\n */\nif (pty() || !m_incoming_queue.empty()) {\n        m_child_exit_status = status;\n        m_child_exited_after_eos_pending = true;\n\n        m_child_exited_eos_wait_timer.schedule_seconds(2); // FIXME: better value?\n} else {\n        m_child_exited_after_eos_pending = false;\n\n        if (widget())\n                widget()->emit_child_exited(status);\n} \n```", "```\n/* If we still have a PTY, or data to process, defer emitting the signals\n * until we have EOF on the PTY, so that we can process all pending data.\n */\nif (pty()) {\n        /* Read and process about 64k synchronously, up to EOF or EAGAIN\n         * or other error, to make sure we consume the child's output.\n         * See https://gitlab.gnome.org/GNOME/vte/-/issues/2627 */\n        pty_io_read(pty()->fd(), G_IO_IN, 65536);\n        if (!m_incoming_queue.empty()) {\n                process_incoming();\n        }\n\n        /* Stop processing data. Optional. Keeping processing data from grandchildren and\n         * other writers would also be a reasonable choice. It makes a difference if the\n         * terminal is held open after the child exits. */\n        unset_pty();\n}\n\nif (widget())\n        widget()->emit_child_exited(status); \n```", "```\nif (widget())\n        widget()->emit_child_exited(status); \n```", "```\n/* Close out the PTY. */\nunset_pty();\n\n/* Tell observers what's happened. */\nif (widget())\n        widget()->emit_child_exited(status); \n```", "```\n/* A chunk of code that makes no difference. */\n\nif (widget())\n        widget()->emit_child_exited(status); \n```", "```\nxfce4-terminal --hold -e \"bash -i -c '(sleep 10; echo bye grandpa) & exit'\" \n```", "```\n@@ -10283,19 +10287,12 @@ Terminal::emit_pending_signals()\n                 m_bell_pending = false;\n         }\n\n-        auto const eos = m_eos_pending;\n         if (m_eos_pending) {\n                 queue_eof();\n                 m_eos_pending = false;\n\n                 unset_pty();\n         }\n-\n-        if (m_child_exited_after_eos_pending && eos) {\n-                /* The signal handler could destroy the terminal, so send the signal on idle */\n-                queue_child_exited();\n-                m_child_exited_after_eos_pending = false;\n-        }\n }\n\n void \n```", "```\nif (widget())\n        widget()->emit_child_exited(status); \n```"]