<!--yml

category: 未分类

date: 2024-05-29 12:30:50

-->

# C++的真正杀手们（不是你，Rust）

> 来源：[https://wordsandbuttons.online/the_real_cpp_killers.html](https://wordsandbuttons.online/the_real_cpp_killers.html)

这是[Words and Buttons Online](index.html) — 一个关于[#数学](all_mathematics.html)，[#算法](all_algorithms.html)和[#编程](all_programming.html)的交互式[#教程](all_tutorials.html)，[#演示](all_demos.html)和[#测验](all_quizzes.html)的集合。

# C++的真正杀手们（不是你，Rust）

你好！我是Oleksandr Kaleniuk，我是一个C++成瘾者。我已经写了17年的C++，在这17年里，我一直在努力摆脱这种毁灭性的瘾。

一切始于2005年末的一个3D空间模拟引擎。引擎拥有2005年C++所拥有的一切。三星指针，八层依赖，到处都是C风格的宏定义。也有一些汇编代码。有斯坦诺夫风格的迭代器，还有亚历山大斯库风格的元代码。代码应有尽有。当然，除了最重要的问题的答案：为什么？

不久之后，甚至那个问题也有了答案。只不过不是“为什么”，而是“怎么回事”。结果发现，引擎已经由5个不同的团队编写了大约8年时间。每个团队都将他们喜欢的时髦风潮带到项目中，用时髦的包装将旧代码包裹起来，但对引擎本身增加的价值甚少。

起初，我诚实地试图理解每一个小细节。但那并不是一种令人满意的经历，一点也不，而且在某个时刻，我放弃了。我仍然在关闭任务和修复错误。不能说我非常有生产力，只是足够不被解雇。但后来我的老板问我：“你想把一些汇编代码重写成GLSG吗？”我想，天晓得GLSL看起来像什么，但肯定比C++差不了多少，所以我说好。结果并不差。

然后这种情况变成了一种模式。我仍然大部分时间在写C++，但每当有人问我：“你想做那个非C++的事情吗？”我都会说：“当然！”然后我就去做那些事情，不管它是什么。我写过C89，MASM32，C#，PHP，Delphi，ActionScript，JavaScript，Erlang，Python，Haskell，D，Rust，甚至那个极其糟糕的InstallShield脚本语言。我写过VisualBasic，在bash中写过，在几种我不能合法谈论的专有语言中也写过。我甚至无意中制作了一个自己的语言。我制作了一个简单的类Lisp解释器，帮助游戏设计师自动加载资源，然后休假去了。当我回来时，他们已经在这个解释器中编写整个游戏场景了，所以我们必须支持它一段时间。

因此，在过去的17年里，我一直在努力摆脱 C++，但每次尝试了新的耀眼事物后，我都会回来。尽管如此，我仍认为在 C++ 中编程是一种坏习惯。它不安全，不像人们想象的那么有效，并且浪费了程序员大量的心智容量在与软件制作无关的事情上。你知道在 MSVC 中 **uint16_t(50000) * uint16_t(50000) == -1794967296** 吗？你知道为什么吗？是的，我也是这么想的。

我认为，长期从事 C++ 的程序员有道义责任劝阻年轻一代不要把 C++ 作为他们的职业，就像无法戒酒的人有道义责任警告青少年危险一样。

但为什么我就不能退出呢？怎么了？问题在于，没有一种语言，特别是所谓的“C++ 杀手”，在现代世界中真正能比得上 C++ 的优势。所有这些新语言大多集中于控制程序员，为了他们自己的利益。这没什么问题，除了用坏程序员写好代码是二十世纪的问题，当时晶体管密度每18个月增长一倍，而程序员的人数每5年增长一倍。

现在我们生活在二十一世纪。世界上比历史上任何时候都有更多经验丰富的程序员。而且我们现在比以往任何时候都更需要高效的软件。

在二十世纪，事情更简单。你有一个想法，把它包装成一些 UI 并作为桌面产品出售。它慢吗？谁在乎！18个月后桌面电脑将会变得两倍快。重要的是进入市场，开始销售功能，最好没有 bug。在那种氛围中，如果一个编译器能阻止程序员制造 bug - 很好！因为 bug 不会带来现金，而且无论程序员是增加功能还是增加 bug，你都必须支付他们的薪水。

现在情况不同了。你有一个想法，把它放入一个 Docker 容器中，在云中运行。现在，如果你的软件能解决他们的问题，你就能从使用你的软件的人那里得到收入。即使它只完成一件事，但做得正确，你也会得到报酬。你不必为了销售新版本而在产品中塞满虚构的功能。另一方面，现在付出代码低效的代价的是你自己。每一个次优的程序都会反映在你的 AWS 账单上。

因此，在新的环境中，你现在需要更少的功能，但你也需要更好的性能，无论你有什么功能。

突然间，所有的“C++ 杀手”，甚至我真诚喜爱和尊重的 Rust、Julia 和 D，都没有解决二十一世纪的问题。它们仍然停留在二十世纪。它们确实帮助你写出更少 bug 的更多功能，但在你需要从你租用的硬件中挤出最后一点 FLOPS 时，它们并不是很有帮助。

因此，它们仅仅在C++上具有竞争优势。或者，更广义地说，它们甚至在彼此之间也具有竞争优势。例如，大多数编程语言，如Rust、Julia和Cland，甚至共享相同的后端。如果所有赛车手都坐在同一辆车里，谁会在赛车比赛中获胜呢？

那么，哪些技术能让你在C++或者更广义地说，在所有传统的编译器之前获得竞争优势呢？

很好的问题！

很高兴你问到这个问题。

## C++杀手第一。SPIRAL

但在我们开始讨论SPIRAL本身之前，让我们检查一下你的直觉有多准确。你认为哪个更快：标准的C++正弦函数，还是四段多项式模型的正弦函数？

|

```
// version 1
auto y = std::sin(x);

// version 2
y = -0.000182690409228785*x*x*x*x*x*x*x
    +0.00830460224186793*x*x*x*x*x
    -0.166651012143690*x*x*x
    +x;

```

|

下一个问题。在逻辑操作中，使用短路运算更快，还是将逻辑表达式转换为算术运算更快？

|

```
// version 1	
  if (xs[i] == 1 
   && xs[i+1] == 1 
   && xs[i+2] == 1 
   && xs[i+3] == 1) // xs are bools stored as ints

// version 2
  inline int sq(int x) {
      return x*x;
  }

  if(sq(xs[i] - 1) 
   + sq(xs[i+1] - 1) 
   + sq(xs[i+2] - 1) 
   + sq(xs[i+3] - 1) == 0)

```

|

还有一个问题。哪种排序三元组更快：带有分支的交换排序，还是无分支的索引排序？

|

```
// version 1
    if(s[0] > s[1])
        swap(s[0], s[1]);
    if(s[1] > s[2])
        swap(s[1], s[2]);
    if(s[0] > s[1])
        swap(s[0], s[1]);

// version 2
    const auto a = s[0];
    const auto b = s[1];
    const auto c = s[2];
    s[int(a > b) + int(a > c)] = a;
    s[int(b >= a) + int(b > c)] = b;
    s[int(c >= a) + int(c >= b)] = c;

```

|

如果你果断地回答了所有问题，甚至没有思考或查找，那么你的直觉就误导了你。你没有看到陷阱。所有这些问题都没有明确的答案，没有上下文。

1\. 在使用clang 11和**-O2 -march=native**编译，并在Intel Core i7-9700F上运行时，多项式模型比标准正弦函数快<nobr>[3倍](https://wordsandbuttons.online/challenge_your_performance_intuition_with_cpp_sine.html)</nobr>。但是，如果使用NVCC和**--use-fast-math**，并在GPU GeForce GTX 1050 Ti Mobile上运行时，标准正弦函数比模型快10倍。

2\. 在i7上，将短路逻辑换成矢量化算术运算也是有意义的。这样做可以使代码片段运行速度加快一倍。但在ARMv7上，即使使用相同的clang和**-O2**优化选项，标准逻辑运算比微优化<nobr>[快25%](https://wordsandbuttons.online/using_logical_operators_for_logical_operations_is_good.html)</nobr>。

3\. 在Intel平台上，使用索引排序比使用交换排序快3倍，在GeForce上，交换排序比<nobr>[快3倍](https://wordsandbuttons.online/check_if_your_performance_intuition_still_works_with_cuda.html)</nobr>。

所以，我们如此喜欢的微优化，它们既可以将我们的代码加速三倍，也可能使其减速90%。这一切取决于上下文。如果编译器能够为我们选择最佳的替代方案，比如在切换构建目标时索引排序神奇地变成了交换排序，那该有多好啊。但编译器无法做到这一点。

1\. 即使我们允许编译器将正弦函数重新实现为多项式模型，以便在速度上进行折衷，它仍然不知道我们的目标精度。在C++中，我们不能说“这个函数允许有那个误差”。我们只有像“--use-fast-math”这样的编译器标志，而且仅在一个翻译单元的范围内。

2\. 在第二个示例中，编译器不知道我们的值仅限于0或1，并且不可能提出我们可以的优化。也许我们可以通过使用适当的布尔类型来暗示这一点，但那将是一个完全不同的问题。

3\. 在第三个例子中，代码片段非常不同，无法被识别为同义词。我们详细说明了代码太多。如果只是std::sort，这已经可以让编译器有更多选择算法的自由。但它不会选择索引排序或交换排序，因为它们在大数组上都效率低下，而std::sort适用于通用的可迭代容器。

这就是我们介绍 [SPIRAL](https://www.spiral.net/) 的方式。它是卡内基梅隆大学和苏黎世联邦理工学院的联合项目。简而言之：信号处理专家们厌倦了为每一块新硬件手动重写他们喜欢的算法，于是写了一个程序来代替他们完成这项工作。该程序接受算法的高级描述和硬件架构的详细描述，并优化代码，直到实现最有效的算法实现为止。

Fortran等语言与SPIRAL之间的一个重要区别是，SPIRAL确实在数学意义上解决了一个优化问题。它将运行时定义为目标函数，并在硬件架构限制的实现变体因子空间中寻找其全局最优解。这是编译器实际上从未做过的事情。

编译器不会寻求真正的最优解。它优化代码时是根据程序员教给它的启发式方法来进行的。实质上，编译器并不像机器一样搜索最优解，而更像是一个汇编程序员。一个优秀的编译器工作起来就像一个优秀的汇编程序员，但也仅限于此。

SPIRAL是一个研究项目。它的范围和预算有限。但它展示的结果已经令人印象深刻。在快速傅里叶变换方面，他们的解决方案显著优于MKL和FFTW的实现。他们的代码快约为~2倍。即使在Intel上也是如此。

仅仅为了突显其成就的规模，MKL是英特尔自身的数学核心库，所以是那些最了解如何使用他们硬件的人开发的。而WWTF即“西部最快傅里叶变换”是一种高度专业化的库，由那些最了解算法的人开发。它们都是各自领域的冠军，SPIRAL能够双双超越它们，实在令人震惊。

这是他们的 GitHub 页面：[https://github.com/spiral-software/spiral-software](https://github.com/spiral-software/spiral-software)。如果您对以上数字不够满意，可以自行重新测量。

当SPIRAL使用的优化技术最终完成并商业化时，不仅C++，而且Rust、Julia甚至Fortran都将面临以往未曾有过的竞争。如果使用高级算法描述语言编写代码可以使代码运行速度提高2倍，那么为什么还要用C++呢？

## C++的第二个杀手 Numba

最好的编程语言是你已经很熟悉的那种。几十年来，大多数程序员最熟悉的语言一直是C。它也在TIOBE指数中排名第一，其他类似C的语言也紧密地占据前十名。然而，仅仅两年前发生了前所未闻的事情。C把第一名让给了另一种语言。

“某种东西”似乎是Python。在90年代，这门语言没人认真对待，因为它只是另一种我们已经有很多的脚本语言。

有人会说：“啊，Python很慢”，这看起来会像个傻瓜，因为这是术语上的无意义。就像手风琴或煎锅一样，一种语言根本就不能快或慢。就像手风琴的速度取决于谁在演奏一样，一种语言的“速度”取决于它的编译器有多快。

“但Python不是一种编译语言”有人可能会接着说，并再次误解。有很多Python编译器，其中最有前途的是其自身的Python脚本。让我解释一下。

我曾经有一个项目。一个3D打印模拟最初是用Python编写的，然后为了提高性能改写成了C++，然后又被移植到GPU上，这些都是在我参与之前完成的。然后我花了几个月时间将构建移植到Linux，优化了为AWS上的Tesla M60而写的GPU代码，并验证了所有在C++/CU代码中的更改，以与Python原始代码保持一致。所以我做了所有的事情，除了我通常专门从事的几何算法。

最后，当我终于把一切都搞定的时候，一位布雷梅的兼职学生给我打电话，问：“所以你擅长异构的东西，能帮我在GPU上运行一个算法吗？”当然可以！我告诉他关于CUDA、CMake、Linux构建、测试和优化的所有事情；我们可能聊了一个小时。他很有礼貌地听了所有的话，但最后说：“这一切都很有趣，但我有一个非常具体的问题。所以我有一个函数，在它的定义之前我写了@cuda.jit，Python说一些关于数组的东西，而且不编译内核。你知道这里可能的问题是什么吗？”

我不知道。他自己一个人在一天内就搞定了。显然，Numba不能处理原生的Python列表，它只接受NumPy数组中的数据。所以他找到了解决办法，并在GPU上运行了他的算法。用Python。他没有我花几个月时间遇到的任何问题。你想在Linux上运行吗？没问题，就在Linux上运行它。你想让它与Python代码一致吗？没问题，它就是Python代码。你想优化目标平台吗？也没问题。Numba会根据你运行代码的平台优化代码，因为它不是预先编译的，它是在已经部署后按需编译。

难道这不令人惊叹吗？嗯，并不是对我来说。我花了几个月的时间用C++解决问题，而这些问题在Numba中根本不存在，一个来自不莱梅的兼职工人用几天时间做了同样的事情。如果他不是第一次体验Numba，可能只需要几个小时。那么，Numba是什么？它是什么魔法？

没有巫术。Python装饰器将每段代码转换为其抽象语法树，这样你就可以随心所欲地处理它。[Numba](https://numba.pydata.org)是一个Python库，希望能够使用任何后端和支持的任何平台编译抽象语法树。如果你想将你的Python代码编译为在CPU核心上以高度并行的方式运行 - 只需告诉Numba进行编译。如果你想在GPU上运行某些东西，再次，[只需请求](https://numba.readthedocs.io/en/stable/cuda/kernels.html)。

|

```
@cuda.jit
def matmul(A, B, C):
    """Perform square matrix multiplication of C = A * B."""
    i, j = cuda.grid(2)
    if i < C.shape[0] and j < C.shape[1]:
        tmp = 0.
        for k in range(A.shape[1]):
                tmp += A[i, k] * B[k, j]
        C[i, j] = tmp

```

|

Numba是Python编译器之一，使C++变得过时。然而，理论上讲，它并不比C++更好，因为它使用相同的后端。它使用CUDA进行GPU编程，使用LLVM进行CPU编程。在实践中，由于不需要为每个新架构进行预先重建，Numba解决方案更好地适应每个新硬件及其可用的优化。

当然，像SPIRAL那样有明显的性能优势会更好。但SPIRAL更像是一个研究项目，它可能会击败C++，但只是时间问题，并且只有在幸运的情况下。而Numba与Python结合，实时地压制了C++。因为如果你可以用Python编写并拥有C++的性能，为什么还要选择C++呢？

## C++杀手第三。ForwardCom

让我们再玩一个游戏。我会给你三段代码，你猜猜其中哪一段，或者可能更多，是用汇编写的。这里它们：

|

```
    invoke RegisterClassEx, addr wc     ; register our window class
    invoke CreateWindowEx,NULL,
        ADDR ClassName, ADDR AppName,\
        WS_OVERLAPPEDWINDOW,\
        CW_USEDEFAULT, CW_USEDEFAULT,\
        CW_USEDEFAULT, CW_USEDEFAULT,\
        NULL, NULL, hInst, NULL
        mov   hwnd,eax
    invoke ShowWindow, hwnd,CmdShow     ; display our window on desktop
    invoke UpdateWindow, hwnd           ; refresh the client area

    .while TRUE                         ; Enter message loop
        invoke GetMessage, ADDR msg,NULL,0,0
        .break .if (!eax)
        invoke TranslateMessage, ADDR msg
        invoke DispatchMessage, ADDR msg
   .endw

```

|

|

```
(module
  (func $add (param $lhs i32) (param $rhs i32) (result i32)
        get_local $lhs
        get_local $rhs
        i32.add)
  (export "add" (func $add)))

```

|

|

```
v0 = my_vector  // we want the horizontal sum of this
int64 r0 = get_len ( v0 )
int64 r0 = round_u2 ( r0 )
float v0 = set_len ( r0 , v0 )
while ( uint64 r0 > 4) {
        uint64 r0 >>= 1
        float v1 = shift_reduce ( r0 , v0 )
        float v0 = v1 + v0
}

```

|

如果你猜到这三个例子都是汇编，恭喜！你的直觉已经大大提升了！

第一个是[MASM32](http://www.masm32.com/)。它是一个带有“if”和“while”的宏汇编器，人们用它来编写原生Windows应用程序。没错，不是“曾经用来编写”，而是“现在仍在使用”。微软积极保护Windows与Win32 API的向后兼容性，因此所有以前编写的MASM32程序在现代PC上仍然运行良好。

讽刺的是，C语言的发明是为了使UNIX从PDP-7到PDP-11的转换更容易。它被设计为一种可移植的汇编语言，能够在70年代硬件架构的寒武纪爆炸中生存下来。但在21世纪，硬件架构演化得如此缓慢，以至于我20年前用MASM32编写的程序在今天仍然可以装配和运行良好，但我对去年用CMake 3.21构建的C++应用程序在今天用CMake 3.25能否构建没有信心。

第二个代码片段是[WebAssembly](https://github.com/mdn/webassembly-examples/blob/main/understanding-text-format/add.wat)。它甚至不是一个宏汇编器，没有“if”和“while”，更像是一个你的浏览器（或者其他浏览器）的人类可读的机器码。从概念上来说，任何浏览器都可以。

Web Assembly的代码完全不依赖于你的硬件架构。它服务的是一个抽象的、虚拟的、通用的机器，你可以随意称呼它。如果你能阅读这段文字，你的物理机器上已经有一个了。

但最有趣的代码片段是第三个。这就是ForwardCom - 一个由Agner Fog提出的汇编器。与Web Assembly类似，这个提议涵盖的不只是一个汇编器，而是设计为实现向前兼容性的通用指令集。因此得名ForwardCom。ForwardCom的全称是“[一个开放的向前兼容指令集架构](https://www.forwardcom.info)”。换句话说，这不仅仅是一个汇编的提议，而是一个和平条约的提议。

我们知道所有最常见的架构家族：x64、ARM和RISC-V都有不同的指令集。但没有人知道为什么要保持这种状态。除了可能最简单的之外，所有现代处理器运行的不是你输入的代码，而是它们将你的输入翻译成的微码。因此，不仅仅是M1具有与Intel的向后兼容性层，每个处理器本质上都有一个针对其所有早期版本的向后兼容性层。

那么，是什么阻止了架构设计者就类似的向前兼容性层达成一致呢？除了公司间直接竞争的冲突野心外，没有别的了。但如果处理器制造商最终同意采用一个通用的指令集，而不是为每个竞争对手都实现一个新的兼容性层，那么ForwardCom将会使汇编语言重新回到主流。这种向前兼容性层将解决每个汇编程序员最严重的困扰：“如果我为这个特定架构写了一生中仅有的代码，而这个特定架构在一年内就会变得过时怎么办？”

有了向前兼容性层，它将永远不会过时。这就是重点。

汇编语言编程也受到一种误解的限制，即认为汇编语言写起来很难，因此不实用。Fog的提议也解决了这个问题。如果人们认为汇编语言写起来很难，而C语言写起来不难，那么，我们就让汇编语言看起来像C语言一样。这不是问题。现代汇编语言没有理由看起来与上世纪50年代的版本完全一样。

你刚刚看到了三个汇编示例。没有一个看起来像“传统”的汇编语言，也不应该。

因此，ForwardCom是一种汇编语言，您可以在其中编写永不过时的最佳代码，而且您不需要学习“传统”的汇编语言。在所有实际考虑中，它是未来的C语言。不是C++。

## 那么，C++最终何时会消亡？

我们生活在后现代世界。再也没有什么会死去，只有人会。就像拉丁语从未真正消亡一样，就像COBOL、Algol 68和Ada一样，C++注定会永远处于生与死之间的半生状态。C++永远不会真正消亡，它只会被更新更强大的技术推到主流之外。

嗯，并不是“将被推动”，而是“正在被推动”。我以C++程序员的身份来到现在的工作岗位，今天我的工作从Python开始。我编写方程式，SymPy为我解决它们，然后将解决方案转换为C++。我然后将这段代码粘贴到C++库中，甚至不费心稍微格式化一下，因为clang-tidy会帮我做这件事。静态分析器将检查我是否没有搞乱命名空间，动态分析器将检查内存泄漏。CI/CD将负责跨平台编译。分析器将帮助我理解我的代码实际上是如何工作的，而反汇编器则会告诉我为什么。

如果我用“不是C++”来交换C++，我的80%工作内容将完全不变。对我而言，C++对大部分工作都是不相关的。这是否意味着对我来说，C++已经死了80%？
