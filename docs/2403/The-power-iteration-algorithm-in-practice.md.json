["```\nimport numpy as np\n\ndef power_iteration(A, num_simulations: int):\n    # Step 1: Initialize a random vector\n    b_k = np.random.rand(A.shape[1])\n\n    for _ in range(num_simulations):\n        # Step 2: Compute y = Ab_k\n        y = np.dot(A, b_k)\n\n        # Step 3: Normalize the vector\n        b_k1 = y / np.linalg.norm(y)\n\n        # Step 4: Check for convergence\n        if np.linalg.norm(b_k1 - b_k) < 1e-6:\n            break\n\n        b_k = b_k1\n\n    # compute the corresponding eigenvalue\n    lambda_k = np.dot(b_k1, np.dot(A, b_k1)) / np.dot(b_k1, b_k1)\n\n    return b_k1, lambda_k \n```", "```\nimport numpy as np \n```", "```\ndef power_iteration(A, num_iterations = 1000): \n```", "```\nb_k = np.random.rand(A.shape[1]) \n```", "```\nfor _ in range(num_simulations): \n```", "```\ny = np.dot(A, b_k) \n```", "```\nb_k1 = y / np.linalg.norm(y) \n```", "```\nif np.linalg.norm(b_k1 - b_k) < 1e-6:\n    break \n```", "```\nb_k = b_k1 \n```", "```\nlambda_k = np.dot(b_k1, np.dot(A, b_k1)) / np.dot(b_k1, b_k1) \n```", "```\nreturn b_k1, lambda_k \n```"]