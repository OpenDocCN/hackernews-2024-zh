["```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n```", "```\ncat > a.cc <<'eof'\n int main() {\n void *h = dlopen(\"./b.so\", RTLD_NOW);\n ((void (*)())dlsym(h, \"foo\"))();\n dlclose(h);\n}\neof\ncat > b.cc <<'eof'\n struct A { ~A(); } ga;\nA::~A() { printf(\"~A %p\\n\", this); }\nextern \"C\" void foo() {\n static A a;\n puts(\"foo\");\n}\neof\ng++ -fpic -shared b.cc -o b.so\ng++ a.cc -o a \n```", "```\n1\n2\n3\n\n```", "```\nfoo\n~A 0x7f70d66c4c79  // for the static-local variable\n~A 0x7f70d66c4c78  // for the global variable\n\n```", "```\n1\n2\n3\n4\n5\n\n```", "```\n% clang++ -c -Wexit-time-destructors g.cc\ng.cc:1:20: warning: declaration requires an exit-time destructor [-Wexit-time-destructors]\n 1 &#124; struct A { ~A(); } a;\n &#124;                    ^\n1 warning generated.\n\n```", "```\n1\n2\n3\n4\n5\n6\n\n```", "```\nstruct A { int v; ~A(); };\nA &g = *new A; \nA &foo() {\n static A &a = *new A;\n return a; \n}\n\n```", "```\n1\n2\n3\n4\n5\n6\n\n```", "```\n# %bb.2:                                 // initializer\n movl    $4, %edi\n callq   _Znwm@PLT\n movq    %rax, _ZZ3foovE1a(%rip)  // store pointer of the heap-allocated object to _ZZ3foovE1a\n...\n movq    _ZZ3foovE1a(%rip), %rax  // load a pointer from _ZZ3foovE1a\n\n```", "```\n1\n2\n3\n4\n5\n6\n7\n8\n\n```", "```\ntemplate <class T> class no_destroy {\n alignas(T) std::byte data[sizeof(T)];\npublic:\n template <class... Ts> no_destroy(Ts&&... ts) { new (data) T(std::forward<Ts>(ts)...); }\n T &get() { return *reinterpret_cast<T *>(data); }\n};\n no_destroy<widget> my_widget; \n```", "```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n```", "```\nstruct A { ~A(); };\n namespace {\n struct constant_init {\n union { A obj; };\n constexpr constant_init() : obj() { }\n ~constant_init() {  }\n };\n constinit constant_init global;\n}\n A* get() { return &global.obj; } \n```", "```\n1\n2\n3\n4\n5\n6\n\n```", "```\ntemplate <class T> union no_destroy {\n template <typename... Ts>\n explicit constexpr no_destroy(Ts&&... args) : obj(std::forward(args)...) {}\n constexpr ~no_destroy() {}\n T obj;\n};\n\n```", "```\n1\n2\n\n```", "```\nstruct C { C(); ~C() {} };\nvoid foo() { static C c; }\n\n```"]