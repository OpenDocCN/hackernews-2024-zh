["```\nassert(precondition)\ndefer assert(postcondition)\n```", "```\n{\n assert(!grid.free_set.opened);\n defer assert(grid.free_set.opened);\n }\n```", "```\nerrdefer comptime unreachable\n```", "```\n fn grow(\n self: *Self,\n allocator: Allocator,\n new_capacity: Size,\n) Allocator.Error!void {\n @setCold(true);\n var map: Self = .{};\n try map.allocate(allocator, new_capacity);\n errdefer comptime unreachable;\n std.mem.swap(Self, self, &map);\n map.deinit(allocator);\n}\n```", "```\nconst port = port: {\n errdefer |err| log.err(\"failed to read the port number: {}\", .{err});\n var buf: [fmt.count(\"{}\\n\", .{maxInt(u16)})]u8 = undefined;\n const len = try process.stdout.?.readAll(&buf);\n break :port try fmt.parseInt(u16, buf[0 .. len -| 1], 10);\n};\n```", "```\npub fn acquire(self: *ScanBufferPool) Error!*const ScanBuffer {\n if (self.scan_buffer_used == constants.lsm_scans_max) {\n return Error.ScansMaxExceeded;\n }\n defer self.scan_buffer_used += 1;\n return &self.scan_buffers[self.scan_buffer_used];\n}\n```"]