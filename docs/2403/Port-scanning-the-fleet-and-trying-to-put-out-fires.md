<!--yml

category: 未分类

date: 2024-05-29 12:36:36

-->

# 扫描整个机群的端口并尝试解决问题

> 来源：[https://rachelbythebay.com/w/2024/03/21/scan/](https://rachelbythebay.com/w/2024/03/21/scan/)

## 扫描整个机群的端口并尝试解决问题

有一个团队正在运行一个相当复杂的数据存储、领导者选举和“发现”服务。他们有大约3200台机器，并且在它们之上运行大约300个不同的集群/单元/合奏/……(*)。这项服务运行类似于etcd，但并非完全相同。

它的工作方式是一堆“参与者”机器会启动一个选举过程，然后他们会决定谁将在一段时间内担任领导。那个领导者负责处理所有的写入流量，并且在参与者之间执行所有通常的类似raft/paxos的神秘协调工作，包括更新其他参与者，并处理暂时离开并稍后回来的主机等等。对于这种类型的服务来说，这都是必备条件。

这组集群最初看起来相对简单，但多年来已经变成了一个庞然大物。可能没有人预料到它们会有数百个集群和数千台机器，但现在确实如此，他们难以跟踪一切。不断出现故障，由于它们在堆栈中的位置较低，一旦出现故障，会影响到很多其他东西。

我想知道实际情况如何，所以从我的开发机器上开始了一些非常愚蠢的尝试。它将获取他们服务器的列表，并爬取它们，查询服务运行的TCP端口。每台机器只有大约10个端口，所以虽然听起来很讨厌，但在原型设计阶段仍然是可能的。

在这些端口上，可以发送简单的基于文本的命令，并返回关于该特定实例正在运行的配置信息。可以从中推断出集群的身份。考虑到所有这些以及对整个机群的扫描，可以看到支持任何给定集群的主机+端口组合，从而了解它们的运行情况。

这种可怕的手动爬取的早期结果显示了希望。到处都是配置错误的迹象 - 集群本应有5台主机，但实际上只有3台，另外两台不知所踪，非标准主机数量的集群，位置错误的集群等等。

为了摆脱“printf | nc the world in cron”的问题，我们最终编写了这个愚蠢的小代理程序，在所有~3200台主机上运行。它执行相同的爬取操作，但是通过回环进行，因此速度要快得多，因为消除了通过生产网络的长距离传输。它还分担了从我的单一机器轮询~32000个端口的负载，并且本质上是并行的。

现在只需查询一个代理并获取运行在该主机上的所有内容就行了。它每分钟刷新一次，因此比我那个可能每隔几个小时才运行一次（因为速度太慢）的可怕脚本要及时得多。这使事情变得更好，因此我们需要一个聚合器。

每次运行时，我们让这些代理创建一个小的“信标”。我们的“聚合器”进程会启动，并订阅信标创建的位置。然后它会安排检查相关的主机，在那些主机上与代理交流，并要求一份其结果的副本。

现在我们每台约3200台主机上都有一个代理，每个代理轮询10个本地端口，再加上一个与约3200个代理交流并刷新它们数据的聚合器。

最后，所有数据都在一个地方以非常快的单一查询中可用。接下来的步骤是编写一堆简单的“仪表板”网页，让任何人可以查看整个设备组，或者按照特定参数（这些服务器的）给定集群，给定区域，数据中心等进行筛选。

只需点击几下即可看到所有这些，显然我们确实需要更多的东西来实际找出问题所在。点击查看时，我们知道事物应该是什么样的，但关于这种事情应该有一些规则：一个集群中有这么多主机，每个故障域不超过N个主机，等等。

...

失败域是一件有趣的事情。假设你有五台主机形成一个法定人数，应该具有高可用性。你可能希望它们分散开来，对吧？如果它们正在为全球客户提供服务，也许你会把它们放在不同的地方，并且从不将两者放在同一位置？如果有什么违反了这个规则，你如何知道呢？

这里有一个错误放置的例子。我们有一个集群，本应该遍布整个由多个数据中心建筑组成的区域，每个建筑物中都有多个（计算）集群，有不同的机架等等。但是，因为它在该区域生命周期早期启动时只存在少数主机，所以它们全都放在了同两三个机架中。

更糟糕的是，这些机架是物理上相邻的。换句话说，如果服务器有手臂和手的话，它们可以在数据中心套件的热通道和冷通道之间高兴地击掌。它们离得如此之近。某一位置发生严重问题，就会彻底删除所有数据。

我们不得不编写一个模式，让我们能够为给定的集群设定限制——它应该在多少个区域内，每个主机、机架（计算）集群、建筑物、区域等的最大成员数。然后，我们编写了一个工具来让我们创建规则，然后开始使用它来生成规则集。接下来，我们设计了一些工具，可以获取现有状态（从代理/聚合器组合）并将其与规则集进行比较。任何不符合规定的情况都会立即显示出来。

…

然后有管理实际约3200台主机的问题。当足迹如此之大时，总会发生一些事情。某个地点被开启，新主机出现。另一个位置在机器老化后被拆除，这些主机消失。我们不断遇到退役计划的故障，然后远程的某人运行带有大量--force类型命令的脚本，它会拔掉这些机器并擦除它们。它不关心它们实际在做什么，他们通过这种方式设法破坏了一些东西。这种情况一直在发生。

这时我必须采取一些不可扩展的措施。我告诉退役人员，他们应将任何由该团队拥有的主机视为禁区，因为我们控制不了情况。这意味着在这些主机仍由团队拥有时，绝不要再运行退役脚本。

我进一步补充道，虽然我们正在努力控制局面，但如果由于我的这个命令而导致的任何一次退役受阻，他们可以随时联系我，无论白天黑夜，我都会帮助解决……以某种方式。我觉得这是我展示自己有"利害关系"的方式，因为提出这样一个愚蠢且不合理的要求。

我经常说，解决问题的方法是确保有人处于糟糕状态的路径上，这样当出现问题时，他们就会感受到它。这是我正在做的事情。

我们停止了由退役引起的故障。相反，我们开始发生这种“火灾演习”类型的事件，团队中的一两个人（还有我）必须放下手头的事情，花几个小时手动更换各种集群中的机器，以便释放它们。

显然，这是无法容忍的，因此我们着手进行另一个项目。这是更像是一个“车队管理器”的项目，一个简单的服务会跟踪团队拥有的机器，并为每台机器存储我称之为“意图”的一系列位。

每个主机只有三位：排空、释放、冻结。并非所有组合都是有效的。

如果主机上没有设置任何位，那意味着它是用于生产的。如果上面有服务器，那很好。如果有人需要更换，那可能可用（假设它符合其他要求，比如与其他参与者足够远）。

如果“排空”位被设置了，那意味着它不应该提供服务。应该通过用可用主机替换它来将其上的任何服务器取下来，这个可用主机本身不被标记为“排空”（或更糟）。

“释放”位意味着如果主机上没有任何运行的东西了，那么它应该被释放回机器供应系统。在这样做的过程中，主机的名称会改变，因此其所有权（和责任）离开了团队，它不再是我们的问题。进行解体的人会接手处理。

“冻结”是一个特殊位，旨在作为防止自动化系统失控的安全机制。如果主机上设置了该位，任何工具都不会对其进行任何更改。这是那种你永远不应该需要使用的东西，但如果不写下并有一天需要它，你会后悔的事情。

“排空”+“释放”意味着“继续尝试踢掉这台主机上的实例，并且不添加任何新的实例”，然后“一旦它变空，就归还它”。

其他位的组合（比如“释放”而不是“排空”）是无效的，并被自动化系统拒绝。

我应该指出，这是意味着每个主机在每次通行时，如果某个主机有一个设置的位，但却与那个意图或那些意图不匹配，应该尝试排出它，或者交出它，或者其他什么。即使失败了，也应该在下一次通行时再试一次，而且失败应该是不寻常的，因此应该向人类报告。

...

然后还有一个预先存在的系统，它接受配置文件并用它来在机器上安装实例。这个系统工作得很好，但它只完成了流程的一部分。它没有闭环，因此服务生命周期的许多部分最终由它未管理。

回顾这些，现在可以看到我们可以建立一堆可用数据的“集合”。

配置：“我们告诉它运行的地方”

代理 + 聚合器：“实际上正在成功运行的地方”

检查器：“这些东西应该遵守什么规则”

车队经理：“哪些机器应该提供服务（或不提供服务），哪些机器我们应该保留（或交还）”。

对这些集合执行不同的操作会产生不同的结果。

[配置] x [代理/聚合器] = 做他们应该做的事情的主机，因某些原因应该提供服务但并没有做到的主机，和不应该运行但却正在运行的主机。它会找到有问题的机器，在配置系统中的故障，黑暗角落中的奇怪手动安装的hack工作，以及更糟的情况。

[代理/聚合器] x [检查器] = 实际上正确分散的集群和实际上错误分散的集群（可能是因为糟糕的配置，但可能是任何原因）。

[代理/聚合器] x [车队经理] = 提供服务而可以的主机，需要排空直到空的主机，现在可以交还的主机。

[配置] x [检查器] = 由于配置告诉它们放错位置，或者其他事情正在发生，这些配置不合格的群集。如果第一个检查通过，你实际上不需要执行这个，因为你知道每件事都正常运行着。

[配置] x [舰队管理器] = 如果你最终完全信任配置是由机器实施的（因为其他一些操作是清晰的），那么你可以通过这种方式找到不匹配的地方。你不一定需要依赖经验数据，事实上，可以停止扫描它。

就这一点而言，从理论上讲，整个端口扫描代理/聚合组合实际上不应该存在，但在实践中，需要进行独立验证。

我应该指出，管理层并不看好我与这个团队的合作，而且我对发生的事情的报告最终比任何其他事情都让我陷入了麻烦。考虑到我是应直接请求帮助可靠性而与他们合作的，这有点令人惊讶，但打击信使并不是什么新鲜事。这次合作让我认识到很多所谓的技术问题实际上根源于人为问题，而这些问题通常来自管理层。

这次整个过程中发生的事情还有更多，但这篇文章已经够长了。

...

(*) 我在这里使用“群集”主要指的是以5、7或9台主机为一组参与共识并保持世界状态同步。请注意，还有“计算群集”的概念，这只是一个更大的群体，可能有成千上万台机器（都有不同的所有者），在这篇文章中有几个地方也提到了，并在需要时明确指出。
