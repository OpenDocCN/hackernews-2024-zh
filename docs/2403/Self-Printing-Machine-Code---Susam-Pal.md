<!--yml

类别：未分类

日期：2024-05-27 15:01:24

-->

# 自印机器码 - Susam Pal

> 来源：[https://susam.net/self-printing-machine-code.html](https://susam.net/self-printing-machine-code.html)

<主要>

# 自印机器码

由**Susam Pal**于2005年10月27日撰写

在DOS环境中执行时，以下由纯x86机器码组成的12字节程序在标准输出中写入自身：

```
fc b1 0c ac 92 b4 02 cd 21 e2 f8 c3
```

我们可以将这些字节写入扩展名为.COM的文件并在DOS中执行。它在MS-DOS 6.22、Windows 98以及DOSBox中成功运行，并将自身的副本写入标准输出。

## 目录

## 演示

在Unix或Linux系统上，以下命令借助DOSBox演示了如何运行此程序：

```
echo fc b1 0c ac 92 b4 02 cd 21 e2 f8 c3 | xxd -r -p > foo.com
dosbox -c 'MOUNT C .' -c 'C:\FOO > C:\OUT.COM' -c 'EXIT'
diff foo.com OUT.COM

```

`diff`命令不应产生输出，从而确认程序的输出与程序本身相同。在实际的MS-DOS 6.22系统或Windows 98系统上，我们可以通过以下方式演示此程序：

```
C:\>`DEBUG`
-`E 100 fc b1 0c ac 92 b4 02 cd 21 e2 f8 c3`
-`N` FOO.COM
-`R CX`
CX 0000
:`C`
-`W`
Writing 0000C bytes
-`Q`

C:\>`FOO > OUT.COM`

C:\>`FC FOO.COM OUT.COM`
Comparing files FOO.COM and OUT.COM
FC: no differences encountered

```

在上面显示的`DEBUG`会话中，我们使用调试器命令`E`来输入代码段偏移量为0x100的机器码。然后我们使用`N`命令来命名我们想要将这段机器码写入的文件。命令`R CX`用于指定我们要向此文件写入0xC（十进制12）字节。命令`W`写入从偏移量0x100输入的12个字节。命令`Q`退出调试器。然后我们运行新的`FOO.COM`程序，同时将其输出重定向到`OUT.COM`。最后，我们使用`FC`命令比较这两个文件并确认它们完全相同。

现在让我们分解这个程序，看看它的作用。下面的输出是使用Netwide Disassembler（NDISASM）生成的，这是随Netwide Assembler（NASM）提供的工具：

```
$ `ndisasm -o 0x100 foo.com`
00000100  FC                cld
00000101  B10C              mov cl,0xc
00000103  AC                lodsb
00000104  92                xchg ax,dx
00000105  B402              mov ah,0x2
00000107  CD21              int 0x21
00000109  E2F8              loop 0x103
0000010B  C3                ret

```

当DOS执行一个以.COM文件结尾的程序时，它将文件中的机器码加载到DOS选择的代码段的0x100偏移处。这就是为什么我们要求反汇编器假定使用`-o`命令行选项加载地址为0x100。第一条指令清除方向标志。稍后会解释这条指令的目的。接下来的指令将寄存器CL设置为0xc（十进制12）。当.COM程序启动时，寄存器CH默认已设置为0。因此，将寄存器CL设置为0有效地将整个寄存器CX设置为0xc。寄存器CX用作后面的`loop 0x103`指令的循环计数器。每当这个循环指令执行时，它会递减CX，并且如果CX不为0，则跳转到偏移量0x103。这样会进行12次循环。

在循环的每次迭代中，从偏移量0x103到偏移量0x109的指令被执行。`lodsb`指令将地址DS:SI中的一个字节加载到AL寄存器中。当DOS开始执行该程序时，默认情况下DS和SI设置为CS和0x100，因此起始时DS:SI指向程序的第一个字节。`xchg`指令交换AX和DX寄存器的值。因此，刚刚加载到AL中的字节最终存储在DL寄存器中。然后我们将AH设置为2，并生成软中断0x21（十进制33），将DL中的字节写入标准输出。这就是每次迭代读取程序的一个字节并将其写入标准输出的过程。

`lodsb`指令根据方向标志（DF）的状态递增或递减SI寄存器的值。当DF被清除时，SI递增；如果DF被设置，则SI递减。我们在开头使用`cld`指令来清除DF，因此在循环的每次迭代中，SI向前移动以指向程序的下一个字节。这就是循环的12次迭代将程序的12个字节写入标准输出的过程。在许多DOS环境中，当一个.COM程序启动时，DF标志已经被清除，因此在这些环境中可以省略CLD指令。但是，在某些环境中，当我们的程序启动时，DF可能不处于清除状态，因此在依赖于DF之前清除它是一个最佳实践。

最后，当循环终止时，我们执行`RET`指令来结束程序。

## Quine Conundrums

当阅读之前提出的自打印程序的描述时，人们可能会想知道它是否是一个quine。虽然没有关于*quine*的标准定义，但通常认为quine是一个计算机程序，它不接受任何输入并生成其自身源代码的精确副本作为输出。由于quine不能接受任何输入，因此涉及读取自身源代码或评估自身的技巧被排除在外。

例如，此shell脚本是一个有效的quine：

```
s='s=\47%s\47;printf "$s" "$s"\n';printf "$s" "$s"
```

然而，以下shell脚本不被认为是一个正确的quine：

```
cat $0
```

上述shell脚本读取其自身的源代码被认为是作弊行为。像这样的不恰当quine通常被称为*cheating quines*。

我们的12字节x86程序是quine吗？事实证明我们面临一个难题。对于我们的程序，不存在源代码的概念。如果我们用汇编语言写出了该程序的源代码，那么情况就不同了。在这种情况下，我们首先需要选择一个汇编器，并且一个正确的quine需要生成所选汇编器的汇编语言源代码的精确副本（而不是机器码字节）。但是我们现在并没有这样做。我们希望机器码生成其自身的精确副本。这里没有涉及到源代码。我们只有机器码。因此我们可以说机器码quine的整个概念是无意义的。没有机器码quine可以存在，因为没有源代码可以作为输出产生。

然而，我们也可以认为机器码是 CPU 的输入，CPU 获取、解码并将其转换为 CPU 中的状态变化序列。如果我们定义一个机器码 quine 为一个能够写出自己字节的机器码程序，那么我们可以说我们在这里有一个机器码 quine。

现在让我们来思考一下我们的 12 字节程序是否确实是一个机器码 quine。现在我们面临一个新的难题。它是一个正确的 quine 吗？这个程序从内存中读取自己的字节并将它们写出。这是否使它成为一个作弊的 quine？一个纯机器码编写的正确 quine 究竟会是什么样子？如果我们看一下上面的 shell 脚本 quine，我们会看到它包含嵌入在字符串中的脚本代码的可执行部分。然后我们巧妙地格式化字符串以生成一个看起来完全像整个 shell 脚本的新字符串。这是许多 quine 遵循的常见模式。这个 quine 并不读取自己的代码，而是读取由代码定义的一些数据，并将该数据格式化为看起来像自己代码的新字符串。然而，在像这样的纯机器码中，数据和代码之间的界线变得模糊。即使我们尝试将想要读取的字节保留在内存中的另一个位置并将其视为数据，它们看起来也会与机器指令完全相同，因此人们可能会想知道是否有必要制作一个不读取自己字节的机器 quine。尽管如此，下一节展示了如何实现这一点。

## 正确的 Quines

如果想到一个机器码 quine 程序从内存中读取自己的字节会让你感到不适，这里是前一个程序的一个改编，将待执行的机器指令与程序读取的数据字节分开。

```
fc b3 02 b1 14 be 14 01 ac 92 b4 02 cd 21 e2 f8 4b 75 f0 c3
fc b3 02 b1 14 be 14 01 ac 92 b4 02 cd 21 e2 f8 4b 75 f0 c3

```

这是我们如何演示这个 40 字节程序：

```
echo fc b3 02 b1 14 be 14 01 ac 92 b4 02 cd 21 e2 f8 4b 75 f0 c3 | xxd -r -p > foo.com
echo fc b3 02 b1 14 be 14 01 ac 92 b4 02 cd 21 e2 f8 4b 75 f0 c3 | xxd -r -p >> foo.com
dosbox -c 'MOUNT C .' -c 'C:\FOO > C:\OUT.COM' -c 'EXIT'
diff foo.com OUT.COM

```

这是反汇编：

```
$ `ndisasm -o 0x100 foo.com`
00000100  FC                cld
00000101  B302              mov bl,0x2
00000103  B114              mov cl,0x14
00000105  BE1401            mov si,0x114
00000108  AC                lodsb
00000109  92                xchg ax,dx
0000010A  B402              mov ah,0x2
0000010C  CD21              int 0x21
0000010E  E2F8              loop 0x108
00000110  4B                dec bx
00000111  75F0              jnz 0x103
00000113  C3                ret
00000114  FC                cld
00000115  B302              mov bl,0x2
00000117  B114              mov cl,0x14
00000119  BE1401            mov si,0x114
0000011C  AC                lodsb
0000011D  92                xchg ax,dx
0000011E  B402              mov ah,0x2
00000120  CD21              int 0x21
00000122  E2F8              loop 0x11c
00000124  4B                dec bx
00000125  75F0              jnz 0x117
00000127  C3                ret

```

前 20 字节是程序的可执行部分。接下来的 20 字节是程序读取的数据。可执行字节与数据字节相同。程序的可执行部分有一个外部循环，迭代两次。在每次迭代中，它读取数据字节并将它们写入标准输出。因此，在外部循环的两次迭代中，它将数据字节写入两次。通过这种方式，输出与程序本身完全相同。

基于这种方法，这里是另一个更简单的 32 字节 quine：

```
b8 23 09 fe c0 a2 20 01 ba 10 01 cd 21 cd 21 c3
b8 23 09 fe c0 a2 20 01 ba 10 01 cd 21 cd 21 c3

```

这些是演示此 quine 的命令：

```
echo b8 23 09 fe c0 a2 20 01 ba 10 01 cd 21 cd 21 c3 | xxd -r -p > foo.com
echo b8 23 09 fe c0 a2 20 01 ba 10 01 cd 21 cd 21 c3 | xxd -r -p >> foo.com
dosbox -c 'MOUNT C .' -c 'C:\FOO > C:\OUT.COM' -c 'EXIT'
diff foo.com OUT.COM

```

这是反汇编：

```
$ `ndisasm -o 0x100 foo.com`
00000100  B82309            mov ax,0x923
00000103  FEC0              inc al
00000105  A22001            mov [0x120],al
00000108  BA1001            mov dx,0x110
0000010B  CD21              int 0x21
0000010D  CD21              int 0x21
0000010F  C3                ret
00000110  B82309            mov ax,0x923
00000113  FEC0              inc al
00000115  A22001            mov [0x120],al
00000118  BA1001            mov dx,0x110
0000011B  CD21              int 0x21
0000011D  CD21              int 0x21
0000011F  C3                ret

```

这个例子也有两部分。前半部分是可执行字节，后半部分是数据字节。这两部分内容完全相同。这个例子在第一条指令中将AH设置为9，然后稍后使用`int 0x21`来调用DOS服务，该服务打印从DS:DX指定地址开始的以美元符号终止的字符串。当一个.COM程序启动时，DS已经指向当前代码段，因此我们不必显式设置它。美元符号的ASCII码是0x24（十进制36）。我们需要注意确保在数据字节中没有这个值，否则这个DOS函数会在遇到该值时提前停止打印我们的数据字节。这就是为什么我们在第一条指令中将AL设置为0x23，然后在第二条指令中递增到0x24，然后将这个值复制到第三条指令中数据字节的末尾。最后，我们执行两次`int 0x21`以两次将数据字节写入标准输出，以便输出与程序本身匹配。

尽管这两个程序都注意不读取CPU正在执行的相同内存区域，但它们读取的数据字节看起来确实与可执行字节完全相同。这就是我前面提到的在这样的练习中代码与数据之间界限模糊的意思。这也是为什么在编写机器码quine时，我认为将可执行字节与数据字节分开没有意义的原因。

## 关于DOS服务的说明

上面介绍的自打印程序使用了`int 0x21`，该函数提供支持各种输入/输出功能的DOS服务。在前两个程序中，我们设置AH为2，然后调用这个软件中断以写一个字符到标准输出。在下一个程序中，我们设置AH为9，选择写一个以美元符号终止的字符串到标准输出的功能。

结尾处的`ret`指令也依赖于DOS服务。当一个.COM程序启动时，寄存器SP包含0xfffe。堆栈内存位置在偏移0xfffe和0xffff处包含0x00和0x00。此外，偏移0x0000处的内存地址包含了`int 0x20`指令，这是一个DOS服务，用于终止程序。因此，执行`ret`指令将0xfffe处的堆栈弹出0x0000，并将其加载到IP中。这导致偏移0x0000处的`int 0x20`指令被执行。该指令终止程序并返回到DOS。

依赖DOS服务为我们提供了一个舒适的工作环境。特别是，DOS实现了*标准输出*的概念，使我们能够将标准输出重定向到文件。这使得我们可以方便地使用`FC`命令比较原始程序文件和输出文件，并确认它们是相同的。

但是有人可能想知道，我们是否可以完全避免依赖DOS服务并仍然编写一个程序，将其自己的字节打印到屏幕上。我们确实可以。我们可以直接写入地址为0xb800:0x0000的视频存储器，并在屏幕上显示程序的字节。我们还可以完全放弃DOS，让BIOS从引导扇区加载我们的程序并执行它。接下来的两个部分将讨论这些事情。

## 直接写入视频存储器

这是一个18字节的自打印程序示例，直接写入地址为0xb800:0x0000的视频存储器。

```
fc b4 b8 8e c0 31 ff b1 12 b4 0a ac ab e2 fc f4 eb fd
```

这里是创建和运行该程序的命令：

```
echo fc b4 b8 8e c0 31 ff b1 12 b4 0a ac ab e2 fc f4 eb fd | xxd -r -p > foo.com
dosbox foo.com

```

在默认的代码页激活状态下，即代码页437激活状态下，程序应该显示一个输出，看起来大致如下并停止：

```
ⁿ┤╕Ä└1 ▒↕┤◙¼½Γⁿ⌠δ²
```

当然，这种类型的输出看起来像胡言乱语，但有一种快速而不精确的方法可以确认该输出确实代表我们程序的字节。我们可以使用DOS的`TYPE`命令打印程序，并检查其输出中出现的符号是否与上述输出一致。以下是一个示例：

```
C:\>`TYPE FOO.COM`
ⁿ┤╕Ä└1 ▒↕┤
          ¼½Γⁿ⌠δ²
C:\>

```

此输出看起来与先前的输出非常相似，只是在此输出中，字节值0x0a作为换行符显示，而在先前的输出中，该字节值作为一个圆圈在一个方框中表示。如果输出中存在任何控制字符（如退格或回车），导致显示输出中的字符被删除，则此方法将无法工作。

验证程序输出是否代表程序的字节的正确方法是在代码页437的字符图表中找到输出中的每个符号，并确认每个符号的字节值与程序中的每个字节值匹配。以下是一个近似于代码页437中符号的Unicode符号的图表：[cp437.html](code/cp437/cp437.html)。

这里是上述程序的反汇编：

```
$ `ndisasm -o 0x100 foo.com`
00000100  FC                cld
00000101  B4B8              mov ah,0xb8
00000103  8EC0              mov es,ax
00000105  31FF              xor di,di
00000107  B112              mov cl,0x12
00000109  B40A              mov ah,0xa
0000010B  AC                lodsb
0000010C  AB                stosw
0000010D  E2FC              loop 0x10b
0000010F  F4                hlt
00000110  EBFD              jmp short 0x10f

```

该程序将ES设置为0xb800，DI设置为0。因此ES:DI指向地址0xb800:0x0000处的视频存储器。DS:SI默认指向该程序的第一条指令。此程序循环的每次迭代从程序中加载一个字节，并将其与颜色属性一起写入视频存储器。`lodsb`指令从DS:SI指定的内存地址加载程序的一个字节到AL，并将SI增加1。AH已设置为0xa。这用于指定要显示在屏幕上的文本的颜色属性。`stosw`指令将AX中的一个字存储到由ES:DI指定的内存地址，并将DI增加2。通过这种方式，AL中的字节及其在AH中的颜色属性被复制到视频存储器中。

再次强调，如果对程序读取自身可执行字节不满意，我们可以保持读取的字节与 CPU 执行的字节分开。以下是一个实现此功能的 54 字节程序：

```
fc b3 02 b4 b8 8e c0 31 ff be 1b 01 b9 1b 00 b4
0a ac ab e2 fc 4b 75 f1 f4 eb fd fc b3 02 b4 b8
8e c0 31 ff be 1b 01 b9 1b 00 b4 0a ac ab e2 fc
4b 75 f1 f4 eb fd

```

以下是我们创建和运行这个程序的方法：

```
echo fc b3 02 b4 b8 8e c0 31 ff be 1b 01 b9 1b 00 b4 | xxd -r -p > foo.com
echo 0a ac ab e2 fc 4b 75 f1 f4 eb fd fc b3 02 b4 b8 | xxd -r -p >> foo.com
echo 8e c0 31 ff be 1b 01 b9 1b 00 b4 0a ac ab e2 fc | xxd -r -p >> foo.com
echo 4b 75 f1 f4 eb fd | xxd -r -p >> foo.com
dosbox foo.com

```

使用活动的代码页 437，输出应该大致如下：

```
ⁿ│☻┤╕Ä└1 ╛←☺╣← ┤◙¼½ΓⁿKu±⌠δ²ⁿ│☻┤╕Ä└1 ╛←☺╣← ┤◙¼½ΓⁿKu±⌠δ²
```

我们可以清楚地在这个输出中看到，输出的前 27 个字节与后续的 27 个字节是相同的。与之前讨论过的适当的自指程序类似，这个程序也有两个相互相同的部分。第一半中的可执行代码从第二半中读取数据字节并打印两次数据字节，以使输出字节是程序中所有 54 个字节的精确副本。以下是反汇编：

```
$ `ndisasm -o 0x100 foo.com`
00000100  FC                cld
00000101  B302              mov bl,0x2
00000103  B4B8              mov ah,0xb8
00000105  8EC0              mov es,ax
00000107  31FF              xor di,di
00000109  BE1B01            mov si,0x11b
0000010C  B91B00            mov cx,0x1b
0000010F  B40A              mov ah,0xa
00000111  AC                lodsb
00000112  AB                stosw
00000113  E2FC              loop 0x111
00000115  4B                dec bx
00000116  75F1              jnz 0x109
00000118  F4                hlt
00000119  EBFD              jmp short 0x118
0000011B  FC                cld
0000011C  B302              mov bl,0x2
0000011E  B4B8              mov ah,0xb8
00000120  8EC0              mov es,ax
00000122  31FF              xor di,di
00000124  BE1B01            mov si,0x11b
00000127  B91B00            mov cx,0x1b
0000012A  B40A              mov ah,0xa
0000012C  AC                lodsb
0000012D  AB                stosw
0000012E  E2FC              loop 0x12c
00000130  4B                dec bx
00000131  75F1              jnz 0x124
00000133  F4                hlt
00000134  EBFD              jmp short 0x133

```

这个反汇编相当长，但我们可以清楚地看到从偏移量 0x100 到偏移量 0x11a 的字节与从偏移量 0x11b 到 0x135 的字节是相同的。这些字节也是程序输出中看到的字节。

## 引导程序

下面的 32 字节程序在从引导扇区执行时将自身写入视频内存：

```
ea 05 7c 00 00 fc b8 00 b8 8e c0 8c c8 8e d8 31
ff be 00 7c b9 20 00 b4 0a ac ab e2 fc f4 eb fd
```

我们可以创建一个包含这些字节的引导映像，将其写入驱动器的引导扇区，并使用它引导 IBM PC 兼容计算机。引导时，这个程序将其自己的字节打印到屏幕上。

在 Unix 或 Linux 系统上，可以使用以下命令创建具有上述程序的引导映像：

```
echo ea 05 7c 00 00 fc b8 00 b8 8e c0 8c c8 8e d8 31 | xxd -r -p > boot.img
echo ff be 00 7c b9 20 00 b4 0a ac ab e2 fc f4 eb fd | xxd -r -p >> boot.img
echo 55 aa | xxd -r -p | dd seek=510 bs=1 of=boot.img

```

现在我们可以使用 DOSBox 测试这个引导映像，命令如下：

```
dosbox -c cls -c 'boot boot.img'
```

我们还可以使用 QEMU x86 系统仿真器测试这个映像，方法如下：

```
qemu-system-i386 -fda boot.img
```

我们还可以将这个映像写入实际物理存储设备的引导扇区，比如 USB 闪存驱动器，然后用它来引导计算机。以下是一个将引导映像写入由设备路径 `/dev/sdx` 表示的驱动器的示例命令。

```
cp a.img /dev/sdx
```

*注意：您需要绝对确定被写入的设备路径。这里的设备路径 `/dev/sdx` 只是一个示例。如果将引导映像写入错误的设备，可能会导致该设备上的数据访问丢失。*

在使用仿真器或实际计算机测试这个引导映像时，输出应该大致如下：

```
Ω♣|  ⁿ╕ ╕Ä└î╚Ä╪1 ╛ |╣  ┤◙¼½Γⁿ⌠δ²
```

看起来像乱码，但是上述输出中的每个符号都对应程序前面提到的一个字节。例如，第一个符号（欧米茄）代表字节值 0xea，第二个符号（梅花）代表字节值 0x05，依此类推。可以使用 [cp437.html](code/cp437/cp437.html) 中的图表确认，输出中的每个符号确实代表程序的每个字节。

这是程序的反汇编：

```
$ `ndisasm -o 0x7c00 boot.img`
00007C00  EA057C0000        jmp 0x0:0x7c05
00007C05  FC                cld
00007C06  B800B8            mov ax,0xb800
00007C09  8EC0              mov es,ax
00007C0B  8CC8              mov ax,cs
00007C0D  8ED8              mov ds,ax
00007C0F  31FF              xor di,di
00007C11  BE007C            mov si,0x7c00
00007C14  B92000            mov cx,0x20
00007C17  B40A              mov ah,0xa
00007C19  AC                lodsb
00007C1A  AB                stosw
00007C1B  E2FC              loop 0x7c19
00007C1D  F4                hlt
00007C1E  EBFD              jmp short 0x7c1d
00007C20  0000              add [bx+si],al
00007C22  0000              add [bx+si],al
...

```

结尾的省略号代表剩余的包含零字节和最后的引导扇区魔数字节 0x55 和 0xaa。出于简洁起见，在这里被省略了。

当计算机启动时，BIOS将引导设备的引导扇区代码读入物理地址`0x7c00`处的内存，并跳转到该地址。大多数BIOS实现会跳转到`0x0000:0x7c00`，但也有一些实现会跳转到`0x07c0:0x0000`。这两种跳转都是跳转到相同的物理地址`0x7c00`，但是这种差异对我们造成了问题，因为我们程序中的偏移量取决于BIOS执行的跳转方式。为了确保我们的程序能够在两种类型的BIOS实现上运行，我们使用了一个常用的技巧，即让程序的第一条指令执行跳转到地址`0x0000:0x7c05`，从而达到执行第二条指令的目的。这样设置寄存器CS为0，IP为0x7c05，我们就不再需要担心BIOS实现之间的差异了。现在我们可以假设一个跳转到`0x0000:0x7c00`的BIOS实现将加载我们的程序。

程序的其余部分与上一节中的程序类似。但是，存在一些小但重要的区别。尽管DOS环境在.COM程序启动时保证AH和CH初始化为0，但是在加载和执行引导程序时，BIOS并不提供这样的保证。这就是为什么我们在`mov`指令中使用AX和CX寄存器（而不仅仅是AH和CL）来初始化它们的原因。同样，在DOS将SI初始化为0x100时，对于引导程序，我们自己设置寄存器SI。

如果你对将上述程序称为quine感到不适，请注意它是从内存中读取自己的字节，我们可以让程序从内存的另一个位置读取它需要打印的字节。我们不执行这些字节。我们只读取它们并将它们复制到视频内存中。以下76字节的程序可以实现这一点：

```
ea 05 7c 00 00 fc bb 02 00 b8 00 b8 8e c0 8c c8
8e d8 31 ff be 26 7c b9 26 00 b4 0a ac ab e2 fc
4b 75 f1 f4 eb fd ea 05 7c 00 00 fc bb 02 00 b8
00 b8 8e c0 8c c8 8e d8 31 ff be 26 7c b9 26 00
b4 0a ac ab e2 fc 4b 75 f1 f4 eb fd

```

这是我们如何创建一个引导镜像的方法：

```
echo ea 05 7c 00 00 fc bb 02 00 b8 00 b8 8e c0 8c c8 | xxd -r -p > boot.img
echo 8e d8 31 ff be 26 7c b9 26 00 b4 0a ac ab e2 fc | xxd -r -p >> boot.img
echo 4b 75 f1 f4 eb fd ea 05 7c 00 00 fc bb 02 00 b8 | xxd -r -p >> boot.img
echo 00 b8 8e c0 8c c8 8e d8 31 ff be 26 7c b9 26 00 | xxd -r -p >> boot.img
echo b4 0a ac ab e2 fc 4b 75 f1 f4 eb fd | xxd -r -p >> boot.img
echo 55 aa | xxd -r -p | dd seek=510 bs=1 of=boot.img

```

这里是测试该引导镜像的命令：

```
dosbox -c cls -c 'boot boot.img'
qemu-system-i386 -fda boot.img
```

输出应该如下所示：

```
Ω♣|  ⁿ╗☻ ╕ ╕Ä└î╚Ä╪1 ╛&|╣& ┤◙¼½ΓⁿKu±⌠δ²Ω♣|  ⁿ╗☻ ╕ ╕Ä└î╚Ä╪1 ╛&|╣& ┤◙¼½ΓⁿKu±⌠δ²
```

这是该程序的反汇编：

```
$ `ndisasm -o 0x7c00 boot.img`
00007C00  EA057C0000        jmp 0x0:0x7c05
00007C05  FC                cld
00007C06  BB0200            mov bx,0x2
00007C09  B800B8            mov ax,0xb800
00007C0C  8EC0              mov es,ax
00007C0E  8CC8              mov ax,cs
00007C10  8ED8              mov ds,ax
00007C12  31FF              xor di,di
00007C14  BE267C            mov si,0x7c26
00007C17  B92600            mov cx,0x26
00007C1A  B40A              mov ah,0xa
00007C1C  AC                lodsb
00007C1D  AB                stosw
00007C1E  E2FC              loop 0x7c1c
00007C20  4B                dec bx
00007C21  75F1              jnz 0x7c14
00007C23  F4                hlt
00007C24  EBFD              jmp short 0x7c23
00007C26  EA057C0000        jmp 0x0:0x7c05
00007C2B  FC                cld
00007C2C  BB0200            mov bx,0x2
00007C2F  B800B8            mov ax,0xb800
00007C32  8EC0              mov es,ax
00007C34  8CC8              mov ax,cs
00007C36  8ED8              mov ds,ax
00007C38  31FF              xor di,di
00007C3A  BE267C            mov si,0x7c26
00007C3D  B92600            mov cx,0x26
00007C40  B40A              mov ah,0xa
00007C42  AC                lodsb
00007C43  AB                stosw
00007C44  E2FC              loop 0x7c42
00007C46  4B                dec bx
00007C47  75F1              jnz 0x7c3a
00007C49  F4                hlt
00007C4A  EBFD              jmp short 0x7c49
00007C4C  0000              add [bx+si],al
00007C4E  0000              add [bx+si],al
...
```

这个程序分为两个相同的部分。从偏移量`0x7c00`到`0x7c25`的第一部分是可执行字节。从偏移量`0x7c26`到`0x7c4b`的第二部分是可执行字节读取的数据字节。代码的可执行部分有一个外部循环，使用寄存器BX作为计数变量。它将BX设置为2，使得外部循环迭代两次。在每次迭代中，它从程序的第二部分读取数据字节并打印它们。读取字节并打印它们的代码与我们之前的程序非常相似。由于程序第二部分的数据字节与第一部分的可执行字节相同，打印两次数据字节相当于打印程序的所有字节。

虽然这个程序确实避免读取 CPU 执行的字节，但数据字节看起来与可执行字节完全相同。尽管我不认为在像这样的练习中避免读取可执行字节有任何意义，但这个程序作为一个自打印引导程序的例子，不执行它读取的字节。

</main>
