<!--yml

分类：未分类

日期：2024年5月27日14:47:21

-->

# 我们迄今为止与Swift的旅程-一些注释和反思-社区展示- Swift论坛

> 来源：[https://forums.swift.org/t/our-journey-with-swift-thus-far-some-notes-and-reflections/70510](https://forums.swift.org/t/our-journey-with-swift-thus-far-some-notes-and-reflections/70510)

你好！

# 背景

我们的团队正在悄悄地开发一个新的电子交易系统，使用Swift在macOS和Linux上构建，借鉴我们以前两个项目的经验，这两个项目分别用过C、Objective-C、C++、Java、C#，甚至相当长一段时间，使用自行开发的DSL。这些过去的项目都相当庞大，代码行数超过2500万行，历时25多年，团队规模在40到100多个工程师之间。

这些都是非常高性能的、分布式的群集系统，配有复杂的前端可视化和监视功能。服务器端为客户提供API，以便挂接自定义插件，执行交易活动或定价等，这些插件通常需要以进程内方式运行（即动态加载）。这些都是用C++、Java、C和自定义DSL完成的。当我们在这里谈到“服务器端”时，我们指的是传统意义上具有高性能IPC等的服务器端，因此一般不使用HTTP、JSON或类似技术。

探索Swift的生态系统为我们提供了宝贵的见解，了解其优势以及他们有待改进的领域。我们分享的反馈是基于我们迄今为止的旅程，以及我们遇到的障碍，旨在提出对Swift持续完善的建设性想法。在正式推出之前还有一段路要走，但我们想花时间分享一些我们的反思和沉思。

# 为什么选择Swift？

我们希望我们的下一代系统不仅使用一种富有表现力、内存安全且高性能的语言，而且我们还应该能够使用统一的技术栈从上到下。这样可以实现很好的代码重用，工程师可以更容易地在技术栈的不同层面接手工作，我们也可以更轻松地在客户端和服务器端之间统一实现各种类型。我们还有商业上的必要性，需要能够在服务器端部署在Linux上，除了macOS用于可视化（可能还涉及其他Apple平台未来发展）。

Swift大部分情况都符合这些要求，同时还提供了使用SwiftUI创建原生良好用户界面的能力。还有一些其他选择，但出于各种原因，它们不符合我们的标准（对此帖子不相关）。

# 好东西

### 整体设计

+   Swift 的设计“默认安全性” - 严格的类型检查在开始时有点令人沮丧（好吧，有时候还是会；-）但经过最初（小）的障碍后，我们真的能看到它带来了丰厚的回报 - 代码*更经常*会立即按预期工作（特别是与 C 风格语言相比），经过编译器的处理后，主要的重构工作速度更快更稳健。运行时错误的数量只是传统工具中常见数量的一小部分。我们对这一方面非常满意。即将推出的静态数据竞争安全性保证只是锦上添花。

+   总体上来说，语言的表现力非常好，我们认为整体的哲学思想取得了良好的平衡。我们有点担心语言的复杂性对新手来说仍在增加，但希望渐进式披露的哲学思想将使其随着时间的推移变得可管理。

+   过去几年主要语言特性的开发速度很快，有几个功能完全符合我们的需求，非常有用，比如结构化并发/异步+等待/角色、分布式角色、内存所有权（非常重要，很高兴看到它正在开发中！），以及泛型和宏的整体改进。

+   总体来说，开放的演进过程非常好（除了一些小问题，比如结果构建器）。能够看到路线图确实有助于我们，并受到赞赏 - 例如，我们看到分布式角色和新的谓词类型在规划中，可以选择在内部简单地生成平凡的实现，然后随着它们的发布而转移 - 非常好。

+   ABI 稳定性确实是一个关键功能 - 我们希望为客户面向的 SDK 使用库演进，并且这真是一个伟大的功能 - 不仅对于苹果作为系统提供商，对于我们作为第三方也同样重要。我们需要能够发布客户可以链接的共享库，以便我们可以具有弹性和类型兼容性地动态加载插件。

### 生态系统

+   用于服务器端开发的软件包生态系统[比预期的更为广泛](https://forums.swift.org/t/the-current-state-of-swift-for-server-and-linux/47732/9) - 随着时间的推移，我们也为一些我们错过的部分做出了贡献，例如[HDR Histogram](https://github.com/HdrHistogram/hdrhistogram-swift)、[swift-kafka-client](https://github.com/swift-server/swift-kafka-client)和[性能基准测试](https://github.com/ordo-one/package-benchmark)

+   我们也非常满意 Foundation 的本地重写（并且已经开始积极使用某些新功能，如谓词），而且*真的*期待它作为 Linux 内置实现的整合 - 它使我们从无 Foundation 政策转变为现在采纳它。

+   SwiftPM 插件（和宏）正在支持更广泛的工作流。

总体上，我们对语言本身非常满意，并且随着时间的推移看到了显著的进展。

# 主要挑战

很多问题集中在更丰富的动态库支持、API 打包和 Linux 平台支持上，这些是我们需要为正确打包产品做的。

+   [具有库演进的 Linux 动态库支持](https://github.com/apple/swift-package-manager/issues/5714) - 即使是有限的官方支持包，有明确的限制也将非常有用（因为我们的客户将拥有完全受控的环境，可以强制指定特定的库版本和补丁级别等）。

+   [用于工件束的库支持](https://github.com/apple/swift-package-manager/pull/6967)（我们目前正在使用支持在 Linux 上运行 xcframeworks 的自定义工具链来解决此问题，但这并不是长期可持续的）。

+   并发运行时分析工具可能会更丰富，特别是对于任务 - 虽然我们在 Instruments 中有一些工具，但在 LLDB 中也支持访问类似任务信息（异步任务堆栈回溯等，用于创建/运行/休眠），尤其是在没有 Instruments 的 Linux 上（包括检查任务本地变量）。

+   [编译和运行时可用性检查](https://github.com/apple/swift/issues/60458) 目前不支持第三方 API。

+   对于动态库整体的基本支持作为第一类公民，例如[目标不能动态链接](https://github.com/apple/swift-package-manager/issues/4951)。

# 小挑战

### 并发和测试

### 工具和平台支持

+   Linux 支持有时会滞后（例如宏支持），这推迟了我们采用新版本，并且并非总是透明的。

+   在使用新 Foundation 时，Linux 上的构建时间非常痛苦（我们不仅需要构建 swift-foundation，还需要构建 swift-syntax，因为使用了宏 - 当然这是众所周知的问题，但只是想提一下，因为这导致了我们的长期 CI 轮转）。

+   构建稳定性和性能 - 我们经常需要清除 `.build` 或 SwiftPM 缓存，或者 Xcode 派生数据，因为出现了奇怪的问题（例如在 Xcode 中缺少 Packages），例如，某些情况下似乎重建的次数超出预期（例如[这个示例](https://github.com/apple/swift-package-manager/issues/7210)用于基准测试）。

+   SwiftPM 在产品/目标模型上对于较大项目有些问题；目标暴露给下游项目，目标无法依赖同一包中的产品，目标名称冲突（别名并不总是有效）与模块名称（可能不完全是 SwiftPM 的问题）。

+   本地依赖项的开发有些笨拙，Swift 包编辑只能部分解决这个问题。我们最终得到了一个有时复杂且非理想的项目结构，上面堆砌了一些工具/解决方案。

+   LLDB 在 Linux 上的支持一直比较不稳定，尤其是频繁崩溃（以及[报告的问题更新很少](https://github.com/issues?q=is%3Aopen+is%3Aissue+author%3Ahassila+archived%3Afalse+SR-)），尽管随着时间的推移有所改善。

+   在 Linux 上作为线程管理基础的 Libdispatch 仍然落后于 macOS 实现（主要是因为将新实现合并到 Libdispatch 中困难，因为 Libdispatch 大量使用 Mach:isms）。也许在某个时候应该重新考虑与线程管理的集成方法，但可以理解的是，这里有很多历史性的考虑，因为有很多使用 Dispatch 的代码。

### 性能

+   性能问题有时候很难诊断和解决（例如不必要的复制，在使用存在类型/泛型时，如果不得当，可能会导致大量元数据查找，ARC 流量等） - 需要[解决方法](https://forums.swift.org/t/modern-way-to-vend-specializations-of-a-generic-type/65657/5)，以允许编译器正确地进行专门化。似乎某种用于分析 Swift 中反模式的工具会有所帮助，欢迎讨论详细内容。

+   泛型尽管随着时间的推移有所改进，但有时仍然不尽如人意，有时候难以获得期望的行为。从性能的角度来看，有时候是赌运气。保证事物会被专门化是个挑战，并且很容易做一个漂亮的泛型重构，结果性能却突然下降。在这个领域的改进将是很好的，例如有关各种注释的讨论（例如保证专门化）。

+   [KeyPath 的性能问题很严重](https://forums.swift.org/t/pitch-swift-predicates/62000/35) - 不幸的是，KeyPaths 的性能问题迫使我们即使在像排序比较器这样相对简单的情况下也需要采取解决方法，因为它们会完全接管样本 - 如果能毫无顾虑地使用它们会很好。

+   当使用泛型和面向协议编程时，需要更深入的文档和最佳实践提示（与上述问题相关）。基本上是对旧性能最佳实践的跟进，但更多关注跨模块考虑。

+   分析程序行为缺少一些[运行时挂钩](https://github.com/apple/swift/issues/64636)以更好地理解运行时行为和执行更好的基准测试。

总体而言，我们欢迎在运行时性能、编译时间和总体健壮性（SwiftPM / Toolchain / Linux 支持与 macOS 相当）方面进一步投资。

# 结束语

总之，我们对 Swift 的经验虽然在很大程度上是积极的，因为它具有现代特性和健壮的生态系统，但也突出了可以进一步改进和扩展其能力的领域，特别是对稍微复杂和先进的开发场景。我们希望这些反馈能作为对 Swift 持续发展和改进的建设性贡献，反映出我们帮助推动生态系统朝着积极方向发展的承诺。我们很乐意详细阐述并参与上述任何主题的讨论。

许多感谢所有参与使 Swift 及相关包可用的人们 - 我们认为它正在一个很好的轨迹上，期待继续我们的旅程！

特别感谢所有参与并在这些论坛上分享他们知识的人们，这是一个宝贵的社区资源，谢谢！

Joakim
