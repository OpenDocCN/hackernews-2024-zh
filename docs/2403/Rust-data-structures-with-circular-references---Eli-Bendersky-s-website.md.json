["```\nstruct Tree  { root: Option<Node>, } struct Node  { data: i32, left: Option<Box<Node>>, right: Option<Box<Node>>, } \n```", "```\nstruct Node  { data: i32, left: Option<Box<Node>>, right: Option<Box<Node>>, parent: Option<&Node>, } \n```", "```\nstruct Tree<'a>  { root: Option<Node<'a>>, } struct Node<'a>  { data: i32, left: Option<Box<Node<'a>>>, right: Option<Box<Node<'a>>>, parent: Option<&'a  Node<'a>>, } \n```", "```\nuse  std::cell::RefCell; use  std::rc::{Rc,  Weak}; pub  struct Tree  { count: usize, root: Option<NodeLink>, } type NodeLink  =  Rc<RefCell<Node>>; #[derive(Debug)] struct Node  { data: i32, left: Option<NodeLink>, right: Option<NodeLink>, parent: Option<Weak<RefCell<Node>>>, } \n```", "```\n/// Insert a new item into the tree; returns `true` if the insertion\n/// happened, and `false` if the given data was already present in the\n/// tree.\npub  fn insert(&mut  self,  data: i32)  -> bool { if  let  Some(root)  =  &self.root  { if  !self.insert_at(root,  data)  { return  false; } }  else  { self.root  =  Some(Node::new(data)); } self.count  +=  1; true } // Insert a new item into the subtree rooted at `atnode`.\nfn insert_at(&self,  atnode: &NodeLink,  data: i32)  -> bool { let  mut  node  =  atnode.borrow_mut(); if  data  ==  node.data  { false }  else  if  data  <  node.data  { match  &node.left  { None  =>  { let  new_node  =  Node::new_with_parent(data,  atnode); node.left  =  Some(new_node); true } Some(lnode)  =>  self.insert_at(lnode,  data), } }  else  { match  &node.right  { None  =>  { let  new_node  =  Node::new_with_parent(data,  atnode); node.right  =  Some(new_node); true } Some(rnode)  =>  self.insert_at(rnode,  data), } } } \n```", "```\n/// Find the item in the tree; returns `true` iff the item is found.\npub  fn find(&self,  data: i32)  -> bool { self.root .as_ref() .map_or(false,  |root|  self.find_node(root,  data).is_some()) } fn find_node(&self,  fromnode: &NodeLink,  data: i32)  -> Option<NodeLink>  { let  node  =  fromnode.borrow(); if  node.data  ==  data  { Some(fromnode.clone()) }  else  if  data  <  node.data  { node.left .as_ref() .and_then(|lnode|  self.find_node(lnode,  data)) }  else  { node.right .as_ref() .and_then(|rnode|  self.find_node(rnode,  data)) } } \n```", "```\npub  struct Tree  { // All the nodes are owned by the `nodes` vector. Throughout the code, a\n  // NodeHandle value of 0 means \"none\".\n  root: NodeHandle, nodes: Vec<Node>, count: usize, } type NodeHandle  =  usize; #[derive(Debug)] struct Node  { data: i32, left: NodeHandle, right: NodeHandle, parent: NodeHandle, } \n```", "```\n/// Insert a new item into the tree; returns `true` if the insertion\n/// happened, and `false` if the given data was already present in the\n/// tree.\npub  fn insert(&mut  self,  data: i32)  -> bool { if  self.root  ==  0  { self.root  =  self.alloc_node(data,  0); }  else  if  !self.insert_at(self.root,  data)  { return  false; } self.count  +=  1; true } // Insert a new item into the subtree rooted at `atnode`.\nfn insert_at(&mut  self,  atnode: NodeHandle,  data: i32)  -> bool { if  data  ==  self.nodes[atnode].data  { false }  else  if  data  <  self.nodes[atnode].data  { if  self.nodes[atnode].left  ==  0  { self.nodes[atnode].left  =  self.alloc_node(data,  atnode); true }  else  { self.insert_at(self.nodes[atnode].left,  data) } }  else  { if  self.nodes[atnode].right  ==  0  { self.nodes[atnode].right  =  self.alloc_node(data,  atnode); true }  else  { self.insert_at(self.nodes[atnode].right,  data) } } } \n```", "```\n// Allocates a new node in the tree and returns its handle.\nfn alloc_node(&mut  self,  data: i32,  parent: NodeHandle)  -> NodeHandle  { self.nodes.push(Node::new_with_parent(data,  parent)); self.nodes.len()  -  1 } \n```", "```\n// Replaces `node` with `r` in the tree, by setting `node`'s parent's\n// left/right link to `node` with a link to `r`, and setting `r`'s parent\n// link to `node`'s parent.\n// Note that this code doesn't actually deallocate anything. It just\n// makes self.nodes[node] unused (in the sense that nothing points to\n// it).\nfn replace_node(&mut  self,  node: NodeHandle,  r: NodeHandle)  { let  parent  =  self.nodes[node].parent; // Set the parent's appropriate link to `r` instead of `node`.\n  if  parent  !=  0  { if  self.nodes[parent].left  ==  node  { self.nodes[parent].left  =  r; }  else  if  self.nodes[parent].right  ==  node  { self.nodes[parent].right  =  r; } }  else  { self.root  =  r; } // r's parent is now node's parent.\n  if  r  !=  0  { self.nodes[r].parent  =  parent; } } \n```", "```\npub  struct Tree  { count: usize, root: *mut  Node, } #[derive(Debug)] struct Node  { data: i32, // Null pointer means \"None\" here; right.is_null() ==> no right child, etc.\n  left: *mut  Node, right: *mut  Node, parent: *mut  Node, } \n```", "```\nimpl  Node  { fn new(data: i32)  -> *mut  Self  { Box::into_raw(Box::new(Self  { data, left: std::ptr::null_mut(), right: std::ptr::null_mut(), parent: std::ptr::null_mut(), })) } fn new_with_parent(data: i32,  parent: *mut  Node)  -> *mut  Self  { Box::into_raw(Box::new(Self  { data, left: std::ptr::null_mut(), right: std::ptr::null_mut(), parent, })) } } \n```", "```\n/// Insert a new item into the tree; returns `true` if the insertion\n/// happened, and `false` if the given data was already present in the\n/// tree.\npub  fn insert(&mut  self,  data: i32)  -> bool { if  self.root.is_null()  { self.root  =  Node::new(data); }  else  { if  !insert_node(self.root,  data)  { return  false; } } self.count  +=  1; true } // Inserts `data` into a new node at the `node` subtree.\nfn insert_node(node: *mut  Node,  data: i32)  -> bool { unsafe  { if  (*node).data  ==  data  { false }  else  if  data  <  (*node).data  { if  (*node).left.is_null()  { (*node).left  =  Node::new_with_parent(data,  node); true }  else  { insert_node((*node).left,  data) } }  else  { if  (*node).right.is_null()  { (*node).right  =  Node::new_with_parent(data,  node); true }  else  { insert_node((*node).right,  data) } } } } \n```", "```\n// Replaces `node` with `r` in the tree, by setting `node`'s parent's\n// left/right link to `node` with a link to `r`, and setting `r`'s parent\n// link to the `node`'s parent. `node` cannot be null.\nfn replace_node(&mut  self,  node: *mut  Node,  r: *mut  Node)  { unsafe  { let  parent  =  (*node).parent; if  parent.is_null()  { // Removing the root node.\n  self.root  =  r; if  !r.is_null()  { (*r).parent  =  std::ptr::null_mut(); } }  else  { if  !r.is_null()  { (*r).parent  =  parent; } if  (*parent).left  ==  node  { (*parent).left  =  r; }  else  if  (*parent).right  ==  node  { (*parent).right  =  r; } } // node is unused now, so we can deallocate it by assigning it to\n  // an owning Box that will be automatically dropped.\n  Box::from_raw(node); } } \n```", "```\nimpl  Drop  for  Tree  { fn drop(&mut  self)  { // Probably not the most efficient way to destroy the whole tree, but\n  // it's simple and it works :)\n  while  !self.root.is_null()  { self.remove_node(self.root); } } } \n```"]