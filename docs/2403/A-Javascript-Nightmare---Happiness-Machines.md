<!--yml

category: 未分类

date: 2024-05-27 15:03:34

-->

# 一个 JavaScript 的噩梦 | 幸福机器

> 来源：[https://blog.ignaciobrasca.com/opinion/2024/03/15/javascript-nightmare.html](https://blog.ignaciobrasca.com/opinion/2024/03/15/javascript-nightmare.html)

那天是星期五，每个人都在离开或准备离开的时候。

***突然，在一个快速演示中，我意识到有些不对劲。***

哦，天哪，游戏开始了…

在初步的快速审查后，我意识到系统在导出文件时表现不如预期。我以不同格式导出了两个文件 - 一个正常，但另一个却一直在加载。

我们的通知 Slack 频道开始排队消息，告诉我们我们可能会在星期五晚上一直忙到很晚。

在第一次调查后，我并没有慌张，意识到问题不仅限于文件 - 只有 PDF 文件有问题。我从我们的内部系统导出了一个 Word 文档，它运行正常。我导出了一个 CSV 文件，同样也没有问题。我重新尝试生成一个 PDF 文件，但是它一直在加载。

我去了我们的测试环境并导出了一个 PDF 文档 - 运行正常。

我的头脑开始混乱。考虑到我正在进行中的演示，我不得不跳出问题，所以我让马丁（一位技术娴熟的工程师，从 Datia 创立之初就加入了）与我一起调查这个问题。

到这时候，已经是下午3点33分了。

## 通常的嫌疑犯

几分钟后，我们开始在我们的实例之间进行调查。

**“也许是 Nginx 的问题？”** 我们检查了我们的服务器，访问日志显示出现了上游超时错误。

怪异（x1）。

我们继续调查，直到找到了通常的嫌疑犯（之前也曾引起过头痛的东西） - AWS WAF。WAF 是由 AWS 提供的 Web 应用防火墙，主要帮助我们在公共域上阻止、控制和预防来自开放网络的有害请求。

经过几分钟的挖掘和几次不成功的尝试后，我们决定进一步调查我们的存储桶。最近，我们遇到了几个问题，AWS 报错说我们触发了 S3 存储桶的配额限制。

怪异（x2），因为我们以为云端可以扩展到无限大。[实际上，它只是别人的机器。](https://blog.codinghorror.com/the-cloud-is-just-someone-elses-computer/)

我们检查了日志，找到了第一个线索：AWS 显示未经授权的错误，似乎是瓶颈问题。我们在会议中相视而笑，异口同声地说道

**“一定是 S3 的问题。”**

> 叙述者：其实不是这样的。

## 混乱的情况

我们赶紧在一个新的存储桶上进行测试并编写了几个脚本。我们又跑回测试环境，因为这个环境过去是正常工作的，但现在突然间又不工作了 - 一直在加载。

我们的假设是，“好吧，我们可能触发了 S3 的另一个隐秘配额。”

让我们从头开始创建一个存储桶，但首先，让我们从虚拟机中对这些存储桶进行测试。

我们做到了，它也像魔术一样正常工作了 - 同一个文档。现在我们的困惑是极大的，但是我们不得不像夏洛克·福尔摩斯探案一样继续深入挖掘。

### 胡说八道的生态系统

我们遇到了那些在一个严肃的编程环境中基本上不会遇到的问题 [(不是故意说笑，JavaScript 的小伙伴们！)](https://nadh.in/blog/javascript-ecosystem-software-development-are-a-hot-mess/)：

1.  可能实例内存不足了，但是我们为什么没有抛出错误？

1.  可能是文件内容的问题导致了这一切，但为什么我们看不到异常，只是超时了呢？

1.  这是一个 bug，但是在哪里？

1.  必须是一个 `undefined` 的流？

1.  或者是一个 `null` 的流？

1.  我们用来上传东西的库是否已经不再支持了？

到这个时候，对我来说已经是下午6点40分（瑞典时间），对阿根廷的马丁来说也已经很晚了。我们开始打转圈了。

我们决定放大焦点，直接在生产环境中进行测试，因为现在已经超出了工作时间 [(而且因为我没有提到：我们的本地工作像魔术一样顺利！)](https://dylanbeattie.net/2017/04/27/it-works-on-my-machine.html)

我们修改了代码，开始使用一种非库策略将流上传到 S3 中（[顺便说一句，这很混乱，不那么直接](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example_s3_Scenario_UploadStream_section.html)）。

几次尝试，依然没有进展 - 在我们的本地环境中运行正常，但在云端却不行。

## 网络

到这个时候，我已经感到非常沮丧了，因为今天是星期五，我们仍然在这里调试一个 JavaScript 的混乱。足够令人沮丧，因为在 JavaScript 中，你似乎永远无法控制发生了什么。

在 C 语言中，你可以继续错误配置一个 makefile 来输出调试文件，导致段错误或者错误引用，但归根结底，这是你的错。

任何严肃的语言生态系统也是如此。

但 JavaScript 却正好相反：**它像魔法一样运行（这不是在恭维！）即使你知道它只是软件！**

最终我开始相信，“也许是 AWS 封锁了我们的公共域名，从那里开始，我们就无法上传文件了？如果……”

无论如何，我在我们的虚拟机上尝试了，但是没有 - 它就像魔术一样正常工作。有趣的是，在此过程中，我们的背景中有三个管道和周末的工作流程，并且没有一个出现了故障或引发错误。

## 重聚

到了晚上8点15分，我们决定收工，各自继续。我们采取的每一步都毫无作用。

所以我决定开始移除和清理我们用于测试的东西，然后去超市走了五分钟。

我回来说，“好吧，让我们重新开始吧。” 我在我的本地对我们的生产环境进行了测试，并模拟了这种场景 - 它奏效了，甚至包括我们的域名。

这不是 S3 的问题；AWS 被排除了。一定是文档服务或者代码的问题……

我们与马丁讨论了一会儿，聊了聊，然后我继续进行实验……

我清除了本地环境的所有缓存，所有 `node_modules` 引用，所有锁文件。我再次运行了安装过程并重新导出了… **它没有工作。**

我发送的下一条消息是：“我们找到了它！”

现在问题在于理解发生了什么，因为这不是服务器问题，而是一个库的问题。

执行 `git diff`，我们可以观察到与以下相关的几个库的一些更改：

```
@smithy/util-stream@2.2.0
@smithy/is-array-buffer@2.1.1
... 
```

所有这些都是因为几个月前更新了 `@aws-sdk`… 奇怪（x3），而且与此密切相关。

我们继续调查，发现我们在服务器内部用于渲染文件的实际库也发生了变化，并且它改变了… `流式传输管道`。

天哪，我们离成功如此之近。

我们继续挖掘并决定将包降级到互联网上这些更改之前的最新版本。我们修改了 `package.json` 并推送到生产环境（是的，到这一步，没有其他办法了）。

…

几分钟后，部署失败了：`github 超时`。

天哪。无论如何，我们开始了一个新的工作流程，并且它成功了。

我们去到我们的生产环境并检查 - 它不工作了，但现在不再是超时，而是一个直接的错误，由一个处理文件流的功能所导致。

我们离成功如此之近。

查看了日志：

`this.subset.encodeStream is not a function`

天哪，圣杯… 现在怎么办？

我做了个快速搜索，显然，如果你想要使用特定版本的库与特定版本一起使用，你需要在文档中注册字体时使用一个固定的版本…

无论如何，现在大约是晚上 10 点，我们唯一想做的事就是关掉电脑睡觉（对我来说是这样，不知道马丁怎么样）。

我们升级并安装了库，推送了，运行了安装过程 - 它没用。

嗯…

几分钟后，我们清理了管道缓存，重新启动了我们的环境，甚至清理了负载均衡器（WTF，以防万一）。

我再次推送并部署。它起作用了。

直到这一点，我们甚至都不感到惊讶；我们只是想离开。

我们检查了文档 - 里面除了 SVG 之外全是空的。

我正在考虑现在开一家餐厅。

我们再次检查，从头开始执行整个过程，除了我们采取的其他降级/升级操作之外，我们还不得不升级了一个我们没想到与这个混乱有关的库，现在 - 它成功了。文档在那里，现在每个人都可以有一个 PDF。

系统**再次稳定**了。

我们的理智可能不在。

### 心灵的净化

几乎难以置信这个生态系统是如此广泛和分散在全球各地。它很糟糕，开发体验接近于一个试图不用火箭筒朝自己的脚开火的偏执安卓。

JavaScript 有时感觉太可塑、太容易、太干净，但它并不是。报应会在游戏的后期出现。

现在我们的策略肯定是至少使用一个类型化系统或更健壮的运行时。这种混乱不能再持续存在了，如果它存在的话，JavaScript将不再是支持它的工具（因为它严格来说是一个糟糕的工具）。

## 结论

你似乎需要了解太多的琐碎细节（而魔鬼就藏在这些细节里！）才能真正理解发生了什么——这与成为专家无关，而是成为细节上的专家。

为什么这个库不能与最新版本的AWS配合使用呢？谁知道呢？甚至这个库的开发者可能也不知道，因为JavaScript生态系统的联系如此之差，以至于每个人都盲目地信任彼此的代码和基础设施。这与使用像Cargo（Rust）、NuGet（C#）等强大包管理器的体验完全不同。

JavaScript确实有效，而且在很多事情上表现良好。但是不要试图用它来构建一个真正可扩展的系统。当生态系统如此脆弱而微妙时，要完全避免自掘坟墓实在是太困难了。一个微小的版本不匹配或破坏性变化就可能让你的关键应用陷入停顿，我们痛苦地经历过这一点。

JavaScript世界变化太快，依赖项不断变化并且破坏向后兼容性。这使得任何试图成为企业级、长期解决方案的项目都面临极高的风险。当你必须与npm宇宙及其琐碎问题的不断变化抗争时，你就会发现困境重重。

感觉就像你在不断逆流而上，需要成为领域专家才能使你的应用程序保持浮在水面。这是一个不必要的高认知负担，通常超过了JavaScript提供的好处。

别误会，JavaScript有时是一个好工具。但我们通过艰难的方式学到的是，它并不适合构建需要经受时间考验的强大平台。

生态系统是一个美丽的混乱，但仍然是一个混乱。对于关键应用程序来说，处理它的混乱和琐碎问题的成本太高了。

在这一点上，问题甚至不再是JavaScript本身，而是开发者对其工具的基本信任缺失。想象一下，一个木匠有一个大部分时间都是用来打钉子的锤子，但偶尔会随机和不可预测地击打木匠自己。

为什么那个木匠要使用这样一个不可靠和危险的锤子来建造每一件家具？这毫无道理。然而，这就是我们在JavaScript中所面临的情况。

我不知道像Bun.js或Deno这样的即将推出的项目是否会改善这种情况。我只是认为JavaScript语言本身已经变得过于模糊和庞大，无法避免在构建和部署中引发混乱。
