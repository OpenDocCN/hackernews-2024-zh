["```\n`#version 320 es\n// ^^ specify OpenGL ES version\n\n// requested precision of float values (ignore this)\nprecision highp float;\n\n// name of the shader output value (RGBA pixel color)\nout vec4 FragColor;\n\n// max number of ray marching iterations\n#define MAX_STEPS 100\n\n// max distance from object before considered a miss\n#define MISS_DIST 60.0\n\n// max distance to object before considered as hit\n#define HIT_DIST 0.01\n\n// \"uniform\" means this value is set separately using \n// the OpenGL library. Resolution in pixels.\nuniform vec2 screenResolution;\n\n// the position at which rays are spawned\nconst vec3 cameraPos = vec3(6.0, 6.0, -6.0);\n\n// SDF to our scene as a whole\nfloat sdScene(vec3 rayPos);\n\n// main entry point\nvoid main() {\n  // gl_FragCoord.xy is a unique, per pixel (or \"fragment\"),\n  // whole number value. With origin in the lower left corner.\n  vec2 pixelCoord = gl_FragCoord.xy;\n\n  // Move origin from bottom left to center\n  pixelCoord -= (0.5 * screenResolution.xy);\n\n  // Scale y from -1.0 to 1.0, scale x by same factor\n  pixelCoord = pixelCoord / viewPortResolution.y;\n\n  // direction of ray through pixel\n  vec3 rayDir = vec3(pixelCoord.x, pixelCoord.y, 1.0);\n\n  // modify rayDir to be unit length (1 unit long)\n  rayDir = normalize(rayDir);\n\n  // distance the ray has travelled\n  float dist = 0.0;\n\n  // assume miss by default\n  bool hit = false;\n\n  // ray marching iteration count\n  int iterations = 0;\n\n  // break loop after max iterations\n  while(iterations < MAX_STEPS) {\n\n    // current position of the ray\n    vec3 pos = cameraPos + (dist * rayDir);\n\n    // current distance to scene\n    float posToScene = sdScene(pos);\n\n    // add to total ray distance traveled\n    dist += posToScene;\n\n    // register hit if close enough to scene\n    if(posToScene < HIT_DIST) {\n      hit = true;\n      break;\n    }\n\n    // register miss if too far from scene\n    if(posToScene > MISS_DIST) {\n      break;\n    }\n\n    iterations += 1;\n  }\n\n  if(hit) {\n    // simple shading based on ray marching iterations\n    // fading from white (1.0) to black (0.0)\n    vec3 color = vec3(1.0 - (iterations / float(MAX_STEPS));\n\n    // set pixel output value (with 100% opacity)\n    FragColor = vec4(color, 1.0);\n  } else { // miss\n    // dark grey used as miss color\n    const vec3 missColor = vec3(0.2, 0.2, 0.2);\n\n    // set pixel output value (with 100% opacity)\n    FragColor = vec4(missColor, 1.0);\n  }\n}\n\nfloat sdScene(vec3 rayPos) {\n // calculate SDF to the scene\n}`\n```", "```\n`#version 320 es\n\nprecision highp float;\n\nout vec4 FragColor;\n\n#define MAX_STEPS 100\n#define MISS_DIST 60.0\n#define HIT_DIST 0.01\n\nuniform vec2 screenResolution;\n\nconst vec3 cameraPos = vec3(6.0, 6.0, -6.0);\n\nfloat sdScene(vec3 rayPos);\n\nvoid main() {\n  vec2 pixelCoord = gl_FragCoord.xy;\n  pixelCoord -= (0.5 * screenResolution.xy);\n  pixelCoord = pixelCoord / viewPortResolution.y;\n\n  vec3 rayDir = vec3(pixelCoord.x, pixelCoord.y, 1.0);\n  rayDir = normalize(rayDir);\n\n  float dist = 0.0;\n  bool hit = false;\n  int iterations = 0;\n\n  while(iterations < MAX_STEPS) {\n    vec3 pos = cameraPos + (dist * rayDir);\n    float posToScene = sdScene(pos);\n    dist += posToScene;\n    if(posToScene < HIT_DIST) {\n      hit = true;\n      break;\n    }\n    if(posToScene > MISS_DIST) { break; }\n    iterations += 1;\n  }\n\n  if(hit) {\n    vec3 color = vec3(1.0 - (float(iterations) / float(MAX_STEPS)));\n    FragColor = vec4(color, 1.0);\n  } else { // miss\n    const vec3 missColor = vec3(0.2, 0.2, 0.2);\n    FragColor = vec4(missColor, 1.0);\n  }\n}\n\nfloat sdScene(vec3 rayPos) {\n // calculate SDF to the scene\n}`\n```", "```\n// signed distance to a point\nfloat sdPoint(vec3 rayPosition, vec3 pointPosition) {   \n\n  // vector from point to ray\n  vec3 pointToRay = rayPosition - pointPosition;  \n\n  // Pythagorean theorem to get length of vector\n  float distanceToPoint = sqrt(pointToRay.x * pointToRay.x +\n                               pointToRay.y * pointToRay.y +\n                               pointToRay.z * pointToRay.z);\n\n  return distanceToPoint;\n}\n```", "```\nfloat sdSphere(vec3 rayPosition, vec3 sphereCenterPosition, float radius) {\n  vec3 centerToRay = rayPosition - sphereCenterPosition;\n  float distToCenter = length(centerToRay);\n  float distToSurface = distToCenter - radius;\n  return distToSurface;\n}\n```", "```\nfloat sdSphere(vec3 rayPosition, float radius) {\n  float distToCenter = length(rayPosition);\n  float distToSurface = distToCenter - radius;\n  return distToSurface;\n}\n\n// signed distance to a scene\nvoid sdScene() {\n  // ...\n  vec3 spherePosition = vec3(-5.0, 3.0, 0.0);\n  vec3 distToSphere = sdSphere(rayPosition - spherePosition, 1.0);\n  // ...\n}\n```", "```\nfloat sdSphere(vec3 rayPosition) {\n  const float radius = 1.0;\n  return length(rayPosition) - radius; \n}\n\nvoid sdScene() {\n  // …\n  // sphere's position\n  vec3 p = vec3(-5.0, 3.0, 0.0);\n  // sphere's radius\n  float r = 3.0;\n  vec3 distToSphere = sdSphere((rayPos - p) / r) * r;\n  // …\n}\n```", "```\nfloat sdSquareCornerOnly(vec2 rayPos) {\n  // half initial scale of square\n  const float halfWidth = 1.0;\n  const vec2 corner = vec2(halfWidth, halfWidth);\n  // fold ray into positive quadrant\n  vec2 foldedPos = abs(rayPos);\n  vec2 cornerToRay = foldedPos - corner;\n  return length(cornerToRay);\n}\n```", "```\nfloat sdSquareOutsideOnly(vec2 rayPos) {\n  const float halfWidth = 1.0;\n  const vec2 corner = vec2(halfWidth, halfWidth);\n  vec2 foldedPos = abs(rayPos);\n  vec2 cornerToRay = foldedPos - corner;\n\n  // ignore negative components\n  vec2 closestToRay = max(cornerToRay, 0.0); \n\n  return length(closestToRay);\n}\n```", "```\nfloat sdSquare(vec2 rayPos) {\n  const float halfWidth = 1.0;\n  const vec2 corner = vec2(halfWidth, halfWidth);\n  vec2 foldedPos = abs(rayPos);\n  vec2 cornerToRay = foldedPos - corner;\n  vec2 closestToOutsideRay = max(cornerToRay, 0.0);\n\n  // Acquire max component\n  float cornerToRayMaxComponent = max(cornerToRay.x, cornerToRay.y);\n\n  // If the max component is a positive value, clamp it to zero\n  float distToInsideRay = min(cornerToRayMaxComponent, 0.0);\n\n  // return either the distance to outside OR distance to inside\n  return length(closestToOutsideRay) + distToInsideRay;\n} \n```", "```\nfloat sdCube(vec3 rayPos) {\n  // half initial scale of square (arbitrary)\n  const float halfWidth = 1.0;\n  const vec3 corner = vec3(halfWidth, halfWidth, halfWidth);\n\n  // fold ray into positive octant\n  vec3 foldedPos = abs(rayPos);\n  // corner to ray\n  vec3 ctr = foldedPos - corner;\n\n  // ignore negative components for outside points\n  vec3 closestToOutsideRay = max(ctr, 0.0);\n\n  // Acquire max component\n  float cornerToRayMaxComponent = max(max(ctr.x, ctr.y), ctr.z);\n\n  // If the max component is a positive value, clamp to zero\n  float distToInsideRay = min(cornerToRayMaxComponent, 0.0);\n\n  // return either the distance to outside OR distance to inside\n  return length(closestToOutsideRay) + distToInsideRay;\n} \n```", "```\nfloat sdCrossInnerCornerOnly(vec2 rayPos) {\n  const float halfWidth = 1.0;\n  const vec2 corner = vec2(halfWidth, halfWidth);\n  vec2 foldedPos = abs(rayPos);\n  vec2 cornerToRay = foldedPos - corner;\n  // when inside, distances are negative\n  return -length(cornerToRay);\n}\n```", "```\nfloat sdCrossInnerOnly(vec2 rayPos) {\n  const float halfWidth = 1.0;\n  const vec2 corner = vec2(halfWidth, halfWidth);\n  vec2 foldedPos = abs(rayPos);\n  vec2 cornerToRay = foldedPos - corner;\n\n  // ignore positive components for inside points\n  vec2 closestInsidePoint = min(cornerToRay, 0.0);\n\n  return -length(closestInsidePoint);\n}\n```", "```\nfloat sdCross(vec2 rayPos) {\n  const float halfWidth = 1.0;\n  const vec2 corner = vec2(halfWidth, halfWidth);\n  vec2 foldedPos = abs(rayPos);\n  vec2 cornerToRay = foldedPos - corner;\n  vec2 closestInsidePoint = min(cornerToRay, 0.0);\n\n  // acquire min component\n  float minComponent = min(cornerToRay.x, cornerToRay.y);\n\n  // If min component is negative, clamp to zero\n  float distToOutsidePoint = max(minComponent, 0.0);\n\n  // return either the distance to inside OR outside\n  return -length(closestInsidePoint) + distToOutsidePoint;\n}\n```", "```\nfloat sdCross(vec3 rayPos) {\n  const float halfWidth = 1.0;\n  const vec3 corner = vec3(halfWidth, halfWidth, halfWidth);\n  vec3 foldedPos = abs(rayPos);\n\n  // corner to ray\n  vec3 ctr = foldedPos - corner;\n\n  // isolate minimum/maximum components\n  float minComp = min(min(ctr.x, ctr.y), ctr.z);\n  float maxComp = max(max(ctr.x, ctr.y), ctr.z);\n\n  // fancy way to acquire middle component\n  float midComp = ctr.x + ctr.y + ctr.z - minComp - maxComp;\n\n  // Handles: #1, #2, #3, #4\n  vec2 closestOutsidePoint = max(vec2(smallestComp, middleComp), 0.0);\n  // Handles: #5\n  vec2 closestInsidePoint = min(vec2(middleComp, largestComp), 0.0);\n\n  // return either the distance to inside OR outside\n  return length(closestOutsidePoint) + -length(closestInsidePoint);\n}\n```", "```\nfloat union = min(sdShape1(rayPos), sdShape2(rayPos))\n```", "```\nfloat subtraction = max(-sdShape1(ray), sdShape2(ray))\n```", "```\nfloat intersection max(sdShape1(ray), sdShape2(ray))\n```", "```\nfloat sdBoundedCross(vec3 rayPos) {\n  float boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n  float crossDist = sdCross(rayPos);\n  float sdIntersection = max(boundingBoxDist, crossDist);\n  return sdIntersection;\n}\n```", "```\nfloat sdBoundedCrossSlimmed(vec3 rayPos) {\n  const float oneThird = 1.0 / 3.0;\n  float boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n  float crossDist = sdCross(rayPos / oneThird ) * oneThird;\n  float sdIntersection = max(boundingBoxDist, crossDist);\n  return sdIntersection;\n}\n```", "```\nfloat sdBoundedCrossWithBox(vec3 rayPos) {\n  float boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n  float crossDist = sdCross(rayPos / 3.0) * 3.0;\n  float intersection = max(boundingBoxDist, crossDist);\n  float spongeBox = sdCube(rayPos);\n  float sdBoxCrossUnion = min(intersection, spongeBox);\n  return sdBoxCrossUnion;\n}\n```", "```\nfloat sdMengerSpongeIteration1(vec3 rayPos) {\n  const float oneThird = 1.0 / 3.0;\n  float crossDist = sdCross(rayPos / oneThird) * oneThird;\n  float spongeBox = sdCube(rayPos);\n  float sdSubtraction = max(spongeBox, -crossDist);\n  return sdSubtraction;\n}\n```", "```\nfloat sdBoundedBoxFieldBroken(vec3 rayPos) {\n  float boundingBox = sdCube(rayPos / 3.9) * 3.9;\n  // transform space from single unbounded space\n  // to infinite bounded spaces in range of [0.0, 2.0)\n  vec3 repeatingPos = mod(rayPos, 2.0);\n  float cubeDist = sdCube(repeatingPos / 1.5) * 1.5;\n  float sdIntersection = max(cubeDist, boundingBox);\n  return sdIntersection;\n}\n```", "```\nfloat sdBoundedBoxFieldBroken(vec3 rayPos) {\n  // slight change in bounding box scale\n  float boundingBox = sdCube(rayPos / 4.0) * 4.0;\n  vec3 repeatingPos = mod(rayPos, 2.0);\n  float dist = sdCube(repeatingPos / 1.5) * 1.5;\n  float sdIntersection = max(dist, boundingBox);\n  return sdIntersection;\n}\n```", "```\nfloat sdBoundedBoxField(vec3 rayPos) {\n  float boundingBox = sdCube(rayPos / 4.0) * 4.0;\n  vec3 repeatingPos = mod(rayPos, 2.0);\n  // transform repeating space range from [0,2) to [-1, 1)\n  repeatingPos -= 1.0;\n  float dist = sdCube(repeatingPos / 0.8) * 0.8;\n  float sdIntersection = max(dist, boundingBox);\n  return sdIntersection;\n}\n```", "```\nfloat sdTwentySevenBoxesKinda(vec3 rayPos) {\n  // bounding box spans all axes between [-1.0, 1.0]\n  float boundingBox = sdCube(rayPos);\n\n  // sdCube() defines a cube with a halfwidth of 1, or a\n  // width of 2 units.\n  const float cubeWidth = 2.0;\n\n  // Transform space into infinite cube spaces with\n  // dimensions in range of [0, 2/3).\n  float boxedWorldDimen = cubeWidth / 3.0;\n  vec3 repeatingPos = mod(rayPos, boxedWorldDimen);\n\n  // move origin in cube space from corner to center\n  // now with a range between [-1/3, 1/3)\n  repeatingPos -= (boxedWorldDimen / 2.0);\n\n  // Stretch repeated spaces from [-1/3, 1/3) to [-1.0, 1.0)\n  repeatingPos *= 3.0;\n\n  // Shrink the cubes slightly to reveal gaps between them\n  float dist = sdCube(repeatingPos / 0.9) * 0.9;\n\n  // Acquire actual distance with correction to prev stretch\n  dist /= 3.0;\n\n  float sdIntersection = max(dist, boundingBox);\n  return sdIntersection;\n}\n```", "```\nfloat sdTwentySevenBoxesCross(vec3 rayPos) {\n  float boundingBox = sdCube(rayPos);\n  const float cubeWidth = 2.0;\n  float boxedWorldDimen = cubeWidth / 3.0;\n  vec3 repeatedPos = mod(rayPos, boxedWorldDimen);\n  repeatedPos -= (boxedWorldDimen) / 2.0;\n  repeatedPos *= 3.0;\n  float boxesDist = sdCube(ray / 0.9) * 0.9;\n  boxesDist /= 3.0;\n  float boxesIntersection = max(boxesDist, boundingBox);\n\n  // Cross that runs along the axes\n  float crossDist = sdCross(rayPos / 0.25) * 0.25;\n  float sdIntersection = max(boxesDist, crossDist);\n  return sdIntersection;\n}\n```", "```\nfloat sdTwentySevenBoxes(vec3 rayPos) {\n  float boundingBox = sdCube(rayPos);\n  const float cubeWidth = 2.0;\n  float boxedWorldDimen = cubeWidth / 3.0;\n\n  // We want to translate the first box in the\n  // positive octant. Changing its world coordinates\n  // from [0, boxedWorldDimen) to \n  // [-boxedWorldDimen / 2.0, boxedWorldDimen / 2.0)\n  float translation = -boxedWorldDimen / 2.0;\n  vec3 ray = rayPos - translation;\n\n  vec3 repeatedPos = mod(ray, boxedWorldDimen);\n  repeatedPos += translation;\n  repeatedPos *= 3.0;\n  float dist = sdCube(repeatedPos / 0.9) * 0.9;\n  dist /= 3.0;\n  float sdIntersection = max(dist, boundingBox);\n  return sdIntersection;\n}\n```", "```\nfloat sdTwentySevenCrossesBound(vec3 rayPos) {\n  const float oneThird = 1.0 / 3.0;\n  const float cubeWidth = 2.0;\n  float boundingBox = sdCube(rayPos);\n  float boxedWorldDimen = cubeWidth * oneThird;\n  float translation = -boxedWorldDimen / 2.0;\n  vec3 ray = rayPos - translation;\n  vec3 repeatedPos = mod(ray, boxedWorldDimen);\n  repeatedPos += translation;\n  repeatedPos *= 3.0;\n  float dist = sdCross(repeatedPos / oneThird) * oneThird;\n  dist /= 3.0;\n  float sdIntersection = max(dist, boundingBox);\n  return sdIntersection;\n}\n```", "```\nfloat sdMengerSpongeIteration2(vec3 rayPos) {\n  const float cubeWidth = 2.0;\n  float menger1 = sdMengerSpongeIteration1(rayPos);\n  float boxedWorldDimen = cubeWidth / 3.0;\n  float translation = -boxedWorldDimen / 2.0;\n  vec3 ray = rayPos - translation;\n  vec3 repeatedPos = mod(ray, boxedWorldDimen);\n  repeatedPos += translation;\n  repeatedPos *= 3.0;\n  float crossesDist = sdCross(repeatedPos * 3.0) / 3.0;\n  crossesDist /= 3.0;\n  float sdSubtraction = max(menger1, -crossesDist);\n  return sdSubtraction;\n}\n```", "```\nfloat sdOneCrossOvercomplicatedBound(vec3 rayPos) {\n  const float oneThird = 1.0 / 3.0;\n  const float cubeWidth = 2.0;\n  float boundingBox = sdCube(rayPos);\n\n  // boxed world as big as the box\n  // division by 1 for illustrative purposes\n  float boxedWorldDimen = cubeWidth / 1.0;\n\n  // Translate origin of bounded space to align with origin of space\n  float translation = -boxedWorldDimen / 2.0;\n  vec3 ray = rayPos - translation;\n\n  // Create infinite boxes the same width of our sponge\n  vec3 repeatedPos = mod(ray, boxedWorldDimen);\n\n  // Adjust our coordinate system in the boxed world\n  // to have a range of [-boxedWorldDimen/2.0, boxedWorldDimen/2.0)\n  // placing the origin in the center\n  repeatedPos += translation;\n\n  // Stretch space to [-1.0, 1.0)\n  // [Illustrative purposes, No stretching is needed]\n  repeatedPos *= 1.0; \n\n  float crossDist = sdCross(repeatedPos / oneThird) * oneThird;\n\n  // Acquire actual distance with correction to prev stretch\n  // [Illustrative purposes, No correction is needed]\n  crossDist /= 1.0;\n\n  float sdIntersection = max(boundingBox, crossDist);\n  return sdIntersection;\n}\n```", "```\nfloat sdMengerSpongeFirstIterationOvercomplicated(vec3 rayPos) {\n  float crossDist = sdOneCrossOvercomplicatedUnbound(rayPos);\n  float spongeBox = sdBox(rayPos, vec3(halfBoxDimen));\n  float sdSubtraction = max(spongeBox, -crossDist);\n  return sdSubtraction;\n}\n```", "```\n// extra argument for number of iterations\nfloat sdMengerSponge(vec3 rayPos, int numIterations) {\n  const float cubeWidth = 2.0;\n  const float oneThird = 1.0 / 3.0;\n  float spongeCube = sdCube(rayPos);\n  float mengerSpongeDist = spongeCube;\n\n  float scale = 1.0;\n  for(int i = 0; i < numIterations; ++i) {\n    // #1 determine repeated box width\n    float boxedWidth = cubeWidth / scale;\n\n    float translation = -boxedWidth / 2.0;\n    vec3 ray = rayPos - translation;\n    vec3 repeatedPos = mod(ray, boxedWidth);\n    repeatedPos += translation;\n\n    // #2 scale coordinate systems from \n    // [-1/scale, 1/scale) -> to [-1.0, 1.0)\n    repeatedPos *= scale;\n\n    float crossesDist = sdCross(repeatedPos / oneThird) * oneThird;\n\n    // #3 Acquire actual distance by un-stretching\n    crossesDist /= scale;\n\n    mengerSpongeDist = max(mengerSpongeDist, -crossesDist);\n\n    scale *= 3.0;\n  }\n  return mengerSpongeDist;\n}\n```"]