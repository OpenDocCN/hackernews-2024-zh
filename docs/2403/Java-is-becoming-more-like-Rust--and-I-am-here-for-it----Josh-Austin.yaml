- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:35:23'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Java is becoming more like Rust, and I am here for it! | Josh Austin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://joshaustin.tech/blog/java-is-becoming-rust/](https://joshaustin.tech/blog/java-is-becoming-rust/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction[#](#introduction)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As programming enhancements and sophistications gain popularity, many programming
    languages follow suit. Java is no different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust has gained developer love year-over-year despite problems within the community.
    And for good reason: Rust enables developers to avoid entire categories of problems
    thanks to the compiler. The compiler demands correctness to the point some developers
    begin to experience some insecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: I’d like to showcase two Rust features that are part of what makes Rust excellent,
    and then compare them with recent innovations in Java.
  prefs: []
  type: TYPE_NORMAL
- en: '*Disclaimer: In no way am I claiming that these Rust features caused their
    counterparts to appear in Java. I would not be surprised if Kotlin and/or Scala
    were more influential in bringing this to life. But I am excited to see Rust features
    that can also be (sort of) found in Java!*'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable Data[#](#immutable-data)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Rust, data is immutable by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we want data to be mutable, it must be declared mutable explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a plain ol’ Java object (aka POJO) is often written with mutability by
    default, and rather verbosely. Here is how it looks like in Java 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, thanks to modern Java, record classes simplify this with immutability
    in mind and our code is far less verbose. The below is valid Java 21 code with
    previews enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Algebraic Data Types[#](#algebraic-data-types)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [this YouTube video](https://www.youtube.com/watch?v=z-0-bbc80JM), we see
    how Rust can leverage algebraic types to aid in making invalid state unrepresentable,
    with strong guarantees against buggy behavior. In Rust, this is done using enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Up until recently, this could not be implemented elegantly in Java. As of Java
    21 and beyond, however, you can implement this in Java elegantly using sealed
    interfaces containing records and using exhaustive switch syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: RealCat.java
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: RealCatApplication.java
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion[#](#conclusion)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are myriad (good) reasons that Java will never become Rust, but I’m glad
    to see some of Rust’s strong features making their way into Java. This will strengthen
    Java’s long-term placement as one of the programming languages of choice in the
    business world. Java has owned significant market share for the last 28 years
    and is poised to retain, if not regain significant market share over the next
    28 years because of the OpenJDK project’s dedication to developer productivity.
  prefs: []
  type: TYPE_NORMAL
