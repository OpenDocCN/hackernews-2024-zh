<!--yml

类别：未分类

日期：2024-05-29 12:32:59

-->

# 快速虚函数：通过黑客方式操作VTable获取乐趣和利润 | 作者：Caleb Leak | Medium

> 来源：[https://medium.com/@calebleak/fast-virtual-functions-hacking-the-vtable-for-fun-and-profit-25c36409c5e0](https://medium.com/@calebleak/fast-virtual-functions-hacking-the-vtable-for-fun-and-profit-25c36409c5e0)

# 快速虚函数：通过黑客方式操作VTable获取乐趣和利润

虚函数具有明显的内在价值；使用它们可以使体系结构更加灵活，并解决大量设计问题。

当涉及到虚函数（或方法，在这个上下文中术语区别并不重要）时，关于性能有两种主流观点。第一种观点认为它们很慢，一直都是，而且将来也会是。这个学派的人会告诉你，在游戏中使用它们太慢了。第二种观点是，它们曾经很慢，但现代编译器和架构已经使它们变得高效了。这个学派的人会告诉你，应该大量使用它们，即使在性能关键的代码中，因为它们基本上是免费的。

那么，真相是什么？毫不奇怪的答案是：取决于情况。取决于什么？好吧，我很高兴你问了。答案是，像大多数间接性操作一样，它主要取决于缓存以及你的应用程序如何与其交互。在本文中，我将深入探讨三件事情（重点关注C++）：

1.  **如何避免虚函数的性能损失。** 我将展示如何直接调用虚函数并避免间接调用的成本。

1.  **如何使大批量的虚函数快速执行。** 这是游戏引擎中的常见问题，其中一个场景可能有数千个对象，每个对象都有几个不一定是唯一的更新函数。如果这些更新按帧率发生，那么每秒将会有数以十万计的调用。

1.  **如何检测虚函数是否已被覆盖。** 这是现代游戏引擎中的另一个常见问题，在那里有大量要重写的函数。例如，Unity拥有64个这样的可重写方法（它们称之为*消息*），其中大多数对大多数对象来说都是空操作。当检测到这种情况时，引擎可以完全避免调用它们。

我不会讨论虚函数为何有用。

## 理解虚函数和VTables

在深入探讨虚函数性能之前，我想花点时间看看虚函数是如何工作的。如果你是虚函数大师，请随意跳过本节。

让我们从创建一个没有虚函数的类层次结构开始。我们将创建简单地通过给定名称向人们问候的问候者：

其输出如下：

```
Hello Bob! It's a pleasure to meet you!
Hi Alice.
```

可怜的爱丽丝并没有得到合适的问候。请注意，我们如何在相同对象上调用相同函数（至少是同名函数），但根据我们如何进行强制转换而得到不同的结果。这是为什么？

编译器对数据的来源没有特殊知识。对于它来说，从`FriendlyGreeter`构造的`GenericGreeter*`和从`GenericGreeter`构造的是相同的，因此它只是调用基础函数。

现在让我们用虚函数做同样的事情：

现在输出是：

```
Hello Bob! It's a pleasure to meet you!
Hello Alice! It's a pleasure to meet you!
```

派生函数现在被称为——编译器不知道如何做到这一点。它仍然只是一个具有`GenericGreeter`指针的对象，没有特殊知识来构造数据，但是现在这个指针背后有更多的东西。

现在`GenericGreeter`内部隐藏着一个指向虚函数表或*VTable*的指针。这个表只是一小段静态内存，里面有一个或多个函数指针。这段内存是静态的（因此被指向而不是包含），因为特定类的每个实例都会有完全相同的VTable — 所以它被存储在可以共享的地方。

我认为最好用一个例子来说明。这里是我们相同的一组问候者，但这次我们将创建我们自己的VTables：

再次，输出是：

```
Hello Bob! It's a pleasure to meet you!
Hello Alice! It's a pleasure to meet you!
```

这就是VTables和虚函数的基础。在更深的层次结构和多重继承中，可能会有多个VTable，但它们都遵循这个模式。

## 探索VTable

我们在上一节中看到了VTables的工作原理，但我们实际上没有直接访问任何VTable。在这里，我们将介绍如何定位和利用VTable。

让我们首先扩展上一节的示例，以包含多个虚函数：

现在让我们来定义VTable的样子。请注意，我们不是自己实现它，而只是创建一个方便的结构体来理解它：

现在我们已经准备好操作VTable了——但它在哪里？嗯，它就藏在明处。任何声明新虚函数的类，而不仅仅是覆盖现有虚函数的类，都会在其成员变量旁边隐式添加一个指向VTable的指针。按照惯例，VTable指针在类的所有其他成员变量之前 — 这是MSVC、gcc和Clang遵循的稳定惯例。这使得它们非常容易找到。继续我们的例子，一个查找VTable指针的函数就像这样简单：

值得注意的是，在这种情况下，使用`void*`代替`GenericGreeter*`也可以，但不够健壮。VTable指针是层次结构中使VTable的类的成员，就像上一节的示例一样。因此，它们遵循多重继承和`class WeirdGreeter : public Weird, public GenericGreeter {…}`的所有典型规则，包括VTable指针在`Weird`的所有成员*之前*，而不是在`GenericGreeter`的成员之前，包括VTable指针。当然，像上面的函数一样转换为基础类型是绕过此问题的健壮方法。

最后，让我们把所有的部分放在一起，直接调用虚函数，绕过分派：

这个输出是：

```
Hello Bob! It's a pleasure to meet you!
Farewell Bob! Until later!
Hello Alice! It's a pleasure to meet you!
Farewell Alice! Until later!
```

只调用了重写的函数！

## 虚函数何时慢以及它们有多慢？

我们已经看到了如何直接调用虚函数，现在让我们看看为什么你可能想要这样做。

当你因为缓存未命中而查找虚函数时，虚函数是很慢的。正如我们将在基准测试中看到的那样，它们可能非常*慢*。当小心使用时，它们也可以非常快速，甚至快到无法测量开销的程度。

让我们设置一些测试，亲自看看。我们将测试几个方面：

1.  **允许缓存的重复调用非虚成员函数。** 这将为我们提供一个良好的性能基准。

1.  **允许缓存的重复调用虚成员函数。** 这将展示虚函数的最佳（尽管不太可能的）情况。同一个虚函数在紧密循环中被重复调用，因此我们期望 VTable 指针、VTable 和函数代码本身都保持在缓存中。

1.  **不允许缓存的重复调用非虚成员函数。** 我们将显式刷新缓存以达到另一个性能基准。这将是我们非缓存虚函数的目标性能。

1.  **重复调用虚成员函数而不进行缓存。** 这是虚函数性能的最坏情况。VTable 指针、VTable 和函数代码都不会在缓存中。

1.  **直接重复调用虚成员函数而不进行缓存。** 这里的希望是，我们将通过虚函数恢复一些性能损失，并接近非虚函数的性能。

为了测试这一点，我们将使用一个增量器的小层次结构。每个增量器将通过增量函数将其值（随机初始化的 int）重复添加到全局变量中。通过从成员变量添加来确保对象加载到内存中，所以我们公平地进行比较，而由于是随机数，将防止编译器优化掉成员变量。

我们现在已经准备好运行一些测试，看看虚函数有多慢。为了做到这一点，我们将创建每种类型的许多对象，并重复调用它们的增量函数。以下是结果，包括对象数量（或调用次数，因为每个对象的函数只调用一次）与运行时间（秒）：

令人惊讶的是，直接调用虚函数是最快的方法，尽管它仅略胜非虚函数。如果没有直接调用，并且这些函数没有被缓存，虚调用的开销将是非虚调用的3倍。请记住，我们只比较了开销。对于运行时间很长的函数来说，开销成本将是无关紧要的。

## 避免虚函数的性能损失

正如在前面的部分中所见，虚函数调用可能非常慢。为了保证速度，我们将希望直接调用虚函数。

要直接调用虚函数，我们将访问 VTable 并直接获取我们想要调用的函数的指针。“但等等”，你说，“那不会产生与常规虚函数调用相同的惩罚吗？”是的，确实会。这里的关键是我们可以重用这个函数指针，无论是在将来与相同实例调用它，还是（如下一节所述）在同一类的其他实例上调用它。

要获取函数指针，我们可以首先定义一个通用函数来获取 VTable：

然后只需将适当的条目强制转换为所需的函数指针即可：

在上述情况下，它只是调用第 1 个槽中的虚函数。当一个函数被重复调用时，无论是作为批处理还是单独调用，这种技术真正变得有用。

## 高效运行虚函数批处理

在游戏和其他交互应用程序中，一次运行多个虚函数批处理是很常见的。例如，每帧从各种场景对象中运行数千个 `Update()` 函数。我们可以从前面的章节中借用一些工具，以高效完成这项任务。

我们可以利用的关键洞见是，函数调用时的缓存未命中会降低性能。那么如何最小化缓存未命中呢？我们可以分组我们的函数调用以保持代码在缓存中！

使用 `std::set` 来分组虚函数是一种简单的方法，它维护一个有序的值集合。通过对 {函数指针，对象指针} 对进行排序，可以轻松地迭代整个集合以按排序顺序调用所有函数。这尤其方便，因为任何场景管理器都需要此列表。

下面是一个完整的示例。它以 `SceneObject` 作为基类，包含可重写的 `Update()` 函数。`SceneManager` 拥有这些对象，并允许所有更新函数作为单个批处理调用，分组更新函数。

有了这样一个框架，要真正高效地执行还需要迈出一步：不要调用空函数。

## 检测虚函数何时被重写

在前面的示例中，我们将 `Update()` 函数分批，并以效率的方式分组重复调用同一个函数（但使用不同的对象）。如果 `SceneObject` 的每个子类都需要一个更新函数，这种方法很有效。但如果某些类不需要呢？如果我们有大量可重写的函数，如 `LateUpdate`、`PhysicsUpdate` 和 `DrawImmediate`，而大多数对象都不需要重写它们，调用空函数将是浪费周期。这时就需要检查重写。

要检查一个函数是否被重写，你只需比较每个 VTable 中的函数条目。这里的一个注意点是，你需要一个基本对象的实例（适合空对象模式）来进行比较。

让我们用刚刚提到的新函数更新前面章节中的示例：

现在我们可以更新场景管理器，以便仅在对象覆盖了适当的函数时才将其添加到每个批处理中。

就是这么简单！当然，你可能希望开始将这些内容封装在更好的类中。你也可以使用一些宏魔术来确保你的VTable结构始终与类中实际定义的内容匹配。

## 结论

希望你已经看到了玩弄VTable的有用性，而且也发现这并不难。我鼓励你亲自尝试一下。最终结果将是一个更快的程序和更快乐的开发者。能够像这样编写代码真是一件非常令人满足的事情：

而且不必担心不必要的开销或者注册函数。

所有示例和测试的完整源代码位于[GitHub](https://github.com/cleak/VirtualFunctionPerf)上。祝编程愉快！
