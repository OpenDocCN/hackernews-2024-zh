["```\n// You start with a Resolver, and incrementally feed it data to be looked up type Resolver interface {  // Collect collects some piece of data and maybe extra information about it that you // need to do resolution Collect(someId string, someData string) // Maybe you also need some global contextual data to do the resolve AddContextualData(data SomeContext) // When you're done, the resolve can send the bulk query to the executor to perform // the lookup that you want to do Execute(context.Context, Executor) (Resolved, error) }   // Resolved is what you get back after you Execute, and it lets you access the resolved data type Resolved interface {  // Resolve returns the result. If the result doesn't have that id, either because it // wasn't looked up successfully during execution or because you never [Collect]ed it, // it will return (\"\", false) Resolve(id string) (string, bool) }   // Executor is capable of doing the db lookup/cache lookup/service request/http request // that actually gets the data you need to get type Executor interface {  DoTheThing( ctx context.Context, idsToResolve map[string][]string, contextualData SomeContext, ) ([]ResolveResult, error) } \n```", "```\ntype idResolver struct {  collected map[string][]string  contextData SomeContext  resolved map[string]string }   func (r *idResolver) Collect(someId string, someCategory string) {  r.collected[someCategory] = append(r.collected[someCategory], someId) }   func (r *idResolver) AddContextualData(data SomeContext) {  r.contextData = data }   func (r *idResolver) Execute(ctx context.Context, executor Executor) (Resolved, error) {  result, err := executor.DoTheThing(ctx, r.collected, r.contextData)  if err != nil {  return nil, err  }    r.resolved = transformResult(result)    /***  * ðŸª„ THE MAGIC ðŸª„  * Ooh look I'm just returning this struct as a Resolved!  */  return r, nil }   func (r *idResolver) Resolve(id string) (string, bool) {  res, ok := r.resolved[id]  return res, ok } \n```", "```\nfunc (r *StatefulIdResolver) Collect(someId string, someCategory string) {  if r.hasExecuted { panic(\"Collect called after Execute\") }  r.collected[someCategory] = append(r.collected[someCategory], someId) }   // Execute executes and changes state but doesn't return anything new func (r *StatefulIdResolver) Execute(ctx context.Context, executor Executor) error {  if r.hasExecuted { panic(\"Execute called twice\") } ... r.hasExecuted = true ... }   func (r *StatefulIdResolver) Resolve(id string) (string, bool) {  if !r.hasExecuted { panic(\"Resolve called before execute\") }  res, ok := r.resolved[id]  return res, ok } \n```"]