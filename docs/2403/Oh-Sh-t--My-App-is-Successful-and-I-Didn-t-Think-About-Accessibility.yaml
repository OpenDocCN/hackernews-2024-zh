- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:04:52'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Oh Sh*t, My App is Successful and I Didn’t Think About Accessibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://jacobbartlett.substack.com/p/oh-sht-my-app-is-successful-and-i](https://jacobbartlett.substack.com/p/oh-sht-my-app-is-successful-and-i)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you have a genius app idea, a brand-new job, or a fresh injection of venture
    capital, the temptation to tunnel-vision on shipping new features can be overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: If you play your cards right, this focus pays off, rocketing your app to the
    top of the download charts. *Not good enough.*You won’t stop until *everybody*
    is using your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon achieving this absurd milestone, you realise a hard truth: 1 in 6 users
    think your app is broken.'
  prefs: []
  type: TYPE_NORMAL
- en: Then it hits you.
  prefs: []
  type: TYPE_NORMAL
- en: Oh shit.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: My app is successful and I didn’t think about accessibility.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 16% of people have some kind of accessibility (*a11y* if you’re one of the cool
    kids) requirement. But when you’re flying by the seat of your pants, it’s easy
    to let a11y fall by the wayside — particularly when surrounded by deadlines, with
    limited buy-in from leadership.
  prefs: []
  type: TYPE_NORMAL
- en: The more successful you become, the worse you’re perceived for failing to acknowledge
    the a11y needs of your users. This is, unfortunately, hard to prioritise without
    somebody influential championing a11y.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, I’m going to help. I’ll demonstrate how you can get your app up to speed
    with accessibility, and **fast**:'
  prefs: []
  type: TYPE_NORMAL
- en: Audit a11y in your SwiftUI app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the app looking good at all text scales.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the app useable for screen-readers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convince stakeholders to prioritise a11y.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re going to look at a [dead simple, cat-themed, companion app](https://github.com/jacobsapps/oh-shit-a11y)
    I created especially for this article. An app which looks fine on the surface
    but, as soon as you start evaluating it from an a11y perspective, is *utterly
    broken*.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to fully understand the techniques, **code along too!** Start from
    the `Before/` folder as we implement all the techniques detailed in this article
    (look at `After/` for the final, improved, app).
  prefs: []
  type: TYPE_NORMAL
- en: To get a proper feel for a11y, you should always test accessibility on a real
    device, as this is how all your users interact with your app.
  prefs: []
  type: TYPE_NORMAL
- en: With any work on a11y, you should first optimise Control Center. *Seriously*,
    this is a massive timesaver.
  prefs: []
  type: TYPE_NORMAL
- en: Go to iPhone Settings → Control Center. Add the Text Size control and Accessibility
    Shortcuts. Text Size allows you to swipe down from anywhere in any app, and immediately
    select a text scaling to apply — you can even apply sizings on a per-app basis.
  prefs: []
  type: TYPE_NORMAL
- en: Modify Control Centre to include text sizing
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility shortcuts allow you to apply various a11y features on-the-fly,
    such as AssistiveTouch, VoiceOver, Colour Filters, and Reducing Motion. This is,
    however, probably easier to access by **triple-pressing the lock button**, which
    presents the same menu as an action sheet.
  prefs: []
  type: TYPE_NORMAL
- en: There are 12 possible text sizes in iOS, from `extraSmall` to `accessibilityExtraExtraExtraLarge`
    (aka `AX5`), which is approximately 310%* larger than the default (`large`).
  prefs: []
  type: TYPE_NORMAL
- en: '*this is the scaling of `body` font, however different system text sizes scale
    by different amounts, for example a `largeTitle` is already quite big, so will
    not scale up as much as a `caption`, which is tiny.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This will be important later on!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To make sure text sizes work, I like to run two audits:'
  prefs: []
  type: TYPE_NORMAL
- en: Test the app on the largest non-a11y font, `extraExtraExtraLarge` (aka `xxxl`),
    ideally with the *Bold Text*accessibility setting enabled too. This is the biggest
    relatively common font, and also what my mum uses. The app should look *good*
    at this size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the app on the largest a11y font, `AX5`. While, if you’re not used to it,
    it might look comically large, there are people for whom this is *the only way*
    they can interact with your app. While it’s tough to make the UI look perfect
    at this size, it’s blindingly obvious when a company hasn’t even checked if the
    app works at accessibility text scalings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s run through our app.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing my login screen with large (default), xxxLarge (and bold), and AX5
    text scalings
  prefs: []
  type: TYPE_NORMAL
- en: Immediately, we find that our painstakingly crafted login UI falls flat on its
    face when we apply text scaling. We were sloppy, and we didn’t anticipate larger
    text sizes — so never thought to make the content scrollable.
  prefs: []
  type: TYPE_NORMAL
- en: What’s more? Somebody with colourblindness would not be able to read that login
    button, since the contrast is miniscule.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also check out look at the main list screen of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing my list screen with large (default), xxxLarge (and bold), and AX5 text scalings
  prefs: []
  type: TYPE_NORMAL
- en: This one is less ‘broken’, in that you can see everything, but it’s clear to
    anybody using an accessibility-sized font that you didn’t bother testing the app
    at this size — just look at the text labels warring for space, or that tiny ❤
    icon next to a massive caption.
  prefs: []
  type: TYPE_NORMAL
- en: Some of our users are unaffected by text scaling — since they may require a
    screenreader to interact with your app.
  prefs: []
  type: TYPE_NORMAL
- en: iOS VoiceOver does an incredible job handling the heavy lifting here, so a little
    bit of thoughtfulness from your team goes a long way.
  prefs: []
  type: TYPE_NORMAL
- en: Screenreader audits, like text size audits, are also best done on a real device
    (press the lock button 3 times, remember!). There is also a developer tool built
    into Xcode which helps with VoiceOver— the Accessibility Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Accessibility Inspector developer tool in Xcode
  prefs: []
  type: TYPE_NORMAL
- en: Walking through the app, it’s less offensively broken compared to the text scaling,
    but large areas of the UI like our images are entirely invisible to our users
    because we didn’t bother to add accessibility labels.
  prefs: []
  type: TYPE_NORMAL
- en: I’m intentionally using hostile language here, because this is how your app
    is going to be perceived by users you left behind. Hostile.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Screen-reading the login screen tries it’s best, giving the name of the image resource
  prefs: []
  type: TYPE_NORMAL
- en: It’s doubly clear when somebody hasn’t been thoughtful thought about VoiceOver
    when every single UI element is iterated through by the screen-reader, including
    unlabelled icons.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy use of a screenreader ends up listing every UI element individually
  prefs: []
  type: TYPE_NORMAL
- en: The situation gets worse with a big list.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t give SwiftUI information about your content, you can end up with
    a situation where it takes 100s of swipes to move to the logout button at the
    bottom of your scrollable content. And *don’t get me started* on paging.
  prefs: []
  type: TYPE_NORMAL
- en: With many items, it takes a very long time to get to the bottom of the content.
  prefs: []
  type: TYPE_NORMAL
- en: It’s clear we’ve got a fair few issues to solve before we can call our app accessible.
    Fortunately, SwiftUI is packed to the gills in tools that allow you to get up
    to speed on a11y extremely fast.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know where the problems are, we can start to address them one by one.
    And quickly.
  prefs: []
  type: TYPE_NORMAL
- en: This is the most offensive issue — my app onboarding is completely broken, since
    the content doesn’t expand into a scroll view on larger text sizes.
  prefs: []
  type: TYPE_NORMAL
- en: In our audit, the button for our login screen was pushed offscreen as font size
    increased. The rest of the text content strained against each other, labels overlapping
    and truncating as they had no room to expand.
  prefs: []
  type: TYPE_NORMAL
- en: The natural solution is to make the content scrollable. But we don’t want to
    haphazardly allow every single screen to scroll when the content fits fine. We
    aren’t in the business of building Ionic apps **shudders with repressed memories**.
  prefs: []
  type: TYPE_NORMAL
- en: This issue can be addressed with a custom view modifier, what I call the `a11yScrollView()`.
    The goal of this view modifier is to wrap content in a scroll view, but only if
    it *needs* to — content only becomes scrollable if it doesn’t fit. I’ve added
    it to a small library, [A11yUtils](https://github.com/jacobsapps/A11yUtils/blob/main/Sources/A11yUtils/A11yScrollView.swift),
    so you can use it in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, this only achieves our dream behaviour in iOS 16.4 and above — applying
    `scrollBounceBehavior` to the scroll view to prevent it from scrolling if the
    content fits already.
  prefs: []
  type: TYPE_NORMAL
- en: xIn the future, I’d like to make it work with `ViewThatFits*` for iOS 16 and
    `GeometryReader` for iOS 15.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Feel free to submit a pull request!](https://github.com/jacobsapps/A11yUtils/tree/main)**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since nobody is around to demand which OS version I target, I can apply this
    modifier to the `VStack` in our onboarding view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, the content scrolls nicely — looking good across `xxxl`, `AX3`, and `AX5`.
  prefs: []
  type: TYPE_NORMAL
- en: Our content now scrolls on all text scalings. For good measure, I fixed the
    contrast on the Log In button
  prefs: []
  type: TYPE_NORMAL
- en: '*In my experience, the `ViewThatFits` approach works nicely, but has problems
    with text entry — the software keyboard actually changes the size of the view,
    causing the content to resize and the layout engine to redraw the content. If
    a `@FocusState` toggles the keyboard on appearance, this leads to an infinite
    redrawing and resizing loop!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While we’re working on the onboarding screen, there’s another simple improvement
    we can make:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When text size is large, limiting screen real estate, `Spacer()` can cause issues.
    The SwiftUI layout engine will diligently attempt to create space, even if there
    is no room for it, which can lead to your text getting truncated.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, even with the spacer compressed to a very narrow height, there
    will be 20 points above and below, as defined in our `VStack`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can swap out the `Spacer()` for a `frame()` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Frames behave in a more reliable manner: SwiftUI knows to give as much space
    as possible above this button, however it is clear that the space itself isn’t
    a critical part of the UI, so no unnecessary spacing is applied if there isn’t
    room.'
  prefs: []
  type: TYPE_NORMAL
- en: This frame modifier has a clearer *semantic* meaning — that is, it makes our
    intent clear to SwiftUI. This is a critical concept to understand when it comes
    to a11y, so we’ll cover it more later on.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to dynamic type, iOS will scale the font in our app automatically based
    on the user’s chosen font size. This is also pretty straightforward to implement
    with a [custom font](https://developer.apple.com/documentation/uikit/text_display_and_fonts/adding_a_custom_font_to_your_app).
  prefs: []
  type: TYPE_NORMAL
- en: This means when we use semantic font sizes in SwiftUI, text will automatically
    scale.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even better, when sticking to SFSymbols, we can get dynamic type on our icons!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, most iOS apps tend to have an Android counterpart, which means
    your designer will be creating custom icons rather than allowing you to use SFSymbols
    everywhere. Most apps will also include custom images and media.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, for our `Before/` example, I’ve treated the icon like any regular
    image we’d add to SwiftUI, using a hardcoded size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The result? At the largest font scaling, the content looks very mismatched.
  prefs: []
  type: TYPE_NORMAL
- en: Images and icons with a fixed size look strange on larger text scalings
  prefs: []
  type: TYPE_NORMAL
- en: 'SwiftUI has a nifty tool that gives us the power of dynamic type in our custom
    images and views: the `@ScaledMetric`property wrapper.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can use `@ScaledMetric` on its own, which uses the default `body` font scaling.
    It’s even better to use `relativeTo` so SwiftUI knows how to scale it.
  prefs: []
  type: TYPE_NORMAL
- en: '`largeTitle` scales a little bit, since it’s already quite large. A `caption`
    style font scales up far more. In this instance, the icon has `body` scaling so
    it matches the accompanying quote text.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, our images look a lot more sensible alongside the text.
  prefs: []
  type: TYPE_NORMAL
- en: Image scaling using @ScaledMetric
  prefs: []
  type: TYPE_NORMAL
- en: The images scale better, however our UI is still clearly broken, with the text
    labels vying for space. After exhaustive negotiations with the layout engine,
    they end up full of line breaks.
  prefs: []
  type: TYPE_NORMAL
- en: '**What if we could align content based on a user’s text scaling?**'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, thanks to my library [A11yUtils](https://github.com/jacobsapps/A11yUtils/blob/main/Sources/A11yUtils/A11yHStack.swift),
    we can utilise an `A11yHStack`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the blistering pace of new SwiftUI tool releases (and Apple’s crappy
    back-porting), this also has a couple of different implementations based on your
    minimum supported OS:'
  prefs: []
  type: TYPE_NORMAL
- en: On `iOS 16`, it uses `ViewThatFits` to check whether the `HStack` can contain
    all the content, and if not, uses a `VStack`to arrange the content instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On `iOS 15`, it applies a more blunt approach, checking `@Environment(\.sizeCategory)`,
    and switching to a `VStack` if an accessibility text size category (such as `AX1`,
    `AX2`, or `AX5`) is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the simple approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `@Environment(\.sizeCategory)` is a useful tool to know about, in the cases
    where it’s important to know whether an a11y text size category is being used
    (with `isAccessibilityCategory`). Sometimes, I use this property to remove unnecessary
    UI elements such as images which simply don’t fit at massive content sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more modern implementation works similarly but utilises `ViewThatFits`,
    so content is only re-distributed if it doesn’t fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we’re thoughtful, we can apply `A11yHStack` in a few places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now our content looks much more sensible on very large text sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Utilising A11yHStack for our content in the List cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another small warning: make sure you test on all supported iOS versions, as
    I’ve found the `ViewThatFits`approach to give behaviour I wasn’t expecting. When
    getting started, you may have an easier time re-implementing the `@Environment(\.sizeCategory)`
    approach.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: VoiceOver is a reasonably straightforward piece of the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making your app play well with a screenreader means:'
  prefs: []
  type: TYPE_NORMAL
- en: Making sure visual content is adequately described.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making navigation work intuitively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring our view makes *semantic* sense.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with visual descriptions. This is the simplest fix in our repertoire:
    ensuring our graphical content can be described by VoiceOver. The `accessibilityLabel`
    modifier is our bread and butter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This tells the screenreader how to explain what it’s currently focused on.
  prefs: []
  type: TYPE_NORMAL
- en: Applying an accessibilityLabel to the onboarding image
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can apply the same approach on our main view’s cells. With a small
    modification to our `Cat` data model, we supply an image description alongside
    each cat’s photo.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is as easy as it sounds, and tends to *just work* on Apple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Applying voiceover descriptions to all our images via the data model
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to navigation through our app, we have the opportunity to be more
    thoughtful. By default, VoiceOver will iterate through every leaf node in the
    SwiftUI view tree and read out all our `Image`s, `Button`s, and `Text`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, this causes lots of unnecessary navigation for the user. In our app,
    we force users to tap multiple times to navigate past the icon and quote for each
    cat. Reading out the icon’s name (such as `cat.fill`) adds nothing to the experience.
  prefs: []
  type: TYPE_NORMAL
- en: We can combine these together as a single a11y element using the `accessibilityElement(children:)`
    modifier, so the screenreader can treat them as one item when navigating through.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can hear the screenreader move through the elements as one item:'
  prefs: []
  type: TYPE_NORMAL
- en: Combining VoiceOver UI elements together using accessibilityElement(children:)
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, you might have a really complicated UI, such as a [stylised
    timer element which graphically ticks down](https://jacobbartlett.substack.com/i/141732200/image-loading-bug).
    VoiceOver is smart, but it isn’t going infer anything useful from a fancy collection
    of unexplained views.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `accessibilityRepresentation` modifier comes in really useful.
    It allows you to replace a view’s VoiceOver UI with a fully customised a11y representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was particularly useful for my latest indie project, [Check ’em](https://jacobbartlett.substack.com/p/building-a-2fa-app-that-detects-patterns),
    where a user’s 2FA codes were displayed with a countdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This modifier allowed me to introduce a fully custom VoiceOver interface, which
    was far more useful than iterating through each element of the cell in sequence.
    It also prevented the screenreader reading 676,252 as *six hundred and seventy-six
    thousand, two hundred and fifty-two.*
  prefs: []
  type: TYPE_NORMAL
- en: accessibilityRepresentation modifier used in Check ’em, my indie project
  prefs: []
  type: TYPE_NORMAL
- en: 'The main view of this app uses a common, but sloppy, approach to laying out
    our content: wrapping our cells inside a `ForEach`, wrapped in a `LazyVStack`,
    wrapped in a `ScrollView`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The optimal approach is to **utilise native SwiftUI components wherever possible**.
    In this instance, a `List` is most appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Apple makes this a smidgen harder than it needs to be — inexplicably, to use
    our own custom UI rather than the iOS-Settings-styled `List`, we need to add 3
    separate modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With that boilerplate out of the way, the modifiers now allow us to freely use
    our own UI in a SwiftUI `List`.
  prefs: []
  type: TYPE_NORMAL
- en: Default List (left) and our custom List (right) that used .listStyle and .listRow
    modifiers
  prefs: []
  type: TYPE_NORMAL
- en: One question.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why go to all this extra trouble to use a native component? **'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, the non-a11y reason: SwiftUI `List` is implemented using a `UICollectionView`.
    This utilises cell reuse for high performance scrolling, even if you have many
    items. Conversely, `LazyVStack` keeps all previously-rendered cells in memory,
    meaning your performance nosedives if you’re scrolling through many items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This information comes courtesy of [Thomas Ricouard](https://medium.com/u/b067c9115d59)
    and friends; read [SwiftUI: The difference between List and LazyVStack](https://dimillian.medium.com/swiftui-the-difference-between-list-and-lazyvstack-3d5eeaccb156)
    to learn more!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you’d like to see more content on app performance, check out my recent deep-dive,
    [High Performance Swift Apps](https://jacobbartlett.substack.com/p/high-performance-swift-apps).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The a11y-related reason to use native components are simple, yet myriad:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apple has, collectively, put more thought into making a11y work more than
    you ever will.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`List` has a *semantic meaning*: it tells the screenreader that it’s a container
    that houses a collection of similar content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why, when we have many list items, the naïve implementation was so
    broken: instead of allowing us to skip past the `List` container with VoiceOver,
    we had to swipe through every item in order to reach the *Log Out* button.'
  prefs: []
  type: TYPE_NORMAL
- en: With `List`, SwiftUI can inform the screenreader that its content is a single
    Container, making it trivial for the screenreader to navigate past.
  prefs: []
  type: TYPE_NORMAL
- en: When using VoiceOver, you can skip past the List by setting the navigation increment
    to “containers” and swiping forwards through the content
  prefs: []
  type: TYPE_NORMAL
- en: There are also many built-in interaction modes with a `List`, such as swipe-to-delete,
    drag-and-drop, and keyboard-based navigation. These will *just work* when using
    the native components. Have you any clue how you’d get a screenreader to work
    with your janky custom implementation?
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the above passage the next time you need to push back on your designer’s
    latest stroke of genius.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`List` isn’t even the most complicated component. How would you implement a11y
    for a custom `Grid`, or a custom distribution of views that wasn’t using the `Layout`
    protocol?'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how to speedrun a11y in your SwiftUI app, before getting
    to work, the final piece of the puzzle is getting buy-in from the rest of your
    business. This is where you can flex your soft skill of *wielding organisational
    influence*.
  prefs: []
  type: TYPE_NORMAL
- en: One big, blunt tool you can wield is the hammer of legislation. Various countries
    around the world such as the [UK](https://www.legislation.gov.uk/uksi/2018/852/contents/made),
    the [USA](https://www.section508.gov/manage/laws-and-policies/), and the [EU](https://www.levelaccess.com/compliance-overview/european-accessibility-act-eaa/),
    have implemented legislation mandating that digital services meet minimum standards
    of accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, there are serious business benefits to a11y. 16% of the world population
    currently experience significant disability, meaning you could be missing out
    on users, positive reviews, and revenue by catering to a wider range of needs.
    Depending on your target demographics, this may be more or less critical.
  prefs: []
  type: TYPE_NORMAL
- en: On a smaller scale, I have found that banging the drum on addressing accessibility
    as product debt is far less effective than simply *demonstrating how your app
    is broken*. Taking the need for a11y out of the abstract and displaying the buggy
    sign-up flow is far more persuasive to any engineering organisation.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing is more helpful than having an influential champion in leadership who
    is bought-in to making the product accessible. Of course, all organisations are
    different, so your mileage may vary when applying this advice.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing, now that you’ve speedrun a11y and your product is
    totally accessible?
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t drop the ball!**'
  prefs: []
  type: TYPE_NORMAL
- en: Much like with technical debt, now that you’re in a good place, you can bake
    a11y into your standard development workflow. It’s quick and easy now you know
    how!
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered a lot today.
  prefs: []
  type: TYPE_NORMAL
- en: First we went through the process of auditing your app for common accessibility
    mistakes that show up when using large text scalings or VoiceOver.
  prefs: []
  type: TYPE_NORMAL
- en: We looked into fixing the problems that arise when using text scalings, applying
    scrolling with our `a11yScrollView`, content scaling with `@ScaledMetric`, and
    alignment with `A11yHStack`.
  prefs: []
  type: TYPE_NORMAL
- en: To make our app work well on a screenreader, we implemented `accessibilityLabel`s,
    combined `accessibilityElement`s, and even fully-customised `accessibilityRepresentation`s.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the reasons to stick to native SwiftUI components over custom views,
    such as semantics, interaction modes, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we went over how you might apply soft skills to get buy-in from your
    organisation to take accessibility seriously.
  prefs: []
  type: TYPE_NORMAL
- en: If you are serious about a11y in your SwiftUI apps, I implore you to work through
    the [companion app](https://github.com/jacobsapps/oh-shit-a11y) and implement
    these techniques yourself, it’s really the best way to internalise the tools.
    If you have a side project you’ve been working on, that’s also a great place to
    start.
  prefs: []
  type: TYPE_NORMAL
- en: I am gladly accepting contributions (and issues) to my [A11yUtils](https://github.com/jacobsapps/A11yUtils/blob/main/Sources/A11yUtils/A11yHStack.swift)
    library — I’d love to work with the community to transform this into a comprehensive
    suite of a11y tools to supplement the APIs already in SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
