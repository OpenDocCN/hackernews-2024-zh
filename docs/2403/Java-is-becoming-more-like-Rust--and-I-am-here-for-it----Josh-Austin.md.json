["```\nstruct User {  // struct members are immutable name: &'static str, age:  i32 }   fn main() {  // user and members are immutable let user = User { name: \"Bob\", age: 42 }; } \n```", "```\nfn main() {  let mut user = User { name: \"Bob\", age: 42 }; user.name = \"Jim\"; } \n```", "```\npublic class User {  private String name; private int age;  public User(String name, int age) { this.name = name; this.age = age; }  public String getName() { return this.name; }  public int getAge() { return this.age; }  public void setName(String name) { this.name = name; }  public void setAge(int age) { this.age = age; }  public static void main(String[] args) { User user = new User(\"Bob\", 42); user.setName(\"Jim\"); System.out.println(user.getName()); }  // not to mention equals(), toString() and friends! } \n```", "```\nrecord User(String name, int age) {}   void main() {  final var user = new User(\"Bob\", 42); } \n```", "```\nenum RealCat {  Alive { is_hungry: bool }, Dead }   fn main() {  let real_cat: RealCat = RealCat::Alive { is_hungry: true }; match real_cat { RealCat::Alive { is_hungry } => { if is_hungry { println!(\"The cat demands a sacrifice.\"); } else { println!(\"The cat is bored.\"); } }, RealCat::Dead => println!(\"Oh no!!!\") } } \n```", "```\npublic sealed interface RealCat permits RealCat.Alive, RealCat.Dead {   record Alive(boolean isHungry) implements RealCat {} record Dead() implements RealCat {}   static void check(RealCat realCat) { switch (realCat) { case Alive aliveCat -> { if (aliveCat.isHungry()) { System.out.println(\"The cat demands a sacrifice.\"); } else { System.out.println(\"The cat is bored.\"); } } case Dead _ -> System.out.println(\"Oh no!!!\"); } } } \n```", "```\nvoid main() {  final var hungryCat = new RealCat.Alive(true); RealCat.check(hungryCat); } \n```"]