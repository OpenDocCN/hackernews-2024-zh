- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-28 18:07:29'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: James' Coffee Blog
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://jamesg.blog/2024/02/28/programming-projects/](https://jamesg.blog/2024/02/28/programming-projects/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: My knowledge of programming has been largely self-directed. When I get excited
    about an idea, I research what I need to do to solve that problem. For example,
    when I was interested in how search engines work, I learned about the computational
    efficiency of sets. I discovered the problem "how can I check if I have crawled
    this URL?" when I may have crawled thousands of URLs. To answer this question
    faster, I used a set, which has O(1) lookup time, instead of O(n) lookup time.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Learning what you need to solve a problem is exciting, but following your own
    path in coding also leaves you with gaps in your knowledge. My conclusion here
    is that if you keep challenging yourself, you will fill in the gaps as you go
    (Even if it takes longer than it would have if you pursured a course. Fun is an
    important motivator for making progress; pursue what excites you.)
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: 'The moment I really started to understand computational efficiency -- and build
    an appreciation for making my programs faster -- was tackling that one problem
    for that one search engine. Since then, I sometimes ask myself: what can I do
    next? What is the next challenge? This is highly specific to where you are; some
    ideas will make sense, others will seem out of reach. Thus is learning.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: In the spirit of Austin Henley's "[challenging projects every programmer should
    try](https://austinhenley.com/blog/morechallengingprojects.html)" series, I wanted
    to offer my own list of projects that have sustained my joy of programming. Herein
    begins the list.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: Build a search crawler
  id: totrans-split-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A crawler is a bot that navigates web pages and saves their contents. Search
    engines use crawlers to explore the web. The contents of web pages are "indexed".
    This means that pages are saved somewhere that they can be looked up.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: I decided to build a search engine for a small community I was a part of. There
    were ~1000 sites that were known to the community, as established by people who
    contributed to our shared wiki. I used that as the list of sites to crawl. You
    can make your own list of sites and create your own search engine. Maybe you make
    a search engine for your favourite anime blogs. Or Taylor Swift fan sites. Whatever
    you want, so long as it's on the web.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: My biggest learning through this process was that the web is a wild west. You
    can never trust that someone's web page is going to be exactly how you want it
    to be. Buidling a search crawler is an exercise in learning how to retrieve as
    many web pages as possible, reliably. without taking someone's site down.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: 'In building a search crawler, you will learn about:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: How to download a web page
  id: totrans-split-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Standards for content crawling (robots.txt, adult meta tags)
  id: totrans-split-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rate limiting
  id: totrans-split-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exponential back-offs
  id: totrans-split-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Knowing when to crawl and recrawl sites
  id: totrans-split-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Content negotiation
  id: totrans-split-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Etags
  id: totrans-split-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And more
  id: totrans-split-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indeed, the web is a wild west. But with that wild west comes many exciting
    technical challenges to solve. This challenge occupied my mind for months. While
    my search engine is no longer active, this project was what gave me confidence
    that I can do more than write small Python scripts.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: Build an autocomplete system
  id: totrans-split-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you have a blog post. How could you auto-complete a word based on a
    sequence of letters? Take this blog post. If I started a word with "exponent",
    how could you, efficiently, recommend "exponential" as the last word? Herein lies
    a challenge. I am not going to talk too much about the how behind this project,
    but there is a lot of fun to be had!
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: 'When you discover how to auto-complete words, there is another challenge: how
    to recommend *which* word to auto-complete. If I type "expone", how should an
    autocomplete know whether to recommend "exponent" or "exponential" (both used
    in this guide).'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: Write a file compressor
  id: totrans-split-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many existing tools that compress files, but have you ever asked:
    how do they make files smaller?'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a challenge: download this web page as a HTML file. Write a program
    that creates a compressed version of the HTML file. Your program should then be
    able to reproduce the exact file. Spaces, captalisation: everything should be
    the same.'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some relevant topics that may guide your reading on this subject (although
    I recommend trying to write a compressor before reading too much about it if that
    excites you!):'
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: Information theory (the parent field of compression)
  id: totrans-split-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary coding (a way of representing information)
  id: totrans-split-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Huffman coding (a commonly used compression algorithm)
  id: totrans-split-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entropy (a measure of the amount of "information" in a file; "information" is
    intentionally in quotation marks)
  id: totrans-split-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement BitCask
  id: totrans-split-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[BitCask](https://riak.com/assets/bitcask-intro.pdf) is a key-value store algorithm.
    Key-value stores map keys (names) to values (pieces of information). For example,
    I could store information about posts on this blog like so:'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
- en: Where "title" and "published" are names, which are associated with values.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: 'BitCask works entirely using your file system. You store keys and values in
    files. Every file is append-only. You can delete keys, but this works by overriding
    an existing key rather than deleting the value explicitly. [BitCask is documented
    in a short, useful paper](https://riak.com/assets/bitcask-intro.pdf) that guided
    me when I was making it. Challenge yourself to implement:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: Creating a "cask" (a key-value store that follows the BitCask algorithm)
  id: totrans-split-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add items to a cask
  id: totrans-split-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve items from a cask
  id: totrans-split-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove items from a cask
  id: totrans-split-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close a cask
  id: totrans-split-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you close a cask, a merge operation is performed to merge all cask files
    into one.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: Write a programming language
  id: totrans-split-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Wow... slow down. A programming language? Only serious experts can make that!*
    That''s what I thought, too. It turns out it isn''t true! You, too, can make a
    programming language. And you don''t even need to read hundreds of pages of literature
    on theory before you get started (although the more you read, the more information
    you''ll have to design your language!).'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: Designing a programming language lets you decide how you want to write code.
    You can follow existing patterns or make up your own. You get to set the rules.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of programming language, but a good place to start is writing
    a language that doesn't need a compiler. I am biased because that's how I learned,
    but the thought of writing a compiler before I had a bit more experience with
    programming langauge theory felt daunting. Thus, I wrote an "interpreted" language.
    A file is read, parsed, then executed; no compiling.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: 'An interpreted language has a few key pieces:'
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: A "grammar", which outlines the structure of a language;
  id: totrans-split-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A "lexer" / "parser", which takes in arbitrary text (i.e. a script written in
    your language!) and turns it into an Abstract Syntax Tree (AST) using your grammar,
    and;
  id: totrans-split-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The evaluation engine, which reads the syntax tree and does something with it.
  id: totrans-split-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above three components are separate technical challenges. I recommend
    starting with writing a grammar and a parser. Your grammar will state how your
    language works (i.e. how to declare variables, which symbols are allowed and in
    which order, how things can nest, or not nest). You can use an existing lexer
    to interpret your grammer. I used Lark in Python. Your evaluation engine will
    take your syntax tree and enforce the logic of your program (i.e. maintain variables,
    perform mathematical computations, work with strings and booleans; whatever you
    want your language to do).
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: '*P.S. Writing a Lisp language is a great place to start, too!*'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: 'The list, and: What other ideas should be here?'
  id: totrans-split-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list above is not a checklist, rather inspiration for projects you can take
    on. Perhaps one of the items above will inspire you to make something. Perhaps
    none of them resonate. That is okay, too. If that's the case, I recommend saving
    this post in the back of your mind; there may come a day when one of the ideas
    above delights you. James five years ago would probably have found the list above
    out of reach. James one year ago would have yearned for this list.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: I recommend [Austin Henley's writing](https://austinhenley.com/blog/morechallengingprojects.html)
    for more wonderful ideas. His post is the reason I wrote this one.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: If you do implement anything as a result of this post, let me know! Send me
    an email at readers [at] jamesg [dot] blog. In addition, if you need any guidance
    with the ideas above, email me. I would love to help. I have completed all the
    challenges I documented above; they continue to cultivate my child-like excitement
    for coding. I hope they can do the same for you, too.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Now: what other ideas should be on this list? What have you made that you think
    would be a great challenge for other programmers? Share it with others! An idea
    for a project that pushed you to learn more about programming five years ago may
    be the thing that helps change someone''s perception of programming like search
    engines did for me.'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: '[Share this post on Hacker News](https://news.ycombinator.com/submitlink?u=https://jamesg.blog/https://jamesg.blog/2024/02/28/programming-projects/&t=(Even%20more)%20challenging%20programming%20projects%20you%20should%20try).'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: '[Share this post on Lobste.rs](https://lobste.rs/stories/new?url=https://jamesg.blog/https://jamesg.blog/2024/02/28/programming-projects/&title=(Even%20more)%20challenging%20programming%20projects%20you%20should%20try).'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
