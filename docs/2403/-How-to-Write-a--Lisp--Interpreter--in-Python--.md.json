["```\n(define r 10)\n(* pi (* r r))\n\n```", "```\n>> program = \"(begin (define r 10) (* pi (* r r)))\"\n\n>>> parse(program)\n['begin', ['define', 'r', 10], ['*', 'pi', ['*', 'r', 'r']]]\n\n>>> eval(parse(program))\n314.1592653589793\n\n```", "```\nSymbol = str              # A Scheme Symbol is implemented as a Python str\nNumber = (int, float)     # A Scheme Number is implemented as a Python int or float\nAtom   = (Symbol, Number) # A Scheme Atom is a Symbol or Number\nList   = list             # A Scheme List is implemented as a Python list\nExp    = (Atom, List)     # A Scheme expression is an Atom or List\nEnv    = dict             # A Scheme environment (defined below) \n                          # is a mapping of {variable: value}\n\n```", "```\ndef tokenize(chars: str) -> list:\n    \"Convert a string of characters into a list of tokens.\"\n    return chars.replace('(', ' ( ').replace(')', ' ) ').split()\n\n```", "```\n>>> program = \"(begin (define r 10) (* pi (* r r)))\"\n>>> tokenize(program)\n['(', 'begin', '(', 'define', 'r', '10', ')', '(', '*', 'pi', '(', '*', 'r', 'r', ')', ')', ')']\n\n```", "```\ndef parse(program: str) -> Exp:\n    \"Read a Scheme expression from a string.\"\n    return read_from_tokens(tokenize(program))\n\ndef read_from_tokens(tokens: list) -> Exp:\n    \"Read an expression from a sequence of tokens.\"\n    if len(tokens) == 0:\n        raise SyntaxError('unexpected EOF')\n    token = tokens.pop(0)\n    if token == '(':\n        L = []\n        while tokens[0] != ')':\n            L.append(read_from_tokens(tokens))\n        tokens.pop(0) # pop off ')'\n        return L\n    elif token == ')':\n        raise SyntaxError('unexpected )')\n    else:\n        return atom(token)\n\ndef atom(token: str) -> Atom:\n    \"Numbers become numbers; every other token is a symbol.\"\n    try: return int(token)\n    except ValueError:\n        try: return float(token)\n        except ValueError:\n            return Symbol(token)\n\n```", "```\n>>> program = \"(begin (define r 10) (* pi (* r r)))\"\n\n>>> parse(program)\n['begin', ['define', 'r', 10], ['*', 'pi', ['*', 'r', 'r']]]\n\n```", "```\nimport math\nimport operator as op\n\ndef standard_env() -> Env:\n    \"An environment with some Scheme standard procedures.\"\n    env = Env()\n    env.update(vars(math)) # sin, cos, sqrt, pi, ...\n    env.update({\n        '+':op.add, '-':op.sub, '*':op.mul, '/':op.truediv, \n        '>':op.gt, '=':op.ge, '<=':op.le, '=':op.eq, \n        'abs':     abs,\n        'append':  op.add,  \n        'apply':   lambda proc, args: proc(*args),\n        'begin':   lambda *x: x[-1],\n        'car':     lambda x: x[0],\n        'cdr':     lambda x: x[1:], \n        'cons':    lambda x,y: [x] + y,\n        'eq?':     op.is_, \n        'expt':    pow,\n        'equal?':  op.eq, \n        'length':  len, \n        'list':    lambda *x: List(x), \n        'list?':   lambda x: isinstance(x, List), \n        'map':     map,\n        'max':     max,\n        'min':     min,\n        'not':     op.not_,\n        'null?':   lambda x: x == [], \n        'number?': lambda x: isinstance(x, Number),  \n\t\t'print':   print,\n        'procedure?': callable,\n        'round':   round,\n        'symbol?': lambda x: isinstance(x, Symbol),\n    })\n    return env\n\nglobal_env = standard_env()\n\n```", "```\ndef eval(x: Exp, env=global_env) -> Exp:\n    \"Evaluate an expression in an environment.\"\n    if isinstance(x, Symbol):        # variable reference\n        return env[x]\n    elif isinstance(x, Number):      # constant number\n        return x                \n    elif x[0] == 'if':               # conditional\n        (_, test, conseq, alt) = x\n        exp = (conseq if eval(test, env) else alt)\n        return eval(exp, env)\n    elif x[0] == 'define':           # definition\n        (_, symbol, exp) = x\n        env[symbol] = eval(exp, env)\n    else:                            # procedure call\n        proc = eval(x[0], env)\n        args = [eval(arg, env) for arg in x[1:]]\n        return proc(*args)\n\n```", "```\n>>> eval(parse(\"(begin (define r 10) (* pi (* r r)))\"))\n314.1592653589793\n\n```", "```\ndef repl(prompt='lis.py> '):\n    \"A prompt-read-eval-print loop.\"\n    while True:\n        val = eval(parse(raw_input(prompt)))\n        if val is not None: \n            print(schemestr(val))\n\ndef schemestr(exp):\n    \"Convert a Python object back into a Scheme-readable string.\"\n    if isinstance(exp, List):\n        return '(' + ' '.join(map(schemestr, exp)) + ')' \n    else:\n        return str(exp)\n\n```", "```\n>>> repl()\nlis.py> (define r 10)\nlis.py> (* pi (* r r))\n314.159265359\nlis.py> (if (> (* 11 11) 120) (* 7 6) oops)\n42\nlis.py> (list (+ 1 1) (+ 2 2) (* 2 3) (expt 2 3))\nlis.py> \n\n```", "```\nlis.py> (define circle-area (lambda (r) (* pi (* r r)))\nlis.py> (circle-area (+ 5 5))\n314.159265359\n\n```", "```\nclass Env(dict):\n    \"An environment: a dict of {'var': val} pairs, with an outer Env.\"\n    def __init__(self, parms=(), args=(), outer=None):\n        self.update(zip(parms, args))\n        self.outer = outer\n    def find(self, var):\n        \"Find the innermost Env where var appears.\"\n        return self if (var in self) else self.outer.find(var)\n\nclass Procedure(object):\n    \"A user-defined Scheme procedure.\"\n    def __init__(self, parms, body, env):\n        self.parms, self.body, self.env = parms, body, env\n    def __call__(self, *args): \n        return eval(self.body, Env(self.parms, args, self.env))\n\nglobal_env = standard_env()\n\n```", "```\ndef eval(x, env=global_env):\n    \"Evaluate an expression in an environment.\"\n    if isinstance(x, Symbol):    # variable reference\n        return env.find(x)[x]\n    elif not isinstance(x, List):# constant \n        return x   \n    op, *args = x       \n    if op == 'quote':            # quotation\n        return args[0]\n    elif op == 'if':             # conditional\n        (test, conseq, alt) = args\n        exp = (conseq if eval(test, env) else alt)\n        return eval(exp, env)\n    elif op == 'define':         # definition\n        (symbol, exp) = args\n        env[symbol] = eval(exp, env)\n    elif op == 'set!':           # assignment\n        (symbol, exp) = args\n        env.find(symbol)[symbol] = eval(exp, env)\n    elif op == 'lambda':         # procedure\n        (parms, body) = args\n        return Procedure(parms, body, env)\n    else:                        # procedure call\n        proc = eval(op, env)\n        vals = [eval(arg, env) for arg in args]\n        return proc(*vals)\n\n```", "``` &#124;\n\n |\n\nEach rectangular box represents an environment, and the color of the box matches the color of the variables that are newly defined in the environment. In the last two lines of the program we define `account1` and call `(account1 -20.00)`; this represents the creation of a bank account with a 100 dollar opening balance, followed by a 20 dollar withdrawal. In the process of evaluating `(account1 -20.00)`, we will eval the expression highlighted in yellow. There are three variables in that expression. `amt` can be found immediately in the innermost (green) environment. But `balance` is not defined there: we have to look at the green environment's outer `env`, the blue one. And finally, the variable `+` is not found in either of those; we need to do one more outer step, to the global (red) environment. This process of looking first in inner environments and then in outer ones is called *lexical scoping*. `Env.find(var)` finds the right environment according to lexical scoping rules.\n\nLet's see what we can do now:\n\n```"]