<!--yml

分类：未分类

日期：2024-05-27 14:30:10

-->

# Laurence Tratt: 关于编写 Unix 守护程序的一些反思

> 来源：[https://tratt.net/laurie/blog/2024/some_reflections_on_writing_unix_daemons.html](https://tratt.net/laurie/blog/2024/some_reflections_on_writing_unix_daemons.html)

Unix 守护程序是在后台运行的程序，无限期地代表我们执行任务。守护程序有些神秘，容易被忽视，是我们很少有经验编写的一类程序。

在本篇文章中，我将描述我在编写和维护三个守护程序（[extsmail](/laurie/src/extsmail/)、[snare](/laurie/src/snare/) 和 [pizauth](/laurie/src/pizauth/)）15 年来所学到的一些东西。但我将从简要概述守护程序及其启动方式开始，因为这将使本文后面的部分更容易理解。

## 背景

让我们从最重要的问题开始：为什么使用术语“守护程序”，而且为什么这种奇怪的拼写？这个术语似乎可以追溯到[20世纪60年代初期](https://ei.cs.vt.edu/~history/Daemon.html)，当今天我们所熟知的“操作系统”开始形成。总体术语相当合理，基于[麦克斯韦的恶魔](https://en.wikipedia.org/wiki/Maxwell%27s_demon)，但我认为“古老世界”的伪古文拼写（即额外的“a”）是当时人们觉得有趣的结果。Unix 似乎从其早期就使用了“守护程序”的拼写[（见这里）](https://github.com/dspinellis/unix-history-repo/commit/57d94bd7265b0f4c07b74eeb409118de076baef4)。这两种拼写“demon”和“daemon”通常可以互换使用，可能因为前者更为熟悉且被人们的拼写检查器所接受。

本文将逐步介绍各种类型的守护程序，但首先让我们考虑“服务器”进程（例如 HTTP/web 或 SMTP/mail 服务器）。这些通常具有最小化的用户界面、文本文件配置和一些命令行开关。大多数在系统安装后或不久之后进行配置。关键是，这类守护程序不与“人类用户登录”绑定 —— 一旦执行守护程序，它就会自行“进入后台”，无限期地运行，即使用户注销。

随着时间的推移，守护程序在非服务器环境中变得更加普遍。Unix 桌面会启动大量的守护程序（例如用于音频复用）。尽管实现方式有所不同，其中一些最终间接地与桌面登录相关联（即注销将尝试终止它们）。我将忽略这一点，因为这并不重要，主要是为了掩盖这两类守护程序之间更为普遍的共同点。

## 启动守护程序

大多数守护程序在系统启动时运行，或者在用户启动桌面环境时运行。

因为守护进程需要在后台运行，它们必须以不同于大多数其他程序的方式启动 – 或者更准确地说，被启动。基本上，守护进程需要以某种方式“分离”于正常终端进程控制，以便它们在后台运行，并且不会在其直接父进程退出时被杀死（例如，因为用户注销或关闭终端窗口）。据我所知，有三种主要方法可以实现这一点。

最早的是“[双重fork方法](https://en.wikipedia.org/wiki/Fork_(system_call))”。第一个`fork`像平常一样创建一个新的进程；子进程调用`setsid`；然后子进程再次`fork`。孙子进程因此[无法重新附加到终端](https://0xjet.github.io/3OHA/2022/04/11/post.html)。我不确定这样做可能带来的安全收益是否值得，而且`fork`并非没有成本。

更晚些时候，1990年，[`daemon()`](https://man.openbsd.org/daemon)函数变得相当流行，尽管从未普遍。它本质上只做了一次`fork`。[第一个版本](https://github.com/dspinellis/unix-history-repo/commit/ec6328965ffe37aef2882f92004284f56088cb3a)缺少`nochdir`和`noclose`参数，这些参数是[仅在两周后添加的](https://github.com/dspinellis/unix-history-repo/commit/c6c450362dec22b151e6b669a54f8a2222d6c123)。这个函数在OpenBSD的[当前版本](https://github.com/openbsd/src/commit/b7041c0781c8668129da8084451ded41b0c43954#diff-9c2dace2b189ae391df92e2f2673d49895f3ab9aebbdcad7bf90e26aed8788e9)可以从第二个版本中辨认出来！虽然双重fork方法和`daemon()`之间有一些[轻微差异](https://www.man7.org/linux/man-pages/man3/daemon.3.html#BUGS)，但大多数人可以在不了解它们的情况下过上幸福而富有成效的生活。

较近期的，启动守护进程的一种非常不同的方法是通过某种“管理器”，其中最著名的是Linux的[systemd](https://systemd.io/)。与让进程从终端分离不同，这些管理器将守护进程运行得像是正常的（尽管是长时间运行的）程序。这在某种程度上简化了守护进程本身，并为用户提供了更加统一的体验。然而，管理器本身现在必须为比大多数人关心的情况更广泛的功能提供支持。特别地，管理器必须在引导过程中早期运行，并且对于那些一个守护进程*必须*在另一个之前运行的情况，必须有某种守护进程依赖的概念。我不是Linux专家，但我甚至意识到systemd引发了强烈的正面和负面意见，尽管我对此事无经验，也没有意见。

最终，无论守护进程如何被启动，所有守护进程共享的共同点是它们都是长期运行的后台任务。

## 我的经历

我目前已经编写并且仍在维护三个Unix守护进程（按时间顺序）：

1.  [extsmail](/laurie/src/extsmail/)，用于通过外部命令发送电子邮件。

1.  [snare](/laurie/src/snare/)，一个GitHub Webhooks运行程序。

1.  [pizauth](/laurie/src/pizauth/)，用于访问OAuth2令牌。

除了涵盖3个不同的问题领域和用例外，这3个守护进程还涵盖了时间：我从2008年开始使用extsmail，2019年启动snare，2022年启动pizauth。它们使用了2种语言：extsmail使用C语言；snare和pizauth使用Rust语言。随着时间的推移，我对守护进程的理解以及它们运行的上下文发生了相当大的变化。

我将依次介绍每个守护进程，然后总结一些一般性的经验教训。

## extsmail

我在互联网接入比现在更少、更慢、更不可靠的时期开始使用extsmail。我希望能够从[mutt](https://mutt.org/)（后来是[neomutt](https://neomutt.org/)）发送电子邮件，而无需检查它们是否实际发送出去。我本可以设置一个完整的本地SMTP服务器，但许多系统可能会拒绝来自随机IP地址的电子邮件。我本可以设置某种经过身份验证的中继，但这不仅看起来难以做到，而且在[Let's Encrypt](https://letsencrypt.org/)出现之前难以确保安全性。

我真正想做的是利用我现有的ssh设置来发送电子邮件，隐含地获得免费的身份验证和安全性。这导致我创建了extsmail，最容易将其理解为“一个每个用户的sendmail二进制文件，不断尝试通过给定的命令发送电子邮件，直到成功为止”。例如，要配置mutt使用extsmail，只需设置：

```
set sendmail="extsmail -oem -oi" 
```

然后在`~/.extsmail/externals`中配置extsmail本身：

```
group {
 external myremote { sendmail = "/usr/bin/ssh myremote.example.com /usr/sbin/sendmail" } } 
```

在这个简单的例子中，远程机器上的`sendmail`被当作在我的本地机器上运行。我的邮件似乎是由`myremote.example.com`发送的，尽管我是在本地机器上写的。

我个人在`~/.xsession`中启动`extsmaild`（extsmail的守护进程部分），命令是`extsmaild -m daemon`。

当我开始使用extsmail时，我根本不知道自己在做什么。事实上，这是我写的第一个“正式”的Unix程序。我当然没想到会在15年后仍在使用它，但就目前情况而言，我无法想象不使用它。我正在火车上写这段话，虽然这里有wifi，但并不完全可靠。extsmail使我能够在按下“发送”按钮后，确信邮件会发送出去，尽管在火车的wifi上尝试失败的频率令人惊讶。

尽管有少量bug导致一些电子邮件被卡在队列中，但据我记得，extsmail从未声称发送了未发送的电子邮件，这更重要。单单我自己就通过extsmail发送了至少8万封电子邮件！

回顾历程，extsmail 经历了几个阶段：2008年底至2009年初的初步开发高潮；随着用户增多，直到2012年初，主要是进行了一些小的可移植性调整；2013年初至2014年初，我逐渐理解并修复了一些罕见情况，导致消息可能被卡在队列中的问题；2014年，一位相当多产的贡献者进行了一些小但有用的改进；此后长期进行维护，并且大约每年发布一次更新。

### 好处

现在显而易见的一件事，但我开始时并不明显，那就是在不需要过高努力的情况下，可以创建高质量的Unix守护程序。extsmail并不是一个庞大的程序，但它已被证明对一些用户来说是有用的，并且在至少过去的十年中是可靠的。我从知道即使是这样一个小众工具对其他人也是有用的事实中获得了相当多的满足感。

从extsmail学到的一个非常不同的教训是约定的力量。这有两种不同的方式。

首先是Unix约定，关于软件如何打包和安装。我决定创建一个标准的`configure`脚本，标准的安装预期，传统的man页面等等，部分原因只是为了看看它们是如何完成的。其中大多数约定至少略显烦人 —— 例如，man页面使用一种非常奇怪、难以阅读的格式。然而，随着时间的推移，这样做的好处变得显而易见 —— 它们对用户来说是熟悉的，并且减少了安装、理解和使用新工具的负担。与使用自定义构建系统（或者使用新的构建工具）的项目相比，这可以节省用户大量时间。从那时起，我一直试图思考“我是否可以以重用已知约定的方式解决这个问题，或者我真的需要做一些不同的事情？” 一旦我能控制自己的自负，答案几乎总是“我不需要做一些不同的事情”。

其次是更模糊的Unix约定，即好的程序应该尽量做好一件事，并尽可能多地留给外部程序处理。extsmail有一个特定的用例：通过外部命令发送电子邮件。在极端的情况下，我可以尝试制作一个完全通用的程序，但那样做会模仿“大型”SMTP服务器的复杂性，这将背离初衷。在极简的情况下，我可以只让extsmail能够通过ssh发送电子邮件，因为那是我写extsmail时唯一的用例，也是我所知道的唯一用例。

通过允许用户运行任意命令，我发现自己处于这样一种幸福的境地：早期用户告诉我他们正在使用[msmtp](https://marlam.de/msmtp/)而不是`ssh`来使用extsmail。我不仅不知道msmtp，而且不久之后我发现我需要与extsmail一起使用SMTP，而msmtp则是完美的选择！extsmail让我意识到，我可以设计小型程序，这些程序足够灵活，不会感到过于受限。这听起来像是一件小事，但这个意识从那时起对我设计软件的方式产生了深远的影响。

### 不好的

回顾来看，extsmail有几个小缺陷。

首先是它的配置缺陷。extsmail使用旧的惯例，期望配置文件位于`~/.extsmail/`而不是更现代化、我认为更整洁的`~/.config/`。这很容易解决，但如果我要这样做，我还应该解决一个问题：extsmail强制用户创建两个配置文件（`~/.extsmail/config`和`~/.extsmail/externals`），其实只需要一个文件就够了。我之所以做出这个选择，完全是因为愚蠢：我没有仔细看先例，也没有思考到可能真正需要的灵活性。我一直告诉自己，我会允许这两个文件合并成一个，并且有一个迁移期，在这个期间旧的和新的都是有效的，但这从未成为我的待办事项清单的重要项目。

其次是extsmail安装的两个二进制文件：`extsmail`是一个非常小的sendmail替代品（约150行代码）；主要守护进程命名为`extsmaild`。‘d’后缀在Unix中并不罕见，但如果你安装了一个名为`extsmail`的程序，你会首先运行什么命令？当然是`extsmail`！这样做会加载一个程序，看起来好像在你的终端上静默无声地运行。实际上，它正在等待stdin的输入（就像`sendmail`一样！），但这一点并不明显。如果你手动退出`extsmail`——使用Ctrl-D或Ctrl-D——它会留下一个空白文件。`extsmaild`曾经抱怨这不是一个有效的文件：在早期混淆的extsmail用户之后，我教会了`extsmaild`完全忽略空文件。

第三是相对缺乏自动化测试。文档告诉我们有许多我们需要处理的奇怪情况，但我们不知道如何实际制造它们。这时很容易完全不进行自动化测试——这是我屈服于的诱惑。

令人惊讶的是，这个决定的后果花了很长时间才变得清晰。特别是在我尝试处理Unix抛出的奇怪情况时，我变得非常谨慎——我成了man手册的忠实读者——这种情况比人们想象的要多。

我最终遇到的两个例子是 Unix 的[子进程处理绝对一团糟](http://catern.com/process.html)，以及 `poll` 在[不同平台上表现不同](https://www.greenend.org.uk/rjk/tech/poll.html)。即使我分别调整了 extsmail 来处理这些问题，但我没有考虑它们相互之间的影响。多年后，我意识到存在问题，并强迫自己编写了一个[简单的测试套件](https://github.com/ltratt/extsmail/commit/8deb27e620e6aba873dfe956304755c3a95d4e69)，帮助我缩小问题的范围，并[慢慢但肯定地](https://github.com/ltratt/extsmail/commit/d457926f7c6e452787570fa5ac86a221b1cdad56)修复了问题。如果我早些时候创建了一个测试套件，即使是小的测试套件，我就能避免很多痛苦！

### 其他教训

开始编写 extsmail 时真正让我吃惊的是 Unix 函数失败的方式有多么多样化。一个简单的例子是，如果接收到中断，Unix 中的许多函数可以提前返回（带有 `EINTR`）：有时可以尝试重新调用函数，但在其他情况下，可能需要采取不同的方法。

事情出错的方式多种多样，令人难以置信：管道可能意外关闭；有数据的文件可能不再返回数据；子进程有时会像电脑游戏中的旅鼠那样表现；等等。最终，我在现实生活中慢慢遇到了所有这些问题，还有更多其他问题。

当我慢慢意识到自己承担的负担时，我担心自己咬了比自己能咬的更多的东西。我曾考虑简化问题，如果发生任何更奇怪的情况，特别是那些我不知道如何触发的情况，就让程序退出。

我很快决定，作为守护程序的一个基本部分是在事情出错时（正确地！）继续运行。最终，这导致我决定，除了内存不足外，extsmail 在任何情况下都会继续运行。我想最终我成功了，尽管现在处理所有这些情况可能占据 extsmail 源代码的大约 50%！

令我惊讶的结果是意识到我无法在基于异常的语言中编写 extsmail。因为 C 强迫你考虑每一种可能出错的情况，库必须仔细记录所有可能出错的方式。这正是我[需要使 extsmail 更加健壮的东西](/laurie/blog/2008/how_can_c_programs_be_so_reliable.html)。

## snare

我所在的研究小组通常试图自动化我们的大部分基础设施。我们使用 [Buildbot](https://www.buildbot.net/) 进行持续集成，但有很多其他任务并不适合该工具。例如，我们希望在 GitHub 仓库推送时自动重建网站，但是现有的系统复杂——我记得甚至无法让其中一两个构建成功，更不用说运行了！

我很快意识到我想要的是一个守护进程，可以在仓库上发生事件时运行任意 Unix 命令（例如推送、合并拉取请求等）。因为我不确定这有多容易，所以我在几个小时内用 Python 快速制作了一个原型。它运行得相当好，足以让我意识到编写一个“正式”的守护进程是可行的。那时我主要在 Rust 中编写代码，所以我决定将这个即将进行的工作用作编写 Rust 守护进程的测试场。

因此，我创建了 [snare](/laurie/src/snare/)。snare 配置文件只有一个，从 extsmail 中吸取了教训！一个最简配置文件如下所示：

```
listen = "<ip-address>:<port>";   github {
 match ".*" { cmd = "/path/to/prps/%o/%r %e %j"; errorcmd = "cat %s | mailx -s \"snare error: github.com/%o/%r\" someone@example.com"; secret = "<secret>"; } } 
```

如此一来，snare 监听给定的 IP 地址和端口。在 GitHub 仓库中，您指定了一个“webhook”，该 webhook 发送消息（作为 HTTP 请求）到该 IP 和端口。 `match ".*"` 是一个正则表达式，匹配 `owner/repository` 对：`.*` 匹配任何字符串。当接收到请求时，snare 检查它是否与 `secret` 匹配，然后运行 shell 命令 `cmd`：`%` 变量分别展开为 GitHub 所有者仓库事件和 JSON 请求。如果出现任何问题，snare 运行 `errorcmd`，例如将错误输出发送到指定的电子邮件地址。

### The good

snare 相对快速地编写完成了。在几个月的业余时间工作后，它已经形成了稳定的形态。再过几个月，它基本上就完成了。部分原因是因为我已经有了 extsmail 的经验。

但是，大多数情况下，这是因为 snare 是用 Rust 编写的，而不是 C。这是我故意做出的选择：extsmail 给我一个令人惊讶的教训是，尽管 C 明显存在缺陷，但它确实能够编写可靠的程序。我尝试 Rust 之前，没有其他语言似乎能够替代 C。总体而言，我认为这个实验是一个明确的成功！

snare 借鉴了一个配置模式，我最初在 OpenBSD 的 [pf](https://www.openbsd.org/faq/pf/) 中看到过，并且之后几次看到了重复。基本上，配置文件从上到下“执行”，每个匹配都会覆盖前面的一些或全部值。这是一个简单而强大的模式。例如，给定这个 snare 配置：

```
listen = "<address>:<port>"; github {
 match ".*" { cmd = "/path/to/prps/%o/%r %e %j"; errorcmd = "cat %s | mailx -s \"snare error: github.com/%o/%r\" abc @def.com"; secret = "sec"; } match "a/b" { errorcmd = "lpr %s"; } } 
```

仓库 `a/b` 和 `c/d` 将有以下设置：

```
a/b:
 queue = sequential timeout = 3600 cmd = "/path/to/prps/%o/%r %e %j" errorcmd = "lpr %s" secret = "sec" c/d:
 queue = sequential timeout = 3600 cmd = "/path/to/prps/%o/%r %e %j" errorcmd = "cat %s | mailx -s \"snare error: github.com/%o/%r\" abc@def.com" secret = "sec" 
```

如此可能暗示，`queue = sequential` 和 `timeout = 3600` 是 snare 提供的默认值：`match ".*"` 块覆盖了 `cmd`、`errorcmd` 和 `secret`；而 `a/b` 进一步覆盖了 `secret`。

这种配置风格并不适用于每个程序，但在适用的情况下，它确实非常有效。我有几个复杂的 snare 设置受益匪浅。

### The bad

snare 包含一个HTTP服务器来监听请求。我使用了一个外部库，这个库似乎会带来使用 Rust 的 `async`/`await` 特性的小副作用。不久我就后悔了。`async`/`await` 有它的用例，特别是对于单线程语言，或者写网络服务器需要处理大量查询的人。Rust 是多线程的 - 实际上，它的类型系统禁止了大多数经典的多线程错误 - 我们很少有人编写需要处理大量查询的服务器。

不幸的是，`async`/`await` [将代码分成两部分](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)，在使用起来变得非常笨拙。我很快发现，snare 被分成了需要是 `async`/`await` 的代码和不需要的代码。当我发现需要为 `async`/`await` 代码使用 [不同的 `Mutex` 库](https://crates.io/crates/async-mutex) 时，我感到吃惊，并尽量减少它在 snare 中的使用到最低限度。但即便如此，这还不够：我发现 snare 有一些奇怪的，尽管非常小的内存泄漏，似乎是由我隐式吸收的大量 `async`/`await` 运行时代码引起的。

在2023年，我终于受够了，[删除了最后的`async`/`await`遗留](https://github.com/softdevteam/snare/commit/1263ececbeb693bce5ef89111b65baf8a74fde21)。snare的依赖项从213减少到172，在OpenBSD上二进制大小减少了20% - 对于完全相同的用户可见功能！当然，这触及了snare的核心部分，而我又一次太愚蠢没有添加测试套件。所以，我首先为基本功能添加了一个测试套件，让我确信这些变化不会破坏它；然后，我进一步扩展了测试套件，以覆盖snare安全相关的部分，我有了信心。

最终，为什么我在配置选项的末尾使用了分号呢？我觉得受到了写许多类似C语言的语法的影响。然而，这与Unix配置规范格格不入。

### 其他的经验教训

extsmail 和 snare 都会监听 `SIGHUP` 信号，并在接收到信号时重新加载它们的配置文件。我很少使用 extsmail 这个功能，但是对于 snare，我经常使用它：因为它可能正在运行作业，除非必须这样做，我宁愿不关闭它并重新启动它。

然而，`SIGHUP` 是不理想的：通过 PID（进程ID）进行通信既危险又笨拙（区分多个实例）。当出现问题时，用户不会直接收到通知，而是消息藏在日志中，他们经常忘记检查。

这个观察并不是新观点 - 实际上，在我之前许多人都已经提出过 - 但我决定，对于我将来可能编写的任何其他Unix守护程序，我将尝试不同的方法。

## pizauth

OAuth2是越来越广泛使用的认证标准。在2022年，我突然发现自己需要在工作流程的一些关键部分（包括电子邮件）中使用它，但是无法找到适合我设置的现有工具。我从使用snare的经验中意识到，我现在可以相当快速地创建相当不错的守护程序，因此不久之后，我创建了pizauth的第一个版本。第一个alpha版本在[大约6周后发布](/laurie/blog/2022/pizauth_oauth_authenticator_alpha.html)。

pizauth需要一个配置文件（通常是`~/.confg/pizauth.conf`），大致如下所示：

```
account "officesmtp" {
 auth_uri = "https://login.microsoftonline.com/common/oauth2/v2.0/authorize"; token_uri = "https://login.microsoftonline.com/common/oauth2/v2.0/token"; client_id = "..."; // Fill in with your Client ID client_secret = "..."; // Fill in with your Client secret scopes = [ "https://outlook.office365.com/IMAP.AccessAsUser.All", "https://outlook.office365.com/SMTP.Send", "offline_access" ]; // You don't have to specify login_hint, but it does make // authentication a little easier. auth_uri_fields = {"login_hint": "email@example.com"}; } 
```

我从snare中学到的一个教训是，pizauth被分成两部分。“后端”或“服务器”部分是这样启动的：

```
pizauth server 
```

“前端”命令然后通过Unix域套接字与后端通信。例如，不是向PID发送`SIGHUP`信号并祈祷，而是通过`pizauth reload`以安全的方式请求pizauth重新加载其配置文件。这两部分使用非常简单的基于文本的协议进行通信。`pizauth reload`向服务器发送`reload:`命令，服务器回复`ok:`或`error:<reason>`。

要获取授权令牌，可以运行`pizauth show`命令。首次为某个帐户运行此命令时，它将在stderr上打印包含授权网址的错误：

```
$ pizauth show officesmtp ERROR - Token unavailable until authorised with URL https://login.microsoftonline.com/common/oauth2/v2.0/authorize?access_type=offline&code_challenge=xpVa0mDzvR1Ozw5_cWN43DsO-k5_blQNHIzynyPfD3c&code_challenge_method=S256&scope=https%3A%2F%2Foutlook.office365.com%2FIMAP.AccessAsUser.All+https%3A%2F%2Foutlook.office365.com%2FSMTP.Send+offline_access&client_id=&redirect_uri=http%3A%2F%2Flocalhost%3A14204%2F&response_type=code&state=%25E6%25A0%25EF%2503h6%25BCK&client_secret=&login_hint=email@example.com 
```

然后用户需要在其选择的浏览器中打开该网址并完成验证。完成后，pizauth将收到通知，不久后`pizauth show officesmtp`将开始在stdout上显示令牌：

```
$ pizauth show officesmtp DIASSPt7jlcBPTWUUCtXMWtj9TlPC6U3P3aV6C9NYrQyrhZ9L2LhyJKgl5MP7YV4 
```

一旦认证完成，pizauth会定期更新访问令牌，目标是在访问令牌更改时，最终用户无需担心。

pizauth有一些有用的技巧。显而易见的是，`pizauth show`是异步的，因此可能需要另一个程序的授权而不会在终端上打印警告。`auth_notify_cmd`允许用户指定在这种情况下要运行的命令。要立即在浏览器中打开授权网址，我们可以指定：

```
auth_notify_cmd = "open \"$PIZAUTH_URL\""; 
```

浏览器突然打开一个页面可能会让人感到不安。如果我们想要更加 subtle，我们可以使用`notify-send`显示一个弹出窗口，我们必须点击以打开URL：

```
auth_notify_cmd = "if [[ \"$(notify-send -A \"Open $PIZAUTH_ACCOUNT\" -t 30000 'pizauth authorisation')\" == \"0\" ]]; then open \"$PIZAUTH_URL\"; fi"; 
```

### 好的

pizauth是以几乎不体面的速度编写的：到这个时候，我已经成为Rust中更好的程序员，并且已经有了编写snare的经验。我避免了写snare时犯的几个错误，这节省了我大量的时间。

我有意试图吸收从extsmail和snare中学到的守护程序知识，使pizauth成为一个更“现代”的Unix守护程序。显而易见的是，将其拆分为后端和前端，通过域套接字进行通信，消除了传统的PID和竞争条件问题。所有pizauth的命令都通过单一二进制运行，这使得安装和发现变得容易。

pizauth 也遵循关于配置和缓存文件位置的各种现代约定。`pizauth info` 是一个子命令，我希望更多守护程序也有（受 [这篇文章](https://utcc.utoronto.ca/~cks/space/blog/sysadmin/ReportConfigFileLocations) 的启发），因为它消除了文件位置的猜测：

```
$ pizauth info pizauth version 1.0.0:
 cache directory: /home/ltratt/.cache/pizauth config file: /home/ltratt/.config/pizauth.conf 
```

“现代”并不意味着偏离“传统”守护程序的优点。特别是，pizauth 相当简洁。我特别喜欢 `pizauth dump` 和 `pizauth restore` 的设计，它们 [设计得与外部工具很好地配合](/laurie/blog/2023/pizauth_dump_restore.html)。

### 缺点

或许现在对我来说知道我将对 pizauth 感到遗憾还为时过早。处理后端与前端之间通信的代码可能需要进行彻底整理，但它是功能齐全且安全的。

到目前为止，我意识到的可能最深刻的问题也许是，我希望在幕后安装了多个二进制文件：一个用于后端；每个前端命令一个。如果每个二进制文件只包含运行所需的代码，那么像基于小工具的攻击之类的事情的范围就会减少。

* * *

## 更高层次的反思

我希望分享我对 extsmail、snare 和 pizauth 的详细反思对大家有所帮助。这样做还帮助我汇总了一些更高层次的反思，其中一些可能从上文中显而易见，但也有一些可能不是。我将它们分成几类。

## 我们需要更多的守护程序

使守护程序成为一种独特的软件的特点是它们在后台永久运行并对事件做出反应。我们直观地意识到这对于那些对计算机外部事件做出反应的守护程序是相关的（例如，HTTP 服务器对 `GET` 请求做出反应），但我们通常低估了它对于计算机内部事件有多么有用。因为守护程序可以立即对事件做出反应，它允许不同的程序如此无缝地协同工作，以至于作为用户，我们将它们视为一个实体。

例如，许多人运行 — 或者希望运行！ — 一个守护进程，检测本地驱动器上文件的每次更新，并立即远程备份。extsmail 是同样技术的一个更为专业的例子 — 一旦电子邮件写入驱动器，extsmail 就会尝试运行一个“发送”命令。还有许多其他有用的事件可以做出反应，包括硬件连接/断开、网络上下线、程序启动和停止等。

曾几何时，守护进程必须“轮询”（即间歇性地查询）系统以查看事件是否发生。这不仅引入了延迟，而且持续唤醒守护进程，它执行大部分无意义的操作可能是一个显著的计算和功耗负担。现代 Unix 系统已经在很大程度上解决了这个问题：进程可以请求内核通知它们关注的广泛类型事件（参见例如 [`epoll`](https://zh.wikipedia.org/wiki/Epoll) 或 [`kqueue`](https://zh.wikipedia.org/wiki/Kqueue)）。换句话说，我们现在可以编写几乎不消耗资源的守护进程，直到确实发生可能感兴趣的事件。

我坚信，太少的程序利用了这种工作方式，如果我们写更多这样的程序，世界将会变得更美好。在某种程度上，我认为这是因为很多人并没有意识到一个守护进程*能够*做什么，更不用说现代 Unix 系统是如何使其易于高效地实现的了。

我还意识到很多优秀的程序员默认地认为他们不能或不应该编写一个守护进程。许多人认为“其他”人更适合这样做，要么是因为守护进程只能由最优秀的程序员创建，要么是因为那些深谙古老 Unix 知识的人更合适。

你可能会认为我即将陷入陈词滥调，并说每个程序员都可以创建高质量的守护进程。尽管我很希望情况是这样，长期经验告诉我并非如此。特别是在编写守护进程时，人们必须在每一点上思考“可能出现什么问题？”并不是每个程序员似乎能够或愿意以这种方式思考。

然而，“并非每位程序员”远非“仅限于最优秀的程序员”。我是一个不错的程序员，但我认识到有很多更优秀的人 —— 而我已经能够在零碎的时间里创建三个质量合理的守护进程。现在创建一个守护进程比以往更容易多了，部分原因是 Rust 现在是一个适合守护进程的可行语言。

因此在这里有一个好消息：虽然我认为我们需要更多的守护进程，但现在创建好的守护进程从未如此简单！

## 对于守护进程来说，简洁是一种美德。

“做好一件事，并且做到最好”已经成为 Unix 的陈词滥调。作为建议，这通常不合适 —— 例如，我记得使用极简主义文本编辑器，但我更喜欢现代的多功能工具。但守护进程的本质使这个建议特别适用。

这是因为守护进程的不寻常特性，最终导致了这一结果：因为它们在后台运行，很容易被忽略。我故意使用“被忘记”这个词，因为它有两种解释方式：守护进程因为工作得很好而被忘记，我们假设它们将继续如此；或者它们因为停止工作良好而被忘记，但没有人注意到和/或知道罪魁祸首是谁。

有时候会产生一种诱惑，认为如果没有人注意到某些功能未正常工作，那么这些功能就不重要。问题在于，有时候我们直到为时已晚才发现某些功能未正常工作，自动备份未能工作就是一个众所周知的例子。

处理守护进程出现问题的一个常见解决方案是持续通知或监控：当出现问题时，会有人类被警报，并且他们必须修复因此产生的混乱。有时候这是无法避免的，但显然效率低下，只有最有耐心或最充足资源的人才能做到。更重要的是，这集中于症状而非原因。

我的观点是，守护进程的可靠性在很大程度上取决于其配置的复杂性。与我们每天明知故问地互动的前台软件不同，我们往往不完全了解守护进程的能力，或者它们的工作原理。更糟糕的是，我们往往在最无知的时候一次性地配置它们，然后长达数月甚至数年不再理会。

随着守护进程配置的复杂性增加，我们增加了用户配置错误的可能性。我认为大多数守护进程向用户提供了过多的配置选项：许多看似有用或最坏的情况下无害，但总体上它们往往会使用户感到超负荷。通常用户甚至没有意识到他们超负荷了：守护进程拥有的配置选项越多，它在记录单个细节时的表现就越差。

由于守护进程难以测试，我有时怀疑更加隐晦的配置选项之间的交互是否可以完全依赖。最终，我们向用户提供的配置选项越多，我们的守护进程在内部就变得越复杂，引入错误的可能性也就越大。

## 用户界面：

用户通常以4种方式与守护进程互动：

1.  使用给定的标志启动守护进程（例如 `-v`）。

1.  指定一个配置文件（例如 `~/.config/pizauth.con`）。

1.  向守护进程发送信号（例如 `SIGHUP`）。

1.  通过域套接字进行通信（即进程间通信，其中管道以特定文件标识，例如 `~/.cache/pizauth/pizauth.sock`）。

这4种方式可以清晰地分为两类：配置（1和2）和通信（3和4）。

### 配置

如上所述，正如保持守护进程范围尽可能窄一样，将配置灵活性保持尽可能有限也是最佳选择。

我往往很少向我的守护进程添加很多标志，通常只有这些：允许指定特定配置文件（`-c`）；通过不分叉进入后台以帮助调试（`-d`）；以及临时增加日志详细度（`-v`，通常可以多次指定以增加日志信息）。

对于配置文件，我也尽量保持我认为用户需要的选项最少化。总的来说，我认为用户*认为*他们需要的灵活性比实际需要的要多。一小部分用户（有时候声音很大）会因为无法配置系统的每一个小细节而感到非常沮丧，但我认为他们不应该毁掉我们其他人的体验。当我觉得有必要为一部分用户提供选项时，我会力求提供一个明智的默认设置，这样大多数人可以忽略它。例如，snare 允许用户配置可以运行多少个并行作业，但默认设置是允许与活动CPU核心数量相同的作业。显然这并不适用于所有情况，但对大多数情况来说已经足够好了。

最后，还有配置文件语法的问题。使用像TOML这样的“标准”语法是很诱人的。但总体上我认为这些标准语法并不适合守护程序：它们要么不够灵活（例如TOML），要么太灵活（例如YAML）。我更喜欢创建一个简单的Yacc语法，通常是C风格的语法，用大括号进行嵌套。使用自定义语法的一个优点是我可以在解析器中捕获大量意外错误，并提供高质量的错误消息。虽然这样做确实需要用户学习一种新的语法，但大多数人对这种语法已经如此熟悉，以至于这并不是一个明显的入门障碍。

### 通信

传统上，与守护程序直接通信的唯一方法是通过信号。例如，大多数守护程序将`SIGHUP`解释为“重新加载配置文件”。

现在我坚定地认为，以这种方式使用信号是一个我们应该放弃的坏主意。坦率地说，信号是Unix中设计最糟糕的部分之一。从用户的角度来看，它们对进程名称和/或PID的依赖性增加了发送信号给错误进程的机会。从守护程序作者的角度来看，信号以一种奇怪的异步执行形式执行代码，期间很少能安全执行正常操作。我注意到，大多数程序员对信号处理程序中允许的操作过于乐观，只有通过奇怪的故障经历才真正读懂并理解相关规则。

相反，最好通过域套接字与守护程序通信。实质上，这是一个Unix管道，其用户端通过命名文件标识。由于向管道写入字节不是很好的用户体验，因此“守护程序”需要分成两部分：“后端”或“服务器”守护程序和“前端”或“客户端”命令，后者与后端进行通信。

pizauth 就是使用这种习惯用法的守护程序示例。当它启动时，`pizauth server`会创建一个域套接字（例如`~/.cache/pizauth/pizauth.sock`）。诸如`pizauth show act1`的命令会连接到域套接字，向套接字写入一个简单的命令（例如`showtoken:act1`），并监听回复（例如`access_token:abcd1234`）。

除了绕过有关 PID 和信号处理程序的担忧外，这种习惯用法还有其他优点。它使得守护程序可以轻松可靠地检查自己是否已经在运行：如果域套接字文件不存在，则明显守护程序未在运行；如果域套接字文件存在，则守护程序可以向套接字发送请求，如果没有收到回复，则守护程序未在运行。最后，它使得与守护程序交互的新方式变得微不足道。例如，pizauth 随着时间的推移增加了几个新的子命令，每个子命令我只需要一两分钟就能实现。

这种守护程序风格有两个后果。首先，如何向用户公开所有不同的子命令？一些守护程序安装多个具有不同名称的二进制文件。特别是如果这些二进制文件没有共同的前缀，这会降低可发现性。即使它们有共同的前缀，这意味着简单的 `-h` 类型的帮助只能针对每个二进制文件。相比之下，`pizauth -h` 可以合理地一次性向用户展示所有子命令：

```
$ pizauth -h Usage:
 pizauth dump pizauth info [-j] pizauth refresh [-u] <account> pizauth restore pizauth reload pizauth revoke <account> pizauth server [-c <config-path>] [-dv] pizauth show [-u] <account> pizauth shutdown pizauth status 
```

其次，如何实现所有这些子命令？pizauth 实际上只安装了一个单独的二进制文件：如果作为 `pizauth server` 调用，它会走一条路径；所有其他子命令则走另一条路径。对于许多守护程序来说，这可能是可以接受的，但这也意味着单个二进制文件相当大。如今，这让我有些担心，因为我可能会为[gadget attacks](https://en.wikipedia.org/wiki/Return-oriented_programming)暴露一个不必要的大攻击面。

回顾来看，我认为最好在用户看不到的地方安装多个子命令二进制文件（例如 `pizauth-server`、`pizauth-show` 安装在 `/usr/local/exec/pizauth/` 目录下），然后使用单个二进制文件或者 shell 脚本（`/usr/local/bin/pizauth`）来转发执行。每个子命令二进制文件只包含执行其特定操作所需的最小代码。从实现的角度来看，pizauth 的“核心”将是一个库，每个子命令都会导入并根据需要使用。采用这种风格的实现并不会增加太多难度，我以后写的任何守护程序都可能会这样做。

## 实施建议

直到最近，守护程序普遍使用 C 语言编写。很难推荐 C 语言用于新软件：它降低了生产力，而且很难编写安全的代码。

我在 snare 和 pizauth 的经验表明，Rust 是编写守护进程的可行语言。Rust 并非完美的语言（例如，不安全的 Rust 当前没有实质性的语义，因此任何使用 `unsafe` 的代码都比 C 语言的保证更少），而且某些实现的部分与传统的 Unix 期望不符（它生成的二进制文件大小令人惊讶）。但是在 Rust 中，即使在达到 [目前可用的广泛库](https://crates.io) 之前，也可以比在 C 中更高效地工作。毫无疑问，如果我局限于 C 语言，我将无法找到足够的时间来编写 snare 或 pizauth。

Rust 类型系统的一个愉快的好处是，它使得编写多线程程序比任何其他等效语言都更容易。由于守护进程通常希望并行执行多个任务（例如监听新事件并执行与先前事件相关的操作），线程是一种自然的方法。pizauth 特别是广泛使用线程，因此效果更佳。我唯一的警告是，带锁的代码经常因为 [临时生命周期延长](https://rustwiki.org/en/reference/destructors.html#temporary-lifetime-extension) 的未指明性而失败。这不是一个理论问题 —— 只有在它在 pizauth 中引发 [问题](https://github.com/ltratt/pizauth/commit/b8bcfd06d0642f75ec9ed391f63ba4bf7213b0f3)（现已修复）后，我才意识到什么是临时生命周期延长。

无论使用哪种语言编写守护进程，稳健性 —— 在面对困难情况时保持正确工作的能力 —— 是关键。人们很容易认为，稳健性可以在稍后添加到守护进程中，但它在宏观和微观层面上都有深远的影响。期望像临时脚本一样快速编写守护进程是一个坏主意：稳健性需要时间；它需要更多的代码（通常是 *更多* 的代码）；它需要仔细和持续的思考。

我为守护进程学到的最后一课是，仅仅因为自动化测试很困难，并不意味着应该避免自动化测试。我所知的大多数守护进程几乎没有进行任何自动化测试，我也接受了这一点。然而，由于守护进程持续运行，它们比我们编写的任何其他软件更有可能遇到不太可能的情况。虽然一些不太可能发生的情况，特别是那些只可能发生在某些平台上的情况，是难以触发的，但我后悔没有更彻底地测试我编写的守护进程。

显而易见的挑战是，在守护进程中通常很难进行单元测试。例如，snare 和 pizauth 的配置模块进行了合理的单元测试，但我更担心的是整个系统是否能够正确运行。我之前提到了 extsmail、子进程和 poll 的问题。现在，extsmail 有一个小型但令人惊讶地有效的测试套件，检查这些方面是否正常工作。

snare 面临不同的问题：随着时间推移，我越来越不愿意对 snare 进行重大更改，因为我担心可能会以微妙的方式引发问题。当我决定移除 snare 使用的外部 HTTP 服务器时，我意识到我需要确信我的替代方案不会出问题。因此，我还添加了一个有意义的系统全面测试套件（有时称为“集成”或“黑盒”测试），现在涵盖了 snare 大部分的功能（https://github.com/softdevteam/snare/commit/1263ececbeb693bce5ef89111b65baf8a74fde21）。

在 extsmail 和 snare 的情况中，关键在于接受，虽然测试守护进程的 *所有内容* 是不切实际的，但通过足够的思考，大多数事情是可以进行测试的。测试可以轻松设置隔离环境（例如在临时目录中），运行简单的 shell 命令，然后检查这些命令的效果。在许多情况下，产生的测试是“基于时间的” — 即，有时测试的唯一操作就是 `sleep` 一段足够长的时间，以确保可以测试到的动作已发生。基于时间的测试显然是脆弱的，因此通常不被看好。但当这是测试的唯一合理选项时，接受这是必要的，远比不测试要好！

总结起来，尽管许多现有的 Unix 守护进程缺乏自动化测试，但我们现在知道应该做得更好，也知道如何做到这一点。毫无疑问，我已经吸取了教训：我写的任何未来守护进程从第一天起都会进行彻底测试。

## 总结

写守护进程的高级建议如下：

1.  守护进程往往配置一次，然后被遗忘。因此，守护进程在范围上更加聚焦且配置起来更简单，就越有可能持续正确运行。试图使守护进程超级灵活是诱人的，但这会给用户和实施者带来很大的认知负担，这通常是不必要且常常是适得其反的。

1.  在 Rust 中编写新守护进程是可行的，甚至对于中等复杂度的守护进程来说是一个良好的权衡。不过，对于最小的守护进程来说，Rust 二进制文件的大小可能不合适。

1.  如果我们希望今天和未来的更改后对守护进程的正确性有信心，守护进程需要系统全面的自动化测试。测试守护进程可能看起来困难或不可能，特别是如果期望测试所有内容，但通常可以相对容易地自动测试大量功能的子集。

1.  通过信号（例如 `SIGHUP`）与守护进程通信是个坏主意。Unix 域套接字提供更大的灵活性和更好的用户体验。

1.  安装一个具有子命令处理的用户可见二进制文件可以更容易理解和扩展守护进程。

最后，了解Unix的最好方法莫过于编写一个守护程序。这样做有很多积极的方面——令人惊讶的是，我能够运用我在研究中从extsmail学到的许多经验教训，甚至还有一两个来自snare！但也有一个消极的方面。被迫面对Unix几十年的历史，从诞生时的缺陷到此后积累的缺陷，让我深信我们应该重新思考操作系统。但即使有人找到资源重新构想操作系统，我们几乎肯定希望得到类似守护程序的东西！

[更新的文章](/laurie/blog/2024/what_factors_explain_the_nature_of_software.html)

2024-02-28 11:00

[更旧的文章](/laurie/blog/2024/faster_shell_startup_with_shell_switching.html)

如果您想获取博客新文章的更新，请关注我

[Mastodon](https://mastodon.social/@ltratt)

或

[Twitter](https://twitter.com/laurencetratt)

; 或

[订阅RSS提要](../blog.rss)

; 或

[订阅电子邮件更新](/laurie/newsletter/)

:

### 脚注

### 评论
