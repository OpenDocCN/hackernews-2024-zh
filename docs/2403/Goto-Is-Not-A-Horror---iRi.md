<!--yml

category: 未分类

date: 2024-05-29 12:34:09

-->

# Goto不是一种恐怖 - iRi

> 来源：[https://jerf.org/iri/post/2024/goto/](https://jerf.org/iri/post/2024/goto/)

1968年，艾德斯格·迪杰斯特拉发表了一封经典的信，标题是“Go To Statement Considered Harmful”。我认为标题掩盖了要点，因为实际上它是对结构化编程的一种鼓励，但这并不是错误的。在这封信中，确实认为`goto`是有害的。

迪杰斯特拉的信完全正确。历史证明了他的正确性。他赢了。

他*赢了*。

*过去时*。

胜利已经结束。已经完成了。

`goto`已经*死*了。迪杰斯特拉将其消灭了。

换句话说，迪杰斯特拉所说的`goto`已经死了。你的语言没有它。你的语言几十年来都没有它。你没有迪杰斯特拉-`goto`。

它在汇编语言中还存在。它可以在那里存在。它不必再打扰其他人。

你现代语言中的`goto`并不是迪杰斯特拉所说的那种`goto`。迪杰斯特拉所说的是一种可以跳到任何地方的`goto`。字面上的任何地方。

你的语言没有那种`goto`。你的语言有一个被结构化编程范式彻底约束的`goto`。你不能从一个函数跳转到另一个函数，在`if`语句的中间，在`for`循环的中间使用`goto`。

不仅迪杰斯特拉所抱怨的那个`goto`确实能够做到这一点，如果你仔细阅读这封信，你会发现信件的真正抱怨是`goto`本身是当时程序的组织原则……这意味着`goto`之所以有害的原因之一是它首先阻止了函数的存在！在存在无约束的`goto`的情况下，你无法获得函数提供的保证。

这是从现代角度表达的。这封信将讨论根据执行索引来判断程序位置的能力。该信通常假设你理解结构化编程及其应用的批评。幸运的是，你确实理解结构化编程，因为这几乎是你所有的工作。

所以停止将上世纪60年代`goto`的批评应用于现代的`goto`。不要表现得像在函数中使用一次`goto`就意味着你是一个糟糕的程序员，不懂行。`DELETE FROM shibboleths WHERE value LIKE "%goto%"`。抨击现代`goto`并不明智，也不是一个好程序员的标志，这表明你不理解为什么`goto`……或者说，*曾经*……是不好的。

这意味着你应该更频繁地使用它吗？不。结构化编程已经有数十年的成功经验。绝大多数情况下，结构化编程都能很好地完成工作。

在现代编程语言中，很难通过`goto`搞乱一个函数。可能“如果我……？”这样的问题早就被禁止了。你会发现你的编程语言已经禁止了从外部跳入`for`循环的中间。你会发现你的编程语言已经禁止了跳过变量初始化，如果它们是你语言中的语句的话。

当然，你可以通过大量使用`goto`来搞乱函数，但这有什么了不起呢。我有成百上千种方法来搞乱函数；查看你所在的非平凡代码库，会有成千上万的例子。可以肯定，这些例子中几乎*没有一个*会涉及任何形式的`goto`。`goto`并非特别的威胁。我要说[stringly typing](https://www.hanselman.com/blog/stringly-typed-vs-strongly-typed)对你的代码造成的危害要比`goto`大得多，至少是6或7个数量级。许多程序员知道如何批评`goto`，但对于随意在程序结构中到处塞入字符串和整数却不以为然，毫不知情。

实际上……保持你们的帽子……当我看到现代代码使用`goto`时，我实际上会认为这标志着它可能是由*高技能*程序员编写的。因为他们理解问题，理解现代反对`goto`的共识是错误的，并且明白他们有一个情况，`goto`是最好的解决方案。

不要过分担心`goto`。不要把上世纪60年代的`goto`和今天的`goto`相提并论。

这重要吗？一点也不。这只是一个个人的小怨念博客主题。

但如果你想从中得到实际的东西，[重新阅读这封信](https://dl.acm.org/doi/10.1145/362929.362947)（或者第一次阅读它），但把所有关于`goto`的引用都删掉，并且阅读其它内容。你会对你作为编程鱼所处的水域有更深入的理解。你会了解整个编程行业为什么集体决定在这种水域中游泳。你会了解堆栈跟踪*真正*意味着什么。我已经忘记了链接，但我曾经读过一篇关于为什么堆栈跟踪实际上应该在其中包含for循环索引的博客文章；你会了解为什么这是一个有趣的想法，可能是整个编程社区几十年来忽视的东西。这样至少对你来说，这篇无聊的抱怨博客文章不会是毫无意义的了。
