- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-28 18:11:19'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe possible bug in std::shared_mutex on Windows : cpp'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://old.reddit.com/r/cpp/comments/1b55686/maybe_possible_bug_in_stdshared_mutex_on_windows/](https://old.reddit.com/r/cpp/comments/1b55686/maybe_possible_bug_in_stdshared_mutex_on_windows/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A team at my company ran into a peculiar and unexpected behavior with `std::shared_mutex`.
    This behavior only occurs on Windows w/ MSVC. It does not occur with MinGW or
    on other platforms.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point the behavior is pretty well understood. The question isn''t "how
    to work around this". The questions are:'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: Is this a bug in `std::shared_mutex`?
  id: totrans-split-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is this a bug in the [Windows SlimReaderWriter](https://learn.microsoft.com/en-us/windows/win32/sync/slim-reader-writer--srw--locks)
    implementation?
  id: totrans-split-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I'm going to boldly claim "definitely yes" and "yes, or the SRW behavior needs
    to be documented". Your reaction is surely "it's never a bug, it's always user
    error". I appreciate that sentiment. Please hold that thought for just a minute
    and read on.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the scenario:'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Main thread acquires **exclusive** lock
  id: totrans-split-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Main thread creates N child threads
  id: totrans-split-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each child thread:'
  id: totrans-split-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acquires a **shared** lock
  id: totrans-split-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yields until all children have acquired a shared lock
  id: totrans-split-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Releases the **shared** lock
  id: totrans-split-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Main thread releases the **exclusive** lock
  id: totrans-split-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This works ***most*** of the time. However 1 out of ~1000 times it "deadlocks".
    When it deadlocks exactly 1 child successfully acquires a shared lock and all
    other children block forever in `lock_shared()`. This behavior can be observed
    with `std::shared_mutex`, `std::shared_lock`/`std::unique_lock`, or simply calling
    `SRW` functions directly.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: If the single child that succeeds calls `unlock_shared()` then the other children
    will wake up. However if we're waiting for all readers to acquire their shared
    lock then we will wait forever. Yes, we could achieve this behavior in other ways,
    that's not the question.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: I made a [StackOverflow post](https://stackoverflow.com/questions/78090862/stdshared-mutexunlock-shared-blocks-even-though-there-are-no-active-exclus)
    that has had some good discussion. The behavior has been confirmed. However at
    this point we need a language lawyer, [u/STL](/u/STL), or quite honestly Raymond
    Chen to declare whether this is "by design" or a bug.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: Here is code that can be trivially compiled to repro the error.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-23
  prefs: []
  type: TYPE_PRE
- en: Personally I don't think the function `lock_shared()` should ever be allowed
    to block forever when there is not an exclusive lock. That, to me, is a bug. One
    that only appears for `std::shared_mutex` in the `SRW`-based Windows MSVC implementation.
    *Maybe* it's allowed by the language spec? I'm not a language lawyer.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: I'm also inclined to call the `SRW` behavior either a bug or something that
    should be documented. There's a [2017 Raymond Chen](https://devblogs.microsoft.com/oldnewthing/20170301-00/?p=95615)
    post that discusses EXACTLY this behavior. He implies it is user error. Therefore
    I'm inclined to boldly, and perhaps wrongly, call this is an `SRW` bug.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: What do y'all think?
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit: Updated to explicitly set `readCounter` to 0\. That is not the problem.'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
