["```\n(m^e)^d â‰¡ m (mod n)\n```", "```\ndef eucalg(a, b):\n\t# make a the bigger one and b the lesser one\n\tswapped = False\n\tif a < b:\n\t\ta, b = b, a\n\t\tswapped = True\n\t# ca and cb store current a and b in form of\n\t# coefficients with initial a and b\n\t# a' = ca[0] * a + ca[1] * b\n\t# b' = cb[0] * a + cb[1] * b\n\tca = (1, 0)\n\tcb = (0, 1)\n\twhile b != 0:\n\t\t# k denotes how many times number b\n\t\t# can be substracted from a\n\t\tk = a // b\n\t\t# a  <- b\n\t\t# b  <- a - b * k\n\t\t# ca <- cb\n\t\t# cb <- (ca[0] - k * cb[0], ca[1] - k * cb[1])\n\t\ta, b, ca, cb = b, a-b*k, cb, (ca[0]-k*cb[0], ca[1]-k*cb[1])\n\tif swapped:\n\t\treturn (ca[1], ca[0])\n\telse:\n\t\treturn ca \n```", "```\ndef modpow(b, e, n):\n\t# find length of e in bits\n\ttst = 1\n\tsiz = 0\n\twhile e >= tst:\n\t\ttst <<= 1\n\t\tsiz += 1\n\tsiz -= 1\n\t# calculate the result\n\tr = 1\n\tfor i in range(siz, -1, -1):\n\t\tr = (r * r) % n\n\t\tif (e >> i) & 1: r = (r * b) % n\n\treturn r \n```", "```\ndef keysgen(p, q):\n\tn = p * q\n\tlambda_n = (p - 1) * (q - 1)\n\te = 35537\n\td = eucalg(e, lambda_n)[0]\n\tif d < 0: d += lambda_n\n        # both private and public key must have n stored with them\n\treturn {'priv': (d, n), 'pub': (e, n)}\n\ndef numencrypt(m, pub):\n\treturn modpow(m, pub[0], pub[1])\n\ndef numdecrypt(m, priv):\n\treturn modpow(m, priv[0], priv[1]) \n```", "```\n>>> import rsa\n>>> keys = rsa.keysgen(31337, 31357)\n>>> keys\n{'priv': (720926705, 982634309), 'pub': (35537, 982634309)}\n>>> priv = keys['priv']\n>>> pub = keys['pub']\n>>> msg = 80087\n>>> enc = rsa.numencrypt(msg, priv)\n>>> enc\n34604568\n>>> dec = rsa.numdecrypt(enc, pub)\n>>> dec\n80087\n>>> \n```"]