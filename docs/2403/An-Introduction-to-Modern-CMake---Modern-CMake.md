<!--yml

类别：未分类

日期：2024-05-29 12:35:14

-->

# 现代CMake简介 · 现代CMake

> 来源：[https://cliutils.gitlab.io/modern-cmake/](https://cliutils.gitlab.io/modern-cmake/)

# 现代CMake简介

人们喜欢抱怨构建系统。只需观看CppCon17的演讲，就能看到开发人员将构建系统的状态作为笑话的对象。这引发了一个问题：为什么？当然，在构建时存在许多问题。但我认为，在2023年，我们对这些问题有了一个非常好的解决方案。那就是CMake。不过不是CMake 2.8；那是在C++11甚至还不存在的时候发布的！也不是CMake的可怕示例（甚至包括KitWare自己教程列表中发布的示例）。我说的是现代CMake。CMake 3.5+，甚至CMake 3.29+！它简洁、强大、优雅，这样你就可以把大部分时间用在编码上，而不是在难以理解、难以维护的Make（或CMake 2）文件中添加行。而且，CMake 3.11+的速度据说要显著更快！

*你有兴趣使用CMake来构建Python软件包吗？我正在研究scikit-build-core，[提案描述在此](https://iscinumpy.gitlab.io/post/scikit-build-proposal/)！如果你有使用例子，请告诉我！*

*简而言之，如果你正在考虑使用现代CMake，你最可能脑中出现的问题有：*

## 为什么我需要一个好的构建系统？

以下哪个情况适用于你？

+   你想避免硬编码路径

+   你需要在多台计算机上构建一个软件包

+   你想要使用CI（持续集成）

+   你需要支持不同的操作系统（甚至只是Unix的不同版本）

+   你想支持多个编译器

+   你想要使用集成开发环境，但可能不是全部时间

+   你想要描述你的程序在逻辑上是如何结构化的，而不只是标志和命令

+   你想要使用一个库

+   你想要使用工具，比如Clang-Tidy，来帮助你编码

+   你想要使用调试器

如果是这样，你将受益于类似于CMake的构建系统。

## 为什么答案必须是CMake？

构建系统是一个热门话题。当然，有很多选择。但即使是一个真正好的选择，或者是一个重复使用熟悉语法的选择，也无法与CMake相提并论。为什么？支持。每个集成开发环境都支持CMake（或CMake支持该集成开发环境）。比起任何其他系统，更多的软件包使用CMake。因此，如果你使用一个旨在包含在你的代码中的库，你可以选择：自己制作一个构建系统，或者使用提供的系统之一，几乎总是包括CMake。如果你包含了多个项目，那么CMake很快就会成为共同的因素。并且，如果你需要一个预安装的库，那么它有一个搜索CMake脚本或配置CMake脚本的可能性非常大。

## 为什么要使用现代CMake？

大约在CMake 2.6-2.8的时候，CMake开始盛行。它在大多数Linux操作系统的软件包管理器中，以及许多软件包中被使用。

然后，Python 3发布了。

我知道，这实际上与CMake毫不相关。

但它有一个 3。并且它跟随了 2。并且这是一个艰难、丑陋的过渡，在某些地方甚至今天仍在进行中。

我认为 CMake 3 不走运，因为它紧随 Python 3.^([1](#fn_1))，尽管每个 CMake 版本都极其向后兼容，但 3 系列被当作是全新的东西对待。因此，你会发现像 CentOS7 这样的操作系统配备 GCC 4.8，几乎完全支持 C++14，但使用的却是几年前发布的 CMake 2.8，甚至连 C++11 都不支持。

你至少应该使用比你的编译器发布更晚的 CMake 版本，因为它需要了解该版本的编译器标志等等。而且，由于 CMake 会将自己降级到你的 CMake 文件中所需的最低版本，安装一个新的 CMake，即使是系统范围内，也是相当安全的。你至少应该在本地安装它。这很容易（在许多情况下只需 1-2 行），而且你会发现，投入 5 分钟的工作将为你节省数百行和数小时的 `CMakeLists.txt` 编写，并且长期来看更易于维护。

本书试图解决网上泛滥的糟糕示例和最佳实践问题。

## 其他来源

其他这本书的原作者的资料：

在网上还有一些其他地方可以找到好的信息。以下是其中一些：

## 致谢

现代 CMake 最初由[Henry Schreiner](https://iscinumpy.gitlab.io)编写。其他贡献者可以在[GitLab 上找到](https://gitlab.com/CLIUtils/modern-cmake/-/network/master)。

> ¹. CMake 3.0 还移除了几个非常旧版本的 CMake 的长期弃用功能，并对与方括号相关的语法进行了一个非常微小的不兼容更改，所以这并不完全公平；可能会有一些非常、非常旧的 CMake 文件在 3\ 版本下停止工作，但我从未见过这种情况。[↩](#reffn_1 "跳转回文中的脚注 [1]")*
