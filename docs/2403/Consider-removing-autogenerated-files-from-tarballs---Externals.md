<!--yml

类别：未分类

日期：2024-05-29 12:48:32

-->

# 考虑从tarballs中删除自动生成的文件——外部

> 来源：[https://externals.io/message/122811](https://externals.io/message/122811)
> 
> 但我主要的问题是：我看不到我种植我的区别
> 
> 在`configure`中的恶意代码，[configure.ac](http://configure.ac)或者*.c: 有人必须审查
> 
> 更改并注意问题。而我们必须信任RMs。什么
> 
> 我错过了什么？

据我所了解，讨论中涉及的攻击涉及*从未提交到版本控制的代码*。大部分负载被提交到假的二进制测试工件中，这些工件不太可能被检查，但本身无害；但触发器手动添加到自动化构建和生成签名发布归档之间。

所以理论上如果在该过程中没有人参与，那么人类就无法引入恶意变更。利用需要在版本控制、人类可读的代码中引入漏洞。将额外的机会给予检测。

> 你认为如果改变发生在
> 
> 分布式源文件？我的意思是，你仍然可以修改tarball
> 
> 分布文件的（例如在[configure.ac](http://configure.ac)中隐藏或在我们
> 
> 在更不可见的文件中更容易地进行（例如各种Makefile.frag和
> 
> 类似）。仅使用VCS文件，你唯一得到的是
> 
> 人们可以对文件的分布内容进行哈希，并进行比较
> 
> 带有VCS文件的哈希，但有没有人做这种
> 
> 验证？

我们已经完全基于比较源文件的哈希构建的版本控制系统。因此，给定一个声称与签名标签内容匹配的签名tarball，任何用户都可以轻松地检出标签，展开tarball，并运行“git diff”来检测任何异常。

谁会在实践中这样做是个合法的问题，也是我肯定在其他地方讨论过的问题，关于可再现的二进制构建。

> 顺便说一句，我不相信“需要用户安装
> 
> 为了从tarballs中编译PHP有效地使用autotools和bison是合法的
> 
> 理由延迟尽快修补严重攻击向量的补丁。

正如总是这样，安全与之间存在权衡

方便性——在这种情况下，分发一些可用的东西而无需

大量额外的工具（包括某些生成的文件，如

PHP本身的副本），与分发100%可审查的东西相比

由人类审查。

最终，99.999%的用户不会编译他们自己的副本

PHP的源代码；他们将信任某些供应商链来接管

来源，执行所有必要的构建步骤，并生成二进制文件。

从tarballs中移除生成的文件并不消除这种需要

信任，它只是更多地转移到像Debian和

RedHat这样的组织；也许这是一个有效的目标，因为这些组织有

比我们更多的资源来构建适当的流程。

使事情可重现旨在从不同角度解决同一问题：

而不是对链条的一部分更加信任，

它允许多个并行链条，这些链条都应该给出

相同的结果。如果来自不同源的构建开始显示未经解释的

差异，它可以被自动标记。

致敬，

--

Rowan Tommins

[IMSoP]
