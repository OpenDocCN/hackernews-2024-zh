<!--yml

category: 未分类

date: 2024-05-29 12:47:02

-->

# 从MongoDB到PostgreSQL的大迁移

> 来源：[https://infisical.com/blog/postgresql-migration-technical](https://infisical.com/blog/postgresql-migration-technical)

[Infisical](https://github.com/Infisical/infisical)在过去一年中迅速增长，现在每天处理超过5000万个密钥，将应用程序配置和密钥数据发送给需要它们的团队、CI/CD流水线和服务器/应用程序。

随着使用量的持续增长，我们不得不不断升级我们的技术栈。最近，Infisical 完成了从[MongoDB](https://www.mongodb.com/)迁移到[PostgreSQL](https://www.postgresql.org/)的全面数据库迁移。这涉及到深思熟虑的举措，采用新技术，创建新的数据库模式，重组逻辑，重写查询，并将数百万（如果不是数十亿）的数据库记录迁移到[PostgreSQL](https://www.postgresql.org/)。这是一个复杂的过程，但这绝对是必要的，也是为了平台的进步。

这就是我们为什么从[MongoDB](https://www.mongodb.com/)迁移到PostgreSQL的决策背后的故事，以及我们是如何做到的。希望这对于那些有一天也在考虑类似数据库迁移的人们来说是一个有趣且有用的阅读材料。

## [](#where-we-started)我们的起点

当我们第一次构建Infisical时，我们选择了团队最熟悉的技术栈。作为其中的一部分，我们选择了MongoDB + [Mongoose ORM](https://mongoosejs.com/)，因为这种组合的开销最小，允许我们快速发布高质量的功能。正如Tony Hoare先生所说，“[过早优化是万恶之源](https://stackify.com/premature-optimization-evil/)”，那时确实不需要进一步优化。

当时，我们更专注于构建[Infisical Cloud](https://infisical.com/)，这是一种托管的SaaS产品，考虑到这一重点，我们并没有预料到会有这么多用户自托管产品，因此产品设计并未考虑到这种使用情况。

## [](#why-not-mongodb)为什么不使用 MongoDB？

虽然MongoDB在早期阶段为Infisical服务得很好，但当我们产品的用例超出托管服务的范围时，它开始显露出不足之处。随着时间的推移，我们发现许多组织，特别是在合规性和安全性交汇处运营的组织，更倾向于自托管Infisical，而不是使用Infisical Cloud；其他组织有本地部署的要求需要满足。

随着对自托管 Infisical 的需求增长，我们发现自己不得不发布许多旨在减少自托管 Infisical 所需学习曲线的功能，作为其中的一部分，我们最终选择放弃了MongoDB，转向了PostgreSQL。

在实践中，我们和客户经常遇到 MongoDB 功能和可用性的限制，比如不支持[事务](https://en.wikipedia.org/wiki/Database_transaction)，清理问题，云提供商管理产品的版本不一致，更不用说与无模式数据库设计结构相关的问题了。

我在下面更详细地阐述了其中的一些挑战：

+   配置数据库事务的困难：使用 MongoDB，设置事务并不容易，因为它需要在集群模式下运行 MongoDB，并带有各种配置开销；例如，这使得客户无法仅通过运行 MongoDB 的生产设置来运行 Infisical 的简单 POC。对于处理高度敏感数据且数据完整性至关重要的产品而言，这是不可接受的。

+   缺少关系型特性：使用 MongoDB，我们失去了来自关系型世界许多优秀特性，比如`CASCADE`，当指定时，删除目标资源时跨其他表删除所有引用资源；这特别痛苦，因为我们的数据非常关系型。因此，我们在旧代码库中使用了庞大的删除函数，但从未完全完成任务，导致 MongoDB 数据库中留下了悬空资源。

+   在云提供商间缺乏支持：在 MongoDB 的许可证变更为 SSPL 后，许多云提供商选择提供较旧的 MongoDB 版本。因此，我们发现很难确保除最新稳定版本外，运行 Infisical 的客户能够使用全部功能。

+   缺乏 MongoDB 经验：由于更多人熟悉部署基于 SQL 的数据库，他们经常在尝试扩展和正确配置 MongoDB 时遇到困难；这导致我们需要为客户提供的支持大幅增加，特别是因为他们对 MongoDB 不熟悉。

在诸多原因中，我们意识到，将完整数据库迁移到更通用的解决方案是使 Infisical 更易于全球团队和组织使用的最终所需功能。

## [](#why-postgresql)为什么选择 PostgreSQL？

在寻找新数据库时，我们首先列出了对我们最重要的方面：管理的便捷性（即配置、部署和扩展包括在内）、内建的事务支持以及关系型能力。作为讨论的一部分，我们还在考虑是构建自己的集成存储解决方案还是追求外部存储解决方案。

这就是每个选项的含义：

+   集成存储：我们可以直接将像[SQLite](https://www.sqlite.org/)这样的数据库系统打包到Infisical中，并采用水平复制策略，通过避免额外的网络跳跃来降低延迟。在这种模型中，扩展系统意味着部署多个Infisical实例，并通过某种[共识算法](https://en.wikipedia.org/wiki/Consensus_(computer_science))如[Raft](https://en.wikipedia.org/wiki/Raft_(algorithm))使它们相互通信。尽管这似乎是一个很好的解决方案，因为客户无需连接任何依赖项即可运行Infisical，但实现此愿景所需的工具生态系统尚显不成熟，工程化工作也感觉异常繁重。

+   外部存储：我们可以简单地将MongoDB替换为像PostgreSQL或MySQL这样的其他数据库，并利用其内置的扩展能力。虽然这种解决方案并未完全消除使用Infisical所需的外部依赖的摩擦，但我们认为它已经通过不使用MongoDB带来了显著的好处。在支持单个或多个数据库时，我们觉得支持多个数据库会意味着错过每种解决方案的独特优势；这也会增加我们的工程负担。

在仔细考虑后，我们选择了PostgreSQL。除了拥有活跃的社区、广泛的文档和大量可用的解决方案和扩展之外，我们尤其欣赏它的开源性质以及绝大多数云服务提供商提供的PostgreSQL托管服务。

最重要的是，这意味着Infisical的用户可以更轻松地在任何云服务提供商上自行托管我们的平台，并与相应的托管PostgreSQL服务配对使用。此外，考虑到这种数据库的广泛采用，我们有信心用户在使用Infisical时操作它会更加轻松。

## [](#what-about-the-orm)ORM怎么办？

在决定使用PostgreSQL之后，我们需要弄清楚我们的应用程序将如何与数据库交互。从一开始，我们希望有类似于我们在MongoDB中使用Mongoose ORM的体验。因此，我们开始根据成熟度、可视化和迁移支持以及适当的抽象级别评估候选者；我们主要考虑了[Drizzle ORM](https://orm.drizzle.team/)、[Prisma ORM](https://www.prisma.io/)、[TypeORM](https://typeorm.io/)和查询构建器[Knex.js](https://knexjs.org/)。

最后，我们决定使用 Knex.js，一个查询构建器，而不是 ORM，以便更好地控制数据库。虽然可以承认，使用原始 SQL 可能是最通用且最少抽象的方法，但我们觉得这种方法会太容易出错，并且维护起来相当繁琐，特别是在没有适当的 TypeScript 支持的情况下。此外，与纯 SQL 非常接近，Knex.js 还带有自己的用于种子数据和迁移的工具包，具有成熟的生态系统，拥有出色的文档和几乎任何可能的查询答案。再加上一些定制的 Zod 集成工作，我们设法使其达到了对 TypeScript 支持的满意水平。

在确定了数据库和 ORM 后，我们启动了一个过程，最终导致应用程序中数十个数据结构和数百个查询的重写。

## [](#how-did-we-plan-the-migration)我们是如何规划迁移的？

在代码重写的最后阶段，我们开始考虑如何在尽可能减少对 Infisical Cloud 平台干扰的情况下，进行从 MongoDB 数据到 PostgreSQL 的迁移操作。

鉴于 Infisical 在客户基础设施中的关键角色，我们立即排除了任何绝对停机的可能性。我们不得不做出妥协的地方是在短暂的迁移窗口期间禁止写操作（即客户无法创建或更新应用程序配置），以换取更高的数据完整性保证。考虑到客户主要从 Infisical 检索秘密，并且在第二秒更新其应用程序配置的可能性较小，这种权衡似乎是可以接受的。

接下来，关于实际的迁移操作，我们需要从 MongoDB 中导出数据，小心地进行转换，然后插入到 PostgreSQL 中。在审计迁移顺序时，我们遇到了许多挑战，例如确保从 NoSQL 的各种树状结构正确转换为其关系数据库的对应结构；对于像文件夹这样具有递归考虑的数据结构，这尤为敏感。我们还发现需要一种持久化的方式来存储和映射 MongoDB 中的标识符到 PostgreSQL 中的标识符；考虑到我们处理的数据量，内存中进行这些操作是行不通的。最后，我们决定使用 [LevelDB](https://leveljs.org/) 键值存储来协助标识符的存储和查找操作。借助它，我们将数据逐表地迁移到 PostgreSQL 中。

## [](#the-great-migration)大迁移

最后，我们准备进行迁移。此时，除了直接参与代码重写的人员外，还有很多人花费了一个急需的季度来改进 Infisical 的其他方面，包括进行前端更改、执行维护补丁、扩展客户功能以及撰写更好的文档。现在我们都重新聚集在一起，准备进行迁移，即用新的应用程序代码库替换旧的，并将数据从 MongoDB 迁移到 PostgreSQL。

作为准备工作的一部分，我们起草了详细的迁移检查清单及预期时间表。

在高层次上，计划大致如下：

+   在迁移前几周，我们通过电子邮件和应用内横幅提前通知用户关于即将进行的数据库升级。我们会对平台上的每个功能流程进行彻底测试，并进行迁移的试运行。

+   迁移本身将在一个六小时的窗口期内进行，只允许对平台进行读操作。在此期间，我们将运行迁移脚本，将数据从 MongoDB 迁移到 PostgreSQL，检查是否丢失数据，并在成功后切换 DNS 到新实例。当然，如果出现问题，我们也有备份计划。

+   最后，在迁移后，我们将解决任何残留问题，并开始发布新的文档，以便使用 Infisical 和 PostgreSQL。

有了计划后，我们就开始执行。

### [](#results)结果

幸运的是，迁移执行非常顺利，没有数据丢失，仅有少量非关键性功能故障的问题；我们在接下来的36小时内解决了这些问题，对客户的影响最小化。

迁移后，我们观察到了许多好处：

+   平台经历了显著的性能提升，这主要归功于关联查询的查询优化。使用 MongoDB 时，平台经常进行低效的聚合查询和多次网络跳跃来实现所需功能。例如，由于我们核心数据的关系特性，我们经常需要执行多个 `$lookup` 操作来模拟 SQL 中的连接操作；这些操作效率低下，并且经常需要我们相应地扩展数据库和应用实例。转向 PostgreSQL 后，我们避免了这些低效操作，这也导致我们的数据库账单减少了 50%。

+   现在，平台在数据库层面实现了更好的数据验证，而不是在应用程序层面。由于 MongoDB 的设计是无模式的，它依赖于 Mongoose 框架来定义数据类型、必填字段和验证规则。现在有了 PostgreSQL，我们不再面临数据一致性问题，以前如果在 Mongoose 视野之外访问或修改数据库，可能会出现数据不一致。

+   最后但也最重要的是，我们认为现在自主托管Infisical要容易得多，客户可以进行POC而无需额外的配置开销，比如在MongoDB中处理副本集以启用事务功能。

总体而言，考虑到手头的目标、任务的范围以及结果的执行，我们认为这项倡议非常成功。一旦我们手头有更多数据，我们打算在未来发布更具体的结果。

## [](#conclusion)结论

从一开始决定从MongoDB迁移到PostgreSQL并不容易。总体而言，我们花了3-4个月的时间进行精心规划和讨论，包括为什么需要执行它，如何执行它；然后小心地执行。对于任何阅读此文的人，我强烈建议在尝试这样一项重大事业之前深入思考用例和实施。总的来说，我非常高兴一切都按计划进行，我们能够推出如此重要的更新，这将对Infisical的用户带来重大改变。

非常感谢[Akhil Mohan](https://www.linkedin.com/in/akhilmhdh/)全力支持迁移倡议，以及Infisical的所有其他人员在此过程中的协助。
