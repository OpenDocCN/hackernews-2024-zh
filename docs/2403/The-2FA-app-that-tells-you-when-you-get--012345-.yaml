- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 12:42:25'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: The 2FA app that tells you when you get `012345`
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://jacobbartlett.substack.com/p/building-a-2fa-app-that-detects-patterns](https://jacobbartlett.substack.com/p/building-a-2fa-app-that-detects-patterns)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you love apps but hate reading, skip ahead to download **[Check ’em: The
    Based 2FA App](https://apps.apple.com/app/check-em-the-based-2fa-app/id6477842236)**
    today!'
  id: totrans-split-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Like all recovered edgelords who came of age in the early 2010s, I somewhat
    miss the heyday of image-boards like 4chan. They were the final bastion of the
    wild-west early internet before the nazis ruined everything.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: One of the classic memes was [GET](https://knowyourmeme.com/memes/get), where
    you’d take intense pride in correctly anticipating your randomly-generated post
    ID containing an interesting sequence of numbers.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: These days, now that [all the normies have grown up and found jobs](https://www.wired.co.uk/article/moot-joins-google),
    the closest we get to the magic of yesteryear is multi-factor authentication codes.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: If you know, *you know*.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: The drudgery of having to re-authenticate with your bank, your email, or your
    cloud services. The little glimmer of joy when you get a really *nice* number
    like `787000` or `123450`.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Inspiration hit.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: These MFA codes use a common algorithm which refreshes every 30 seconds. We’re
    only exposed to a tiny sliver of the dubs, trips, quads, quints, and sextuples
    possible in our 6-digit authentication codes.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: 'As with [all my indie projects](https://jacobbartlett.substack.com/p/my-toddler-loves-planes-so-i-built),
    I had a singular clear vision around which I can build:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: What if your 2FA app told you every time a cool number came up?
  id: totrans-split-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I knew what I had to do.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: I don’t need many moving parts to find out whether this works.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: 'If the concept — getting notifications when cool 2FA numbers appear — holds
    up, then I could turn this into a real app with a few key features:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: Capture 2FA secrets with the camera.
  id: totrans-split-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store multiple 2FA codes
  id: totrans-split-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement more numerical patterns.
  id: totrans-split-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let users choose which patterns they want to know about.
  id: totrans-split-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I knew I was onto something: 90% of the people I explained this to thought
    I was a moron. The other 10% saw only sheer brilliance.'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s me: moron to some; genius to others.'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '[TOTP](https://www.protectimus.com/blog/totp-algorithm-explained/), or *time-based
    one-time password*, is a surprisingly simple concept. It’s an authentication process
    which uses two inputs:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: A secret key, stored on both the authentication service and your own device.
  id: totrans-split-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current time, or, more specifically, the number of 30-second intervals which
    have elapsed since unix time.
  id: totrans-split-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An algorithm deterministically hashes these two inputs to create the 6-digit
    codes you know and love. This hashing algorithm is pretty cookie-cutter, found
    in Apple’s CryptoKit. Thanks to our friends at the [Apple forums](https://forums.developer.apple.com/forums/thread/120918),
    here’s the full TOTP algorithm in all its glory:'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To make sure this worked right; I set up 2FA on my [Google](https://myaccount.google.com/)
    account, and displayed the secret in my app using the algorithm.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: Coincidentally, I got a damn good code with which to confirm my 2fa setup
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: And, like magic (after some annoying base32 to base64 conversion), Google accepted
    my 2FA!
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve got the bare bones of our 2FA working, we can implement the
    final piece of the proof of concept puzzle: generating notifications.'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: Our key limitation lies in our mobile device.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: We can’t actually keep a background process such as 2FA generation running forever,
    and *certainly* can’t store user secrets on a backend push server.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to make this concept work, we have to be a sneaky: precompute 2FA
    codes into the future, and schedule delivery for the time at which they appear
    in real life.'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can only schedule 64 pushes on iOS at any time, so we should:'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: Save a notification or two asking users to re-enter the app.
  id: totrans-split-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incentivise users to open the app via tapping the notifications, toggling a
    re-computation of the 2FA codes.
  id: totrans-split-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we know how our POC will work, let’s get building.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: Let’s jazz up our lowly 2FA code.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: We plan to pre-compute many codes, then implement some kind of regex to detect
    whether each code is a GET — worthy of checking ‘em.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: My super-simple SwiftUI view can display these codes handily, using a `UICollectionView`-backed
    `List` to ensure decent performance (the vanilla `VStack` in a `ScrollView` would
    begin creaking far before 10,000 items!).
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looking good so far.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: Initial list of 2FA codes
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can add a simple regex-based evaluator to check for trips — that is,
    a TOTP containing a sequence of three matching digits such as `120333`.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We add a `fontWeight` modifier to our `Text` views to easily detect these GETs
    when we’re scrolling.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Et viola! *Check those trips*!
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: We can even make a basic modification to the our regex to detect the hallowed
    *quads* — I’ll leave this as an exercise to the reader.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Our careless `ForEach` implementation causes a warning:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We actually get dozens of this warning!
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: Using the code string as a view identity is a bad idea here
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
- en: Since we generated 10,000 OTPs, it’s extremely likely that several match — this
    is the same as the [birthday problem](https://en.wikipedia.org/wiki/Birthday_problem),
    where the number of pairs of possible matches is well over a million.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start calculating some interesting codes.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: 'The key here is precomputing to look ahead into the future: TOTP is a deterministic
    hash of the secret and date inputs. Therefore, we can feed a long sequence of
    dates in the future to determine which OTP code you see at what time.'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s adjust to our OTP generation to return both the code and date:'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To test this, let’s generate a ton of these codes, and search for the full-house
    of GETs: *quints*.'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After some number crunching while my M1 runs the hashing function — about 30
    seconds of it — we arrive at some seriously checkable GETs.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: It’s… it’s beautiful. Check ’em.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: Fun as it is to see great numbers, the app concept is no better than a random-number
    generating machine if you can’t really use the GETs in real life for your real
    authentication.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know when the interesting numbers are arriving, we want to queue
    up a push notification so we catch the number live:'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These are scheduled right after generating the `interestingCodes` we use in
    our view. A short while later, I got 2 wonderful push notifications at once!
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: I still tell my wife every single time I get a subscriber
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: This became more exciting when I confirmed this notification corresponded with
    the number appearing in reality!
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: Finding quads in the 2FA app itself
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: 'This app has now been elevated beyond a random number generator: this code
    really works for signing into my Google account.'
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine different types of interesting number, we need to introduce the
    concept of *interestingness*. This could include, non-exhaustively, a few potential
    kinds of number sequence:'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: These types of interesting number can be enumerated as… well, as an enum case,
    optionally created for each OTP we generate.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each `checkThose` method we use wraps a different regex, and we run them in
    order of what we care about most — for instance, sextuples is 100x rarer than
    quads.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: 'A long-overdue refactor later and we’ve created our proof-of-concept. Let’s
    recap:'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: The app allows me to enter a (hardcoded) 2FA secret key.
  id: totrans-split-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app generates a 6-digit 2FA code locally, every 30 seconds.
  id: totrans-split-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app schedules push notifications that show up when quads, quints, and sexts
    are generated.
  id: totrans-split-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m going to take a break to play with the app for a few days. I suspect I might
    have the basis for a cool app on my hands.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: I’ve been using the app, the bare-bones POC containing the kernel of my idea,
    for a few days now. And I *LOVE* it. I can’t wait until the first time I get sextuples.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Now’s the time to add some meat on the bones and build a fully-fledged 2FA
    app around the concept. As I laid out before, this really only requires 4 major
    new features:'
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: Scanning 2FA QR codes and store them securely on the keychain.
  id: totrans-split-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and managing multiple 2FA accounts in the UI.
  id: totrans-split-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letting users set the numbers they care about.
  id: totrans-split-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing more kinds of *interestingness*.
  id: totrans-split-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, a non-functional requirement: I’ll need to do some work optimising
    the very slow code generation — maybe using batching or local persistence.'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
- en: I have no intention of doing anything fancy with the design — the standard apple
    `List` view components will take me far, conforming to the [HIG](https://developer.apple.com/design/human-interface-guidelines)
    out of the box.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s keep our UX nice and simple: I know the functionality primarily lives
    in the push notifications; and it’s pretty perfect. That means hiding the QR scanner
    and settings behind toolbar buttons that display modal flows.'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: The basic List UI for my MVP
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
- en: A couple of open-source libraries will save me a ton of time on cookie-cutter
    tasks. [CodeScanner](https://github.com/twostraws/CodeScanner/) to supply simple
    SwiftUI QR code scanning, and [KeychainAccess](https://github.com/kishikawakatsumi/KeychainAccess)
    to easily store these 2FA account secrets in the keychain.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 几个开源库将为我节省大量处理重复任务的时间。[CodeScanner](https://github.com/twostraws/CodeScanner/)
    提供简单的 SwiftUI QR 码扫描功能，而 [KeychainAccess](https://github.com/kishikawakatsumi/KeychainAccess)
    则轻松存储这些双因素认证账户的密钥。
- en: 'This scanner library uses camera access to turn QR codes into easily-parseable
    URLs like this:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扫描库使用摄像头访问将 QR 码转换为易于解析的 URL，如下所示：
- en: '[PRE9]'
  id: totrans-split-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we can easily get our accounts into the app!
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地将我们的账户导入到应用中！
- en: 'Check ’em: now with a QR scanner!'
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 看看它们：现在带有 QR 扫描器！
- en: Using SwiftUI `@AppStorage`, alongside a `List` and some `Toggle`s, we can easily
    build a user settings screen.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SwiftUI 的 `@AppStorage`，以及一些 `List` 和一些 `Toggle`，我们可以轻松地构建用户设置屏幕。
- en: I used a closure in `onDisappear` to tell the parent view to begin number crunching
    again and re-schedule the notifications. This was the simplest way I to batch
    everything up, rather than running expensive computation each time a toggle changed.
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 `onDisappear` 中使用闭包来告诉父视图重新开始数值计算并重新安排通知。这是我批处理所有内容的最简单方法，而不是每次切换变化时运行昂贵的计算。
- en: '[PRE10]'
  id: totrans-split-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Look, I’m an indie dev, I’m allowed to do this halfway through the build process!
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 瞧，我是一个独立开发者，我可以在构建过程中做到这一点！
- en: I decided to download a few other 2FA apps to see if there were any ideas I
    could copy. Frankly, I expected a pretty crowded and competitive app market, but
    some of these were truly terrible.
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定下载几款其他的双因素认证应用程序，看看有没有可以借鉴的点子。坦率地说，我预料到市场上会有相当拥挤和竞争激烈的应用程序，但有些应用真的非常糟糕。
- en: 'The 2FA app space: mostly astonishingly bad'
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 双因素认证应用领域：大多数情况下非常糟糕
- en: Seriously, more than 50% of them threw up an extremely aggressive paywall before
    you could use them… when there are perfectly good free options.
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 真的，超过 50% 的应用在您使用之前会弹出极具攻击性的付费墙……明明有完全免费的好选择。
- en: Does nobody make apps for fun anymore?
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 没人再为了好玩而开发应用了吗？
- en: Despite this paywall menagerie, I did manage to note down a few good ideas to
    borrow.
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这么多的付费墙，我确实设法记下了一些可以借鉴的好点子。
- en: This is, of course, pretty critical for anyone that has more than one account.
    More accounts also means more opportunities for rare GETs!
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于拥有多个账户的任何人来说当然是相当关键的。更多账户也意味着更多机会来获取稀有的 GET 请求！
- en: Updating my keychain code, now we can scan multiple QR codes, persisted our
    account data (including the secret), and they worked perfectly for logging me
    into my various accounts!
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 更新我的钥匙链代码，现在我们可以扫描多个 QR 码，持久化我们的账户数据（包括密钥），并且它们完美地用于登录我的各种账户！
- en: I also implemented the proper built-in `List` functionality, so we can swipe-to-delete
    codes we don’t need anymore.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我还实现了正确的内置 `List` 功能，因此我们可以滑动删除不再需要的验证码。
- en: While doing my competitor analysis, I discovered that the Google Authenticator
    kept all my 2FA codes from years ago, which I’d added on my previous iPhone!
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行竞争对手分析时，我发现 Google Authenticator 保存了我多年前添加的所有双因素认证码，这些码是我之前的 iPhone 上添加的！
- en: I realised then I was making two mistakes with my data layer.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那时我意识到自己在数据层面犯了两个错误。
- en: 'Firstly, synchronising our keychain to iCloud means accounts appear on all
    your other Apple devices. This is a piece of cake with the Keychain Access library:'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将我们的钥匙链同步到 iCloud 意味着账户会出现在您的其他所有苹果设备上。使用 Keychain Access 库非常简单：
- en: '[PRE11]'
  id: totrans-split-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Secondly, I was suffering from shiny-object syndrome: in my haste to use SwiftData
    as a persistence layer, I was only using the Keychain for the secrets, and persisting
    the rest of the Account metadata through the new framework.'
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在我匆忙地选择 SwiftData 作为持久化层时，我患了“闪烁物体综合症”，只使用钥匙链保存密钥，通过新框架持久化其余的账户元数据。
- en: This meant I couldn’t get my accounts on any other device — the secret on its
    own is useless!
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我无法将我的账户信息同步到任何其他设备上——只有密钥本身是无用的！
- en: Therefore, I realised I had to place the whole `Account` on the keychain.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我意识到必须将整个 `Account` 放在钥匙链上。
- en: My new approach keeps the QR code URL on the keychain in its entirety. Now,
    the `Account` object itself is ephemeral; re-computed from the URL every time
    the app loads.
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我的新方法将 QR 码的完整 URL 保存在钥匙链中。现在，`Account` 对象本身是暂时的；每次应用程序加载时都从 URL 重新计算。
- en: 'This means the `Account`s can appear on any iDevice you’re signed in to! This
    ephemeral approach neatly kills two birds with one stone. Now we use the Accounts
    from the keychain when we need to fetch them at load:'
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: My code is a little bit spaghetti, but the final app was about 1,500 LoC in
    total — I’ll rebuild it using a proper DI framework when I want to write an article
    about DI. If you’re a junior engineer, please don’t try this at home!
  id: totrans-split-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I did a lot of generic coding work to improve the UI and refactor the code nicely,
    but there were also a few gems in my development process that were pretty interesting.
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
- en: This is very much a nice to have, but the best open-source app did the same,
    so I felt I had to *at least* be as good as that.
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is a little-known Google API which crawls the web for FavIcons
    on websites and allows you to download them at several resolutions.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
- en: How do I work out the website? I found pretty good results by simply using the
    `issuer` property on the QR code and trying the`.com`.
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-split-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here I used the [CachedAsyncImage](https://github.com/lorenzofiamingo/swiftui-cached-async-image)
    library to get blazingly-fast loading performance on the icons.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
- en: Images for each 2FA account
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
- en: I also added a Metal shader to handle background removal, and make the icon
    pop a little more.
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the SwiftUI View extension:'
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-split-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And of course the MSL shader code:'
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-split-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here’s how they look. They’re not bad, but not amazing.
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
- en: Metal shaders to remove the white backgrounds on the icons
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
- en: I’ve started over-engineering. Let’s stick a pin in this and see how we feel
    later.
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
- en: It’s working pretty well now as a basic 2fa app in its own right.
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
- en: Who would have thought that to be ahead of most of the pack, I just had to not
    have an extremely aggressive paywall ($4.99 per week? Seriously?!)
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
- en: After some boilerplate software development work on the timings, the basic UI,
    and the data storage, it’s really working quite nicely now — sticking to the basic
    SwiftUI components is a brilliant way to ensure stuff *“just works”**.
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
- en: '*and helps make everything accessible!'
  id: totrans-split-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I also implemented some nice QoL features I found through my competitor research
    such as tap-to-copy.
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
- en: I utilised accessibility tools like `@ScaledMetric` and `ViewThatFits` to ensure
    the app works great regardless of your visual needs. I even get light mode for
    free out of the box by sticking closely to Apple’s basic SwiftUI components and
    colours.
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-split-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Check ’em at the largest accessibility font size
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the true core value proposition, I implemented a lot more options
    for interestingness:'
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
- en: Sexts, quints, and quads like `000000`
  id: totrans-split-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting sequences like `012345`
  id: totrans-split-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hundred-thousands like `300000`
  id: totrans-split-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Units like `000001` and tens like `000010`
  id: totrans-split-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maths constants like pi (`314159`)
  id: totrans-split-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics constants like Planck's constant, `661034` (6.6x10⁻³⁴)
  id: totrans-split-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Palindromes like `012210`
  id: totrans-split-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeated twos and threes like `121212` and `123123`
  id: totrans-split-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these were fun little leet-code puzzles to implement, some were annoying
    regexes, while some were very straightforward.
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-split-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now I’ve updated the Settings UI so that you can sort by either rarity (common,
    rare, and ultra-rare), or by type (such as repetitions, constants, sequences,
    or round numbers).
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
- en: Toggle on the Settings menu
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
- en: How do I calculate the probabilities of each rarity level?
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
- en: For perfect counting sequences like `012345`, there are only 6 possible sequences
    (up to `567890`) out of one million possible number combinations.
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
- en: 30 seconds times 1 million combinations, divided by 6 possible sequences, means
    for each account you might only expect a perfect counting sequence to occur on
    average every 5 million seconds — that is, **every 58 days** on average.
  id: totrans-split-159
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty ultra rare.
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
- en: However, palindromes such as `123321`, have 1000 possible 3-sequence numbers
    that make them up. This means you could see them **every 0.34 days** on average!
    Much more common.
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
- en: In the middle, something like repeated twos (e.g. `141414`) have 100 possible
    numbers (`00` to `99`), so they happen **every 3.5 days** on average. So, pretty
    rare, but not *ultra*-rare.
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
- en: Some of these sequences, like quads, are a little tougher to number crunch,
    so it was simpler to generate tens of millions of OTPs and counting the incidence
    of each kind of interestingness, to get a feel for their relative frequency.
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
- en: The app can process 64 interesting 2FA codes quite quickly, but only when I
    have all the common `Interestingness`enabled. When I only want ultra-rare GETs,
    the processing takes a long time.
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
- en: I need to invoke chunking — while crunching through millions of potential OTPs,
    returning and scheduling a notification as soon as a valid interesting code is
    discovered.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
- en: My old friend the `Combine` framework gives us a neat solution!
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-split-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I also used some `Task`s so that we can cancel and re-start computation in case,
    for instance, a user changes their settings mid-processing. Detaching the tasks
    ensures the heavy processing for our crypto and string analysis operations keeps
    off the UI thread.
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-split-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now the scheduling works pretty smoothly, coming out in sequence instead of
    a single large chunk!
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-split-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This was the one that got away killed me. I’m desperate to use the real check
    ’em meme for the app icon. It’s simply perfect.
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
- en: However, my good friend pointed out that our friends over at Lionsgate films
    might be feeling a little litigious.
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
- en: '*But I had to have it!*'
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps there is hope after all:'
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
- en: Unlike you, I have faith in the American copyright system.
  id: totrans-split-176
  prefs: []
  type: TYPE_NORMAL
- en: Partially completed form for requesting permission to use a still from a movie
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
- en: Now we play the waiting game.
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
- en: Crickets.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
- en: I’ve lost all faith in the American copyright system. Goddammit, Bob Iger, whatever
    happened to fair use?!
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
- en: This is the best I could get from DALL-E 3\. It has the wrong number of fingers,
    and it’s the wrong side of the hand, but after trying to prompt-engineer something
    better for several hours I am resigned to it.
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
- en: DALL-E *really* didn’t like drawing the back of a hand. I tried.
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: DALL-E真的不喜欢画手背。我试过了。
- en: The concept was proven. The app works well! Time for some polish and pet features
    before we show the world the joy of Check ‘em.
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念得到了验证。应用运行良好！现在是时候进行一些润色和个人特性的工作，然后我们向世界展示Check 'em的乐趣了。
- en: I created a list of TODOs — new features and bug-fixes — that I could implement
    in my V1 before I made my first release.
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个TODO列表——新功能和bug修复——在发布第一个版本之前我可以在我的V1中实现它们。
- en: '[PRE21]'
  id: totrans-split-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Naturally, since I don’t have a product manager in sight, I immediately began
    work on the lowest-priority task: building out a collection with deep links — I
    don’t want my rare GETs to go to waste!'
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，由于我眼前没有产品经理，我立即开始处理优先级最低的任务：通过深链接来构建收藏——我不想让我的稀有GET浪费掉！
- en: 'This piece actually helps with a problem we identified original proof of concept:
    we need to incentivise users to re-enter the app by making users interact with
    the notifications.'
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这件事实际上有助于我们解决了最初的概念验证中遇到的一个问题：我们需要通过让用户与通知交互来激励他们重新进入应用程序。
- en: 'Creating a collect-a-thon is a little tricky, because there are a few moving
    parts:'
  id: totrans-split-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个收集任务有点棘手，因为涉及到一些移动的部分：
- en: Allow users to tap on notifications and deep link into the app.
  id: totrans-split-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户点击通知并深入链接到应用程序。
- en: Securely store the interestingness of the code they tapped.
  id: totrans-split-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全地存储他们点击的代码的有趣程度。
- en: Render these into a collection screen.
  id: totrans-split-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染这些成一个集合屏幕。
- en: Adding a deep link to the notification was fairly simple.
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
  zh: 给通知添加一个深链接相当简单。
- en: '[PRE22]'
  id: totrans-split-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But, a little annoyingly, I had to create an `AppDelegate` to handle the notifications — SwiftUI
    doesn’t quite handle these well on its own yet.
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但有点让人恼火的是，我不得不创建一个`AppDelegate`来处理通知——SwiftUI目前还不能很好地处理这些。
- en: '[PRE23]'
  id: totrans-split-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, I lazily added a long, comma-separated list of stored codes in the
    Keychain.
  id: totrans-split-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我懒惰地添加了一个长长的、逗号分隔的存储代码列表到钥匙串中。
- en: '[PRE24]'
  id: totrans-split-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This was more a product of a desire to release fast rather than a well-thought-out
    engineering decision, one I will come to regret if my power-users approach the
    soft limit of 4kB per Keychain item (the hard limit is more like 16MB, so I should
    be okay!).
  id: totrans-split-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这更多是出于快速发布的愿望，而不是深思熟虑的工程决策，如果我的超级用户接近每个钥匙串项目4kB的软限制，我将会后悔（硬限制更接近16MB，所以我应该没问题！）。
- en: This work paid off rapidly though, as the collection screen quickly started
    filling up with my rare GETs!
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作迅速取得了回报，因为收藏屏幕很快就开始填满我的稀有GET！
- en: Collection menu containing all your rare GETs
  id: totrans-split-200
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有稀有GET的收藏菜单
- en: I originally hid the collection until a user had tapped a notification, but
    I realised it was far more compelling to entice a user to collecting ’em all by
    showing them the menu option.
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初隐藏了收藏品，直到用户点击了通知，但后来我意识到通过显示菜单选项来诱使用户收集所有内容更具吸引力。
- en: The iOS 17 `sensoryFeedback` API gives us some extremely subtle haptics to play
    with, so subtle in fact that I didn’t like them. So I ripped out the Haptic Engine
    from Carbn and reused it here.
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 17的`sensoryFeedback` API为我们提供了一些极其微妙的触觉反馈，实际上如此微妙，以至于我不喜欢它们。所以我从Carbn中删除了触觉引擎并在这里重复使用。
- en: 'I simply added a truly atrocious side effect to my existing refresh code:'
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是在现有的刷新代码中添加了一个真正可怕的副作用：
- en: '[PRE25]'
  id: totrans-split-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Don’t try this at home, kids!
  id: totrans-split-205
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子们，不要在家里尝试这个！
- en: There’s a bug where the `CachedAsyncImage` library is eagerly loading the non-existent
    FavIcons, yielding a blurry globe… But I think I will release with this.
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个bug，`CachedAsyncImage`库急切加载不存在的FavIcons，导致一个模糊的地球… 但我想我会发布这个版本。
- en: It works pretty much 90% of the time, and I’d rather ship than replace one of
    my pet third-party SwiftUI libraries.
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作效果基本上是90%，我宁愿发货，而不是替换我心爱的第三方SwiftUI库之一。
- en: FavIcon not found for steam.com
  id: totrans-split-208
  prefs: []
  type: TYPE_NORMAL
  zh: steam.com找不到FavIcon
- en: Some of the other bugs, I was a little more attentive to before shipping — this
    one in particular was pretty bad, since someone might scan a QR code twice and
    get a weird duplicate of the same account.
  id: totrans-split-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在发货之前，我对其他一些bug更加注意了——特别是这个bug很糟糕，因为有人可能会扫描两次QR码，得到相同账户的怪异重复。
- en: '[PRE26]'
  id: totrans-split-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Far from ripping out and replacing a time-saving library, this bug had a single-line-of-code
    fix.
  id: totrans-split-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与更换节省时间的库相去甚远，这个bug只需要一行代码来修复。
- en: '[PRE27]'
  id: totrans-split-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since the Keychain is keying 2FA accounts based on the name, this fix is pretty
    sensible.
  id: totrans-split-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Keychain是基于名称对2FA账户进行索引，所以这个修复非常合理。
- en: I found another issue with codes not being queued.
  id: totrans-split-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现另一个代码未排队的问题。
- en: '[PRE28]'
  id: totrans-split-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It turns out, I misunderstood how `@AppStorage` actually behaves — the default
    only applied to the UI, as opposed to actually storing something in user defaults.
  id: totrans-split-216
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我误解了`@AppStorage`的实际行为——默认值只应用于UI，而不是实际存储在用户默认中。
- en: '[PRE29]'
  id: totrans-split-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A function to populate UserDefaults on the first app load solved this.
  id: totrans-split-218
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，在第一次加载应用程序时填充UserDefaults解决了这个问题。
- en: '[PRE30]'
  id: totrans-split-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One little bit of improvement used the new iOS 17 TipKit to give a user a bit
    of an idea of what to do when they first load into the app.
  id: totrans-split-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过新iOS 17 TipKit做了一点小改进，为用户提供了关于首次加载应用程序时应该做什么的一点想法。
- en: Tips displayed on first launch
  id: totrans-split-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次启动时显示的提示
- en: This was surprisingly simple to implement with the new API.
  id: totrans-split-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这实施起来出乎意料地简单，借助新API。
- en: '[PRE31]'
  id: totrans-split-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I think we’re ready to ship.
  id: totrans-split-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们准备好要发布了。
- en: Setting up our store listing via [AppScreens](https://appscreens.com/), the
    coup de grâce second screenshot shows the true power of Check ’em (featuring my
    cats).
  id: totrans-split-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[AppScreens](https://appscreens.com/)设置我们的商店列表，决定性的第二张截图展示了Check 'em的真正力量（展示了我的猫）。
- en: Seriously?
  id: totrans-split-226
  prefs: []
  type: TYPE_NORMAL
  zh: 真的吗？
- en: Sorry France, I don’t have the energy to fill in a form at 11pm at night 🤷‍♂️
  id: totrans-split-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对不起法国，我没有精力在晚上11点填写表格 🤷‍♂️
- en: Look, I’m not the most libertarian person in the world, but I don’t want to
    jump through several extra hoops to increase my target market by 1%. Do better!
  id: totrans-split-228
  prefs: []
  type: TYPE_NORMAL
  zh: 听着，我并不是世界上最自由主义的人，但我不想为了将目标市场增加1%而跳过几个额外的障碍。请做得更好！
- en: '*(Sorry to all my French readers)*'
  id: totrans-split-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*(对我所有的法国读者说抱歉)*'
- en: In short order, we’re set up on App Store Connect and ready to press the button!
  id: totrans-split-230
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们在App Store Connect上设置好并准备好按按钮！
- en: Thanks for reading along with my journey!
  id: totrans-split-231
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢你一路上与我同行！
- en: 'This was a pretty fun project: not only did I manage to tickle the part of
    my geek brain which loves spotting patterns; I got to handle some nifty processing,
    threading, and optimisation problems!'
  id: totrans-split-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当有趣的项目：不仅让我能够激发我那爱发现模式的极客大脑；我还处理了一些巧妙的处理、线程和优化问题！
- en: My next step is [focusing fully on performance](https://jacobbartlett.substack.com/p/high-performance-swift-apps)
    for the `v1.1` release, so it loads up crunches the OTPs even faster than normal!
  id: totrans-split-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我接下来的步骤是[全力提升性能](https://jacobbartlett.substack.com/p/high-performance-swift-apps)，以便在`v1.1`版本中，它加载并处理一次性密码比正常更快！
- en: If you love this app, please give your suggestions on numbers you’d like to
    see! Finally, if anyone is keen to see an Android version, I’m more than happy
    to share my source code let you to run with it.
  id: totrans-split-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这个应用程序，请提出你想看到的数字建议！最后，如果有人想看到Android版本，我很乐意分享我的源代码让你跑一下。
