- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: Êú™ÂàÜÁ±ª'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 12:42:25'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: The 2FA app that tells you when you get `012345`
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Êù•Ê∫êÔºö[https://jacobbartlett.substack.com/p/building-a-2fa-app-that-detects-patterns](https://jacobbartlett.substack.com/p/building-a-2fa-app-that-detects-patterns)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you love apps but hate reading, skip ahead to download **[Check ‚Äôem: The
    Based 2FA App](https://apps.apple.com/app/check-em-the-based-2fa-app/id6477842236)**
    today!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Like all recovered edgelords who came of age in the early 2010s, I somewhat
    miss the heyday of image-boards like 4chan. They were the final bastion of the
    wild-west early internet before the nazis ruined everything.
  prefs: []
  type: TYPE_NORMAL
- en: One of the classic memes was [GET](https://knowyourmeme.com/memes/get), where
    you‚Äôd take intense pride in correctly anticipating your randomly-generated post
    ID containing an interesting sequence of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: These days, now that [all the normies have grown up and found jobs](https://www.wired.co.uk/article/moot-joins-google),
    the closest we get to the magic of yesteryear is multi-factor authentication codes.
  prefs: []
  type: TYPE_NORMAL
- en: If you know, *you know*.
  prefs: []
  type: TYPE_NORMAL
- en: The drudgery of having to re-authenticate with your bank, your email, or your
    cloud services. The little glimmer of joy when you get a really *nice* number
    like `787000` or `123450`.
  prefs: []
  type: TYPE_NORMAL
- en: Inspiration hit.
  prefs: []
  type: TYPE_NORMAL
- en: These MFA codes use a common algorithm which refreshes every 30 seconds. We‚Äôre
    only exposed to a tiny sliver of the dubs, trips, quads, quints, and sextuples
    possible in our 6-digit authentication codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with [all my indie projects](https://jacobbartlett.substack.com/p/my-toddler-loves-planes-so-i-built),
    I had a singular clear vision around which I can build:'
  prefs: []
  type: TYPE_NORMAL
- en: What if your 2FA app told you every time a cool number came¬†up?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I knew what I had to do.
  prefs: []
  type: TYPE_NORMAL
- en: I don‚Äôt need many moving parts to find out whether this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the concept‚Ää‚Äî‚Äägetting notifications when cool 2FA numbers appear‚Ää‚Äî‚Ääholds
    up, then I could turn this into a real app with a few key features:'
  prefs: []
  type: TYPE_NORMAL
- en: Capture 2FA secrets with the camera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store multiple 2FA codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement more numerical patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let users choose which patterns they want to know about.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I knew I was onto something: 90% of the people I explained this to thought
    I was a moron. The other 10% saw only sheer brilliance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That‚Äôs me: moron to some; genius to¬†others.'
  prefs: []
  type: TYPE_NORMAL
- en: '[TOTP](https://www.protectimus.com/blog/totp-algorithm-explained/), or *time-based
    one-time password*, is a surprisingly simple concept. It‚Äôs an authentication process
    which uses two inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: A secret key, stored on both the authentication service and your own device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current time, or, more specifically, the number of 30-second intervals which
    have elapsed since unix time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An algorithm deterministically hashes these two inputs to create the 6-digit
    codes you know and love. This hashing algorithm is pretty cookie-cutter, found
    in Apple‚Äôs CryptoKit. Thanks to our friends at the [Apple forums](https://forums.developer.apple.com/forums/thread/120918),
    here‚Äôs the full TOTP algorithm in all its glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To make sure this worked right; I set up 2FA on my [Google](https://myaccount.google.com/)
    account, and displayed the secret in my app using the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Coincidentally, I got a damn good code with which to confirm my 2fa¬†setup
  prefs: []
  type: TYPE_NORMAL
- en: And, like magic (after some annoying base32 to base64 conversion), Google accepted
    my 2FA!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we‚Äôve got the bare bones of our 2FA working, we can implement the
    final piece of the proof of concept puzzle: generating notifications.'
  prefs: []
  type: TYPE_NORMAL
- en: Our key limitation lies in our mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: We can‚Äôt actually keep a background process such as 2FA generation running forever,
    and *certainly* can‚Äôt store user secrets on a backend push server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to make this concept work, we have to be a sneaky: precompute 2FA
    codes into the future, and schedule delivery for the time at which they appear
    in real life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can only schedule 64 pushes on iOS at any time, so we should:'
  prefs: []
  type: TYPE_NORMAL
- en: Save a notification or two asking users to re-enter the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incentivise users to open the app via tapping the notifications, toggling a
    re-computation of the 2FA codes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we know how our POC will work, let‚Äôs get building.
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs jazz up our lowly 2FA code.
  prefs: []
  type: TYPE_NORMAL
- en: We plan to pre-compute many codes, then implement some kind of regex to detect
    whether each code is a GET‚Ää‚Äî‚Ääworthy of checking ‚Äòem.
  prefs: []
  type: TYPE_NORMAL
- en: My super-simple SwiftUI view can display these codes handily, using a `UICollectionView`-backed
    `List` to ensure decent performance (the vanilla `VStack` in a `ScrollView` would
    begin creaking far before 10,000 items!).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Looking good so far.
  prefs: []
  type: TYPE_NORMAL
- en: Initial list of 2FA¬†codes
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can add a simple regex-based evaluator to check for trips‚Ää‚Äî‚Ääthat is,
    a TOTP containing a sequence of three matching digits such as `120333`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We add a `fontWeight` modifier to our `Text` views to easily detect these GETs
    when we‚Äôre scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Et viola! *Check those trips*!
  prefs: []
  type: TYPE_NORMAL
- en: We can even make a basic modification to the our regex to detect the hallowed
    *quads*‚Ää‚Äî‚ÄäI‚Äôll leave this as an exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our careless `ForEach` implementation causes a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We actually get dozens of this warning!
  prefs: []
  type: TYPE_NORMAL
- en: Using the code string as a view identity is a bad idea¬†here
  prefs: []
  type: TYPE_NORMAL
- en: Since we generated 10,000 OTPs, it‚Äôs extremely likely that several match‚Ää‚Äî‚Ääthis
    is the same as the [birthday problem](https://en.wikipedia.org/wiki/Birthday_problem),
    where the number of pairs of possible matches is well over a million.
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs start calculating some interesting codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key here is precomputing to look ahead into the future: TOTP is a deterministic
    hash of the secret and date inputs. Therefore, we can feed a long sequence of
    dates in the future to determine which OTP code you see at what time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs adjust to our OTP generation to return both the code and date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this, let‚Äôs generate a ton of these codes, and search for the full-house
    of GETs: *quints*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After some number crunching while my M1 runs the hashing function‚Ää‚Äî‚Ääabout 30
    seconds of it‚Ää‚Äî‚Ääwe arrive at some seriously checkable GETs.
  prefs: []
  type: TYPE_NORMAL
- en: It‚Äôs‚Ä¶ it‚Äôs beautiful. Check¬†‚Äôem.
  prefs: []
  type: TYPE_NORMAL
- en: Fun as it is to see great numbers, the app concept is no better than a random-number
    generating machine if you can‚Äôt really use the GETs in real life for your real
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know when the interesting numbers are arriving, we want to queue
    up a push notification so we catch the number live:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These are scheduled right after generating the `interestingCodes` we use in
    our view. A short while later, I got 2 wonderful push notifications at once!
  prefs: []
  type: TYPE_NORMAL
- en: I still tell my wife every single time I get a subscriber
  prefs: []
  type: TYPE_NORMAL
- en: This became more exciting when I confirmed this notification corresponded with
    the number appearing in reality!
  prefs: []
  type: TYPE_NORMAL
- en: Finding quads in the 2FA app¬†itself
  prefs: []
  type: TYPE_NORMAL
- en: 'This app has now been elevated beyond a random number generator: this code
    really works for signing into my Google account.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine different types of interesting number, we need to introduce the
    concept of *interestingness*. This could include, non-exhaustively, a few potential
    kinds of number sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: These types of interesting number can be enumerated as‚Ä¶ well, as an enum case,
    optionally created for each OTP we generate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each `checkThose` method we use wraps a different regex, and we run them in
    order of what we care about most‚Ää‚Äî‚Ääfor instance, sextuples is 100x rarer than
    quads.
  prefs: []
  type: TYPE_NORMAL
- en: 'A long-overdue refactor later and we‚Äôve created our proof-of-concept. Let‚Äôs
    recap:'
  prefs: []
  type: TYPE_NORMAL
- en: The app allows me to enter a (hardcoded) 2FA secret key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app generates a 6-digit 2FA code locally, every 30 seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app schedules push notifications that show up when quads, quints, and sexts
    are generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I‚Äôm going to take a break to play with the app for a few days. I suspect I might
    have the basis for a cool app on my hands.
  prefs: []
  type: TYPE_NORMAL
- en: I‚Äôve been using the app, the bare-bones POC containing the kernel of my idea,
    for a few days now. And I *LOVE* it. I can‚Äôt wait until the first time I get sextuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now‚Äôs the time to add some meat on the bones and build a fully-fledged 2FA
    app around the concept. As I laid out before, this really only requires 4 major
    new features:'
  prefs: []
  type: TYPE_NORMAL
- en: Scanning 2FA QR codes and store them securely on the keychain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and managing multiple 2FA accounts in the UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letting users set the numbers they care about.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing more kinds of *interestingness*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, a non-functional requirement: I‚Äôll need to do some work optimising
    the very slow code generation‚Ää‚Äî‚Äämaybe using batching or local persistence.'
  prefs: []
  type: TYPE_NORMAL
- en: I have no intention of doing anything fancy with the design‚Ää‚Äî‚Ääthe standard apple
    `List` view components will take me far, conforming to the [HIG](https://developer.apple.com/design/human-interface-guidelines)
    out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs keep our UX nice and simple: I know the functionality primarily lives
    in the push notifications; and it‚Äôs pretty perfect. That means hiding the QR scanner
    and settings behind toolbar buttons that display modal flows.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic List UI for my¬†MVP
  prefs: []
  type: TYPE_NORMAL
- en: A couple of open-source libraries will save me a ton of time on cookie-cutter
    tasks. [CodeScanner](https://github.com/twostraws/CodeScanner/) to supply simple
    SwiftUI QR code scanning, and [KeychainAccess](https://github.com/kishikawakatsumi/KeychainAccess)
    to easily store these 2FA account secrets in the keychain.
  prefs: []
  type: TYPE_NORMAL
- en: 'This scanner library uses camera access to turn QR codes into easily-parseable
    URLs like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can easily get our accounts into the app!
  prefs: []
  type: TYPE_NORMAL
- en: 'Check ‚Äôem: now with a QR¬†scanner!'
  prefs: []
  type: TYPE_NORMAL
- en: Using SwiftUI `@AppStorage`, alongside a `List` and some `Toggle`s, we can easily
    build a user settings screen.
  prefs: []
  type: TYPE_NORMAL
- en: I used a closure in `onDisappear` to tell the parent view to begin number crunching
    again and re-schedule the notifications. This was the simplest way I to batch
    everything up, rather than running expensive computation each time a toggle changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Look, I‚Äôm an indie dev, I‚Äôm allowed to do this halfway through the build process!
  prefs: []
  type: TYPE_NORMAL
- en: I decided to download a few other 2FA apps to see if there were any ideas I
    could copy. Frankly, I expected a pretty crowded and competitive app market, but
    some of these were truly terrible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 2FA app space: mostly astonishingly bad'
  prefs: []
  type: TYPE_NORMAL
- en: Seriously, more than 50% of them threw up an extremely aggressive paywall before
    you could use them‚Ä¶ when there are perfectly good free options.
  prefs: []
  type: TYPE_NORMAL
- en: Does nobody make apps for fun¬†anymore?
  prefs: []
  type: TYPE_NORMAL
- en: Despite this paywall menagerie, I did manage to note down a few good ideas to
    borrow.
  prefs: []
  type: TYPE_NORMAL
- en: This is, of course, pretty critical for anyone that has more than one account.
    More accounts also means more opportunities for rare GETs!
  prefs: []
  type: TYPE_NORMAL
- en: Updating my keychain code, now we can scan multiple QR codes, persisted our
    account data (including the secret), and they worked perfectly for logging me
    into my various accounts!
  prefs: []
  type: TYPE_NORMAL
- en: I also implemented the proper built-in `List` functionality, so we can swipe-to-delete
    codes we don‚Äôt need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: While doing my competitor analysis, I discovered that the Google Authenticator
    kept all my 2FA codes from years ago, which I‚Äôd added on my previous iPhone!
  prefs: []
  type: TYPE_NORMAL
- en: I realised then I was making two mistakes with my data layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, synchronising our keychain to iCloud means accounts appear on all
    your other Apple devices. This is a piece of cake with the Keychain Access library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, I was suffering from shiny-object syndrome: in my haste to use SwiftData
    as a persistence layer, I was only using the Keychain for the secrets, and persisting
    the rest of the Account metadata through the new framework.'
  prefs: []
  type: TYPE_NORMAL
- en: This meant I couldn‚Äôt get my accounts on any other device‚Ää‚Äî‚Ääthe secret on its
    own is useless!
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, I realised I had to place the whole `Account` on the keychain.
  prefs: []
  type: TYPE_NORMAL
- en: My new approach keeps the QR code URL on the keychain in its entirety. Now,
    the `Account` object itself is ephemeral; re-computed from the URL every time
    the app loads.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means the `Account`s can appear on any iDevice you‚Äôre signed in to! This
    ephemeral approach neatly kills two birds with one stone. Now we use the Accounts
    from the keychain when we need to fetch them at load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: My code is a little bit spaghetti, but the final app was about 1,500 LoC in
    total‚Ää‚Äî‚ÄäI‚Äôll rebuild it using a proper DI framework when I want to write an article
    about DI. If you‚Äôre a junior engineer, please don‚Äôt try this at home!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I did a lot of generic coding work to improve the UI and refactor the code nicely,
    but there were also a few gems in my development process that were pretty interesting.
  prefs: []
  type: TYPE_NORMAL
- en: This is very much a nice to have, but the best open-source app did the same,
    so I felt I had to *at least* be as good as that.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is a little-known Google API which crawls the web for FavIcons
    on websites and allows you to download them at several resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: How do I work out the website? I found pretty good results by simply using the
    `issuer` property on the QR code and trying the`.com`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here I used the [CachedAsyncImage](https://github.com/lorenzofiamingo/swiftui-cached-async-image)
    library to get blazingly-fast loading performance on the icons.
  prefs: []
  type: TYPE_NORMAL
- en: Images for each 2FA¬†account
  prefs: []
  type: TYPE_NORMAL
- en: I also added a Metal shader to handle background removal, and make the icon
    pop a little more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs the SwiftUI View extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course the MSL shader code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here‚Äôs how they look. They‚Äôre not bad, but not amazing.
  prefs: []
  type: TYPE_NORMAL
- en: Metal shaders to remove the white backgrounds on the¬†icons
  prefs: []
  type: TYPE_NORMAL
- en: I‚Äôve started over-engineering. Let‚Äôs stick a pin in this and see how we feel
    later.
  prefs: []
  type: TYPE_NORMAL
- en: It‚Äôs working pretty well now as a basic 2fa app in its own right.
  prefs: []
  type: TYPE_NORMAL
- en: Who would have thought that to be ahead of most of the pack, I just had to not
    have an extremely aggressive paywall ($4.99 per week? Seriously?!)
  prefs: []
  type: TYPE_NORMAL
- en: After some boilerplate software development work on the timings, the basic UI,
    and the data storage, it‚Äôs really working quite nicely now‚Ää‚Äî‚Äästicking to the basic
    SwiftUI components is a brilliant way to ensure stuff *‚Äújust works‚Äù**.
  prefs: []
  type: TYPE_NORMAL
- en: '*and helps make everything accessible!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I also implemented some nice QoL features I found through my competitor research
    such as tap-to-copy.
  prefs: []
  type: TYPE_NORMAL
- en: I utilised accessibility tools like `@ScaledMetric` and `ViewThatFits` to ensure
    the app works great regardless of your visual needs. I even get light mode for
    free out of the box by sticking closely to Apple‚Äôs basic SwiftUI components and
    colours.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Check ‚Äôem at the largest accessibility font¬†size
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the true core value proposition, I implemented a lot more options
    for interestingness:'
  prefs: []
  type: TYPE_NORMAL
- en: Sexts, quints, and quads like `000000`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting sequences like `012345`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hundred-thousands like `300000`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Units like `000001` and tens like `000010`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maths constants like pi (`314159`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics constants like Planck's constant, `661034` (6.6x10‚Åª¬≥‚Å¥)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Palindromes like `012210`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeated twos and threes like `121212` and `123123`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these were fun little leet-code puzzles to implement, some were annoying
    regexes, while some were very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now I‚Äôve updated the Settings UI so that you can sort by either rarity (common,
    rare, and ultra-rare), or by type (such as repetitions, constants, sequences,
    or round numbers).
  prefs: []
  type: TYPE_NORMAL
- en: Toggle on the Settings¬†menu
  prefs: []
  type: TYPE_NORMAL
- en: How do I calculate the probabilities of each rarity level?
  prefs: []
  type: TYPE_NORMAL
- en: For perfect counting sequences like `012345`, there are only 6 possible sequences
    (up to `567890`) out of one million possible number combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 30 seconds times 1 million combinations, divided by 6 possible sequences, means
    for each account you might only expect a perfect counting sequence to occur on
    average every 5 million seconds‚Ää‚Äî‚Ääthat is, **every 58 days** on average.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty ultra rare.
  prefs: []
  type: TYPE_NORMAL
- en: However, palindromes such as `123321`, have 1000 possible 3-sequence numbers
    that make them up. This means you could see them **every 0.34 days** on average!
    Much more common.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle, something like repeated twos (e.g. `141414`) have 100 possible
    numbers (`00` to `99`), so they happen **every 3.5 days** on average. So, pretty
    rare, but not *ultra*-rare.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these sequences, like quads, are a little tougher to number crunch,
    so it was simpler to generate tens of millions of OTPs and counting the incidence
    of each kind of interestingness, to get a feel for their relative frequency.
  prefs: []
  type: TYPE_NORMAL
- en: The app can process 64 interesting 2FA codes quite quickly, but only when I
    have all the common `Interestingness`enabled. When I only want ultra-rare GETs,
    the processing takes a long time.
  prefs: []
  type: TYPE_NORMAL
- en: I need to invoke chunking‚Ää‚Äî‚Ääwhile crunching through millions of potential OTPs,
    returning and scheduling a notification as soon as a valid interesting code is
    discovered.
  prefs: []
  type: TYPE_NORMAL
- en: My old friend the `Combine` framework gives us a neat solution!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I also used some `Task`s so that we can cancel and re-start computation in case,
    for instance, a user changes their settings mid-processing. Detaching the tasks
    ensures the heavy processing for our crypto and string analysis operations keeps
    off the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now the scheduling works pretty smoothly, coming out in sequence instead of
    a single large chunk!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This was the one that got away killed me. I‚Äôm desperate to use the real check
    ‚Äôem meme for the app icon. It‚Äôs simply perfect.
  prefs: []
  type: TYPE_NORMAL
- en: However, my good friend pointed out that our friends over at Lionsgate films
    might be feeling a little litigious.
  prefs: []
  type: TYPE_NORMAL
- en: '*But I had to have it!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps there is hope after all:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike you, I have faith in the American copyright system.
  prefs: []
  type: TYPE_NORMAL
- en: Partially completed form for requesting permission to use a still from a¬†movie
  prefs: []
  type: TYPE_NORMAL
- en: Now we play the waiting game.
  prefs: []
  type: TYPE_NORMAL
- en: Crickets.
  prefs: []
  type: TYPE_NORMAL
- en: I‚Äôve lost all faith in the American copyright system. Goddammit, Bob Iger, whatever
    happened to fair use?!
  prefs: []
  type: TYPE_NORMAL
- en: This is the best I could get from DALL-E 3\. It has the wrong number of fingers,
    and it‚Äôs the wrong side of the hand, but after trying to prompt-engineer something
    better for several hours I am resigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: DALL-E *really* didn‚Äôt like drawing the back of a hand. I tried.
  prefs: []
  type: TYPE_NORMAL
- en: The concept was proven. The app works well! Time for some polish and pet features
    before we show the world the joy of Check ‚Äòem.
  prefs: []
  type: TYPE_NORMAL
- en: I created a list of TODOs‚Ää‚Äî‚Äänew features and bug-fixes‚Ää‚Äî‚Ääthat I could implement
    in my V1 before I made my first release.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, since I don‚Äôt have a product manager in sight, I immediately began
    work on the lowest-priority task: building out a collection with deep links‚Ää‚Äî‚ÄäI
    don‚Äôt want my rare GETs to go to waste!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This piece actually helps with a problem we identified original proof of concept:
    we need to incentivise users to re-enter the app by making users interact with
    the notifications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a collect-a-thon is a little tricky, because there are a few moving
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow users to tap on notifications and deep link into the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Securely store the interestingness of the code they tapped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render these into a collection screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a deep link to the notification was fairly simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But, a little annoyingly, I had to create an `AppDelegate` to handle the notifications‚Ää‚Äî‚ÄäSwiftUI
    doesn‚Äôt quite handle these well on its own yet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, I lazily added a long, comma-separated list of stored codes in the
    Keychain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This was more a product of a desire to release fast rather than a well-thought-out
    engineering decision, one I will come to regret if my power-users approach the
    soft limit of 4kB per Keychain item (the hard limit is more like 16MB, so I should
    be okay!).
  prefs: []
  type: TYPE_NORMAL
- en: This work paid off rapidly though, as the collection screen quickly started
    filling up with my rare GETs!
  prefs: []
  type: TYPE_NORMAL
- en: Collection menu containing all your rare¬†GETs
  prefs: []
  type: TYPE_NORMAL
- en: I originally hid the collection until a user had tapped a notification, but
    I realised it was far more compelling to entice a user to collecting ‚Äôem all by
    showing them the menu option.
  prefs: []
  type: TYPE_NORMAL
- en: The iOS 17 `sensoryFeedback` API gives us some extremely subtle haptics to play
    with, so subtle in fact that I didn‚Äôt like them. So I ripped out the Haptic Engine
    from Carbn and reused it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'I simply added a truly atrocious side effect to my existing refresh code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Don‚Äôt try this at home, kids!
  prefs: []
  type: TYPE_NORMAL
- en: There‚Äôs a bug where the `CachedAsyncImage` library is eagerly loading the non-existent
    FavIcons, yielding a blurry globe‚Ä¶ But I think I will release with this.
  prefs: []
  type: TYPE_NORMAL
- en: It works pretty much 90% of the time, and I‚Äôd rather ship than replace one of
    my pet third-party SwiftUI libraries.
  prefs: []
  type: TYPE_NORMAL
- en: FavIcon not found for steam.com
  prefs: []
  type: TYPE_NORMAL
- en: Some of the other bugs, I was a little more attentive to before shipping‚Ää‚Äî‚Ääthis
    one in particular was pretty bad, since someone might scan a QR code twice and
    get a weird duplicate of the same account.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Far from ripping out and replacing a time-saving library, this bug had a single-line-of-code
    fix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since the Keychain is keying 2FA accounts based on the name, this fix is pretty
    sensible.
  prefs: []
  type: TYPE_NORMAL
- en: I found another issue with codes not being queued.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It turns out, I misunderstood how `@AppStorage` actually behaves‚Ää‚Äî‚Ääthe default
    only applied to the UI, as opposed to actually storing something in user defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A function to populate UserDefaults on the first app load solved this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: One little bit of improvement used the new iOS 17 TipKit to give a user a bit
    of an idea of what to do when they first load into the app.
  prefs: []
  type: TYPE_NORMAL
- en: Tips displayed on first¬†launch
  prefs: []
  type: TYPE_NORMAL
- en: This was surprisingly simple to implement with the new API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: I think we‚Äôre ready to ship.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our store listing via [AppScreens](https://appscreens.com/), the
    coup de gr√¢ce second screenshot shows the true power of Check ‚Äôem (featuring my
    cats).
  prefs: []
  type: TYPE_NORMAL
- en: Seriously?
  prefs: []
  type: TYPE_NORMAL
- en: Sorry France, I don‚Äôt have the energy to fill in a form at 11pm at¬†night ü§∑‚Äç‚ôÇÔ∏è
  prefs: []
  type: TYPE_NORMAL
- en: Look, I‚Äôm not the most libertarian person in the world, but I don‚Äôt want to
    jump through several extra hoops to increase my target market by 1%. Do better!
  prefs: []
  type: TYPE_NORMAL
- en: '*(Sorry to all my French readers)*'
  prefs: []
  type: TYPE_NORMAL
- en: In short order, we‚Äôre set up on App Store Connect and ready to press the button!
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading along with my journey!
  prefs: []
  type: TYPE_NORMAL
- en: 'This was a pretty fun project: not only did I manage to tickle the part of
    my geek brain which loves spotting patterns; I got to handle some nifty processing,
    threading, and optimisation problems!'
  prefs: []
  type: TYPE_NORMAL
- en: My next step is [focusing fully on performance](https://jacobbartlett.substack.com/p/high-performance-swift-apps)
    for the `v1.1` release, so it loads up crunches the OTPs even faster than normal!
  prefs: []
  type: TYPE_NORMAL
- en: If you love this app, please give your suggestions on numbers you‚Äôd like to
    see! Finally, if anyone is keen to see an Android version, I‚Äôm more than happy
    to share my source code let you to run with it.
  prefs: []
  type: TYPE_NORMAL
