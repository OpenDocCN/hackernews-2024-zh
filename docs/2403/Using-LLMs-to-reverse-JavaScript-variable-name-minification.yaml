- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 15:03:12'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Using LLMs to reverse JavaScript variable name minification
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://thejunkland.com/blog/using-llms-to-reverse-javascript-minification.html](https://thejunkland.com/blog/using-llms-to-reverse-javascript-minification.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This blog introduces a novel way to reverse minified Javascript using large
    language models (LLMs) like ChatGPT and llama2 while keeping the code semantically
    intact. The code is open source and available at [Github project Humanify](https://github.com/jehna/humanify).
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: What is minification?
  id: totrans-split-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Minification is a process of reducing the size of a Javascript file in order
    to optimize for fast network transfer. Looking from the reverse engineering standpoint,
    there are a few different categories of minification that present increasing challenges:'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: Lossless minification
  id: totrans-split-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most minification is lossless; There's no data lost when `true` is converted
    to its minified alternative `!0`. It's straightforward to [write a Babel transformation](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md)
    to reverse this process. There are [many](https://www.npmjs.com/package/babel-plugin-transform-beautifier)
    [tools](https://www.npmjs.com/package/debundle) that are specifically designed
    to reverse these kind of lossless transformations.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: Unimportant data loss
  id: totrans-split-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some data is lost during the minification, but that data may be trivial to recreate.
    A good example is whitespace; it's trivial to use [Prettier](https://prettier.io)
    (or a similar tool) to reformat minified code's indentation and whitespace to
    a human-readable format. Most of the time the developers have used similar tools
    with the original code too, so the whitespace data can be recreated with high
    confidence.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: Variable names
  id: totrans-split-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most important information that's lost during the minification process is
    the loss of variable and function names. When you run a minifier, it completely
    replaces all possible variable and function names to save bytes.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: Until now, there has not been any good way to reverse this process; when you
    rename a variable from `crossProduct` to `a`, there's not much you can do to reverse
    that process.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: How would a human reverse minification?
  id: totrans-split-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many reverse engineers train their eyes to recognize some heuristics from the
    context of the code so that they form educated guesses about the code''s purpose.
    Let''s have a look at a simple example:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-18
  prefs: []
  type: TYPE_PRE
- en: How would you rename the function `a`? Given the context, we can make a pretty
    good guess that the original name was something like `square`. But this requires
    the knowledge of the internal workings of the function.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to codify the process of renaming the function:'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: Read the function's body
  id: totrans-split-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe what the function does
  id: totrans-split-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to come up with a name that fits that description
  id: totrans-split-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a classical computer program it would be very difficult to make the leap
    from "multiply `b` with itself" to "squaring a number". Fortunately recent advances
    in LLMs have made this leap not only possible, but almost trivial.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: Essentially the step 2\. is called "rephrasing" (or "translating" if you consider
    Javascript as its own natural language), and LLMs are known to be very good at
    that.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: Another task where LLMs really shine is summarization, which is pretty much
    what we're doing in step 3\. The only specialization here is that the output needs
    to be short enough and formatted to the camel case.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: Controlling LLMs
  id: totrans-split-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The issue with using output from LLMs is that they are not deterministic. In
    a nutshell a LLM is a very complex markov chain; it tries its best to guess the
    next word in a text based on the previous words.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that even if we have a good prompt like:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-30
  prefs: []
  type: TYPE_PRE
- en: An LLM might still answer "No, but ...", "I don't know" or the famous "I'm sorry,
    but as an AI language model I cannot...".
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: This used to be a problem, but fortunately there are now ways to control the
    LLM's output like [guidance](https://guidance.readthedocs.io/) and [outlines](https://github.com/normal-computing/outlines).
    These tools use different techniques to ensure that the LLM's output matches a
    desired format.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately Javascript variables can only have a specific format, so can match
    the output with a regular expression to ensure that the output is a valid Javascript
    variable name.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: Don't let AI touch the code
  id: totrans-split-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now while LLMs are very good at rephrasing and summarizing, they are not very
    good at coding (yet). They have inherent randomness, which makes them unsuitable
    for performing the actual renaming and modification of the code.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately renaming a Javascript variable within its scope is a solved problem
    with traditional tools like Babel. Babel first parses the code into an abstract
    syntax tree (AST, a machine representation of the code), which is easy to modify
    using well behaving algorithms.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: This is much better than letting the LLM modify the code on a text level; it
    ensures that only very specific transformations are carried out so the code's
    functionality does not change after the renaming. The code is guaranteed to have
    the original functionality and to be runnable by the computer.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  id: totrans-split-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, how do we un-minify Javascript? Let''s put it all together:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: Unbundle webpack bundles with [webcrack](https://github.com/j4k0xb/webcrack)
  id: totrans-split-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code through [transform-beautifier](https://www.npmjs.com/package/babel-plugin-transform-beautifier)
    and a few custom Babel plugins that reverse lossless minification
  id: totrans-split-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through all variables in the code, asking LLM to describe their intent
    and generate a better name based on that description
  id: totrans-split-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the variables using Babel
  id: totrans-split-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a final round of [Prettier](https://prettier.io/) to ensure nice whitespace
  id: totrans-split-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And that''s it! Given the following code:'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-46
  prefs: []
  type: TYPE_PRE
- en: 'The tool outputs the following:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-48
  prefs: []
  type: TYPE_PRE
- en: Try it yourself!
  id: totrans-split-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tool is called [Humanify and it's available at Github](https://github.com/jehna/humanify).
    Do check it out and see if it works for you!
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
