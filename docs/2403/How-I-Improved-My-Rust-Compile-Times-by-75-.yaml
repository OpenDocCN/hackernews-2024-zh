- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†ç±»ï¼šæœªåˆ†ç±»
- en: 'date: 2024-05-29 12:32:08'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ—¥æœŸï¼š2024-05-29 12:32:08
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: How I Improved My Rust Compile Times by 75%
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æˆ‘æ˜¯å¦‚ä½•å°†æˆ‘çš„ Rust ç¼–è¯‘æ—¶é—´æé«˜äº† 75% çš„ã€‚
- en: æ¥æºï¼š[https://benw.is/posts/how-i-improved-my-rust-compile-times-by-seventy-five-percent](https://benw.is/posts/how-i-improved-my-rust-compile-times-by-seventy-five-percent)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://benw.is/posts/how-i-improved-my-rust-compile-times-by-seventy-five-percent](https://benw.is/posts/how-i-improved-my-rust-compile-times-by-seventy-five-percent)
- en: There's now a Part 2, where I cover a couple more options. Check it out [here](https://benw.is/posts/how-i-improved-my-rust-compile-times-part2)
  id: totrans-split-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨æœ‰ç¬¬äºŒéƒ¨åˆ†ï¼Œæˆ‘å°†ä»‹ç»æ›´å¤šé€‰é¡¹ã€‚åœ¨è¿™é‡Œå¯ä»¥æŸ¥çœ‹ [é“¾æ¥](https://benw.is/posts/how-i-improved-my-rust-compile-times-part2)
- en: One of Rust's often mentioned pain points is slow compile times. In order to
    have nice things like the borrow checker, safety, and zero cost abstractions,
    we pay in time spent compiling. Web developers, especially those that come from
    one of the Javascript frameworks, really, really like fast reload times. I was
    fairly active in the Remix discord early on, and the number of people who asked
    about HMR(Hot Module Reloading) [was insane](https://github.com/remix-run/remix/discussions/2384).
    Hot Module Reloading is when the web framework will replaces javascript, html,
    and css modules in an existing page as they are changed without losing page state.
    The alternative, Live Page Reloading, will trigger a page reload when a change
    is detected. For Remix, the time difference between the two is signifigantly less
    than it would be in Rust, where we'd have to recompile.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: Rust ç»å¸¸æåˆ°çš„ä¸€ä¸ªç—›ç‚¹æ˜¯ç¼–è¯‘æ—¶é—´æ…¢ã€‚ä¸ºäº†æ‹¥æœ‰åƒå€Ÿç”¨æ£€æŸ¥å™¨ã€å®‰å…¨æ€§å’Œé›¶æˆæœ¬æŠ½è±¡ç­‰å¥½ä¸œè¥¿ï¼Œæˆ‘ä»¬è¦èŠ±è´¹å¤§é‡æ—¶é—´ç¼–è¯‘ã€‚Web å¼€å‘è€…ï¼Œå°¤å…¶æ˜¯é‚£äº›æ¥è‡ª JavaScript
    æ¡†æ¶çš„å¼€å‘è€…ï¼Œéå¸¸éå¸¸å–œæ¬¢å¿«é€Ÿçš„é‡æ–°åŠ è½½æ—¶é—´ã€‚æˆ‘åœ¨ Remix çš„ Discord æ—©æœŸéå¸¸æ´»è·ƒï¼Œå¾ˆå¤šäººéƒ½åœ¨é—®å…³äº HMRï¼ˆçƒ­æ¨¡å—é‡è½½ï¼‰çš„é—®é¢˜[è¶…çº§å¤š](https://github.com/remix-run/remix/discussions/2384)ã€‚çƒ­æ¨¡å—é‡è½½æ˜¯æŒ‡å½“ç½‘é¡µæ¡†æ¶åœ¨ç°æœ‰é¡µé¢ä¸Šæ›´æ”¹
    JavaScriptã€HTML å’Œ CSS æ¨¡å—æ—¶ï¼Œä¸ä¼šä¸¢å¤±é¡µé¢çŠ¶æ€ã€‚è€Œå¦ä¸€ç§æ–¹æ³•ï¼Œå³å®æ—¶é¡µé¢é‡æ–°åŠ è½½ï¼Œä¼šåœ¨æ£€æµ‹åˆ°æ›´æ”¹æ—¶è§¦å‘é¡µé¢é‡æ–°åŠ è½½ã€‚å¯¹äº Remixï¼Œè¿™ä¸¤è€…ä¹‹é—´çš„æ—¶é—´å·®å¼‚æ˜¾è‘—å°äºåœ¨
    Rust ä¸­çš„æ—¶é—´å·®å¼‚ï¼Œå› ä¸ºåœ¨ Rust ä¸­ï¼Œæˆ‘ä»¬å¿…é¡»é‡æ–°ç¼–è¯‘ã€‚
- en: You can imagine, as a Leptos team member, we hear a lot of the same discussion.
    Leptos, as a frontend Rust web framework, sits at the intersection of these two
    worlds We see it on the [Leptos Discord](https://discord.gg/x8NhWWYTV2) all the
    time.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸º Leptos å›¢é˜Ÿæˆå‘˜ï¼Œæˆ‘ä»¬ç»å¸¸å¬åˆ°ç›¸åŒçš„è®¨è®ºã€‚ä½œä¸ºå‰ç«¯ Rust ç½‘ç»œæ¡†æ¶ï¼ŒLeptos ä½äºè¿™ä¸¤ä¸ªä¸–ç•Œçš„äº¤æ±‡å¤„ã€‚æˆ‘ä»¬ç»å¸¸åœ¨ [Leptos Discord](https://discord.gg/x8NhWWYTV2)
    ä¸Šçœ‹åˆ°è¿™ç§æƒ…å†µã€‚
- en: '"Now, if only rebuild was fasterâ€¦ ğŸ«£"'
  id: totrans-split-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"ç°åœ¨ï¼Œå¦‚æœé‡å»ºé€Ÿåº¦æ›´å¿«å°±å¥½äº†... ğŸ«£"'
- en: '"Anyone have some tips to improve compile times? Leptos is amazing but having
    to wait 5-10 seconds to render an extra div is very annoying"'
  id: totrans-split-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"æœ‰äººæœ‰ä¸€äº›æ”¹å–„ç¼–è¯‘æ—¶é—´çš„å»ºè®®å—ï¼ŸLeptos çœŸçš„å¾ˆæ£’ï¼Œä½†æ˜¯ç­‰å¾… 5-10 ç§’æ¥æ¸²æŸ“é¢å¤–çš„ div å®åœ¨æ˜¯å¾ˆçƒ¦äºº"'
- en: So Leptos basically has two approaches to solve this, improve Rust's compile
    time itself, and/or come up with a way to output changes to parts of the page
    without needing to recompile first. In this piece, we'll explore both.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒLeptos åŸºæœ¬ä¸Šæœ‰ä¸¤ç§æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼šæ”¹å–„ Rust çš„ç¼–è¯‘æ—¶é—´æœ¬èº«ï¼Œå’Œ/æˆ–è€…æƒ³å‡ºä¸€ç§æ–¹æ³•æ¥åœ¨ä¸éœ€è¦é¦–å…ˆé‡æ–°ç¼–è¯‘çš„æƒ…å†µä¸‹è¾“å‡ºé¡µé¢çš„éƒ¨åˆ†å˜åŒ–ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨è¿™ä¸¤ç§æ–¹æ³•ã€‚
- en: In order to test different changes, we need to establish a baseline. In default
    Rust, on my machine, how long will it take to compile my web app?
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æµ‹è¯•ä¸åŒçš„æ›´æ”¹ï¼Œæˆ‘ä»¬éœ€è¦å»ºç«‹ä¸€ä¸ªåŸºå‡†ã€‚åœ¨æˆ‘çš„æœºå™¨ä¸Šï¼Œé»˜è®¤çš„ Rust ç¯å¢ƒï¼Œç¼–è¯‘æˆ‘çš„ Web åº”ç”¨éœ€è¦å¤šé•¿æ—¶é—´ï¼Ÿ
- en: I have a quite beefy test machine on which I usually compile. On my machine
    I'll be compiling a simpler project, and my friend Alex kindly agreed to run test
    his startup Houski's [site](https://www.houski.ca/),
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æœ‰ä¸€å°éå¸¸å¼ºå¤§çš„æµ‹è¯•æœºå™¨ï¼Œé€šå¸¸ç”¨æ¥ç¼–è¯‘ã€‚åœ¨æˆ‘çš„æœºå™¨ä¸Šï¼Œæˆ‘å°†ç¼–è¯‘ä¸€ä¸ªæ›´ç®€å•çš„é¡¹ç›®ï¼Œæˆ‘çš„æœ‹å‹ Alex å‹å¥½åœ°åŒæ„æµ‹è¯•ä»–çš„åˆ›ä¸šå…¬å¸ Houski çš„ [ç½‘ç«™](https://www.houski.ca/)ã€‚
- en: AMD 5950x processor,
  id: totrans-split-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD 5950x å¤„ç†å™¨ï¼Œ
- en: 72GB RAM
  id: totrans-split-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 72GB RAM
- en: SATA SSD system drive.
  id: totrans-split-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SATA SSD ç³»ç»Ÿé©±åŠ¨å™¨ã€‚
- en: 7200RPM spinning disk storage drives
  id: totrans-split-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7200RPM æ—‹è½¬ç¡¬ç›˜å­˜å‚¨é©±åŠ¨å™¨
- en: NVME drives
  id: totrans-split-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NVME é©±åŠ¨å™¨
- en: NixOS linux distro
  id: totrans-split-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NixOS Linux å‘è¡Œç‰ˆ
- en: Rust 1.75 nightly
  id: totrans-split-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 1.75 nightly
- en: AMD 7900x processor
  id: totrans-split-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD 7900x å¤„ç†å™¨
- en: 128GB RAM
  id: totrans-split-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 128GB RAM
- en: NVME drive
  id: totrans-split-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NVME é©±åŠ¨å™¨
- en: Ubuntu linux distro
  id: totrans-split-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Linux å‘è¡Œç‰ˆ
- en: Rust 1.75 nightly
  id: totrans-split-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 1.75 nightly
- en: A Leptos web app typicallys undergoes a two stage build process.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: Leptos Web åº”ç”¨é€šå¸¸ç»å†ä¸¤ä¸ªé˜¶æ®µçš„æ„å»ºè¿‡ç¨‹ã€‚
- en: Build Webassembly frontend module using cargo. Optimize and package it with
    warm-bindgen.
  id: totrans-split-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ cargo æ„å»º WebAssembly å‰ç«¯æ¨¡å—ã€‚ä½¿ç”¨ warm-bindgen è¿›è¡Œä¼˜åŒ–å’Œæ‰“åŒ…ã€‚
- en: Build the server binary with cargo.
  id: totrans-split-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ cargo æ„å»ºæœåŠ¡å™¨äºŒè¿›åˆ¶æ–‡ä»¶ã€‚
- en: I chose to benchmark the whole process for most of these demos, but since it's
    essentially two cargo steps, any relative changes would affect any cargo command.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘é€‰æ‹©ä¸ºå¤§å¤šæ•°æ¼”ç¤ºé¡¹ç›®è¿›è¡Œæ•´ä½“è¿‡ç¨‹åŸºå‡†æµ‹è¯•ï¼Œä½†ç”±äºå®è´¨ä¸Šæ˜¯ä¸¤ä¸ª cargo æ­¥éª¤ï¼Œä»»ä½•ç›¸å¯¹å˜åŒ–éƒ½ä¼šå½±å“ä»»ä½• cargo å‘½ä»¤ã€‚
- en: '~~Note: Discord User @PaulH(and a couple others) let me know about this [bug](https://github.com/leptos-rs/cargo-leptos/pull/203)
    that prevents the server build from using the dependencies built for the previous
    compilation of the server/webassembly frontend build due to changes in the RUSTFLAGS.
    You can fix this by having cargo-leptos > 0.2.1 and adding this to you Cargo.toml
    under your Leptos settings block.!~~ I did not test with this enabled, but this
    is now the default behavior of cargo-leptos. The feature is deprecated.'
  id: totrans-split-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ~~æ³¨æ„ï¼šDiscord ç”¨æˆ· @PaulHï¼ˆè¿˜æœ‰å‡ ä½å…¶ä»–äººï¼‰å‘æˆ‘åæ˜ äº†å…³äºè¿™ä¸ª [bug](https://github.com/leptos-rs/cargo-leptos/pull/203)
    çš„æƒ…å†µï¼Œè¯¥ bug å¯¼è‡´æœåŠ¡å™¨æ„å»ºæ— æ³•ä½¿ç”¨ä¹‹å‰ç¼–è¯‘çš„ä¾èµ–é¡¹ï¼Œå› ä¸º RUSTFLAGS å‘ç”Ÿäº†å˜åŒ–ã€‚æ‚¨å¯ä»¥é€šè¿‡å°† cargo-leptos è®¾ç½®ä¸º > 0.2.1
    å¹¶å°†ä»¥ä¸‹å†…å®¹æ·»åŠ åˆ°æ‚¨çš„ Cargo.toml æ–‡ä»¶ä¸­çš„ Leptos è®¾ç½®å—ä¸­æ¥ä¿®å¤æ­¤é—®é¢˜ã€‚æˆ‘æ²¡æœ‰å¯ç”¨è¿‡è¿™ä¸ªé€‰é¡¹ï¼Œä½†è¿™ç°åœ¨æ˜¯ cargo-leptos çš„é»˜è®¤è¡Œä¸ºã€‚è¯¥åŠŸèƒ½å·²è¢«å¼ƒç”¨ã€‚~~
- en: TOML markup
  id: totrans-split-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TOML æ ‡è®°è¯­è¨€
- en: '[PRE0]'
  id: totrans-split-32
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This advice comes from Bevy, which recommends setting the opt-level for development
    higher in order to possibly reduce dev compile times and improve performance.
    By default, the Rust compiler sets an opt-level of 0 for development builds. We're
    going to give it an opt-level of 1 for our code, and an opt-level of 3 for all
    the dependencies of our code.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›å»ºè®®æ¥è‡ª Bevyï¼Œå»ºè®®åœ¨å¼€å‘ä¸­è®¾ç½®æ›´é«˜çš„ opt-level ä»¥å¯èƒ½å‡å°‘å¼€å‘ç¼–è¯‘æ—¶é—´å¹¶æé«˜æ€§èƒ½ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ŒRust ç¼–è¯‘å™¨ä¸ºå¼€å‘æ„å»ºè®¾ç½® opt-level
    ä¸º 0ã€‚æˆ‘ä»¬å°†ä¸ºæˆ‘ä»¬çš„ä»£ç è®¾ç½® opt-level ä¸º 1ï¼Œå¹¶ä¸ºæ‰€æœ‰ä»£ç çš„ä¾èµ–é¡¹è®¾ç½® opt-level ä¸º 3ã€‚
- en: This does come with the drawback of much less useful error messages if they
    come from our dependencies. So you might have to adjust the levels if you run
    into tricky bugs.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¸¦æ¥äº†ä¸€ä¸ªç¼ºç‚¹ï¼Œå¦‚æœé”™è¯¯æ¶ˆæ¯æ¥è‡ªæˆ‘ä»¬çš„ä¾èµ–é¡¹ï¼Œå®ƒä»¬çš„æœ‰ç”¨æ€§ä¼šå¤§å¤§é™ä½ã€‚å› æ­¤ï¼Œå¦‚æœé‡åˆ°æ£˜æ‰‹çš„ bugï¼Œæ‚¨å¯èƒ½éœ€è¦è°ƒæ•´çº§åˆ«ã€‚
- en: Since optimization takes additional time, I expect the clean compile times to
    increase, but we may see the increased optimizations make the code easier to compile
    in incremental builds. We also had some positive anecdotes on our Discord.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºä¼˜åŒ–éœ€è¦é¢å¤–çš„æ—¶é—´ï¼Œæˆ‘é¢„è®¡æ¸…æ´ç¼–è¯‘æ—¶é—´ä¼šå¢åŠ ï¼Œä½†æˆ‘ä»¬å¯èƒ½ä¼šçœ‹åˆ°å¢åŠ çš„ä¼˜åŒ–ä½¿ä»£ç åœ¨å¢é‡æ„å»ºä¸­æ›´å®¹æ˜“ç¼–è¯‘ã€‚æˆ‘ä»¬åœ¨ Discord ä¸Šä¹Ÿæœ‰ä¸€äº›ç§¯æçš„æ¡ˆä¾‹ã€‚
- en: '"fwiw @gbj @Alex Wilkinson i dropped my compile time from between 5-30 minutes
    to 6 seconds by putting this in my workspace Cargo.toml'
  id: totrans-split-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"fwiw @gbj @Alex Wilkinson æˆ‘é€šè¿‡å°†è¿™ä¸ªæ”¾å…¥æˆ‘çš„å·¥ä½œç©ºé—´ Cargo.toml ä¸­ï¼Œå°†æˆ‘çš„ç¼–è¯‘æ—¶é—´ä»5åˆ°30åˆ†é’Ÿç¼©çŸ­åˆ°äº†6ç§’ã€‚'
- en: We can enable adding these blocks to our `Cargo.toml` file. Nice and easy.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åœ¨æˆ‘ä»¬çš„ `Cargo.toml` æ–‡ä»¶ä¸­å¯ç”¨æ·»åŠ è¿™äº›å—ã€‚ç®€å•æ˜“è¡Œã€‚
- en: TOML markup
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: TOML æ ‡è®°è¯­è¨€
- en: '[PRE1]'
  id: totrans-split-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For those unfamiliar with how what goes on inside the Rust compiler, it typically
    follows a few basic steps. It reads in source code, which is converted to a variety
    of types of IR(Intermediate Representation), and optimizations are performed during
    that conversion. Then that IR is fed to a code generator, provided by LLVM, which
    converts the IR into object files, and then the linker links together those object
    files and other system libs into one executable binary. Way more details about
    how that works can be found [here](https://rustc-dev-guide.rust-lang.org/overview.html).
    Fascinating reading, but a bit too deep for our discussion here.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºé‚£äº›ä¸ç†Ÿæ‚‰ Rust ç¼–è¯‘å™¨å†…éƒ¨å·¥ä½œçš„äººï¼Œå®ƒé€šå¸¸éµå¾ªå‡ ä¸ªåŸºæœ¬æ­¥éª¤ã€‚å®ƒè¯»å–æºä»£ç ï¼Œå°†å…¶è½¬æ¢ä¸ºå„ç§ç±»å‹çš„ä¸­é—´è¡¨ç¤ºï¼ˆIRï¼‰ï¼Œå¹¶åœ¨æ­¤è½¬æ¢è¿‡ç¨‹ä¸­æ‰§è¡Œä¼˜åŒ–ã€‚ç„¶åå°†è¯¥
    IR æäº¤ç»™ç”± LLVM æä¾›çš„ä»£ç ç”Ÿæˆå™¨ï¼Œå°† IR è½¬æ¢ä¸ºç›®æ ‡æ–‡ä»¶ï¼Œç„¶åé“¾æ¥å™¨å°†è¿™äº›ç›®æ ‡æ–‡ä»¶åŠå…¶ä»–ç³»ç»Ÿåº“é“¾æ¥æˆä¸€ä¸ªå¯æ‰§è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ã€‚å…³äºå…¶å·¥ä½œåŸç†çš„æ›´å¤šç»†èŠ‚å¯ä»¥åœ¨
    [è¿™é‡Œ](https://rustc-dev-guide.rust-lang.org/overview.html) æ‰¾åˆ°ã€‚è¿™æ˜¯ä¸€ç¯‡å¼•äººå…¥èƒœçš„é˜…è¯»ï¼Œä½†å¯¹æˆ‘ä»¬çš„è®¨è®ºæ¥è¯´æœ‰äº›æ·±å…¥ã€‚
- en: '[Mold](https://github.com/rui314/mold) is a new linker developed by Rui Ueyama,
    with the goal of increasing linker performance by parallelizing the load as much
    as possible, and benchmarks have shown it to be signifigantly faster than Rust''s
    default linker.'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[Mold](https://github.com/rui314/mold) æ˜¯ç”± Rui Ueyama å¼€å‘çš„ä¸€æ¬¾æ–°é“¾æ¥å™¨ï¼Œæ—¨åœ¨é€šè¿‡å°½å¯èƒ½å¹¶è¡ŒåŒ–åŠ è½½æ¥æé«˜é“¾æ¥å™¨çš„æ€§èƒ½ï¼ŒåŸºå‡†æµ‹è¯•æ˜¾ç¤ºå®ƒæ¯”
    Rust çš„é»˜è®¤é“¾æ¥å™¨è¦å¿«å¾—å¤šã€‚'
- en: For Linux and Mac, the default linker is ld, run by cc. Windows is a different
    story, using Microsoft's MVC link.exe. If you're running Linux, you can use mold
    directly. If you're on Mac, a paid version of mold called Sold is available for
    Mac. If Mold generates benefits for you, I encourage you to buy Sold(very affordable)
    or sponsor Rui on his Github Sponsors [page](https://github.com/sponsors/rui314).
    Windows users, unforunately, are not supported at this time. Support for Windows
    in Sold is in development.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äº Linux å’Œ Macï¼Œé»˜è®¤çš„é“¾æ¥å™¨æ˜¯ ldï¼Œç”± cc è¿è¡Œã€‚Windows åˆ™ä½¿ç”¨ Microsoft çš„ MVC link.exeã€‚å¦‚æœæ‚¨åœ¨è¿è¡Œ
    Linuxï¼Œåˆ™å¯ä»¥ç›´æ¥ä½¿ç”¨ moldã€‚å¦‚æœæ‚¨åœ¨ Mac ä¸Šï¼Œå¯ä»¥è´­ä¹°ä¸€ä¸ªåä¸º Sold çš„ mold çš„ä»˜è´¹ç‰ˆæœ¬ï¼Œä»·æ ¼éå¸¸å®æƒ ã€‚å¦‚æœ Mold ä¸ºæ‚¨å¸¦æ¥äº†å¥½å¤„ï¼Œæˆ‘å»ºè®®æ‚¨åœ¨ä»–çš„
    Github Sponsors [é¡µé¢](https://github.com/sponsors/rui314) ä¸Šè´­ä¹° Sold æˆ–èµåŠ© Ruiã€‚ç›®å‰ä¸æ”¯æŒ
    Windows ç”¨æˆ·ã€‚Sold ä¸­å¯¹ Windows çš„æ”¯æŒæ­£åœ¨å¼€å‘ä¸­ã€‚
- en: A fairly signifigant amount of time is spent linking your Rust binary, especially
    during incremental builds, so this could provide some real benefits.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¢é‡æ„å»ºè¿‡ç¨‹ä¸­ï¼Œé“¾æ¥æ‚¨çš„RustäºŒè¿›åˆ¶æ–‡ä»¶éœ€è¦ç›¸å½“å¤§çš„æ—¶é—´ï¼Œå› æ­¤è¿™å¯èƒ½ä¼šå¸¦æ¥ä¸€äº›çœŸæ­£çš„å¥½å¤„ã€‚
- en: 'On Linux, it''s actually really easy to use, just [install Mold](https://github.com/rui314/mold)
    and then prepend you cargo commands with `mold -run`. For example, `mold -run
    cargo build`. It can also be enabled in `.cargo/config.toml`, like this:'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Linuxä¸Šï¼Œå®é™…ä¸Šéå¸¸å®¹æ˜“ä½¿ç”¨ï¼Œåªéœ€[å®‰è£…Mold](https://github.com/rui314/mold)ï¼Œç„¶ååœ¨cargoå‘½ä»¤ä¹‹å‰åŠ ä¸Š`mold
    -run`ã€‚ä¾‹å¦‚ï¼Œ`mold -run cargo build`ã€‚ä¹Ÿå¯ä»¥åƒè¿™æ ·åœ¨`.cargo/config.toml`ä¸­å¯ç”¨å®ƒï¼š
- en: TOML markup
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: TOMLæ ‡è®°
- en: '[PRE2]'
  id: totrans-split-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: where `/path/to/mold` is an absolute path to the mold executable. This is also
    how you enable Sold, just replace the mold path with the sold path and the target
    to the one for your Mac.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­`/path/to/mold`æ˜¯åˆ°æ¨¡å…·å¯æ‰§è¡Œæ–‡ä»¶çš„ç»å¯¹è·¯å¾„ã€‚è¿™ä¹Ÿæ˜¯æ‚¨å¯ç”¨Soldçš„æ–¹æ³•ï¼Œåªéœ€å°†æ¨¡å…·è·¯å¾„æ›¿æ¢ä¸ºSoldè·¯å¾„ï¼Œå°†ç›®æ ‡æ›¿æ¢ä¸ºæ‚¨çš„Macçš„ç›®æ ‡ã€‚
- en: In the previous optimization, we replaced the linker the Rust compiler uses.
    Let's try replacing the code generator, Cranelift is an alternative code generator,
    used instead of LLVM in the build step. While it's not good at doing as many optimizations
    as LLVM, it is good at spitting out code fast. It was recently integrated as an
    option for code generation in Rust 1.73 nightly for x86_64 linux targets. Other
    platforms will need to setup cranelift seperately, see their [README](https://github.com/rust-lang/rustc_codegen_cranelift).
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰é¢çš„ä¼˜åŒ–ä¸­ï¼Œæˆ‘ä»¬æ›¿æ¢äº†Rustç¼–è¯‘å™¨ä½¿ç”¨çš„é“¾æ¥å™¨ã€‚è®©æˆ‘ä»¬å°è¯•æ›¿æ¢ä»£ç ç”Ÿæˆå™¨ï¼ŒCraneliftæ˜¯ä¸€ä¸ªæ›¿ä»£ä»£ç ç”Ÿæˆå™¨ï¼Œåœ¨æ„å»ºæ­¥éª¤ä¸­ä»£æ›¿LLVMä½¿ç”¨ã€‚è™½ç„¶å®ƒåœ¨æ‰§è¡Œè®¸å¤šä¼˜åŒ–æ–¹é¢ä¸å¦‚LLVMï¼Œä½†å®ƒèƒ½å¤Ÿå¿«é€Ÿç”Ÿæˆä»£ç ã€‚æœ€è¿‘ï¼Œåœ¨Rust
    1.73å¤œé—´ç‰ˆæœ¬ä¸­ï¼ŒCraneliftä½œä¸ºx86_64 Linuxç›®æ ‡ä»£ç ç”Ÿæˆçš„ä¸€ä¸ªé€‰é¡¹è¿›è¡Œäº†é›†æˆã€‚å…¶ä»–å¹³å°éœ€è¦å•ç‹¬è®¾ç½®craneliftï¼Œè¯·å‚é˜…å®ƒä»¬çš„[README](https://github.com/rust-lang/rustc_codegen_cranelift)ã€‚
- en: bash
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: bash
- en: '[PRE3]'
  id: totrans-split-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To use it with Cargo, it can be enabled by enabling the unstable `codegen-backend`
    feature, and then setting the `codegen-backend= "cranelift"` value for a profile.
    That can be done in `.cargo/config.toml` like so:'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: è¦åœ¨Cargoä¸­ä½¿ç”¨å®ƒï¼Œå¯ä»¥é€šè¿‡å¯ç”¨ä¸ç¨³å®šçš„`codegen-backend`åŠŸèƒ½ï¼Œç„¶åä¸ºä¸€ä¸ªé…ç½®æ–‡ä»¶è®¾ç½®`codegen-backend= "cranelift"`å€¼æ¥å¯ç”¨å®ƒã€‚å¯ä»¥åƒè¿™æ ·åœ¨`.cargo/config.toml`ä¸­å®Œæˆï¼š
- en: TOML markup
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: TOMLæ ‡è®°
- en: '[PRE4]'
  id: totrans-split-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you don't need to worry about multi-target builds, you can also enable it
    below with a target. This does conflict with the desire to not use cranelift during
    production builds, so I wouldn't recommend it. Rust doesn't support per target
    profile builds, so creating your own profile is a lot more flexible.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨ä¸éœ€è¦æ‹…å¿ƒå¤šç›®æ ‡æ„å»ºï¼Œä¹Ÿå¯ä»¥åœ¨ä¸‹é¢ä½¿ç”¨ä¸€ä¸ªç›®æ ‡æ¥å¯ç”¨å®ƒã€‚è¿™ä¸åœ¨ç”Ÿäº§æ„å»ºè¿‡ç¨‹ä¸­ä¸ä½¿ç”¨Craneliftçš„æ„¿æœ›ç›¸å†²çªï¼Œå› æ­¤æˆ‘ä¸å»ºè®®è¿™æ ·åšã€‚Rustä¸æ”¯æŒæ¯ä¸ªç›®æ ‡çš„é…ç½®æ–‡ä»¶æ„å»ºï¼Œå› æ­¤åˆ›å»ºè‡ªå·±çš„é…ç½®æ–‡ä»¶æ›´åŠ çµæ´»ã€‚
- en: TOML markup
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: TOMLæ ‡è®°
- en: '[PRE5]'
  id: totrans-split-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Keep in mind that Cranelift is still in development, and may have some issues
    with missing intrinsics. So your crate may or may not work in it natively. If
    you do find missing intrinsics, I encourage you to create an issue in their repo
    [here](https://github.com/rust-lang/rustc_codegen_cranelift), there may be a workaround
    available.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·è®°ä½ï¼ŒCraneliftä»åœ¨å¼€å‘ä¸­ï¼Œå¯èƒ½å­˜åœ¨ä¸€äº›ç¼ºå°‘çš„å†…éƒ¨å‡½æ•°ã€‚å› æ­¤ï¼Œæ‚¨çš„crateåœ¨å…¶ä¸­å¯èƒ½å·¥ä½œæˆ–ä¸å·¥ä½œã€‚å¦‚æœæ‚¨å‘ç°ç¼ºå°‘å†…éƒ¨å‡½æ•°ï¼Œæˆ‘å»ºè®®æ‚¨åœ¨å®ƒä»¬çš„ä»“åº“[è¿™é‡Œ](https://github.com/rust-lang/rustc_codegen_cranelift)åˆ›å»ºä¸€ä¸ªé—®é¢˜ï¼Œå¯èƒ½ä¼šæœ‰å¯è¡Œçš„è§£å†³æ–¹æ³•ã€‚
- en: I'm primarily interested in optimizing build times for Rust projects in development.
    This means I'm not concerned about filesize, optimizations, or run speed, as long
    as they are not signifigantly affected. We're interested in the time it takes
    to build our Rust Leptos apps, both from a clean state, and with incremental compilation.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¸»è¦å…³æ³¨ä¼˜åŒ–Rusté¡¹ç›®åœ¨å¼€å‘ä¸­çš„æ„å»ºæ—¶é—´ã€‚è¿™æ„å‘³ç€æˆ‘ä¸å…³å¿ƒæ–‡ä»¶å¤§å°ã€ä¼˜åŒ–æˆ–è¿è¡Œé€Ÿåº¦ï¼Œåªè¦å®ƒä»¬ä¸å—åˆ°æ˜¾è‘—å½±å“å³å¯ã€‚æˆ‘ä»¬å…³æ³¨çš„æ˜¯ä»å¹²å‡€çŠ¶æ€å¼€å§‹æ„å»ºæˆ‘ä»¬çš„Rust
    Leptosåº”ç”¨ç¨‹åºçš„æ—¶é—´ï¼Œä»¥åŠå¢é‡ç¼–è¯‘çš„æ—¶é—´ã€‚
- en: To do that we're going to use [hyperfine](https://github.com/sharkdp/hyperfine)
    a command line benchmarking tool, to run 'cargo leptos build', which as described
    earlier does Leptos's two step compilation. For clean builds, we will run `cargo
    clean` before each build, in order to delete any files cached by Rust. Incremental
    builds are a bit harder.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨[hyperfine](https://github.com/sharkdp/hyperfine)ï¼Œä¸€ä¸ªå‘½ä»¤è¡ŒåŸºå‡†æµ‹è¯•å·¥å…·ï¼Œè¿è¡Œ 'cargo
    leptos build'ï¼Œæ­£å¦‚å‰é¢æè¿°çš„é‚£æ ·ï¼ŒLeptosçš„ä¸¤æ­¥ç¼–è¯‘ã€‚å¯¹äºæ¸…ç†æ„å»ºï¼Œæˆ‘ä»¬å°†åœ¨æ¯æ¬¡æ„å»ºä¹‹å‰è¿è¡Œ`cargo clean`ï¼Œä»¥åˆ é™¤Rustç¼“å­˜çš„ä»»ä½•æ–‡ä»¶ã€‚å¢é‡æ„å»ºç¨å¾®å›°éš¾ä¸€äº›ã€‚
- en: 'For incremental builds, we''ll simulate a developer modifying a single HTML
    tag in a Leptos component. To do that, we''ll run our handy unix friend `sed`
    to insert the current date and time into an HTML tag. For this purpose, I''ve
    chosen the `<dfn>` tag, because I''ve never seen it used, and thus I probably
    don''t have to worry about multiple replacements tags. After some finagling, I
    ended up with this sed command:'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºå¢é‡æ„å»ºï¼Œæˆ‘ä»¬å°†æ¨¡æ‹Ÿå¼€å‘äººå‘˜åœ¨Leptosç»„ä»¶ä¸­ä¿®æ”¹å•ä¸ªHTMLæ ‡è®°ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†è¿è¡Œæˆ‘ä»¬ä¾¿æ·çš„Unixæœ‹å‹`sed`ï¼Œå°†å½“å‰æ—¥æœŸå’Œæ—¶é—´æ’å…¥HTMLæ ‡è®°ä¸­ã€‚ä¸ºæ­¤ï¼Œæˆ‘é€‰æ‹©äº†`<dfn>`æ ‡è®°ï¼Œå› ä¸ºæˆ‘ä»æœªè§è¿‡å®ƒè¢«ä½¿ç”¨è¿‡ï¼Œå› æ­¤æˆ‘å¯èƒ½ä¸å¿…æ‹…å¿ƒå¤šæ¬¡æ›¿æ¢æ ‡è®°ã€‚ç»è¿‡ä¸€äº›è°ƒæ•´ï¼Œæˆ‘æœ€ç»ˆå¾—åˆ°äº†è¿™ä¸ªsedå‘½ä»¤ï¼š
- en: bash
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: bash
- en: '[PRE6]'
  id: totrans-split-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each configuration is tested six times, with two warmup runs to fill any caches
    and reduce variability in the output. Without the warmup runs variance was a bit
    wider, but the results were still consistent. Six runs is probably overkill for
    this test, but what can I say, I got CPU time for days, or more accurately nights.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªé…ç½®éƒ½ç»è¿‡å…­æ¬¡æµ‹è¯•ï¼Œå…¶ä¸­åŒ…æ‹¬ä¸¤æ¬¡é¢„çƒ­è¿è¡Œä»¥å¡«å……ä»»ä½•ç¼“å­˜å¹¶å‡å°‘è¾“å‡ºå˜å¼‚æ€§ã€‚æ²¡æœ‰é¢„çƒ­è¿è¡Œæ—¶ï¼Œå˜å¼‚æ€§ä¼šç•¥å¾®åŠ å¤§ï¼Œä½†ç»“æœä»ç„¶æ˜¯ä¸€è‡´çš„ã€‚å¯¹äºè¿™ä¸ªæµ‹è¯•æ¥è¯´ï¼Œå…­æ¬¡è¿è¡Œå¯èƒ½æœ‰ç‚¹å¤šä½™ï¼Œä½†æˆ‘èƒ½è¯´ä»€ä¹ˆå‘¢ï¼Œæˆ‘æœ‰å¤§é‡çš„CPUæ—¶é—´ï¼Œæˆ–è€…æ›´ç¡®åˆ‡åœ°è¯´æ˜¯å¤œé—´æ—¶é—´ã€‚
- en: We'll measure the time it takes to complete six runs, with two warmup runs to
    setup filesystem caches, and hopefully provide consistent results.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†æµ‹é‡å®Œæˆå…­æ¬¡è¿è¡Œæ‰€éœ€çš„æ—¶é—´ï¼ŒåŒ…æ‹¬ä¸¤æ¬¡é¢„çƒ­è¿è¡Œä»¥è®¾ç½®æ–‡ä»¶ç³»ç»Ÿç¼“å­˜ï¼Œå¹¶å¸Œæœ›æä¾›ä¸€è‡´çš„ç»“æœã€‚
- en: I will be compiling my [site](https://benwis), and Alex will be compiling [Houski's
    site](https://houski.ca). Houski's is a lot more complicated than this blog, with
    heavy usage of Polars, Serialization/Deserialization with Serde, and plenty more
    routes. Neither of us has tried to reduce these times much or done any special
    kinds of optimization.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å°†ç¼–è¯‘æˆ‘çš„[ç½‘ç«™](https://benwis)ï¼Œè€ŒAlexå°†ç¼–è¯‘[Houskiçš„ç½‘ç«™](https://houski.ca)ã€‚Houskiçš„ç½‘ç«™æ¯”è¿™ä¸ªåšå®¢å¤æ‚å¾—å¤šï¼Œå¤§é‡ä½¿ç”¨Polarsã€Serdeçš„åºåˆ—åŒ–/ååºåˆ—åŒ–ä»¥åŠæ›´å¤šçš„è·¯ç”±ã€‚æˆ‘ä»¬ä¸¤ä¸ªéƒ½æ²¡æœ‰å°è¯•å¤§å¹…ç¼©çŸ­è¿™äº›æ—¶é—´ï¼Œä¹Ÿæ²¡æœ‰è¿›è¡Œä»»ä½•ç‰¹æ®Šçš„ä¼˜åŒ–ã€‚
- en: For both of us, these will be the times to beat.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæˆ‘ä»¬ä¸¤ä¸ªæ¥è¯´ï¼Œè¿™äº›å°†æ˜¯è¦è¶…è¶Šçš„æ—¶é—´ã€‚
- en: '| Clean Compilation |  |  |'
  id: totrans-split-67
  prefs: []
  type: TYPE_TB
  zh: '| æ¸…æ´ç¼–è¯‘ |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-split-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Site | Mean(s) | Standard Deviation(s) |'
  id: totrans-split-69
  prefs: []
  type: TYPE_TB
  zh: '| ç½‘ç«™ | å¹³å‡(s) | æ ‡å‡†åå·®(s) |'
- en: '| benw.is 7200RPM | 88.387 | 1.817 |'
  id: totrans-split-70
  prefs: []
  type: TYPE_TB
  zh: '| benw.is 7200RPM | 88.387 | 1.817 |'
- en: '| benw.is NVME | 80.057 | 0.268 |'
  id: totrans-split-71
  prefs: []
  type: TYPE_TB
  zh: '| benw.is NVME | 80.057 | 0.268 |'
- en: '| houski.ca | 124.993 | 0.483 |'
  id: totrans-split-72
  prefs: []
  type: TYPE_TB
  zh: '| houski.ca | 124.993 | 0.483 |'
- en: '| Incremental Compilation |  |  |'
  id: totrans-split-73
  prefs: []
  type: TYPE_TB
  zh: '| å¢é‡ç¼–è¯‘ |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-split-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Site | Mean(s) | Standard Deviation(s) |'
  id: totrans-split-75
  prefs: []
  type: TYPE_TB
  zh: '| ç½‘ç«™ | å¹³å‡(s) | æ ‡å‡†åå·®(s) |'
- en: '| benw.is 7200RPM | 20.461 | 0.801 |'
  id: totrans-split-76
  prefs: []
  type: TYPE_TB
  zh: '| benw.is 7200RPM | 20.461 | 0.801 |'
- en: '| benw.is NVME | 19.097 | 0.078 |'
  id: totrans-split-77
  prefs: []
  type: TYPE_TB
  zh: '| benw.is NVME | 19.097 | 0.078 |'
- en: '| houski.ca | 40.818 | 0.252 |'
  id: totrans-split-78
  prefs: []
  type: TYPE_TB
  zh: '| houski.ca | 40.818 | 0.252 |'
- en: Not a bad baseline. Interesting to me was the variation in the 7200RPM build
    time for both clean and incremental builds, which might suggest that the drive
    was struggling to provide the data at the same rate consistently, or perhaps something
    else was contending with the benchmark for IO access.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ç®—å¤ªå·®çš„åŸºçº¿ã€‚æˆ‘è§‰å¾—æœ‰è¶£çš„æ˜¯åœ¨7200è½¬/åˆ†é’Ÿçš„æ„å»ºæ—¶é—´å˜åŒ–ï¼Œæ— è®ºæ˜¯å¹²å‡€æ„å»ºè¿˜æ˜¯å¢é‡æ„å»ºï¼Œè¿™å¯èƒ½è¡¨æ˜ç¡¬ç›˜åœ¨ä¿æŒä¸€è‡´çš„æ•°æ®æä¾›é€Ÿç‡æ–¹é¢å¯èƒ½æœ‰å›°éš¾ï¼Œæˆ–è€…å¯èƒ½æœ‰å…¶ä»–å› ç´ æ­£åœ¨äº‰å¤ºIOè®¿é—®çš„åŸºå‡†ã€‚
- en: Twenty or forty seconds is a pretty substantial time to rebuild the site in
    the dev profile, hopefully we can improve that.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 20æˆ–40ç§’åœ¨devé…ç½®æ–‡ä»¶ä¸­é‡æ–°æ„å»ºç½‘ç«™æ˜¯ä¸€ä¸ªç›¸å½“å¤§çš„æ—¶é—´ï¼Œå¸Œæœ›æˆ‘ä»¬èƒ½æ”¹è¿›ã€‚
- en: Let's enable the Mold linker as described earlier, and see how that changes
    things!
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æŒ‰ç…§ä¹‹å‰æè¿°çš„æ–¹å¼å¯ç”¨Moldé“¾æ¥å™¨ï¼Œçœ‹çœ‹è¿™å°†å¦‚ä½•æ”¹å˜äº‹æƒ…ï¼
- en: '| Clean Compilation |  |  |  |  |'
  id: totrans-split-82
  prefs: []
  type: TYPE_TB
  zh: '| æ¸…æ´ç¼–è¯‘ |  |  |  |  |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-84
  prefs: []
  type: TYPE_TB
  zh: '| ç½‘ç«™ | å¹³å‡(s) | æ ‡å‡†åå·®(s) | ä¸åŸºçº¿çš„å·®å¼‚(s) | % ä¸åŸºçº¿çš„å·®å¼‚ |'
- en: '| benw.is 7200RPM | 74.35 | 0.96 | 14.037 | 15.88129476 |'
  id: totrans-split-85
  prefs: []
  type: TYPE_TB
  zh: '| benw.is 7200RPM | 74.35 | 0.96 | 14.037 | 15.88129476 |'
- en: '| benw.is NVME | 67.206 | 0.386 | 12.851 | 16.05231273 |'
  id: totrans-split-86
  prefs: []
  type: TYPE_TB
  zh: '| benw.is NVME | 67.206 | 0.386 | 12.851 | 16.05231273 |'
- en: '| houski.ca | 102.892 | 0.416 | 22.101 | 17.68179018 |'
  id: totrans-split-87
  prefs: []
  type: TYPE_TB
  zh: '| houski.ca | 102.892 | 0.416 | 22.101 | 17.68179018 |'
- en: '| Incremental Compilation |  |  |  |  |'
  id: totrans-split-88
  prefs: []
  type: TYPE_TB
  zh: '| å¢é‡ç¼–è¯‘ |  |  |  |  |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-90
  prefs: []
  type: TYPE_TB
  zh: '| ç½‘ç«™ | å¹³å‡(s) | æ ‡å‡†åå·®(s) | ä¸åŸºçº¿çš„å·®å¼‚(s) | % ä¸åŸºçº¿çš„å·®å¼‚ |'
- en: '| benw.is 7200RPM | 5.842 | 0.268 | 14.619 | 71.44812082 |'
  id: totrans-split-91
  prefs: []
  type: TYPE_TB
  zh: '| benw.is 7200RPM | 5.842 | 0.268 | 14.619 | 71.44812082 |'
- en: '| benw.is NVME | 5.615 | 0.051 | 13.482 | 70.59747604 |'
  id: totrans-split-92
  prefs: []
  type: TYPE_TB
  zh: '| benw.is NVME | 5.615 | 0.051 | 13.482 | 70.59747604 |'
- en: '| houski.ca | 19.6 | 0.067 | 21.218 | 51.98196874 |'
  id: totrans-split-93
  prefs: []
  type: TYPE_TB
  zh: '| houski.ca | 19.6 | 0.067 | 21.218 | 51.98196874 |'
- en: Woah! That's quite a bit faster. For my site, clean compilation time decreased
    by 12.04s(13.6%) on spinning disk and 12.80s(16.0%) for NVME. Houski dropped 22.10s(17.7s).
    Nice boost there.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: å“‡ï¼è¿™å¿«äº†ä¸å°‘ã€‚å¯¹äºæˆ‘çš„ç«™ç‚¹ï¼Œæ—‹è½¬ç£ç›˜çš„æ¸…æ´ç¼–è¯‘æ—¶é—´å‡å°‘äº†12.04ç§’ï¼ˆ13.6%ï¼‰ï¼ŒNVMEå‡å°‘äº†12.80ç§’ï¼ˆ16.0%ï¼‰ã€‚Houskiå‡å°‘äº†22.10ç§’ï¼ˆ17.7ç§’ï¼‰ã€‚è¿™æ˜¯ä¸€ä¸ªä¸é”™çš„æå‡ã€‚
- en: Incremental compilation times changed signifigantly as well. My site on spinning
    disk dropped 14.62s(71.4%) and 13.5s(70.6%). That's a radical reduction, which
    makes some sense. Incremental compilation spends a majority of it's time in the
    linking step, so any upgrades there will disproportionally affect it.
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: å¢é‡ç¼–è¯‘æ—¶é—´ä¹Ÿå‘ç”Ÿäº†æ˜¾è‘—å˜åŒ–ã€‚æˆ‘çš„æ—‹è½¬ç£ç›˜ç«™ç‚¹å‡å°‘äº†14.62ç§’ï¼ˆ71.4%ï¼‰ï¼ŒNVMEå‡å°‘äº†13.5ç§’ï¼ˆ70.6%ï¼‰ã€‚è¿™æ˜¯ä¸€ä¸ªæ ¹æœ¬æ€§çš„æ”¹è¿›ï¼Œè¿™åœ¨æŸç§ç¨‹åº¦ä¸Šæ˜¯åˆç†çš„ã€‚å¢é‡ç¼–è¯‘çš„å¤§éƒ¨åˆ†æ—¶é—´éƒ½èŠ±åœ¨é“¾æ¥æ­¥éª¤ä¸Šï¼Œå› æ­¤åœ¨è¿™é‡Œè¿›è¡Œä»»ä½•å‡çº§å°†ä¼šä¸æˆæ¯”ä¾‹åœ°å½±å“å®ƒã€‚
- en: As far as Leptos users go, mold only supports compiling for x84_64_linux, so
    the webassembly compile time remained unchanged. Most of these optimizations only
    affect the server build, but I will be careful to note which ones don't.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: è‡³äºLeptosç”¨æˆ·ï¼ŒMoldä»…æ”¯æŒx84_64_linuxçš„ç¼–è¯‘ï¼Œå› æ­¤WebAssemblyçš„ç¼–è¯‘æ—¶é—´ä¿æŒä¸å˜ã€‚è¿™äº›ä¼˜åŒ–å¤§å¤šæ•°åªå½±å“æœåŠ¡å™¨æ„å»ºï¼Œä½†æˆ‘ä¼šæ³¨æ„å“ªäº›ä¸å—å…¶å½±å“ã€‚
- en: With few downsides, and such a huge upside, Mold/Sold seems like a no-brainer,
    especially if you are doing a lot of incremental builds!
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†ä¸€äº›å°ç¼ºç‚¹å¤–ï¼Œå¦‚æ­¤å·¨å¤§çš„ä¼˜åŠ¿ï¼ŒMold/Soldä¼¼ä¹æ˜¯ä¸€ä¸ªæ˜æ™ºçš„é€‰æ‹©ï¼Œç‰¹åˆ«æ˜¯å¦‚æœä½ ç»å¸¸è¿›è¡Œå¢é‡æ„å»ºï¼
- en: What will adding more optimization do to compile times?
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: æ·»åŠ æ›´å¤šä¼˜åŒ–å°†å¦‚ä½•å½±å“ç¼–è¯‘æ—¶é—´ï¼Ÿ
- en: '| Clean Compilation |  |  |  |  |'
  id: totrans-split-99
  prefs: []
  type: TYPE_TB
  zh: '| æ¸…æ´ç¼–è¯‘ |  |  |  |  |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-101
  prefs: []
  type: TYPE_TB
  zh: '| ç«™ç‚¹ | å¹³å‡æ—¶é—´(s) | æ ‡å‡†åå·®(s) | åŸºå‡†æ—¶é—´å·®(s) | % åŸºå‡†æ—¶é—´å·® |'
- en: '| benw.is 7200RPM | 174.399 | 0.488 | -86.012 | -97.31295326 |'
  id: totrans-split-102
  prefs: []
  type: TYPE_TB
  zh: '| benw.is 7200RPM | 174.399 | 0.488 | -86.012 | -97.31295326 |'
- en: '| benw.is NVME | 166.847 | 0.41 | -86.79 | -108.4102577 |'
  id: totrans-split-103
  prefs: []
  type: TYPE_TB
  zh: '| benw.is NVME | 166.847 | 0.41 | -86.79 | -108.4102577 |'
- en: '| houski.ca | 288.562 | 0.674 | -163.569 | -130.8625283 |'
  id: totrans-split-104
  prefs: []
  type: TYPE_TB
  zh: '| houski.ca | 288.562 | 0.674 | -163.569 | -130.8625283 |'
- en: '| Incremental Compilation |  |  |  |  |'
  id: totrans-split-105
  prefs: []
  type: TYPE_TB
  zh: '| å¢é‡ç¼–è¯‘ |  |  |  |  |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-107
  prefs: []
  type: TYPE_TB
  zh: '| ç«™ç‚¹ | å¹³å‡æ—¶é—´(s) | æ ‡å‡†åå·®(s) | åŸºå‡†æ—¶é—´å·®(s) | % åŸºå‡†æ—¶é—´å·® |'
- en: '| benw.is 7200RPM | 16.201 | 1.303 | 4.26 | 20.82009677 |'
  id: totrans-split-108
  prefs: []
  type: TYPE_TB
  zh: '| benw.is 7200RPM | 16.201 | 1.303 | 4.26 | 20.82009677 |'
- en: '| benw.is NVME | 14.334 | 0.147 | 4.763 | 24.94109022 |'
  id: totrans-split-109
  prefs: []
  type: TYPE_TB
  zh: '| benw.is NVME | 14.334 | 0.147 | 4.763 | 24.94109022 |'
- en: '| houski.ca | 32.489 | 0.348 | 8.329 | 20.40521339 |'
  id: totrans-split-110
  prefs: []
  type: TYPE_TB
  zh: '| houski.ca | 32.489 | 0.348 | 8.329 | 20.40521339 |'
- en: I did expect a clean compile to be slower, but this is quite a bit slower. Compared
    to baseline, it takes twice as long for clean builds. Incremental builds do net
    a twenty percent improvement, which is nice to see. Contained within the listed
    build time is a doubling of both the webassembly and server builds, which makes
    sense but should be noted. For me, I don't think the benefits of setting this
    are worth the delays in clean compile times.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ç¡®å®é¢„æ–™åˆ°æ¸…æ´ç¼–è¯‘ä¼šæ…¢ä¸€äº›ï¼Œä½†å®ƒç¡®å®æ…¢äº†å¾ˆå¤šã€‚ä¸åŸºå‡†ç›¸æ¯”ï¼Œæ¸…æ´æ„å»ºæ—¶é—´æ˜¯åŸæ¥çš„ä¸¤å€ã€‚å¢é‡æ„å»ºçš„ç¡®å®è·å¾—äº†20%çš„æ”¹è¿›ï¼Œè¿™æ˜¯ä»¤äººæ¬£æ…°çš„ã€‚åœ¨åˆ—å‡ºçš„æ„å»ºæ—¶é—´ä¸­ï¼ŒåŒ…å«äº†WebAssemblyå’ŒæœåŠ¡å™¨æ„å»ºæ—¶é—´çš„ç¿»å€ï¼Œè¿™æ˜¯æœ‰é“ç†çš„ï¼Œä½†åº”è¯¥æ³¨æ„åˆ°ã€‚å¯¹æˆ‘æ¥è¯´ï¼Œè®¾å®šè¿™äº›çš„å¥½å¤„å¹¶ä¸å€¼å¾—å»¶è¿Ÿæ¸…æ´ç¼–è¯‘æ—¶é—´ã€‚
- en: '| Clean Compilation |  |  |  |  |'
  id: totrans-split-112
  prefs: []
  type: TYPE_TB
  zh: '| æ¸…æ´ç¼–è¯‘ |  |  |  |  |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-114
  prefs: []
  type: TYPE_TB
  zh: '| ç«™ç‚¹ | å¹³å‡æ—¶é—´(s) | æ ‡å‡†åå·®(s) | åŸºå‡†æ—¶é—´å·®(s) | % åŸºå‡†æ—¶é—´å·® |'
- en: '| benw.is 7200RPM | 67.989 | 0.763 | 20.398 | 23.07805447 |'
  id: totrans-split-115
  prefs: []
  type: TYPE_TB
  zh: '| benw.is 7200RPM | 67.989 | 0.763 | 20.398 | 23.07805447 |'
- en: '| benw.is NVME | 63.645 | 0.247 | 16.412 | 20.50039347 |'
  id: totrans-split-116
  prefs: []
  type: TYPE_TB
  zh: '| benw.is NVME | 63.645 | 0.247 | 16.412 | 20.50039347 |'
- en: '| houski.ca |  |  |  |  |'
  id: totrans-split-117
  prefs: []
  type: TYPE_TB
  zh: '| houski.ca |  |  |  |  |'
- en: '| Incremental Compilation |  |  |  |  |'
  id: totrans-split-118
  prefs: []
  type: TYPE_TB
  zh: '| å¢é‡ç¼–è¯‘ |  |  |  |  |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-120
  prefs: []
  type: TYPE_TB
  zh: '| ç«™ç‚¹ | å¹³å‡æ—¶é—´(s) | æ ‡å‡†åå·®(s) | åŸºå‡†æ—¶é—´å·®(s) | % åŸºå‡†æ—¶é—´å·® |'
- en: '| benw.is 7200RPM | 9.201 | 0.092 | 11.26 | 55.03152339 |'
  id: totrans-split-121
  prefs: []
  type: TYPE_TB
  zh: '| benw.is 7200RPM | 9.201 | 0.092 | 11.26 | 55.03152339 |'
- en: '| benw.is NVME | 9.345 | 0.212 | 9.752 | 51.0656124 |'
  id: totrans-split-122
  prefs: []
  type: TYPE_TB
  zh: '| benw.is NVME | 9.345 | 0.212 | 9.752 | 51.0656124 |'
- en: '| houski.ca |  |  |  |  |'
  id: totrans-split-123
  prefs: []
  type: TYPE_TB
  zh: '| houski.ca |  |  |  |  |'
- en: Cranelift, I had high hopes for you, and you delivered! It improved both clean
    and incremental compilations compared to the baseline. You may notice that the
    houski app lines here are blank, which are due to a failure to compile due to
    missing llvm intrinsics.
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: Craneliftï¼Œæˆ‘å¯¹ä½ å¯„äºˆäº†å¾ˆé«˜çš„æœŸæœ›ï¼Œè€Œä½ ä¹Ÿæ²¡æœ‰è¾œè´Ÿï¼ä¸åŸºå‡†ç›¸æ¯”ï¼Œå®ƒåœ¨æ¸…æ´å’Œå¢é‡ç¼–è¯‘ä¸­éƒ½æœ‰æ‰€æ”¹å–„ã€‚ä½ å¯èƒ½ä¼šæ³¨æ„åˆ°è¿™é‡Œçš„houskiåº”ç”¨è¡Œæ˜¯ç©ºç™½çš„ï¼Œè¿™æ˜¯ç”±äºç¼ºå°‘llvmå†…ç½®å‡½æ•°è€Œæ— æ³•ç¼–è¯‘ã€‚
- en: After my testing completed, they merged this [PR](%5B#1417%5D(https://github.com/rust-lang/rustc_codegen_cranelift/pull/1417))
    which added the missing `llvm.x86.avx.ldu.dq.256` instrinsic, and @bjorn3 mentioned
    that I can avoid the missing aes intrinsics with a rust flag `RUSTFLAGS="--cfg
    aes_force_soft"`. Either that, or this [PR](https://github.com/rust-lang/rustc_codegen_cranelift/pull/1425)
    gets merged into rustup nightly. I hope to update this section soon.
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
- en: If you are missing intrinsics, you can hook up a debugger to see what is causing
    the trap, or you can use `cargo vendor` and do a search for the the intrinsic
    name or part of the intrinsic name. I'd be sure to mention anything you're missing
    in the [rustc cranelift repo](https://github.com/rust-lang/rustc_codegen_cranelift/issues/171#issuecomment-1803136179)
    and occasionally check in to see if there's a fix coming. @bjorn3 is on a roll
    there.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
- en: '| Clean Compilation |  |  |  |  |'
  id: totrans-split-127
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-128
  prefs: []
  type: TYPE_TB
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-129
  prefs: []
  type: TYPE_TB
- en: '| benw.is 7200RPM | 170.241 | 1.016 | -81.854 | -92.60864154 |'
  id: totrans-split-130
  prefs: []
  type: TYPE_TB
- en: '| benw.is NVME | 168.047 | 1.018 | -87.99 | -109.9091897 |'
  id: totrans-split-131
  prefs: []
  type: TYPE_TB
- en: '| houski.ca | 271.949 | 0.735 | -146.956 | -117.571384 |'
  id: totrans-split-132
  prefs: []
  type: TYPE_TB
- en: '| Incremental Compilation |  |  |  |  |'
  id: totrans-split-133
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-134
  prefs: []
  type: TYPE_TB
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-135
  prefs: []
  type: TYPE_TB
- en: '| benw.is 7200RPM | 5.789 | 0.051 | 14.672 | 71.70715019 |'
  id: totrans-split-136
  prefs: []
  type: TYPE_TB
- en: '| benw.is NVME | 5.727 | 0.041 | 13.37 | 70.01099649 |'
  id: totrans-split-137
  prefs: []
  type: TYPE_TB
- en: '| houski.ca | 18.15 | 0.202 | 22.668 | 55.53432309 |'
  id: totrans-split-138
  prefs: []
  type: TYPE_TB
- en: Our first combination of features. Unforunately, this seems to have the slow
    clean compile times of O3, without decreasing compile times more than mold alone.
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
- en: '| Clean Compilation |  |  |  |  |'
  id: totrans-split-140
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-141
  prefs: []
  type: TYPE_TB
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-142
  prefs: []
  type: TYPE_TB
- en: '| benw.is 7200RPM | 107.401 | 1.05 | -19.014 | -21.51221333 |'
  id: totrans-split-143
  prefs: []
  type: TYPE_TB
- en: '| benw.is NVME | 103.544 | 0.88 | -23.487 | -29.33784678 |'
  id: totrans-split-144
  prefs: []
  type: TYPE_TB
- en: '| houski.ca |  |  |  |  |'
  id: totrans-split-145
  prefs: []
  type: TYPE_TB
- en: '| Incremental Compilation |  |  |  |  |'
  id: totrans-split-146
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-147
  prefs: []
  type: TYPE_TB
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-148
  prefs: []
  type: TYPE_TB
- en: '| benw.is 7200RPM | 4.992 | 0.322 | 15.469 | 75.60236548 |'
  id: totrans-split-149
  prefs: []
  type: TYPE_TB
- en: '| benw.is NVME | 4.767 | 0.073 | 14.33 | 75.03796408 |'
  id: totrans-split-150
  prefs: []
  type: TYPE_TB
- en: '| houski.ca |  |  |  |  |'
  id: totrans-split-151
  prefs: []
  type: TYPE_TB
- en: Let's enable all the things! The incremental compiles are faster than any of
    the previously tested options, but the clean compiles are still suffering a penalty
    from O3\. Cranelift seems to reduce the penalty from O3, but time will tell whether
    it is better than Mold + Cranelift alone. I suspect this is because Cranelift
    optimizes less than llvm, which is in line with their documentation.
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
- en: '| Clean Compilation |  |  |  |  |'
  id: totrans-split-153
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-154
  prefs: []
  type: TYPE_TB
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-155
  prefs: []
  type: TYPE_TB
- en: '| benw.is 7200RPM | 110.251 | 0.687 | -21.864 | -24.737 |'
  id: totrans-split-156
  prefs: []
  type: TYPE_TB
- en: '| benw.is NVME | 106.732 | 0.526 | -26.675 | -33.323 |'
  id: totrans-split-157
  prefs: []
  type: TYPE_TB
- en: '| houski.ca |  |  |  |  |'
  id: totrans-split-158
  prefs: []
  type: TYPE_TB
- en: '| Incremental Compilation |  |  |  |  |'
  id: totrans-split-159
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-160
  prefs: []
  type: TYPE_TB
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-161
  prefs: []
  type: TYPE_TB
- en: '| benw.is 7200RPM | 9.096 | 0.351 | 11.365 | 55.54469479 |'
  id: totrans-split-162
  prefs: []
  type: TYPE_TB
- en: '| benw.is NVME | 8.73 | 0.076 | 10.367 | 54.28601351 |'
  id: totrans-split-163
  prefs: []
  type: TYPE_TB
- en: '| houski.ca |  |  |  |  |'
  id: totrans-split-164
  prefs: []
  type: TYPE_TB
- en: Adding further support to the Cranelift optimization hypothesis, we see similiar
    performance in the clean compilation, but slower performance in incremental without
    Mold enabled. It is interesting that this ran faster than the previous test with
    Mold enabled, although I am not sure the difference is signifigant. Perhaps Mold
    and Cranelift or Mold and O3 have some negative interaction I don't recognize.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
- en: '| Clean Compilation |  |  |  |  |'
  id: totrans-split-166
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-167
  prefs: []
  type: TYPE_TB
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-168
  prefs: []
  type: TYPE_TB
- en: '| benw.is 7200RPM | 65.343 | 1.243 | 23.044 | 26.07170738 |'
  id: totrans-split-169
  prefs: []
  type: TYPE_TB
- en: '| benw.is NVME | 59.777 | 0.191 | 20.28 | 25.33195098 |'
  id: totrans-split-170
  prefs: []
  type: TYPE_TB
- en: '| houski.ca |  |  |  |  |'
  id: totrans-split-171
  prefs: []
  type: TYPE_TB
- en: '| Incremental Compilation |  |  |  |  |'
  id: totrans-split-172
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-split-173
  prefs: []
  type: TYPE_TB
- en: '| Site | Mean(s) | Standard Deviation(s) | Delta from Baseline(s) | % Delta
    from Baseline |'
  id: totrans-split-174
  prefs: []
  type: TYPE_TB
- en: '| benw.is 7200RPM | 4.831 | 0.251 | 15.63 | 76.38922829 |'
  id: totrans-split-175
  prefs: []
  type: TYPE_TB
- en: '| benw.is NVME | 4.654 | 0.067 | 14.443 | 75.62968005 |'
  id: totrans-split-176
  prefs: []
  type: TYPE_TB
- en: '| houski.ca |  |  |  |  |'
  id: totrans-split-177
  prefs: []
  type: TYPE_TB
- en: Here's the big money, Cranelift and Mold together. This offered the fastest
    clean compilation times, with a roughly 25% reduction, and incremental, sitting
    pretty at around 75% reduction. Interestingly enough, there seemed to be little
    difference between the NVME and the 7200RPM drives here, suggesting that these
    two might be better at using disk I/O than some of the other configurations.
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
- en: For Rust web frameworks, we can try to simulate the performance of HMR, but
    we won't be able to substitute JS modules. Our attempt to do this is in cargo-leptos,
    and can be used with the `--hot-reload` flag. It will attempt to send html and
    css patches to the browser over a web socket connection when a change inside a
    `view` macro is detected that does not involve a change to a rust code block,
    and compile in the background. For me it works fairly well.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
- en: I didn't try to instrument and test it, as hot reload times are nearly instant.
    Any changes to the rust code will require a incremental recompilation though,
    which is why it's so useful to improve that time. JS frameworks will probably
    have an edge there for the foreseeable future.
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Mold and Cranelift netted me a 75% incremental and 25% clean compilation
    time reduction, which is quite signifigant. Using Cranelift requires nightly,
    or setting it up outside rustup, which some projects might find undesirable. Since
    Mold requires Linux, and Sold requires Mac(and paying), for me this further increases
    the argument that Rust web development should be done on some for of Linux or
    Mac, and not on Windows. WSL2 may help improve things, but may [be slower](https://medium.com/for-linux-users/wsl-2-why-you-should-use-real-linux-instead-4ee14364c18).
    Since I have a Mac laptop and a Linux workstation, I will be buying Sold for my
    Mac and using Cranelift for my projects that can.
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ç”¨Moldå’ŒCraneliftä½¿æˆ‘å‡å°‘äº†75%çš„å¢é‡å’Œ25%çš„å¹²å‡€ç¼–è¯‘æ—¶é—´ï¼Œè¿™æ˜¯ç›¸å½“æ˜¾è‘—çš„ã€‚ä½¿ç”¨Craneliftéœ€è¦nightlyç‰ˆæœ¬ï¼Œæˆ–è€…åœ¨rustupä¹‹å¤–è®¾ç½®å®ƒï¼Œè¿™å¯èƒ½ä¼šè®©ä¸€äº›é¡¹ç›®æ„Ÿåˆ°ä¸ç†æƒ³ã€‚ç”±äºMoldéœ€è¦Linuxï¼ŒSoldéœ€è¦Macï¼ˆå¹¶ä¸”éœ€è¦æ”¯ä»˜è´¹ç”¨ï¼‰ï¼Œå¯¹æˆ‘æ¥è¯´ï¼Œè¿™è¿›ä¸€æ­¥å¢å¼ºäº†Rust
    Webå¼€å‘åº”è¯¥åœ¨æŸç§Linuxæˆ–Macä¸Šè¿›è¡Œï¼Œè€Œä¸æ˜¯åœ¨Windowsä¸Šçš„è®ºç‚¹ã€‚WSL2å¯èƒ½æœ‰åŠ©äºæ”¹å–„æƒ…å†µï¼Œä½†å¯èƒ½ä¼š[æ›´æ…¢ä¸€äº›](https://medium.com/for-linux-users/wsl-2-why-you-should-use-real-linux-instead-4ee14364c18)ã€‚å› ä¸ºæˆ‘æœ‰ä¸€å°Macç¬”è®°æœ¬å’Œä¸€å°Linuxå·¥ä½œç«™ï¼Œæ‰€ä»¥æˆ‘å°†ä¸ºæˆ‘çš„Macè´­ä¹°Soldï¼Œå¹¶åœ¨å¯ä»¥ä½¿ç”¨Craneliftçš„é¡¹ç›®ä¸­ä½¿ç”¨å®ƒã€‚
- en: If you feel like running some of these tests on your hardware or with your project,
    I have automated the process somewhat and put that repo on Github [here](https://github.com/benwis/customs).
  id: totrans-split-182
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æƒ³åœ¨ä½ çš„ç¡¬ä»¶æˆ–è€…ä½ çš„é¡¹ç›®ä¸Šè¿è¡Œè¿™äº›æµ‹è¯•ï¼Œæˆ‘å·²ç»åœ¨Githubä¸Šè‡ªåŠ¨åŒ–äº†éƒ¨åˆ†è¿‡ç¨‹ï¼Œå¹¶å°†é‚£ä¸ªä»“åº“æ”¾åœ¨[è¿™é‡Œ](https://github.com/benwis/customs)ã€‚
- en: Let me know what your experience was, and whether this helped you with your
    project by reaching out on mastodon at `@benwis@hachyderm.io`.
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘çŸ¥é“ä½ çš„ç»å†å¦‚ä½•ï¼Œå¹¶ä¸”è¿™æ˜¯å¦é€šè¿‡åœ¨mastodonä¸Šè”ç³»`@benwis@hachyderm.io`å¯¹ä½ çš„é¡¹ç›®æœ‰æ‰€å¸®åŠ©ã€‚
