["```\n0\\. Preface\n1\\. Complexity Models\n 1.1\\. Modern Hardware\n 1.2\\. Programming Languages\n 1.3\\. Models of Computation\n 1.4\\. When to Optimize\n2\\. Computer Architecture\n 1.1\\. Instruction Set Architectures\n 1.2\\. Assembly Language\n 1.3\\. Loops and Conditionals\n 1.4\\. Functions and Recursion\n 1.5\\. Indirect Branching\n 1.6\\. Machine Code Layout\n 1.7\\. System Calls\n 1.8\\. Virtualization\n3\\. Instruction-Level Parallelism\n 3.1\\. Pipeline Hazards\n 3.2\\. The Cost of Branching\n 3.3\\. Branchless Programming\n 3.4\\. Instruction Tables\n 3.5\\. Instruction Scheduling\n 3.6\\. Throughput Computing\n 3.7\\. Theoretical Performance Limits\n4\\. Compilation\n 4.1\\. Stages of Compilation\n 4.2\\. Flags and Targets\n 4.3\\. Situational Optimizations\n 4.4\\. Contract Programming\n 4.5\\. Non-Zero-Cost Abstractions\n 4.6\\. Compile-Time Computation\n 4.7\\. Arithmetic Optimizations\n 4.8\\. What Compilers Can and Can't Do\n5\\. Profiling\n 5.1\\. Instrumentation\n 5.2\\. Statistical Profiling\n 5.3\\. Program Simulation\n 5.4\\. Machine Code Analyzers\n 5.5\\. Benchmarking\n 5.6\\. Getting Accurate Results\n6\\. Arithmetic\n 6.1\\. Floating-Point Numbers\n 6.2\\. Interval Arithmetic\n 6.3\\. Newton's Method\n 6.4\\. Fast Inverse Square Root\n 6.5\\. Integers\n 6.6\\. Integer Division\n 6.7\\. Bit Manipulation\n(6.8\\. Data Compression)\n7\\. Number Theory\n 7.1\\. Modular Inverse\n 7.2\\. Montgomery Multiplication\n(7.3\\. Finite Fields)\n(7.4\\. Error Correction)\n 7.5\\. Cryptography\n 7.6\\. Hashing\n 7.7\\. Random Number Generation\n8\\. External Memory\n 8.1\\. Memory Hierarchy\n 8.2\\. Virtual Memory\n 8.3\\. External Memory Model\n 8.4\\. External Sorting\n 8.5\\. List Ranking\n 8.6\\. Eviction Policies\n 8.7\\. Cache-Oblivious Algorithms\n 8.8\\. Spacial and Temporal Locality\n(8.9\\. B-Trees)\n(8.10\\. Sublinear Algorithms)\n(9.13\\. Memory Management)\n9\\. RAM & CPU Caches\n 9.1\\. Memory Bandwidth\n 9.2\\. Memory Latency\n 9.3\\. Cache Lines\n 9.4\\. Memory Sharing\n 9.5\\. Memory-Level Parallelism\n 9.6\\. Prefetching\n 9.7\\. Alignment and Packing\n 9.8\\. Pointer Alternatives\n 9.9\\. Cache Associativity\n 9.10\\. Memory Paging\n 9.11\\. AoS and SoA\n10\\. SIMD Parallelism\n 10.1\\. Intrinsics and Vector Types\n 10.2\\. Moving Data\n 10.3\\. Reductions\n 10.4\\. Masking and Blending\n 10.5\\. In-Register Shuffles\n 10.6\\. Auto-Vectorization and SPMD\n11\\. Algorithm Case Studies\n 11.1\\. Binary GCD\n(11.2\\. Prime Number Sieves)\n 11.3\\. Integer Factorization\n 11.4\\. Logistic Regression\n 11.5\\. Big Integers & Karatsuba Algorithm\n 11.6\\. Fast Fourier Transform\n 11.7\\. Number-Theoretic Transform\n 11.8\\. Argmin with SIMD\n 11.9\\. Prefix Sum with SIMD\n 11.10\\. Reading Decimal Integers\n 11.11\\. Writing Decimal Integers\n(11.12\\. Reading and Writing Floats)\n(11.13\\. String Searching)\n 11.14\\. Sorting\n 11.15\\. Matrix Multiplication\n12\\. Data Structure Case Studies\n 12.1\\. Binary Search\n 12.2\\. Static B-Trees\n(12.3\\. Search Trees)\n 12.4\\. Segment Trees\n(12.5\\. Tries)\n(12.6\\. Range Minimum Query)\n 12.7\\. Hash Tables\n(12.8\\. Bitmaps)\n(12.9\\. Probabilistic Filters) \n```"]