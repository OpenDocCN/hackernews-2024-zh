<!--yml

category: 未分类

date: 2024-05-29 12:29:42

-->

# 理解谷歌文件系统

> Source: [https://www.micahlerner.com/2020/03/22/understanding-googles-file-system.html](https://www.micahlerner.com/2020/03/22/understanding-googles-file-system.html)

[Hacker News的讨论](https://news.ycombinator.com/item?id=39756262)

*这些论文评论可以[每周发送到您的收件箱](https://newsletter.micahlerner.com/)，或者您可以订阅[Atom feed](https://www.micahlerner.com/feed.xml)。如往常一样，欢迎通过[Twitter](https://twitter.com/micahlerner)提供反馈或建议！*

今天我阅读了[谷歌文件系统（GFS）的原始论文](https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf)，这是谷歌早期公司应用中提供存储层的系统。据报道，原始实现已被称为Colossus的新版本取代，但阅读原始方法仍然很有启发性，我想快速写一篇关于它的简要总结。

### GFS为何如此重要？

原始论文于2003年在SOSP（操作系统原理研讨会 - 是操作系统研究中最好的会议之一）上发表。

GFS之所以如此革命性，是因为它成功地在产业应用中以极大规模实现了学术上弱一致性和对单个主控制器的依赖的思想，附带的论文详细说明了当时的情况。

GFS的最终目标是在谷歌数据中心的商品级机器上提供复制的存储层（数据的冗余副本分布在多台机器上）。开发这样一个系统的最初动机是为了支持批处理作业，尽管最终该系统也为其他项目提供了动力。

因为GFS设计用于批处理作业，主要优化的是文件的追加，而不是修改。程序的用户通常一次性写入大文件，而不是对文件的特定部分进行修改。

### GFS的驱动抽象是什么？

GFS的核心概念是**chunk**（块）。Chunks用于将文件分割成固定大小的64MB段，然后在数据中心周围复制这些段[†](#footnotes)。Chunks由**chunk handle**（块句柄）引用，基本上是块的唯一标识符。将大文件分割成许多块，然后在多台机器上复制这些块实现了两个目标：提高性能（因为现在可以有多个读者和写者访问单个文件）并允许大文件存在于简单的抽象之后。

为了更具体地说明这种抽象工作原理的想法，请想象使用一个库来打开磁盘上的文件。在幕后，该库现在会从数据中心各处的计算机上获取您请求的文件的所有不同部分，然后提供一种透明的方式与拼接在一起的数据进行交互 [†](#footnotes)。

上述库（由您的用户程序调用，称为客户端）通过与GFS的几个组件交互来执行获取和写入操作：

+   **主节点**：主节点有几个职责。首先，当客户端希望与GFS交互时，它是客户端的第一个接触点。除了这个功能之外，主节点还负责与托管分块的一组**分块服务器**进行通信。为了执行其功能，主节点在RAM中存储了几个表：

    +   从文件名到**分块句柄**的映射（分块句柄基本上是分块的ID）。

    +   从**分块句柄**到存储该分块的机器列表的映射，分块的版本信息（用于管理对同一分块的多次写入的数据片段），以及两个与管理对该分块的写入相关的信息 - 主要和租约。我将在下一节讨论主要和租约。

+   **分块服务器**：分块服务器处理与磁盘写入和读取相关的工作。客户端在主节点告知后开始与它们通信。

### 写入和从GFS中读取的工作原理是怎样的？

#### 从GFS中读取

要从GFS中读取文件，客户端对主节点说：“我想读取此文件中的这个字节偏移量”，文件看起来像是一个常规的文件系统路径。

然后，主节点接收来自客户端的请求，并计算与关联文件和字节偏移量对应的分块。使用计算出的分块的分块句柄，主节点然后获取存储上述分块的分块服务器列表，并将其提供给客户端。然后客户端选择一个分块服务器，与其联系，并获取它想要的分块和偏移量，然后获取请求的数据。

在整个过程中，客户端还会缓存有关分块和它能找到的分块服务器的信息，以便在需要时重新请求该分块。

#### 写入到GFS中

在GFS中写入（在这种情况下，追加）文件比从GFS中读取要复杂得多。

要启动客户端，客户端向主节点请求特定文件的最后一个分块（由于我们正在附加，所以文件的末尾是必要的）。然后，主节点检查其表以获取有关该分块的信息，使用返回的分块句柄（分块句柄实质上是分块的ID）。

然后，主节点检查它关于每个分块存储的两个信息 - 主要字段和租约字段。

**主服务器**是指被分配协调块服务器之间写入的块服务器的引用。此分配是短暂的，并受**租约**到期的管理。租约到期后，主服务器可以分配新的块服务器来协调写入操作。

如果客户端请求的块没有分配主服务器，主服务器将分配一个并增加数据的版本号。增加版本号允许主服务器跟踪最新的数据。如果块已经有了主服务器，则跳过此步骤。

下一步是向客户端传输关于主服务器和副本（具有块但不是主服务器的块服务器）的信息。然后，客户端将要写入的数据发送到各个块服务器。当所有块服务器都有数据后，客户端告诉主服务器进行写入。主块服务器选择块中的字节偏移量（文件末尾），并将其发送给所有副本，之后它们都执行写入操作。

如果主服务器和所有副本都写入了，客户端会收到成功的消息！如果没有所有副本都写入，客户端会收到失败的消息，此时需要重新联系主服务器并从头开始重复此过程。

### 总结

我发现一篇[采访](https://queue.acm.org/detail.cfm?id=1594206)其中一个工程师讨论了他在 GFS 上的工作，觉得非常有趣。GFS 对其设计的应用非常成功，并在谷歌内部广泛采用。

不幸的是，由于几个原因，它对新用例的扩展能力不是很好。首先，系统使用单个主进程存储块服务器以及其他元数据。将所有这些信息存储在单台机器的 RAM 中只能做到这么多。

GFS 遇到的另一个问题是存储小文件。例如，如果用户想要存储许多小于块大小的文件，主服务器需要为每个文件存储一个条目，并在磁盘上分配完整的块大小。谷歌最终着手开发其他系统，并对 GFS 进行了调整以解决这个问题（特别是其中讨论到的一个系统是 BigTable）。

+   [1] 谷歌的新存储系统试图减少块大小，原因我在本文末尾有讨论。

+   [2] 数据是否实际上被拼接在一起，这在一定程度上是一个实现细节。

### 参考资料：
