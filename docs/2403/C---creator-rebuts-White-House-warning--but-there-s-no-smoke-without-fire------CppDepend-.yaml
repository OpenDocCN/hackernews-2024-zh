- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-29 12:34:59'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-29 12:34:59'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'C++ creator rebuts White House warning, but there’s no smoke without fire :)
    – CppDepend:'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'C++ 创作者反驳白宫的警告，但没有烟就不会有火 :) – CppDepend:'
- en: 来源：[https://cppdepend.com/blog/c-creator-rebuts-white-house-warning-but-theres-no-smoke-without-fire/](https://cppdepend.com/blog/c-creator-rebuts-white-house-warning-but-theres-no-smoke-without-fire/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://cppdepend.com/blog/c-creator-rebuts-white-house-warning-but-theres-no-smoke-without-fire/](https://cppdepend.com/blog/c-creator-rebuts-white-house-warning-but-theres-no-smoke-without-fire/)
- en: In a March 15 response to an inquiry from [InfoWorld](https://www.infoworld.com/article/3714401/c-plus-plus-creator-rebuts-white-house-warning.html),
    Stroustrup pointed out strengths of C++. “I find it surprising that the writers
    of those government documents seem oblivious of the strengths of contemporary
    C++ and the efforts to provide strong safety guarantees,” Stroustrup said.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在3月15日回应[InfoWorld](https://www.infoworld.com/article/3714401/c-plus-plus-creator-rebuts-white-house-warning.html)的查询时，Stroustrup指出了C++的优势。“我发现那些政府文件的撰写者似乎对当代C++的优势和提供强大安全保证的努力毫无察觉，”
    Stroustrup说。
- en: 'And Stroustrup cited a fact about the origin of the issue :'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: Stroustrup提到了这个问题的起源：
- en: There are two problems related to safety. Of the billions of lines of C++, few
    completely follow modern guidelines, and peoples’ notions of which aspects of
    safety are important differ.
  id: totrans-split-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与安全相关的两个问题。在数十亿行C++代码中，很少有完全符合现代指南的，人们对安全重要性的认识也存在差异。
- en: This highlights a significant problem with C++. When any programming language
    permits the execution of potentially harmful actions, it shouldn’t come as a surprise
    that a considerable portion of developers may misuse it.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这突显了C++的一个重要问题。当任何编程语言允许执行潜在有害的操作时，不应该感到惊讶，许多开发人员可能会滥用它。
- en: 'And when confronted about writing bad code, developers may offer various arguments
    to justify their actions, though these are often excuses rather than valid reasons:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当被指责编写糟糕代码时，开发人员可能会提出各种论点来为他们的行为辩护，尽管这些通常是借口而不是有效理由：
- en: '1.  **Tight Deadlines**: “I had to rush because of tight deadlines. There wasn’t
    enough time to write clean code.”'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  **严格的截止日期**：“由于时间紧迫，我不得不匆忙完成。没有足够的时间编写干净的代码。”
- en: '**Legacy Code**: “The existing codebase is messy and poorly structured. My
    changes just blend in with the existing mess.”'
  id: totrans-split-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**遗留代码**：“现有的代码库混乱且结构混乱。我的更改只是与现有混乱融为一体。”'
- en: '**Scope Creep**: “The requirements kept changing throughout the project, making
    it difficult to maintain clean code.”'
  id: totrans-split-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**范围膨胀**：“项目过程中需求不断变化，这使得保持干净的代码变得困难。”'
- en: '**Technological Constraints**: “The technology stack we’re using isn’t suitable
    for writing clean code. We’re limited by what we have.”'
  id: totrans-split-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**技术限制**：“我们使用的技术栈不适合编写干净的代码。我们受到当前技术的限制。”'
- en: So yes the developers have a responsibility to ensure they develop their code
    properly in C++. However, this kind of approach could be risky for the futur of
    C++. Just few years ago we have suprisingly assisted to the Nokia failure. Indeed,
    Nokia’s decline from being the world’s leading mobile phone manufacturer to struggling
    in the market is a story marked by several factors and strategic missteps. One
    of Nokia’s critical mistakes was its decision to stick with its Symbian operating
    system for too long. While Symbian was once a dominant platform, it struggled
    to compete with the user experience offered by iOS and Android.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以是的，开发人员有责任确保他们在C++中正确开发他们的代码。然而，这种方法可能对C++的未来存在风险。仅仅几年前，我们令人惊讶地目睹了诺基亚的失败。事实上，诺基亚从世界领先的手机制造商沦为市场中的一员，这个故事被几个因素和战略失误所标记。诺基亚的关键错误之一是决定长时间坚持其Symbian操作系统。尽管Symbian曾经是一个主导平台，但它在与iOS和Android提供的用户体验竞争中陷入困境。
- en: In C++ we stick for too long with the current memory management mechanism and
    no radical solution is suggested, only few improvements that need to be applied
    by the developers.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们长期坚持使用当前的内存管理机制，没有提出根本性的解决方案，只有一些需要开发人员应用的改进措施。
- en: '**C++ vs .Net startegy**:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++ vs .Net 策略**：'
- en: C# was developed in 2000 primarily for Windows machines. Miguel de Icaza created
    Mono to enable its use on Linux and Mac OSX. However, after over a decade of predominantly
    using the standard .Net framework on Windows, a significant issue arose regarding
    the language’s portability. To address this, Microsoft collaborated with Miguel
    to create .Net Core, a subset of .Net designed to function on other operating
    systems.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: C#是在2000年为Windows机器开发的。Miguel de Icaza创建了Mono，以使其能够在Linux和Mac OSX上使用。然而，在长达十多年主要在Windows上使用标准.NET框架后，关于语言可移植性的一个重大问题出现了。为了解决这个问题，微软与Miguel合作创建了.NET
    Core，这是.NET的一个子集，设计用于在其他操作系统上运行。
- en: This is not a step by step solution to resolve the portability issue, but a
    radical one even if the legacy code is not compatible. at this time  Miguel de
    Icaza describes .NET Core as a “**redesigned version of .NET** that is based on
    the simplified version of the class libraries”,and Microsoft’s Immo Landwerth
    explained that .NET Core would be “**the foundation of all future .NET platforms**“.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是逐步解决可移植性问题的方法，而是一个激进的解决方案，即使旧代码不兼容。此时，Miguel de Icaza将.NET Core描述为“**.NET的重新设计版本，基于简化版本的类库**”，而Microsoft的Immo
    Landwerth解释说，.NET Core将成为“**所有未来.NET平台的基础**”。
- en: And finally this solution worked perfetly and .Net core become widely used,
    and the big portability issue is resolved.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这个解决方案完美地奏效了，.NET Core变得广泛使用，大的可移植性问题也解决了。
- en: Ultimately, this solution proved highly effective, with .Net Core becoming widely
    adopted, successfully resolving the significant portability issue.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这个解决方案被证明非常有效，.NET Core被广泛采用，成功解决了重大的可移植性问题。
- en: Why not take a similar approach with C++ to definitively address the safety
    concerns? Why not develop a safe subset of C++ and provide the option to work
    with this subset through the compiler?
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不采取类似的方法来彻底解决C++的安全问题呢？为什么不开发C++的安全子集，并通过编译器提供使用此子集的选项呢？
- en: clang –safe
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: clang –safe
- en: '**Conclusion**:'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**：'
- en: If C++ continues to allow developers to engage in unsafe memory practices, this
    significant safety concern will persist, potentially leading to other languages
    such as Rust or Go being preferred for new projects. Maybe, it’s time to think
    to a radical solution rather than step by step improvements. Certainly, experience
    has demonstrated that despite the availability of modern features in C++ aimed
    at addressing safety concerns for over a decade, the issue persists due to the
    language’s continued allowance of legacy bad practices.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果C++继续允许开发者从事不安全的内存操作，这个重大的安全问题将持续存在，可能导致其他语言如Rust或Go成为新项目的首选。也许，现在是时候考虑一个根本性的解决方案，而不是逐步改进了。当然，经验表明，尽管C++中已经有了旨在解决安全问题的现代特性超过十年，但由于语言继续允许传统的糟糕做法，问题依然存在。
