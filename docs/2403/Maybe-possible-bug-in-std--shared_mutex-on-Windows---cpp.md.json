["```\n#include <atomic>\n#include <cstdint>\n#include <iostream>\n#include <memory>\n#include <shared_mutex>\n#include <thread>\n#include <vector>\n\nstruct ThreadTestData {\n    int32_t numThreads = 0;\n    std::shared_mutex sharedMutex = {};\n    std::atomic<int32_t> readCounter = 0;\n};\n\nint DoStuff(ThreadTestData* data) {\n    // Acquire reader lock\n    data->sharedMutex.lock_shared();\n\n    // wait until all read threads have acquired their shared lock\n    data->readCounter.fetch_add(1);\n    while (data->readCounter.load() != data->numThreads) {\n        std::this_thread::yield();\n    }\n\n    // Release reader lock\n    data->sharedMutex.unlock_shared();\n\n    return 0;\n}\n\nint main() {\n    int count = 0;\n    while (true) {\n        ThreadTestData data = {};\n        data.numThreads = 5;\n\n        // Acquire write lock\n        data.sharedMutex.lock();\n\n        // Create N threads\n        std::vector<std::unique_ptr<std::thread>> readerThreads;\n        readerThreads.reserve(data.numThreads);\n        for (int i = 0; i < data.numThreads; ++i) {\n            readerThreads.emplace_back(std::make_unique<std::thread>(DoStuff, &data));\n        }\n\n        // Release write lock\n        data.sharedMutex.unlock();\n\n        // Wait for all readers to succeed\n        for (auto& thread : readerThreads) {\n            thread->join();\n        }\n\n        // Cleanup\n        readerThreads.clear();\n\n        // Spew so we can tell when it's deadlocked\n        count += 1;\n        std::cout << count << std::endl;\n    }\n\n    return 0;\n} \n```"]