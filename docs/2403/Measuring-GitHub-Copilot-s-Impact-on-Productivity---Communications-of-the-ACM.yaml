- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:29:09'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Measuring GitHub Copilot’s Impact on Productivity – Communications of the ACM
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://cacm.acm.org/research/measuring-github-copilots-impact-on-productivity/](https://cacm.acm.org/research/measuring-github-copilots-impact-on-productivity/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code-completion systems offering suggestions to a developer in their integrated
    development environment (IDE) have become the most frequently used kind of programmer
    assistance.^([1](#bib1)) When generating whole snippets of code, they typically
    use a large language model (LLM) to predict what the user might type next (the
    completion) from the context of what they are working on at the moment (the prompt).^([2](#bib2))
    This system allows for completions at any position in the code, often spanning
    multiple lines at once.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Key Insights
  id: totrans-split-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AI pair-programming tools such as GitHub Copilot have a big impact on developer
    productivity. This holds for developers of all skill levels, with junior developers
    seeing the largest gains.
  id: totrans-split-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reported benefits of receiving AI suggestions while coding span the full
    range of typically investigated aspects of productivity, such as task time, product
    quality, cognitive load, enjoyment, and learning.
  id: totrans-split-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perceived productivity gains are reflected in objective measurements of developer
    activity.
  id: totrans-split-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While suggestion correctness is important, the driving factor for these improvements
    appears to be not correctness as such, but whether the suggestions are useful
    as a starting point for further development.
  id: totrans-split-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential benefits of generating large sections of code automatically are huge,
    but evaluating these systems is challenging. Offline evaluation, where the system
    is shown a partial snippet of code and then asked to complete it, is difficult
    not least because for longer completions there are many acceptable alternatives
    and no straightforward mechanism for labeling them automatically.^([5](#bib5))
    An additional step taken by some researchers^([3](#bib3))^,^([21](#bib21))^,^([29](#bib29))
    is to use online evaluation and track the frequency of real users accepting suggestions,
    assuming that the more contributions a system makes to the developer’s code, the
    higher its benefit. The validity of this assumption is not obvious when considering
    issues such as whether two short completions are more valuable than one long one,
    or whether reviewing suggestions can be detrimental to programming flow.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: Code completion in IDEs using language models was first proposed in Hindle et
    al.,^([9](#bib9)) and today neural synthesis tools such as [GitHub Copilot](https://www.copilot.com/),
    [CodeWhisperer](https://aws.amazon.com/codewhisperer/), and [TabNine](https://tabnine.com/)
    suggest code snippets within an IDE with the explicitly stated intention to increase
    a user’s productivity. Developer productivity has many aspects, and a recent study
    has shown that tools like these are helpful in ways that are only partially reflected
    by measures such as completion times for standardized tasks.^([23](#bib23))^,
    ^(Alternatively, we can leverage the developers themselves as expert assessors
    of their own productivity. This meshes well with current thinking in software
    engineering research suggesting measuring productivity on multiple dimensions
    and using self-reported data.^([6](#bib6)) Thus we focus on studying *perceived*
    productivity.)
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: Here, we investigate whether usage measurements of developer interactions with
    GitHub Copilot can predict perceived productivity as reported by developers. We
    analyze <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>2</mn><mo>,</mo><mn>631</mn></mrow></math>
    survey responses from developers using GitHub Copilot and match their responses
    to measurements collected from the IDE. We consider acceptance counts and more
    detailed measures of contribution, such as the amount of code contributed by GitHub
    Copilot and persistence of accepted completions in the code. **We find that acceptance
    rate of shown suggestions is a better predictor of perceived productivity than
    the alternative measures**. We also find that acceptance rate varies significantly
    over our developer population as well as over time, and present a deeper dive
    into some of these variations.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: Our results support the principle that acceptance rate can be used for coarse-grained
    monitoring of the performance of a neural code synthesis system. This ratio of
    shown suggestions being accepted correlates better than more detailed measures
    of contribution. However, other approaches remain necessary for fine-grained investigation
    due to the many human factors involved.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: Background
  id: totrans-split-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Offline evaluation of code completion can have shortcomings even in tractable
    circumstances where completions can be labeled for correctness. For example, a
    study of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>15</mn><mo>,</mo><mn>000</mn></mrow></math>
    completions by 66 developers in Visual Studio found significant differences between
    synthetic benchmarks used for model evaluation and real-world usage.^([7](#bib7))
    The evaluation of context-aware API completion for Visual Studio IntelliCode considered
    Recall@5—the proportion of completions for which the correct method call was in
    the top five suggestions. This metric fell from <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mn>90</mn><mo>%</mo></mrow></math> in offline evaluation
    to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>70</mn><mo>%</mo></mrow></math>
    when used online.^([21](#bib21))
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: '[![GitHub Copilot’s code completion funnel.](img/6bf303bf6d244f471685b4ba874bcf94.png)](https://cacm.acm.org/wp-content/uploads/2024/02/funnel_white.png)'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 1.  GitHub Copilot’s code completion funnel.**'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: Offline evaluation of code completion can have shortcomings even in tractable
    circumstances.
  id: totrans-split-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Due to the diversity of potential solutions to a multi-line completion task,
    researchers have used software testing to evaluate the behavior of completions.
    Competitive programming sites have been used as a source of such data^([8](#bib8))^,^([11](#bib11))
    as well as handwritten programming problems.^([5](#bib5)) Yet, it is unclear how
    well performance on programming competition data generalizes to interactive development
    in an IDE.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: It is unclear how well performance on programming competition data generalizes
    to interactive development in an IDE.
  id: totrans-split-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this work, we define acceptance rate as the fraction of completions shown
    to the developer that are subsequently accepted for inclusion in the source file.
    The IntelliCode Compose system uses the term *click through rate* (CTR) for this
    and reports a value of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>10</mn><mo>%</mo></mrow></math>
    in online trials.^([20](#bib20)) An alternative measure is that of *daily completions
    accepted per user* (DCPU) for which a value of around 20 has been reported.^([3](#bib3))^,^([29](#bib29))
    To calculate acceptance rate one must, of course, normalize DCPU by the time spent
    coding each day. For context, in our study GitHub Copilot has an acceptance rate
    of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>27</mn><mo>%</mo></mrow></math>
    and a mean DCPU in excess of 312 (See Figure 1). ^(These differences are presumably
    due to differences in the kinds of completion offered, or perhaps to user-interface
    choices. We discuss later how developer objectives, choice of programming language,
    and even time of day seem to affect our data. Such discrepancies highlight the
    difficulty in using acceptance rate to understand the value of a system.)
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: There is some evidence that acceptance rate (and indeed correctness) might not
    tell the whole story. One survey of developers considered the use of AI to support
    translation between programming languages and found indications that developers
    tolerated, and in some cases valued, erroneous suggestions from the model.^([26](#bib26))
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: There is some evidence that acceptance rate (and indeed correctness) might not
    tell the whole story.
  id: totrans-split-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Measuring developer productivity through activity counts over time (a typical
    definition of productivity borrowed from economics) disregards the complexity
    of software development as they account for only a subset of developer outputs.
    A more holistic picture is formed by measuring *perceived* productivity through
    self-reported data across various dimensions^([6](#bib6)) and supplementing it
    with automatically measured data.^([4](#bib4)) We used the SPACE framework^([6](#bib6))
    to design a survey that captures self-reported productivity and paired the self-reported
    data with usage telemetry.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: To the best of our knowledge, this is the first study of code suggestion tools
    establishing a clear link between usage measurements and developer productivity
    or happiness. A previous study comparing GitHub Copilot against IntelliCode with
    25 participants found no significant correlation between task completion times
    and survey responses.^([22](#bib22))
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: '[![Demographic composition of survey respondents.](img/522ee08620c7d5ce1ff40de6c8ce71af.png)](https://cacm.acm.org/wp-content/uploads/2024/02/survey_demographics_white.png)'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 2.  Demographic composition of survey respondents.**'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: Data and Methodology
  id: totrans-split-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usage measurements.
  id: totrans-split-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub Copilot provides code completions using OpenAI language models. It runs
    within the IDE and at appropriate points sends a completion request to a cloud-hosted
    instance of the neural model. GitHub Copilot can generate completions at arbitrary
    points in code rather than, for example, only being triggered when a developer
    types a period for invoking a method on an object. A variety of rules determine
    when to request a completion, when to abandon requests if the developer has moved
    on before the model is ready with a completion, and how much of the response from
    the model to surface as a completion.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: As stated in our terms of usage, ^(the GitHub Copilot IDE extension records
    the events shown in Table [1](#T1) for all users. We make usage measurements for
    each developer by counting those events.)
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1.  Developer usage events collected by GitHub Copilot.**'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: '| `opportunity` | A heuristic-based determination by the IDE and the plug-in
    that a completion might be appropriate at this point in the code (for example,
    the cursor is not in the middle of a word) |'
  id: totrans-split-35
  prefs: []
  type: TYPE_TB
- en: '| `shown` | Completion shown to the developer |'
  id: totrans-split-36
  prefs: []
  type: TYPE_TB
- en: '| `accepted` | Completion accepted by the developer for inclusion in the source
    file |'
  id: totrans-split-37
  prefs: []
  type: TYPE_TB
- en: '| `accepted_char` | The number of characters in an accepted completion |'
  id: totrans-split-38
  prefs: []
  type: TYPE_TB
- en: '| `mostly_unchanged_X` | Completion persisting in source code with limited
    modifications (Levenshtein distance less than 33%) after X seconds, where we consider
    durations of 30, 120, 300, and 600 seconds |'
  id: totrans-split-39
  prefs: []
  type: TYPE_TB
- en: '| `unchanged_X` | Completion persisting in source code unmodified after X seconds.
    |'
  id: totrans-split-40
  prefs: []
  type: TYPE_TB
- en: '| (active) `hour` | An hour during which the developer was using their IDE
    with the plug-in active |'
  id: totrans-split-41
  prefs: []
  type: TYPE_TB
- en: 'Our measures of persistence go further than existing work, which stops at acceptance.
    The intuition here is that a completion which is accepted into the source file
    but then subsequently turns out to be incorrect can be considered to have wasted
    developer time both in reviewing it and then having to go back and delete it.
    We also record *mostly* unchanged completions: A large completion requiring a
    few edits might still be a positive contribution. It is not clear how long after
    acceptance one should confirm persistence, so we consider a range of options.'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: The events pertaining to completions form a funnel which we show quantitatively
    in Table [1](#T1). We include a summary of all data in Appendix A. ^((*All appendices
    for this article can be found online at* [*https://dl.acm.org/doi/10.1145/3633453*](https://dl.acm.org/doi/10.1145/3633453)).)
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: 'We normalize these measures against each other and write `X_per_Y` to indicate
    we have normalized metric `X` by metric `Y`. For example: `accepted_per_hour`
    is calculated as the total number of `accepted` events divided by the total number
    of (active) `hour` events.'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: Table [2](#T2) defines the core set of metrics which we feel have a natural
    interpretation in this context. We note that there are other alternatives and
    we incorporate these in our discussion where relevant.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2.  The core set of measurements considered in this paper.**'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: '| Natural name | Explanation |'
  id: totrans-split-47
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-split-48
  prefs: []
  type: TYPE_TB
- en: '| Shown rate | Ratio of completion opportunities that resulted in a completion
    being shown to the user |'
  id: totrans-split-49
  prefs: []
  type: TYPE_TB
- en: '| Acceptance rate | Ratio of shown completions accepted by the user |'
  id: totrans-split-50
  prefs: []
  type: TYPE_TB
- en: '| Persistence rate | Ratio of accepted completions unchanged after 30, 120,
    300, and 600 seconds |'
  id: totrans-split-51
  prefs: []
  type: TYPE_TB
- en: '| Fuzzy persistence rate | Ratio of accepted completions mostly unchanged after
    30, 120, 300, and 600 seconds |'
  id: totrans-split-52
  prefs: []
  type: TYPE_TB
- en: '| Efficiency | Ratio of completion opportunities that resulted in a completion
    accepted and unchanged after 30, 120, 300, and 600 seconds |'
  id: totrans-split-53
  prefs: []
  type: TYPE_TB
- en: '| Contribution speed | Number of characters in accepted completions per distinct,
    active hour |'
  id: totrans-split-54
  prefs: []
  type: TYPE_TB
- en: '| Acceptance frequency | Number of accepted completions per distinct, active
    hour |'
  id: totrans-split-55
  prefs: []
  type: TYPE_TB
- en: '| Persistence frequency | Number of unchanged completions per distinct, active
    hour |'
  id: totrans-split-56
  prefs: []
  type: TYPE_TB
- en: '| Total volume | Total number of completions shown to the user |'
  id: totrans-split-57
  prefs: []
  type: TYPE_TB
- en: '| Loquaciousness | Number of shown completions per distinct, active hour |'
  id: totrans-split-58
  prefs: []
  type: TYPE_TB
- en: '| Eagerness | Number of shown completions per opportunity |'
  id: totrans-split-59
  prefs: []
  type: TYPE_TB
- en: Productivity survey.
  id: totrans-split-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand users’ experience with GitHub Copilot, we emailed a link to an
    online survey to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>17</mn><mo>,</mo><mn>420</mn></mrow></math>
    users. These were participants of the unpaid technical preview using GitHub Copilot
    with their everyday programming tasks. The only selection criterion was having
    previously opted in to receive communications. A vast majority of survey users
    (more than 80%) filled out the survey within the first two days, on or before
    February 12, 2022\. We therefore focus on data from the four-week period leading
    up to this point (“the study period”). We received a total of 2,047 responses
    we could match to usage data from the study period, the earliest on Feb. 10, 2022
    and the latest on Mar. 6, 2022.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: The survey contained multiple-choice questions regarding demographic information
    (see Figure [2](#F2)) and Likert-style questions about different aspects of productivity,
    which were randomized in their order of appearance to the user. Figure [2](#F2)
    shows the demographic composition of our respondents. We note the significant
    proportion of professional programmers who responded.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The SPACE framework^([6](#bib6)) defines 5 dimensions of productivity: **S**atisfaction
    and well-being, **P**erformance, **A**ctivity, **C**ommunication and collaboration,
    and **E**fficiency and flow. We use four of these (S,P,C,E) since self reporting
    on (A) is generally considered inferior to direct measurement. We included 11
    statements covering these four dimensions in addition to a single statement: “I
    am more productive when using GitHub Copilot.” For each self-reported productivity
    measure, we encoded its five ordinal response values to numeric labels (1 = Strongly
    Disagree, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>…</mo></math>,
    5 = Strongly Agree). We include the full list of questions and their coding to
    the SPACE framework in Appendix C. For more information on the SPACE framework
    and how the empirical software engineering community has been discussing developer
    productivity, please see the following section.'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: Early in our analysis, we found that the usage metrics we describe in the Usage
    Measurements section corresponded similarly to each of the measured dimensions
    of productivity, and in turn these dimensions were highly correlated to each other
    (Figure [3](#F3)). We therefore added an aggregate productivity score calculated
    as the mean of all 12 individual measures (excluding skipped questions). This
    serves as a rough proxy for the much more complex concept of productivity, facilitating
    recognition of overall trends, which may be less discernible on individual variables
    due to higher statistical variation.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: '[![Correlation between metrics. Metrics are ordered by similarity based on
    distance in the correlation matrix, except for manually fixing the aggregate productivity
    and acceptance rate at the end for visibility.](img/2422b29f25389cb987eb758e3202a687.png)](https://cacm.acm.org/wp-content/uploads/2024/02/heatmap_white.png)'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 3.  Correlation between metrics. Metrics are ordered by similarity
    based on distance in the correlation matrix, except for manually fixing the aggregate
    productivity and acceptance rate at the end for visibility.**'
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: The full dataset of these aggregate productivity scores together with the usage
    measurements considered in this article is available at [https://github.com/wunderalbert/prod-neural-materials](https://github.com/wunderalbert/prod-neural-materials).
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: Given it has been impossible to produce a unified definition or metric(s) for
    developer productivity, there have been attempts to synthesize the factors that
    impact productivity to describe it holistically, include various relevant factors,
    and treat developer productivity as a composite measure^([17](#bib17))^,^([19](#bib19))^,^([24](#bib24))
    In addition, organizations often use their own multidimensional frameworks to
    operationalize productivity, which reflects their engineering goals—for example,
    Google uses the QUANTS framework, with 5 components of productivity.^([27](#bib27))
    In this article, we use the SPACE framework,^([6](#bib6)) which builds on synthesis
    of extensive and diverse literature by expert researchers and practitioners in
    the area of developer productivity.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: 'SPACE is an acronym of the five dimensions of productivity:'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: '**S (Satisfaction and well being)**: This dimension is meant to reflect developers’
    fulfillment with the work they do and the tools they use, as well as how healthy
    and happy they are with the work they do. This dimension reflects some of the
    easy-to-overlook trade-offs involved when looking exclusively at velocity acceleration
    (for example, when we target faster turnaround of code reviews without considering
    workload impact or burnout for developers).'
  id: totrans-split-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**P (Performance)**: This dimension aims to quantify outcomes rather than output.
    Example metrics that capture performance relate to quality and reliability, as
    well as further-removed metrics such as customer adoption or satisfaction.'
  id: totrans-split-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A (Activity)**: This is the count of outputs—for example, the number of pull
    requests closed by a developer. As a result this is a dimension that is best quantified
    via system data. Given the variety of developers’ activities as part of their
    work, it is important that the activity dimension accounts for more than coding
    activity—for instance, writing documentation, creating design specs, and so on.'
  id: totrans-split-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C (Communication and collaboration)**: This dimension aims to capture that
    modern software development happens in teams and is, therefore, impacted by the
    discoverability of documentation or the speed of answering questions, or the onboarding
    time and process of new team members.'
  id: totrans-split-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E (Efficiency and flow)**: This dimension reflects the ability to complete
    work or make progress with little interruption or delay. It is important to note
    that delays and interruptions can be caused either by systems or humans, and it
    is best to monitor both self-reported and observed measurements—for example, use
    self-reports of the ability to do uninterrupted work, as well as measure wait
    time in engineering systems).'
  id: totrans-split-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Drives Perceived Productivity?
  id: totrans-split-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To examine the relationship between objective measurements of user behavior
    and self-reported perceptions of productivity, we used our set of core usage measurements
    (Table [2](#T2)). We then calculated Pearson’s R correlation coefficient and the
    corresponding p-value of the F-statistic between each pair of usage measurement
    and perceived productivity metric. We also computed a PLS regression from all
    usage measurements jointly.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: We summarize these results in Figure [3](#F3), showing the correlation coefficients
    between all measures and survey questions. The full table of all results is included
    in Appendix B, available online.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: '**We find acceptance rate (**accepted_per_shown**) most positively predicts
    users’ perception of productivity, although, given the confounding and human factors,
    there is still notable unexplained variance.**'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: Of all usage measurements, acceptance rate correlates best with aggregate productivity
    (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ρ</mi><mo>=</mo><mn>0</mn><mo>.</mo><mn>24</mn></mrow></math>,
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>P</mi><mo><</mo><mn>0</mn><mo>.</mo><mn>0001</mn></mrow></math>).
    This measurement is also the best performing for at least one survey question
    in each of the SPACE dimensions. This correlation is high confidence but leaves
    considerable unexplained variance. Later, we explore improvements from combining
    multiple usage measurements together.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the more detailed metrics around persistence, we see that it is generally
    better over shorter time periods than over longer periods. This is intuitive in
    the sense that shorter periods move the measure closer to acceptance rate. We
    also expect that at some point after accepting the completion it becomes simply
    part of the code and so any changes (or not) after that point will not be attributed
    to GitHub Copilot. All persistence measures were less well correlated than acceptance
    rate.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: To assess the different metrics in a single model, we ran a regression using
    projection on latent structures (PLS). The choice of PLS, which captures the common
    variation of these variables as is linearly connected to the aggregate productivity,^([28](#bib28))
    is due to the high collinearity of the single metrics. The first component, to
    which every metric under consideration contributes positively, explains <math
    xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>43</mn><mo>.</mo><mn>2</mn><mo>%</mo></mrow></math>
    of the variance. The second component captures the acceptance rate/change rate
    dichotomy; it explains a further <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mn>13</mn><mo>.</mo><mn>1</mn><mo>%</mo></mrow></math>.
    Both draw most strongly from acceptance rate.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: This strongly points to acceptance rate being the most immediate indicator of
    perceived productivity, although it is beneficial to combine with others to get
    a fuller picture.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: Experience
  id: totrans-split-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how different types of developers interact with Copilot, our
    survey asked respondents to self-report their level of experience in two ways:'
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: “Think of the language you have used the most with Copilot. How proficient are
    you in that language?” with options “Beginner”, “Intermediate”, and “Advanced”.
  id: totrans-split-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Which best describes your programming experience?” with options starting with
    “Student” and ranging from “0-2 years” to “16+ years” in two year intervals.
  id: totrans-split-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We compute correlations with productivity metrics for both experience variables
    and include these two variables as covariates in a multivariate regression analysis.
    We find that both are negatively correlated with our aggregate productivity measure
    (proficiency: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ρ</mi><mo>=</mo><mo>–</mo><mn>0</mn><mo>.</mo><mn>095</mn></mrow></math>,
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>P</mi><mo>=</mo><mn>0</mn><mo>.</mo><mn>0001</mn></mrow></math>;
    years of experience: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ρ</mi><mo>=</mo><mo>–</mo><mn>0</mn><mo>.</mo><mn>161</mn></mrow></math>,
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>P</mi><mo><</mo><mn>0</mn><mo>.</mo><mn>0001</mn></mrow></math>).
    However, in multivariate regressions predicting productivity from usage metrics
    while controlling for demographics, proficiency had a non-significant positive
    effect (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>c</mi><mi>o</mi><mi>e</mi><mi>f</mi><mi>f</mi><mo>=</mo><mn>0</mn><mo>.</mo><mn>021</mn></mrow></math>,
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>P</mi><mo>=</mo><mn>0</mn><mo>.</mo><mn>213</mn></mrow></math>),
    while years of experience had a non-significant negative effect (<math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mi>c</mi><mi>o</mi><mi>e</mi><mi>f</mi><mi>f</mi><mo>=</mo><mo>–</mo><mn>0</mn><mo>.</mo><mn>032</mn></mrow></math>,
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>P</mi><mo>=</mo><mn>0</mn><mo>.</mo><mn>122</mn></mrow></math>).'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
- en: Looking further at individual measures of productivity, (Table [3](#T3)) we
    find that both language proficiency and years of experience negatively predict
    developers agreeing that Copilot helps them write better code. However, proficiency
    positively predicts developers agreeing that Copilot helps them stay in the flow,
    focus on more satisfying work, spend less effort on repetitive tasks, and perform
    repetitive tasks faster. Years of experience negatively predicts developers feeling
    less frustrated in coding sessions and perform repetitive tasks faster while using
    Copilot, but positively predicts developers making progress faster when working
    in an unfamiliar language. These findings suggest that experienced developers
    who are already highly skilled are less likely to write better code with Copilot,
    but Copilot can assist their productivity in other ways particularly when engaging
    with new areas and automating routine work.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: Experienced developers who are already highly skilled are less likely to write
    better code with Copilot, but Copilot can assist their productivity in other ways.
  id: totrans-split-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Table 3. Effects of experience on facets of productivity where result of
    linear regression was a statistically significant covariate.**'
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: '|   | **productivity measure** | **coeff** |'
  id: totrans-split-91
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-92
  prefs: []
  type: TYPE_TB
- en: '| proficiency | `better_code` | <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mo>–</mo> <mn>0</mn> <mo>.</mo> <msup><mn>061</mn> <mo>*</mo></msup></mrow></math>
    |'
  id: totrans-split-93
  prefs: []
  type: TYPE_TB
- en: '| proficiency | `stay_in_flow` | <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mn>0</mn> <mo>.</mo> <msup><mn>069</mn> <mo>*</mo></msup></mrow></math>
    |'
  id: totrans-split-94
  prefs: []
  type: TYPE_TB
- en: '| proficiency | `focus_satisfying` | <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mn>0</mn> <mo>.</mo> <msup><mn>067</mn> <mo>*</mo></msup></mrow></math>
    |'
  id: totrans-split-95
  prefs: []
  type: TYPE_TB
- en: '| proficiency | `less_effort_repetitive` | <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mn>0</mn> <mo>.</mo> <msup><mn>072</mn> <mrow><mo>**</mo></mrow></msup></mrow></math>
    |'
  id: totrans-split-96
  prefs: []
  type: TYPE_TB
- en: '| proficiency | `repetitive_faster` | <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mn>0</mn> <mo>.</mo> <msup><mn>055</mn> <mrow><mo>***</mo></mrow></msup></mrow></math>
    |'
  id: totrans-split-97
  prefs: []
  type: TYPE_TB
- en: '| years | `better_code` | <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mo>–</mo> <mn>0</mn> <mo>.</mo> <msup><mn>087</mn> <mo>*</mo></msup></mrow></math>
    |'
  id: totrans-split-98
  prefs: []
  type: TYPE_TB
- en: '| years | `less_frustrated` | <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mo>–</mo> <mn>0</mn> <mo>.</mo> <msup><mn>103</mn> <mrow><mo>**</mo></mrow></msup></mrow></math>
    |'
  id: totrans-split-99
  prefs: []
  type: TYPE_TB
- en: '| years | `repetitive_faster` | <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mo>–</mo> <mn>0</mn> <mo>.</mo> <msup><mn>054</mn> <mo>*</mo></msup></mrow></math>
    |'
  id: totrans-split-100
  prefs: []
  type: TYPE_TB
- en: '| years | `unfamiliar_progress` | <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mn>0</mn> <mo>.</mo> <msup><mn>081</mn> <mo>*</mo></msup></mrow></math>
    |'
  id: totrans-split-101
  prefs: []
  type: TYPE_TB
- en: '**Table 4.  Correlations of acceptance rate with aggregate productivity broken
    down by subgroup.**'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
- en: '| **subgroup** | **coeff** | **n** |'
  id: totrans-split-103
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-split-104
  prefs: []
  type: TYPE_TB
- en: '| none | <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn>
    <mo>.</mo> <msup><mn>135</mn> <mo>*</mo></msup></mrow></math> | 344 |'
  id: totrans-split-105
  prefs: []
  type: TYPE_TB
- en: '| <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>≤</mo></math>
    2y | <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn>
    <mo>.</mo> <msup><mn>178</mn> <mrow><mo>**</mo></mrow></msup></mrow></math> |
    451 |'
  id: totrans-split-106
  prefs: []
  type: TYPE_TB
- en: '| 3 – 5 y | <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn>
    <mo>.</mo> <msup><mn>255</mn> <mrow><mo>***</mo></mrow></msup></mrow></math> |
    358 |'
  id: totrans-split-107
  prefs: []
  type: TYPE_TB
- en: '| 6 – 10 y | <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn>
    <mo>.</mo> <msup><mn>265</mn> <mrow><mo>***</mo></mrow></msup></mrow></math> |
    251 |'
  id: totrans-split-108
  prefs: []
  type: TYPE_TB
- en: '| 11 – 15 y | <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn>
    <mo>.</mo> <msup><mn>171</mn> <mo>*</mo></msup></mrow></math> | 162 |'
  id: totrans-split-109
  prefs: []
  type: TYPE_TB
- en: '| <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mo>≥</mo></math>
    16 y | <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn>
    <mo>.</mo> <msup><mn>153</mn> <mo>*</mo></msup></mrow></math> | 214 |'
  id: totrans-split-110
  prefs: []
  type: TYPE_TB
- en: '| JavaScript | <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn>
    <mo>.</mo> <msup><mn>227</mn> <mrow><mo>***</mo></mrow></msup></mrow></math> |
    1184 |'
  id: totrans-split-111
  prefs: []
  type: TYPE_TB
- en: '| TypeScript | <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn>
    <mo>.</mo> <msup><mn>165</mn> <mrow><mo>***</mo></mrow></msup></mrow></math> |
    654 |'
  id: totrans-split-112
  prefs: []
  type: TYPE_TB
- en: '| Python | <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn>
    <mo>.</mo> <msup><mn>172</mn> <mrow><mo>***</mo></mrow></msup></mrow></math> |
    716 |'
  id: totrans-split-113
  prefs: []
  type: TYPE_TB
- en: '| other | <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn>
    <mo>.</mo> <msup><mn>178</mn> <mrow><mo>***</mo></mrow></msup></mrow></math> |
    1829 |'
  id: totrans-split-114
  prefs: []
  type: TYPE_TB
- en: Junior developers not only report higher productivity gains; they also tend
    to accept more suggestions. However, the connection observed in section “What
    Drives Perceived Productivity” is not solely due to differing experience levels.
    In fact, the connection persists in every single experience group, as shown in
    Figure [5](#F5).
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
- en: Variation over Time
  id: totrans-split-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Its connection to perceived productivity motivates a closer look at the acceptance
    rate and what factors influence it. Acceptance rate typically increases over the
    board when the model or underlying prompt-crafting techniques are improved. But
    even if these conditions are held constant (the study period did not see changes
    to either), there are more fine-grained temporal patterns emerging.
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
- en: For coherence of the cultural implications of time of day and weekdays, all
    data in this section was restricted to users from the U.S. (whether in the survey
    or not). We used the same time frame as for the investigation in the previous
    section. In the absence of more fine-grained geolocation, we used the same time
    zone to interpret timestamps and for day boundaries (Pacific Standard Time), recognizing
    that this will introduce some level of noise due to the inhomogeneity of U.S.
    time zones.
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, we observe strong regular patterns in overall acceptance rate
    (Figure [6](#F6)). These lead us to distinguish three different time regimes,
    all of which are statistically significantly distinct at <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mi>p</mi><mo><</mo><mn>0</mn><mo>.</mo><mn>001</mn><mo>%</mo></mrow></math>
    (using bootstrap resampling):'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
- en: '[![Average acceptance rate during the week. Each point represents the average
    for a one-hour period, whereas the shaded ribbon shows the min-max variation during
    the observed four-week period.](img/3d6cf6b3a9ef192278219bcd47735ef7.png)](https://cacm.acm.org/wp-content/uploads/2024/02/patterns_white_2.png)'
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 6.  Average acceptance rate during the week. Each point represents
    the average for a one-hour period, whereas the shaded ribbon shows the min-max
    variation during the observed four-week period.**'
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The weekend: Saturdays and Sundays, where the average acceptance rate is comparatively
    high at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>23</mn><mo>.</mo><mn>5</mn><mo>%</mo></mrow></math>.'
  id: totrans-split-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typical non-working hours during the week: evenings after 4:00 pm PST until
    mornings 7:00 am PST, where the average acceptance rate is also rather high at
    <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>23</mn><mo>%</mo></mrow></math>.'
  id: totrans-split-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical working hours during the week from 7:00 am PST to 4:00 pm PST, where
    the average acceptance rate is much lower at <math xmlns="http://www.w3.org/1998/Math/MathML"
    display="inline"><mrow><mn>21</mn><mo>.</mo><mn>2</mn><mo>%</mo></mrow></math>.
  id: totrans-split-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusions
  id: totrans-split-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we set out to connect the productivity benefit of GitHub Copilot to usage
    measurements from developer activity, we collected measurements about acceptance
    of completions in line with prior work, but also developed persistence metrics,
    which arguably capture sustained and direct impact on the resulting code. We were
    surprised to find acceptance rate (number of acceptances normalized by the number
    of shown completions) to be better correlated with reported productivity than
    our measures of persistence.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
- en: In hindsight, this makes sense. Coding is not typing, and GitHub Copilot’s central
    value lies not in being the way the user enters most of their code. Instead, it
    lies in helping the user to make the best progress toward their goals. A suggestion
    that serves as a useful template to tinker with may be as good or better than
    a perfectly correct (but obvious) line of code that only saves the user a few
    keystrokes.
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
- en: This suggests that a narrow focus on the correctness of suggestions would not
    tell the whole story for these kinds of tooling. Instead one could view code suggestions
    inside an IDE to be more akin to a conversation. While chatbots such as ChatGPT
    are already used for programming tasks, they are explicitly structured as conversations.
    Here, we hypothesize that interactions with Copilot, which is not a chatbot, share
    many characteristics with natural-language conversations.
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
- en: We see anecdotal evidence of this in comments posted about GitHub Copilot online
    (see Appendix E for examples) in which users talk about sequences of interactions.
    A conversation turn in this context consists of the prompt in the completion request
    and the reply as the completion itself. The developer’s response to the completion
    arises from the subsequent changes which are incorporated in the next prompt to
    the model. There are clear programming parallels to factors such as specificity
    and repetition that have been identified to affect human judgements of conversation
    quality.^([18](#bib18)) Researchers have already investigated the benefits of
    natural-language feedback to guide program synthesis,^([2](#bib2)) so the conversational
    framing of coding completions is not a radical proposal. But neither is it one
    we have seen followed yet.
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
