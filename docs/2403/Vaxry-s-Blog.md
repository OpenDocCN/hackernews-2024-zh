<!--yml

category: 未分类

date: 2024-05-27 14:59:40

-->

# Vaxry 的博客

> 来源：[https://blog.vaxry.net/articles/2024-cursors](https://blog.vaxry.net/articles/2024-cursors)

由于我最近推出了 [hyprcursor](https://github.com/hyprwm/hyprcursor)，这是一种完全新的光标格式，用于现代桌面，旨在取代 XCursor 的旧标准，我认为写一篇博文解释 Linux（以及 BSD，啦啦啦）上的光标实际上如何工作，对于帮助人们理解发生了什么是个好主意。

## 术语

关于使用的术语的简短说明：

+   "主题" 是一组光标形状。

+   "形状" 是一个形状。例如指针、文本指示器、抓取手等。

+   "图像" 是一个形状在一定分辨率下的单个图片（或 svg）

## 光标是如何工作的？

> *"嘿，只要画一个 PNG 哈哈"*

哦，不，事情并不那么简单。

光栅图很烦人。光栅意味着图像以像素形式存储，例如 png 或 mp4。光栅的问题在于当你调整它们的大小时，计算机必须猜测它应该看起来像什么。有各种算法可以做到这一点，但最常用的是双线性和最近邻。

最近邻算法会产生 "像素化" 外观，而双线性会使其更模糊。

现在，如果我们只将我们的光标编码为例如 128x128，我们可以简单地缩小到用户请求的大小，然后完成，对吧？

哦，不完全是。无论算法如何，它几乎永远不会产生完美的像素结果。它几乎总是看起来 "奇怪"。

这就是为什么对于光栅光标来说，最佳方法就是只编码几种常见尺寸并完成。这就是 XCursor 所做的。

每个 XCursor 形状只是几个不同尺寸的图像。96、64、48、32、24、18 等等。

这个明显的问题是，首先，我们正在存储每个形状的多个图像，其次，我们无法得到任何中间值。

XCursor 不允许调整这些图像的大小，因此要么客户端必须这样做，要么就不会发生。在大多数情况下，不会发生。

### 那并不太糟糕

噢等等，我们还有更多！

大多数光标尺寸的最大图像为 96x96。在 8K 屏幕上，已经比 1080p 屏幕上的 32px 要小得多。

你可能认为 1080p 的 PNG 大约是一个兆字节，那为什么不编码更多？比如 128px 和 256px？

嗯，原因很简单。XCursor 早于 PNG。GIF 也是。JPEG 也是。这就是为什么 XCursor 图像是…… 未压缩的。

单个 96x96 Bibata 光标，一个光标，大约 2MB。太多了。整个主题是 44.1MB。哎呀。

*修正*：Bibata 中的单个静态光标几乎是 170kB，动画光标大约每个 16MB，我的错。44.1MB 的数字是正确的。

## 一种现代格式

为了停止像原始人一样存储未压缩的像素数据，我做了 hyprcursor。

Hyprcursor 有几个关键优势：

+   光标可以作为 *PNG 或 SVG* 图像存储。

+   每个光标都有描述它想要展示方式的元数据

+   简化和直观的 API

+   *完全* 更少的空间使用。

让我们详细说明每一点：

### 存储格式

您的光标可以是PNG，这是一种高效的，被广泛使用的无损光栅图像格式，也可以是SVG，这是基于矢量的图像的最常见标准。

几乎所有的光标最初都是SVG格式的，因为它们具有无限的可扩展性。SVG基本上描述了你的光标的“形状”，而不是原始像素，然后在不同分辨率下渲染，以便打包到主题中。

使用hyprcursor，hyprcursor本身可以进行渲染，这有两个好处：

+   你可以支持任何大小（有趣的是，前几天我在2048像素上渲染了Bibata，它看起来很漂亮）

+   空间使用大大减少：光标的SVG通常只有约1kB。

一些光标不能成为SVG，这没关系。一些光标用于多个形状，这也没关系。一些光标是动画的，这也没关系！

所有形状的属性都在一个小的`meta.hl`文件中描述。

对于覆盖，不要像穴居人一样到处创建符号链接，只需在meta中简单地定义`define_override = name`就足够了。

对于光栅形状，您可以定义要使用的缩放算法（如果有的话），以便控制光标如何在您制作的尺寸之外的尺寸上缩放。

### API

使用hyprcursor将光标形状渲染为磁盘上的PNG大约需要10行C代码，如果不考虑错误检查。加上错误检查，大约需要25行。

您还可以使用C++ API，在幕后为您做一些额外的QoL（生活质量）工作:)

### 空间效率

PNG比未压缩数据更高效，将Bibata从44.1MB降低到约6MB。然而，使用SVG，我们可以降低到**171kB**，这是250倍的减少。

## 好吧好吧，但是这怎么用？

谁来绘制光标呢？你可能会认为是显示服务器，复合器，对吧？

嗯，有点。

在开始时，地球是没有形状和空虚的。等等，有点太远了。

在wayland的开始和核心设计规范中，**客户端的**职责是绘制光标。我是说，这有点说得通，因为一些应用可能希望绘制自定义光标（例如游戏）。

但是，对于桌面使用来说，这有点糟糕。每个应用程序都必须支持渲染光标，而一些应用程序可能以不同的方式渲染它们，导致不一致性。如果您使用HiDPI屏幕，可能已经遇到过这些问题。

最近，我们有了wp_cursor_shape协议，允许应用程序只需说“嘿，复合器，渲染一个~~形状~~”，这要好得多，因为复合器现在可以绘制光标。

协议中定义了大约35种形状，老实说，这已经足够了。

如果你的复合器支持hyprcursor（如hyprland），那么在使用服务器端光标时，也将使用hyprcursor。然而，如果使用客户端经典样式，则由应用程序决定，目前大多数应用不支持hyprcursors。

### 支持情况如何？

嗯，现在，还不完美。QT、chromium、electron 和 hypr* 应用程序支持 cursor_shape，在 hyprland（或使用 hyprcursors 的任何其他合成器）中，您将获得像素完美的 hyprcursors。

值得注意的是，GTK 不支持该协议，因此像 Firefox 或整个 GNOME 套件这样的应用程序将退回到丑陋的 XCursor 主题。

## 这会被采纳吗？

我不知道！我只知道这是一个显然优越的系统，易于实施。

在我看来，最好的路径是在 gtk 推动 `wp_cursor_shape` 的采用。如果 gtk 最终支持该协议，几乎所有人们可能在 Linux 上使用的桌面应用程序都能通过合成器利用 hyprcursors。

支持 hyprcursor 本身的工具包本身可能不太可能发生，因为 hyprcursor 不是通过 10 年的官僚过程由百万美元非营利实体制造的，除非那边的开发人员某种方式决定现在更有利于使用 hyprcursors 而不是等待并开发他们自己的新标准。谁知道呢？ :)

## 如何制作 hyprcursor 主题？我可以使用我的当前主题吗？

您可以使用 hyprcursor 仓库中的 `hyprcursor-util` 将 xcursor 主题转换为 hyprcursor 主题，只需 5 分钟。

但是，你可能更愿意访问原始的光标源并用源 `.svg` 版本替换所有生成的 `.png` 文件，以获得矢量图像的好处。这个过程会花费一些时间，但肯定是值得的 :) *记得更新 meta.hl 文件中的新图像！*

如果您想与其他人分享主题（并且根据其许可证允许），请随时在 Hyprland Discord 服务器的 `#hyprcursor-themes` 发布它 :)

查看 [hyprcursor github 页面](https://github.com/hyprwm/hyprcursor) 上的文档和实用工具，了解更多信息。你也可以在 `docs/` 目录中找到使用此库的最终用户和开发者的说明。

## 总结思想

感谢大家对使 Hypr* 项目变得越来越好的持续支持！

我们有一些前进的大计划，所以请继续关注这段旅程 :)

作为一个小礼物，这里是 bibata 的 left_ptr，在 4K 下使用 hyprcursor 渲染，只是因为我觉得这很有趣：

[点击这里](../resource/articleCursor/arrow.png)

*我尝试了 16K 但几乎让我的电脑崩溃了 lol*
