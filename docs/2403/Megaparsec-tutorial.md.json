["```\ntype  Parsec  e  s  a  =  ParsecT  e  s  Identity  a \n```", "```\ntype  Parser  =  Parsec  Void  Text  --                   ^    ^  --                   |    |  -- Custom error component Type of input stream \n```", "```\nclass  Stream  s  where  type  Token  s  ::  *  type  Tokens  s  ::  *  take1_  ::  s  ->  Maybe  (Token  s,  s)  -- aka uncons  tokensToChunk  ::  Proxy  s  ->  [Token  s]  ->  Tokens  s \n```", "```\ntoken  ::  MonadParsec  e  s  m  =>  (Token  s  ->  Maybe  a)  -- ^ Matching function for the token to parse  ->  Set  (ErrorItem  (Token  s))  -- ^ Expected items (in case of an error)  ->  m  a \n```", "```\nsatisfy  ::  MonadParsec  e  s  m  =>  (Token  s  ->  Bool)  -- ^ Predicate to apply  ->  m  (Token  s)  satisfy  f  =  token  testToken  Set.empty  where  testToken  x  =  if  f  x  then  Just  x  else  Nothing \n```", "```\nλ> import Text.Megaparsec\nλ> import Text.Megaparsec.Char\nλ> import Data.Text (Text)\nλ> import Data.Void \n```", "```\nλ> type Parser = Parsec Void Text \n```", "```\nλ> :set -XOverloadedStrings\n\nλ> parseTest (satisfy (== 'a') :: Parser Char) \"\"\n1:1:\n  |\n1 | <empty line>\n  | ^\nunexpected end of input\n\nλ> parseTest (satisfy (== 'a') :: Parser Char) \"a\"\n'a'\n\nλ> parseTest (satisfy (== 'a') :: Parser Char) \"b\"\n1:1:\n  |\n1 | b\n  | ^\nunexpected 'b'\n\nλ> parseTest (satisfy (> 'c') :: Parser Char) \"a\"\n1:1:\n  |\n1 | a\n  | ^\nunexpected 'a'\n\nλ> parseTest (satisfy (> 'c') :: Parser Char) \"d\"\n'd' \n```", "```\nsingle  ::  MonadParsec  e  s  m  =>  Token  s  -- ^ Token to match  ->  m  (Token  s)  single  t  =  token  testToken  expected  where  testToken  x  =  if  x  ==  t  then  Just  x  else  Nothing  expected  =  Set.singleton  (Tokens  (t:|[])) \n```", "```\nλ> parseTest (char 'a' :: Parser Char) \"b\"\n1:1:\n  |\n1 | b\n  | ^\nunexpected 'b'\nexpecting 'a'\n\nλ> parseTest (char 'a' :: Parser Char) \"a\"\n'a' \n```", "```\nnewline  ::  (MonadParsec  e  s  m,  Token  s  ~  Char)  =>  m  (Token  s)  newline  =  single  '\\n' \n```", "```\ntokens  ::  MonadParsec  e  s  m  =>  (Tokens  s  ->  Tokens  s  ->  Bool)  -- ^ Predicate to check equality of chunks  ->  Tokens  s  -- ^ Chunk of input to match against  ->  m  (Tokens  s) \n```", "```\n-- from \"Text.Megaparsec\":  chunk  ::  MonadParsec  e  s  m  =>  Tokens  s  ->  m  (Tokens  s)  chunk  =  tokens  (==)  -- from \"Text.Megaparsec.Char\" and \"Text.Megaparsec.Byte\":  string'  ::  (MonadParsec  e  s  m,  Data.CaseInsensitive.FoldCase  (Tokens  s))  =>  Tokens  s  ->  m  (Tokens  s)  string'  =  tokens  ((==)  `on`  Data.CaseInsensitive.mk) \n```", "```\nλ> parseTest (string \"foo\" :: Parser Text) \"foo\"\n\"foo\"\n\nλ> parseTest (string \"foo\" :: Parser Text) \"bar\"\n1:1:\n  |\n1 | bar\n  | ^\nunexpected \"bar\"\nexpecting \"foo\"\n\nλ> parseTest (string' \"foo\" :: Parser Text) \"FOO\"\n\"FOO\"\n\nλ> parseTest (string' \"foo\" :: Parser Text) \"FoO\"\n\"FoO\"\n\nλ> parseTest (string' \"foo\" :: Parser Text) \"FoZ\"\n1:1:\n  |\n1 | FoZ\n  | ^\nunexpected \"FoZ\"\nexpecting \"foo\" \n```", "```\nmySequence  ::  Parser  (Char,  Char,  Char)  mySequence  =  do  a  <-  char  'a'  b  <-  char  'b'  c  <-  char  'c'  return  (a,  b,  c) \n```", "```\nλ> parseTest mySequence \"abc\"\n('a','b','c')\n\nλ> parseTest mySequence \"bcd\"\n1:1:\n  |\n1 | bcd\n  | ^\nunexpected 'b'\nexpecting 'a'\n\nλ> parseTest mySequence \"adc\"\n1:2:\n  |\n1 | adc\n  |  ^\nunexpected 'd'\nexpecting 'b' \n```", "```\nmySequence  ::  Parser  (Char,  Char,  Char)  mySequence  =  (,,)  <$>  char  'a'  <*>  char  'b'  <*>  char  'c' \n```", "```\nλ>  parseTest  (many  (char  'a')  ::  Parser  [Char])  \"aaa\"  \"aaa\"  λ>  parseTest  (many  (char  'a')  ::  Parser  [Char])  \"aabbb\"  \"aa\" \n```", "```\nλ> parseTest (many (char 'a') <* eof :: Parser [Char]) \"aabbb\"\n1:3:\n  |\n1 | aabbb\n  |   ^\nunexpected 'b'\nexpecting 'a' or end of input \n```", "```\nscheme:[//[user:password@]host[:port]][/]path[?query][#fragment] \n```", "```\n{-# LANGUAGE OverloadedStrings #-}  {-# LANGUAGE RecordWildCards   #-}  module  Main  (main)  where  import  Control.Applicative  import  Control.Monad  import  Data.Text  (Text)  import  Data.Void  import  Text.Megaparsec  hiding  (State)  import  Text.Megaparsec.Char  import  qualified  Data.Text  as  T  import  qualified  Text.Megaparsec.Char.Lexer  as  L  type  Parser  =  Parsec  Void  Text  pScheme  ::  Parser  Text  pScheme  =  string  \"data\"  <|>  string  \"file\"  <|>  string  \"ftp\"  <|>  string  \"http\"  <|>  string  \"https\"  <|>  string  \"irc\"  <|>  string  \"mailto\" \n```", "```\nλ> parseTest pScheme \"\"\n1:1:\n  |\n1 | <empty line>\n  | ^\nunexpected end of input\nexpecting \"data\", \"file\", \"ftp\", \"http\", \"https\", \"irc\", or \"mailto\"\n\nλ> parseTest pScheme \"dat\"\n1:1:\n  |\n1 | dat\n  | ^\nunexpected \"dat\"\nexpecting \"data\", \"file\", \"ftp\", \"http\", \"https\", \"irc\", or \"mailto\"\n\nλ> parseTest pScheme \"file\"\n\"file\"\n\nλ> parseTest pScheme \"irc\"\n\"irc\" \n```", "```\npScheme  ::  Parser  Text  pScheme  =  choice  [  string  \"data\"  ,  string  \"file\"  ,  string  \"ftp\"  ,  string  \"http\"  ,  string  \"https\"  ,  string  \"irc\"  ,  string  \"mailto\"  ] \n```", "```\ndata  Uri  =  Uri  {  uriScheme  ::  Text  }  deriving  (Eq,  Show)  pUri  ::  Parser  Uri  pUri  =  do  r  <-  pScheme  _  <-  char  ':'  return  (Uri  r) \n```", "```\nλ> parseTest pUri \"irc\"\n1:4:\n  |\n1 | irc\n  |    ^\nunexpected end of input\nexpecting ':'\n\nλ> parseTest pUri \"irc:\"\nUri {uriScheme = \"irc\"} \n```", "```\ndata  Scheme  =  SchemeData  |  SchemeFile  |  SchemeFtp  |  SchemeHttp  |  SchemeHttps  |  SchemeIrc  |  SchemeMailto  deriving  (Eq,  Show)  pScheme  ::  Parser  Scheme  pScheme  =  choice  [  SchemeData  <$  string  \"data\"  ,  SchemeFile  <$  string  \"file\"  ,  SchemeFtp  <$  string  \"ftp\"  ,  SchemeHttp  <$  string  \"http\"  ,  SchemeHttps  <$  string  \"https\"  ,  SchemeIrc  <$  string  \"irc\"  ,  SchemeMailto  <$  string  \"mailto\"  ]  data  Uri  =  Uri  {  uriScheme  ::  Scheme  }  deriving  (Eq,  Show) \n```", "```\nλ> parseTest pUri \"https:\"\n1:5:\n  |\n1 | https:\n  |     ^\nunexpected 's'\nexpecting ':' \n```", "```\nλ> parseTest pUri \"http:\"\nUri {uriScheme = SchemeHttp}\n\nλ> parseTest pUri \"https:\"\nUri {uriScheme = SchemeHttps}\n\nλ> parseTest pUri \"mailto:\"\nUri {uriScheme = SchemeMailto}\n\nλ> parseTest pUri \"foo:\"\n1:1:\n  |\n1 | foo:\n  | ^\nunexpected \"foo:\"\nexpecting \"data\", \"file\", \"ftp\", \"http\", \"https\", \"irc\", or \"mailto\" \n```", "```\ndata  Uri  =  Uri  {  uriScheme  ::  Scheme  ,  uriAuthority  ::  Maybe  Authority  }  deriving  (Eq,  Show)  data  Authority  =  Authority  {  authUser  ::  Maybe  (Text,  Text)  -- (user, password)  ,  authHost  ::  Text  ,  authPort  ::  Maybe  Int  }  deriving  (Eq,  Show) \n```", "```\nalternatives  ::  Parser  (Char,  Char)  alternatives  =  foo  <|>  bar  where  foo  =  (,)  <$>  char  'a'  <*>  char  'b'  bar  =  (,)  <$>  char  'a'  <*>  char  'c' \n```", "```\nλ> parseTest alternatives \"ab\"\n('a','b')\n\nλ> parseTest alternatives \"ac\"\n1:2:\n  |\n1 | ac\n  |  ^\nunexpected 'c'\nexpecting 'b' \n```", "```\nalternatives  ::  Parser  (Char,  Char)  alternatives  =  try  foo  <|>  bar  where  foo  =  (,)  <$>  char  'a'  <*>  char  'b'  bar  =  (,)  <$>  char  'a'  <*>  char  'c' \n```", "```\nλ>  parseTest  alternatives  \"ac\"  ('a','c') \n```", "```\noptional  ::  Alternative  f  =>  f  a  ->  f  (Maybe  a)  optional  p  =  (Just  <$>  p)  <|>  pure  Nothing \n```", "```\npUri  ::  Parser  Uri  pUri  =  do  uriScheme  <-  pScheme  void  (char  ':')  uriAuthority  <-  optional  .  try  $  do  -- (1)  void  (string  \"//\")  authUser  <-  optional  .  try  $  do  -- (2)  user  <-  T.pack  <$>  some  alphaNumChar  -- (3)  void  (char  ':')  password  <-  T.pack  <$>  some  alphaNumChar  void  (char  '@')  return  (user,  password)  authHost  <-  T.pack  <$>  some  (alphaNumChar  <|>  char  '.')  authPort  <-  optional  (char  ':'  *>  L.decimal)  -- (4)  return  Authority  {..}  -- (5)  return  Uri  {..}  -- (6) \n```", "```\nλ> parseTest (pUri <* eof) \"https://mark:secret@example.com\"\nUri\n  { uriScheme = SchemeHttps\n  , uriAuthority = Just (Authority\n    { authUser = Just (\"mark\",\"secret\")\n    , authHost = \"example.com\"\n    , authPort = Nothing } ) }\n\nλ> parseTest (pUri <* eof) \"https://mark:secret@example.com:123\"\nUri\n  { uriScheme = SchemeHttps\n  , uriAuthority = Just (Authority\n    { authUser = Just (\"mark\",\"secret\")\n    , authHost = \"example.com\"\n    , authPort = Just 123 } ) }\n\nλ> parseTest (pUri <* eof) \"https://example.com:123\"\nUri\n  { uriScheme = SchemeHttps\n  , uriAuthority = Just (Authority\n    { authUser = Nothing\n    , authHost = \"example.com\"\n    , authPort = Just 123 } ) }\n\nλ> parseTest (pUri <* eof) \"https://mark@example.com:123\"\n1:13:\n  |\n1 | https://mark@example.com:123\n  |             ^\nunexpected '@'\nexpecting '.', ':', alphanumeric character, or end of input \n```", "```\nλ> parseTest (pUri <* eof) \"https://mark:@example.com\"\n1:7:\n  |\n1 | https://mark:@example.com\n  |       ^\nunexpected '/'\nexpecting end of input \n```", "```\ndbg  ::  (VisualStream  s,  ShowToken  (Token  s),  ShowErrorComponent  e,  Show  a)  =>  String  -- ^ Debugging label  ->  ParsecT  e  s  m  a  -- ^ Parser to debug  ->  ParsecT  e  s  m  a  -- ^ Parser that prints debugging messages \n```", "```\npUri  ::  Parser  Uri  pUri  =  do  uriScheme  <-  dbg  \"scheme\"  pScheme  void  (char  ':')  uriAuthority  <-  dbg  \"auth\"  .  optional  .  try  $  do  void  (string  \"//\")  authUser  <-  dbg  \"user\"  .  optional  .  try  $  do  user  <-  T.pack  <$>  some  alphaNumChar  void  (char  ':')  password  <-  T.pack  <$>  some  alphaNumChar  void  (char  '@')  return  (user,  password)  authHost  <-  T.pack  <$>  dbg  \"host\"  (some  (alphaNumChar  <|>  char  '.'))  authPort  <-  dbg  \"port\"  $  optional  (char  ':'  *>  L.decimal)  return  Authority  {..}  return  Uri  {..} \n```", "```\nλ> parseTest (pUri <* eof) \"https://mark:@example.com\"\nscheme> IN: \"https://mark:@example.com\"\nscheme> MATCH (COK): \"https\"\nscheme> VALUE: SchemeHttps\n\nuser> IN: \"mark:@example.com\"\nuser> MATCH (EOK): <EMPTY>\nuser> VALUE: Nothing\n\nhost> IN: \"mark:@example.com\"\nhost> MATCH (COK): \"mark\"\nhost> VALUE: \"mark\"\n\nport> IN: \":@example.com\"\nport> MATCH (CERR): ':'\nport> ERROR:\nport> 1:14:\nport> unexpected '@'\nport> expecting integer\n\nauth> IN: \"//mark:@example.com\"\nauth> MATCH (EOK): <EMPTY>\nauth> VALUE: Nothing\n\n1:7:\n  |\n1 | https://mark:@example.com\n  |       ^\nunexpected '/'\nexpecting end of input \n```", "```\nscheme:[//[user:password@]host[:port]][/]path[?query][#fragment] \n```", "```\npUri  ::  Parser  Uri  pUri  =  do  uriScheme  <-  pScheme  void  (char  ':')  uriAuthority  <-  optional  $  do  -- removed 'try' on this line  void  (string  \"//\")  authUser  <-  optional  .  try  $  do  user  <-  T.pack  <$>  some  alphaNumChar  void  (char  ':')  password  <-  T.pack  <$>  some  alphaNumChar  void  (char  '@')  return  (user,  password)  authHost  <-  T.pack  <$>  some  (alphaNumChar  <|>  char  '.')  authPort  <-  optional  (char  ':'  *>  L.decimal)  return  Authority  {..}  return  Uri  {..} \n```", "```\nλ> parseTest (pUri <* eof) \"https://mark:@example.com\"\n1:14:\n  |\n1 | https://mark:@example.com\n  |              ^\nunexpected '@'\nexpecting integer \n```", "```\nλ> parseTest (pUri <* eof) \"foo://example.com\"\n1:1:\n  |\n1 | foo://example.com\n  | ^\nunexpected \"foo://\"\nexpecting \"data\", \"file\", \"ftp\", \"http\", \"https\", \"irc\", or \"mailto\" \n```", "```\npUri  ::  Parser  Uri  pUri  =  do  uriScheme  <-  pScheme  <?>  \"valid scheme\"  -- the rest stays the same \n```", "```\nλ> parseTest (pUri <* eof) \"foo://example.com\"\n1:1:\n  |\n1 | foo://example.com\n  | ^\nunexpected \"foo://\"\nexpecting valid scheme \n```", "```\npUri  ::  Parser  Uri  pUri  =  do  uriScheme  <-  pScheme  <?>  \"valid scheme\"  void  (char  ':')  uriAuthority  <-  optional  $  do  void  (string  \"//\")  authUser  <-  optional  .  try  $  do  user  <-  T.pack  <$>  some  alphaNumChar  <?>  \"username\"  void  (char  ':')  password  <-  T.pack  <$>  some  alphaNumChar  <?>  \"password\"  void  (char  '@')  return  (user,  password)  authHost  <-  T.pack  <$>  some  (alphaNumChar  <|>  char  '.')  <?>  \"hostname\"  authPort  <-  optional  (char  ':'  *>  label  \"port number\"  L.decimal)  return  Authority  {..}  return  Uri  {..} \n```", "```\nλ> parseTest (pUri <* eof) \"https://mark:@example.com\"\n1:14:\n  |\n1 | https://mark:@example.com\n  |              ^\nunexpected '@'\nexpecting port number \n```", "```\nλ> parseTest (many (char 'a') >> many (char 'b') >> eof :: Parser ()) \"d\"\n1:1:\n  |\n1 | d\n  | ^\nunexpected 'd'\nexpecting 'a', 'b', or end of input\n\nλ> parseTest (many (char 'a') >> hidden (many (char 'b')) >> eof :: Parser ()) \"d\"\n1:1:\n  |\n1 | d\n  | ^\nunexpected 'd'\nexpecting 'a' or end of input \n```", "```\nrunParser  ::  Parsec  e  s  a  -- ^ Parser to run  ->  String  -- ^ Name of source file  ->  s  -- ^ Input for parser  ->  Either  (ParseErrorBundle  s  e)  a \n```", "```\ntype  Parsec  e  s  =  ParsecT  e  s  Identity \n```", "```\nrunParser'  ::  Parsec  e  s  a  -- ^ Parser to run  ->  State  s  -- ^ Initial state  ->  (State  s,  Either  (ParseErrorBundle  s  e)  a) \n```", "```\ntype  MyStack  a  =  ReaderT  MyContext  (State  MyState)  a \n```", "```\nnewtype  ReaderT  r  m  a  =  ReaderT  {  runReaderT  ::  r  ->  m  a  }  instance  Monad  m  =>  Monad  (ReaderT  r  m)  where  m  >>=  k  =  ReaderT  $  \\r  ->  do  a  <-  runReaderT  m  r  runReaderT  (k  a)  r \n```", "```\ninstance  Alternative  m  =>  Alternative  (ReaderT  r  m)  where  empty  =  liftReaderT  empty  ReaderT  m  <|>  ReaderT  n  =  ReaderT  $  \\r  ->  m  r  <|>  n  r \n```", "```\ninstance  (Functor  m,  Alternative  m)  =>  Alternative  (StateT  s  m)  where  empty  =  StateT  $  \\_  ->  empty  StateT  m  <|>  StateT  n  =  StateT  $  \\s  ->  m  s  <|>  n  s \n```", "```\ntype  MyStack  a  =  ParsecT  Void  Text  (State  MyState)  a \n```", "```\n{-# LANGUAGE OverloadedStrings #-}  module  Main  (main)  where  import  Control.Applicative  import  Control.Monad.State.Strict  import  Data.Text  (Text)  import  Data.Void  import  Text.Megaparsec  hiding  (State)  type  Parser  =  ParsecT  Void  Text  (State  String)  parser0  ::  Parser  String  parser0  =  a  <|>  b  where  a  =  \"foo\"  <$  put  \"branch A\"  b  =  get  <*  put  \"branch B\"  parser1  ::  Parser  String  parser1  =  a  <|>  b  where  a  =  \"foo\"  <$  put  \"branch A\"  <*  empty  b  =  get  <*  put  \"branch B\"  main  ::  IO  ()  main  =  do  let  run  p  =  runState  (runParserT  p  \"\"  \"\")  \"initial\"  (Right  a0,  s0)  =  run  parser0  (Right  a1,  s1)  =  run  parser1  putStrLn  \"Parser 0\"  putStrLn  (\"Result:      \"  ++  show  a0)  putStrLn  (\"Final state: \"  ++  show  s0)  putStrLn  \"Parser 1\"  putStrLn  (\"Result:      \"  ++  show  a1)  putStrLn  (\"Final state: \"  ++  show  s1) \n```", "```\nParser 0\nResult:      \"foo\"\nFinal state: \"branch A\"\nParser 1\nResult:      \"branch A\"\nFinal state: \"branch B\" \n```", "```\ntype  MyStack  a  =  StateT  MyState  (ParsecT  Void  Text  Identity)  a \n```", "```\nStateT  m  <|>  StateT  n  =  StateT  $  \\s  ->  m  s  <|>  n  s \n```", "```\n{-# LANGUAGE OverloadedStrings #-}  module  Main  (main)  where  import  Control.Applicative  import  Control.Monad.Identity  import  Control.Monad.State.Strict  import  Data.Text  (Text)  import  Data.Void  import  Text.Megaparsec  hiding  (State)  type  Parser  =  StateT  String  (ParsecT  Void  Text  Identity)  parser  ::  Parser  String  parser  =  a  <|>  b  where  a  =  \"foo\"  <$  put  \"branch A\"  <*  empty  b  =  get  <*  put  \"branch B\"  main  ::  IO  ()  main  =  do  let  p  =  runStateT  parser  \"initial\"  Right  (a,  s)  =  runParser  p  \"\"  \"\"  putStrLn  (\"Result:      \"  ++  show  a)  putStrLn  (\"Final state: \"  ++  show  s) \n```", "```\nResult:      \"initial\"\nFinal state: \"branch B\" \n```", "```\ninstance  MonadWriter  w  m  =>  MonadWriter  w  (StateT  s  m)  where  … \n```", "```\ninstance  MonadParsec  e  s  m  =>  MonadParsec  e  s  (StateT  st  m)  where  … \n```", "```\nspace  ::  MonadParsec  e  s  m  =>  m  ()  -- ^ A parser for space characters which does not accept empty\n          -- input (e.g. 'space1')  ->  m  ()  -- ^ A parser for a line comment (e.g. 'skipLineComment')  ->  m  ()  -- ^ A parser for a block comment (e.g. 'skipBlockComment')  ->  m  () \n```", "```\n{-# LANGUAGE OverloadedStrings #-}  module  Main  (main)  where  import  Data.Text  (Text)  import  Data.Void  import  Text.Megaparsec  import  Text.Megaparsec.Char  import  qualified  Text.Megaparsec.Char.Lexer  as  L  -- (1)  type  Parser  =  Parsec  Void  Text  sc  ::  Parser  ()  sc  =  L.space  space1  -- (2)  (L.skipLineComment  \"//\")  -- (3)  (L.skipBlockComment  \"/*\"  \"*/\")  -- (4) \n```", "```\nlexeme  ::  Parser  a  ->  Parser  a  lexeme  =  L.lexeme  sc  symbol  ::  Text  ->  Parser  Text  symbol  =  L.symbol  sc \n```", "```\ncharLiteral  ::  (MonadParsec  e  s  m,  Token  s  ~  Char)  =>  m  Char \n```", "```\ncharLiteral  ::  Parser  Char  charLiteral  =  between  (char  '\\'')  (char  '\\'')  L.charLiteral  stringLiteral  ::  Parser  String  stringLiteral  =  char  '\\\"'  *>  manyTill  L.charLiteral  (char  '\\\"') \n```", "```\nmanyTill  ::  Alternative  m  =>  m  a  ->  m  end  ->  m  [a]  manyTill  p  end  =  go  where  go  =  ([]  <$  end)  <|>  ((:)  <$>  p  <*>  go) \n```", "```\ndecimal,  octal,  hexadecimal  ::  (MonadParsec  e  s  m,  Token  s  ~  Char,  Num  a)  =>  m  a \n```", "```\ninteger  ::  Parser  Integer  integer  =  lexeme  L.decimal \n```", "```\nλ> parseTest (integer <* eof) \"123  \"\n123\n\nλ> parseTest (integer <* eof) \"12a  \"\n1:3:\n  |\n1 | 12a\n  |   ^\nunexpected 'a'\nexpecting end of input or the rest of integer \n```", "```\nscientific  ::  (MonadParsec  e  s  m,  Token  s  ~  Char)  =>  m  Scientific  float  ::  (MonadParsec  e  s  m,  Token  s  ~  Char,  RealFloat  a)  =>  m  a \n```", "```\nfloat  ::  Parser  Double  float  =  lexeme  L.float \n```", "```\nλ> parseTest (float <* eof) \"123\"\n1:4:\n  |\n1 | 123\n  |    ^\nunexpected end of input\nexpecting '.', 'E', 'e', or digit\n\nλ> parseTest (float <* eof) \"123.45\"\n123.45\n\nλ> parseTest (float <* eof) \"123d\"\n1:4:\n  |\n1 | 123d\n  |    ^\nunexpected 'd'\nexpecting '.', 'E', 'e', or digit \n```", "```\nsignedInteger  ::  Parser  Integer  signedInteger  =  L.signed  sc  integer  signedFloat  ::  Parser  Double  signedFloat  =  L.signed  sc  float \n```", "```\nnotFollowedBy  ::  MonadParsec  e  s  m  =>  m  a  ->  m  () \n```", "```\npKeyword  ::  Text  ->  Parser  Text  pKeyword  keyword  =  lexeme  (string  keyword) \n```", "```\npKeyword  ::  Text  ->  Parser  Text  pKeyword  keyword  =  lexeme  (string  keyword  <*  notFollowedBy  alphaNumChar) \n```", "```\nlookAhead  ::  MonadParsec  e  s  m  =>  m  a  ->  m  a \n```", "```\nwithPredicate1  ::  (a  ->  Bool)  -- ^ The check to perform on parsed input  ->  String  -- ^ Message to print when the check fails  ->  Parser  a  -- ^ Parser to run  ->  Parser  a  -- ^ Resulting parser that performs the check  withPredicate1  f  msg  p  =  do  r  <-  lookAhead  p  if  f  r  then  p  else  fail  msg \n```", "```\nwithPredicate2  ::  (a  ->  Bool)  -- ^ The check to perform on parsed input  ->  String  -- ^ Message to print when the check fails  ->  Parser  a  -- ^ Parser to run  ->  Parser  a  -- ^ Resulting parser that performs the check  withPredicate2  f  msg  p  =  do  o  <-  getOffset  r  <-  p  if  f  r  then  return  r  else  do  setOffset  o  fail  msg \n```", "```\na * (b + 2) \n```", "```\ndata  Expr  =  Var  String  |  Int  Int  |  Negation  Expr  |  Sum  Expr  Expr  |  Subtr  Expr  Expr  |  Product  Expr  Expr  |  Division  Expr  Expr  deriving  (Eq,  Ord,  Show) \n```", "```\nmakeExprParser  ::  MonadParsec  e  s  m  =>  m  a  -- ^ Term parser  ->  [[Operator  m  a]]  -- ^ Operator table, see 'Operator'  ->  m  a  -- ^ Resulting expression parser \n```", "```\npVariable  ::  Parser  Expr  pVariable  =  Var  <$>  lexeme  ((:)  <$>  letterChar  <*>  many  alphaNumChar  <?>  \"variable\")  pInteger  ::  Parser  Expr  pInteger  =  Int  <$>  lexeme  L.decimal  parens  ::  Parser  a  ->  Parser  a  parens  =  between  (symbol  \"(\")  (symbol  \")\")  pTerm  ::  Parser  Expr  pTerm  =  choice  [  parens  pExpr  ,  pVariable  ,  pInteger  ]  pExpr  ::  Parser  Expr  pExpr  =  makeExprParser  pTerm  operatorTable  operatorTable  ::  [[Operator  Parser  Expr]]  operatorTable  =  undefined  -- TODO \n```", "```\ndata  Operator  m  a  -- N.B.  =  InfixN  (m  (a  ->  a  ->  a))  -- ^ Non-associative infix  |  InfixL  (m  (a  ->  a  ->  a))  -- ^ Left-associative infix  |  InfixR  (m  (a  ->  a  ->  a))  -- ^ Right-associative infix  |  Prefix  (m  (a  ->  a))  -- ^ Prefix  |  Postfix  (m  (a  ->  a))  -- ^ Postfix  operatorTable  ::  [[Operator  Parser  Expr]]  operatorTable  =  [  [  prefix  \"-\"  Negation  ,  prefix  \"+\"  id  ]  ,  [  binary  \"*\"  Product  ,  binary  \"/\"  Division  ]  ,  [  binary  \"+\"  Sum  ,  binary  \"-\"  Subtr  ]  ]  binary  ::  Text  ->  (Expr  ->  Expr  ->  Expr)  ->  Operator  Parser  Expr  binary  name  f  =  InfixL  (f  <$  symbol  name)  prefix,  postfix  ::  Text  ->  (Expr  ->  Expr)  ->  Operator  Parser  Expr  prefix  name  f  =  Prefix  (f  <$  symbol  name)  postfix  name  f  =  Postfix  (f  <$  symbol  name) \n```", "```\nλ> parseTest (pExpr <* eof) \"a * (b + 2)\"\nProduct (Var \"a\") (Sum (Var \"b\") (Int 2))\n\nλ> parseTest (pExpr <* eof) \"a * b + 2\"\nSum (Product (Var \"a\") (Var \"b\")) (Int 2)\n\nλ> parseTest (pExpr <* eof) \"a * b / 2\"\nDivision (Product (Var \"a\") (Var \"b\")) (Int 2)\n\nλ> parseTest (pExpr <* eof) \"a * (b $ 2)\"\n1:8:\n  |\n1 | a * (b $ 2)\n  |        ^\nunexpected '$'\nexpecting ')' or operator \n```", "```\nnonIndented  ::  (TraversableStream  s,  MonadParsec  e  s  m)  =>  m  ()  -- ^ How to consume indentation (white space)  ->  m  a  -- ^ Inner parser  ->  m  a \n```", "```\nindentBlock  ::  (TraversableStream  s,  MonadParsec  e  s  m,  Token  s  ~  Char)  =>  m  ()  -- ^ How to consume indentation (white space)  ->  m  (IndentOpt  m  a  b)  -- ^ How to parse “reference” token  ->  m  a \n```", "```\ndata  IndentOpt  m  a  b  =  IndentNone  a  -- ^ Parse no indented tokens, just return the value  |  IndentMany  (Maybe  Pos)  ([b]  ->  m  a)  (m  b)  -- ^ Parse many indented tokens (possibly zero), use given indentation\n    -- level (if 'Nothing', use level of the first indented token); the\n    -- second argument tells how to get the final result, and the third\n    -- argument describes how to parse an indented token  |  IndentSome  (Maybe  Pos)  ([b]  ->  m  a)  (m  b)  -- ^ Just like 'IndentMany', but requires at least one indented token to\n    -- be present \n```", "```\n{-# LANGUAGE OverloadedStrings #-}  {-# LANGUAGE TupleSections     #-}  module  Main  (main)  where  import  Control.Applicative  hiding  (some)  import  Control.Monad  (void)  import  Data.Text  (Text)  import  Data.Void  import  Text.Megaparsec  import  Text.Megaparsec.Char  import  qualified  Text.Megaparsec.Char.Lexer  as  L  type  Parser  =  Parsec  Void  Text \n```", "```\nlineComment  ::  Parser  ()  lineComment  =  L.skipLineComment  \"#\"  scn  ::  Parser  ()  scn  =  L.space  space1  lineComment  empty  sc  ::  Parser  ()  sc  =  L.space  (void  $  some  (char  ' '  <|>  char  '\\t'))  lineComment  empty  lexeme  ::  Parser  a  ->  Parser  a  lexeme  =  L.lexeme  sc \n```", "```\npItemList  ::  Parser  (String,  [String])  -- header and list items  pItemList  =  L.nonIndented  scn  (L.indentBlock  scn  p)  where  p  =  do  header  <-  pItem  return  (L.IndentMany  Nothing  (return  .  (header,  ))  pItem) \n```", "```\npItem  ::  Parser  String  pItem  =  lexeme  (some  (alphaNumChar  <|>  char  '-'))  <?>  \"list item\" \n```", "```\nλ> parseTest (pItemList <* eof) \"\"\n1:1:\n  |\n1 | <empty line>\n  | ^\nunexpected end of input\nexpecting list item\n\nλ> parseTest (pItemList <* eof) \"something\"\n(\"something\",[])\n\nλ> parseTest (pItemList <* eof) \"  something\"\n1:3:\n  |\n1 |   something\n  |   ^\nincorrect indentation (got 3, should be equal to 1)\n\nλ> parseTest (pItemList <* eof) \"something\\none\\ntwo\\nthree\"\n2:1:\n  |\n2 | one\n  | ^\nunexpected 'o'\nexpecting end of input \n```", "```\nλ> parseTest (pItemList <* eof) \"something\\n  one\\n    two\\n  three\"\n3:5:\n  |\n3 |     two\n  |     ^\nincorrect indentation (got 5, should be equal to 3)\n\nλ> parseTest (pItemList <* eof) \"something\\n  one\\n  two\\n three\"\n4:2:\n  |\n4 |  three\n  |  ^\nincorrect indentation (got 2, should be equal to 3)\n\nλ> parseTest (pItemList <* eof) \"something\\n  one\\n  two\\n  three\"\n(\"something\",[\"one\",\"two\",\"three\"]) \n```", "```\npItemList  ::  Parser  (String,  [String])  pItemList  =  L.nonIndented  scn  (L.indentBlock  scn  p)  where  p  =  do  header  <-  pItem  return  (L.IndentSome  (Just  (mkPos  5))  (return  .  (header,  ))  pItem) \n```", "```\nλ> parseTest (pItemList <* eof) \"something\\n\"\n2:1:\n  |\n2 | <empty line>\n  | ^\nincorrect indentation (got 1, should be greater than 1)\n\nλ> parseTest (pItemList <* eof) \"something\\n  one\"\n2:3:\n  |\n2 |   one\n  |   ^\nincorrect indentation (got 3, should be equal to 5)\n\nλ> parseTest (pItemList <* eof) \"something\\n    one\"\n(\"something\",[\"one\"]) \n```", "```\npComplexItem  ::  Parser  (String,  [String])  pComplexItem  =  L.indentBlock  scn  p  where  p  =  do  header  <-  pItem  return  (L.IndentMany  Nothing  (return  .  (header,  ))  pItem)  pItemList  ::  Parser  (String,  [(String,  [String])])  pItemList  =  L.nonIndented  scn  (L.indentBlock  scn  p)  where  p  =  do  header  <-  pItem  return  (L.IndentSome  Nothing  (return  .  (header,  ))  pComplexItem) \n```", "```\nfirst-chapter\n  paragraph-one\n      note-A # an important note here!\n      note-B\n  paragraph-two\n    note-1\n    note-2\n  paragraph-three \n```", "```\nRight\n  ( \"first-chapter\"\n  , [ (\"paragraph-one\",   [\"note-A\",\"note-B\"])\n    , (\"paragraph-two\",   [\"note-1\",\"note-2\"])\n    , (\"paragraph-three\", [])\n    ]\n  ) \n```", "```\npComplexItem  ::  Parser  (String,  [String])  pComplexItem  =  L.indentBlock  scn  p  where  p  =  do  header  <-  pItem  return  (L.IndentMany  Nothing  (return  .  (header,  ))  pLineFold)  pLineFold  ::  Parser  String  pLineFold  =  L.lineFold  scn  $  \\sc'  ->  let  ps  =  some  (alphaNumChar  <|>  char  '-')  `sepBy1`  try  sc'  in  unwords  <$>  ps  <*  scn  -- (1) \n```", "```\n user  <-  T.pack  <$>  some  alphaNumChar \n```", "```\n user  <-  takeWhile1P  (Just  \"alpha num character\")  isAlphaNum  --                  ^                            ^  --                  |                            |  -- label for tokens we match against         predicate \n```", "```\ntakeWhileP  (Just  \"foo\")  f  =  many  (satisfy  f  <?>  \"foo\")  takeWhileP  Nothing  f  =  many  (satisfy  f)  takeWhile1P  (Just  \"foo\")  f  =  some  (satisfy  f  <?>  \"foo\")  takeWhile1P  Nothing  f  =  some  (satisfy  f) \n```", "```\ndata  ParseError  s  e  =  TrivialError  Int  (Maybe  (ErrorItem  (Token  s)))  (Set  (ErrorItem  (Token  s)))  -- ^ Trivial errors, generated by Megaparsec's machinery. The data\n    -- constructor includes the offset of error, unexpected token (if any),\n    -- and expected tokens.  |  FancyError  Int  (Set  (ErrorFancy  e))  -- ^ Fancy, custom errors. \n```", "```\ndata  ErrorItem  t  =  Tokens  (NonEmpty  t)  -- ^ Non-empty stream of tokens  |  Label  (NonEmpty  Char)  -- ^ Label (cannot be empty)  |  EndOfInput  -- ^ End of input \n```", "```\ndata  ErrorFancy  e  =  ErrorFail  String  -- ^ 'fail' has been used in parser monad  |  ErrorIndentation  Ordering  Pos  Pos  -- ^ Incorrect indentation error: desired ordering between reference\n    -- level and actual level, reference indentation level, actual\n    -- indentation level  |  ErrorCustom  e  -- ^ Custom error data, can be conveniently disabled by indexing\n    -- 'ErrorFancy' by 'Void' \n```", "```\n-- | A non-empty collection of 'ParseError's equipped with 'PosState' that\n-- allows to pretty-print the errors efficiently and correctly.  data  ParseErrorBundle  s  e  =  ParseErrorBundle  {  bundleErrors  ::  NonEmpty  (ParseError  s  e)  -- ^ A collection of 'ParseError's that is sorted by parse error offsets  ,  bundlePosState  ::  PosState  s  -- ^ State that is used for line\\/column calculation  } \n```", "```\nλ> parseTest (fail \"I'm failing, help me!\" :: Parser ()) \"\"\n1:1:\n  |\n1 | <empty line>\n  | ^\nI'm failing, help me! \n```", "```\nfailure  ::  MonadParsec  e  s  m  =>  Maybe  (ErrorItem  (Token  s))  -- ^ Unexpected item (if any)  ->  Set  (ErrorItem  (Token  s))  -- ^ Expected items  ->  m  a \n```", "```\nunfortunateParser  ::  Parser  ()  unfortunateParser  =  failure  (Just  EndOfInput)  (Set.fromList  es)  where  es  =  [Tokens  (NE.fromList  \"a\"),  Tokens  (NE.fromList  \"b\")] \n```", "```\nλ> parseTest unfortunateParser \"\"\n1:1:\n  |\n1 | <empty line>\n  | ^\nunexpected end of input\nexpecting 'a' or 'b' \n```", "```\nfancyFailure  ::  MonadParsec  e  s  m  =>  Set  (ErrorFancy  e)  -- ^ Fancy error components  ->  m  a \n```", "```\nincorrectIndent  ::  MonadParsec  e  s  m  =>  Ordering  -- ^ Desired ordering between reference level and actual level  ->  Pos  -- ^ Reference indentation level  ->  Pos  -- ^ Actual indentation level  ->  m  a  incorrectIndent  ord  ref  actual  =  fancyFailure  .  Set.singleton  $  ErrorIndentation  ord  ref  actual \n```", "```\ndata  Custom  =  NotKeyword  Text  deriving  (Eq,  Show,  Ord) \n```", "```\ninstance  ShowErrorComponent  Custom  where  showErrorComponent  (NotKeyword  txt)  =  T.unpack  txt  ++  \" is not a keyword\" \n```", "```\ntype  Parser  =  Parsec  Custom  Text \n```", "```\nnotKeyword  ::  Text  ->  Parser  a  notKeyword  =  customFailure  .  NotKeyword \n```", "```\ncustomFailure  ::  MonadParsec  e  s  m  =>  e  ->  m  a  customFailure  =  fancyFailure  .  E.singleton  .  ErrorCustom \n```", "```\nλ> parseTest (notKeyword \"foo\" :: Parser ()) \"\"\n1:1:\n  |\n1 | <empty line>\n  | ^\nfoo is not a keyword \n```", "```\n-- | Pretty-print a 'ParseErrorBundle'. All 'ParseError's in the bundle will\n-- be pretty-printed in order together with the corresponding offending\n-- lines by doing a single efficient pass over the input stream. The\n-- rendered 'String' always ends with a newline.  errorBundlePretty  ::  (  VisualStream  s  ,  TraversableStream  s  ,  ShowErrorComponent  e  )  =>  ParseErrorBundle  s  e  -- ^ Parse error bundle to display  ->  String  -- ^ Textual rendition of the bundle \n```", "```\n-- | @'observing' p@ allows to “observe” failure of the @p@ parser, should\n-- it happen, without actually ending parsing, but instead getting the\n-- 'ParseError' in 'Left'. On success parsed value is returned in 'Right'\n-- as usual. Note that this primitive just allows you to observe parse\n-- errors as they happen, it does not backtrack or change how the @p@\n-- parser works in any way.  observing  ::  MonadParsec  e  s  m  =>  m  a  -- ^ The parser to run  ->  m  (Either  (ParseError  (Token  s)  e)  a) \n```", "```\n{-# LANGUAGE OverloadedStrings #-}  {-# LANGUAGE TypeApplications  #-}  module  Main  (main)  where  import  Control.Applicative  hiding  (some)  import  Data.List  (intercalate)  import  Data.Set  (Set)  import  Data.Text  (Text)  import  Data.Void  import  Text.Megaparsec  import  Text.Megaparsec.Char  import  qualified  Data.Set  as  Set  data  Custom  =  TrivialWithLocation  [String]  -- position stack  (Maybe  (ErrorItem  Char))  (Set  (ErrorItem  Char))  |  FancyWithLocation  [String]  -- position stack  (ErrorFancy  Void)  -- Void, because we do not want to allow to nest Customs  deriving  (Eq,  Ord,  Show)  instance  ShowErrorComponent  Custom  where  showErrorComponent  (TrivialWithLocation  stack  us  es)  =  parseErrorTextPretty  (TrivialError  @Text  @Void  undefined  us  es)  ++  showPosStack  stack  showErrorComponent  (FancyWithLocation  stack  cs)  =  parseErrorTextPretty  (FancyError  @Text  @Void  undefined  (Set.singleton  cs))  ++  showPosStack  stack  showPosStack  ::  [String]  ->  String  showPosStack  =  intercalate  \", \"  .  fmap  (\"in \"  ++)  type  Parser  =  Parsec  Custom  Text  inside  ::  String  ->  Parser  a  ->  Parser  a  inside  location  p  =  do  r  <-  observing  p  case  r  of  Left  (TrivialError  _  us  es)  ->  fancyFailure  .  Set.singleton  .  ErrorCustom  $  TrivialWithLocation  [location]  us  es  Left  (FancyError  _  xs)  ->  do  let  f  (ErrorFail  msg)  =  ErrorCustom  $  FancyWithLocation  [location]  (ErrorFail  msg)  f  (ErrorIndentation  ord  rlvl  alvl)  =  ErrorCustom  $  FancyWithLocation  [location]  (ErrorIndentation  ord  rlvl  alvl)  f  (ErrorCustom  (TrivialWithLocation  ps  us  es))  =  ErrorCustom  $  TrivialWithLocation  (location:ps)  us  es  f  (ErrorCustom  (FancyWithLocation  ps  cs))  =  ErrorCustom  $  FancyWithLocation  (location:ps)  cs  fancyFailure  (Set.map  f  xs)  Right  x  ->  return  x  myParser  ::  Parser  String  myParser  =  some  (char  'a')  *>  some  (char  'b')  main  ::  IO  ()  main  =  do  parseTest  (inside  \"foo\"  myParser)  \"aaacc\"  parseTest  (inside  \"foo\"  $  inside  \"bar\"  myParser)  \"aaacc\" \n```", "```\n1:4:\n  |\n1 | aaacc\n  |    ^\nunexpected 'c'\nexpecting 'a' or 'b'\nin foo\n1:4:\n  |\n1 | aaacc\n  |    ^\nunexpected 'c'\nexpecting 'a' or 'b'\nin foo, in bar \n```", "```\n-- | Specify how to process 'ParseError's that happen inside of this\n-- wrapper. This applies to both normal and delayed 'ParseError's.\n--\n-- As a side-effect of the implementation the inner computation will start\n-- with empty collection of delayed errors and they will be updated and\n-- “restored” on the way out of 'region'.  region  ::  MonadParsec  e  s  m  =>  (ParseError  s  e  ->  ParseError  s  e)  -- ^ How to process 'ParseError's  ->  m  a  -- ^ The “region” that the processing applies to  ->  m  a  region  f  m  =  do  r  <-  observing  m  case  r  of  Left  err  ->  parseError  (f  err)  -- see the next section  Right  x  ->  return  x \n```", "```\nparseError  ::  MonadParsec  e  s  m  =>  ParseError  s  e  ->  m  a \n```", "```\nfailure  ::  MonadParsec  e  s  m  =>  Maybe  (ErrorItem  (Token  s))  -- ^ Unexpected item (if any)  ->  Set  (ErrorItem  (Token  s))  -- ^ Expected items  ->  m  a  failure  us  ps  =  do  o  <-  getOffset  parseError  (TrivialError  o  us  ps)  fancyFailure  ::  MonadParsec  e  s  m  =>  Set  (ErrorFancy  e)  -- ^ Fancy error components  ->  m  a  fancyFailure  xs  =  do  o  <-  getOffset  parseError  (FancyError  o  xs) \n```", "```\nwithPredicate2  ::  (a  ->  Bool)  -- ^ The check to perform on parsed input  ->  String  -- ^ Message to print when the check fails  ->  Parser  a  -- ^ Parser to run  ->  Parser  a  -- ^ Resulting parser that performs the check  withPredicate2  f  msg  p  =  do  o  <-  getOffset  r  <-  p  if  f  r  then  return  r  else  do  setOffset  o  fail  msg \n```", "```\nwithPredicate3  ::  (a  ->  Bool)  -- ^ The check to perform on parsed input  ->  String  -- ^ Message to print when the check fails  ->  Parser  a  -- ^ Parser to run  ->  Parser  a  -- ^ Resulting parser that performs the check  withPredicate3  f  msg  p  =  do  o  <-  getOffset  r  <-  p  if  f  r  then  return  r  else  region  (setErrorOffset  o)  (fail  msg)  withPredicate4  ::  (a  ->  Bool)  -- ^ The check to perform on parsed input  ->  String  -- ^ Message to print when the check fails  ->  Parser  a  -- ^ Parser to run  ->  Parser  a  -- ^ Resulting parser that performs the check  withPredicate4  f  msg  p  =  do  o  <-  getOffset  r  <-  p  if  f  r  then  return  r  else  parseError  (FancyError  o  (Set.singleton  (ErrorFail  msg))) \n```", "```\n-- | @'withRecovery' r p@ allows continue parsing even if parser @p@\n-- fails. In this case @r@ is called with the actual 'ParseError' as its\n-- argument. Typical usage is to return a value signifying failure to\n-- parse this particular object and to consume some part of the input up\n-- to the point where the next object starts.\n--\n-- Note that if @r@ fails, original error message is reported as if\n-- without 'withRecovery'. In no way recovering parser @r@ can influence\n-- error messages.  withRecovery  ::  (ParseError  s  e  ->  m  a)  -- ^ How to recover from failure  ->  m  a  -- ^ Original parser  ->  m  a  -- ^ Parser that can recover from failures \n```", "```\n-- | Register a 'ParseError' for later reporting. This action does not end\n-- parsing and has no effect except for adding the given 'ParseError' to the\n-- collection of “delayed” 'ParseError's which will be taken into\n-- consideration at the end of parsing. Only if this collection is empty\n-- parser will succeed. This is the main way to report several parse errors\n-- at once.  registerParseError  ::  MonadParsec  e  s  m  =>  ParseError  s  e  ->  m  ()  -- | Like 'failure', but for delayed 'ParseError's.  registerFailure  ::  MonadParsec  e  s  m  =>  Maybe  (ErrorItem  (Token  s))  -- ^ Unexpected item (if any)  ->  Set  (ErrorItem  (Token  s))  -- ^ Expected items  ->  m  ()  -- | Like 'fancyFailure', but for delayed 'ParseError's.  registerFancyFailure  ::  MonadParsec  e  s  m  =>  Set  (ErrorFancy  e)  -- ^ Fancy error components  ->  m  () \n```", "```\n{-# LANGUAGE OverloadedStrings #-}  module  Main  (main)  where  import  Control.Applicative  hiding  (some)  import  Data.Text  (Text)  import  Data.Void  import  Test.Hspec  import  Test.Hspec.Megaparsec  import  Text.Megaparsec  import  Text.Megaparsec.Char  type  Parser  =  Parsec  Void  Text  myParser  ::  Parser  String  myParser  =  some  (char  'a')  main  ::  IO  ()  main  =  hspec  $  describe  \"myParser\"  $  do  it  \"returns correct result\"  $  parse  myParser  \"\"  \"aaa\"  `shouldParse`  \"aaa\"  it  \"result of parsing satisfies what it should\"  $  parse  myParser  \"\"  \"aaaa\"  `parseSatisfies`  ((==  4)  .  length) \n```", "```\n it  \"should parse 'a's all right\"  $  parse  myParser  \"\"  `shouldSucceedOn`  \"aaaa\"  it  \"should fail on 'b's\"  $  parse  myParser  \"\"  `shouldFailOn`  \"bbb\" \n```", "```\n it  \"fails on 'b's producing correct error message\"  $  parse  myParser  \"\"  \"bbb\"  `shouldFailWith`  TrivialError  0  (Just  (Tokens  ('b'  :|  [])))  (Set.singleton  (Tokens  ('a'  :|  []))) \n```", "```\n it  \"fails on 'b's producing correct error message\"  $  parse  myParser  \"\"  \"bbb\"  `shouldFailWith`  err  0  (utok  'b'  <>  etok  'a') \n```", "```\n it  \"consumes all 'a's but does not touch 'b's\"  $  runParser'  myParser  (initialState  \"aaabbb\")  `succeedsLeaving`  \"bbb\"  it  \"fails without consuming anything\"  $  runParser'  myParser  (initialState  \"bbbccc\")  `failsLeaving`  \"bbbccc\" \n```", "```\nrunParser'  ::  Parsec  e  s  a  -- ^ Parser to run  ->  State  s  -- ^ Initial state  ->  (State  s,  Either  (ParseError  (Token  s)  e)  a)  runParserT'  ::  Monad  m  =>  ParsecT  e  s  m  a  -- ^ Parser to run  ->  State  s  -- ^ Initial state  ->  m  (State  s,  Either  (ParseError  (Token  s)  e)  a) \n```", "```\n{-# LANGUAGE LambdaCase        #-}  {-# LANGUAGE OverloadedStrings #-}  {-# LANGUAGE RecordWildCards   #-}  {-# LANGUAGE TypeFamilies      #-}  module  Main  (main)  where  import  Data.List.NonEmpty  (NonEmpty  (..))  import  Data.Proxy  import  Data.Void  import  Text.Megaparsec  import  qualified  Data.List  as  DL  import  qualified  Data.List.NonEmpty  as  NE  import  qualified  Data.Set  as  Set  data  MyToken  =  Int  Int  |  Plus  |  Mul  |  Div  |  OpenParen  |  CloseParen  deriving  (Eq,  Ord,  Show) \n```", "```\ndata  WithPos  a  =  WithPos  {  startPos  ::  SourcePos  ,  endPos  ::  SourcePos  ,  tokenLength  ::  Int  ,  tokenVal  ::  a  }  deriving  (Eq,  Ord,  Show) \n```", "```\ndata  MyStream  =  MyStream  {  myStreamInput  ::  String  -- for showing offending lines  ,  unMyStream  ::  [WithPos  MyToken]  } \n```", "```\ninstance  Stream  MyStream  where  type  Token  MyStream  =  WithPos  MyToken  type  Tokens  MyStream  =  [WithPos  MyToken]  -- … \n```", "```\ninstance  Stream  MyStream  where  type  Token  MyStream  =  WithPos  MyToken  type  Tokens  MyStream  =  [WithPos  MyToken]  tokenToChunk  Proxy  x  =  [x]  tokensToChunk  Proxy  xs  =  xs  chunkToTokens  Proxy  =  id  chunkLength  Proxy  =  length  chunkEmpty  Proxy  =  null  take1_  (MyStream  _  [])  =  Nothing  take1_  (MyStream  str  (t:ts))  =  Just  (  t  ,  MyStream  (drop  (tokensLength  pxy  (t:|[]))  str)  ts  )  takeN_  n  (MyStream  str  s)  |  n  <=  0  =  Just  ([],  MyStream  str  s)  |  null  s  =  Nothing  |  otherwise  =  let  (x,  s')  =  splitAt  n  s  in  case  NE.nonEmpty  x  of  Nothing  ->  Just  (x,  MyStream  str  s')  Just  nex  ->  Just  (x,  MyStream  (drop  (tokensLength  pxy  nex)  str)  s')  takeWhile_  f  (MyStream  str  s)  =  let  (x,  s')  =  DL.span  f  s  in  case  NE.nonEmpty  x  of  Nothing  ->  (x,  MyStream  str  s')  Just  nex  ->  (x,  MyStream  (drop  (tokensLength  pxy  nex)  str)  s')  instance  VisualStream  MyStream  where  showTokens  Proxy  =  DL.intercalate  \" \"  .  NE.toList  .  fmap  (showMyToken  .  tokenVal)  tokensLength  Proxy  xs  =  sum  (tokenLength  <$>  xs)  instance  TraversableStream  MyStream  where  reachOffset  o  PosState  {..}  =  (  Just  (prefix  ++  restOfLine)  ,  PosState  {  pstateInput  =  MyStream  {  myStreamInput  =  postStr  ,  unMyStream  =  post  }  ,  pstateOffset  =  max  pstateOffset  o  ,  pstateSourcePos  =  newSourcePos  ,  pstateTabWidth  =  pstateTabWidth  ,  pstateLinePrefix  =  prefix  }  )  where  prefix  =  if  sameLine  then  pstateLinePrefix  ++  preLine  else  preLine  sameLine  =  sourceLine  newSourcePos  ==  sourceLine  pstateSourcePos  newSourcePos  =  case  post  of  []  ->  case  unMyStream  pstateInput  of  []  ->  pstateSourcePos  xs  ->  endPos  (last  xs)  (x:_)  ->  startPos  x  (pre,  post)  =  splitAt  (o  -  pstateOffset)  (unMyStream  pstateInput)  (preStr,  postStr)  =  splitAt  tokensConsumed  (myStreamInput  pstateInput)  preLine  =  reverse  .  takeWhile  (/=  '\\n')  .  reverse  $  preStr  tokensConsumed  =  case  NE.nonEmpty  pre  of  Nothing  ->  0  Just  nePre  ->  tokensLength  pxy  nePre  restOfLine  =  takeWhile  (/=  '\\n')  postStr  pxy  ::  Proxy  MyStream  pxy  =  Proxy  showMyToken  ::  MyToken  ->  String  showMyToken  =  \\case  (Int  n)  ->  show  n  Plus  ->  \"+\"  Mul  ->  \"*\"  Div  ->  \"/\"  OpenParen  ->  \"(\"  CloseParen  ->  \")\" \n```", "```\ntype  Parser  =  Parsec  Void  MyStream \n```", "```\nliftMyToken  ::  MyToken  ->  WithPos  MyToken  liftMyToken  myToken  =  WithPos  pos  pos  0  myToken  where  pos  =  initialPos  \"\"  pToken  ::  MyToken  ->  Parser  MyToken  pToken  c  =  token  test  (Set.singleton  .  Tokens  .  nes  .  liftMyToken  $  c)  where  test  (WithPos  _  _  _  x)  =  if  x  ==  c  then  Just  x  else  Nothing  nes  x  =  x  :|  []  pInt  ::  Parser  Int  pInt  =  token  test  Set.empty  <?>  \"integer\"  where  test  (WithPos  _  _  _  (Int  n))  =  Just  n  test  _  =  Nothing \n```", "```\npSum  ::  Parser  (Int,  Int)  pSum  =  do  a  <-  pInt  _  <-  pToken  Plus  b  <-  pInt  return  (a,  b) \n```", "```\nexampleStream  ::  MyStream  exampleStream  =  MyStream  \"5 + 6\"  [  at  1  1  (Int  5)  ,  at  1  3  Plus  -- (1)  ,  at  1  5  (Int  6)  ]  where  at  l  c  =  WithPos  (at'  l  c)  (at'  l  (c  +  1))  2  at'  l  c  =  SourcePos  \"\"  (mkPos  l)  (mkPos  c) \n```", "```\nλ> parseTest (pSum <* eof) exampleStream\n(5,6) \n```", "```\nλ> parseTest (pSum <* eof) exampleStream\n1:3:\n  |\n1 | 5 + 6\n  |   ^^\nunexpected /\nexpecting + \n```"]