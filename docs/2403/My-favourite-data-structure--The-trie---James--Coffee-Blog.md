<!--yml

类别：未分类

日期：2024-05-27 14:33:33

-->

# 我最喜欢的数据结构：字典树 | 詹姆斯的咖啡博客

> 来源：[https://jamesg.blog/2024/01/16/trie/](https://jamesg.blog/2024/01/16/trie/)

假设你想构建一个预测文本引擎。给定一些字母，你想预测单词的结尾。假设我们有字符串"co"。接下来的单词可能是：

+   钴

+   代码

+   咖啡

+   合作

或者其他很多单词。

给定包含所有英语单词的字典，你可以找到以"co"开头的所有单词，并挑选一个推荐。但是如何选择要推荐的单词呢？

一个好的答案是使用单词概率。你可以有一个包含各种不同文本的参考文本，从中计算一个单词使用的可能性。你也可以根据实际使用进行调整。如果有人经常输入"cobalt"（我不知道为什么会这样，但好吧 :D），在为字符串"co"选择推荐单词时，你可以更高地排名"Cobalt"。

我们缺少的一个部分是如何高效地实现这一点？

这就是字典树发挥作用的地方，我的最爱数据结构。

## 什么是字典树？

字典树是一个深度嵌套的树。这种结构通常用于预测文本引擎，因为你可以将所有字符串表示为树。然后，你可以使用单词概率来决定应该推荐哪个单词。可以通过使用来自英语出版物的数百万单词的参考语料库来识别不同单词的常见程度来实现这一点。

对于下一个单词的预测，字典树可能会在字母级别上构建。这意味着每个字母都有一个值，并且还链接到可能跟在其后的每一个其他可能字母。

你可以向字典树添加项目，搜索项目，以及从字典树中删除项目。

## 逐步了解字典树

让我们模拟一个字典树，看看它是如何工作的！

我们的字典树将包含两个单词：

考虑以下的字典树：

```
 {
	"c": {
		"*": 0,
		"o": {
			"*": 1.0,
			"b": {
				"*": 1.2,
				"a": {
					"*": 0,
					"l": {
						"*": 0,
						"t": {
							"*": 0.9
						}
					}
				}
			},
			"d": {
				"*": 0.1,
				"e": {
					"*": 7.3
				}
			}
		}
	}
} 
```

我们的字典树中的每个可能的字母都是一个键。如上所述，我们的字典树被表示为一个字典。在实际实现中，字典树可能会被表示为一组类，这在基于树的算法中很常见。

每个键有两种可能的属性：

1.  `*`，这表示单词推荐的概率，以及；

1.  一个包含所有可能下一个字母或者如果没有更多字母则为一个数字的字典。

假设我们只想获取以"co"开头的单词。如果我们的字典树是一个字典，这是如何实现的伪代码：

```
 trie["c"]["o"] 
```

我们随后可以递归地遍历所有键中的"o"，以计算下一个可能的单词。在此示例中，我们可以生成两个单词：

我们可以通过添加另一个字符来完善我们的搜索：

```
 trie["c"]["o"]["d"] 
```

这样做的价值在于：

```
 "*": 0.1,
"e": {
	"*": 7.3
} 
```

`*` 其值为 0.1 代表"cod"（鱼的一种）。"e"告诉我们后面还有一个字母可以跟在"cod"后面："e"。其值为"7.3"。

现在，让我们假设我们遍历了先前创建的整个树以寻找"co"。我们最终会得到两个值：

我们可以对这些进行排序，并选择概率最高的一个作为我们的下一个单词推荐。

## 让我们制作一个字典树！（Python 版本）

如果你想在 Python 中使用 Trie，我推荐使用[pygtrie](https://pygtrie.readthedocs.io/en/latest/)库，该库由 Google 原始开发。此库具有预建的实用程序，用于访问 Trie 中的项、遍历 Trie 等功能。

首先，运行：

```
 pip install pygtrie 
```

然后，创建一个包含以下代码的新文件：

```
 import pygtrie

trie = pygtrie.CharTrie()

# add an element
trie["code"] = 7.3
trie["cobalt"] = 0.9
trie["coffee"] = 10

print(trie.keys(prefix="co")) 
```

在这段代码中，我们创建了一个包含三个元素的 Trie：

在代码末尾，我们搜索 Trie 来查找以 "co" 开头的所有单词。

我们的代码返回：

```
 ['code', 'cobalt', 'coffee'] 
```

我们可以使用以下代码按概率对单词进行排序：

```
 results = sorted(results, key=lambda x: trie[x]) 
```

这是结果：

```
 ['coffee', 'code', 'cobalt'] 
```

## 结论和资源

Trie 是一种树数据结构。在 Trie 中，每个节点都有节点本身的值和一组可以遍历的节点。你可以将单词表示为 Trie，以便高效地查找以给定前缀开头的所有单词。由于你可以为每个节点赋值，你可以将概率附加到 Trie 中的每个单词。这对于下一个单词预测非常理想，你可以使用用户已经输入的字母从 Trie 中提取下一个单词的候选项，然后根据每个节点关联的概率对它们进行排序。

你也可以高效地查找不在 Trie 中的单词。为此，你需要将一个单词（例如 "codep"）拆分为其字母，并逐个搜索 `trie["c"]["o"]["d"]["e"]["p"]`。如果结果没有关联的值，那么你就知道这个单词不在树中。

欲详细了解 trie 数据结构，请参阅[Trie 维基百科页面](https://zh.wikipedia.org/wiki/Trie)。

[在 Hacker News 上分享此帖子](https://news.ycombinator.com/submitlink?u=https://jamesg.blog//2024/01/16/trie/&t=My%20favourite%20data%20structure:%20The%20trie)。

[在 Lobste.rs 上分享此帖子](https://lobste.rs/stories/new?url=https://jamesg.blog//2024/01/16/trie/&title=My%20favourite%20data%20structure:%20The%20trie)。
