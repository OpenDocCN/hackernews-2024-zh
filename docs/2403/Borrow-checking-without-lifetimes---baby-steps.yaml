- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:35:17'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Borrow checking without lifetimes · baby steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://smallcultfollowing.com/babysteps/blog/2024/03/04/borrow-checking-without-lifetimes/](https://smallcultfollowing.com/babysteps/blog/2024/03/04/borrow-checking-without-lifetimes/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This blog post explores an alternative formulation of Rust’s type system that
    eschews *lifetimes* in favor of *places*. The TL;DR is that instead of having
    `'a` represent a *lifetime* in the code, it can represent a set of *loans*, like
    `shared(a.b.c)` or `mut(x)`. If this sounds familiar, it should, it’s the basis
    for [polonius](https://smallcultfollowing.com/babysteps/blog/2023/09/22/polonius-part-1/),
    but reformulated as a type system instead of a static analysis. This blog post
    is just going to give the high-level ideas. In follow-up posts I’ll dig into how
    we can use this to support interior references and other advanced borrowing patterns.
    In terms of implementation, I’ve mocked this up a bit, but I intend to start extending
    [a-mir-formality](https://github.com/rust-lang/a-mir-formality) to include this
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Why would you want to replace lifetimes?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lifetimes are the best and worst part of Rust. The best in that they let you
    express very cool patterns, like returning a pointer into some data in the middle
    of your data structure. But they’ve got some serious issues. For one, the idea
    of what a lifetime is rather abstract, and hard for people to grasp (“what does
    `'a` actually represent?”). But also Rust is not able to express some important
    patterns, most notably interior references, where one field of a struct refers
    to data owned by another field.
  prefs: []
  type: TYPE_NORMAL
- en: So what *is* a lifetime exactly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the definition of a lifetime from the RFC on non-lexical lifetimes:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you create a borrow, the compiler assigns the resulting reference a
    lifetime. This lifetime corresponds to the span of the code where the reference
    may be used. The compiler will infer this lifetime to be the smallest lifetime
    that it can have that still encompasses all the uses of the reference.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Read the RFC for more details.](https://rust-lang.github.io/rfcs/2094-nll.html#what-is-a-lifetime)'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a *lifetime* with an *origin*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under this formulation, `'a` no longer represents a *lifetime* but rather an
    **origin** – i.e., it explains where the reference may have come from. We define
    an origin as a **set of loans**. Each loan captures some **place expression**
    (e.g. `a` or `a.b.c`), that has been borrowed along with the mode in which it
    was borrowed (`shared` or `mut`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Defining types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using origins, we can define Rust types roughly like this (obviously I’m ignoring
    a bunch of complexity here&mldr;):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the first interesting thing to note: there is no `''a` notation here!
    This is because I’ve not introduced generics yet. Unlike Rust proper, this formulation
    of the type system has a concrete syntax (`Origin`) for what `''a` represents.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit types for a simple program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having a fully explicit type system also means we can easily write out example
    programs where all types are fully specified. This used to be rather challenging
    because we had no notation for lifetimes. Let’s look at a simple example, a program
    that ought to get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the type of `p`, this is valid Rust. Of course, it won’t compile,
    because we can’t modify `counter` while there is a live shared reference `p` ([playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1a05f0a4aad12c33345ca4adc1cd9bb2)).
    As we continue, you will see how the new type system formulation arrives at the
    same conclusion.
  prefs: []
  type: TYPE_NORMAL
- en: Basic typing judgments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typing judgments are the standard way to describe a type system. We’re going
    to phase in the typing judgments for our system iteratively. We’ll start with
    a simple, fairly standard formulation that doesn’t include borrow checking, and
    then show how we introduce borrow checking. For this first version, the typing
    judgment we are defining has the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This says, “in the environment `Env`, the expression `Expr` is legal and has
    the type `Type`”. The *environment* `Env` here defines the local variables in
    scope. The Rust expressions we are looking at for our [sample program](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1a05f0a4aad12c33345ca4adc1cd9bb2)
    are pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we only support one scalar type (`u32`), the typing judgment for `Expr
    + Expr` is as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The rule for `Place = Expr` assignments is based on subtyping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The rule for `&Place` is somewhat more interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The rule just says that we figure out the type of the place `Place` being borrowed
    (here, the place is `counter` and its type will be `u32`) and then we have a resulting
    reference to that type. The origin of that reference will be `{shared(Place)}`,
    indicating that the reference came from `Place`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Computing liveness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To introduce borrow checking, we need to phase in the idea of **liveness**.
    ^(If you’re not familiar with the concept, the NLL RFC has a [nice introduction](https://rust-lang.github.io/rfcs/2094-nll.html#liveness):)
  prefs: []
  type: TYPE_NORMAL
- en: The term “liveness” derives from compiler analysis, but it’s fairly intuitive.
    We say that a variable is live if the current value that it holds may be used
    later.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Unlike with NLL, where we just computed live **variables**, we’re going to
    compute **live places**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the set of live places, we’ll introduce a helper function `LiveBefore(Env,
    LivePlaces, Expr): LivePlaces`. `LiveBefore()` returns the set of places that
    are live before `Expr` is evaluated, given the environment `Env` and the set of
    places live after expression. I won’t define this function in detail, but it looks
    roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Integrating liveness into our typing judgments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To detect borrow check errors, we need to adjust our typing judgment to include
    liveness. The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This judgment says, “in the environment `Env`, and given that the function will
    access `LivePlaces` in the future, `Expr` is valid and has type `Type`”. Integrating
    liveness in this way gives us some idea of what accesses will happen in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'For compound expressions, like `Expr1 + Expr2`, we have to adjust the set of
    live places to reflect control flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We start out with `LiveAfter2`, i.e., the places that are live after the entire
    expression. These are also the same as the places live after expression 2 is evaluated,
    since this expression doesn’t itself reference or overwrite any places. We then
    compute `LiveAfter1` – i.e., the places live after `Expr1` is evaluated – by looking
    at the places that are live *before* `Expr2`. This is a bit mind-bending and took
    me a bit of time to see. The tricky bit here is that liveness is computed *backwards*,
    but most of our typing rules (and intution) tends to flow *forwards*. If it helps,
    think of the “fully desugared” version of `+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Borrow checking with liveness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know liveness information, we can use it to do borrow checking.
    We’ll introduce a “permits” judgment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'that indicates that “taking the loan Loan would be allowed given the environment
    and the live places”. Here is the rule for assignments, modified to include liveness
    and the new “permits” judgment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Before I dive into how we define “permits”, let’s go back to our example and
    get an intution for what is going on here. We want to declare an error on this
    assigment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that, because of the `println!` on the next line, `p` will be in our `LiveAfter`
    set. Looking at the type of `p`, we see that it includes the loan `shared(counter)`.
    The idea then is that mutating counter is illegal because there is a live loan
    `shared(counter)`, which implies that `counter` must be immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restating that intution:'
  prefs: []
  type: TYPE_NORMAL
- en: A set `Live` of live places *permits* a loan `Loan1` if, for every live place
    `Place` in `Live`, the loans in the type of `Place` are compatible with `Loan1`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Written more formally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition makes use of two helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Loans(Type)` – the set of loans that appear in the type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compatible(Loan1, Loan2)` – defines if two loans are compatible. Two shared
    loans are always compatible. A mutable loan is only compatible with another loan
    if the places are disjoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this post was to give a high-level intution. I wrote it from memory,
    so I’ve probably overlooked a thing or two. In follow-up posts though I want to
    go deeper into how the system I’ve been playing with works and what new things
    it can support. Some high-level examples:'
  prefs: []
  type: TYPE_NORMAL
- en: How to define subtyping, and in particular the role of liveness in subtyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important borrow patterns that we use today and how they work in the new system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interior references that point at data owned by other struct fields and how
    it can be supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
