["```\nstruct  landlock_ruleset_attr  ruleset_attr  =  { .handled_access_fs  = LANDLOCK_ACCESS_FS_EXECUTE  | LANDLOCK_ACCESS_FS_WRITE_FILE  | LANDLOCK_ACCESS_FS_READ_FILE  | LANDLOCK_ACCESS_FS_READ_DIR  | LANDLOCK_ACCESS_FS_REMOVE_DIR  | LANDLOCK_ACCESS_FS_REMOVE_FILE  | LANDLOCK_ACCESS_FS_MAKE_CHAR  | LANDLOCK_ACCESS_FS_MAKE_DIR  | LANDLOCK_ACCESS_FS_MAKE_REG  | LANDLOCK_ACCESS_FS_MAKE_SOCK  | LANDLOCK_ACCESS_FS_MAKE_FIFO  | LANDLOCK_ACCESS_FS_MAKE_BLOCK  | LANDLOCK_ACCESS_FS_MAKE_SYM  | LANDLOCK_ACCESS_FS_REFER  | LANDLOCK_ACCESS_FS_TRUNCATE  | LANDLOCK_ACCESS_FS_IOCTL_DEV, .handled_access_net  = LANDLOCK_ACCESS_NET_BIND_TCP  | LANDLOCK_ACCESS_NET_CONNECT_TCP, }; \n```", "```\nint  abi; abi  =  landlock_create_ruleset(NULL,  0,  LANDLOCK_CREATE_RULESET_VERSION); if  (abi  <  0)  { /* Degrades gracefully if Landlock is not handled. */ perror(\"The running kernel does not enable to use Landlock\"); return  0; } switch  (abi)  { case  1: /* Removes LANDLOCK_ACCESS_FS_REFER for ABI < 2 */ ruleset_attr.handled_access_fs  &=  ~LANDLOCK_ACCESS_FS_REFER; __attribute__((fallthrough)); case  2: /* Removes LANDLOCK_ACCESS_FS_TRUNCATE for ABI < 3 */ ruleset_attr.handled_access_fs  &=  ~LANDLOCK_ACCESS_FS_TRUNCATE; __attribute__((fallthrough)); case  3: /* Removes network support for ABI < 4 */ ruleset_attr.handled_access_net  &= ~(LANDLOCK_ACCESS_NET_BIND_TCP  | LANDLOCK_ACCESS_NET_CONNECT_TCP); __attribute__((fallthrough)); case  4: /* Removes LANDLOCK_ACCESS_FS_IOCTL_DEV for ABI < 5 */ ruleset_attr.handled_access_fs  &=  ~LANDLOCK_ACCESS_FS_IOCTL_DEV; } \n```", "```\nint  ruleset_fd; ruleset_fd  =  landlock_create_ruleset(&ruleset_attr,  sizeof(ruleset_attr),  0); if  (ruleset_fd  <  0)  { perror(\"Failed to create a ruleset\"); return  1; } \n```", "```\nint  err; struct  landlock_path_beneath_attr  path_beneath  =  { .allowed_access  = LANDLOCK_ACCESS_FS_EXECUTE  | LANDLOCK_ACCESS_FS_READ_FILE  | LANDLOCK_ACCESS_FS_READ_DIR, }; path_beneath.parent_fd  =  open(\"/usr\",  O_PATH  |  O_CLOEXEC); if  (path_beneath.parent_fd  <  0)  { perror(\"Failed to open file\"); close(ruleset_fd); return  1; } err  =  landlock_add_rule(ruleset_fd,  LANDLOCK_RULE_PATH_BENEATH, &path_beneath,  0); close(path_beneath.parent_fd); if  (err)  { perror(\"Failed to update ruleset\"); close(ruleset_fd); return  1; } \n```", "```\nstruct  landlock_net_port_attr  net_port  =  { .allowed_access  =  LANDLOCK_ACCESS_NET_CONNECT_TCP, .port  =  443, }; err  =  landlock_add_rule(ruleset_fd,  LANDLOCK_RULE_NET_PORT, &net_port,  0); \n```", "```\nif  (prctl(PR_SET_NO_NEW_PRIVS,  1,  0,  0,  0))  { perror(\"Failed to restrict privileges\"); close(ruleset_fd); return  1; } \n```", "```\nif  (landlock_restrict_self(ruleset_fd,  0))  { perror(\"Failed to enforce ruleset\"); close(ruleset_fd); return  1; } close(ruleset_fd); \n```", "```\n$ zgrep -h \"^CONFIG_LSM=\" \"/boot/config-$(uname -r)\" /proc/config.gz 2>/dev/null\nCONFIG_LSM=\"lockdown,yama,integrity,apparmor\" \n```", "```\n$ sed -n 's/.*\\(\\<lsm=\\S\\+\\).*/\\1/p' /proc/cmdline\nlsm=lockdown,yama,integrity,apparmor \n```", "```\nlsm=landlock,lockdown,yama,integrity,apparmor \n```", "```\n# dmesg | grep landlock || journalctl -kb -g landlock\n[    0.000000] Command line: [...] lsm=landlock,lockdown,yama,integrity,apparmor\n[    0.000000] Kernel command line: [...] lsm=landlock,lockdown,yama,integrity,apparmor\n[    0.000000] LSM: initializing lsm=lockdown,capability,landlock,yama,integrity,apparmor\n[    0.000000] landlock: Up and running. \n```"]