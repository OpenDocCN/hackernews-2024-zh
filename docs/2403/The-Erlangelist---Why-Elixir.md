<!--yml

category: 未分类

date: 2024-05-29 12:43:38

-->

# The Erlangelist - Why Elixir

> 来源：[https://www.theerlangelist.com/article/why_elixir](https://www.theerlangelist.com/article/why_elixir)

我开始使用 Elixir 已经一年了。最初，我打算仅将这种语言用于博客目的，认为它可以帮助我更好地阐明 Erlang 虚拟机（EVM）的优势。然而，我立即被语言所带来的东西深深迷住，并很快将其引入到我当时正在开发的基于 Erlang 的生产系统中。今天，我认为 Elixir 是开发基于 EVM 的系统的更好选择，在这些文章中，我将尝试突出一些它的优点，并消除一些关于它的误解。

## Erlang 语言的问题

EVM 具有许多优点，使得构建高可用、可扩展、容错、分布式系统变得更加容易。有各种各样的互联网见证，我在这里和这里写了一些关于 Erlang 的优势，并且我即将出版的书《Elixir 实战》第一章介绍了 Erlang 和 Elixir 的优点。

长话短说，Erlang 提供了优秀的抽象来管理高度可扩展、容错系统，这在并发系统中特别有用，其中需要执行许多独立或松散依赖的任务。我已经在生产环境中使用 Erlang 超过三年，用来构建基于长轮询的 HTTP 推送服务器，在高峰期间每秒处理超过 2000 个请求（非缓存）。我以前从未编写过这样规模的东西，也从未开发过这么稳定的东西。服务运行得很顺利，我都不用担心。这实际上是我第一段 Erlang 代码，充斥着反模式和糟糕的方法。然而，EVM 证明非常有弹性，尽可能地运行代码。最重要的是，对于复杂问题，我工作起来相当直接，主要归功于 Erlang 的并发机制。

尽管有些优点，我从来不太喜欢（到现在也是如此）用 Erlang 编程。编程体验总是感觉不太流畅，最终的代码总是充斥着过多的样板和重复。**问题并不在语言语法上**。在学生时代，我稍微接触了一些 Prolog，我非常喜欢那种语言。由此延伸，我也喜欢 Erlang 的语法，实际上认为它在很多方面比 Elixir 更加优雅。这是从一个大部分时间用 Ruby、JavaScript、C# 和 C++ 等语言编码的面向对象开发者口中说出来的。

我对 Erlang 的问题是，这种语言似乎过于简单，使得很难消除样板和结构重复。相反，生成的代码有点混乱，编写、分析和修改都更加困难。在使用 Erlang 编程一段时间后，我认为函数式编程在高效的代码组织方面不如面向对象。

## Elixir 是什么（不是什么）

这就是 Elixir 改变了我的看法的地方。在我花足够的时间与这门语言一起后，我终于能够更清楚地看到函数式编程的优点和优雅之处。现在我不能再说我更喜欢面向对象而不是函数式编程了。我觉得在 Elixir 中编码体验更加愉快，我能够集中精力解决我遇到的问题，而不是处理语言的缺陷。

在讨论 Elixir 的一些好处之前，有一件重要的事情我想强调：**Elixir 不是 Ruby 对于 Erlang**。它也不是 CoffeeScript、Clojure、C++ 或其他什么语言对于 Erlang。Elixir 与 Erlang 的关系是独特的，Elixir 通常在语义上非常接近 Erlang，但还从其他语言带来了许多想法。最终的结果可能在表面上看起来像 Ruby，但我发现它更接近 Erlang，这两种语言完全共享类型系统，并采用相同的功能路线。

那么，什么是 Elixir？对我来说，它是一种类似于 Erlang 的语言，具有改进的代码组织能力。这个定义与您在官方页面上看到的不同，但我认为它捕捉了 Elixir 的本质，与 Erlang 相比。

让我详细说明一下。在我看来，编程语言有几个角色：

+   它作为一个接口，允许程序员控制某些东西，例如硬件的一部分、虚拟机、运行中的应用程序、UI 布局等等。

+   它塑造了开发者对他们建模的世界的思考方式。面向对象的语言会让我们寻找具有状态和行为的实体，而在函数式编程语言中，我们会思考数据和转换。声明式编程语言会迫使我们思考规则，而在命令式语言中，我们会更多地考虑操作的顺序。

+   它提供了工具来组织代码，消除重复、样板、噪声，并希望尽可能地模拟我们理解问题的方式。

Erlang 和 Elixir 在前两个角色上完全相同 - 它们都针对同样的“东西”（EVM），并且它们都采用功能性方法。在第三个角色中，Elixir 改进了 Erlang，并为我们提供了额外的工具来组织我们的代码，并希望在编写生产就绪、可维护的代码时更加高效。

## 成分

互联网上已经有很多关于 Elixir 的讨论，但我特别喜欢 Devin Torres 的两篇文章，你可以在[这里](https://devinus.io/the-excitement-of-elixir/)和[这里](https://devinus.io/elixir-its-not-about-syntax/)找到。Devin 是一位经验丰富的 Erlang 开发者，除其他事情外还编写了流行的 [poolboy](https://github.com/devinus/poolboy) 库，所以值得了解他对 Elixir 的看法。

我会尽量不重复太多内容，并避免深入许多机械细节。相反，让我们简要介绍一下可以用于更好代码组织的主要工具。

### 元编程

在 Elixir 中的元编程有几种不同的风格，但本质是相同的。它允许我们编写简洁的构造，看起来就像它们是语言的一部分。然后这些构造在编译时转换为适当的代码。从机械层面上来说，它帮助我们消除结构重复——两段代码共享相同的抽象模式，但在许多机械细节上有所不同。

例如，以下片段展示了一个模块草图，用于建模 `User` 记录：

```
defmodule  User  do  #initializer  def  new(data)  do  ...  end  # getters  def  name(user)  do  ...  end  def  age(user)  do  ...  end  # setters  def  name(value,  user)  do  ...  end  def  age(value,  user)  do  ...  end  end
```

后续将出现其他类型的记录，但包含不同的字段。我们可以使用 Elixir 的 `defrecord` 宏，而不是复制粘贴这种模式：

```
defrecord  User,  name:  nil,  age:  0
```

根据给定的定义，`defrecord` 生成一个专用模块，其中包含用于操作我们的 `User` 记录的实用函数。因此，通用模式仅在一个地方（`defrecord` 宏的代码）陈述，而特定逻辑则摆脱了机械实现细节。

Elixir 宏与 C/C++ 宏完全不同。它们不是处理字符串，而是类似于编译时的 Elixir 函数，在解析中被调用，并在抽象语法树（AST）上工作，即以 Elixir 数据结构表示的代码。宏可以在 AST 上工作，并输出表示生成代码的替代 AST。因此，宏在编译时执行，因此一旦到达运行时，性能不受影响，并且不会出现某些代码片段可以更改模块定义的意外情况（例如在 JavaScript 或 Ruby 中可能发生的情况）。

由于宏，大部分 Elixir 实际上是用 Elixir 实现的，包括诸如 `if`、`unless` 或单元测试支持之类的构造。Unicode 支持通过读取 UnicodeData.txt 文件，并生成相应的 Unicode 意识字符串函数的实现，例如 `downcase` 或 `upcase`。这反过来使得开发者更容易为 Elixir 贡献。

宏还允许第三方库作者提供自然适合语言的内部 DSL。[Ecto](https://github.com/elixir-lang/ecto) 项目提供了嵌入式集成查询，类似于 Elixir 的 LINQ，是我个人特别喜欢的项目，它真正展示了宏的强大功能。

我曾经看到有人有时会忽略 Elixir，声称他们不需要元编程能力。虽然极其有用，元编程也可能成为一种非常危险的工具，建议仔细考虑它们的使用。也就是说，有许多功能是由元编程支持的，即使你自己不编写宏，你可能仍然会享受到许多这些功能，比如前面提到的记录，Unicode 支持或集成查询语言。

### 管道操作符

这个看似简单的操作符非常有用，我甚至在意识到它在 Elixir（或其他语言中同样存在）之前，“发明”了它的[Erlang 等效](https://github.com/sasa1977/fun_chain)。

首先让我们看看问题。在 Erlang 中，没有管道操作符，而且我们也不能重新分配变量。因此，典型的 Erlang 代码通常以以下模式编写：

```
State1 = trans_1(State),
State2 = trans_2(State1),
State3 = trans_3(State2),
...
```

这是一段非常笨拙的代码，依赖中间变量，并正确地将最后的结果传递给下一个调用。我实际上因为在一个地方意外地使用了`State6`而不是`State7`而出现了一个讨厌的错误。

当然，我们可以通过内联函数调用来绕过：

```
trans_3(
  trans_2(
    trans_1(State)
  )
)
```

正如您所见，这段代码很快就会变得丑陋，当转换函数接收到额外的参数并且转换的数量增加时，问题通常会加剧。

管道操作符使得可以组合各种操作而无需使用中间变量：

```
state  |>  trans_1  |>  trans_2  |>  trans_3
```

代码从上到下读起来像散文，并突显了 FP 的一项优势，即我们将函数视为数据转换器，以各种方式组合以达到期望的结果。

例如，以下代码计算列表中所有正数的平方和：

```
list  |>  Enum.filter(&(&1  >  0))  # take positive numbers  |>  Enum.map(&(&1  *  &1))  # square each one  |>  Enum.reduce(0,  &(&1  +  &2))  # calculate sum
```

管道操作符非常有效，因为 Elixir 库中的 API 遵循“主题（名词）作为第一个参数”的约定。与 Erlang 不同，Elixir 认为所有函数都应该将它们操作的东西作为第一个参数。因此，`String` 模块函数以字符串作为第一个参数，而 `Enum` 模块函数以可枚举对象作为第一个参数。

### 通过协议实现多态性

协议是 Elixir 提供类似于 OO 接口的方式。最初，我对它们并不怎么感兴趣，但随着时间的推移，我开始看到它们带来的许多好处。协议允许开发人员创建一个通用的逻辑，可以与任何类型的数据一起使用，假设给定数据实现了某些契约。

一个很好的例子是[Enum](https://hexdocs.pm/elixir/Enum.html) 模块，它提供了许多用于操作任何可枚举对象的有用函数。例如，这是我们如何迭代一个可枚举对象的方式：

```
Enum.each(enumerable,  fn  ->  ...  end)
```

`Enum.each`可以与不同类型一起工作，如列表或键值字典，当然，我们也可以通过实现相应的协议来为自己的类型添加支持。这类似于 OO 接口，但有一个额外的变化，即可以为一个类型实现协议，即使你没有其源代码。

协议实用性的最佳例子之一是[Stream](https://hexdocs.pm/elixir/Stream.html)模块，它实现了一个惰性、可组合的枚举抽象。通过将流馈送给`Enum`模块的某些函数，可以组合各种可枚举的转换，然后仅在需要时生成结果。例如，下面的代码计算列表中所有正数的平方和：

```
list  |>  Stream.filter(&(&1  >  0))  |>  Stream.map(&(&1  *  &1))  |>  Enum.reduce(0,  &(&1  +  &2))  # Entire iteration happens here in a single pass
```

在第 2 和第 3 行，操作已经组合，但尚未执行。结果是一个实现了`Enumerable`协议的规范描述符。一旦我们将这个描述符传递给某些`Enum`函数（第 3 行），它就开始产生值。除了支持协议机制外，Elixir 编译器没有特殊的惰性支持。

### mix 工具

最后一个重要的 puzzle piece 是帮助我们管理项目的工具。Elixir 自带了`mix`工具，正是它完成了这一任务。这也是以一种令人印象深刻的简单方式完成的。当你创建一个新项目时，只会在磁盘上创建 7 个文件（包括 .gitignore 和 README.md）。这些就足够创建一个正确的 OTP 应用程序了。这是一个极好的例子，展示了通过在通用抽象中隐藏必要的样板和官僚主义，可以将事情简化到何种程度。

Mix 工具支持各种其他任务，如依赖管理。该工具还是可扩展的，因此您可以根据需要创建自己的特定任务。

### 语法上的变化

列表并不止于此，Elixir 给我们提供了许多其他好处。其中许多包括语法上的变化，例如支持变量重绑定、可选的括号、隐式语句结束、可空性、短路运算符等等。

诚然，由于可选的括号引入了一些歧义，正如这个例子所示：

```
abs  -1  +  5  # same as abs(-1 + 5)
```

但是，我使用括号（除了宏和零参数函数），所以我不记得在实践中遇到过这个问题。

总体而言，我喜欢这个部门做出的许多决定。能够写`if`而不必加上`else`是很好的。不用再有意识地考虑该用哪个字符来结束语句，也是件好事。

即使是可选的括号也是很好的，因为它们支持宏的 DSL-ish 使用方式，使得代码更加简洁。如果没有它们，我们在调用宏时就必须添加括号：

```
defrecord  User,  name:  nil,  age:  0  # without parentheses  defrecord(User,  [name:  nil,  age:  0])  # with parentheses
```

尽管如此，我并不认为这些增强功能至关重要。它们是不错的点睛之笔，但如果这就是 Elixir 提供的全部，我可能仍然会使用纯 Erlang。

## 总结

本文中所述内容已经很丰富，但我认为Elixir的魔力远远未被完全发掘。语言偏好固然是主观的，但我认为Elixir确实在Erlang的基础上有所提升。我有三年多的Erlang生产级编码经验，以及大约一年的Elixir使用经验，我发现Elixir的使用体验更加愉快。结果代码看起来更加紧凑，我可以更专注于我所解决的问题，而不用与过多的噪音和样板代码搏斗。

出于类似的原因，我也喜欢使用EVM。其底层并发机制使得我能够轻松应对高度负载的服务器端系统的复杂性，这种系统必须始终提供服务并执行许多并行任务。

Elixir和EVM都提高了抽象化程度，并帮助我更加轻松地应对复杂问题。因此我总是会支持用Elixir/EVM组合作为构建服务器端系统的首选工具。当然，个人情况可能有所不同（Your mileage may vary）。
