- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:41:10'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Printf Debugging with GDB – Abstract Expression
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://abstractexpr.com/2024/03/03/dynamic-printf-debugging-with-gdb/](https://abstractexpr.com/2024/03/03/dynamic-printf-debugging-with-gdb/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When we debug a program with `printf()` we have to recompile it whenever we
    add new `printf()` statements! Right!?
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Wrong!
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: With gdb we can add `printf()` statements without recompiling a program and
    even add them while it is running.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: Adding Printfs with GDB
  id: totrans-split-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we have the following example program that computes the sum of all
    the elements of an array:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-11
  prefs: []
  type: TYPE_PRE
- en: 'Save this program to `sumarray.c` and compile it with the following command:'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-13
  prefs: []
  type: TYPE_PRE
- en: 'When we run it the output will look like this:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
- en: What if we want to add a debug print before the for loop to print out the number
    of elements in the array, and a debug print inside the loop that prints the current
    loop index and the value of the current array element?
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already compiled our program with debug information we can just open
    it with gdb:'
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the source code within gdb for orientation you can just use
    the list command. Or you can use the enable tui command to get a semi-graphical
    UI where you can see the source code all the time.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: 'We add our first dynamic printf at line 8 to print out the total number of
    elements in the array:'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-20
  prefs: []
  type: TYPE_PRE
- en: 'The first part of the syntax is like adding a breakpoint in gdb. After that,
    there is a comma and a C format string followed by the parameters to the format
    string. Of course, we can print multiple variables at once, as we see when adding
    the second dynamic print:'
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-22
  prefs: []
  type: TYPE_PRE
- en: The debugger has added a breakpoint to our program for each of our dynamic printfs.
    But instead of interrupting the program and dropping us into the debugger those
    breakpoints execute `printf()` with the given format string and parameters and
    continue the program.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run our program from within gdb with:'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should now look similar to that:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-26
  prefs: []
  type: TYPE_PRE
- en: 'If we use the `info break` command to list all breakpoints we will see that
    our dynamic printfs are indeed represented as breakpoints by gdb:'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
- en: To delete a dynamic printf you can use the `delete` command, followed by the
    number of the breakpoint (e.g. `delete 2` to delete the second dynamic print).
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Dynamic Printfs
  id: totrans-split-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When code runs very often (e.g. in a loop) there are situations where you don’t
    want your `printf()` calls to execute every time but only when a variable has
    a certain value or some other special condition is met. Otherwise, there would
    be so much output that it would be very hard to find the relevant lines in all
    of the irrelevant debug output.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: When you add calls to `printf()` to your source code, you can just put the `printf()`
    inside an `if` block and your problem is solved.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: With dprintf you first add your dynamic print. Then you make the resulting breakpoint
    conditional by using the gdb command `condition`.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: 'In our last example, gdb created the breakpoint number 2 for the second dynamic
    printf statement (the one that prints the index and the value in the loop). If
    we wanted to make it print its output only for even loop indexes, we could achieve
    this with the following command:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-35
  prefs: []
  type: TYPE_PRE
- en: 'With this modification, the output of our program will now look like this in
    gdb:'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-37
  prefs: []
  type: TYPE_PRE
- en: Saving and Loading Dynamic Printfs
  id: totrans-split-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since dynamic printfs are breakpoints, we can save them like any other breakpoints
    with the *save breakpoints* command:'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-40
  prefs: []
  type: TYPE_PRE
- en: 'And to load them we can use the *source* command:'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: Printing Discarded Function Return Values
  id: totrans-split-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you want to print the return value of a function. This is easy to
    accomplish if the function’s return value is stored in a variable when it is called.
    But what if the return value is ignored by the code that calls it?
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider this program:'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-45
  prefs: []
  type: TYPE_PRE
- en: Here the function `func()` is called and it returns an int value. But the code
    that calls it ignores this fact and discards the return value.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Save it to a file named `return.c` and compile it with:'
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-48
  prefs: []
  type: TYPE_PRE
- en: 'If we are on an x86-64 machine and we know that the calling convention for
    this architecture mandates that return values (of integer and pointer types) are
    returned in the register `RAX`, this problem is easy to solve. We just put a `dprintf`
    in the line after the function call and print the value of the `RAX` register:'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-split-50
  prefs: []
  type: TYPE_PRE
- en: 'On ARM64 (aka AArch64) we have to print the `x0` register instead:'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-split-52
  prefs: []
  type: TYPE_PRE
- en: When we run the program with
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: 'the output will look similar to this:'
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-split-55
  prefs: []
  type: TYPE_PRE
- en: Custom Printf Function
  id: totrans-split-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using `printf()` to output our debug messages gdb also allows us
    to configure our own custom function to be called for every `dprintf` we add to
    our code.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Such a custom function might look like this:'
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-split-59
  prefs: []
  type: TYPE_PRE
- en: This function returns an `int` and expects a format string and a variable number
    of additional arguments. Therefore, it has the same prototype as `printf()`.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: It first initializes the variable argument list and then calls `vfprintf()`
    (this function is a variant of `fprintf()` that accepts the variable argument
    list in the form of a `va_list` variable) with a `FILE` pointer stored in a global
    variable, the format string, and the variable argument list.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: To use this function we need to open the logfile at the start of the main function.
    We must not put a `dprintf` at any point in the program before the file has been
    opened or we get a segmentation fault due to the global variable `logfile` still
    being `NULL`.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The full code of our modified example program looks like this:'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-split-64
  prefs: []
  type: TYPE_PRE
- en: 'Let’s save this to a file named `custom_printf.c` and compile it with:'
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-split-66
  prefs: []
  type: TYPE_PRE
- en: 'After loading the resulting `custom_printf` program with gdb we first have
    to set the calling style for `dprintf` to `call` (otherwise, gdb uses a builtin
    printf instead of looking it up in our program), and set the function used by
    `dprintf` to our `log_msg` function:'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-split-68
  prefs: []
  type: TYPE_PRE
- en: 'Now we can set our dprintfs with new line numbers:'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-split-70
  prefs: []
  type: TYPE_PRE
- en: Once you execute the program with
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: the output of the `dprintfs` should now appear in the file `logfile.txt` instead
    of on the screen.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-split-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dynamic printf feature of gdb is a very powerful alternative to adding throw-away
    `printf()` statements to your code while debugging. You can add new dynamic printfs
    without recompiling your program, and you can even add additional print statements
    while your program is running.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: The last advantage is especially useful when debugging long-running programs
    like servers. Imagine you add some initial dynamic printfs. Then you start your
    server and send a request. As you learn more and dig deeper into the code you
    add more dynamic printfs from the comfort of your debugger and start a new request
    every time. Once you analyze the output you add more dynamic printfs until you
    find your bug.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: Add to this the feature to save your dynamic printfs to a file for later debugging
    sessions, as well as the ability to print discarded function return values and
    you will see why gdb pushes printf debugging to the next level.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
