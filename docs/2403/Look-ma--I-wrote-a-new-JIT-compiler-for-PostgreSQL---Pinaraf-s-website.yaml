- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: æœªåˆ†ç±»'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: æœªåˆ†ç±»'
- en: 'date: 2024-05-27 15:05:34'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 15:05:34'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Look ma, I wrote a new JIT compiler for PostgreSQL â€“ Pinaraf's website
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: çœ‹å¦ˆï¼Œæˆ‘ä¸º PostgreSQL å†™äº†ä¸€ä¸ªæ–°çš„ JIT ç¼–è¯‘å™¨ â€“ Pinaraf çš„ç½‘ç«™
- en: æ¥æºï¼š[https://www.pinaraf.info/2024/03/look-ma-i-wrote-a-new-jit-compiler-for-postgresql/](https://www.pinaraf.info/2024/03/look-ma-i-wrote-a-new-jit-compiler-for-postgresql/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¥æºï¼š[https://www.pinaraf.info/2024/03/look-ma-i-wrote-a-new-jit-compiler-for-postgresql/](https://www.pinaraf.info/2024/03/look-ma-i-wrote-a-new-jit-compiler-for-postgresql/)
- en: Sometimes, I donâ€™t know why I do things. Itâ€™s one of these times. A few months
    ago, Python 3.13 got its JIT engine, built with a new JIT compiler construction
    methodology (copy-patch, cf. [research paper](https://arxiv.org/pdf/2011.13127.pdf)).
    After reading the paper, I was sold and I just had to try it with PostgreSQL.
    And what a fun ride itâ€™s been so far. This blog post will not cover everything,
    and I prefer other communication methods, but I would like to introduce pg-copyjit,
    the latest and shiniest way to ~~destroy and segfault~~ speed up your PostgreSQL
    server.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œæˆ‘ä¸çŸ¥é“ä¸ºä»€ä¹ˆä¼šå»åšä¸€äº›äº‹æƒ…ã€‚è¿™å°±æ˜¯å…¶ä¸­ä¹‹ä¸€ã€‚å‡ ä¸ªæœˆå‰ï¼ŒPython 3.13 è·å¾—äº†å®ƒçš„ JIT å¼•æ“ï¼Œä½¿ç”¨äº†ä¸€ç§æ–°çš„ JIT ç¼–è¯‘å™¨æ„å»ºæ–¹æ³•ï¼ˆcopy-patchï¼Œå‚è§[ç ”ç©¶è®ºæ–‡](https://arxiv.org/pdf/2011.13127.pdf)ï¼‰ã€‚åœ¨é˜…è¯»äº†è¿™ç¯‡è®ºæ–‡ä¹‹åï¼Œæˆ‘è¢«æ·±æ·±å¸å¼•ï¼Œä¸å¾—ä¸å°è¯•å°†å…¶ä¸
    PostgreSQL ç»“åˆèµ·æ¥ã€‚è¿„ä»Šä¸ºæ­¢ï¼Œè¿™æ˜¯ä¸€æ®µéå¸¸æœ‰è¶£çš„æ—…ç¨‹ã€‚æœ¬åšå®¢æ–‡ç« ä¸ä¼šæ¶µç›–ä¸€åˆ‡ï¼Œæˆ‘æ›´å–œæ¬¢å…¶ä»–æ²Ÿé€šæ–¹å¼ï¼Œä½†æˆ‘æƒ³ä»‹ç»ä¸€ä¸‹ pg-copyjitï¼Œè¿™æ˜¯æœ€æ–°ã€æœ€é—ªäº®çš„æ–¹å¼æ¥~~æ¯ç­å’Œå¯¼è‡´æ®µé”™è¯¯~~åŠ é€Ÿæ‚¨çš„
    PostgreSQL æœåŠ¡å™¨ã€‚
- en: 'Before going any further, a mandatory warning: all code produced here is experimental.
    Please. I want to hear reports from you, like â€œho itâ€™s funâ€, â€œho I got this performance
    boostâ€, â€œhey maybe this could be doneâ€, but not â€œhey, your extension cost me hours
    of downtime on my business critical applicationâ€. Anyway, its current state is
    for professional hackers, I hope you know better than trusting experimental code
    with a production server.'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç»§ç»­ä¹‹å‰ï¼Œæœ‰ä¸€ä¸ªå¼ºåˆ¶æ€§çš„è­¦å‘Šï¼šè¿™é‡Œç”Ÿæˆçš„æ‰€æœ‰ä»£ç éƒ½æ˜¯å®éªŒæ€§çš„ã€‚è¯·ã€‚æˆ‘å¸Œæœ›å¬åˆ°æ‚¨çš„åé¦ˆï¼Œåƒâ€œå“¦ï¼Œè¿™å¤ªæœ‰è¶£äº†â€ï¼Œâ€œå“¦ï¼Œæˆ‘å¾—åˆ°äº†è¿™ä¸ªæ€§èƒ½æå‡â€ï¼Œâ€œå˜¿ï¼Œä¹Ÿè®¸å¯ä»¥è¿™æ ·åšâ€ï¼Œä½†ä¸è¦æ˜¯â€œå˜¿ï¼Œä½ çš„æ‰©å±•è®©æˆ‘çš„ä¸šåŠ¡å…³é”®åº”ç”¨åœæœºäº†å‡ ä¸ªå°æ—¶â€ã€‚æ— è®ºå¦‚ä½•ï¼Œå®ƒå½“å‰çš„çŠ¶æ€é€‚ç”¨äºä¸“ä¸šé»‘å®¢ï¼Œæˆ‘å¸Œæœ›æ‚¨æ¯”ä¿¡ä»»å®éªŒæ€§ä»£ç ç”¨äºç”Ÿäº§æœåŠ¡å™¨æ›´æ‡‚å¾—æ›´å¥½ã€‚
- en: In the beginning, there was no JIT, and then came the LLVM JIT compiler
  id: totrans-split-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: èµ·åˆï¼Œæ²¡æœ‰ JITï¼Œç„¶å LLVM JIT ç¼–è¯‘å™¨è¯ç”Ÿäº†
- en: In a PostgreSQL release a long time ago, in a galaxy far far away, Andres Freund
    introduced the PostgreSQL world to the magics of JIT compilation, using LLVM.
    They married and there was much rejoicing. Alas, darkness there was in the bright
    castle, for LLVM is a very very demanding husband.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¾ˆä¹…ä»¥å‰çš„ä¸€ä¸ª PostgreSQL å‘å¸ƒç‰ˆæœ¬ä¸­ï¼Œåœ¨ä¸€ä¸ªé¥è¿œçš„æ˜Ÿç³»ï¼Œå®‰å¾·çƒˆæ–¯Â·å¼—æ´›ä¼Šå¾·å‘ PostgreSQL ç¤¾åŒºä»‹ç»äº† JIT ç¼–è¯‘çš„é­”åŠ›ï¼Œä½¿ç”¨äº†
    LLVMã€‚å®ƒä»¬ç»“åˆåœ¨ä¸€èµ·ï¼Œå¸¦æ¥äº†å¾ˆå¤šæ¬¢ä¹ã€‚ç„¶è€Œï¼Œè¿™ä¸ªå…‰æ˜çš„åŸå ¡ä¸­æœ‰é»‘æš—å­˜åœ¨ï¼Œå› ä¸º LLVM æ˜¯ä¸€ä¸ªéå¸¸è‹›åˆ»çš„â€œä¸ˆå¤«â€ã€‚
- en: 'LLVM is a great compilation framework. Its optimizer produces very good and
    efficient code, and Andres went further than what anybody else would have thought
    and tried in order to squeeze the last microsecond of performance in his JIT compiler.
    This is a wonderful work and I donâ€™t know how to express my love for the madness
    this kind of dedication to performance is. But LLVM has a big downsideÂ : itâ€™s
    not built for JIT compilation. At least not in the way PostgreSQL will use it:
    the LLVM optimizer is very expensive, but not using it may be worse than no compilation
    at all. And in order to compile only the good stuff, the queries that can enjoy
    the performance boost, the typical query cost estimation is used. And thatâ€™s the
    PostgreSQL downside making the whole thing almost impossible: costs in PostgreSQL
    are not designed to mean anything. They are meant to be compared to each other,
    but do not mean anything regarding the real execution time. A query costing 100Â may
    run in 1 second, while another costing 1000 may run in 100 milliseconds. Itâ€™s
    not a bug, itâ€™s a design decision.Â Thatâ€™s why a lot of people (including me) end
    up turning off the JIT compiler: most if not all queries on my production system
    will not get enough from the performance boost to compensate the LLVM optimizer
    cost. If I can run the query 10ms faster but it needed 50ms to be optimized, itâ€™s
    pure loss.'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: LLVMæ˜¯ä¸€ä¸ªå¾ˆæ£’çš„ç¼–è¯‘æ¡†æ¶ã€‚å®ƒçš„ä¼˜åŒ–å™¨äº§ç”Ÿéå¸¸å‡ºè‰²å’Œé«˜æ•ˆçš„ä»£ç ï¼ŒAndresèµ°å¾—æ¯”ä»»ä½•äººéƒ½æ›´è¿œï¼Œå¹¶ä¸”è¯•å›¾åœ¨ä»–çš„JITç¼–è¯‘å™¨ä¸­æŒ¤å‡ºæ¯ä¸€å¾®ç§’æ€§èƒ½ã€‚è¿™æ˜¯ä¸€ä¸ªäº†ä¸èµ·çš„å·¥ä½œï¼Œæˆ‘ä¸çŸ¥é“å¦‚ä½•è¡¨è¾¾æˆ‘å¯¹è¿™ç§å¯¹æ€§èƒ½æ‰§ç€çš„ç–¯ç‹‚çš„çˆ±ã€‚ä½†æ˜¯LLVMæœ‰ä¸€ä¸ªå¾ˆå¤§çš„ç¼ºç‚¹ï¼šå®ƒå¹¶éä¸ºJITç¼–è¯‘è€Œå»ºç«‹ã€‚è‡³å°‘ä¸æ˜¯åƒPostgreSQLå°†è¦ä½¿ç”¨å®ƒçš„æ–¹å¼ï¼šLLVMä¼˜åŒ–å™¨éå¸¸æ˜‚è´µï¼Œä½†ä¸ä½¿ç”¨å®ƒå¯èƒ½æ¯”æ ¹æœ¬ä¸ç¼–è¯‘æ›´ç³Ÿç³•ã€‚ä¸ºäº†ä»…ç¼–è¯‘å¥½çš„ä¸œè¥¿ï¼Œå¯ä»¥äº«å—æ€§èƒ½æå‡çš„æŸ¥è¯¢ï¼Œä½¿ç”¨å…¸å‹çš„æŸ¥è¯¢æˆæœ¬ä¼°è®¡ã€‚è¿™å°±æ˜¯PostgreSQLçš„ç¼ºç‚¹ï¼Œä½¿æ•´ä¸ªè¿‡ç¨‹å‡ ä¹ä¸å¯èƒ½ï¼šåœ¨PostgreSQLä¸­ï¼Œæˆæœ¬å¹¶ä¸æ˜¯è®¾è®¡ä¸ºå…·æœ‰ä»»ä½•æ„ä¹‰çš„ã€‚å®ƒä»¬æ˜¯ä¸ºäº†ç›¸äº’æ¯”è¾ƒè€Œè®¾è®¡çš„ï¼Œä½†ä¸æ„å‘³ç€ä»»ä½•å…³äºçœŸå®æ‰§è¡Œæ—¶é—´çš„ä¸œè¥¿ã€‚ä¸€ä¸ªæˆæœ¬ä¸º100çš„æŸ¥è¯¢å¯èƒ½åœ¨1ç§’é’Ÿå†…è¿è¡Œï¼Œè€Œå¦ä¸€ä¸ªæˆæœ¬ä¸º1000çš„æŸ¥è¯¢å¯èƒ½åœ¨100æ¯«ç§’å†…è¿è¡Œã€‚è¿™ä¸æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œè¿™æ˜¯ä¸€ä¸ªè®¾è®¡å†³ç­–ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå¾ˆå¤šäººï¼ˆåŒ…æ‹¬æˆ‘åœ¨å†…ï¼‰æœ€ç»ˆå…³é—­äº†JITç¼–è¯‘å™¨çš„åŸå› ï¼šæˆ‘ç”Ÿäº§ç³»ç»Ÿä¸Šçš„å¤§å¤šæ•°ï¼Œå¦‚æœä¸æ˜¯å…¨éƒ¨çš„æŸ¥è¯¢éƒ½æ— æ³•ä»æ€§èƒ½æå‡ä¸­è·å¾—è¶³å¤Ÿçš„è¡¥å¿æ¥æŠµæ¶ˆLLVMä¼˜åŒ–å™¨çš„æˆæœ¬ã€‚å¦‚æœæˆ‘å¯ä»¥è®©æŸ¥è¯¢å¿«10æ¯«ç§’ä½†æ˜¯éœ€è¦50æ¯«ç§’æ¥è¿›è¡Œä¼˜åŒ–ï¼Œé‚£å°±æ˜¯çº¯ç²¹çš„æŸå¤±ã€‚
- en: 'There is one way to make the LLVM JIT compiler more usable, but I fear itâ€™s
    going to take years to be implemented: being able to cache and reuse compiled
    queries. I will not dig further into that topic in this post, but trust me, itâ€™s
    not going to be a small feat to achieve.'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥ä½¿LLVM JITç¼–è¯‘å™¨æ›´åŠ å¯ç”¨ï¼Œä½†æˆ‘æ‹…å¿ƒéœ€è¦å¤šå¹´æ—¶é—´æ¥å®ç°ï¼šèƒ½å¤Ÿç¼“å­˜å’Œé‡å¤ä½¿ç”¨å·²ç¼–è¯‘çš„æŸ¥è¯¢ã€‚æˆ‘ä¸ä¼šåœ¨è¿™ç¯‡æ–‡ç« ä¸­è¿›ä¸€æ­¥æ¢è®¨è¿™ä¸ªè¯é¢˜ï¼Œä½†è¯·ç›¸ä¿¡æˆ‘ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå°å°çš„å£®ä¸¾ã€‚
- en: And in 2021, copy-and-patch was describedâ€¦
  id: totrans-split-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¹¶ä¸”åœ¨2021å¹´ï¼Œå¤åˆ¶å’Œè¡¥ä¸è¢«æè¿°å‡ºæ¥â€¦
- en: So, what can we do?Â We need fast enough code generated the fastest way possible.
    Fast enough code mean at least a bit faster than the current interpreterâ€¦ But
    writing a compiler is painful, writing several code generators (for different
    ISAs for instance) is even worseâ€¦
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œæˆ‘ä»¬èƒ½åšä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬éœ€è¦ä»¥å°½å¯èƒ½æœ€å¿«çš„æ–¹å¼ç”Ÿæˆè¶³å¤Ÿå¿«çš„ä»£ç ã€‚è¶³å¤Ÿå¿«çš„ä»£ç è‡³å°‘æ¯”å½“å‰çš„è§£é‡Šå™¨å¿«ä¸€ç‚¹â€¦ä½†ç¼–å†™ç¼–è¯‘å™¨æ˜¯ç—›è‹¦çš„ï¼Œç¼–å†™å‡ ä¸ªä»£ç ç”Ÿæˆå™¨ï¼ˆä¾‹å¦‚ä¸åŒçš„ISAï¼‰ç”šè‡³æ›´ç³Ÿâ€¦
- en: This is where the innovation of copy-and-patch comes into play and saves the
    day.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯å¤åˆ¶å’Œè¡¥ä¸åˆ›æ–°çš„åœ°æ–¹ï¼Œå¹¶ä¸”æ‹¯æ•‘äº†å½“å¤©ã€‚
- en: With copy-patch, you write stencils in C. These stencils are functions with
    holes, and they are compiled by your typical clang compiler (gcc support pending,
    too complicated to explain here). Then when you want to compile something, you
    stitch stencils together, fill in the gaps, and jump straight into your brand
    new â€œcompiledâ€ function.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å¤åˆ¶å’Œè¡¥ä¸ï¼Œä½ åœ¨Cä¸­ç¼–å†™æ¨¡å…·ã€‚è¿™äº›æ¨¡å…·æ˜¯å¸¦æœ‰ç©ºç™½çš„å‡½æ•°ï¼Œå¹¶ä¸”ç”±ä½ å…¸å‹çš„clangç¼–è¯‘å™¨ï¼ˆgccæ”¯æŒå¾…å®šï¼Œè¿™é‡Œå¤ªå¤æ‚ï¼Œæ— æ³•è§£é‡Šï¼‰ã€‚ç„¶åï¼Œå½“ä½ æƒ³è¦ç¼–è¯‘æŸäº›å†…å®¹æ—¶ï¼Œä½ å°†æ¨¡å…·æ‹¼æ¥åœ¨ä¸€èµ·ï¼Œå¡«å……ç©ºç™½ï¼Œå¹¶ç›´æ¥è·³è½¬åˆ°ä½ å…¨æ–°çš„â€œç¼–è¯‘â€å‡½æ•°ä¸­ã€‚
- en: And this is it. This is the magic of copy-and-patch. You only copy the stencils
    in a new memory area, patch the holes, and voilÃ .
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯å¤åˆ¶å’Œè¡¥ä¸çš„é­”åŠ›ã€‚ä½ åªéœ€å°†æ¨¡å…·å¤åˆ¶åˆ°ä¸€ä¸ªæ–°çš„å†…å­˜åŒºåŸŸï¼Œä¿®è¡¥ç©ºç™½ï¼Œå¹¶å®Œæˆã€‚
- en: Of course, you can go further. You can figure out what computation can be done
    at compilation time, you can split loops in several stencils to unroll them, you
    can merge several stencils together to optimize them in one go (creating kind
    of meta-stencilsâ€¦)
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œä½ å¯ä»¥è¿›ä¸€æ­¥ã€‚ä½ å¯ä»¥å¼„æ¸…æ¥šåœ¨ç¼–è¯‘æ—¶å¯ä»¥è¿›è¡Œå“ªäº›è®¡ç®—ï¼Œå¯ä»¥å°†å¾ªç¯åˆ†æˆå‡ ä¸ªæ¨¡å…·æ¥å±•å¼€å®ƒä»¬ï¼Œå¯ä»¥å°†å‡ ä¸ªæ¨¡å…·åˆå¹¶åœ¨ä¸€èµ·ä»¥ä¸€æ¬¡æ€§ä¼˜åŒ–å®ƒä»¬ï¼ˆåˆ›å»ºä¸€ç§ç±»ä¼¼çš„å…ƒæ¨¡å…·â€¦ï¼‰
- en: This paper caught the eyes of the Faster-CPython team, they implemented it in
    CPython 3.13, and this is when more people (including me) discovered it.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç¯‡è®ºæ–‡å¼•èµ·äº†æ›´å¿«CPythonå›¢é˜Ÿçš„æ³¨æ„ï¼Œä»–ä»¬åœ¨CPython 3.13ä¸­å®ç°äº†å®ƒï¼Œè¿™æ—¶æ›´å¤šçš„äººï¼ˆåŒ…æ‹¬æˆ‘åœ¨å†…ï¼‰å¼€å§‹äº†è§£å®ƒã€‚
- en: Bringing copy-and-patch to PostgreSQL
  id: totrans-split-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å°†å¤åˆ¶å’Œè¡¥ä¸å¸¦åˆ°PostgreSQL
- en: So, what does it take to build a new JIT engine in PostgreSQL? Hopefully, not
    that much, otherwise I would likely not be blogging about this.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: When JIT compilation was introduced, it was suggested on hackers to make LLVM
    a plugin, allowing future extensions to bring other JIT compilers. Back then,
    I was quite skeptical to this idea (but never expressed this opinion, I did not
    want to be wrong later), and it turned out I proved myself wrongâ€¦ The interface
    is really simple, your .so only needs to provide a single _PG_jit_provider_init
    function, and in this function initialize three callbacks, named compile_expr,
    release_context and reset_after_error. The main one is obviously compile_expr.
    You get one ExprState* parameter, a pointer to an expression, made of opcodes.
    Then itâ€™s â€œonlyâ€ a matter of compiling the opcodes together in any way you want,
    mark this built code as executable, and changing the evalfunc to this code instead
    of the PostgreSQL interpreter. This is easy, and you have an automatic fallback
    to the PostgreSQL interpreter if you encounter any opcode youâ€™ve not implemented
    yet.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: The copy and patch algorithm (implemented with only a few small optimizations
    so far) is so easy I can explain it here. For each opcode, the compiler will look
    into the stencil collection. If the opcode has a stencil, the stencil is appended
    to the â€œbuiltâ€ code. Otherwise, the compilation stops and the PostgreSQL interpreter
    will kick in. After appending the stencil, each of its holes are patched with
    the required value.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: For instance, letâ€™s consider this basic unoptimized stencil, for the opcode
    CONST.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: op is declared as extern ExprEvalStep op; (and NEXT_OP is a bit harder to explain,
    I wonâ€™t dig into it here). When building this to a single .o file, the compiler
    will leave a hole in the assembly code, where the address for op will have to
    be inserted (using a relocation). When the stencil collection is built, this information
    is kept and used by the JIT compiler to use the current opcode structure address
    in order to get a working code.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: The build process for the stencils is quite fun, not complicated, but fun. The
    first step is to build the stencils to a single .o file, and then extract the
    assembly code and relocations from this .o file into C usable structures, that
    the JIT compiler will link to.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: And thatâ€™s about all there is.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: At first, I was extracting the assembly code manually. Using that way, I managed
    to get the three needed opcodes for SELECT 42; to work. And there was much joy.
    After this first proof of concept (and I guess some disturbed looks a few days
    ago at PgDay.Paris when people saw me happy with being able to run SELECT 42,
    that may have sound weird), I wrote a DirtyPython (unofficial variant) script
    to automate the assembly code extraction, and in a few hours I implemented function
    calls, single table queries, more complicated data types, introduced a few optimizationsâ€¦
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: Current state
  id: totrans-split-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It works on my computer with PostgreSQL 16\. It should be fine with older releases.
    It only supports AMD64 because thatâ€™s what I have and I can not target everything
    at once. Later I will add ARM64, and I would love to have some time to add support
    for some interesting targets like POWER64 or S390x (these may require some compiler
    patches, sadly, and access to such computers, nudge nudge wink wink)â€¦
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒåœ¨æˆ‘ä½¿ç”¨çš„PostgreSQL 16ç‰ˆæœ¬çš„ç”µè„‘ä¸Šè¿è¡Œè‰¯å¥½ã€‚åœ¨æ—§ç‰ˆä¸Šåº”è¯¥ä¹Ÿå¯ä»¥æ­£å¸¸è¿è¡Œã€‚å®ƒä»…æ”¯æŒAMD64ï¼Œå› ä¸ºè¿™æ˜¯æˆ‘æ‹¥æœ‰çš„ç¡¬ä»¶ï¼Œæˆ‘æ— æ³•ä¸€æ¬¡æ€§æ”¯æŒæ‰€æœ‰å¹³å°ã€‚ç¨åæˆ‘å°†æ·»åŠ å¯¹ARM64çš„æ”¯æŒï¼Œæˆ‘ä¹Ÿå¾ˆæ„¿æ„æœ‰äº›æ—¶é—´æ¥æ”¯æŒä¸€äº›æœ‰è¶£çš„ç›®æ ‡å¹³å°ï¼Œæ¯”å¦‚POWER64æˆ–S390xï¼ˆè¿™äº›å¯èƒ½éœ€è¦ä¸€äº›ç¼–è¯‘å™¨è¡¥ä¸ï¼Œé—æ†¾çš„æ˜¯ï¼Œä»¥åŠè®¿é—®è¿™æ ·çš„è®¡ç®—æœºï¼ŒæŒ æŒ å¤´ï¼Œçœ¨çœ¨çœ¼ï¼‰...
- en: Performance-wise, well, keeping in mind that Iâ€™ve spent almost no time optimizing
    it, the results are great. Code generation is done in a few hundreds microseconds,
    making it usable even for short queries, where LLVM is simply out of the game.
    On a simple SELECT 42; query, running with no JIT takes 0,3ms, with copyjit it
    requires 0,6ms, LLVM with no optimizations goes to 1,6ms and optimizing LLVM will
    require 6,6ms. Sure, LLVM can create really fast code, but the whole idea here
    is to quickly generate fast enough code, and thus comparing both tools wonâ€™t make
    much sense.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: å°±æ€§èƒ½è€Œè¨€ï¼Œè€ƒè™‘åˆ°æˆ‘å‡ ä¹æ²¡æœ‰èŠ±æ—¶é—´å¯¹å…¶è¿›è¡Œä¼˜åŒ–ï¼Œç»“æœéå¸¸å¥½ã€‚ä»£ç ç”Ÿæˆåªéœ€å‡ ç™¾å¾®ç§’ï¼Œä½¿å…¶å³ä½¿å¯¹äºçŸ­æŸ¥è¯¢ä¹Ÿå¯ç”¨ï¼Œè€ŒLLVMåˆ™æ˜¾ç„¶æ— æ³•èƒœä»»ã€‚åœ¨ç®€å•çš„SELECT
    42;æŸ¥è¯¢ä¸­ï¼Œä¸ä½¿ç”¨JITèŠ±è´¹0.3æ¯«ç§’ï¼Œä½¿ç”¨copyjitåˆ™éœ€è¦0.6æ¯«ç§’ï¼ŒLLVMæ— ä¼˜åŒ–åˆ™éœ€è¦1.6æ¯«ç§’ï¼Œä¼˜åŒ–LLVMéœ€è¦6.6æ¯«ç§’ã€‚å½“ç„¶ï¼ŒLLVMå¯ä»¥ç”Ÿæˆéå¸¸å¿«é€Ÿçš„ä»£ç ï¼Œä½†è¿™é‡Œçš„æ•´ä½“æ€æƒ³æ˜¯å¿«é€Ÿç”Ÿæˆè¶³å¤Ÿå¿«çš„ä»£ç ï¼Œå› æ­¤æ¯”è¾ƒè¿™ä¸¤ç§å·¥å…·å¹¶æ²¡æœ‰å¤ªå¤šæ„ä¹‰ã€‚
- en: But still, you are all waiting for a benchmark, so here we go, benchmarking
    two queries on a simple non-indexed 90k rows table. This benchmark is done on
    a laptop and my trust in such a benchmark setup is moderate at best, a proper
    benchmark will be done later on a desktop computer without any kind of thermal
    envelope shenanigans. And I have not optimized my compiler, itâ€™s still quite stupid
    and there is a lot of things that can and must be done.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ï¼Œä½ ä»¬ä»åœ¨ç­‰å¾…åŸºå‡†æµ‹è¯•ï¼Œæ‰€ä»¥æˆ‘ä»¬æ¥çœ‹çœ‹ï¼Œåœ¨ä¸€ä¸ªç®€å•çš„éç´¢å¼•çš„9ä¸‡è¡Œè¡¨ä¸Šå¯¹ä¸¤ä¸ªæŸ¥è¯¢è¿›è¡ŒåŸºå‡†æµ‹è¯•ã€‚è¿™ä¸ªåŸºå‡†æµ‹è¯•æ˜¯åœ¨ç¬”è®°æœ¬ç”µè„‘ä¸Šè¿›è¡Œçš„ï¼Œæˆ‘å¯¹è¿™æ ·çš„åŸºå‡†æµ‹è¯•è®¾ç½®çš„ä¿¡ä»»åº¦æœ€å¤šæ˜¯ä¸­ç­‰ç¨‹åº¦çš„ï¼Œç¨åä¼šåœ¨æ²¡æœ‰ä»»ä½•çƒ­é‡åŒ…å›´éª—å±€çš„å°å¼æœºä¸Šè¿›è¡Œä¸€æ¬¡åˆé€‚çš„åŸºå‡†æµ‹è¯•ã€‚è€Œä¸”æˆ‘çš„ç¼–è¯‘å™¨è¿˜æ²¡æœ‰ä¼˜åŒ–ï¼Œå®ƒä»ç„¶ç›¸å½“æ„šè ¢ï¼Œæœ‰å¾ˆå¤šäº‹æƒ…å¯ä»¥åšï¼Œä¹Ÿå¿…é¡»åšã€‚
- en: '| **Query** | **Min/max (ms)** | **Median (ms) and stdev** |'
  id: totrans-split-33
  prefs: []
  type: TYPE_TB
  zh: '| **æŸ¥è¯¢** | **æœ€å°/æœ€å¤§å€¼ï¼ˆæ¯«ç§’ï¼‰** | **ä¸­ä½æ•°ï¼ˆæ¯«ç§’ï¼‰å’Œæ ‡å‡†åå·®** |'
- en: '| select * from b; â€” no JIT | 10.340/14.046 | 10.652/0.515 |'
  id: totrans-split-34
  prefs: []
  type: TYPE_TB
  zh: '| select * from b; â€” no JIT | 10.340/14.046 | 10.652/0.515 |'
- en: '| select * from b; â€” JIT | 10.326/14.613 | 10.614/0.780 |'
  id: totrans-split-35
  prefs: []
  type: TYPE_TB
  zh: '| select * from b; â€” JIT | 10.326/14.613 | 10.614/0.780 |'
- en: '| select i, j from b where i < 10; â€” no JIT | 3.348/4.070 | 3.7333/0.073 |'
  id: totrans-split-36
  prefs: []
  type: TYPE_TB
  zh: '| select i, j from b where i < 10; â€” no JIT | 3.348/4.070 | 3.7333/0.073 |'
- en: '| select i, j from b where i < 10; â€” JIT | 3.210/4.701 | 3.519/0.107 |'
  id: totrans-split-37
  prefs: []
  type: TYPE_TB
  zh: '| select i, j from b where i < 10; â€” JIT | 3.210/4.701 | 3.519/0.107 |'
- en: Stupid benchmark on a laptop running non-optimized code, donâ€™t trust theseâ€¦
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸€å°è¿è¡Œéä¼˜åŒ–ä»£ç çš„ç¬”è®°æœ¬ä¸Šè¿›è¡Œæ„šè ¢çš„åŸºå‡†æµ‹è¯•ï¼Œä¸è¦è½»ä¿¡è¿™äº›ç»“æœ...
- en: As you can see, even in the current unfinished state, as soon as there is CPU
    work to do (here itâ€™s the where clause), performance relative to the interpreter
    get better. Itâ€™s only logical, and what is important here is that even if the
    JIT is an extra, slightly time consuming step, it takes so little time even these
    queries can go a few percents faster.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æ‚¨æ‰€è§ï¼Œå³ä½¿åœ¨å½“å‰æœªå®Œæˆçš„çŠ¶æ€ä¸‹ï¼Œä¸€æ—¦éœ€è¦CPUå·¥ä½œï¼ˆè¿™é‡Œæ˜¯whereå­å¥ï¼‰ï¼Œç›¸å¯¹äºè§£é‡Šå™¨çš„æ€§èƒ½ä¼šæœ‰æ‰€æå‡ã€‚è¿™æ˜¯å¾ˆåˆä¹é€»è¾‘çš„ï¼Œè€Œé‡è¦çš„æ˜¯ï¼Œå³ä½¿JITæ˜¯é¢å¤–çš„ã€ç¨å¾®è€—æ—¶çš„æ­¥éª¤ï¼Œå®ƒæ‰€èŠ±è´¹çš„æ—¶é—´å¦‚æ­¤ä¹‹å°‘ï¼Œä»¥è‡³äºå³ä½¿è¿™äº›æŸ¥è¯¢å¯ä»¥å¿«å‡ ä¸ªç™¾åˆ†ç‚¹ã€‚
- en: Note that even if Iâ€™ve implemented only a small handful of opcodes, I can run
    any query on my server, the JIT engine will only complain loudly about it and
    let the interpreter run the queryâ€¦
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œå³ä½¿æˆ‘åªå®ç°äº†ä¸€å°éƒ¨åˆ†æ“ä½œç ï¼Œæˆ‘å¯ä»¥åœ¨æˆ‘çš„æœåŠ¡å™¨ä¸Šè¿è¡Œä»»ä½•æŸ¥è¯¢ï¼ŒJITå¼•æ“åªä¼šå¤§å£°æŠ±æ€¨å¹¶è®©è§£é‡Šå™¨è¿è¡ŒæŸ¥è¯¢...
- en: For the more curious, the code is [dumped there on github](https://github.com/pinaraf/pg-copyjit).
    I said dumped because I focus only on the code and not on the clarity of my git
    history nor on wrapping it in a nice paper with flying colors and pretty flowers,
    thatâ€™s what you do when the code is done, this one isnâ€™t yetâ€¦ If you want to build
    it, the build-stencils.sh file must be run manually first. But again, I do not
    document it yet because I simply can not provide any support for the code in its
    current state.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ›´æ„Ÿå…´è¶£çš„äººï¼Œä»£ç å¯ä»¥åœ¨[githubè¿™é‡Œ](https://github.com/pinaraf/pg-copyjit)æ‰¾åˆ°ã€‚æˆ‘è¯´â€œå¯ä»¥æ‰¾åˆ°â€æ˜¯å› ä¸ºæˆ‘åªå…³æ³¨ä»£ç æœ¬èº«ï¼Œè€Œä¸å…³æ³¨gitå†å²çš„æ¸…æ™°åº¦ï¼Œä¹Ÿä¸ä¼šä¸ºå…¶æ·»åŠ æ¼‚äº®çš„å°é¢å’ŒèŠ±å“¨çš„èŠ±æœµï¼Œè¿™äº›æ˜¯åœ¨ä»£ç å®Œæˆååšçš„äº‹æƒ…ï¼Œè€Œè¿™ä¸ªä»£ç ç›®å‰è¿˜æ²¡æœ‰å®Œæˆ...
    å¦‚æœä½ æƒ³æ„å»ºå®ƒï¼Œé¦–å…ˆå¿…é¡»æ‰‹åŠ¨è¿è¡Œbuild-stencils.shæ–‡ä»¶ã€‚ä½†å†æ¬¡å¼ºè°ƒï¼Œæˆ‘è¿˜æ²¡æœ‰ä¸ºæ­¤è¿›è¡Œä»»ä½•æ–‡æ¡£å·¥ä½œï¼Œå› ä¸ºåœ¨ç›®å‰çš„çŠ¶æ€ä¸‹æˆ‘æ ¹æœ¬æ— æ³•ä¸ºè¿™æ®µä»£ç æä¾›ä»»ä½•æ”¯æŒã€‚
- en: TODOâ€¦
  id: totrans-split-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¾…åŠäº‹é¡¹â€¦
- en: This is a proof of concept. Iâ€™ve not worked on making it easy to build, on making
    it possible to package itâ€¦ The build scripts are Debian and PostgreSQL 16 specific.
    And, well, to be honest, at this point, I donâ€™t care much and it will not trouble
    me, my focus is on implementing more opcodes, and searching for optimizations.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæ¦‚å¿µéªŒè¯ã€‚æˆ‘è¿˜æ²¡æœ‰ç€æ‰‹è®©å®ƒæ˜“äºæ„å»ºï¼Œæˆ–è€…è¯´è®©å®ƒå¯ä»¥æ‰“åŒ…â€¦â€¦æ„å»ºè„šæœ¬é’ˆå¯¹çš„æ˜¯Debianå’ŒPostgreSQL 16ã€‚è€Œä¸”ï¼Œè¯´å®è¯ï¼Œç›®å‰æˆ‘å¹¶ä¸å¤ªåœ¨æ„ï¼Œè¿™ä¸ä¼šå›°æ‰°æˆ‘ï¼Œå› ä¸ºæˆ‘çš„é‡ç‚¹æ˜¯å®ç°æ›´å¤šçš„æ“ä½œç ï¼Œå¹¶å¯»æ‰¾ä¼˜åŒ–æ–¹æ³•ã€‚
- en: I really hope I will reach a point where I can safely package this and deploy
    it on my production servers. This way, Iâ€™ll keep using the LLVM JIT on the server
    that can use it (a GIS server where queries are worth the optimization) and use
    this JIT on my web-application databases, where short query time is a must have,
    and the LLVM optimizations end up being counter-productive.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘çœŸçš„å¸Œæœ›èƒ½å¤Ÿè¾¾åˆ°ä¸€ä¸ªå®‰å…¨æ‰“åŒ…å¹¶åœ¨ç”Ÿäº§æœåŠ¡å™¨ä¸Šéƒ¨ç½²å®ƒçš„æ—¶å€™ã€‚è¿™æ ·ï¼Œæˆ‘å°†ç»§ç»­åœ¨å¯ä»¥ä½¿ç”¨LLVM JITçš„æœåŠ¡å™¨ä¸Šä½¿ç”¨å®ƒï¼ˆä¸€ä¸ªGISæœåŠ¡å™¨ï¼ŒæŸ¥è¯¢å€¼å¾—ä¼˜åŒ–ï¼‰ï¼Œå¹¶åœ¨æˆ‘çš„Webåº”ç”¨ç¨‹åºæ•°æ®åº“ä¸Šä½¿ç”¨è¿™ä¸ªJITï¼Œå…¶ä¸­çŸ­æŸ¥è¯¢æ—¶é—´æ˜¯å¿…éœ€çš„ï¼Œè€ŒLLVMä¼˜åŒ–æœ€ç»ˆä¼šé€‚å¾—å…¶åã€‚
- en: I am also dead serious on porting this to other architectures. IÂ love the old
    days of Alpha, Itanium, Sparc, M68k and other different architectures. I am not
    going to use this kind of system, but I miss the diversity, and I really donâ€™t
    want to be a part of the monoculture issue here.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¹Ÿéå¸¸è®¤çœŸåœ°è€ƒè™‘å°†è¿™ä¸ªç§»æ¤åˆ°å…¶ä»–æ¶æ„ä¸Šã€‚æˆ‘çƒ­çˆ±Alphaã€Itaniumã€Sparcã€M68kå’Œå…¶ä»–ä¸åŒçš„æ¶æ„çš„æ—§æ—¥å­ã€‚æˆ‘ä¸æ‰“ç®—ä½¿ç”¨è¿™ç§ç³»ç»Ÿï¼Œä½†æˆ‘æ€€å¿µé‚£ç§å¤šæ ·æ€§ï¼Œæˆ‘çœŸçš„ä¸æƒ³æˆä¸ºè¿™é‡Œå•ä¸€æ–‡åŒ–é—®é¢˜çš„ä¸€éƒ¨åˆ†ã€‚
- en: Thanks
  id: totrans-split-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è°¢è°¢
- en: First, huge thanks to my current day-job employer, Entrâ€™ouvert. We are a small
    french SaaS company, free-software focused, and my colleagues simply let me toy
    on this between tickets and other DBA or sysadmin tasks.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œéå¸¸æ„Ÿè°¢æˆ‘çš„ç°ä»»é›‡ä¸»Entrâ€™ouvertã€‚æˆ‘ä»¬æ˜¯ä¸€å®¶å°å‹æ³•å›½SaaSå…¬å¸ï¼Œä¸“æ³¨äºè‡ªç”±è½¯ä»¶ï¼Œæˆ‘çš„åŒäº‹ä»¬ç®€ç›´è®©æˆ‘åœ¨è§£å†³é—®é¢˜å’Œå…¶ä»–DBAæˆ–ç³»ç»Ÿç®¡ç†å‘˜ä»»åŠ¡ä¹‹é—´å¬‰æˆä¸å·²ã€‚
- en: 'I would like to thank my DBA friends for supporting me and motivating me into
    doing this (wonâ€™t give their names, they know who they are). BTW: use [PoWA](https://powa.readthedocs.io/en/latest/),
    great tool, tell your friendsâ€¦'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æƒ³æ„Ÿè°¢æˆ‘çš„DBAæœ‹å‹ä»¬ï¼Œä»–ä»¬æ”¯æŒæˆ‘ï¼Œå¹¶æ¿€åŠ±æˆ‘å»åšè¿™ä»¶äº‹ï¼ˆä¸ä¼šé€éœ²ä»–ä»¬çš„åå­—ï¼Œä»–ä»¬çŸ¥é“ä»–ä»¬æ˜¯è°ï¼‰ã€‚é¡ºä¾¿è¯´ä¸€å¥ï¼šä½¿ç”¨[Powa](https://powa.readthedocs.io/en/latest/)ï¼Œæ˜¯ä¸ªå¾ˆæ£’çš„å·¥å…·ï¼Œå‘Šè¯‰ä½ çš„æœ‹å‹ä»¬â€¦â€¦
- en: 'Also, quick question: they suggest I shall go to PGConf.dev to show this, but
    itâ€™s too late for the schedule and since I live in France I did not intend to
    go there. If you think itâ€™s important or worth it, please, please, say so (comments
    below, or my email is p@this.domain), otherwise see you in future european PG
    eventsÂ ğŸ™‚'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰ä¸ªå°é—®é¢˜ï¼šä»–ä»¬å»ºè®®æˆ‘å»PGConf.devå±•ç¤ºè¿™ä¸ªï¼Œä½†æ—¶é—´å®‰æ’å·²ç»å¤ªæ™šäº†ï¼Œè€Œä¸”æˆ‘ä½åœ¨æ³•å›½ï¼Œæˆ‘å¹¶æ²¡æœ‰æ‰“ç®—å»é‚£é‡Œã€‚å¦‚æœä½ è®¤ä¸ºè¿™å¾ˆé‡è¦æˆ–è€…å€¼å¾—ï¼Œæ‹œæ‰˜ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼ˆè¯„è®ºä¸‹é¢ï¼Œæˆ–è€…æˆ‘çš„é‚®ç®±æ˜¯p@this.domainï¼‰ï¼Œå¦åˆ™æˆ‘ä»¬åœ¨æœªæ¥çš„æ¬§æ´²PGæ´»åŠ¨è§ğŸ™‚
