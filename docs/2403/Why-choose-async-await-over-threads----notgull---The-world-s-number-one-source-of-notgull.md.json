["```\nfn main() {\n    foo();\n    bar();\n    baz();\n} \n```", "```\nfn main() -> io::Result<()> {\n    let socket = TcpListener::bind(\"0.0.0.0:80\")?;\n\n    loop {\n        let (client, _) = socket.accept()?;\n        handle_client(client)?;\n    }\n} \n```", "```\nfn main() -> io::Result<()> {\n    let socket = TcpListener::bind(\"0.0.0.0:80\")?;\n\n    loop {\n        let (client, _) = socket.accept()?;\n        thread::spawn(move || handle_client(client));\n    }\n} \n```", "```\n#[apply(smol_macros::main!)]\nasync fn main(ex: &smol::Executor) -> io::Result<()> {\n    let socket = TcpListener::bind(\"0.0.0.0:80\").await?;\n\n    loop {\n        let (client, _) = socket.accept().await?;\n        ex.spawn(async move {\n            handle_client(client).await;\n        }).detach();\n    }\n} \n```", "```\nlet (send, recv) = mpsc::channel();\nmy_list.extend(\n    recv.try_iter()\n        .filter(|x| x & 1 == 0)\n        .map(|x| x + 1)\n); \n```", "```\nasync fn handle_client(client: TcpStream) -> io::Result<()> {\n    let mut data = vec![];\n    client.read_to_end(&mut data).await?;\n\n    let response = do_something_with_data(data).await?\n    client.write_all(&response).await?;\n\n    Ok(())\n} \n```", "```\nasync fn handle_client(client: TcpStream) -> io::Result<()> {\n    // Future that handles the actual connection.\n    let driver = async move {\n        let mut data = vec![];\n        client.read_to_end(&mut data).await?;\n\n        let response = do_something_with_data(data).await?\n        client.write_all(&response).await?;\n\n        Ok(())\n    };\n\n    // Future that handles waiting for a timeout.\n    let timeout = async {\n        Timer::after(Duration::from_secs(3)).await;\n\n        // We just hit a timeout! Return an error.\n        Err(io::ErrorKind::TimedOut.into())\n    };\n\n    // Run both in parallel.\n    driver.race(timeout).await\n} \n```", "```\nfn handle_client(client: TcpStream) -> io::Result<()> {\n    let mut data = vec![];\n    client.read_to_end(&mut data)?;\n\n    let response = do_something_with_data(data)?\n    client.write_all(&response)?;\n\n    Ok(())\n} \n```", "```\n// Deadline-aware wrapper around `TcpStream.\nstruct DeadlineStream {\n    tcp: TcpStream,\n    deadline: Instant\n}\n\nimpl DeadlineStream {\n    /// Create a new `DeadlineStream` that expires after some time.\n    fn new(tcp: TcpStream, timeout: Duration) -> Self {\n        Self {\n            tcp,\n            deadline: Instant::now() + timeout,\n        }\n    }\n}\n\nimpl io::Read for DeadlineStream {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // Set the deadline.\n        let time_left = self.deadline.saturating_duration_since(Instant::now());\n        self.tcp.set_read_timeout(Some(time_left))?;\n\n        // Read from the stream.\n        self.tcp.read(buf)\n    }\n}\n\nimpl io::Write for DeadlineStream {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        // Set the deadline.\n        let time_left = self.deadline.saturating_duration_since(Instant::now());\n        self.tcp.set_write_timeout(Some(time_left))?;\n\n        // Read from the stream.\n        self.tcp.write(buf)\n    }\n}\n\n// Create the wrapper.\nlet client = DeadlineStream::new(client, Duration::from_secs(3));\n\nlet mut data = vec![];\nclient.read_to_end(&mut data)?;\n\nlet response = do_something_with_data(data)?\nclient.write_all(&response)?;\n\nOk(()) \n```"]