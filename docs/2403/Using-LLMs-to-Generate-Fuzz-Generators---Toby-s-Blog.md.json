["```\n/** Raw packet format:  * *        +---------+----------+-----+-------------------+ *        |  crc32  | seq_num  | len |       data        | *        +---------+----------+-----+-------------------+ * bytes  0  ...  3  4  ...  7  8  9  10   ...   len+10 */ \n```", "```\nimport random import struct import sys import binascii   # Constants MAX_DATA_LEN = 0xfff PACKET_LEN = MAX_DATA_LEN + 10 CRC_OFFSET = 0 SEQ_NUM_OFFSET = 4 LEN_OFFSET = 8 DATA_OFFSET = 10   # Instructions INSTRUCTION_ADD = ord('a') INSTRUCTION_SUBTRACT = ord('s') INSTRUCTION_READ = ord('r') INSTRUCTION_MULT = ord('m') INSTRUCTION_DIVIDE = ord('d') INSTRUCTION_POP = ord('p') INSTRUCTION_WRITE = ord('w') INSTRUCTIONS = [INSTRUCTION_ADD, INSTRUCTION_SUBTRACT, INSTRUCTION_READ, INSTRUCTION_MULT,  INSTRUCTION_DIVIDE, INSTRUCTION_POP, INSTRUCTION_WRITE]   # Generate packets for _ in range(10000):  # Generate packet data data_len = random.randint(0, MAX_DATA_LEN) data = bytearray(random.randrange(256) for _ in range(data_len)) padding = [random.choice(INSTRUCTIONS + list(range(ord('0'), ord('9') + 1))) for _ in range(MAX_DATA_LEN - data_len)] data += bytes(padding)   # Generate sequence number seq_num = random.getrandbits(32)   # Construct packet packet = bytearray(PACKET_LEN) struct.pack_into(\">I\", packet, CRC_OFFSET, 0)  # Placeholder for CRC32 struct.pack_into(\">I\", packet, SEQ_NUM_OFFSET, seq_num) struct.pack_into(\">H\", packet, LEN_OFFSET, data_len) packet[DATA_OFFSET:] = data   # Calculate CRC32 and update packet crc32 = binascii.crc32(packet[4:]) struct.pack_into(\">I\", packet, CRC_OFFSET, crc32)   # Write packet to stdout sys.stdout.buffer.write(packet) \n```", "```\n # Generate packet data data_len = random.randint(0, MAX_DATA_LEN) data = bytearray(random.randrange(256) for _ in range(data_len)) padding = [random.choice(INSTRUCTIONS + list(range(ord('0'), ord('9') + 1))) for _ in range(MAX_DATA_LEN - data_len)] data += bytes(padding) \n```", "```\n data = [random.choice(INSTRUCTIONS + list(range(ord('0'), ord('9') + 1))) for _ in range(data_len)] padding = bytearray(random.randrange(256) for _ in range(MAX_DATA_LEN - data_len)) \n```", "```\n struct.pack_into(\">H\", packet, LEN_OFFSET, data_len) \n```"]