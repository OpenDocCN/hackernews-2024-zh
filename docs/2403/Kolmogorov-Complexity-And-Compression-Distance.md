<!--yml

类别：未分类

date: 2024-05-29 12:47:51

-->

# 科尔莫戈罗夫复杂性和压缩距离

> 来源：[https://smunshi.net/kolmogorov-complexity-and-compression-distance.html](https://smunshi.net/kolmogorov-complexity-and-compression-distance.html)

2023-09-26

# 科尔莫戈罗夫复杂性和压缩距离

Alice 和 Bob 在 20 次抛硬币的游戏中竞争谁能得到更多的反面。

Alice 得到序列：`HHHTHTHTTHTHHTHTTTTH`，而 Bob 得到序列：`TTTTTTTTTTTTTTTTTTTT`。Alice 对 Bob 的结果感到困惑。她察觉到了不正当操作，并质问了 Bob。Bob 用以下论点为自己辩护：

总共 20 次抛硬币的可能序列数量：\(2^{20}\)

从 \(2^{20}\) 个序列中随机获取序列的概率：\(2^{-20}\)

Bob 声称，由于得到他和 Alice 的序列的概率相同（\(2^{-20}\)），这证明没有不正当操作。Bob 归功于他的运气极好。Alice 聪明，不容易被说服。她通过声称概率在此情境中无法使用来反击 Bob，因为它不揭示获得序列的随机性信息。人们可以快速浏览获得的序列，并轻易指出 Alice 的序列比 Bob 的序列更随机。Alice 需要一种方法来描述字符串/序列的“难以描述”或随机程度。然而，这个论点缺乏数学严谨性。在本文中，我们将用一个称为科尔莫戈罗夫复杂性的数学工具来帮助 Alice。

让我们从描述 Bob 在 Python 中的序列开始，

```
In [0]: 'T'*20
Out[0]: TTTTTTTTTTTTTTTTTTTT 
```

这个 Python 描述的长度为 6（如下所示），少于序列本身的长度。

```
In [1]: len("'T'*20")
Out[1]: 6 
```

如果我们要用 Python 描述 Alice 的序列，那会非常复杂（或者文字），描述可能会等于或更长于 20 个字符。还要记住描述语言也很重要。如果我们用 Javascript 复制 Bob 序列的 Python 描述，我们会得到以下描述：

```
>> "T".repeat(20)
"TTTTTTTTTTTTTTTTTTTT"

>> "\"T\".repeat(20)".length
14 
```

注意到改变描述语言会将描述长度从 6 增加到 14。这告诉我们，一个字符串的复杂性不仅取决于字符串本身，还取决于描述语言。

考虑我们手头的信息，我们可以如下数学地定义科尔莫戈罗夫复杂性：

\[KC(x) = \min \{|d| : L(d) = x\}\]

where，\(L\) 是接受程序 \(d\) 的语言，该程序输出与字符串 \(x\) 相同。我要为了清晰起见而简化数学内容。上述数学表达式将以以下方式包括我们的 Python 和 Javascript 示例：

\[KC(\text{'TTTTTTTTTTTTTTTTTTTT'}) = \\ \min \{|d| : \text{Python}(d) = \text{'TTTTTTTTTTTTTTTTTTTT'}\} = 6 \\ 其中，d \in \{\text{'T'*20}, \text{'TTTTTTTTTTTTTTTTTTTT'}, \text{...}\}\\\] \[KC(\text{'TTTTTTTTTTTTTTTTTTTT'}) = \\ \min \{|d| : \text{Javascript}(d) = \text{'TTTTTTTTTTTTTTTTTTTT'}\} = 14 \\ 其中，d \in \{\text{'T'.repeat(20)}, \text{'TTTTTTTTTTTTTTTTTTTT'}, \text{...}\}\]

* * *

这定义了字符串的 Kolmogorov 复杂性为输出该字符串的最短程序长度。这个想法是，Kolmogorov 复杂性为我们提供了描述字符串随机性的一种方式。如果一个字符串的 Kolmogorov 复杂性等于其长度，那么它比其 Kolmogorov 复杂性小的字符串更随机。此外，如果 $$KC(x) \geq |x|$$ ，则字符串不能被压缩。另外需要注意的是，字符串的 Kolmogorov 复杂性无法计算。不存在一台计算机能够保证所有字符串的 Kolmogorov 复杂性。这不是一个计算问题，而是一个根本上的理论问题。要更好地理解这一点，请看

[有趣的数字悖论](https://en.wikipedia.org/wiki/Interesting_number_paradox)

.

> 有趣的数字悖论围绕这样一个主张：所有自然数都是有趣的。1是第一个数，因此它很有趣。2是第一个偶数。3是第一个奇素数。4之所以有趣，是因为4=2×2和4=2+2。我们可以继续这样做，找到许多数字的有趣属性。在某一点上，我们可能会遇到一些看起来没有有趣属性的数字。我们可以称这个数字为第一个无趣的数字。但这本身就是一个有趣的属性。总之，无趣的数字实际上是有趣的！[[来源](https://nautil.us/kolmogorov-complexity-and-our-search-for-meaning-237158/)]

总结一下，我们永远不能证明我们得到的最短程序确实是最短程序。

## 消除语言依赖性

目前，我们对描述字符串的语言类型有很强的依赖性，并且这并不保证数学表达的一致性。换句话说，我们需要定义一个复杂性，这个定义不会因我们选择的 \(L\) 而改变，只取决于字符串本身。在上述示例中，从Python到Javascript的转换改变了我们的值。那么，我们如何推广这一点，使其与语言无关呢？为了解决这个问题，让我们假设存在一种通用语言 \(U\)，它总是为我们提供所有字符串的最短描述长度。这将意味着，

\[KC_{U}(x) \leq KC_{L}(x) + C\]

换句话说，使用\(U\)相对于使用任意语言\(L\)描述字符串\(x\)的复杂性最多相差一个常数因子，\(C\)。然而，让我们回顾上面讨论的悖论。根据那个悖论，\(U\)无法存在或者\(U\)无法提供比任意\(L\)更短的描述。为了解决这个问题，我们对有效描述语言集合施加限制，允许出现单一的通用描述方法\(U\)。输入图灵机（\(TM\)），这是用于分析算法属性以及确定哪些计算问题可以或不能够可行解决的基本理论概念/计算机/模型。这里需要考虑的几个要点：

+   图灵机模型的停机问题是一种著名的问题，用于确定任意计算机程序的描述和输入，程序是否会停止运行，或者会永远运行 *[[维基百科](https://en.wikipedia.org/wiki/Halting_problem)]*。

+   数学上，停机问题被定义为所有二元组\((TM, w)\)，使得\(w\)是\(TM\)停机的输入之一，其中\(H(TM)\)表示图灵机\(TM\)停机的输入的集合（或者\(\{(TM, w) : w \in H(TM)\}\)）。

+   上述表示意味着，对于图灵机，存在某些输入它会停机，而其他一些输入我们不知道它是否会停机。

+   因此，如果我们将通用语言\(U\)建模为一台我们知道在某些输入上会停机的图灵机，我们可以避免上述解释的悖论！

重申我们的观察，我们可以说对于科尔莫戈洛夫复杂性来说，要实现语言无关性，需要有一个可以模拟图灵机\(TM\)且在每个输入\(w\)上停机并输出\(x\)的通用语言\(U\)。这为我们提供了如下的真正的语言无关定义：

\[KC_{U}(x) = \min \{|(TM, w)| : \text{TM halts on input w and outputs x} \}\]

## 归一化距离

定义了科尔莫戈洛夫复杂性后，我们可以进一步使用它来估计两个字符串/对象的相似性。**标准化信息距离（Normalized Information Distance）**可以定义为：

\[NID(x, y) = \frac{KC(x, y) - \min (KC(x), KC(y))}{\max(KC(x), KC(y))}\]

其中\(KC(x, y)\)是连接\(x\)和\(y\)后的科尔莫戈洛夫复杂性。

然而，**归一化压缩距离（Normalized Compression Distance）**可以定义为：

\[NCD(x, y) = \frac{C(x, y) - \min (C(x), C(y))}{\max(C(x), C(y))}\]

其中\(C(x, y)\)表示连接\(x\)和\(y\)后的压缩长度。

*已经证明\(KC(x)\)，可以通过使用压缩器\(C\)（如gzip）编码\(x\)所需的比特数来合理估计*

* * *

艾丽斯最终能够凭借她新学到的知识智胜鲍勃。✌️
