- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-29 12:40:57'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-29 12:40:57'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Who killed the network switch? - Cliffle
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁杀死了网络交换机？ - Cliffle
- en: 来源：[https://cliffle.com/blog/who-killed-the-network-switch/](https://cliffle.com/blog/who-killed-the-network-switch/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://cliffle.com/blog/who-killed-the-network-switch/](https://cliffle.com/blog/who-killed-the-network-switch/)
- en: Who killed the network switch?
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁杀死了网络交换机？
- en: A Hubris Bug Story
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Hubris Bug的故事
- en: '2024-03-24'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: '2024-03-24'
- en: We found a neat bug in [Hubris](https://hubris.oxide.computer/) this week. Like
    many bugs, it wasn’t a bug when it was originally written — correct code *became*
    a bug as other things changed around it.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本周在[傲慢](https://hubris.oxide.computer/)中发现了一个很棒的bug。像许多bug一样，当它最初编写时并不是一个bug
    —— 随着其周围环境的改变，正确的代码*变成了*一个bug。
- en: I thought the bug itself, and the process of finding and fixing it, provided
    an interesting window into our development process around Hubris. It’s very rare
    for us to find a bug in the Hubris kernel, mostly because it’s so small. So I
    jumped at the opportunity to write this one down.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这个bug本身以及找到和修复它的过程为我们围绕Hubris的开发过程提供了一个有趣的窗口。在Hubris内核中找到bug对我们来说非常罕见，主要是因为它非常小。因此，我抓住了机会把它写下来。
- en: This is a tale of how two features, each useful on its own, can combine to become
    a bug. Read on for details.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个讲述两个本来各自有用的功能如何结合成为一个bug的故事。继续阅读了解详情。
- en: '## What’s a Hubris?'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: '## 什么是Hubris？'
- en: Hubris is an operating system designed for deeply embedded systems — all the
    computers that you don’t think of as “computers,” like the one inside a keyboard.
    We wrote it to handle all the tasks required to start up the *big* processors
    — the part you *do* think of as “computers” — in the Oxide Rack.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: Hubris是专为深度嵌入式系统设计的操作系统 —— 所有你不认为是“计算机”的计算机，比如键盘内部的计算机。我们设计它来处理启动Oxide机架中的*大*处理器所需的所有任务。
- en: Hubris is pretty weird. I’ll explain the bits of that are relevant to this story
    below. If you’d like more background, I recommend reading either
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: Hubris相当奇怪。我将在下面解释与这个故事相关的部分。如果您想了解更多背景信息，我建议阅读以下内容之一
- en: The scene of the crime
  id: totrans-split-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 犯罪现场
- en: Like any good murder mystery, let’s start with the victim.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何一部好的侦探小说，让我们从受害者开始。
- en: My colleague Arjen Roodselaar is largely responsible for the firmware that runs
    on our network switches at Oxide. He was testing a change he’d made to power sequencing
    and clock configuration — the very important bits that are responsible for turning
    everything else on. After a seemingly innocuous change, suddenly, the switch wouldn’t
    power on.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我的同事Arjen Roodselaar主要负责在Oxide的网络交换机上运行的固件。他在测试他对电源顺序和时钟配置所做的更改时 —— 这些非常重要的部分负责开启其他所有设备。在一次看似无害的更改后，突然间，交换机无法启动。
- en: Curiously, *parts of the firmware* would respond to inquiries, but the really
    important part — the power supply sequencer — seemed to be dead in its tracks.
    Without power, the network switch was just a rather large, very heavy paperweight.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，*固件的某些部分*会响应查询，但真正重要的部分 —— 电源供应顺序控制器 —— 似乎已经无法运行。没有电源，网络交换机只是一个相当大且非常沉重的纸砖。
- en: Messing up power sequencing can literally fry the hardware. Was the switch dead
    or merely unresponsive? And how did an apparently unrelated code change, to a
    different part of the system, kill power sequencing?
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: 搞乱电源顺序可能会彻底损坏硬件。交换机是死了还是只是不响应？那么，一个显然与系统的其他部分无关的代码更改是如何导致电源顺序问题的？
- en: A mystery!
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个谜！
- en: Alright, with that stage set, let’s flash-back to talk about a couple of Hubris
    design details.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，舞台已经设定好了，现在让我们回溯一下，谈一谈Hubris设计的一些细节。
- en: Squeezing more out of limited RAM
  id: totrans-split-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在有限RAM中挤出更多内容
- en: On the relatively inexpensive microcontrollers we use with Hubris, one of the
    challenges is that RAM (and flash, for storing code) is quite limited. For instance,
    we have an internal board that serves as a useful I2C debugging probe and has
    8 kiB of RAM and 32 kiB of flash. The system you’re reading this on, even if it’s
    an inexpensive phone, might have a million times that.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用Hubris的相对廉价的微控制器上，挑战之一是RAM（以及用于存储代码的flash）非常有限。例如，我们有一个内部板子，作为一个有用的I2C调试探针，并拥有8
    kiB的RAM和32 kiB的flash。而您当前使用的系统，即使是一部廉价的手机，可能有百万倍的资源。
- en: Hubris faces this challenge a bit more than other operating systems in our niche,
    because firmware using Hubris is built out of many separately-compiled programs
    called *tasks.* Each task gets its own copy of everything it needs, including
    common standard library code. This means our systems tend to have somewhat higher
    resource requirements than others (though not by as much as you might expect —
    this will be the topic of another post).
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: Hubris 在我们这个小众操作系统中面临的挑战比其他更多一些，因为使用 Hubris 的固件由许多单独编译的程序（称为*任务*）组成。每个任务都有其自己所需的所有内容，包括通用的标准库代码。这意味着我们的系统倾向于具有比其他系统更高的资源需求（尽管并不多到你可能期望的程度
    —— 这将是另一篇文章的主题）。
- en: We isolate tasks from each other using the hardware memory protection unit,
    which keeps them from crashing or corrupting each other. This adds some pressure
    on our RAM and flash requirements, though. In the ARM microcontrollers that we
    mostly use to run Hubris — the older members of the Cortex-M family, aka the ARMv7-M
    architecture — any protected region of memory has to be a *power of two* in size,
    and aligned according to its size. This means if you have a region that is currently
    1024 bytes, and you need one more byte, you can’t just grow it to 1025 — it is
    now 2048 bytes whether you like it or not.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用硬件内存保护单元将任务彼此隔离，以防止它们相互崩溃或损坏。尽管如此，这也给我们的 RAM 和闪存需求增加了一些压力。在我们主要使用的 ARM 微控制器上运行
    Hubris —— Cortex-M 家族的较老成员，也就是 ARMv7-M 架构 —— 任何受保护的内存区域都必须是*二的幂*大小，并根据其大小对齐。这意味着如果你当前有一个大小为
    1024 字节的区域，而你需要一个额外的字节，你不能简单地将它增长到 1025 字节 —— 不管你喜不喜欢，它现在是 2048 字节。
- en: Originally, Hubris used one memory protection region for a task’s RAM, and one
    for its flash. Simple, but wasteful. This encouraged [fragmentation](https://en.wikipedia.org/wiki/Fragmentation_(computing)),
    which in practice meant that there was often unused RAM and flash left between
    tasks that didn’t quite line up. That unused memory was basically wasted. This
    is really frustrating when you don’t have enough of it to begin with!
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Hubris 使用一个内存保护区域来存放任务的 RAM，另一个用于存放其闪存。简单，但浪费。这鼓励了[碎片化](https://zh.wikipedia.org/wiki/%E7%A2%8E%E7%89%87%E5%8C%96_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))，实际上意味着通常存在未使用的
    RAM 和闪存，它们之间的对齐并不完美。这些未使用的内存基本上是浪费的。当你一开始就不够用的时候，这真的很令人沮丧！
- en: 'My colleague [Matt Keeter](https://www.mattkeeter.com/blog/) fixed this recently
    by making the system smarter: it now attempts to pack tasks using multiple power-of-two
    regions where possible. (“Where possible” is important, because the hardware limits
    each task to no more than eight regions, total.) In some of our firmware images,
    this recovered 30% of RAM! Our smallest devices went from being so crammed full
    that I regularly had to make optimization passes over the code, to having free
    space to spare.'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我的同事 [Matt Keeter](https://www.mattkeeter.com/blog/) 最近通过使系统更智能来解决了这个问题：现在它尝试使用多个二次幂区域来打包任务。("在可能的情况下"很重要，因为硬件限制每个任务总共不能超过八个区域。)
    在我们的一些固件镜像中，这节省了 30% 的 RAM！我们最小的设备从以前几乎被挤满了以至于我经常需要对代码进行优化，变成了有多余空间可用。
- en: 'This is incredibly awesome, and he’s written [an entire post about it](https://www.mattkeeter.com/blog/2024-03-25-packing/).
    But how is it relevant? I’ll explain in a bit. But first:'
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这太令人兴奋了，他已经写了[一篇完整的文章](https://www.mattkeeter.com/blog/2024-03-25-packing/)讲解这个。但这与我们的主题有什么关系？我马上会解释。但首先：
- en: The smoking gun
  id: totrans-split-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键线索
- en: Arjen reached for Humility, our debugger for Hubris, and gently probed the failed
    network switch. The service processor responsible for power sequencing appeared
    to be alive and running, so a hardware problem was unlikely.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: Arjen 拿起了谦卑（[Humility](https://www.example.org/humility)），我们的 Hubris 调试器，轻轻探查了失败的网络开关。负责电源顺序的服务处理器看起来是活跃且运行良好，所以硬件问题不太可能。
- en: 'One of the first commands we tend to reach for to learn about the state of
    a running Hubris system is `humility tasks`. This prints a list of tasks running
    on the processor, as well as information about their status. When Arjen ran `humility
    tasks`, one line in particular jumped out: the `sequencer` task, which is the
    component responsible for power sequencing, had the following status:'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要了解运行中的 Hubris 系统状态时，我们通常会首先使用的命令是 `humility tasks`。这会打印出在处理器上运行的任务列表，以及它们的状态信息。当
    Arjen 运行 `humility tasks` 时，特别引人注目的是 `sequencer` 任务的一行，这个任务负责电源顺序，状态如下：
- en: '[PRE0]'
  id: totrans-split-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The task also indicated that it had been restarted 115 times. Since we pretty
    much only restart tasks in response to crashes, that suggested that this fault
    — whatever it was! — was occurring every time the sequencer tried to power the
    system on.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务还表明，它已经重新启动了115次。由于我们几乎只在任务崩溃时重新启动它们，这表明这个故障 — 无论是什么！ — 每次时序器试图启动系统时都会发生。
- en: So the task was getting killed. But who pulled the trigger?
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任务被杀死了。但是是谁扣动了扳机？
- en: The answer involves an important aspect of Hubris IPC.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 答案涉及Hubris IPC的一个重要方面。
- en: Extending Rust borrows across tasks in Hubris IPC
  id: totrans-split-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Hubris IPC中跨任务扩展Rust借用
- en: 'Hubris tasks can communicate with each other using *messages* in an Inter-Process
    Communication scheme, or IPC. Each message looks and behaves very much like a
    function call: the task sending the message stops, the task receiving it takes
    control of the CPU, and eventually returns some result that causes the sender
    to wake back up.'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: Hubris任务可以使用*消息*在进程间通信方案或IPC中相互通信。每个消息看起来和行为都非常像一个函数调用：发送消息的任务停止，接收它的任务控制CPU，并最终返回一些结果，导致发送方重新唤醒。
- en: We chose this scheme for a bunch of reasons — there are, after all, many other
    options! — but one of the most useful ones is that it plays nicely with Rust’s
    resources ownership model. Just as a function can loan some memory it controls
    to a function it calls, and reliably get ownership back when the function returns,
    a task on Hubris can loan some of its memory to another task along with an IPC
    message.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择这个方案有很多原因 — 毕竟，还有很多其他选择！ — 但其中一个最有用的原因之一是它与Rust的资源所有权模型非常兼容。正如一个函数可以向其调用的函数借用一些它控制的内存，并在函数返回时可靠地收回所有权一样，Hubris上的任务可以向另一个任务借用一些其内存以及一个IPC消息。
- en: This feature is very widely used in Hubris-based firmware. For example, tasks
    that want to interact with an I2C device loan sections of their memory to the
    I2C bus driver, which then reads and/or writes them in-place. This keeps the bus
    driver itself from needing to have a buffer pool or similar resource internally,
    and reduces the number of copies needed to move data from place to place.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在基于Hubris的固件中被广泛使用。例如，希望与I2C设备交互的任务将它们的内存部分借给I2C总线驱动程序，然后在原地读取和/或写入它们。这样一来，总线驱动程序本身就不需要内部的缓冲池或类似的资源，并且减少了数据从一个地方移动到另一个地方所需的复制次数。
- en: It’s also a potential security hole if implemented incorrectly. Much of Hubris’s
    reliability comes from the *isolation* of tasks; tasks don’t share any memory,
    so one task can do arbitrarily silly things in its own space without hurting any
    other tasks. So it’s very important that loaning memory via IPC doesn’t let tasks
    break out of their isolated containers.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现不正确，这也是潜在的安全漏洞。Hubris的可靠性很大程度上来自于任务的*隔离*；任务不共享任何内存，因此一个任务可以在其自己的空间中做任意愚蠢的事情而不会伤害其他任务。因此，通过IPC借用内存不会让任务突破其隔离的容器是非常重要的。
- en: And so, attempting to loan memory that you don’t actually *own* is bad. Specifically,
    it’s forbidden by the Hubris kernel.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，试图借用实际上*不拥有*的内存是不好的。具体来说，Hubris内核禁止这样做。
- en: If a caller attempts to loan memory it can’t access to a server, once this is
    discovered, the server is handed an apologetic error code by the kernel, while
    the client receives a fault. To the server, this is never fatal; to the client,
    it is *always fatal.* We assume that the access violation indicates a bug, corruption,
    or exploit in the sending task, so we immediately shut it down without giving
    it an opportunity to respond.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用者试图向服务器借用它无法访问的内存，一旦发现这一点，内核会向服务器提供一个道歉性错误代码，而客户端会收到一个故障。对服务器来说，这永远不是致命的；对客户端来说，这总是致命的。我们假设访问违规表明发送任务中存在错误、损坏或利用漏洞，因此我们立即关闭它，而不给它回应的机会。
- en: 'When the kernel does this, it records information about the triggering event,
    which (when formatted for human consumption) produces a status like the one Arjen
    found on the sequencer task. Let’s take it apart:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核执行此操作时，它会记录有关触发事件的信息，这（当格式化为人类可读格式时）产生了类似Arjen在时序器任务上找到的状态。让我们来详细看看：
- en: '[PRE1]'
  id: totrans-split-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This says:'
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: '`mem fault`, because the task was faulted for incorrect handling of memory;'
  id: totrans-split-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem fault`，因为任务由于错误处理内存而出现故障；'
- en: '`precise`, because we can tell the specific address that was handled incorrectly;'
  id: totrans-split-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precise`，因为我们可以确定处理错误的具体地址；'
- en: '`in syscall`, because the task wasn’t actually *running* when the fault occurred;
    and'
  id: totrans-split-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in syscall`，因为在发生故障时任务实际上并未*运行*；'
- en: '`was: wait: reply from i2c_driver/gen0`, because at the time the fault occurred,
    instead of running, the task was waiting for a reply from a message it sent to
    the I2C driver. We always try to record the task state *just before* the fault
    happened to help with debugging.'
  id: totrans-split-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`was: wait: reply from i2c_driver/gen0`，因为在故障发生时，任务不是在运行，而是在等待来自其发送给I2C驱动程序的消息的回复。我们总是尝试记录故障发生*之前*的任务状态，以帮助调试。'
- en: (If you’re curious, the `gen0` means the `i2c_driver` is on generation 0, which
    means it hasn’t ever crashed. `sequencer` was on generation 115!)
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: （如果您感兴趣，`gen0`表示`i2c_driver`位于第0代，这意味着它从未崩溃过。`sequencer`位于第115代！）
- en: The kernel distinguishes between *real* and *synthetic* faults. A real fault
    happens when a task does something simple and wrong, such as dereferencing a null
    pointer, or trying to write to its code region. Real faults are generated by the
    hardware (in this case, the memory protection unit) in response to actions performed
    by a task. As a result, they can only happen when the task is actually running
    and doing something wrong.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 内核区分*真实*故障和*合成*故障。真实故障发生在任务做了简单且错误的事情时，比如解引用空指针，或者试图写入其代码区域。真实故障由硬件（在本例中是内存保护单元）响应任务执行的操作而生成。因此，它们只能在任务实际运行并执行错误操作时发生。
- en: Rather than *hardware* rules, synthetic faults represent violations of *software*
    rules. The processor has no concept of “IPC” or “loaning memory across tasks,”
    those are ideas that Hubris added to the system. They have their own rules, and
    if a task violates them, we treat it just like a null pointer dereference or other
    “real” hardware fault — just with a different set of fault information that marks
    it as synthetic.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与*硬件*规则不同，合成故障表示*软件*规则的违反。处理器没有“IPC”或“跨任务借用内存”的概念，这些都是Hubris添加到系统中的概念。它们有自己的规则，如果任务违反了这些规则，我们将其视为空指针解引用或其他“真实”硬件故障
    — 只是使用了标记它为合成故障的不同故障信息集。
- en: 'So, from this rather dense status report, we have learned the following:'
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从这份相当密集的状态报告中，我们学到了以下几点：
- en: The `sequencer` task broke the kernel’s rules for memory access.
  id: totrans-split-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sequencer`任务违反了内核对内存访问的规则。'
- en: It did so at the address `0x801bffd`, which is an unusual but valid address
    in flash for the processor.
  id: totrans-split-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在地址`0x801bffd`处执行了此操作，这是处理器中闪存中的一个不寻常但有效的地址。
- en: It did so as part of an IPC sent to the I2C driver.
  id: totrans-split-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是作为发送给I2C驱动程序的IPC的一部分做的。
- en: This seems really bad! Memory access violations usually indicate a very serious
    program bug or data corruption. The fact that one was happening in the sequencer
    task, despite that task not having changed much recently, suggested that we had
    some kind of long-hidden data corruption bug!
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来真的很糟糕！内存访问违规通常表示非常严重的程序错误或数据损坏。尽管这个任务最近没有做过太多更改，但在序列控制器任务中发生了这种情况，这表明我们可能存在某种长期隐藏的数据损坏
    bug！
- en: This would be very unusual — since our firmware is almost entirely safe Rust,
    data corruption bugs are incredibly rare in our systems. But all signs point to
    data corruption here.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是非常不寻常的 — 因为我们的固件几乎完全是安全的Rust，数据损坏 bug 在我们的系统中极其罕见。但所有迹象都指向这里存在数据损坏。
- en: …or do they?
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: …或者它们？
- en: When features attack
  id: totrans-split-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当特性攻击
- en: The address reported for the memory violation was `0x801bffd`.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的内存违规地址是`0x801bffd`。
- en: When Arjen called me in for assistance, this immediately looked weird. It’s
    a valid flash address, sure, but it’s three bytes below a power of two boundary.
    We knew this wasn’t a result of an accidental integer overflow in an address computation,
    because Hubris systems enable runtime integer overflow checks — the task would
    have crashed and reported the problem.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当阿尔杰为了帮助我而叫我过去时，这看起来很奇怪。这是一个有效的闪存地址，没错，但它比一个2的幂次方边界低三个字节。我们知道这不是地址计算中意外整数溢出的结果，因为Hubris系统启用了运行时整数溢出检查
    — 任务会崩溃并报告问题。
- en: And that’s when I remembered Matt’s packing change.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这时，我想起了马特的打包更改。
- en: Recall that the MPU on our processor requires memory regions to be power-of-two
    sized and aligned. I used `humility mem` to print the image’s memory layout, and
    sure enough, there was a region ending at `0x801c000`, and another one starting
    at the same address.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请回忆，我们处理器上的MPU要求内存区域大小为2的幂次方并且对齐。我使用`humility mem`打印了镜像的内存布局，果然，在`0x801c000`结束了一个区域，并且在同一地址开始了另一个区域。
- en: And they both belonged to the *same task.*
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都属于*同一个任务*。
- en: '[PRE2]'
  id: totrans-split-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is perfectly fine, except when it’s not.
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很好，除非它不好。
- en: The memory access permission checking code is one of the most security-critical
    parts of the Hubris kernel. We try to keep the most important code as simple as
    possible. As I mentioned above, early in Hubris’s life — which was when I wrote
    this part of the kernel — tasks had a single region for RAM and a single region
    for Flash, and that’s that.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 访问权限检查代码是Hubris内核中最重要的安全关键部分之一。我们尽量保持最重要的代码尽可能简单。正如我在上面提到的，Hubris早期 —— 就是我编写内核这部分时
    —— 任务有一个用于RAM和一个用于Flash的单一区域，就是这样。
- en: 'And I simplified the kernel checking code to reflect that. It was:'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我简化了内核检查代码以反映这一点。它是：
- en: '[PRE3]'
  id: totrans-split-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An access was permitted if, and only if, there was any single region in the
    task’s region table that
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 访问只有在任务的区域表中存在任何单一区域时才被允许。
- en: Completely covered the slice of memory being loaned,
  id: totrans-split-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全覆盖了被借出的内存片段，
- en: Had all the required attributes (e.g. it was writable if the IPC said it should
    be writable), and
  id: totrans-split-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具备了所有所需的属性（例如，如果IPC要求可写，则该内存是可写的），以及
- en: Did not have any “forbidden” attributes, like containing memory-mapped registers
    or being used for hardware DMA. (Such memory cannot currently be loaned, for subtle
    reasons that are out of scope for this post.)
  id: totrans-split-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有任何“禁止”属性，比如包含内存映射寄存器或用于硬件DMA。 (这种内存目前不能被借出，原因微妙，超出本文的范围。)
- en: At the time that code was written, it was correct, but it embodied the assumption
    that any loaned memory would fit into *one* region.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写那段代码时，它是正确的，但它体现了一个假设，即任何借出的内存都能适合*一个*区域。
- en: That assumption became obsolete the moment that Matt implemented task packing,
    but we didn’t notice. This code, which was still simple and easy to read, was
    now also *wrong.*
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当Matt实施任务打包时，这种假设立即变得过时，但我们没有注意到。这段代码仍然简单易读，但现在也*是错误的*。
- en: Critically, this code is only used to check loaned memory. Normal accesses from
    a running program are checked by the hardware memory protection unit directly,
    and the hardware doesn’t have this bug. This means the task probably had no trouble
    at all accessing memory across this region boundary… until it tried to loan it
    out.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，此代码仅用于检查借出的内存。运行程序的正常访问直接由硬件内存保护单元检查，而硬件没有这个漏洞。这意味着任务可能根本没有任何问题访问跨越此区域边界的内存…直到它尝试借出它。
- en: How two innocent features conspired to kill the network switch
  id: totrans-split-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两个无辜的特性如何合谋杀死网络交换机
- en: Task packing in our build system operates *opportunistically.* Because the MPU
    hardware limits each task to no more than 8 regions, and because many tasks represent
    hardware drivers that have various memory-mapped registers accessible through
    some of those regions, we don’t always have enough region slots left over in the
    8-region table to be clever about task layout.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构建系统中，任务打包操作*机会主义*。因为MPU硬件限制每个任务最多8个区域，并且因为许多任务代表硬件驱动程序，其中一些驱动可以通过其中一些区域访问各种内存映射寄存器，我们并不总是有足够的8个区域表中的剩余区域槽位来聪明地布局任务。
- en: But whenever we *can*, we attempt to pack the tasks using multiple regions.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但每当我们*可以*时，我们尝试使用多个区域来打包任务。
- en: The net effect of this is that region boundaries are now being introduced in
    the middle of task flash and RAM regions. Critically, they’re appearing at places
    that are *very difficult for the author of the task itself to predict.* The layout
    of tasks in memory, and the places where those boundaries fall, depend on the
    size required for each task.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这的净效果是现在在任务Flash和RAM区域的中间引入了区域边界。关键是，它们出现在*任务作者自身难以预测的地方*。内存中任务的布局以及边界位置的出现，取决于每个任务所需的大小。
- en: This means an apparently innocuous change in task A, if it changes task A’s
    size very slightly, can now move the positions of MPU region boundaries in unrelated
    task B.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果任务A中一个明显无害的变更，稍微改变了任务A的大小，现在可能会移动MPU区域边界在不相关的任务B中的位置。
- en: It was now pretty clear that this behavior was bad. Apparently random crashes
    that go away when you add some debugging code are the *worst kind* of crash, but
    that was the situation we were in — since adding any code to the system would
    shift the allocation decisions and the region boundaries, potentially angering
    the kernel.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显，这种行为是有问题的。显然，当你添加一些调试代码时，偶发的崩溃就会消失，这是*最糟糕的一种*崩溃，但这正是我们面对的情况 —— 因为向系统添加任何代码都会改变分配决策和区域边界，潜在地激怒内核。
- en: Matt immediately switched off the task packing feature in the build system,
    which let Arjen build a working firmware image and continue with his network switch
    hacking. Meanwhile, I [started writing up my analysis on a bug report](https://github.com/oxidecomputer/hubris/issues/1672),
    and prepared to face this murderer I had accidentally created four years earlier.
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: Matt立即关闭了构建系统中的任务打包功能，使得Arjen可以构建出一个工作的固件镜像，并继续他的网络交换机黑客活动。同时，我[开始撰写关于一个缺陷报告的分析](https://github.com/oxidecomputer/hubris/issues/1672)，并准备面对我四年前无意中创造的这个杀手。
- en: The call is coming from inside the house!
  id: totrans-split-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 呼叫是从屋内发出的！
- en: Since the kernel was now killing tasks in a misguided attempt to enforce memory
    protection, the memory protection algorithm needed to change. A previously appealing
    *simplification* was now an *over-simplification.*
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内核现在正试图通过误导的方式来执行内存保护，因此内存保护算法需要更改。以前吸引人的*简化*现在成了*过度简化*。
- en: 'The basic *intent* of the algorithm remained the same as when I originally
    wrote it in 2020:'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的基本*意图*，自我在2020年最初编写时保持不变：
- en: Let tasks specify sections of memory they want to loan with a message.
  id: totrans-split-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让任务通过消息指定它们想要借用的内存段。
- en: Require that the task *actually has* the access to that memory that it claims.
    For instance, if it’s attempting to loan some memory writable, it had better be
    able to write the memory itself! Otherwise, the mechanism could let tasks gain
    powers they aren’t supposed to have.
  id: totrans-split-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要求任务*确实具有*它声称拥有的那些内存的访问权限。例如，如果尝试借用一些可写内存，它最好能够自己写入内存！否则，机制可能会让任务获取它们不应该具有的权限。
- en: The only thing that’s different is that we now need to tolerate the loaned memory
    crossing MPU regions, as long as those regions are exactly adjacent.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不同的是，现在我们需要容忍借用的内存跨越MPU区域，只要这些区域正好相邻。
- en: 'The [replacement algorithm](https://github.com/oxidecomputer/hubris/blob/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6/sys/kerncore/src/lib.rs#L103)
    is significantly more complex than the original, because it’s taking pains to
    perform a single pass over the region table. We try really hard in Hubris to not
    expose operations that have *task-controlled time complexity.* We’re not perfect
    at it, but we try. So it was important to me that the algorithm’s performance
    depend only on the size of the *region table* — fixed at 8 — rather than the amount
    of memory being loaned. It’s possible to do this in a single pass if you know
    in advance that the table is in sorted address order; I altered the build system
    to ensure that this was always true. You can read [the commit](https://github.com/oxidecomputer/hubris/commit/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6#diff-0270185909262248f95c960a9fdd6074669172623c61f59781ee47b50ddc9c69R156)
    if you want the gritty details, but the important bit was:'
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[替代算法](https://github.com/oxidecomputer/hubris/blob/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6/sys/kerncore/src/lib.rs#L103)比原来复杂得多，因为它努力在区域表上执行单次遍历。在Hubris中，我们努力不暴露*由任务控制的时间复杂度*的操作。我们做得不完美，但我们努力。因此，对我来说，算法的性能仅取决于*区域表*的大小
    —— 固定为8 —— 而不是被借用内存的数量。如果您事先知道表按排序地址顺序排列，可以在一次遍历中完成此操作；我修改了构建系统以确保这一点始终成立。如果您想要详细了解，可以阅读[提交记录](https://github.com/oxidecomputer/hubris/commit/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6#diff-0270185909262248f95c960a9fdd6074669172623c61f59781ee47b50ddc9c69R156)，但重要的是：'
- en: '[PRE4]'
  id: totrans-split-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: …added to the kernel’s `build.rs` file.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: …添加到内核的`build.rs`文件中。
- en: Because the new algorithm is much more complex, my colleague [Eliza Weissman](https://elizas.website/)
    nudged me into factoring it out of the core Hubris kernel, and into a [more portable
    crate](https://github.com/oxidecomputer/hubris/tree/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6/sys/kerncore)
    where it can be more easily unit-tested. It currently has unit tests for the corner
    cases we’re most concerned about; we plan to add a few more, in the words of Kent
    Beck, “until fear turns to boredom.”
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为新算法更复杂，我的同事[Eliza Weissman](https://elizas.website/)推动我将其从核心Hubris内核中分离出来，放入[一个更可移植的crate](https://github.com/oxidecomputer/hubris/tree/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6/sys/kerncore)，这样可以更容易进行单元测试。目前已对我们最关注的边界情况进行了单元测试；按照Kent
    Beck的话说，我们计划再添加几个测试，直到"恐惧转为无聊"。
- en: When I say the code is “much more complex,” I mean relative to Hubris’s original
    code that performed the same function; it’s still much simpler than the equivalent
    code in most operating systems. Here’s all of it, with the comments from the original.
    (Note that `slice` here is not a Rust slice in the kernel, but a struct representing
    a *task-proposed slice* by address and size.)
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说代码“更加复杂”时，我是指相对于Hubris原始的执行相同功能的代码而言；它仍然比大多数操作系统中等效的代码要简单得多。以下是所有内容，包括原始的注释。（请注意，`slice`在这里不是内核中的Rust切片，而是表示地址和大小的*任务建议切片*的结构体。）
- en: '[PRE5]'
  id: totrans-split-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this new code, we can turn task packing back on without handing task developers
    a ticking time-bomb.
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段新代码，我们可以重新启用任务打包，而不会将潜在的问题交给任务开发人员。
- en: In all, about three hours had passed from the time Arjen noticed the network
    switch malfunctioning, until the kernel bug was fixed. I hacked on the unit tests
    the next morning.
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，从阿尔延注意到网络交换机故障到内核错误修复，大约已经过去了三个小时。第二天早上我对单元测试进行了修改。
- en: Failing with Hubris
  id: totrans-split-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Hubris失败
- en: For me, the interesting thing about this story is all the stuff that didn’t
    happen. Or more specifically, the way the system failed, and the ways in which
    it didn’t.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这个故事有趣的地方是没有发生的事情。更具体地说，系统失败的方式，以及它没有失败的方式。
- en: We went from “network switch won’t turn on with new firmware,” to two engineers
    3,000 miles apart separately analyzing snapshots of the failure, to having the
    kernel bug fixed, in about three hours. I’ve easily spent longer than that chasing
    a *single* memory corruption bug in other firmware. I think the difference comes
    down to the following things.
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从“网络交换机无法使用新固件开机”到两位分别位于3000英里之外的工程师分析失败快照，再到修复内核错误，大约用了三个小时。在其他固件中，我很容易花费更长的时间来追踪*单个*内存损坏错误。我认为差异在于以下几点。
- en: '**Fault isolation.** We had a crash during power sequencing on a *very* complex
    piece of hardware. But only part of the system crashed. The network switch firmware
    consists of 23 isolated components (tasks). Some of them have dependencies on
    power sequencing at various points in their lifecycle, of course — power sequencing
    is very important! — but for the most part they kept working through the *one
    hundred and fifteen crash and restart attempts.* This includes:'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障隔离。** 我们在非常复杂的硬件上电顺序期间遇到了崩溃。但只有系统的一部分崩溃了。网络交换机固件由23个隔离的组件（任务）组成。其中一些在它们的生命周期中的各个时刻都依赖于电源顺序，当然——电源顺序非常重要！——但大部分时间它们通过*一百一十五次崩溃和重新启动尝试*继续工作。这包括：'
- en: The in-system firmware update system.
  id: totrans-split-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统内固件更新系统。
- en: The IP network stack providing the management and control interface.
  id: totrans-split-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP网络堆栈提供管理和控制接口。
- en: Several network services, from a basic `echo` protocol implementation up through
    our rack control plane interface.
  id: totrans-split-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个网络服务，从基本的`echo`协议实现，直至我们的机架控制面板接口。
- en: I2C, SMBus, and PMBus to all the sensors, fans, and miscellanea monitoring the
    system’s resource usage and physical health.
  id: totrans-split-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I2C、SMBus和PMBus到所有传感器、风扇和监视系统资源使用和物理健康的杂项设备。
- en: Drivers for 32 QSFP 100-gigabit transceivers across the front of the switch.
  id: totrans-split-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动程序支持32个位于交换机正面的QSFP 100G光纤收发器。
- en: …and more. They kept working because of the fault isolation that Hubris provides,
    which manifested here in two ways. First, the sequencer task was able to crash
    without disrupting state in any other task, hardware peripheral, or the kernel.
    Second, the Hubris IPC mechanism is specifically designed under the assumption
    that other tasks may fail, and allows operations marked “idempotent” to be transparently
    retried, letting clients decouple themselves from crashing servers.
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: …还有更多。它们之所以能继续工作，是因为Hubris提供的故障隔离，在这里表现出两种方式。首先，定序任务能够崩溃而不会影响任何其他任务、硬件外围设备或内核的状态。其次，Hubris的IPC机制专门设计为假设其他任务可能会失败，并允许标记为“幂等”的操作透明地重试，让客户端能够与崩溃的服务器解耦。
- en: '**Failing toward safety.** In Hubris, both the implementation and the APIs
    try to maintain *one-sided error* — preventing some correct programs, rather than
    allowing some incorrect programs. The original memory access check algorithm was
    blocking accesses by a correct program, *not* admitting invalid accesses by a
    wrong or malicious program. This means it’s a rare case of a kernel memory access
    check bug that had no security implications. We’ve tried to maintain this throughout
    the stack, by comprehensively parsing all input as untrusted and making any undefined
    usage a fault. As a result, when the system fails, it tends to fail in non-exploitable
    ways.'
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**向安全失败。** 在 Hubris 中，无论是实现还是 API，都试图维持*单边错误* — 阻止某些正确的程序，而不是允许某些不正确的程序。原始的内存访问检查算法会阻止正确程序的访问，*而不是*接受错误或恶意程序的无效访问。这意味着这是一个罕见的内核内存访问检查错误，没有安全影响。我们试图在整个堆栈中保持这一点，通过全面地将所有输入解析为不受信任的内容，并使任何未定义的使用成为故障。因此，当系统失败时，它倾向于以不可利用的方式失败。'
- en: '**Safer shared memory.** Because of how we designed the IPC memory loan mechanism,
    even though the sequencer task and the I2C driver were effectively sharing memory
    at the time the sequencer crashed, the I2C driver was at no risk of corruption,
    and could go on with its business. (It never did restart, in the end.) This is
    because we assumed that a task acting as a server (like the I2C driver, here)
    will typically serve more than one client, and so needs to be made as robust as
    possible to arbitrary mistakes by clients. Including, in this case, (apparent)
    memory access violations.'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**更安全的共享内存。** 由于我们设计的 IPC 内存借用机制，尽管时序任务和 I2C 驱动器在时序任务崩溃时有效地共享内存，但 I2C 驱动器不会有损坏的风险，并且可以继续其业务。（最终它从未重新启动。）这是因为我们假设作为服务器的任务（比如这里的
    I2C 驱动器）通常会为多个客户提供服务，因此需要尽可能做得对客户的任意错误都足够强健。包括在这种情况下（表面上的）内存访问违规。'
- en: '**Kernel-debugger codesign.** My colleague Bryan Cantrill wrote the code that
    became Humility, our debugger, at the same time that I was writing the code that
    would become the Hubris kernel. The two programs have grown and changed together,
    and I wouldn’t have it any other way. Thanks to Humility, Arjen was able to identify
    the crashing code (down to the line number) within the first few minutes, and
    take a self-contained snapshot of the service processor, which he posted in a
    chat channel for Matt and I to pore over.'
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**内核调试器的代码签名。** 我的同事 Bryan Cantrill 在我编写即将成为 Hubris 内核的代码的同时，编写了成为我们调试器 Humility
    的代码。这两个程序一起成长和变化，我也希望没有其他方式。由于 Humility，Arjen 能够在几分钟内识别出崩溃代码（到行号），并且获取服务处理器的自包含快照，他在聊天频道中发布供
    Matt 和我查阅。'
- en: '**Firmware crash dumps are really great.** I never had physical access to the
    crashing network switch, and in fact I’m not actually sure where in the country
    it’s located. It doesn’t really matter; Humility can dump a consistent snapshot
    of our embedded systems when *at least one person* has physical access, and Hubris
    itself records compressed coredumps of crashing tasks into RAM where we can retrieve
    them over the network. This means we can still get crash dumps despite not having
    writable persistent storage, such as flash.'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**固件崩溃转储真的很棒。** 我从未有过物理访问崩溃的网络交换机，实际上我并不确定它位于国家的哪个位置。这并不重要；Humility 可以在至少有一个人有物理访问权限时转储我们的嵌入式系统的一致快照，而
    Hubris 本身将崩溃任务的压缩核心转储记录到 RAM 中，我们可以通过网络检索它们。这意味着我们可以获取崩溃转储，尽管没有可写的持久存储，比如闪存。'
- en: '**Simplicity of design and implementation.** The concepts provided by the Hubris
    kernel are simple — so simple, in fact, that I was initially concerned that they
    couldn’t be used to make useful production firmware. (Thankfully I was wrong!)
    The IPC mechanism has only three operations and no optional or fancy parts, so
    when a fault points to IPC, there are not a lot of places you might need to hunt
    for the problem.'
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计和实现的简单性。** Hubris 内核提供的概念非常简单 — 实际上，它们如此简单，以至于我最初担心它们无法用于制作有用的生产固件。（幸运的是我错了！）IPC
    机制仅有三种操作，并且没有可选或花哨的部分，因此当故障指向 IPC 时，你可能需要搜索问题的地方并不多。'
- en: But if you *did* have to hunt in a lot of places for the problem, the architecture-independent
    part of the Hubris kernel is currently 1,789 lines of code. That’s about four
    copies of this post. In a pinch, a single person could read through the entire
    kernel in search of a bug.
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你必须在许多地方搜索问题，Hubris 内核中与架构无关的部分目前有 1,789 行代码。大约相当于这篇帖子的四倍。在紧急情况下，一个人可以阅读整个内核以寻找错误。
- en: We haven’t had to do that yet, but it’s nice to know that we could if we had
    to!
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有必须这样做的情况，但知道如果必须的话我们是可以的！
- en: '**Tight nonhierarchical integration of the team.** This isn’t a Hubris feature,
    but it’s hard to separate Hubris from the team that built it. Oxide’s engineering
    team has essentially no internal silos. Our culture rewards openness, curiosity,
    and communication, and discourages defensiveness, empire-building, and gatekeeping.
    We’ve worked hard to create and defend this culture, and I think it shows in the
    way we organized horizontally, across the borders of what other organizations
    would call teams, to solve this mystery.'
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**团队紧密的非层级化整合。** 这不是傲慢的特征，但很难将傲慢与构建它的团队分开。Oxide 的工程团队基本上没有内部的壁垒。我们的文化鼓励开放、好奇和沟通，阻止防御性、帝国主义和守门人行为。我们努力创造和捍卫这种文化，我认为这在我们跨团队边界水平组织解决问题的方式上表现出来。'
- en: If I hadn’t been in the office that day, somebody else would have found and
    fixed the bug in my place — if not me it would have been Matt, or Laura Abbott,
    or Eliza, or Arjen, or Bryan, or any of several other people. This is really important
    to me. They would have done so without fear of reprisal; at most, they might have
    done it slightly slower, since I wrote the original buggy code and knew where
    the bodies were buried — but not dramatically slower. There is a real benefit
    to keeping critical code simple, well-commented, easy to reason about, and accessible
    — and there’s a real benefit to maintaining a team culture where *everyone* can
    take advantage of that.
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果那天我不在办公室，别人也会找到并修复这个 bug — 如果不是我，可能是马特、劳拉·阿博特、伊丽莎、阿尔杰恩、布莱恩或其他几个人之一。对我来说，这真的很重要。他们会毫无畏惧地做到这一点；最多，他们可能做得稍微慢一些，因为我写了最初有
    bug 的代码，知道问题出在哪里 — 但并不会慢得太多。保持关键代码简单、注释良好、易于理解和可访问确实有很大好处 — 保持团队文化，*每个人*都能从中受益，这也是一个真正的好处。
- en: Incidentally, we could use more help; at the time of this writing, we’re hiring
    more software folk. For details, [see the job description on our site](https://oxide.computer/careers/software-engineer).
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们需要更多的帮助；在撰写本文时，我们正在招聘更多的软件工程师。详情请参阅[我们网站上的职位描述](https://oxide.computer/careers/software-engineer)。
- en: '[#api-design](https://cliffle.com/tags/api-design/) [#dayjob](https://cliffle.com/tags/dayjob/)
    [#embedded](https://cliffle.com/tags/embedded/) [#rust](https://cliffle.com/tags/rust/)
    [#security](https://cliffle.com/tags/security/)'
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[#api-design](https://cliffle.com/tags/api-design/) [#dayjob](https://cliffle.com/tags/dayjob/)
    [#embedded](https://cliffle.com/tags/embedded/) [#rust](https://cliffle.com/tags/rust/)
    [#security](https://cliffle.com/tags/security/)'
