- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 12:48:17'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Basic Things
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://matklad.github.io/2024/03/22/basic-things.html](https://matklad.github.io/2024/03/22/basic-things.html)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Basic Things Mar 22, 2024
  id: totrans-split-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After working on the initial stages of several largish projects, I accumulated
    a list of things that share the following three properties:'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: they are irrelevant while the project is small,
  id: totrans-split-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: they are a productivity multiplier when the project is large,
  id: totrans-split-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: they are much harder to introduce down the line.
  id: totrans-split-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the list:'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: A project should have a *short* one-page readme that is mostly links to more
    topical documentation. The two most important links are the user docs and the
    dev docs.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: A common failure is a readme growing haphazardly by accretion, such that it
    is neither a good landing page, nor a source of comprehensive docs on any particular
    topic. It is hard to refactor such an unstructured readme later. The information
    is valuable, if disorganized, but there isn’t any better place to move it to.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: For developers, you generally want to have a docs folder in the repository.
    The docs folder should *also* contain a short landing page describing the structure
    of the documentation. This structure should allow for both a small number of high
    quality curated documents, and a large number of ad-hoc append-only notes on any
    particular topic. For example, `docs/README.md` could point to carefully crafted
    [`ARCHITECTURE.md`](https://matklad.github.io/2021/02/06/ARCHITECTURE.md.html)
    and `CONTRIBUTING.md`, which describe high level code and social architectures,
    and explicitly say that everything else in the `docs/` folder is a set of unorganized
    topical guides.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Common failure modes here:'
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: There’s no place where to put new developer documentation at all. As a result,
    no docs are getting written, and, by the time you do need docs, the knowledge
    is lost.
  id: totrans-split-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s only highly structured, carefully reviewed developer documentation.
    Contributing docs requires a lot of efforts, and many small things go undocumented.
  id: totrans-split-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s only unstructured append-only pile of isolated documents. Things are
    *mostly* documented, often two or there times, but any new team member has to
    do the wheat from the chaff thing anew.
  id: totrans-split-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Most project can benefit from a dedicated website targeted at the users. You
    want to have website ready when there are few-to-no users: usage compounds over
    time, so, if you find yourself with a significant number of users and no web “face”,
    you’ve lost quite a bit of value already!'
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other failure modes here:'
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: A different team manages the website. This prevents project developers from
    directly contributing improvements, and may lead to divergence between the docs
    and the shipped product.
  id: totrans-split-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Today’s web stacks gravitate towards infinite complexity. It’s all too natural
    to pick an “easy” heavy framework at the start, and then get yourself into npm’s
    bog. Website is about content, and content has gravity. Whatever markup language
    dialect you choose at the beginning is going to stay with for some time. Do carefully
    consider the choice of your web stack.
  id: totrans-split-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当今的Web堆栈倾向于无限复杂性。从一开始选择一个“简单”的重型框架然后陷入npm的泥潭是太自然不过了。网站关乎内容，而内容有重力。您在开始时选择的任何标记语言方言将在一段时间内保持不变。务必慎重考虑您的Web堆栈的选择。
- en: Saying that which isn’t quite done yet. Don’t overpromise, it’s much easier
    to say more later than to take back your words, and humbleness might be a good
    marketing. Consider if you are in a domain where engineering credibility travel
    faster than buzz words. But this is situational. More general advice would be
    that marketing also compounds over time, so it pays off to be deliberate about
    your image from the start.
  id: totrans-split-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 说那些尚未完成的事情。不要过度承诺，稍后说更多比收回您的话更容易，谦卑可能是一种良好的营销方式。请考虑您是否处于工程可信度比噱头更快传播的领域。但这是情境性的。更一般的建议是，营销也会随时间累积，因此从一开始就有意识地塑造您的形象是划算的。
- en: This is more situational, but consider if, in addition to public-facing website,
    you also need an internal, engineering-facing one. At some point you’ll probably
    need a bit more interactivity than what’s available in a `README.md`  — perhaps
    you need a place to display code-related metrics like coverage or some javascript
    to compute release rotation. Having a place on the web where a contributor can
    place something they need right now without much red tape is nice!
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这更多是情境性的，但请考虑一下，除了公共网站之外，您是否还需要一个面向内部工程师的网站。在某个时候，您可能需要比`README.md`中提供的更多交互性
    —— 也许您需要一个地方来显示与代码相关的指标，如覆盖率或一些JavaScript来计算发布轮换。在网络上有一个地方，贡献者可以放置他们现在需要的东西而不需要太多的繁文缛节是很好的！
- en: This is a recurring theme — you should be organized, you should not be organized.
    *Some* things have large fan-out and should be guarded with careful review. *Other*
    things benefit from just being there and a lightweight process. You need to create
    places for both kinds of things, and a clear decision rule about what goes where.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经常出现的主题 —— 您应该组织好，您不应该组织好。*某些*事情有很大的扇出，应该通过仔细的审查来保护。*其他*事情则受益于只是存在和轻量级流程。您需要为这两种事情创建地方，并制定明确的决策规则确定哪些事情放在哪里。
- en: For internal website, you’ll probably need some kind of data store as well.
    If you want to track binary size across commits, *something* needs to map commit
    hashes to (lets be optimistic) kilobytes! I don’t know a good solution here. I
    use a JSON file in a github repository for similar purposes.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内部网站，您可能还需要某种数据存储。如果您想要跟踪二进制大小的变化，*某种东西*需要将提交哈希映射到（让我们乐观地说）千字节！我不知道这里有什么好的解决方案。我在GitHub存储库中使用JSON文件用于类似的目的。
- en: 'There are many possible ways to get some code into the main branch. Pick one,
    and spell it out in an `.md` file explicitly:'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多将代码合并到主分支的可能方法。选择一种，并在`.md`文件中明确说明：
- en: Are feature branches pushed to the central repository, or is anyone works off
    their fork? I find forks work better in general as they automatically namespace
    everyone’s branches, and put team members and external contributors on equal footing.
  id: totrans-split-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支功能是否推送到中央存储库，还是任何人从其分叉中进行工作？一般来说，我发现分叉效果更好，因为它们自动为每个人的分支命名空间，并将团队成员和外部贡献者放在同等地位。
- en: If the repository is shared, what is the naming convention for branches? I prefix
    mine with `matklad/`.
  id: totrans-split-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存储库是共享的，分支的命名约定是什么？我用`matklad/`作为前缀。
- en: You use [not rocket-science rule](https://graydon2.dreamwidth.org/1597.html)
    (more on this later :).
  id: totrans-split-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用[非火箭科学规则](https://graydon2.dreamwidth.org/1597.html)（稍后详述 :）。
- en: Who should do code review of a particular PR? A single person, to avoid bystander
    effect and to reduce notification fatigue. The reviewer is picked by the author
    of PR, as that’s a stable equilibrium in a high-trust team and cuts red tape.
  id: totrans-split-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁应该审查特定PR的代码？一个人，以避免旁观效应并减少通知疲劳。评审员由PR的作者选择，因为这是高信任团队中的稳定均衡点，并简化了繁文缛节。
- en: How the reviewer knows that they need to review code? On GitHub, you want to
    *assign* rather than *request* a review. Assign is level-triggered — it won’t
    go away until the PR is merged, and it becomes the responsibility of the reviewer
    to help the PR along until it is merged (*request review* is still useful to poke
    the assignee after a round of feedback&changes). More generally, code review is
    the highest priority task — there’s no reason to work on new code if there’s already
    some finished code which is just blocked on your review.
  id: totrans-split-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评审员如何知道他们需要审查代码？在 GitHub 上，你希望*指派*而不是*请求*审查。指派是电平触发的 —— 它不会消失，直到 PR 被合并，并且成为评审员负责帮助
    PR 完成的责任（*请求审查*在反馈和更改一轮后通知指派者仍然有用）。更广泛地说，代码审查是最优先的任务 —— 如果已经有一些完成的代码被阻塞在你的审查上，没有理由去开发新代码。
- en: What is the purpose of review? Reviewing for correctness, for single voice,
    for idioms, for knowledge sharing, for high-level architecture are choices! Explicitly
    spell out what makes most sense in the context of your project.
  id: totrans-split-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论的目的是什么？检查正确性、一致性、习语、知识共享、高级架构是选择的一部分！明确说明在项目背景下最合理的选择。
- en: 'Meta process docs: positively encourage contributing process documentation
    itself.'
  id: totrans-split-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元过程文档：积极鼓励贡献过程文档本身。
- en: Speaking about meta process, style guide is where it is most practically valuable.
    Make sure that most stylistic comments during code reviews are immediately codified
    in the project-specific style document. New contributors should learn project’s
    voice not through a hundred repetitive comments on PRs, but through a dozen links
    to specific items of the style guide.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论元过程时，样式指南在实践中最具价值。确保代码审查期间大多数风格评论立即纳入项目特定的样式文档中。新贡献者应通过几个指向样式指南具体条款的链接学习项目的语调，而不是通过对
    PR 的数百次重复评论。
- en: Do you even need a project-specific style guide? I think you do — cutting down
    mental energy for trivial decisions is helpful. If you need a result variable,
    and half of the functions call it `res` and another half of the functions call
    it `result`, making this choice is just distracting.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否需要一个项目特定的样式指南？我认为你需要 —— 减少对微小决策的精力投入是有帮助的。如果你需要一个结果变量，并且有一半的函数称它为 `res`，另一半称它为
    `result`，做出这个选择只会分散注意力。
- en: Project-specific naming conventions is one of the more useful thing to place
    in the style guide.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 项目特定的命名约定是样式指南中最有用的内容之一。
- en: Optimize style guide for extensibility. Uplifting a comment from a code review
    to the style guide should not require much work.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 优化样式指南以提高可扩展性。将代码审查中的评论提升到样式指南中不应该需要太多工作。
- en: Ensure that there’s a style tzar — building consensus around *specific* style
    choices is very hard, better to delegate the entire responsibility to one person
    who can make good enough choices. Style usually is not about what’s better, it’s
    about removing needless options in a semi-arbitrary ways.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 确保有一个样式专员 —— 围绕*具体*的样式选择建立共识非常困难，最好将整个责任委托给一个人，他能够做出足够好的选择。样式通常不是关于什么更好，而是在半随意的方式下消除不必要的选项。
- en: Document stylistic details pertaining to git. If project uses `area:` prefixes
    for commits, spell out an explicit list of such prefixes.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 文档化与 Git 相关的风格细节。如果项目使用 `area:` 前缀来表示提交，明确列出这类前缀的具体列表。
- en: Consider documenting acceptable line length for the summary line. Git man page
    boldly declares that a summary should be under 50 characters, but that is just
    plain false. Even in the kernel, most summaries are somewhere between 50 and 80
    characters.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑为摘要行文档化可接受的行长度。Git 手册大胆声明摘要应在50个字符以下，但这纯属错误。即使在内核中，大多数摘要也在50到80个字符之间。
- en: Definitely explicitly forbid adding large files to git. Repository size increases
    monotonically, `git clone` time is important.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 明确禁止向 Git 中添加大文件。仓库大小单调增加，`git clone` 的时间非常重要。
- en: 'Document merge-vs-rebase thing. My preferred answer is:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 文档化合并与变基的事情。我偏好的答案是：
- en: A unit of change is a pull request, which might contain several commits
  id: totrans-split-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更的单位是一个拉取请求，可能包含几个提交。
- en: Merge commit for the pull request is what is being tested
  id: totrans-split-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取请求的合并提交是正在测试的内容。
- en: The main branch contains only merge commits
  id: totrans-split-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主分支仅包含合并提交。
- en: Conversely, *only* the main branch contains merge commits, pull requests themselves
    are always rebased.
  id: totrans-split-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，*仅*主分支包含合并提交，拉取请求本身总是变基。
- en: Forbidding large files in the repo is a good policy, but it’s hard to follow.
    Over the lifetime of the project, someone somewhere will sneakily add and revert
    a megabyte of generated protobufs, and that will fly under code review radar.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止在仓库中放置大文件是一个好的策略，但很难遵循。在项目的生命周期内，某处某人会偷偷地添加并回退一兆字节的生成的protobufs，而这将飞过代码审查的雷达。
- en: 'This brings us to the most basic thing of them all:'
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到了所有基础中最基础的事情：
- en: Maintain a well-defined set of automated checks that pass on the main branch
    at all times. If you don’t want large blobs in git repository, write a test rejecting
    large git objects and run that right before updating the main branch. No merge
    commits on feature branches? Write a test which fails with a pageful of Git self-help
    if one is detected. Want to wrap `.md` at 80 columns? Write a test :)
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 维护一组明确定义的自动化检查，这些检查在主分支上始终通过。如果你不希望在git仓库中有大块对象，请编写一个拒绝大git对象的测试，并在更新主分支之前运行该测试。特性分支上没有合并提交？编写一个测试，如果检测到合并提交，则以Git自助的页面失败。
- en: 'It is perhaps worth you while to re-read the original post: [https://graydon2.dreamwidth.org/1597.html](https://graydon2.dreamwidth.org/1597.html)'
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或许值得你再次阅读原始帖子：[https://graydon2.dreamwidth.org/1597.html](https://graydon2.dreamwidth.org/1597.html)
- en: '[This mindset of monotonically growing set of properties](https://matklad.github.io/2024/01/03/of-rats-and-ratchets.html)
    that are true about the codebase is *incredibly* powerful. You start seeing code
    as temporary, fluid thing that can always be changed relatively cheaply, and the
    accumulated set of automated tests as the real value of the project.'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[这种单调增长的属性集的心态](https://matklad.github.io/2024/01/03/of-rats-and-ratchets.html)，关于代码库是*非常*强大的。你开始把代码看作是可以相对便宜地随时改变的暂时性、流动性物体，而积累的一组自动化测试是项目的真正价值。'
- en: Another second order effect is that NRSR puts a pressure to optimize your build
    and test infrastructure. If you don’t have an option to merge the code when an
    unrelated flaky test fails, you won’t have flaky tests.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个二阶效应是，NRSR促使你优化你的构建和测试基础设施。如果你没有选项在一个不相关的不稳定测试失败时合并代码，你将不会有不稳定的测试。
- en: A common anti-pattern here is that a project grows a set of semi-checks — tests
    that exists, but are not 100% reliable, and thus are not exercised by the CI routinely.
    And that creates ambiguity — are tests failing due to a regression which should
    be fixed, or were they never reliable, and just test a property that isn’t actually
    essential for functioning of the project? This fuzziness compounds over time.
    If a check isn’t reliable enough to be part of NRSR CI gate, it isn’t actually
    a check you care about, and should be removed.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个常见反模式是项目会增加一组半检查——存在但不是100%可靠的测试，因此CI不会经常执行它们。这会造成歧义——测试失败是因为应该修复的回归，还是它们从未可靠，只是测试了一个实际上对项目功能并不重要的属性？这种模糊性随时间而累积。如果一个检查不够可靠以成为NRSR
    CI门的一部分，那它实际上不是你关心的检查，应该被移除。
- en: 'But to do NRSR, you need to build & CI your code first:'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但要做NRSR，你首先需要构建和CI你的代码：
- en: 'This is a complex topic. Let’s start with the basics: what is a build system?
    I would love to highlight a couple of slightly unconventional answers here.'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的话题。让我们从基础开始：什么是构建系统？我想在这里强调一些稍微不寻常的答案。
- en: '*First*, a build system is a bootstrap process: it is how you get from `git
    clone` to a working binary. The two aspects of this boostrapping process are important:'
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*首先*，构建系统是一个引导过程：它是你从`git clone`到工作二进制文件的方式。这个引导过程的两个方面很重要：'
- en: It should be simple. No `sudo apt-get install bazzilion packages`, the single
    binary of your build system should be able to bring everything else that’s needed,
    automatically.
  id: totrans-split-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是简单的。没有`sudo apt-get install bazzilion packages`，你的构建系统的单个二进制文件应该能够自动地带来所有其他需要的东西。
- en: It should be repeatable. Your laptop and your CI should end up with exactly
    identical set of dependencies. The end result should be a function of commit hash,
    and not your local shell history, otherwise NRSR doesn’t work.
  id: totrans-split-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是可重复的。你的笔记本和你的CI应该最终具有完全相同的依赖项集。最终结果应该是提交哈希的函数，而不是你本地的shell历史，否则NRSR无法工作。
- en: '*Second*, a build system is developer UI. To do almost anything, you need to
    type some sort of build system invocation into your shell. There should be a single,
    clearly documented command for building and testing the project. If it is not
    a single `makebelieve test`, something’s wrong.'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*其次*，构建系统是开发者的UI。几乎做任何事情，你都需要在你的shell中输入某种构建系统调用。应该有一个单一、清晰文档化的命令来构建和测试项目。如果不是一个单一的`makebelieve
    test`，那就有问题了。'
- en: One anti-pattern here is when the build system spills over to CI. When, to figure
    out what the set of checks even is, you need to read `.github/workflows/*.yml`
    to compile a list of commands. That’s accidental complexity! Sprawling yamls are
    a bad entry point. Put all the logic into the build system and let the CI drive
    that, and not vice verse.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个反模式是构建系统溢出到 CI。当你需要读取 `.github/workflows/*.yml` 来编译命令列表以了解检查集时，这就是偶然复杂性！庞大的
    yaml 文件是一个糟糕的入口点。将所有逻辑放入构建系统中，并让 CI 驱动它，而不是反过来。
- en: '[There is a stronger version of the advice](https://matklad.github.io/2023/12/31/O(1)-build-file.html).
    No matter the size of the project, there’s probably only a handful of workflows
    that make sense for it: testing, running, releasing, etc. This small set of workflows
    should be nailed from the start, and specific commands should be documented. When
    the project subsequently grows in volumes, this set of build-system entry points
    should *not* grow.'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[这里有更强烈的建议版本](https://matklad.github.io/2023/12/31/O(1)-build-file.html)。无论项目大小如何，它可能只有少数几个适合它的工作流程：测试、运行、发布等。应该从一开始就明确这个小组工作流程，并记录具体的命令。当项目随后扩展时，这组构建系统入口点不应该增长。'
- en: If you add a Frobnicator, `makebelieve test` invocation *should* test that Frobnicator
    works. If instead you need a dedicated `makebelieve test-frobnicator` and the
    corresponding line in some CI yaml, you are on a perilous path.
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加了一个 Frobnicator，`makebelieve test` 的调用*应该*测试 Frobnicator 的工作。如果你需要一个专用的
    `makebelieve test-frobnicator` 并在某些 CI yaml 文件中相应地加上一行，那你走的是一条危险的道路。
- en: '*Finally*, a build system is a collection of commands to make stuff happen.
    In larger projects, you’ll inevitably need some non-trivial amount of glue automation.
    Even if the entry point is just `makebelive release`, internally that might require
    any number of different tools to build, sign, tag, upload, validate, and generate
    a changelog for a new release.'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*最后*，一个构建系统是一系列使事情发生的命令。在较大的项目中，你不可避免地需要一些非常规自动化。即使入口点只是 `makebelive release`，内部可能需要任意数量的不同工具来构建、签名、标记、上传、验证和生成新版本的更改日志。'
- en: A common anti-pattern is to write these sorts of automations in bash and Python,
    but that’s almost pure technical debt. These ecosystems are extremely finnicky
    in and off themselves, and, crucially (unless your project itself is written in
    bash or Python), they are a second ecosystem to what you already have in your
    project for “normal” code.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的反模式是用 bash 和 Python 编写这些类型的自动化，但这几乎纯粹是技术债务。这些生态系统本身非常棘手，并且至关重要的是（除非你的项目本身是用
    bash 或 Python 编写的），它们是对你已有项目中“正常”代码的第二个生态系统。
- en: But releasing software is also just code, which you can write in your primarly
    language. [The right tool for the job is often the tool you are already using](https://twitter.com/id_aa_carmack/status/989951283900514304).
    It pays off to explicitly attack the problem of glue from the start, and to pick/write
    a library that makes writing subprocess wrangling logic easy.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但发布软件也只是代码，你可以用你的主要语言来编写它。[选择适合工作的工具通常是你已经在使用的工具](https://twitter.com/id_aa_carmack/status/989951283900514304)。从一开始就明确解决胶水问题，并选择/编写一个使编写子进程处理逻辑变得容易的库，这是值得的。
- en: 'Summing the build and CI story up:'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总结构建和 CI 流程：
- en: Build system is self-contained, reproducible and takes on the task of downloading
    all external dependencies. Irrespective of size of the project, it contains O(1)
    different entry points. One of those entry points is triggered by the not rocket
    science rule CI infra to run the set of canonical checks. There’s an explicit
    support for free-form automation, which is implemented in the same language as
    the bulk of the project.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统是自包含的、可复现的，并承担下载所有外部依赖项的任务。无论项目大小如何，它都包含 O(1) 个不同的入口点。其中一个入口点由“不是火箭科学规则”的
    CI 基础设施触发以运行一组规范检查。这支持显式的自由形式自动化，其实现与项目大部分内容相同语言中。
- en: Integration with NRSR is the most important aspect of the build process, as
    it determines how the project evolves over time. Let’s zoom in.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与 NRSR 的集成是构建过程中最重要的方面，因为它决定了项目随时间的演变。让我们来详细看看。
- en: 'Testing is a primary architectural concern. When the first line of code is
    written, you already should understand the big picture testing story. It is empathically
    *not*  “every class and module has unit-test”. Testing should be data oriented
    — the job of a particular software is to take some data in, transform it, and
    spit different data out. Overall testing strategy requires:'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个主要的架构关注点。在编写第一行代码时，你应该已经理解了整体的测试策略。这绝对不是“每个类和模块都有单元测试”。测试应该是数据导向的 —— 特定软件的工作是接收一些数据，对其进行转换，并输出不同的数据。总体的测试策略需要考虑：
- en: some way to specify/generate input data,
  id: totrans-split-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些指定/生成输入数据的方法，
- en: some way to assert desired properties of output data, and
  id: totrans-split-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些验证输出数据期望属性的方法，
- en: a way to run many individual checks very fast.
  id: totrans-split-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速运行许多单独检查的方法。
- en: 'If time is a meaningful part of the input data, it should be modeled explicitly.
    Not getting the testing architecture right usually results in:'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果时间是输入数据中的一个重要部分，那么它应该明确地进行建模。如果测试架构不正确，通常会导致以下问题：
- en: Software that is hard to change because thousands of test nail existing internal
    APIs.
  id: totrans-split-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为成千上万的测试钉住了现有的内部 API，软件变得难以更改。
- en: Software that is hard to change because there are no test to confidently verify
    absence of unintended breakages.
  id: totrans-split-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为没有测试可以自信地验证无意的破坏是否不存在，软件变得难以更改。
- en: Software that is hard to change because each change requires hours of testing
    time to verify.
  id: totrans-split-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为每次变更都需要数小时的测试时间来验证，软件变得难以更改。
- en: How to architect a test suite goes beyond the scope of this article, but please
    read [Unit and Integration Tests](https://matklad.github.io/2022/07/04/unit-and-integration-tests.html)
    and [How To Test](https://matklad.github.io/2021/05/31/how-to-test.html).
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设计测试套件超出了本文的范围，请阅读[单元测试与集成测试](https://matklad.github.io/2022/07/04/unit-and-integration-tests.html)和[如何测试](https://matklad.github.io/2021/05/31/how-to-test.html)。
- en: 'Some specific things that are in scope for this article:'
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的范围包括一些具体的事项：
- en: Zero tolerance for flaky tests. Strict not rocket science rules gives this by
    construction — if you can’t merge *your* pull request because someone elses test
    is flaky, that flaky test immediately becomes your problem.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对不稳定测试的零容忍。严格而非复杂的规则通过设计实现了这一点 —— 如果你不能合并你的拉取请求，因为其他人的测试不稳定，那么这个不稳定的测试立即成为你的问题。
- en: Fast tests. Again, NRSR already provides a natural pressure for this, but it
    also helps to make testing time more salient otherwise. Just by default printing
    the total test time and five slowest tests in a run goes a long way.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测试。同样，NRSR已经通过自然的压力提供了这种自然压力，但通过默认打印总测试时间和运行中五个最慢的测试，可以更加显著地显示测试时间的重要性。
- en: Not all tests could be fast. Continuing the ying-yang theme of embracing order
    and chaos simultaneously, it helps to introduce the concept of slow tests early
    on. CI always runs the full suite of tests, fast and slow. But the local `makebelive
    test` by default runs only fast test, with an opt-in for slow tests. Opt in can
    be as simple as an `SLOW_TESTS=1` environmental variable.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有测试都能够快速完成。在同时接纳秩序和混沌的阴阳主题中，早期引入慢速测试的概念是有帮助的。CI 总是运行完整的测试套件，包括快速和慢速测试。但默认情况下，本地的
    `makebelive test` 只运行快速测试，并选择性地运行慢速测试。选择性可以简单地通过设置 `SLOW_TESTS=1` 环境变量来实现。
- en: Introduce a [snapshot testing](https://ianthehenry.com/posts/my-kind-of-repl/)
    library early. Although the bulk of tests should probably use project-specific
    testing harness, for everything else inline repl-driven snapshot testing is a
    good default approach, and is something costly to introduce once you’ve accumulated
    a body of non-snapshot-based tests.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 早期引入[快照测试](https://ianthehenry.com/posts/my-kind-of-repl/)库。尽管大部分测试应该使用项目特定的测试工具，但对于其他所有情况，内联
    REPL 驱动的快照测试是一个很好的默认方法，而且一旦积累了一定数量的非快照测试，引入这种方法的成本会很高。
- en: Alongside the tests, come the benchmarks.
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试之外，还有基准测试。
- en: I don’t have a grand vison about how to make benchmark work in a large, living
    project, it always feels like a struggle to me. I do have a couple of tactical
    tips though.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我对如何在大型、活跃项目中使基准工作起作用没有一个宏伟的愿景，我总觉得这对我来说都是一种挑战。不过，我确实有几个战术上的建议。
- en: '*Firstly*, any code that is *not* running during NRSR is effectively dead.
    It is exceedingly common for benchmarks to be added alongside a performance improvement,
    and then *not* getting hooked up with CI. So, two month down the line, the benchmark
    either stops compiling outright, or maybe just panics at a startup due to some
    unrelated change.'
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*首先*，任何在 NRSR 过程中*不*运行的代码实际上是死代码。很常见的情况是，在性能改进的同时添加基准测试，然后*没有*与 CI 链接起来。因此，两个月后，基准测试要么完全停止编译，要么可能只是由于一些无关的更改在启动时发生恐慌。'
- en: This fix here is to make sure that every benchmark is *also* a test. Parametrize
    every benchmark by input size, such that with a small input it finishes in milliseconds.
    Then write a test that literally just calls the benchmarking code with this small
    input. And remember that your build system should have O(1) entry points. Plug
    this into a `makebelieve test`, not into a dedicated `makebelieve benchmark --small-size`.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的修复是确保每个基准测试也是一个测试。通过输入大小参数化每个基准测试，使得用小输入完成毫秒级测试。然后编写一个测试，字面上只调用具有这个小输入的基准测试代码。记住，你的构建系统应该有
    O(1) 的入口点。将其插入到一个 `makebelieve test` 中，而不是一个专用的 `makebelieve benchmark --small-size`。
- en: '*Secondly*, any large project has a certain amount of very important macro
    metrics.'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*其次*，任何大型项目都有一定数量的非常重要的宏度量标准。'
- en: How long does it take to build?
  id: totrans-split-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建需要多长时间？
- en: How long does it take to test?
  id: totrans-split-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试需要多长时间？
- en: How large is the resulting artifact shipping to users?
  id: totrans-split-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果产生的供用户使用的工件有多大？
- en: These are some of the questions that always matter. You need infrastructure
    to track these numbers, and to see them regularly. This where the internal website
    and its data store come in. During CI, note those number. After CI run, upload
    a record with commit hash, metric name, metric value *somewhere*. Don’t worry
    if the results are noisy — you target the baseline here, ability to notice large
    changes over time.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是总是重要的问题。你需要基础设施来跟踪这些数字，并定期查看它们。这就是内部网站及其数据存储的作用。在 CI 过程中，记录这些数字。在 CI 运行后，将一个记录上传到提交哈希、指标名称和指标值的*某个地方*。不要担心结果会有噪音——你的目标是基线，能够随时间注意到大的变化。
- en: 'Two options for the “upload” part:'
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: '"上传"部分有两个选项：'
- en: Just put them into some `.json` file in a git repo, and LLM a bit of javascript
    to display a nice graph from these data.
  id: totrans-split-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需将它们放入 git 仓库中的某个 `.json` 文件中，然后用一点 JavaScript 来显示这些数据的漂亮图表。
- en: '[https://nyrkio.com](https://nyrkio.com) is a surprisingly good SaaS offering
    that I can recommend.'
  id: totrans-split-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://nyrkio.com](https://nyrkio.com) 是一个令人惊讶地好的 SaaS 提供，我可以推荐。'
- en: Serious fuzz testing curiously shares characteristics of tests and benchmarks.
    Like a normal test, a fuzz test informs you about a correctness issue in your
    application, and is reproducible. Like a benchmark, it is (infinitely) long running
    and infeasible to do as a part of NRSR.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 严肃的模糊测试好奇地共享了测试和基准测试的特性。像正常测试一样，模糊测试告诉你应用程序中的正确性问题，并且是可重现的。像基准测试一样，它是（无限）长时间运行的，并且作为
    NRSR 的一部分是不可行的。
- en: 'I don’t yet have a good hang on how to most effectively integrate continuous
    fuzzing into development process. I don’t know what is the not rocket science
    rule of fuzzing. But two things help:'
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我还不知道如何最有效地将持续模糊测试集成到开发过程中。我不知道模糊测试的“不是火箭科学”规则是什么。但有两件事是有帮助的：
- en: '*First*, even if you can’t run fuzzing loop during CI, you can run isolated
    seeds. To help ensure that the fuzing code doesn’t get broken, do the same thing
    as with benchmark — add a test that runs fuzzing logic with a fixed seed and small,
    fast parameters. One variation here is that you can use commit sha as random a
    seed — that way the code is still reproducible, but there is enough variation
    to avoid dynamically dead code.'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*首先*，即使你不能在 CI 过程中运行模糊测试循环，你可以运行隔离的种子。为了帮助确保模糊测试代码不会出问题，可以像进行基准测试一样——添加一个使用固定种子和小型快速参数运行模糊逻辑的测试。这里的一个变化是，你可以使用提交的
    sha 作为随机种子——这样代码仍然是可重现的，但有足够的变化以避免动态死代码。'
- en: '*Second*, it is helpful to think about fuzzing in terms of level triggering.
    With tests, when you make an erroneous commit, you immediately know that it breaks
    stuff. With fuzzing, you generally discover this later, and a broken seed generally
    persists for several commits. So, as an output of the fuzzer, I think what you
    want is *not* a set of GitHub issues, but rather a dashboard of sorts which shows
    a table of recent commits and failing seeds for those commits.'
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
- en: With not rocket science rule firmly in place, it makes sense to think about
    releases.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Two core insights here:'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
- en: '*First* release *process* is orthogonal from software being *production ready*.
    You can release stuff before it is ready (provided that you add a short disclaimer
    to the readme). So, it pays off to add proper release process early on, such that,
    when the time comes to actually release software, it comes down to removing disclaimers
    and writing the announcement post, as all technical work has been done ages ago.'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
- en: '*Second*, software engineering in general observes reverse triangle inequality:
    to get from A to C, it is faster to go from A to B and then from B to C, then
    moving from A to C atomically. If you make a pull request, it helps to split it
    up into smaller parts. If you refactor something, it is faster to first introduce
    a new working copy and then separately retire the old code, rather than changing
    the thing in place.'
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Releases are no different: faster, more frequent releases are easier and less
    risky. Weekly cadence works great, provided that you have a solid set of checks
    in your NRSR.'
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
- en: It is much easier to start with a state where almost nothing works, but there’s
    a solid release (with an empty set of features), and ramp up from there, than
    to hack with reckless abandon *without* thinking much about eventual release,
    and then scramble to decide which is ready and releasable, a what should be cut.
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
- en: 'I think that’s it for today? That’s a lot of small points! Here’s a bullet
    list for convenient reference:'
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
- en: README as a landing page.
  id: totrans-split-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dev docs.
  id: totrans-split-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User docs.
  id: totrans-split-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured dev docs (architecture and processes).
  id: totrans-split-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unstructured ingest-optimized dev docs (code style, topical guides).
  id: totrans-split-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User website, beware of content gravity.
  id: totrans-split-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ingest-optimized internal web site.
  id: totrans-split-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meta documentation process — its everyone job to append to code style and process
    docs.
  id: totrans-split-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear code review protocol (in whose court is the ball currently?).
  id: totrans-split-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated check for no large blobs in a git repo.
  id: totrans-split-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not rocket science rule.
  id: totrans-split-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s repeat: at **all** times, the main branch points at a commit hash which
    is known to pass a set of well-defined checks.'
  id: totrans-split-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No semi tests: if the code is not good enough to add to NRSR, it is deleted.'
  id: totrans-split-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No flaky tests (mostly by construction from NRSR).
  id: totrans-split-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single command build.
  id: totrans-split-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reproducible build.
  id: totrans-split-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed number of build system entry points. No separate lint step, a lint is
    a kind of a test.
  id: totrans-split-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI delegates to the build system.
  id: totrans-split-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Space for ad-hoc automation in the main language.
  id: totrans-split-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overarching testing infrastructure, grand unified theory of project’s testing.
  id: totrans-split-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast/Slow test split (fast=seconds per test suite, slow=low digit minutes per
    test suite).
  id: totrans-split-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapshot testing.
  id: totrans-split-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarks are tests.
  id: totrans-split-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macro metrics tracking (time to build, time to test).
  id: totrans-split-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzz tests are tests.
  id: totrans-split-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level-triggered display of continuous fuzzing results.
  id: totrans-split-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverse triangle inequality.
  id: totrans-split-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weekly releases.
  id: totrans-split-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
