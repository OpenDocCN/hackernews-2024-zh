<!--yml

分类：未分类

日期：2024-05-29 12:40:24

-->

# 上下文：编程语言缺失的特性 | 作者：Keaton Brandt | 来源和错误 | Medium

> 来源：[https://medium.com/source-and-buggy/context-the-missing-feature-of-programming-languages-7c1095fe8d32](https://medium.com/source-and-buggy/context-the-missing-feature-of-programming-languages-7c1095fe8d32)

现代计算机硬件如此强大，以至于在编写代码时我们通常可以简单地忽略其限制。但从概念上讲，任何分配内存的函数都是依赖上下文的：其结果不仅取决于传入的参数，还取决于系统能够授予的连续RAM的数量。

> **上下文 [名词]:** 可以影响函数结果或性能的任何状态，而无需作为参数传递。

上下文的其他基本示例包括：全局变量、调用外部服务、当前线程的信息（例如，是否是UI线程）以及当前堆栈的信息（例如，为异常创建堆栈跟踪）。

上下文的问题在于其假设和变异发生在应用代码的阴暗角落——低级实现细节，而不是明亮的接口定义。编译器简单地不检查函数依赖的上下文（例如，它是否从`stdin`读取），函数也不会报告它。这不是黑市，但它是一个[危险的不受监管的市场](https://en.wikipedia.org/wiki/Gun_law_in_the_United_States)。

当我调用`getTimestamp(user.registeredAt, TimeZone.PST)`时，我可以*假设*它只是进行一些简单的数学运算并返回结果。它*可能*不会进行网络调用或持有锁或挖矿比特币，因此我*可能*不需要优化调用频率。但实际上，它*可能*需要查找今年夏令时的时间表，无论是从数据库还是从网络中获取。作为程序员，我们在这种情况下必须依赖直觉，这并不是稳定性的坚实基础。

如果程序员是结构工程师

## 控制上下文

上下文之所以危险，仅因为它缺乏函数参数并且对调用者不透明。例如，调用者无法知道函数是否可能引发死锁，因为它无法知道该函数的实现是否依赖于锁定。处理上下文的最简单方法是简单地摆脱它，并将*所有东西*作为函数参数传递。

例如，我们可以要求代码库中所有的锁只能通过传入的 `LockGrabber` 对象来获取，并且所有的 `synchronized` 代码块坚决拒绝将该 LockGrabber 传递给任何子函数，从而阻止它们获取嵌套锁的能力。相反，执行计算密集型操作的服务可以在后台线程中构建，并且只能传递给在该线程内调用的函数，从而防止这些服务阻塞 UI 线程上的工作。问题解决了！

糟糕，我又犯了同样的错误。*其实这还是有点糟糕的。*

撇开这将很快导致拥有 *数十个* 参数的函数，这不仅难看且糟糕 —— 这种方法仍然将所有上下文管理的责任都放在程序员身上。很容易在不应该的地方意外传递一个参数，而这并不一定会引起编译器错误、运行时错误或测试失败。只需一个人在持有锁的同时意外将 `LockGrabber` 传递给另一个函数，所有精心设计的架构保证就会毁于一旦。

远离隐式上下文，转向一切显式参数的想法是一个良好的开始，但如果没有编译器的帮助，这是不可持续的。以下是一个上下文感知编译器如何工作的示例：

这里的 `with` 和 `without` 函数改变了上下文，允许编译器识别死锁。语法灵感来自 Kotlin 的上下文接收器（稍后详述）。

在幕后，编译器基本上只是在传递额外的参数，但会自动强制执行约束条件，而不会使代码混乱。一个有礼貌的编译器甚至会给我们一个有用的错误消息，例如：

```
ERROR: Cannot call `myFunction2` without required context: `LockGrabber`

Problematic trace:
 - myFunction1 [main.kt:17]                     << has LockGrabber
 - LockGrabber::withLock [main.kt:2]
 - without(LockGrabber) [main.kt:6]             << LockGrabber removed here
 - myFunction1::$lambda1@withLock [main.kt:19]
 - call to myFunction1 [main.kt:22]             << needs LockGrabber
```

将新功能直接集成到编程语言中并不总是明智的选择，因为第三方库更为灵活，可以在某种自由市场中相互竞争。但在这种情况下，我认为管理上下文对于良好的软件至关重要，因此也必须成为良好编程语言的基础，而不是后来添加的功能。标准库应该具备上下文感知能力，IDE、调试器和构建工具也应如此。管理上下文带来的复杂性不好，但忽略它所带来的复杂性则更糟糕。

# Kotlin：一个（部分）案例研究

Kotlin 可能是世界上最被低估的编程语言之一。通常情况下，我会说它是“Java，但更好” —— 这并不是一个引人入胜的标题。但是，抛开 Java 和 JVM 长时间笼罩的阴影，Kotlin 是一个充满新思想的语言。事实上，尽管 Kotlin 有时被视为 Android 上的 Swift 克隆，但实际上它比 Swift 更早诞生。（在此，我需要说明我在 Google 的 Android 团队工作，因此这对我个人而言有点敏感）

Kotlin 中与上下文相关的两个特性：

[**CoroutineContext**](https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html) 是一种运行时机制，允许 [协程](https://kotlinlang.org/docs/coroutines-overview.html) 访问上下文数据，如其异步堆栈跟踪或当前线程。它可以在理论上用作传递其他数据的任意键值存储，但这种用法无法在编译时检查，因此通常不建议使用。我对此没有意见，但本文不讨论这个问题。

**实验性** [**上下文接收器**](https://github.com/Kotlin/KEEP/blob/master/proposals/context-receivers.md) **API** 是一种编译时语言特性，允许从上下文中提供函数参数，而不是手动传递。这可能正是我一直在等待的东西？看起来非常接近！

这个工作示例打印出“LOG: Hi Keaton!”

虽然这确实使“将一切作为参数传递”的方法更为可行，但它有两个主要缺点：

+   没有 `**without**` **函数。** 我可以用 `with` 将用户和记录器添加到上下文中，但 `sayHi` 没有调用其他函数的选项，除非存在相同的上下文。这次你赢了，死锁。

+   **上下文显式。** 调用 `sayHi` 的任何函数需要为自身指定 `UserAccount` 和 `Logger` 作为上下文，以便将该上下文转发给 `sayHi`。编译器本身并不足够智能来完成这一点。例如，这种方式行不通：

在这里，`processOnAppStartup` 需要在其上下文中包含 `UserAccount`、`Logger`、`Database`、`SyncApi`，以及 `someOtherHeavyComputation` 需要的任何内容，以及 `somethingElseAsWell` 需要的内容，*及其所有子函数需要的任何内容*。向函数添加新的上下文部分将需要更新调用它的所有函数，这是不可避免的，因此我们并没有避免像“带有十几个参数的函数”问题，只是在其上披了一层语法糖。

我理解对理想解决方案与实际情况之间仍然存在很大差距的犹豫。一行代码读作“此函数从调用堆栈中的*某处*获取Logger”的想法，如果没有适当的工具来仔细分析，将会令人不安。然而，在这种情况下，Kotlin 是这类功能的完美测试场所。Kotlin 由 JetBrains 维护，他们是 IntelliJ 及其他 IDE 的制造商。它非常适合在可以用其他语言明确说明的信息装饰其代码的 IDE 中使用（Kotlin 省略大多数数据类型，某些 `return` 语句，甚至*没有* `await` 语句）。上下文只是另一种装饰的东西。

# 补充：上下文中的其他案例研究

我通常不会在发布后编辑帖子，但我得到了很多关于这个领域学术工作的有趣反馈，我想简要分享一些。我不是编程语言研究者，所以我不会尝试更多的高级概述，但我会链接到一些优秀的深度资源。

首先，坏消息是：我与之交谈的人都不知道有任何真实世界的生产就绪编程语言可以做我想要的事情。我遇到的唯一支持类似`without`的语言是[Flix](https://flix.dev/)，一个小巧而有趣的研究语言。像Haskell、OCaml和Scala这样的函数式语言有强类型的效果，可以做其他所有事情，只是没有`without`。

在编程语言的行话中，Effect 是函数返回值之外的任何函数*做的*事情。修改状态，例如：打印到控制台或进行网络调用，都是 Effect。知道函数何时修改状态是一半的战斗，另一半是知道函数何时*读取*状态。这不是 Effect，而是一个[Coeffect](https://tomasp.net/coeffects/) — 虽然有时它都被统称为‘Effects’或‘Effect Systems’。

探索 Effects 不同方法的研究语言示例包括：[Eff](https://www.eff-lang.org/try/)、[Effekt](https://effekt-lang.org/docs/concepts/effect-safety)、[Flix](https://flix.dev/) 和 [Koka](https://koka-lang.github.io/koka/doc/book.html)。在这里有一个巨大的工作列表[here](https://github.com/yallop/effects-bibliography)，尽管其中大部分采用运行时库的形式，我并不特别喜欢。毕竟，“最好的集成测试是一个好的编译器”，一个有用的推论将是“最糟糕的集成测试是崩溃的生产版本，希望有人给你发邮件”。

这个主题有很多学术论文，我最喜欢的是基于博士论文的[Coeffect](https://tomasp.net/coeffects/)网站和[Effects as Capabilities](https://dl.acm.org/doi/10.1145/3428194)。

## 异常处理是上下文。

我从研究中得到的一个有趣的见解是，异常处理基本上是上下文的一个特殊情况。抛出的异常会在调用堆栈上传播，直到找到一个接受它的`catch`块。我们可以修改这个系统以实现看起来非常像上下文的某些功能：

这个示例打印：“Hi！”然后是“HI！”

这对于`sayHi`及其内部调用的任何函数都有效，无需将`Logger`作为参数传递！明显的问题是，`throw LogText()`行后的任何代码都将永远不会运行。另一个问题是，这实际上仍然没有在编译时进行检查。调用没有`LogText`的catch块的`sayHi`将会导致整个程序崩溃。

这两者都不是根本问题，只是语言设计的选择。异常处理程序可以有一个 `continue` 关键字，恢复抛出异常的函数，就好像它从未抛出异常一样。编译器可以确保每个抛出的异常都在某处被捕获 —— Java 已经做到了，尽管它忽略了 RuntimeExceptions。

就个人而言，我不认为通过黑客方式处理 try/catch 块是实现上下文管理的好方法，但这确实表明上下文并非一个完全破坏每个现有语言特性并使编译器速度减慢到龟速的全新范式。这只是异常处理的强化版。

# 结论

这篇文章是[“Zoom Out”: The missing feature of IDEs](/source-and-buggy/zoom-out-the-missing-feature-of-ides-f32d0f36f392)的精神续篇。两者都涉及同样的问题：我们可以看到代码库的各个部分，但却看不到它们如何相互关联。代码不仅仅是一堆文本文件，还是一个逻辑互联的图形，往往太过庞大，难以在我们脆弱的人类大脑中完全理解。认为我们可以在没有计算机帮助的情况下捕获所有死锁或优化线程利用率，是傲慢的想法。

就像任何事情一样，都存在权衡。在这里，我理想的解决方案增加了编程语言的复杂性并减慢了编译器的速度。这将需要开发一套新的最佳实践，只有在人们以各种可想象的方式失败之后才能确定。

优点在于它使程序员拥有更多的表达能力，特别是允许我们限制未来程序员对我们代码库的操作。*在这个项目中，我们不允许从 UI 线程进行网络调用*。我可以在代码审查指南中写上这句话，但即使是最聪明的工程师有时也会犯错。唯一真正的保证是编译时的保证。

当然，写博客文章与解决问题是非常不同的。最理想的情况是，你读到这篇文章，并开始思考上下文如何应用到你的工作中。也许你会与他人分享，他们又会与他人分享，最终写出一个提案，被纳入一个生产语言中。从 A 点到 B 点的路径并不容易，中间还有许多奇怪和不可思议的步骤。从想法到产品的路径，像许多事情一样，是一个鲁伯·戈尔德伯格机器。
