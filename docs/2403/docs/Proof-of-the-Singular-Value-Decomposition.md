<!--yml
category: 未分类
date: 2024-05-27 14:55:16
-->

# Proof of the Singular Value Decomposition

> 来源：[https://gregorygundersen.com/blog/2018/12/20/svd-proof/](https://gregorygundersen.com/blog/2018/12/20/svd-proof/)

The existence claim for the singular value decomposition (SVD) is quite strong: “Every matrix is diagonal, provided one uses the proper bases for the domain and range spaces” [(Trefethen & Bau III, 1997)](#trefethen1997numerical). MIT professor Gilbert Strang has a [wonderful lecture](https://www.youtube.com/watch?v=Nx0lRBaXoz4) on the SVD, and he includes an existence proof for the SVD. The goal of this post is to force myself to walk through his proof carefully. For legibility, I break the proof into two sections: an overview and details. I hope this allows the reader to get the big picture of the proof while consulting details as needed.

Note that while the SVD holds for complex matrices, we restrict ourselves to real-valued matrices in this proof. Trefethen and Bau have a proof for the existence and uniqueness of the SVD for complex matrices, but I found Strang’s proof more instructive.

If you’re unfamiliar with the SVD, please see my previous post on a [geometrical interpretation of it](/blog/2018/12/10/svd/).

## Proof

Consider an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math>m×n matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A with rank <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math>r. The matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top} A</annotation></semantics></math>A⊤A is therefore symmetric and positive semi-definite (PSD) ([Details, Section 1](#1-gram-matrices-as-positive-semi-definite)). This means the matrix is diagonalizable with an eigendecomposition of the form:

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mo>=</mo><mi>V</mi><mi mathvariant="normal">Λ</mi><msup><mi>V</mi><mi mathvariant="normal">⊤</mi></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>λ</mi><mi>i</mi></msub><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup></mrow> <annotation encoding="application/x-tex">A^{\top} A = V \Lambda V^{\top} = \sum_{i=1}^{n} \lambda_i \textbf{v}_i \textbf{v}_i^{\top} = \sum_{i=1}^{n} (\sigma_i)^2 \textbf{v}_i \textbf{v}_i^{\top}</annotation></semantics></math> A⊤A=VΛV⊤=i=1∑n​λi​vi​vi⊤​=i=1∑n​(σi​)2vi​vi⊤​

where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>V is an orthonormal matrix whose columns are the eigenvectors of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top} A</annotation></semantics></math>A⊤A and where <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">r \leq n</annotation></semantics></math>r≤n and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mtext>rank</mtext><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>rank</mtext><mo stretchy="false">(</mo><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r = \text{rank}(A) = \text{rank}(A^{\top} A)</annotation></semantics></math>r=rank(A)=rank(A⊤A) ([Details, Section 2](#2-a-and-atop-a-have-the-same-rank)). The second equality above, which is a sum of matrices, holds [because <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math>Λ is diagonal](https://math.stackexchange.com/a/2306159/159872).

We have defined a quantity <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_i</annotation></semantics></math>σi​ (the *singular values*) as the square root of the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>i-th eigenvalue; we know we can take the square root of our eigenvalues because PSD matrices can be equivalently characterized as matrices with non-negative eigenvalues ([Details, Section 3](#3-the-eigenvalues-of-psd-matrices-are-all-non-negative)).

For the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>i-th eigenvector-eigenvalue pair, we have

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><mi mathvariant="normal">.</mi></mrow> <annotation encoding="application/x-tex">A^{\top} A \textbf{v}_i = (\sigma_i)^2 \textbf{v}_i.</annotation></semantics></math> A⊤Avi​=(σi​)2vi​.

Next comes what is, at least in my mind, the critical step in the proof. For now, assume that we have a full-rank matrix (<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub><mo>></mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sigma_i > 0</annotation></semantics></math>σi​>0 for all <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>i). Define a new vector <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​ such that,

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac><mi mathvariant="normal">.</mi></mrow> <annotation encoding="application/x-tex">\textbf{u}_i = \frac{A \textbf{v}_i}{\sigma_i}.</annotation></semantics></math> ui​=σi​Avi​​.

By construction, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​ is a unit eigenvector of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤ ([Details, Section 4](#4-textbfu_i-is-a-unit-eigenvector-of-aatop)). Now let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>V be an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math>n×n matrix—because <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top} A</annotation></semantics></math>A⊤A is <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math>n×n—where the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>i-th column is <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​; let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>U be an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m \times m</annotation></semantics></math>m×m matrix—because <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A \textbf{v}_i</annotation></semantics></math>Avi​ is an <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>m-vector—where the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>i-th column is <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​; and let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>Σ be a diagonal matrix whose <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>i-th element is <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_i</annotation></semantics></math>σi​. Then we can express the relationships we have so far in matrix form as:

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>U</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><mi>V</mi><msup><mi mathvariant="normal">Σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>U</mi><mi mathvariant="normal">Σ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><mi>V</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>A</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>U</mi><mi mathvariant="normal">Σ</mi><msup><mi>V</mi><mi mathvariant="normal">⊤</mi></msup></mrow></mstyle></mtd></mtr></mtable> <annotation encoding="application/x-tex">\begin{aligned} U &= A V \Sigma^{-1} \\ U \Sigma &= A V \\ A &= U \Sigma V^{\top} \end{aligned}</annotation></semantics></math> UUΣA​=AVΣ−1=AV=UΣV⊤​

where we use the fact that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><msup><mi>V</mi><mi mathvariant="normal">⊤</mi></msup><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">VV^{\top} = I</annotation></semantics></math>VV⊤=I and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\Sigma^{-1}</annotation></semantics></math>Σ−1 is a diagonal matrix where the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>i-th value is the reciprocal of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_i</annotation></semantics></math>σi​. And we’re done. Note that the first <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math>r columns of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>V are an orthonormal basis for the row space of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A, while the first <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math>r columns of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>U are an orthonormal basis for the column space of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A.

In the low-rank scenario, some <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sigma_i = 0</annotation></semantics></math>σi​=0. Provided the <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_i</annotation></semantics></math>σi​ are sorted, we can complete <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>U by adding additional column vectors that span <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^m</annotation></semantics></math>Rm and then add rows of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math>0-vectors to <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>Σ. See Figure <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math>7 [here](http://gregorygundersen.com/blog/2018/12/10/svd/).

## Details

### 1\. Gram matrices as positive semi-definite

Gram matrices are PSD. Consider an arbitrary Gram matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><msup><mi>M</mi><mi mathvariant="normal">⊤</mi></msup><mi>M</mi></mrow><annotation encoding="application/x-tex">G = M^{\top} M</annotation></semantics></math>G=M⊤M. Then we have:

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><mi>G</mi><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><msup><mi>M</mi><mi mathvariant="normal">⊤</mi></msup><mi>M</mi><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mtext mathvariant="bold">x</mtext><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup><mi>M</mi><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mtext mathvariant="bold">x</mtext><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable> <annotation encoding="application/x-tex">\begin{aligned} \textbf{x}^{\top} G \textbf{x} &= \textbf{x}^{\top} M^{\top} M \textbf{x} \\ &= (M \textbf{x})^{\top} M \textbf{x} \\ &= (M \textbf{x})^2 \\ &\geq 0 \end{aligned}</annotation></semantics></math> x⊤Gx​=x⊤M⊤Mx=(Mx)⊤Mx=(Mx)2≥0​

If that last step is not obvious, let <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">z</mtext><mo>=</mo><mi>M</mi><mtext mathvariant="bold">x</mtext></mrow><annotation encoding="application/x-tex">\textbf{z} = M \textbf{x}</annotation></semantics></math>z=Mx and note that

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">z</mtext><mi mathvariant="normal">⊤</mi></msup><mtext mathvariant="bold">z</mtext><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow> <annotation encoding="application/x-tex">\textbf{z}^{\top} \textbf{z} = \sum_{i=1}^{N} (z_i)^2.</annotation></semantics></math> z⊤z=i=1∑N​(zi​)2.

In general, positive-definiteness is required for any operation to be an inner product.

### 2\. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top} A</annotation></semantics></math>A⊤A have the same rank

To show that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>rank</mtext><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>rank</mtext><mo stretchy="false">(</mo><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{rank}(A) = \text{rank}(A^{\top} A)</annotation></semantics></math>rank(A)=rank(A⊤A), it is sufficient to show that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A \textbf{x} = \textbf{0}</annotation></semantics></math>Ax=0 and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A^{\top} A \textbf{x} = \textbf{0}</annotation></semantics></math>A⊤Ax=0 have the same solutions, i.e. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext><mo>⟺</mo><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A \textbf{x} = \textbf{0} \iff A^{\top} A \textbf{x} = \textbf{0}</annotation></semantics></math>Ax=0⟺A⊤Ax=0. This makes sense because *rank* is just the maximal number of linearly independent columns, and a set of vectors <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mtext mathvariant="bold">x</mtext><mn>1</mn></msub><mo separator="true">,</mo><msub><mtext mathvariant="bold">x</mtext><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mtext mathvariant="bold">x</mtext><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\\{\textbf{x}_1, \textbf{x}_2, \dots \textbf{x}_k\\}</annotation></semantics></math>x1​,x2​,…xk​ are linearly *dependent* if there exists scalars <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_1, a_2, \dots, a_k</annotation></semantics></math>a1​,a2​,…,ak​, not all zero, such that

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mtext mathvariant="bold">x</mtext><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mtext mathvariant="bold">x</mtext><mn>2</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><mi>k</mi></msub><msub><mtext mathvariant="bold">x</mtext><mi>k</mi></msub><mo>=</mo><mtext mathvariant="bold">0</mtext><mi mathvariant="normal">.</mi></mrow> <annotation encoding="application/x-tex">a_1 \textbf{x}_1 + a_2 \textbf{x}_2 + \dots + a_k \textbf{x}_k = \textbf{0}.</annotation></semantics></math> a1​x1​+a2​x2​+⋯+ak​xk​=0.

Now if <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A \textbf{x} = \textbf{0}</annotation></semantics></math>Ax=0, then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mo stretchy="false">(</mo><mi>A</mi><mtext mathvariant="bold">x</mtext><mo stretchy="false">)</mo><mo>=</mo><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mtext mathvariant="bold">0</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A^{\top} (A \textbf{x}) = A^{\top} \textbf{0} = \textbf{0}</annotation></semantics></math>A⊤(Ax)=A⊤0=0.

If <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">A^{\top} A \textbf{x} = \textbf{0}</annotation></semantics></math>A⊤Ax=0, then

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>x</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>A</mi><mtext mathvariant="bold">x</mtext><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mtext mathvariant="bold">0</mtext><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable> <annotation encoding="application/x-tex">\begin{aligned} A^{\top} A \textbf{x} &= \textbf{0} \\ x^{\top} A^{\top} A \textbf{x} &= \textbf{0} \\ (A \textbf{x})^{\top} A \textbf{x} &= \textbf{0}. \end{aligned}</annotation></semantics></math> A⊤Axx⊤A⊤Ax(Ax)⊤Ax​=0=0=0.​

Note that for any vector <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">v</mtext></mrow><annotation encoding="application/x-tex">\textbf{v}</annotation></semantics></math>v, by definition of the inner product, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">v</mtext><mi mathvariant="normal">⊤</mi></msup><mtext mathvariant="bold">v</mtext><mo>=</mo><mn>0</mn><mo>⟺</mo><mtext mathvariant="bold">v</mtext><mo>=</mo><mtext mathvariant="bold">0</mtext></mrow><annotation encoding="application/x-tex">\textbf{v}^{\top} \textbf{v} = 0 \iff \textbf{v} = \textbf{0}</annotation></semantics></math>v⊤v=0⟺v=0.

### 3\. The eigenvalues of PSD matrices are all non-negative

An equivalent characterization of a PSD matrix is that all its eigenvalues are non-negative. First, consider a real symmetric matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A. Since it is real and symmetric, it has an eigendecomposition of the form:

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>Q</mi><mi mathvariant="normal">Λ</mi><msup><mi>Q</mi><mi mathvariant="normal">⊤</mi></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mtext mathvariant="bold">q</mtext><mi>n</mi></msub><msub><mi>λ</mi><mi>n</mi></msub><msubsup><mtext mathvariant="bold">q</mtext><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup></mrow> <annotation encoding="application/x-tex">A = Q \Lambda Q^{\top} = \sum_{n=1}^{N} \textbf{q}_n \lambda_n \textbf{q}_n^{\top}</annotation></semantics></math> A=QΛQ⊤=n=1∑N​qn​λn​qn⊤​

And therefore:

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><mo fence="false">(</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mtext mathvariant="bold">q</mtext><mi>n</mi></msub><msub><mi>λ</mi><mi>n</mi></msub><msubsup><mtext mathvariant="bold">q</mtext><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup><mo fence="false">)</mo><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>λ</mi><mi>n</mi></msub><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><msub><mtext mathvariant="bold">q</mtext><mi>n</mi></msub><msubsup><mtext mathvariant="bold">q</mtext><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup><mtext mathvariant="bold">x</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>λ</mi><mi>n</mi></msub><mo stretchy="false">(</mo><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><msub><mtext mathvariant="bold">q</mtext><mi>n</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr></mtable> <annotation encoding="application/x-tex">\begin{aligned} \textbf{x}^{\top} A \textbf{x} &= \textbf{x}^{\top} \Big( \sum_{n=1}^{N} \textbf{q}_n \lambda_n \textbf{q}_n^{\top} \Big) \textbf{x} \\ &= \sum_{n=1}^{N} \lambda_n \textbf{x}^{\top} \textbf{q}_n \textbf{q}_n^{\top} \textbf{x} \\ &= \sum_{n=1}^{N} \lambda_n (\textbf{x}^{\top} \textbf{q}_n)^2 \end{aligned}</annotation></semantics></math> x⊤Ax​=x⊤(n=1∑N​qn​λn​qn⊤​)x=n=1∑N​λn​x⊤qn​qn⊤​x=n=1∑N​λn​(x⊤qn​)2​

This final expression is greater or equal to zero if all the eigenvalues <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_n</annotation></semantics></math>λn​ are non-negative. So *if* that is true, the matrix <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A is PSD.

Next, consider a matrix that is PSD, so:

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">x</mtext><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><mtext mathvariant="bold">x</mtext><mo>≥</mo><mn>0</mn></mrow> <annotation encoding="application/x-tex">\textbf{x}^{\top} A \textbf{x} \geq 0</annotation></semantics></math> x⊤Ax≥0

Now consider an arbitrary eigenvector of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A, <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​. Since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A is PSD, we know:

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>λ</mi><mi>i</mi></msub><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable> <annotation encoding="application/x-tex">\begin{aligned} \textbf{v}_i^{\top} A \textbf{v}_i &= \textbf{v}_i^{\top} \lambda_i \textbf{v}_i \\ &= \lambda_i \textbf{v}_i^{\top} \textbf{v}_i \\ &\geq 0 \end{aligned}</annotation></semantics></math> vi⊤​Avi​​=vi⊤​λi​vi​=λi​vi⊤​vi​≥0​

Since <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i^{\top} \textbf{v}_i</annotation></semantics></math>vi⊤​vi​ is necessarily non-negative, then <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_i</annotation></semantics></math>λi​ must be non-negative for <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_i \textbf{v}_i^{\top} \textbf{v}_i \geq 0</annotation></semantics></math>λi​vi⊤​vi​≥0 to hold.

### 4\. <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​ is a unit eigenvector of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤

To see that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​ is an eigenvector of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤, note that

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mo fence="false">(</mo><mfrac><mrow><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac><mo fence="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><mfrac><mn>1</mn><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>A</mi><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub><mfrac><mn>1</mn><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr></mtable> <annotation encoding="application/x-tex">\begin{aligned} AA^{\top} \textbf{u}_i &= AA^{\top} \Big( \frac{A \textbf{v}_i}{\sigma_i} \Big) \\ &= AA^{\top} A \textbf{v}_i \frac{1}{\sigma_i} \\ &= A (\sigma_i)^2 \textbf{v}_i \frac{1}{\sigma_i} \\ &= (\sigma_i)^2 \textbf{u}_i \end{aligned}</annotation></semantics></math> AA⊤ui​​=AA⊤(σi​Avi​​)=AA⊤Avi​σi​1​=A(σi​)2vi​σi​1​=(σi​)2ui​​

where step 2-3 applies the definition of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​ as an eigenvector of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top} A</annotation></semantics></math>A⊤A and step 3-4 applies the definition of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​.

To see that <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{u}_i</annotation></semantics></math>ui​ is unit, note that

<math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mtext mathvariant="bold">u</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext mathvariant="bold">u</mtext><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mo fence="false">(</mo><mfrac><mrow><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac><msup><mo fence="false">)</mo><mi mathvariant="normal">⊤</mi></msup><mfrac><mrow><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mo fence="false">(</mo><mfrac><mrow><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac><mo fence="false">)</mo><mfrac><mrow><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mfrac><mrow><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><mrow><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mfrac><mrow><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><mrow><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msubsup><mtext mathvariant="bold">v</mtext><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable> <annotation encoding="application/x-tex">\begin{aligned} \textbf{u}_i^{\top} \textbf{u}_i &= \Big(\frac{A \textbf{v}_i}{\sigma_i} \Big)^{\top} \frac{A \textbf{v}_i}{\sigma_i} \\ &= \Big( \frac{\textbf{v}_i^{\top} A^{\top}}{\sigma_i} \Big) \frac{A \textbf{v}_i}{\sigma_i} \\ &= \frac{\textbf{v}_i^{\top} A^{\top} A \textbf{v}_i}{(\sigma_i)^2} \\ &= \frac{\textbf{v}_i^{\top} (\sigma_i)^2 \textbf{v}_i}{(\sigma_i)^2} \\ &= \textbf{v}_i^{\top} \textbf{v}_i \\ &= 1 \end{aligned}</annotation></semantics></math> ui⊤​ui​​=(σi​Avi​​)⊤σi​Avi​​=(σi​vi⊤​A⊤​)σi​Avi​​=(σi​)2vi⊤​A⊤Avi​​=(σi​)2vi⊤​(σi​)2vi​​=vi⊤​vi​=1​

where the last step is because <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">v</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\textbf{v}_i</annotation></semantics></math>vi​ is a unit vector as well.

## Conclusion

I found this proof instructive. Importantly, it makes it clear where the relationship between singular values and eigenvalues comes from. The right singular vectors of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A, the columns of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>V, are the set of orthonormal eigenvectors of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top} A</annotation></semantics></math>A⊤A. The left singular vectors of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A, the columns of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>U, are the set of orthonormal eigenvectors of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤. And the non-zero singular values of <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>A are the square roots of the eigenvalues of both <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^{\top}A</annotation></semantics></math>A⊤A and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">AA^{\top}</annotation></semantics></math>AA⊤.

### Acknowledgements

I thank James D., Carl A., and José M. for pointing out a few mistakes in earlier drafts.