<!--yml

分类：未分类

日期：2024-05-27 14:53:30

-->

# Myers 差异算法：第一部分 – The If Works

> 来源：[https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/](https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/)

如果您喜欢本文，我还出版了一本书，通过实现解释Git的内部：[Building Git](https://shop.jcoglan.com/building-git/)。

—

作为程序员，您可能使用像[Git](https://git-scm.com/)这样的版本控制系统，并且大部分时间都在查看差异。您用它们来检查未提交的工作进展，查看单个提交中发生了什么变化，比较两个分支在执行合并之前的情况，等等。差异是您理解软件中事物如何变化的语言。

但除了供人阅读外，差异还被您的版本控制系统用于自动化更改。您可以将差异通过电子邮件发送给某人，他们可以使用`patch`或`git apply`命令将其合并到其工作副本中。`git merge`必须协调和合并两个或多个更改历史记录，以生成单个树，通常在同一文件中协调更改。`git add --patch`允许您从工作副本文件中选择单个更改，而不是将整个文件添加到索引中，这既涉及到您阅读差异，也涉及git选择性地将它们应用到文件的索引版本中。某些版本控制系统使用版本之间的差异作为存储项目历史记录的主要方式，而不是存储每次提交的所有代码的快照。

因此，差异对于版本控制至关重要，但您可能没有考虑它们是如何生成的。通常在阅读差异时，您显然知道应该标记哪些内容为更改。您对将新功能插入文件，删除多余功能或重写部分的直觉心理模型可能已经形成。然而，差异比肉眼看到的要复杂得多，有许多不同的方法可以产生不同的结果。

想一想如何计算差异，以及如何编写一个函数来执行此操作。您可能已经注意到，差异程序只会显示已更改的内容，而不会显示未更改的内容。如何确定文件的哪些部分未发生变化？一旦找到它们之间的差异，如何找到每个版本中下一行文本再次匹配的位置？它比表面看起来的要复杂得多！

在这一系列文章中，我想带你走过Git使用的默认差异算法。它是由Eugene W. Myers开发的，并且[原始论文](http://www.xmailserver.org/diff2.pdf)可以在线获取。尽管论文很短，但数学上非常密集，其重点在于证明其有效性。这里的解释可能没有那么严格，但希望更直观，详细地演示算法实际上做了什么以及它是如何工作的。

在本文的第一篇文章中，我们将阐述算法试图实现的基本模型，并通过一个示例演示如何计算从一个版本到另一个版本的最简编辑集。

举个论文中的例子，假设我们想计算两个字符串之间的差异：

通过“差异”，我们指的是一系列编辑操作，这些操作将字符串*a*转换为字符串*b*。其中一种可能的序列是简单地删除*a*中的每个字符，然后插入*b*中的每个字符，或使用常见的差异表示法：

```
- A
- B
- C
- A
- B
- B
- A + C
+ B
+ A
+ B
+ A
+ C 
```

然而，我们不认为这是一个质量很高的差异，因为它并没有告诉我们很多。对源代码的更改通常会使文件的大部分保持不变，我们确实希望看到*插入或删除*的代码段。一个显示整个文件被删除并替换为新版本的差异对我们没有什么用处。

这两个字符串的更好差异应该是：

```
- A
- B
  C
+ B
  A
  B
- B
  A
+ C 
```

这样就能以尽可能小的改动次数来将*a*变成*b*，因此更好地可视化了真正的变化。这并不是唯一可能的解决方案，例如以下也是有效的：

```
1\.  - A       2\.  - A       3\.  + C
    - B           + C           - A
      C             B             B
    - A           - C           - C
      B             A             A
    + A             B             B
      B           - B           - B
      A             A             A
    + C           + C           + C 
```

然而，它们都是*最小*的：它们使得可能的编辑次数最小，本例中为五次。它们之所以有趣，是因为它们在考虑字符串之间相同部分和执行编辑顺序方面存在差异。通过查看差异，你可能有一个直观的想法，即差异只显示发生变化的内容，但这些例子表明，在两个文件之间的差异有许多可能的解释。

因此，差异算法的目的是提供一种生成差异的策略，使得差异具有某些理想特性。我们通常希望差异尽可能小，但还有其他考虑因素。例如，当你进行更改时，你可能习惯看到删除后跟随插入，而不是反过来。也就是说，你更愿意看到上面的解决方案2而不是解决方案3。当你更改整个代码块时，你希望看到整个块被删除，然后插入新代码，而不是许多删除和插入相互交错。

```
Good:   - one         Bad:    - one
        - two                 + four
        - three               - two
        + four                + five
        + five                + six
        + six                 - three 
```

你可能还希望看到删除或插入的代码与你对代码结构的想法相一致，例如如果你插入一个方法，你希望该方法的`end`被视为新的，而不是前一个方法的`end`：

```
Good:   class Foo                   Bad:    class Foo
          def initialize(name)                def initialize(name)
            @name = name                        @name = name
          end                             +   end
      +                                   +
      +   def inspect                     +   def inspect
      +     @name                         +     @name
      +   end                                 end
        end                                 end 
```

Myers’ 算法是一种这样的策略之一，但它速度快，大多数时候产生的差异质量较好。它通过*贪心*方法实现这一点，即在进行更改之前尝试消耗尽可能多相同的行（因此避免了“错误的`end`”问题），并且在选择时更倾向于删除而不是插入，因此删除优先出现。

Myers 的论文基于这样一个思想，即寻找*最短编辑脚本*（SES）可以被建模为图搜索。让我们取两个字符串，*a* = `ABCABBA` 和 *b* = `CBABAC`，并构建一个图，展示我们可以从*a*到*b*的所有方法。

在下面显示的网格中，(*x*, *y*) 坐标对应于编辑过程中的步骤；在(0,0)处有字符串*a*，也就是说，我们还没有开始编辑。向右移动（增加*x*）对应于从*a*中删除一个字符，例如移动到(1,0)意味着我们从*a*中删除了第一个`A`。向下移动（增加*y*）对应于从*b*中插入一个字符，例如如果我们现在从(1,0)向下移动到(1,1)，我们从*b*中插入第一个`C`，因此我们的编辑后字符串为`CBCABBA`。在位置(4,3)，我们已经将`ABCA`转换为`CBA`，但我们仍然需要将`BBA`转换为`BAC`。右下角位置(7,6)对应于将字符串*a*完全转换为字符串*b*。

除了向右和向下移动外，在某些位置上我们还可以对角移动。当两个字符串在位置的索引处具有相同字符时，例如*a*中的第三个字符和*b*中的第一个字符都是`C`，因此位置(2,0)有一个导致(3,1)的对角线。这对应于消耗两个字符串中相同字符的情况，既不删除也不插入任何内容。

```
 A     B     C     A     B     B     A

    o-----o-----o-----o-----o-----o-----o-----o   0
    |     |     | \   |     |     |     |     |
C   |     |     |  \  |     |     |     |     |
    |     |     |   \ |     |     |     |     |
    o-----o-----o-----o-----o-----o-----o-----o   1
    |     | \   |     |     | \   | \   |     |
B   |     |  \  |     |     |  \  |  \  |     |
    |     |   \ |     |     |   \ |   \ |     |
    o-----o-----o-----o-----o-----o-----o-----o   2
    | \   |     |     | \   |     |     | \   |
A   |  \  |     |     |  \  |     |     |  \  |
    |   \ |     |     |   \ |     |     |   \ |
    o-----o-----o-----o-----o-----o-----o-----o   3
    |     | \   |     |     | \   | \   |     |
B   |     |  \  |     |     |  \  |  \  |     |
    |     |   \ |     |     |   \ |   \ |     |
    o-----o-----o-----o-----o-----o-----o-----o   4
    | \   |     |     | \   |     |     | \   |
A   |  \  |     |     |  \  |     |     |  \  |
    |   \ |     |     |   \ |     |     |   \ |
    o-----o-----o-----o-----o-----o-----o-----o   5
    |     |     | \   |     |     |     |     |
C   |     |     |  \  |     |     |     |     |
    |     |     |   \ |     |     |     |     |
    o-----o-----o-----o-----o-----o-----o-----o   6

    0     1     2     3     4     5     6     7 
```

Myers算法背后的思想非常简单：我们希望尽可能少地从(0,0)到达(7,6)（右下角）。一个“移动”是向右移动（从*a*中删除）或向下移动（从*b*中插入）的单个步骤。我们从*a*到*b*可能采取的最大步数是13：两个字符串的长度之和。

然而，走对角路径是免费的，因为它们不对应于进行*更改*，因此我们希望最大化我们采取的对角步数，并尽量减少向右/向下移动的次数。上面的例子表明，我们实际上可以只进行五次编辑从*a*到*b*，而Myers提供了一种找到这条路径的策略。

为了对算法的工作方式有所直观理解，让我们开始探索这个图。为了尝试找到到达右下角位置的最短路径，我们将同时探索从(0,0)开始的每条可能路径，直到找到达到末尾的路径。我建议你在跟随时保持上面的网格。

让我们从记录我们的初始位置开始，在(0,0)处。

在这个位置，我们有两个选择：我们可以向下移动并达到(0,1)，或者向右移动并达到(1,0)。

现在让我们考虑（0,1）。如果我们从这里向下移动，我们将到达（0,2），但从那里到（1,3）有一条对角线，从（1,3）到（2,4），由于对角线移动是免费的，我们可以说从（0,1）向下移动只需一个步骤就能到达（2,4）。因此，我们将（0,1）到（2,4）的移动标记为我们路径中的单步。

从（0,1）向右移动将我们带到（1,1），然后从那里到（2,2）有一条对角线。让我们在我们的步行中标记这两个移动。

```
0,0 --- 1,0
 |
 |
0,1 --- 2,2
 |
 |
2,4 
```

现在让我们考虑从（0,0）开始的另一条分支，向右移动到（1,0）。从（1,0）向下移动将我们带到（1,1），正如我们刚刚发现的那样，这将使我们到达（2,2）。从（1,0）向右移动将我们带到（2,0），这里有一个对角线到（3,1）。我们将记录这两个步骤。

我将（2,2）记录为通过（1,0）访问，而不是（0,1），稍后的原因会变得清楚。直觉上，考虑到先右移动意味着先进行删除操作，我们通常希望在插入操作之前出现删除操作。

```
0,0 --- 1,0 --- 3,1
 |       |
 |       |
0,1     2,2
 |
 |
2,4 
```

现在我们已经完全探索了图的深度为2的部分，可以开始第三步了。从（2,4）向下移动将我们带到（2,5），然后对角线到（3,6）。从（2,4）向右移动将我们带到（3,4），再次对角线移动到（4,5）。

```
0,0 --- 1,0 --- 3,1
 |       |
 |       |
0,1     2,2
 |
 |
2,4 --- 4,5
 |
 |
3,6 
```

接下来，我们考虑（2,2）。从那里向右移动如前所述：我们移动到（3,2），然后沿着对角线到（5,4）。然而，向下移动引入了一个新的情况：这一移动将我们带到（2,3），而那里没有对角线。现在，如果我们进行通用图搜索，我们会记录从（2,4）向右移动的结果和从（2,2）向下移动的结果，即：

```
0,0 --- 1,0 --- 3,1
 |       |
 |       |
0,1     2,2 --- 5,4
 |        \
 |         \
2,4 -       2,3
 |   \
 |    4,5
3,6 
```

然而，我们正在检查的特定图形结构意味着只需存储在一定编辑步骤后能达到的*最佳*位置就足够了。上面的记录告诉我们，先插入两次然后删除（向下两次，然后向右）可以使我们到达（4,5），而先删除然后插入两次可以使我们到达（2,3）。因此，我们将保留（4,5）的结果，放弃（2,3），表示（4,5）是在任意顺序下进行一次删除和两次插入后能到达的最佳位置。

```
0,0 --- 1,0 --- 3,1
 |       |
 |       |
0,1     2,2 --- 5,4
 |
 |
2,4 --- 4,5
 |
 |
3,6 
```

最后，在我们的深度2扫描中，我们访问了（3,1）。从那里向下移动到（3,2），然后对角线移动到（5,4），因此我们将这个记录为从（3,1）向下移动而不是从（2,2）向右移动。从（3,1）向右移动到（4,1），然后对角线到（5,2）。

这是经过三次移动后的完整记录：

```
0,0 --- 1,0 --- 3,1 --- 5,2
 |       |       |
 |       |       |
0,1     2,2     5,4
 |
 |
2,4 --- 4,5
 |
 |
3,6 
```

现在你可能已经掌握了这个过程，所以让我们快速浏览剩下的移动。我们无法从（3,6）向下移动，而从那里向右移动到（4,6），也可以从（4,5）向下到达，所以我们将其标记为这样。在（4,5）的右侧是（5,5）。

```
0,0 --- 1,0 --- 3,1 --- 5,2
 |       |       |
 |       |       |
0,1     2,2     5,4
 |
 |
2,4 --- 4,5 --- 5,5
 |       |
 |       |
3,6     4,6 
```

（5,5）也是（5,4）的下方，因此我们将其标记，从（5,4）向右移动得到（6,4），带有对角线导向（7,5）。

```
0,0 --- 1,0 --- 3,1 --- 5,2
 |       |       |
 |       |       |
0,1     2,2     5,4 --- 7,5
 |               |
 |               |
2,4 --- 4,5     5,5
 |       |
 |       |
3,6     4,6 
```

从（5,2）向下也导致（7,5），从（5,2）向右移动导致（7,3），从而完成扫描的第四行。

```
0,0 --- 1,0 --- 3,1 --- 5,2 --- 7,3
 |       |       |
 |       |       |
0,1     2,2     5,4 --- 7,5
 |               |
 |               |
2,4 --- 4,5     5,5
 |       |
 |       |
3,6     4,6 
```

现在我们开始第五行。由于我们知道从 *a* 到 *b* 需要仅五次编辑，我们期望此扫描的这一行找到右下角位置，（7,6）。

（4,6）下方没有东西，右边是（5,6），也是从（5,5）向下。（5,5）的右边是（6,5）。

```
0,0 --- 1,0 --- 3,1 --- 5,2 --- 7,3
 |       |       |
 |       |       |
0,1     2,2     5,4 --- 7,5
 |               |
 |               |
2,4 --- 4,5     5,5 --- 6,5
 |       |       |
 |       |       |
3,6     4,6     5,6 
```

最后，从（7,5）向下移动得到（7,6）——最终位置！这肯定比我们通过右、右、下、下、右到达的（6,5）更好，因此我们在移动的轨迹中替换它。

```
0,0 --- 1,0 --- 3,1 --- 5,2 --- 7,3
 |       |       |
 |       |       |
0,1     2,2     5,4 --- 7,5
 |               |       |
 |               |       |
2,4 --- 4,5     5,5     7,6
 |       |       |
 |       |       |
3,6     4,6     5,6 
```

所以算法的基本思想是：给定两个字符串，在表示两者之间编辑空间的图中找到最短路径。我们通过图的广度优先探索每条可能的路线，并在达到最终位置时立即停止。

在下一篇文章中，我们将看看Myers实际上是如何表示这个过程的，并开始考虑在代码中实现它。
