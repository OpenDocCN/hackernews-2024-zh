<!--yml

类别：未分类

日期：2024-05-29 12:38:00

-->

# 构建时间是集体的责任

> 来源：[https://yoyo-code.com/build-time-is-collective-responsibility/](https://yoyo-code.com/build-time-is-collective-responsibility/)

最近又有关于Rust的编译时间的讨论。我觉得在这个主题上总体期望存在一种不匹配。我想解决这个问题，而Rust是一个特别好的例子来说明这一点。

## 你必须尽自己的一份[🔗](#you-have-to-do-your-part)

在我的上一份工作中，我对我们的C++代码库的构建速度慢感到非常沮丧。从前端的世界来看，我习惯于在浏览器中看到代码更改大约在~1s内反映出来，所以5分钟的构建时间对我来说有点太长了。

当我询问一位开发者时，我的担忧多多少少被忽视了。有人告诉我只是接受这个现实并继续前进。有一种回避责任的感觉：“这不是我们的问题，这是强加给我们的，我们是一个本地项目，我们必须编译大量的代码。”但是当我深入研究构建系统时，我发现了一堆琐碎的问题：

+   代码库中最重的部分被构建了两次

+   单个大头文件几乎被包含在每个地方，并编译了100多次

+   许多不必要的包含创建了虚假的构建时间依赖关系

+   由于构建图中一个（可避免的）瓶颈，严重限制了并行性

修复它们通常只需在`CMakeLists.txt`中更改几行或在不同文件之间移动一些代码。最终我减少了几分钟的构建时间。

令人好奇的是，一个问题甚至不是一个构建系统的问题。我被告知要使用`make -j <target>`，这实际上会使计算机一段时间内变砖。不知何故，团队中的每个人都认为`-j`是`-j <num_cpus>`的速记，但实际上它是`-j <infinity>`的速记。这是一个用户问题，但也说明了我的观点。

我们可以抱怨C++许多固有的编译时间问题，关于令人困惑的`make`默认值，一些`CMake`结构并不按您期望的方式运行，但问题是-这是我们的程序，我们的构建配置，我们的责任。**我们责任的一部分是理解这些工具并正确使用它们。**

## 构建器是一个解释器[🔗](#builder-is-an-interpreter)

这就是问题所在：

构建时间永远不会简单快速。构建只是一个程序，就像任何其他程序一样，具有所有程序的问题属性。

Rust在这里是一个完美的例子，因为它具有图灵完备的类型系统，所以你的代码可以被视为在其上层叠加了多个程序。一个程序将由用户运行，但另一个程序将在构建期间由Rust的类型系统解释。

不过，你并不一定要使用一个图灵完备的构建系统。即使你的构建系统不允许任意计算，它可能也有一些方式让你完成大量的工作。正则表达式在一些输入上也不一定要是图灵完备的，但可能运行实际上永远不停。

这意味着你不能把构建时间的担忧完全推卸给第三方，比如编译器开发者。是的，他们也必须尽自己的一份力量，但他们不能对您的程序或构建配置进行基本上有问题的操作负责。

**正如语言开发者在运行时性能方面不负责您的二次方程序一样，他们在构建时间程序方面也不负责您的二次方构建时间程序。**

## 我们共同面对这一挑战 [🔗](#we-are-in-this-together)

公平地说，库和工具链开发者有这样的元责任，即提供和鼓励那些对他们的工具链有益的结构。

我认为这部分原因是为什么首先会有这些不匹配的期望。许多人来自那些没有这些问题的生态系统，因为他们的开发者设计了这些语言或工具链来避免这些问题。对于解释型语言来说尤其如此。

Rust 在这里处于一个更为困难的位置。他们不仅包含了在构建时间上有问题的特性（trait 系统、单态化、宏、match 完备性等等），而且在许多情况下还鼓励使用这些特性。"让无效状态不可表示" 的梗也在这里起了一部分作用。这样做往往意味着将编译器用作定理证明器，这在根本上是一种编译时的权衡。

对于像 Rust 这样的语言，我认为编译时间的考虑应该成为教育和文档的一部分。开发者必须理解他们如何组织代码库或使用某些特性对构建时间有着非平凡的影响。文档还应该为他们提供诊断和解决这些问题的工具。

例如，《Rust 宏小册子》有一个关于一些二次方模式的[性能部分](https://veykril.github.io/tlborm/decl-macros/patterns/tt-muncher.html#performance)。《Rust 性能手册》中也有一个[编译时间](https://nnethercote.github.io/perf-book/compile-times.html)的部分，而且我们也有 [cargo 时间](https://doc.rust-lang.org/cargo/reference/timings.html) 和 [self profile](https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html) 来进行诊断。TypeScript 在他们的 wiki 中也有一个[性能](https://github.com/microsoft/TypeScript/wiki/Performance)部分。
