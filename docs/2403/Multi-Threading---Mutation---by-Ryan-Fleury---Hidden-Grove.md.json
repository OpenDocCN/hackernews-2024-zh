["```\nvoid ThreadEntryPoint(...)\n{\n  U64 x = 0;\n  for(U64 idx = 0; idx < 1000; idx += 1)\n  {\n    x += idx; // will *never* conflict with other threads\n  }\n}\n\nvoid EntryPoint(...)\n{\n  LaunchThread(ThreadEntryPoint, ...);\n  LaunchThread(ThreadEntryPoint, ...);\n}\n```", "```\n`void ThreadEntryPoint(...)\n{\n  static U64 x = 0;\n  for(U64 idx = 0; idx < 1000; idx += 1)\n  {\n    x += idx; // will *always* conflict with other threads\n  }\n}\n\nvoid EntryPoint(...)\n{\n  LaunchThread(ThreadEntryPoint, ...);\n  LaunchThread(ThreadEntryPoint, ...);\n}`\n```", "```\n// retrieves value associated with `key` - if it does not\n// exist inside `table`, then inserts it with initial value\n// of `default_val`\nVal ValFromKey(Table *table, Key *key, Val default_val);\n\nKey key = ...;\nVal val = ValFromKey(table, &key, default_val);\n```", "```\n`void TableInsert(Arena *arena, Table *table, Key *key, Val *val);\nVal *TableLookup(Table *table, Key *key);`\n```", "```\nstruct Node\n{\n  Node *next;\n  Key key;\n  Val val;\n};\n\nstruct Slot\n{\n  Node *first;\n  Node *last;\n};\n\nstruct Table\n{\n  U64 slots_count;\n  Slot *slots;\n};\n```", "```\nTable *dst = ...;\nTable *src = ...;\nfor(U64 idx = 0; idx < slots_count; idx += 1)\n{\n  if(dst->slots[idx].last && src->slots[idx].first)\n  {\n    dst->slots[idx].last->next = src->slots[idx].first;\n    dst->slots[idx].last = src->slots[idx].last;\n  }\n  else if(src->slots[idx].first)\n  {\n    MemoryCopyStruct(&dst->slots[idx], &src->slots[idx]);\n  }\n}\n```", "```\nstruct Table\n{\n  // `slots_count` is omitted - chosen/passed by user\n  Slot *slots;\n};\n\nvoid TableInsert(Arena *arena, Table *table, U64 slots_count, Key *key, Val *val);\nVal *TableLookup(Table *table, U64 slots_count, Key *key);\nvoid TableJoin(Table *dst, Table *src, U64 slots_count);\n```"]