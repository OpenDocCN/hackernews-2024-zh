["```\n# An illustrative data processing pipeline\nDataImporter = Pipeline.new do |pl|\n  pl.step ValidateUserInput\n  pl.step ReadCSV\n  pl.step ValidateData\n  pl.step TransformData\n  pl.step SaveData\nend \n```", "```\n# Initial result\nresult = Result.new([1, 2, 3, 4])\nresult.value # [1, 2, 3, 4]\nresult.continue? # => true \n```", "```\nresult = result.continue([5, 6, 7, 8])\nresult.value # [5, 6, 7, 8]\nresult.continue? # => true\n\nresult = result.halt\nresult.continue? # => false \n```", "```\n#call(Result) Result \n```", "```\nclass MyCustomStep\n  def call(result)\n    # Do something with result.value\n    result.continue(new_value)\n  end\nend \n```", "```\nMyProcStep = proc do |result|\n  # Do something with result.value\n  result.continue(new_value)\nend \n```", "```\nMyPipeline = Pipeline.new do |pl|\n  # Anything that responds to #call can be a step\n  pl.step MyCustomStep.new\n\n  # Or a simple proc. This one limits the set by the first 5 elements\n  pl.step do |result|\n    set = result.value.first(5)\n    result.continue(set)\n  end\nend\n\n# Usage\ninitial_result = Result.new((1..100))\nresult = MyPipeline.call(initial_result)\nresult.value # => [1, 2, 3, 4, 5] \n```", "```\nclass Pipeline\n  attr_reader :steps\n\n  def initialize(&config)\n    @steps = []\n    config.call(self) and @steps.freeze if block_given?\n  end\n\n  # Add a step to the pipeline, either in block form or as a callable object.\n  # @param callable [Object, nil] a step that responds to `#call(Result) Result`\n  # @yield [Result] a step as a block\n  def step(callable = nil, &block)\n    callable ||= block\n    raise ArgumentError, \"Step must respond to #call\" unless callable.respond_to?(:call)\n    steps << callable\n    self\n  end\n\n  # Reduce over steps, call each one in turn,\n  # * [Continue] results are passed on to the next step\n  # * [Halt] results are returned unchanged\n  # @param result [Result]\n  # @return [Result]\n  def call(result)\n    steps.reduce(result) do |r, step|\n      r.continue? ? step.call(r) : r\n    end\n  end\nend \n```", "```\nMyPipeline = Pipeline.new do |pl|\n  # This step halts processing if the set size is greater than 100\n  pl.step do |result|\n    if result.value.size > 100 # value to bit. Halt.\n      return result.halt\n    else # nothing to do. Continue.\n      result\n    end\n  end\n\n  # Any further steps here will not be executed\n  # if the pipeline is halted in the step above\nend \n```", "```\n# @param result [Result]\n# @return [Result]\ndef call(result)\n  steps.reduce(result) do |r, step|\n    if r.continue? # if the result is a Continue, invoke the next step\n      step.call(r)\n    else # if the result is a Halt, return it unchanged\n      r\n    end\n  end\nend \n```", "```\n#call(Result[Continue]) [Result[Continue], Result[Halt]] \n```", "```\n# A portable step to validate set size\nclass ValidateSetSize\n  # @param lte [Integer] the maximum size allowed (Less Than or Equal)\n  def initialize(lte:) = @lte = lte\n\n  def call(result)\n    return result.halt if result.value.size > @lte\n    result\n  end\nend\n\n# A step to multiply each number in the set by a factor\n# This one is a Proc that returns a Proc.\nMultiplyBy = proc do |factor|\n  proc do |result|\n    result.continue(result.value.map { |n| n * factor })\n  end\nend\n\n# Limit set to first N elements\nLimitSet = proc do |limit|\n  proc do |result|\n    result.continue(result.value.first(limit))\n  end\nend\n\n# Compose the pipeline\nNumberCruncher = Pipeline.new do |pl|\n  pl.step { |r| puts 'Logging'; r }\n  pl.step ValidateSetSize.new(lte: 100)\n  pl.step MultiplyBy.(2)\n  pl.step LimitSet.(5)\nend \n```", "```\ninitial_result = Result.new((1..101))\nresult = NumberCruncher.call(initial_result)\nresult.continue? # => false \n```", "```\ninitial_result = Result.new((1..99))\nresult = MyPipeline.call(initial_result)\nresult.continue? # => true\n# Each number in set was multiplied by 2, then limited to the first 5\nresult.value # => [2, 4, 6, 8, 10] \n```", "```\nBigPipeline = Pipeline.new do |pl|\n  pl.step Step1 # a regular step\n  pl.step NumberCruncher # a nested pipeline\n  pl.step Step3 # another regular step\nend \n```", "```\n# A component to validate and coerce a set of numbers\n# It returns a 2-step pipeline that can be composed into a larger pipeline\nmodule NumberValidation\n  def self.new(lte:)\n    Pipeline.new do |pl|\n      pl.step ValidateSetSize.new(lte: lte)\n      pl.step CoerceToIntegers\n    end\n  end\n\n  CoerceToIntegers = proc do |result|\n    result.continue(result.value.map(&:to_i))\n  end\nend\n\n# Compose a larger pipeline\nBigPipeline = Pipeline.new do |pl|\n  pl.step Step1\n  pl.step NumberValidation.new(lte: 100) # a nested pipeline\n  pl.step Step3\nend \n```", "```\nclass NumberValidation\n  def initialize(lte:)\n    @pipeline = Pipeline.new do |pl|\n      pl.step ValidateSetSize.new(lte: lte)\n      # Use a Method object as step\n      # https://ruby-doc.org/3.3.0/Method.html\n      pl.step method(:coerce_to_integers)\n    end\n  end\n\n  # Expose the Step interface\n  # to make instances of this class behave like a step\n  def call(result) = @pipeline.call(result)\n\n  private def coerce_to_integers(result)\n    result.continue(result.value.map(&:to_i))\n  end\nend \n```"]