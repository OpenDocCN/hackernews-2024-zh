- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:33:33'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'My favourite data structure: The trie | James'' Coffee Blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://jamesg.blog/2024/01/16/trie/](https://jamesg.blog/2024/01/16/trie/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Suppose you want to build a predictive text engine. Given a few letters, you
    want to predict the end of a word. Suppose we have the string "co". The next word
    could be:'
  prefs: []
  type: TYPE_NORMAL
- en: Cobalt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coffee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Co-operate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or many other words.
  prefs: []
  type: TYPE_NORMAL
- en: Given a dictionary of all words in the English language, you could find all
    the words that start with "co" and pick one to recommend. But how would you pick
    one to recommend?
  prefs: []
  type: TYPE_NORMAL
- en: A good answer to this is to use word probabilities. You could have a reference
    text with a range of different texts from which you calculate how likely a word
    is to be used. You could tune this based on actual usage, too. If someone types
    "cobalt" a lot (I don't know why they would, but okay :D), you could rank "Cobalt"
    higher when choosing a word to recommend for the string "co".
  prefs: []
  type: TYPE_NORMAL
- en: 'We are missing one piece: how do we do this efficiently?'
  prefs: []
  type: TYPE_NORMAL
- en: That is where the trie comes in, my favourite data structure.
  prefs: []
  type: TYPE_NORMAL
- en: What is a trie?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The trie is a deeply nested tree. The structure is commonly used for predictive
    text engines because you can represent all strings as a tree. Then, you can use
    word probabilities to decide on what word you should recommend. This could be
    done by using a reference corpus of millions of words from English publications
    to identify how common dfifferent words are.
  prefs: []
  type: TYPE_NORMAL
- en: For next word prediction, a trie might be built at the letter level. This means
    that every letter has a value and also links to every other possible letter that
    could come next.
  prefs: []
  type: TYPE_NORMAL
- en: You can add items to, search for items, and remove items from a trie.
  prefs: []
  type: TYPE_NORMAL
- en: A trie, step by step
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's mock up a trie to see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our trie will contain two words:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following trie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Every possible letter is a key in our trie. Above, our trie is represented as
    a dictionary. In a real implementation, a trie might be represented as a set of
    classes, as is common in tree-based algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every key has two possible properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*`, which is the probability the word should be recommended, and;'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dictionary that contains all possible next letters, or a number if there are
    no more letters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose we only want to get words that start with "co". Here is some pseudo
    code about how we would do this if our Trie was a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then recurse down all of the keys in "o" to calculate the next possible
    words. In this example, we can make two words:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could refine our search by adding another character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*` whose value is 0.1 represents "cod" (as in the fish). The "e" tells
    us there is one more letter that can follow "cod": "e". The value for this is
    "7.3".'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say we traverse our whole tree for "co" that we made earlier. We
    would end up with two values:'
  prefs: []
  type: TYPE_NORMAL
- en: We can order these and choose the one with the highest probability for our next
    word.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a trie! (Python edition)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to use a Trie in Python, I recommend the [pygtrie](https://pygtrie.readthedocs.io/en/latest/)
    library, originally developed by Google. This library has pre-built utilities
    for accessing items in a trie, traversing the Trie, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we create a trie with three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the code, we search the trie to find all words that start with
    "co".
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can sort the words by probability using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion and resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The trie is a tree data structure. In a trie, every node has a value for the
    node itself and a set of nodes that you can traverse. You can represent words
    as a trie to efficiently find all words that start with a given prefix. Because
    you can give each node a value, you can attach probabilities to each word in the
    trie. This is ideal for next word prediction, where you can extract candidates
    for a next word from the trie using letters someone has already typed and then
    rank them based on the probabilities associated with each node.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find if a word is not in the trie efficiently. To do so, you would
    split up a word (i.e. "codep") into its letters and search for each one `trie["c"]["o"]["d"]["e"]["p"]`.
    If there is no value associated with the result, you know the word is not in the
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: For a detailed breakdown of the trie data structure, refer to the [Trie Wikipedia
    page](https://en.wikipedia.org/wiki/Trie).
  prefs: []
  type: TYPE_NORMAL
- en: '[Share this post on Hacker News](https://news.ycombinator.com/submitlink?u=https://jamesg.blog//2024/01/16/trie/&t=My%20favourite%20data%20structure:%20The%20trie).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Share this post on Lobste.rs](https://lobste.rs/stories/new?url=https://jamesg.blog//2024/01/16/trie/&title=My%20favourite%20data%20structure:%20The%20trie).'
  prefs: []
  type: TYPE_NORMAL
