- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:50:40'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Maybe Functions | blog.benwinding
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.benwinding.com/maybe-functions/](https://blog.benwinding.com/maybe-functions/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The maybe function is a subtle monster that spreads it’s tentacles across the
    code-base. It’s alternating functionality of “*does/doesn’t do something*” makes
    code hard to understand, maintain and debug.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Example
  id: totrans-split-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s a specific example, it’s a “maybe” function as it only returns the friends
    of a user, if the user is logged in. Basically it introduces a possible `return
    null`.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-10
  prefs: []
  type: TYPE_PRE
- en: '|'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: '*Notes:*'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: This is highly related to the “Null Object Pattern”, but I thought I would explain
    it from the perspective of functions.
  id: totrans-split-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s also important to note here, that in the wild “maybe functions” might not
    be conveniently prefixed with “maybe”…
  id: totrans-split-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So what are the trade-off’s when using “maybe functions”?
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  id: totrans-split-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validation logic coupled with implementation
  id: totrans-split-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy for the caller, can be called in many places
  id: totrans-split-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  id: totrans-split-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Caller has less control, they depend on validation hidden in “maybe function”
  id: totrans-split-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hides complexity but doesn’t actually remove it
  id: totrans-split-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things that depend on the output now need to handle the maybeness case
  id: totrans-split-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a “maybe function” is implemented, it makes it far more likely that **more**
    “maybe functions” will be introduced to deal with all the `null` values. Here’s
    some pseudo code to show the basic problem:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
- en: '|'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: You can see how this pattern *maybe* getting out of control… it does look clean
    in the consumer, with no control logic. However the `null` handling spreads to
    all new functions, and obscures what functions are actually doing… which is usually
    “nothing”, so why even call it?
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: How can we improve this?
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: Solution 1 - Lift the maybeness up
  id: totrans-split-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to remove the “maybeness” from functions is to lift up the “maybe”
    logic into the consumer, this removes the possible `null` aspects of the function,
    which allows other functions to remove theirs too!
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-32
  prefs: []
  type: TYPE_PRE
- en: '|'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: This is much easier to understand, as each function does what it says and there’s
    much less “maybeness” to account for.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: Solution 2 - Monads
  id: totrans-split-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s also possible to generalize and isolate the “maybeness” by using monads.
    In the below example, all `null` checks go through “runSafely”, which removes
    a lot of “maybeness” in remaining functions.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-38
  prefs: []
  type: TYPE_PRE
- en: '|'
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: This might be appropriate for a lot of situations, but I believe the 1st solution
    should definitely be reached for first, as it doesn’t rely on another level of
    abstraction.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-split-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maybe functions have always annoyed me personally and they can found in many
    codebases across any language that allows `null`. They seem to be trivial to add,
    but difficult to remove. But hopefully this illustrates the concern and ways to
    fix it.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: “Functions should do something, not *maybe* do something…”
  id: totrans-split-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
