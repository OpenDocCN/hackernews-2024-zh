- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:50:40'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Maybe Functions | blog.benwinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://blog.benwinding.com/maybe-functions/](https://blog.benwinding.com/maybe-functions/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The maybe function is a subtle monster that spreads it’s tentacles across the
    code-base. It’s alternating functionality of “*does/doesn’t do something*” makes
    code hard to understand, maintain and debug.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s a specific example, it’s a “maybe” function as it only returns the friends
    of a user, if the user is logged in. Basically it introduces a possible `return
    null`.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notes:*'
  prefs: []
  type: TYPE_NORMAL
- en: This is highly related to the “Null Object Pattern”, but I thought I would explain
    it from the perspective of functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s also important to note here, that in the wild “maybe functions” might not
    be conveniently prefixed with “maybe”…
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So what are the trade-off’s when using “maybe functions”?
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validation logic coupled with implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy for the caller, can be called in many places
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Caller has less control, they depend on validation hidden in “maybe function”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hides complexity but doesn’t actually remove it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things that depend on the output now need to handle the maybeness case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a “maybe function” is implemented, it makes it far more likely that **more**
    “maybe functions” will be introduced to deal with all the `null` values. Here’s
    some pseudo code to show the basic problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: You can see how this pattern *maybe* getting out of control… it does look clean
    in the consumer, with no control logic. However the `null` handling spreads to
    all new functions, and obscures what functions are actually doing… which is usually
    “nothing”, so why even call it?
  prefs: []
  type: TYPE_NORMAL
- en: How can we improve this?
  prefs: []
  type: TYPE_NORMAL
- en: Solution 1 - Lift the maybeness up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to remove the “maybeness” from functions is to lift up the “maybe”
    logic into the consumer, this removes the possible `null` aspects of the function,
    which allows other functions to remove theirs too!
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This is much easier to understand, as each function does what it says and there’s
    much less “maybeness” to account for.
  prefs: []
  type: TYPE_NORMAL
- en: Solution 2 - Monads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s also possible to generalize and isolate the “maybeness” by using monads.
    In the below example, all `null` checks go through “runSafely”, which removes
    a lot of “maybeness” in remaining functions.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This might be appropriate for a lot of situations, but I believe the 1st solution
    should definitely be reached for first, as it doesn’t rely on another level of
    abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maybe functions have always annoyed me personally and they can found in many
    codebases across any language that allows `null`. They seem to be trivial to add,
    but difficult to remove. But hopefully this illustrates the concern and ways to
    fix it.
  prefs: []
  type: TYPE_NORMAL
- en: “Functions should do something, not *maybe* do something…”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
