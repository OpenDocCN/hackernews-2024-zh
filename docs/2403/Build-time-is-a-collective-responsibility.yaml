- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 12:38:00'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Build time is a collective responsibility
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://yoyo-code.com/build-time-is-collective-responsibility/](https://yoyo-code.com/build-time-is-collective-responsibility/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There's been some talk about Rust's compile time again recently. I feel like
    there's a mismatch of expectations when it comes to this topic in general. I want
    to address that, and Rust is especially good example to illustrate this.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: You have to do your part [🔗](#you-have-to-do-your-part)
  id: totrans-split-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At my previous job, I became pretty frustrated with slow builds of our C++ codebase.
    From the frontend world, I was used to seeing my code changes reflected in the
    browser in ~1s, so 5-minute build time was a bit too much for me.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: 'When I asked one developer about this, my concerns were more or less dismissed.
    I was told to just accept this as reality and move on. There was a sense of avoiding
    responsibility: "this is not our problem, it''s been inflicted on us, we''re a
    native project, we have to compile a lot of code." But as I have dug into the
    build system, I''ve found a bunch of trivial problems:'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: the heaviest part of the codebase was built twice
  id: totrans-split-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: single big header file was included almost everywhere and compiled more than
    100x times
  id: totrans-split-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: many unnecessary includes that created spurious build time dependencies
  id: totrans-split-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Severely limited parallelism because of a single (avoidable) bottleneck in the
    build graph
  id: totrans-split-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing them was often just about changing few lines in `CMakeLists.txt` or moving
    some code around between different files. I shaved off minutes of build time in
    the end.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: Curiously, one problem wasn't even a build system problem. I was told to use
    `make -j <target>`, which actually bricks the computer for a while. Somehow everybody
    on the team just assumed that `-j` is a shorthand for `-j <num_cpus>`, but it's
    actually a shorthand for `-j <infinity>`. That's a user problem, but it also illustrates
    my point.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: We could go rant about many inherent compile time problems of C++, about confusing
    `make` defaults, some `CMake` constructs not doing what you'd expect, but the
    thing is - this is our program, our build configuration, our responsibility. **Part
    of our responsibility is to understand the tools and use them properly.**
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: Builder is an interpreter [🔗](#builder-is-an-interpreter)
  id: totrans-split-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the thing:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: Build time will never be simply fast. Build is just a program, like any other
    one and has all the problematic properties of programs.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a perfect example here, because it has a turing-complete type system,
    so your code can be thought of as a combination of multiple programs layered on
    top of each other. One program will be run by your users, but another program
    will be interpreted by Rust's type system during the build.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to use a turing-complete build system, though. Even if your build
    system doesn't allow arbitrary computation, it probably has some way you can give
    it a lot of work to do. Regex also doesn't have to be Turing complete to run practically
    forever on some inputs.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，你并不一定要使用一个图灵完备的构建系统。即使你的构建系统不允许任意计算，它可能也有一些方式让你完成大量的工作。正则表达式在一些输入上也不一定要是图灵完备的，但可能运行实际上永远不停。
- en: This means that you can't just offload the build time concern to a third party,
    like compiler developers. Yes, they have to do their part, too, but they can't
    take responsibility for your program or build config doing something fundamentally
    problematic.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不能把构建时间的担忧完全推卸给第三方，比如编译器开发者。是的，他们也必须尽自己的一份力量，但他们不能对您的程序或构建配置进行基本上有问题的操作负责。
- en: '**As much as language developers are not responsible for your quadratic program
    when it comes to runtime performance, they are also not responsible for your quadratic
    build-time program.**'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**正如语言开发者在运行时性能方面不负责您的二次方程序一样，他们在构建时间程序方面也不负责您的二次方构建时间程序。**'
- en: We are in this together [🔗](#we-are-in-this-together)
  id: totrans-split-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们共同面对这一挑战 [🔗](#we-are-in-this-together)
- en: To be fair, library and toolchain developers have this meta-responsibility of
    offering and encouraging constructs that work well for their toolchain.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，库和工具链开发者有这样的元责任，即提供和鼓励那些对他们的工具链有益的结构。
- en: I think this is partly why there are these mismatched expectations in the first
    place. Many people come from ecosystems where these concerns don't exist because
    their developers designed these languages or toolchains to avoid them. This is
    especially true for interpreted languages.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这部分原因是为什么首先会有这些不匹配的期望。许多人来自那些没有这些问题的生态系统，因为他们的开发者设计了这些语言或工具链来避免这些问题。对于解释型语言来说尤其如此。
- en: Rust is in a much harder position here. They not only included features that
    are problematic for build time (trait system, monomorphisation, macros, match
    exhaustiveness, ...) but also encouraged their use in many cases. The 'make invalid
    states unrepresentable' meme is also part of the blame here. Doing that often
    implies using the compiler as theorem prover, which is fundamentally a compile
    time trade-off.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 在这里处于一个更为困难的位置。他们不仅包含了在构建时间上有问题的特性（trait 系统、单态化、宏、match 完备性等等），而且在许多情况下还鼓励使用这些特性。"让无效状态不可表示"
    的梗也在这里起了一部分作用。这样做往往意味着将编译器用作定理证明器，这在根本上是一种编译时的权衡。
- en: For languages like Rust, I believe compile time concerns should be part of the
    education and documentation. Developers have to understand that the way they structure
    their codebase or how they use certain features has a non-trivial impact on build
    time. It should also give them tools to diagnose and fix these problems.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 Rust 这样的语言，我认为编译时间的考虑应该成为教育和文档的一部分。开发者必须理解他们如何组织代码库或使用某些特性对构建时间有着非平凡的影响。文档还应该为他们提供诊断和解决这些问题的工具。
- en: For example, The Little Book of Rust Macros has a [performance section](https://veykril.github.io/tlborm/decl-macros/patterns/tt-muncher.html#performance)
    on some quadratic patterns. There's also a [compile times](https://nnethercote.github.io/perf-book/compile-times.html)
    section in The Rust Performance Book, and we also have [cargo timings](https://doc.rust-lang.org/cargo/reference/timings.html)
    and [self profile](https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html)
    to diagnose. Typescript has a [performance](https://github.com/microsoft/TypeScript/wiki/Performance)
    section in their wiki, too.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，《Rust 宏小册子》有一个关于一些二次方模式的[性能部分](https://veykril.github.io/tlborm/decl-macros/patterns/tt-muncher.html#performance)。《Rust
    性能手册》中也有一个[编译时间](https://nnethercote.github.io/perf-book/compile-times.html)的部分，而且我们也有
    [cargo 时间](https://doc.rust-lang.org/cargo/reference/timings.html) 和 [self profile](https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html)
    来进行诊断。TypeScript 在他们的 wiki 中也有一个[性能](https://github.com/microsoft/TypeScript/wiki/Performance)部分。
