- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:31:18'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: A reactionary take on memory safety - lcamtuf’s thing
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://lcamtuf.substack.com/p/a-reactionary-take-on-memory-safety](https://lcamtuf.substack.com/p/a-reactionary-take-on-memory-safety)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I was there when the universe formed: back in the 1990s, when information security
    wasn’t a reputable occupation, when case law was scant, and when every system
    could be breached at will. In the chaos, I saw an opportunity — and I dedicated
    a good portion of my adult life to helping others stay clear of online risks.'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the years, one of the enduring problems I wrestled with was memory
    safety. For folks unfamiliar with the term, it boils down to programming languages
    such as C and C++ not keeping track of the memory allocated to the program and
    not preventing access out of bounds. This gives rise to endemic coding errors
    such as [buffer overflows](https://en.wikipedia.org/wiki/Buffer_overflow) or [use-after-free](https://en.wikipedia.org/wiki/Dangling_pointer).
    With a bit of luck and skill, a subset of these bugs can corrupt program control
    structures and allow attackers to perform actions they’re not otherwise authorized
    to perform.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, there is a growing chorus of voices in the information security community
    positing that memory safety is the most consequential battle of our times; the
    latest salvo in this debate is the [guidance published by The White House](https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf),
    urging the adoption of memory-safe languages across the industry. For many, a
    non-binding document does not go far enough: perhaps the government ought to outlaw
    C and C++ altogether, be it for federal contracts or for any infrastructure deemed
    critical.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: 'This puts me in an awkward position: after all these years fighting for memory
    safety, I’m disagreeing with the proposal to solve the problem once and for all.
    For one, I think that security professionals are too keen to collect paychecks
    for bossing people around and having others do all the hard work. This proposal
    — demanding that developers re-learn their craft — certainly fits that mold.'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: My more pragmatic critique is that I doubt it’s worth the cost. First, only
    a small fraction of memory-unsafe code is realistically exposed to attacks. In
    the context of modern computing paradigms, the primary attack surface is limited
    chiefly to network stacks, browser APIs, and a handful of multimedia transcoding
    libraries. For a handful of VM providers, the hypervisor code is of interest too.
    But together, these components probably represent less than 10% of the codebase
    targeted by the proposed mandates; and perhaps 2% is of major economic interest.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, thanks to the decades of work on low-overhead exploit mitigations
    — notably including [address space randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization)
    and branch tracking — successful exploitation of memory safety issues has gotten
    quite challenging and accounts only for a tiny sliver of the overall volume of
    security incidents. Although memory corruption bugs are favored by some government
    actors, virtually all large-scale breaches trace back to other issues: outdated
    or misconfigured software, phishing, and so on.'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I’m skeptical that a nonspecific mandate to adopt memory-safe languages
    will necessarily nudge developers in the right direction; for every restrictive
    language designed with security in mind, there are dozens of memory-safe choices
    that on balance, introduce more bugs. In this context, the woes associated with
    PHP, SQL, and JavaScript are of special note; the trio is popular for good reasons,
    but is probably responsible for more harm than C and C++. Migrations to languages
    such as Python and Java might be marginally beneficial, but come with a lot of
    baggage too.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: Together, these observations make me doubt that migrating organizations to memory-safe
    languages is a worthwhile intervention today. If we could wave a magic wand to
    transmogrify all C and C++ into Rust, I wouldn’t bat an eye — although I doubt
    it’d alter the landscape of information security in a profound way. Still, in
    a reality where even simply keeping track of your hardware and software assets
    is a formidable challenge for most enterprises, I think that the push for 100%
    memory safety is a grievous misallocation of funds.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: '*For another article on the topic of infosec prioritization, [click here](https://lcamtuf.substack.com/p/product-security-barking-up-the-wrong).
    For a thematic catalog of posts, try [this page](https://lcamtuf.coredump.cx/offsite.shtml).*'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
