<!--yml
category: æœªåˆ†ç±»
date: 2024-05-27 14:57:13
-->

# Building For Builders - deven.codes

> æ¥æºï¼š[https://deven.codes/posts/building-for-builders/](https://deven.codes/posts/building-for-builders/)

Over the course of 2023-ish I wrote two Python frameworks   (1)Iâ€™d like to avoid a semantic debate, but for clarityâ€™s sake when I say, â€œframeworkâ€ I mean a library that holistically and generically targets the way you write applications (or tests in the case of `sundew`) rather than providing a narrow set of functionality. I think there is some unique consideration you have to have when targeting the whole way a developer builds software, but by I expect these learnings are things that would apply to development of any kind of library that you intend other people to use. You might even notice some similarities with good product development practices in general . The first, an open source testing framework called [sundew](https://github.com/devenjarvis/sundew), that attempts to rethink traditional unit testing with the goal of being both faster and more effective. The second, a closed source actor model framework that I wrote with a team, which we will call `pk`. Currently, `pk` is still under development, but it is actively used in production for user-critical systems. Iâ€™ve learned a lot from building both, each with their own successes and failures, and I thought it would be useful to share a personal retrospective on the things Iâ€™ve learned from building them this year.

## Start with a question [#](#start-with-a-question)

When you decide to build a new framework or library, you get an empty canvas to start with. And wow, can an empty canvas be freeing! You can do anything! Paint with your own stroke, make your unique mark on the software world, and do things in ways theyâ€™ve never been done before   (2)The way they *shouldâ€™ve* been done all along, amiright? . But alsoâ€¦ you could do *anything*. There are a lot of problems to solve in the software world, and usually many ways you could go about solving them. As software engineers weâ€™ve heard time and time again that solving one problem really well is much more effective than trying to solve them all at once. Something about â€œboiling the oceanâ€. Yet for some reason many of us find it so hard to find and keep a specific focus when we begin building, especially for projects that are meant to be widely impactful like frameworks. So, how can we get started on the right foot?

Before I started on `sundew`, I was working with a large unit test suite that was comprehensive with high code coverage, but it was painfully slow to run and still let many obvious-in-hindsight bugs slip through to consumers. I had just finished leading a book club for â€œTest-Driven Web Development with Pythonâ€   (3)7/10, I largely recommend if youâ€™re looking to [strengthen your testing skills](https://www.obeythetestinggoat.com/pages/book.html) and couldnâ€™t stop asking myself, â€œHow can I make testing faster *and* more effective? Thereâ€™s got to be a better way!â€. I knew that I needed my test suite to be **faster**, because quick feedback loops pay compound interest when developing software, but I also needed it to be **more effective** at catching bugs before the code got to our customers. Additionally, I didnâ€™t want to spend hours crafting the perfect tests to achieve these goals, I needed my testing framework to be **smart** ğŸ§  too.

Itâ€™s easy to start building a framework or other project with a statement like, â€œIâ€™m going to build a better testing framework!â€, but if you stop and think about it, what does that really tell you about what you plan to build? My experience is that `sundew` shaped up into something powerful because I started with a question instead. More specifically, I believe the very best question you can ask yourself, before writing a line of code, is:

> What is the **problem** I want to solve?

When you ask yourself this, be as specific as you can be. Generic, theoretical problems lead to generic, theoretical solutions that are going to have a much harder time standing the trials of the real world (more on this later). Focus on the pain-points youâ€™ve directly experienced, or *at the least* have directly heard about from others. You should be able to list a few very specific examples where you, or someone you know, hit this problem and the *pain* it caused. The core concepts of `sundew` came from the pain of a slow, incomplete test suite, not from a generic aspiration that I could â€œdo you one betterâ€ over the existing options.

As another example, `pk` was born when my team recognized a growing need for queue worker services that were well modeled as streaming data pipelines. We knew that we wanted to **reduce rework** and the support burden that comes from multiple services reusing data processing steps, which do the same thing but in *slightly* different ways. We also wanted to maintain and improve our standards for building **robust** and **performant** pipelines. And finally, we wanted to be able to **build new pipelines quicker**! We never said â€œWe need to build an actor model framework for Python!â€, we started with the problems that needed to be addressed and asked ourselves the best way to solve those. Our needs and constraints naturally led us to build an actor model framework, which has turned out to be a well fitting solution.

## Define your anti-goals. [#](#define-your-anti-goals)

> â€œExplicit is better than implicitâ€
> 
> Tim Peters, The Zen of Python

Depending on the scope of your problem, youâ€™re likely to find lots of sub-problems, or closely-related problems that you could easily tackle as well. If you arenâ€™t careful, the list of problems you are solving becomes large, and your framework becomes too general to be the *best* solution for your original issue. Thatâ€™s why at the start of a project I like to define **anti-goals** alongside my goals. These are the things that you explicitly *wonâ€™t* solve, not because they arenâ€™t valuable, but because they take away from your focus or expand the scope too far.

In my experience this is most effective when you are building with/for a team of engineers who may all have their own opinions on the scope of the framework you are building. Being clear upfront where the boundaries are for what youâ€™ll build and support go a long way towards gaining alignment. They also create useful conversations when the boundaries you set donâ€™t align with a team membersâ€™s initial expectations. â€œExplicit is better than implicitâ€, especially when setting boundaries.

Anti-goals are helpful for focusing your effort, but they can be even more helpful for defining how you built your framework. Anti-goals represent the closely related problems *you* choose not to tackle, but thereâ€™s a good chance these are the same problems your future users are going to come across and they will require a solution. With this in mind your anti-goals can serve as a guide for where you want to build extension points for your framework. For example, when building `pk` we established upfront that we would build the framework based on the actor model, but it would not be the home for any shared actors, nor would it house connectors for external data outside of a small predefined core set. This meant acknowledging and agreeing upfront that while sharing actors and connectors across pipelines was important, they would need to be built by users in separate modules. This not only set clear boundaries for building our framework, but made it obvious that building shareable actors and defining new data connectors would be extension points for the framework that we needed to get right upfront.

Finally, remember that just like goals, anti-goals are not set in stone. They can change and evolve over time as your project matures and you learn more. Keep revisiting them to add new boundaries where needed, or remove old ones when your userâ€™s needs outweigh the cost in expanding scope.

## Know what already exists [#](#know-what-already-exists)

> â€Everything that can be invented has been invented.â€
> 
> Punch Magazine, vol 116, 1899

If youâ€™ve gotten clear about the problem you are solving, and youâ€™ve fleshed out our anti-goals itâ€™s time to write some code, right? Well.. almost! Now that we know what we want to build, itâ€™s a good idea to make sure someone hasnâ€™t already built it. If itâ€™s a valuable problem you probably arenâ€™t the first one who has hit it and considered solving it so, while solving our own problems is fun and rewarding, itâ€™s worth it to make sure you arenâ€™t reinventing the wheel. You could be tackling the next most important thing on your list instead. That said, there are a couple of ways I recommend *not* going about this process.

The first wrong way to do this, is to do a search, find a library/framework that says itâ€™ll solve your problem in its tagline, throw up your hands because â€everything that can be invented *has* been inventedâ€, and give up. We just went through **a lot of hard work** to get pretty specific on our problem. So take a few more minutes to dig in and make sure this library or framework actually fits the bill. Oftentimes the developer of that framework either had their own very specific problem they are solving, which may not overlap enough with yours, or they fell into one of the traps above and are solving too general of a problem to make it a good fit for what you need. Take a deeper dive and find out. If itâ€™s exactly what you need, perfect! Donâ€™t despair, thank the open source maintainer(s) for saving you 3-12 months of work, and go ahead `pip/npm/cargo/whatever install` your new found solution! Thereâ€™s more work to be done, and other unsolved problems you can put your mind to.

The other bad way to go about this is to immediately nitpick every solution you find, to convince yourself it couldnâ€™t *possibly* solve your problems. NIH (Not-Invented-Here) Syndrome is real and a lot of humans struggle with it   (4)myself included âœ‹ . We want a sense of ownership, a feeling of â€œhey, *I* solved that," and software is a really *really* easy way to scratch that itch. However, as Iâ€™ve said, it is likely that youâ€™ve got plenty of other important problems to tackle, so donâ€™t block yourself solving this issue if you donâ€™t absolutely have to. If you find an existing framework that might be a good fit, rejoice! If itâ€™s 99% of the way there, and itâ€™s open source, consider contributing the 1% you need (or at least opening a PR to ask about it!). The best software happens collaboratively, and oftentimes hitching onto someone elseâ€™s bandwagon is going to be a much more productive way to get where you want to go.

Once youâ€™ve given everything you find a fair shot, and determine they are still missing the mark in significant ways, *then* itâ€™s time to begin the long journey of building your very own framework. Consider adding these to a â€œPrior Artâ€ section of your README now, and get ready to start building ğŸ”¨

## Consider your interface first [#](#consider-your-interface-first)

> Design is really an act of communication, which means having a deep understanding of the person with whom the designer is communicating.
> 
> Donald A. Norman, The Design of Everyday Things Quotes

Itâ€™s finally time to code! But where do we start? At this point, I highly recommend starting by designing the right interface. This is the â€œfrontendâ€ of your framework, and itâ€™s what we mean when we say â€œDeveloper Experienceâ€ (DX). The way it feels to use your framework is going to be a huge factor in adoption, which is *pretty* important assuming you care about anyone else using it. Iâ€™ve learned that the first thing I like to do is mock out and explore the ways someone might use my framework in its hypothetical finished state. It helps start answering questions like:

As I start landing on a possible interface, the next question I explore is, â€œWhat are **other** interfaces I could build instead?â€. Itâ€™s easy to take the first interface that came to mind and run with it; youâ€™ve got a solution, letâ€™s code already! I hear you, spending time considering alternative interfaces for your framework can seem like a waste of time when you have so much to do, but consider one of the following possibilities:

1.  Your first solution might not be your best ğŸ¤·. Remember you are building this framework for other developers too, and what is immediately obvious to you may not resound for your eventual users. Take some time to come up with at least 2 or 3 other ways developers might want to interact with your framework, and then assess their merits side-by-side.
2.  Your first solution *is* the best one ğŸ‰. Thatâ€™s great, good work! However, itâ€™s your users that have to be convinced that youâ€™re on the best path forward. Take the time to consider 2 or 3 other approaches, and solidify your opinions about why the first is the better approach. This gives you much firmer ground to stand on when users come to you with their own vision of how this could be solved in the future. It also builds confidence in your chosen solution, and confidence often translates to focus in my experience.

Iâ€™ll note this is an exercise I go through, not just when beginning the framework, but before every big new feature or rearchitecture. Anything that has the potential to dramatically change the way your users can/will use your framework is worth the extra upfront design time to get it right.

## Use it before itâ€™s ready [#](#use-it-before-its-ready)

Letâ€™s fast forward juuust a bit. Youâ€™ve written hours of code (maybe spread out over the span of a few weeks) and your framework is starting to do *something* like what you dreamed. Itâ€™s still clunky, doesnâ€™t generalize at all, canâ€™t handle a single edge case, and all the documentation on how to use this is in your head (best case scenario). Itâ€™s time for you to start using it!

â€œBut wait Deven! This is but a whisper of the final product itâ€™ll be. This *barely* solves just a part of the problem I worked so hard to define. Itâ€™s definitely not **ready**â€, you protest. Thatâ€™s perfect, itâ€™s exactly where you want it to be when you start using it. You donâ€™t have to share it with anyone else (yet), but itâ€™s time for you to `pip/npm/cargo/whatever install` your framework into another project and start *using* it. And I donâ€™t mean a trivial made-up project acting as a glorified functional test. I mean a true project that has a real-world use case to deliver value to someone; even better if itâ€™s an existing project that is already delivering value. The reason I say this, is that you are now at the first point where you can determine if your theoretical solution has a chance at solving your real-world problems. If it canâ€™t, you want to know that as **soon** as possible, because the pain of pivoting will never be lower than right now.

I mentioned in the opening that I started an open source testing framework called `sundew`, but what I didnâ€™t share is that currently, `sundew` doesnâ€™t have any users ğŸ˜. Itâ€™s not because `sundew` isnâ€™t good, it has features I would kill to have in my regular testing setup, and ones Iâ€™ve yet to come across in any other framework. It really addresses the core problems I had when I sought to build it, and Iâ€™m proud of the solutions I landed on. But, in its current form, it just isnâ€™t usable. I took an opinionated stance on how to write tests with `sundew`, and I thought I was assessing my opinionated solution with the great tests I was writing for `sundew` by using `sundew`. However, it wasnâ€™t until after my first public release that I took the step to start using `sundew` with other non-trivial projects. Thatâ€™s when I realized that itâ€™s just too inflexible to stand up to real world testing needs. Can it be fixed? Absolutely! But the friction for re-architecting `sundew` now is much higher than it wouldâ€™ve been if Iâ€™d realized this and pivoted earlier in the development process. That friction kills momentum, which can be a death blow for a project, especially if itâ€™s something you are building on the side.

`pk` is a counter example. Notice in my opening I said, that while it is still under development, it is actively used in **production**. Myself and a team member started using it for two non-trivial, customer-facing projects as soon as the base functionality was, just barely, present. The learnings from those experiences were tremendously valuable, and several major pivots have been made since, maturing the framework rapidly and delivering value to users much sooner. These are pivots that were not planned, and wouldnâ€™t have been identified until we started using it. Pivots that wouldâ€™ve been much harder to make if we waited for â€œv1.0â€ to start using it. Now weâ€™ve expanded use of the framework across the team and into additional products, still before a v1.0 release. Deploying rapidly and getting feedback earlier in the process enabled me to make adjustments at a lower cost, and increased my chances of building a quality solution over the long term.

## Sample size of 1 isnâ€™t significant [#](#sample-size-of-1-isnt-significant)

Using your framework yourself early on will tell you if your solution is viable, but it wonâ€™t be a good test for if your framework can generalize or if itâ€™s actually enjoyable to anyone else. You are naturally building the solution that makes the most sense to you for the specific problem you have in mind. However, by definition, if you are taking the time to build a framework this isnâ€™t a one-off problem you are solving, and you need to generalize it enough to still be useful within some meaningful range of flavors that your problem comes in. At this point itâ€™s good to get out of your own head, and start getting your framework in the hands of early adopters.

These may be coworkers, developer friends, or strangers on the internet who happen to have the exact problem you have. Doesnâ€™t really matter where you find them, and you donâ€™t need a lot of them, but you do need *at least* 2 or 3 people who are excited and willing to try out what youâ€™ve built so far. You want to do this early, so make sure these are people who understand this doesnâ€™t come with the polish and production-guarantees of a fully baked answer. You also want to make sure these people actually have the problem you are looking to solve, and have a real use case they can try your framework out with. Then, once they are on board, you want to get as much feedback as possible from them. Their reward for using your half-baked solution, is the influence they have on what the full-baked version will look like. Ask them things like:

*   What isnâ€™t intuitive to you?
*   What works, but is painful?
*   What doesnâ€™t work that you *need* to work?

Also make sure you find out â€œWhat do you love about it?â€. Criticism can be hard, but if you are driven by a building a great product itâ€™s also easier to get caught up in all the things you can fix or make better. Weâ€™ve all come across products that we once loved which eventually changed to be â€œbetterâ€, but ended up losing the thing we actually loved in the first place. Make sure you take the time to understand whatâ€™s *really working* and hold on to that when you address what isnâ€™t.

Writing software is, and always will be, a series of trade-offs. Not all trade-offs are equal though, and losing the things your users love to solve the minorly unintuitive is rarely worth it. Find another path forward that preserves the good and eases the bad or, in some cases, stick to your opinions and be okay with it not being everyoneâ€™s cup-o-tea. Just make sure whatever you choose, you make the choice intentionally based on what youâ€™ve learned from actual users. I learned the value of getting what Iâ€™m building in front of people as soon as possible with `pk`, and I believe `sundew` wouldâ€™ve had a lot more initial success if I had done the same.

## Document, document, document [#](#document-document-document)

> This is the Curse of Knowledge. Once we know something, we find it hard to imagine what it was like not to know it. Our knowledge has â€œcursedâ€ us. And it becomes difficult for us to share our knowledge for others, because we canâ€™t really re-create our listenersâ€™ state of mind.
> 
> Chip Heath & Dan Heath, Made to Stick, p.20

The final thing I want to cover seems to also be the bane of many developerâ€™s existence: documentation. Great software documentation regularly gets praised in software engineer circles, but as soon as itâ€™s time to write some no one seems eager to volunteer. We love to think weâ€™ve written â€œself-documentingâ€ code, or that â€œusing it will be obviousâ€, but the reality is if you want anyone else to ever use your framework youâ€™ve got to put the legwork in to create documentation. Preferrably **good** documentation.

If youâ€™ve ever searched GitHub, found a repo that sounds like it may be what you need, and then found it has zero documentation (sometimes not even a README) then you know the frustration of being on the receiving end of undocumented software. Even if it was the perfect solution for what you needed, the cost to understand someone elseâ€™s code and determine whether it actually meets your needs is much too high. Few people are willing to pay that cost, and honestly we shouldnâ€™t be asking them to. Writing documentation might seem like a big upfront investment, but the payoff down the road in adoption of your framework and the reduced support burden of answering the same questions over and over again is huge.

Iâ€™ll wrap up by acknowledging that writing good documentation is *hard*, and I believe that the â€œCurse of Knowledgeâ€ gives us a clue as to why that is. As the creators of a thing, we are de facto the most knowledgeable people in the entire world about said thing, making this curse of knowledge heavier than usual. Itâ€™s hard, maybe impossible, to foresee all the questions a future user will have about your framework, because youâ€™ve **never** known as little about it as they will when they start using it. I like to believe Iâ€™ve written some pretty good documentation for `sundew` and `pk`, not perfect but at the least comprehensive (`pk` has over a dozen wiki documents dedicated to usage and several more dedicate to itâ€™s inner workings). Yet somehow, every new user brings a question that I never even considered or documented but is obviously critical in hindsight. When it comes to solving this, my best learning so far is to start writing your documentation as soon as possible in your software-building journey. Youâ€™ll never know less about your framework than you do today, thus, perhaps unintuitively, youâ€™ll never be closer to your usersâ€™ and their perspective than you are now.

## What I havenâ€™t learned yet [#](#what-i-havent-learned-yet)

Building both `sundew` and `pk` have been incredible learning experiences, and I grew a lot as both a software engineer and communicator. What Iâ€™d like to learn next is how these concepts scale as the framework, and itâ€™s number of users, grow larger. Iâ€™d like to invest some of this year either revisiting `sundew`, or building something new with these learnings.

For anyone out there in the early days of building your own framework, I hope my learnings are helpful for you. Best of luck on your journey!

If youâ€™re a framework-building pro, then Iâ€™d love to hear where I got this right, and where I still have blindspots; Check out my â€œContactâ€ page and let me know what you think!