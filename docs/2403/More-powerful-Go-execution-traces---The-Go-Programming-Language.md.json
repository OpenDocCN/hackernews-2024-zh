["```\n\n    fr := trace.NewFlightRecorder()\n    fr.Start()\n\n    var once sync.Once\n    http.HandleFunc(\"/my-endpoint\", func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n\n        doWork(w, r)\n\n        if time.Since(start) > 300*time.Millisecond {\n\n            once.Do(func() {\n\n                var b bytes.Buffer\n                _, err = fr.WriteTo(&b)\n                if err != nil {\n                    log.Print(err)\n                    return\n                }\n\n                if err := os.WriteFile(\"trace.out\", b.Bytes(), 0o755); err != nil {\n                    log.Print(err)\n                    return\n                }\n            })\n        }\n    })\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n\n```", "```\n\n    r, err := trace.NewReader(os.Stdin)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    var blocked int\n    var blockedOnNetwork int\n    for {\n\n        ev, err := r.ReadEvent()\n        if err == io.EOF {\n            break\n        } else if err != nil {\n            log.Fatal(err)\n        }\n\n        if ev.Kind() == trace.EventStateTransition {\n            st := ev.StateTransition()\n            if st.Resource.Kind == trace.ResourceGoroutine {\n                from, to := st.Goroutine()\n\n                if from.Executing() && to == trace.GoWaiting {\n                    blocked++\n                    if strings.Contains(st.Reason, \"network\") {\n                        blockedOnNetwork++\n                    }\n                }\n            }\n        }\n    }\n\n    p := 100 * float64(blockedOnNetwork) / float64(blocked)\n    fmt.Printf(\"%2.3f%% instances of goroutines blocking were to block on the network\\n\", p)\n\n```"]