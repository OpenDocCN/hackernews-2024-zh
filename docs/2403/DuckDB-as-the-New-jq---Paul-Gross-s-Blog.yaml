- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 12:32:42'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: DuckDB as the New jq - Paul Gross’s Blog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.pgrs.net/2024/03/21/duckdb-as-the-new-jq/](https://www.pgrs.net/2024/03/21/duckdb-as-the-new-jq/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Recently, I’ve been interested in the [DuckDB](https://duckdb.org/) project
    (like a [SQLite](https://www.sqlite.org/) geared towards data applications). And
    one of the amazing features is that it has many data importers included without
    requiring extra dependencies. This means it can natively read and parse JSON as
    a database table, among many other formats.
  prefs: []
  type: TYPE_NORMAL
- en: I work extensively with JSON day to day, and I often reach for [jq](https://jqlang.github.io/jq/)
    when exploring documents. I love `jq`, but I find it hard to use. The syntax is
    super powerful, but I have to study the docs anytime I want to do anything beyond
    just selecting fields.
  prefs: []
  type: TYPE_NORMAL
- en: Once I learned DuckDB could read JSON files directly into memory, I realized
    that I could use it for many of the things where I’m currently using `jq`. In
    contrast to the complicated and custom `jq` syntax, I’m very familiar with SQL
    and use it almost daily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we fetch some sample JSON to play around with. I used the GitHub API
    to grab the repository information from the golang org:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, as a sample question to answer, let’s get some stats on the types of open
    source licenses used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This might not be the best way, but here is what I cobbled together after searching
    and reading some docs for how to do this in `jq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is what it looks like in DuckDB using SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For me, this SQL is much simpler and I was able to write it without looking
    at any docs. The only tricky part is querying nested JSON with the `->>` operator.
    The syntax is the same as the [PostgreSQL JSON Functions](https://www.postgresql.org/docs/current/functions-json.html),
    however, so I was familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we do need the output in JSON, there’s a DuckDB flag for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can still even pretty print with `jq` at the end, after using DuckDB to
    do the heavy lifting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: JSON is just one of the many ways of importing data into DuckDB. This same approach
    would work for CSVs, parquet, Excel files, etc.
  prefs: []
  type: TYPE_NORMAL
- en: And I could choose to create tables and persist locally, but often I’m just
    interrogating data and don’t need the persistence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more about DuckDB’s great JSON support in this blog post: [Shredding Deeply
    Nested JSON, One Vector at a Time](https://duckdb.org/2023/03/03/json.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Update:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'I also learned that DuckDB can read the JSON directly from a URL, not just
    a local file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
