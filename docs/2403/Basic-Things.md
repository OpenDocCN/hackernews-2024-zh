<!--yml

类别：未分类

日期：2024年05月29日 12:48:17

-->

# 基础事物

> 来源：[https://matklad.github.io/2024/03/22/basic-things.html](https://matklad.github.io/2024/03/22/basic-things.html)

# 基础事物 2024年03月22日

在完成几个较大项目的初始阶段后，我总结了以下具有以下三个特性的事物列表：

+   他们在项目规模较小时是不相关的，

+   他们在项目规模较大时是生产力的倍增器，

+   他们在后续阶段更难引入。

这是列表：

项目应该有一个*简短*的一页自述文件，主要是指向更多主题文档的链接。最重要的两个链接是用户文档和开发文档。

一个常见的失败是自述文件通过渐积法随意增长，因此既不是一个好的着陆页，也不是任何特定主题全面文档的来源。稍后对这样的非结构化自述文件进行重构是困难的。信息虽然有价值，但是不组织，没有更好的地方可以移动。

对于开发者，通常希望在代码库中有一个文档文件夹。文档文件夹应*同时*包含一个简短的着陆页，描述文档结构。该结构应允许少量高质量的策划文档和大量特定主题的即兴追加注释。例如，`docs/README.md` 可以指向精心制作的[`ARCHITECTURE.md`](https://matklad.github.io/2021/02/06/ARCHITECTURE.md.html) 和 `CONTRIBUTING.md`，描述高级代码和社交结构，并明确说明`docs/`文件夹中的其他内容是一组未组织的主题指南。

常见的失败模式在这里：

1.  没有地方可以放置新的开发者文档。因此，没有文档被编写，并且当您确实需要文档时，知识已经丢失。

1.  只有高度结构化、经过精心审核的开发者文档。贡献文档需要大量努力，很多小事情都没有记录。

1.  只有非结构化的追加式堆积的孤立文档。事情*大多*有记录，通常两三次，但任何新团队成员都必须重新筛选精华。

大多数项目可以从面向用户的专用网站中受益。当用户很少或没有用户时，您应准备好网站：使用随时间增长，因此，如果发现自己有大量用户但没有网站“面孔”，那么已经失去了相当大的价值！

其他一些失败模式在这里：

1.  不同的团队管理网站。这阻止了项目开发者直接贡献改进，并可能导致文档与实际发布的产品之间的分歧。

1.  当今的Web堆栈倾向于无限复杂性。从一开始选择一个“简单”的重型框架然后陷入npm的泥潭是太自然不过了。网站关乎内容，而内容有重力。您在开始时选择的任何标记语言方言将在一段时间内保持不变。务必慎重考虑您的Web堆栈的选择。

1.  说那些尚未完成的事情。不要过度承诺，稍后说更多比收回您的话更容易，谦卑可能是一种良好的营销方式。请考虑您是否处于工程可信度比噱头更快传播的领域。但这是情境性的。更一般的建议是，营销也会随时间累积，因此从一开始就有意识地塑造您的形象是划算的。

这更多是情境性的，但请考虑一下，除了公共网站之外，您是否还需要一个面向内部工程师的网站。在某个时候，您可能需要比`README.md`中提供的更多交互性 —— 也许您需要一个地方来显示与代码相关的指标，如覆盖率或一些JavaScript来计算发布轮换。在网络上有一个地方，贡献者可以放置他们现在需要的东西而不需要太多的繁文缛节是很好的！

这是一个经常出现的主题 —— 您应该组织好，您不应该组织好。*某些*事情有很大的扇出，应该通过仔细的审查来保护。*其他*事情则受益于只是存在和轻量级流程。您需要为这两种事情创建地方，并制定明确的决策规则确定哪些事情放在哪里。

对于内部网站，您可能还需要某种数据存储。如果您想要跟踪二进制大小的变化，*某种东西*需要将提交哈希映射到（让我们乐观地说）千字节！我不知道这里有什么好的解决方案。我在GitHub存储库中使用JSON文件用于类似的目的。

有许多将代码合并到主分支的可能方法。选择一种，并在`.md`文件中明确说明：

+   分支功能是否推送到中央存储库，还是任何人从其分叉中进行工作？一般来说，我发现分叉效果更好，因为它们自动为每个人的分支命名空间，并将团队成员和外部贡献者放在同等地位。

+   如果存储库是共享的，分支的命名约定是什么？我用`matklad/`作为前缀。

+   您使用[非火箭科学规则](https://graydon2.dreamwidth.org/1597.html)（稍后详述 :）。

+   谁应该审查特定PR的代码？一个人，以避免旁观效应并减少通知疲劳。评审员由PR的作者选择，因为这是高信任团队中的稳定均衡点，并简化了繁文缛节。

+   评审员如何知道他们需要审查代码？在 GitHub 上，你希望*指派*而不是*请求*审查。指派是电平触发的 —— 它不会消失，直到 PR 被合并，并且成为评审员负责帮助 PR 完成的责任（*请求审查*在反馈和更改一轮后通知指派者仍然有用）。更广泛地说，代码审查是最优先的任务 —— 如果已经有一些完成的代码被阻塞在你的审查上，没有理由去开发新代码。

+   评论的目的是什么？检查正确性、一致性、习语、知识共享、高级架构是选择的一部分！明确说明在项目背景下最合理的选择。

+   元过程文档：积极鼓励贡献过程文档本身。

谈论元过程时，样式指南在实践中最具价值。确保代码审查期间大多数风格评论立即纳入项目特定的样式文档中。新贡献者应通过几个指向样式指南具体条款的链接学习项目的语调，而不是通过对 PR 的数百次重复评论。

你是否需要一个项目特定的样式指南？我认为你需要 —— 减少对微小决策的精力投入是有帮助的。如果你需要一个结果变量，并且有一半的函数称它为 `res`，另一半称它为 `result`，做出这个选择只会分散注意力。

项目特定的命名约定是样式指南中最有用的内容之一。

优化样式指南以提高可扩展性。将代码审查中的评论提升到样式指南中不应该需要太多工作。

确保有一个样式专员 —— 围绕*具体*的样式选择建立共识非常困难，最好将整个责任委托给一个人，他能够做出足够好的选择。样式通常不是关于什么更好，而是在半随意的方式下消除不必要的选项。

文档化与 Git 相关的风格细节。如果项目使用 `area:` 前缀来表示提交，明确列出这类前缀的具体列表。

考虑为摘要行文档化可接受的行长度。Git 手册大胆声明摘要应在50个字符以下，但这纯属错误。即使在内核中，大多数摘要也在50到80个字符之间。

明确禁止向 Git 中添加大文件。仓库大小单调增加，`git clone` 的时间非常重要。

文档化合并与变基的事情。我偏好的答案是：

+   变更的单位是一个拉取请求，可能包含几个提交。

+   拉取请求的合并提交是正在测试的内容。

+   主分支仅包含合并提交。

+   相反，*仅*主分支包含合并提交，拉取请求本身总是变基。

禁止在仓库中放置大文件是一个好的策略，但很难遵循。在项目的生命周期内，某处某人会偷偷地添加并回退一兆字节的生成的protobufs，而这将飞过代码审查的雷达。

这将我们带到了所有基础中最基础的事情：

维护一组明确定义的自动化检查，这些检查在主分支上始终通过。如果你不希望在git仓库中有大块对象，请编写一个拒绝大git对象的测试，并在更新主分支之前运行该测试。特性分支上没有合并提交？编写一个测试，如果检测到合并提交，则以Git自助的页面失败。

或许值得你再次阅读原始帖子：[https://graydon2.dreamwidth.org/1597.html](https://graydon2.dreamwidth.org/1597.html)

[这种单调增长的属性集的心态](https://matklad.github.io/2024/01/03/of-rats-and-ratchets.html)，关于代码库是*非常*强大的。你开始把代码看作是可以相对便宜地随时改变的暂时性、流动性物体，而积累的一组自动化测试是项目的真正价值。

另一个二阶效应是，NRSR促使你优化你的构建和测试基础设施。如果你没有选项在一个不相关的不稳定测试失败时合并代码，你将不会有不稳定的测试。

这里的一个常见反模式是项目会增加一组半检查——存在但不是100%可靠的测试，因此CI不会经常执行它们。这会造成歧义——测试失败是因为应该修复的回归，还是它们从未可靠，只是测试了一个实际上对项目功能并不重要的属性？这种模糊性随时间而累积。如果一个检查不够可靠以成为NRSR CI门的一部分，那它实际上不是你关心的检查，应该被移除。

但要做NRSR，你首先需要构建和CI你的代码：

这是一个复杂的话题。让我们从基础开始：什么是构建系统？我想在这里强调一些稍微不寻常的答案。

*首先*，构建系统是一个引导过程：它是你从`git clone`到工作二进制文件的方式。这个引导过程的两个方面很重要：

+   它应该是简单的。没有`sudo apt-get install bazzilion packages`，你的构建系统的单个二进制文件应该能够自动地带来所有其他需要的东西。

+   它应该是可重复的。你的笔记本和你的CI应该最终具有完全相同的依赖项集。最终结果应该是提交哈希的函数，而不是你本地的shell历史，否则NRSR无法工作。

*其次*，构建系统是开发者的UI。几乎做任何事情，你都需要在你的shell中输入某种构建系统调用。应该有一个单一、清晰文档化的命令来构建和测试项目。如果不是一个单一的`makebelieve test`，那就有问题了。

其中一个反模式是构建系统溢出到 CI。当你需要读取 `.github/workflows/*.yml` 来编译命令列表以了解检查集时，这就是偶然复杂性！庞大的 yaml 文件是一个糟糕的入口点。将所有逻辑放入构建系统中，并让 CI 驱动它，而不是反过来。

[这里有更强烈的建议版本](https://matklad.github.io/2023/12/31/O(1)-build-file.html)。无论项目大小如何，它可能只有少数几个适合它的工作流程：测试、运行、发布等。应该从一开始就明确这个小组工作流程，并记录具体的命令。当项目随后扩展时，这组构建系统入口点不应该增长。

如果你添加了一个 Frobnicator，`makebelieve test` 的调用*应该*测试 Frobnicator 的工作。如果你需要一个专用的 `makebelieve test-frobnicator` 并在某些 CI yaml 文件中相应地加上一行，那你走的是一条危险的道路。

*最后*，一个构建系统是一系列使事情发生的命令。在较大的项目中，你不可避免地需要一些非常规自动化。即使入口点只是 `makebelive release`，内部可能需要任意数量的不同工具来构建、签名、标记、上传、验证和生成新版本的更改日志。

一个常见的反模式是用 bash 和 Python 编写这些类型的自动化，但这几乎纯粹是技术债务。这些生态系统本身非常棘手，并且至关重要的是（除非你的项目本身是用 bash 或 Python 编写的），它们是对你已有项目中“正常”代码的第二个生态系统。

但发布软件也只是代码，你可以用你的主要语言来编写它。[选择适合工作的工具通常是你已经在使用的工具](https://twitter.com/id_aa_carmack/status/989951283900514304)。从一开始就明确解决胶水问题，并选择/编写一个使编写子进程处理逻辑变得容易的库，这是值得的。

总结构建和 CI 流程：

构建系统是自包含的、可复现的，并承担下载所有外部依赖项的任务。无论项目大小如何，它都包含 O(1) 个不同的入口点。其中一个入口点由“不是火箭科学规则”的 CI 基础设施触发以运行一组规范检查。这支持显式的自由形式自动化，其实现与项目大部分内容相同语言中。

与 NRSR 的集成是构建过程中最重要的方面，因为它决定了项目随时间的演变。让我们来详细看看。

测试是一个主要的架构关注点。在编写第一行代码时，你应该已经理解了整体的测试策略。这绝对不是“每个类和模块都有单元测试”。测试应该是数据导向的 —— 特定软件的工作是接收一些数据，对其进行转换，并输出不同的数据。总体的测试策略需要考虑：

+   一些指定/生成输入数据的方法，

+   一些验证输出数据期望属性的方法，

+   快速运行许多单独检查的方法。

如果时间是输入数据中的一个重要部分，那么它应该明确地进行建模。如果测试架构不正确，通常会导致以下问题：

+   因为成千上万的测试钉住了现有的内部 API，软件变得难以更改。

+   因为没有测试可以自信地验证无意的破坏是否不存在，软件变得难以更改。

+   因为每次变更都需要数小时的测试时间来验证，软件变得难以更改。

如何设计测试套件超出了本文的范围，请阅读[单元测试与集成测试](https://matklad.github.io/2022/07/04/unit-and-integration-tests.html)和[如何测试](https://matklad.github.io/2021/05/31/how-to-test.html)。

本文的范围包括一些具体的事项：

对不稳定测试的零容忍。严格而非复杂的规则通过设计实现了这一点 —— 如果你不能合并你的拉取请求，因为其他人的测试不稳定，那么这个不稳定的测试立即成为你的问题。

快速测试。同样，NRSR已经通过自然的压力提供了这种自然压力，但通过默认打印总测试时间和运行中五个最慢的测试，可以更加显著地显示测试时间的重要性。

并非所有测试都能够快速完成。在同时接纳秩序和混沌的阴阳主题中，早期引入慢速测试的概念是有帮助的。CI 总是运行完整的测试套件，包括快速和慢速测试。但默认情况下，本地的 `makebelive test` 只运行快速测试，并选择性地运行慢速测试。选择性可以简单地通过设置 `SLOW_TESTS=1` 环境变量来实现。

早期引入[快照测试](https://ianthehenry.com/posts/my-kind-of-repl/)库。尽管大部分测试应该使用项目特定的测试工具，但对于其他所有情况，内联 REPL 驱动的快照测试是一个很好的默认方法，而且一旦积累了一定数量的非快照测试，引入这种方法的成本会很高。

除了测试之外，还有基准测试。

我对如何在大型、活跃项目中使基准工作起作用没有一个宏伟的愿景，我总觉得这对我来说都是一种挑战。不过，我确实有几个战术上的建议。

*首先*，任何在 NRSR 过程中*不*运行的代码实际上是死代码。很常见的情况是，在性能改进的同时添加基准测试，然后*没有*与 CI 链接起来。因此，两个月后，基准测试要么完全停止编译，要么可能只是由于一些无关的更改在启动时发生恐慌。

这里的修复是确保每个基准测试也是一个测试。通过输入大小参数化每个基准测试，使得用小输入完成毫秒级测试。然后编写一个测试，字面上只调用具有这个小输入的基准测试代码。记住，你的构建系统应该有 O(1) 的入口点。将其插入到一个 `makebelieve test` 中，而不是一个专用的 `makebelieve benchmark --small-size`。

*其次*，任何大型项目都有一定数量的非常重要的宏度量标准。

+   构建需要多长时间？

+   测试需要多长时间？

+   结果产生的供用户使用的工件有多大？

这些都是总是重要的问题。你需要基础设施来跟踪这些数字，并定期查看它们。这就是内部网站及其数据存储的作用。在 CI 过程中，记录这些数字。在 CI 运行后，将一个记录上传到提交哈希、指标名称和指标值的*某个地方*。不要担心结果会有噪音——你的目标是基线，能够随时间注意到大的变化。

"上传"部分有两个选项：

+   只需将它们放入 git 仓库中的某个 `.json` 文件中，然后用一点 JavaScript 来显示这些数据的漂亮图表。

+   [https://nyrkio.com](https://nyrkio.com) 是一个令人惊讶地好的 SaaS 提供，我可以推荐。

严肃的模糊测试好奇地共享了测试和基准测试的特性。像正常测试一样，模糊测试告诉你应用程序中的正确性问题，并且是可重现的。像基准测试一样，它是（无限）长时间运行的，并且作为 NRSR 的一部分是不可行的。

我还不知道如何最有效地将持续模糊测试集成到开发过程中。我不知道模糊测试的“不是火箭科学”规则是什么。但有两件事是有帮助的：

*首先*，即使你不能在 CI 过程中运行模糊测试循环，你可以运行隔离的种子。为了帮助确保模糊测试代码不会出问题，可以像进行基准测试一样——添加一个使用固定种子和小型快速参数运行模糊逻辑的测试。这里的一个变化是，你可以使用提交的 sha 作为随机种子——这样代码仍然是可重现的，但有足够的变化以避免动态死代码。

*其次*，从触发级别的模糊化角度来看，考虑fuzzing非常有帮助。对于测试，当您进行错误提交时，您立即知道它会破坏东西。而使用fuzzing，您通常稍后才会发现这一点，并且破坏的种子通常会持续几个提交。因此，作为fuzzer的输出，我认为您想要的*不是*一组GitHub问题，而是一种显示最近提交和这些提交失败种子的表格的仪表板。

当不是火箭科学规则牢固地处于一定位置时，考虑发布是有意义的。

这里有两个核心见解：

*首先*发布*过程*与软件是否*准备生产*是正交的。您可以在准备好之前发布东西（前提是在readme中添加一个简短的免责声明）。因此，尽早添加适当的发布流程是值得的，这样，当实际发布软件的时候，它就是删除免责声明和撰写公告帖子的时间，因为所有技术工作都已经完成了很久以前。

*其次*，总体上软件工程遵守逆三角不等式：从A到C，比从A到B再从B到C更快，然后原子地从A到C。如果您提交一个拉取请求，将其拆分成较小的部分会有所帮助。如果您重构某些东西，首先介绍一个新的工作副本，然后单独退休旧代码比在原地更快。

发布没有区别：更快、更频繁的发布更容易和风险更小。每周的节奏非常适合，前提是您在您的NRSR中有一组可靠的检查。

更容易从几乎什么都不工作的状态开始，但有一个坚实的发布（没有功能的空集），然后逐步增加，比毫无顾忌地进行黑客攻击更容易，*而不是*考虑到最终发布的情况，并且然后拼命决定哪个是准备好的和可发布的，应该切掉哪个。

我想今天就是这些？这是很多小点！这里有一个符合方便参考的项目列表：

+   README作为一个登陆页面。

+   开发文档。

+   用户文档。

+   结构化的开发文档（架构和流程）。

+   非结构化优化的开发文档（代码样式，主题指南）。

+   用户网站，注意内容引力。

+   优化内部网站。

+   元文档过程——每个人都有责任追加到代码样式和流程文档中。

+   清晰的代码审查协议（球当前在谁的法庭？）。

+   在git库中没有大块的自动检查。

+   不是火箭科学规则。

+   让我们重复一遍：在**任何**时候，主分支都指向一个已知通过一组明确定义的检查的提交哈希。

+   不需要半测试：如果代码不足以添加到NRSR中，它将被删除。

+   没有不稳定的测试（大部分通过NRSR构建）。

+   单命令构建。

+   可重现的构建。

+   固定数量的构建系统入口点。没有单独的lint步骤，lint是一种测试。

+   CI委托给构建系统。

+   主语言中的临时自动化空间。

+   全面的测试基础设施，项目测试的大一统理论。

+   快慢测试分离（快速=每个测试套件几秒钟，慢速=每个测试套件几分钟）。

+   快照测试。

+   基准测试也是测试。

+   宏观指标跟踪（构建时间，测试时间）。

+   模糊测试也是测试。

+   连续模糊测试结果的级别触发显示。

+   逆三角不等式。

+   每周发布。
