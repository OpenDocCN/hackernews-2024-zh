<!--yml

类别：未分类

日期：2024-05-29 12:29:40

-->

# 构建系统分裂：元构建系统的诅咒 | Yzena, LLC

> 来源：[https://yzena.com/2024/03/build-system-schism-the-curse-of-meta-build-systems/](https://yzena.com/2024/03/build-system-schism-the-curse-of-meta-build-systems/)

这篇文章旨在提供信息，但最后确实有一个广告，将明确标记。你已经被警告了！

## 引言[#](#introduction)

[起初什么都没有&mldr;](https://www.gocomics.com/calvinandhobbes/1987/12/06)

&mldr;然后就有了`make`。

[传说中](https://zh.wikipedia.org/wiki/Make_(软件)#起源)，[Stuart Feldman](https://zh.wikipedia.org/wiki/斯图尔特·费尔德曼)在贝尔实验室工作时遇到了一个问题。

Feldman花了一个晚上的时间，努力解决一个未从更改后的源文件更新的可执行文件的问题。第二天早上，[Steve Johnson](https://zh.wikipedia.org/wiki/史蒂芬·C·约翰逊)恰好冲进他的办公室抱怨正好遇到了同样的问题。

有了他前一晚的记忆，还有一位尊敬的同事希望有更好的东西，费尔德曼想到了，“你知道，我可以用一个工具来解决这个问题。”

正如事实所证明的那样，Stuart Feldman坐下来做了一些*设计*：

> 它始于一个复杂的依赖分析器的想法，简化为一些更简单的东西，然后在那个周末演变成了Make。

我们都应该感激那一点设计；我只希望他能更进一步，不要使用制表符。

或者，你知道，只是更新***十几个用户***的工作！

不，我不是在开玩笑：

> 为什么在第一列使用制表符？Yacc是新的，Lex是全新的。我两者都没尝试过，所以我觉得这是一个很好的学习借口。在第一次尝试Lex时遇到了麻烦后，我就简单地使用了模式newline-tab。它有效，就一直沿用下来了。然后几周后，我的用户群大约有十几个，大部分是朋友，我不想搞砸我的嵌入式基础。剩下的，可惜的是历史。

这里有两个教训：

1.  简单的实现导致灾难，而

1.  打破兼容性有时是必要的；尽早执行。

然而，有一段时间，每个人都很开心！

关于[Linux发布](https://zh.wikipedia.org/wiki/Linux历史)的时间，David Mackenzie在使用Make时遇到了问题：他需要图灵完备性。

见，Make的设计初衷是有一个目标列表或要构建的东西，这就是你得到的所有目标，除了[后缀规则](https://zh.wikipedia.org/wiki/Make#后缀规则)和[模式规则](https://zh.wikipedia.org/wiki/Make#模式规则)。

后缀规则和模式规则可能是为了消除重复而添加的；程序员*讨厌*重复。

但是，如果你在进行分析之后还不知道需要哪些目标呢？

Mackenzie面临一个关键的决定（刻意玩梗）：他会重新开始*不用*Make，还是会在Make的基础上构建新东西？

嗯，我猜有什么东西让他不愿意放弃 Make，因为他选择了后者并创建了 [Autoconf](https://en.wikipedia.org/wiki/Autoconf)。

我不知道它是什么，所以我只能假设自 1976 年以来，贝尔实验室的传说已经是传说，他们的软件被认为是不可触及的。

顺便说一句，我一般是 [Unix 哲学](https://en.wikipedia.org/wiki/Unix_philosophy) 的粉丝。

无论如何，这就是创建**构建系统分裂**的决定。

构建系统分裂是“构建系统”和像 Make 和 [Ninja](https://en.wikipedia.org/wiki/Ninja_(build_system)) 这样的东西之间的分离，以及“元构建系统”包括像 Autoconf、[Automake](https://en.wikipedia.org/wiki/Automake)、[CMake](https://en.wikipedia.org/wiki/CMake)、[qmake](https://en.wikipedia.org/wiki/Qmake) 和 [Meson](https://en.wikipedia.org/wiki/Meson_build_system) 这样的东西。

"你可能会问，有什么区别呢？"

要非常简洁，元构建系统构建构建，而构建系统则构建。

为了更易理解，元构建系统生成文件，告诉构建系统如何执行构建，然后构建系统执行该构建。

为了更加准确，让我描述一下这个过程。

假设我有一个 [使用 Make 的项目](https://git.gavinhoward.com/gavin/bc)，但它有一些构建选项。这些构建选项可能需要任何东西，比如在某些情况下*不*编译某些文件。

现在，假设我希望我的软件在任何 POSIX 系统上都能可移植地构建，因此我需要使用 [POSIX Make](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html)。

现在我有个问题：POSIX Make *极其*有限；它不是 [图灵完备](https://stackoverflow.com/questions/7284/what-is-turing-complete) 的。

"Gavin，这为什么是个问题？"

因为很多时候，设置一个构建需要完全的图灵完备性。

这篇文章不适合解释为什么图灵完备性很重要，但可以说，没有*任何*替代品可以代替图灵完备性，因为任何替代品都会因定义而成为图灵完备性。

下周请继续深入了解图灵完备性，以及它对构建系统意味着什么！

因此，我需要在 POSIX Make 的*之上*，需要一些可移植的东西。

好吧，CMake 是可移植的，所以让我们假设我使用它。

那个项目使用一个自定义的 shell 脚本，而不是像 CMake 这样的“真正”的元构建系统，但这个例子仍然成立。

我用 CMake 写了一堆代码，告诉它根据构建选项向构建添加什么目标。

这在 CMake 中是可能的，因为它是图灵完备的。

我记得没错的话，CMake 甚至不应该是*图灵完备*！这就是为什么它的文件被称为 `CMakeLists.txt`；它只是应该是一个列表。

不幸的是，我没有源码，所以如果 Hacker News 或 Reddit 上有人有，请告诉我；我会添加进来。

因此，一个构建看起来像这样：

1.  运行 CMake，并告诉它要使用的配置。

1.  运行Make或Ninja来进行实际构建。

## 障碍[#](#the-barrier)

“加文，这似乎很简单。问题在哪里？”

问题在于无法更改要构建的项目列表！

比如你添加了一个新的源文件。如果您的构建系统只是自动获取它，那岂不是很棒？

不幸的是，它不能；要构建的东西清单是通过元构建系统传递给构建系统的，通常是通过命令。

第一步和第二步之间的障碍本质上是不可逾越的，因为它是两个独立程序之间的接口。

实际上，唯一打破它的方法是在每次构建时运行元构建系统。

那么在这种情况下，为什么不只做一个同时做这两件事的构建系统呢？

## 端到端构建系统[#](#end-to-end-build-systems)

然而，风向似乎有所改变；有一种新型构建系统即将登场。

这些构建系统，我称之为“端到端构建系统”，或者简称E2E构建系统，以区别于“常规”构建系统，它们不仅可以生成构建项列表，还可以执行构建。

一个例子是[`build2`](https://build2.org/)。

`build2`的创作者是[borisk](https://lobste.rs/~borisk)，我从他那里无耻地窃取了这篇文章的[想法](https://lobste.rs/s/i2qnqj/why_cmake_sucks_2021#c_ltemdq)。

borisk，如果这篇文章还不够，请随时告诉我！

在像`build2`这样的系统中，您可以指定如何搜索源文件以及如何构建找到的文件，系统会在每次构建时执行这些搜索。

这样做的好处是，如果您添加了另一个源文件，*您无需更改您的构建！* E2E构建系统将检测到新文件并进行构建。

相比之下，在使用CMake时，我要么必须更改一个或多个`CMakeLists.txt`文件，要么手动运行CMake。

消除这个障碍可以提升用户体验。

### 构建更好的构建系统[#](#building-better-build-systems)

但是E2E构建系统还有另一个优点：动态目标。

一般来说，当您指定一个目标时，您以某种方式明确地写出其依赖关系，或者通过传递某种形式的依赖项列表来实现。

这很好，但“好”还不够好。我想要[无限的力量！](https://star-wars-memes.fandom.com/wiki/Unlimited_power!)

那么，如果您不需要指定目标的所有依赖关系怎么办？如果您可以在构建过程中使用源代码自身找到它们怎么办？

此时，*如此*多的人都在嘲笑我。“但是，加文，我们在`<language>`中已经有这个功能了。”

是的，你需要因为`<language>`具有内置的构建系统和良好的模块支持。

例如，如果您在Go项目上运行`go build`，它将找出需要构建的导入项，然后直接进行构建。添加一个`import`语句，下一次构建将检测到并构建新的导入项。

简单得不能再简单了，对吧？

哦，对于C和C++世界来说，这仍然是一个新概念。事实上，一般化它可能会对许多已经具备此功能的语言听起来很陌生。

我知道的唯一的E2E构建系统，可以以一种普遍的方式做到这一点，是[Shake](https://shakebuild.com/)和[Buck2](https://buck2.build/)。

`build2`可能会，但我还没有深入研究。

Shake是一个超前于其时代的好主意，但也受到用Haskell编写和*采用Haskell作为其构建语言*的不幸决定的阻碍。

糟糕。

但是不要紧，Buck2就是由[Neil Mitchell](https://neilmitchell.blogspot.com/)构建的，他也使用了相同的想法。

Neil使用了什么想法？

嗯，他们[写下了](https://neilmitchell.blogspot.com/2021/09/reflecting-on-shake-build-system.html)，但我认为更好的介绍也许是我的五大最佳论文之一：[“Build Systems à la Carte.”](https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf)

**tl;dr**: 构建系统可以按照以下六个轴分类：

+   **持久化构建信息**

    +   例如：Make使用文件修改时间。

    +   另一种选择是对文件进行哈希。

+   **调度器**

    +   Make是拓扑的。

    +   Shake有一个挂起调度器。

    +   Bazel有一个重启调度器。

+   **依赖关系**

    +   这些要么是静态的，要么是动态的。

+   **最小化**

    +   构建系统是否尽可能地做到最少？

+   **早期截断**

    +   如果从依赖项更新目标，并且更新未更改任何内容，那么构建系统可以放弃构建依赖于该目标的东西吗？

+   **云**

    +   构建系统可以在云中缓存东西并使用该缓存中的项目吗？

你希望一个**最小化**的构建系统，具有**挂起调度器**、**动态依赖**、**早期截断**和**云缓存**。

只要提供所需的功能，包括最小化构建，持久化构建信息就不重要。

你为什么想要这些东西？这是为什么：

**最小化**: 这是显而易见的；为什么你希望你的构建做出多余的事情？

**挂起调度器**: 对于这一点，你的选择基本上是普通调度器（拓扑）、重启或挂起。

如果你有一个普通调度器，你无法拥有动态依赖关系。

如果具有图灵完备性，则挂起调度器很容易转换为重启调度器：

```
while (restart_needed())
{
	// Build target...
} 
```

但是反过来则不可能，没有重复工作，这意味着构建系统无法使用具有重启调度器的**最小化**。

**动态依赖**: 好吧，你可能还不相信动态依赖关系。但是如果你使用Rust和Go，或者任何具有比*头文件*更好模块系统的语言，你正在使用动态依赖。

广义的动态依赖关系可以为C和C++增加这样一个系统。

实际上，我怀疑动态依赖对新的[C++模块](https://en.cppreference.com/w/cpp/language/modules)是*必需*的。

为什么它们是必需的？因为依赖关系在源代码中被指定。实质上，你必须“构建”源代码以弄清它依赖于什么。

既然你构建源代码以获取它的依赖项，你也可以将其存储在某个地方。当你这样做时，你的构建系统必须在下一次构建中使用它。

这意味着构建系统必须：

1.  弄清楚目标是否存在。

1.  检查前一次构建的依赖关系。

1.  将这些依赖项添加到目标*创建后*。

最后一步是动态的部分；用户可能没有在构建文件中列出依赖项，因此当构建系统解析构建文件时，它不知道这些依赖项存在，并且在没有它们的情况下创建了目标。

“但是它可以在解析构建文件时添加它们！”

当然，但那是特殊代码，而动态依赖关系更加通用。

实际上，构建系统*没有*动态依赖关系已经做到了这一点；用尼尔·米切尔的话来说，

> 大多数构建系统从静态图开始，然后意识到无法表达真实世界，开始以无原则的方式进行黑客攻击。结果系统成为一堆特殊情况。

例如：[Ninja和头文件](https://ninja-build.org/manual.html#ref_headers)。

以无原则的方式进行黑客攻击并不好，这意味着*你*作为用户，[也必须进行一些黑客攻击](https://github.com/ninja-build/ninja/issues/1265)。

换句话说，动态依赖关系对于保持构建系统易于使用至关重要。相信我，你会想要它们。

无论如何，我们在哪里？哦，是的&mldr;

**早期截断**：如果你的构建系统可以更快地完成，为什么不呢？

**云缓存**：如果你的构建系统已经构建了你需要的东西，但是对于其他人，为什么不使用它呢？

所以有五个构建系统的特性是你想要的，残酷的事实是，元构建系统***无法***拥有其中一些！这些事情有些只能在端到端的构建系统上使用。

这就是元构建系统的诅咒；它们将永远无法达到构建系统的全部潜力。

所以下次你寻找构建系统时，请确保你检查它是否是一个元构建系统。如果是，继续寻找；还有更好的选择。

## 图灵完备性[#](#turing-completeness)

但是有一个方面，即使是“按需构建系统”也错过了：图灵完备性。

不幸的是，这是大多数最佳构建系统仍然存在问题的一个方面。甚至*Buck2*决定采用非图灵完备语言。

但图灵完备性及其后果被如此误解，以至于它值得有自己的帖子。

下周继续关注！

* * *

下面是顶部提到的广告！

## Rig[#](#rig)

我花了三年多时间学习构建系统并构建一个。

它被称为Rig，将于2024年4月2日公开发布。

它将是**极简**的，具有**挂起调度器**，**动态依赖关系**，**早期截断**和**云缓存**。显然。

在 Hacker News、Reddit 和这个博客上寻找公告！
