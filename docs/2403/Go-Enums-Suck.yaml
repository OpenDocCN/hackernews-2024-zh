- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:29:32'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Go Enums Suck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.zarl.dev/articles/enums](https://www.zarl.dev/articles/enums)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Go Enums Suck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go doesn’t technially have Enums and it is a missing feature in my book but
    there is a Go idiomatic way to achieve roughly the same thing. Go does have however
    the `iota` keyword. This is basically a self incrementing integer - so you end
    up writing Enums something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fine however it is nothing but an integer under the covers this means
    what we actually have is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This also means any function that uses these or a struct that contains these
    can also just take an `int` value. For this reason its best to make sure our default
    case is correctly handled. So for this we either decide which will be the default
    case or what I usually do is specify an `Unknown` case and use this as a validation
    check. So now we have :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But what you notice here is we have no string representation of these Enums
    so we have to build that out next, for this I just use a `map[Operation]string`
    and instantiate this with the defined string constants. We also now need to handle
    in inverse scenario of a `string` to an `Operation` for example if we are reading
    the value off the wire via JSON for example. Adding the string maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have these maps set up we should really put them to use, for this
    I usually make 1 method and 1 function, the `String()` method on the Enum type
    and a package level function Parse which takes the `any` type and can return an
    Operation type. This looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This lets us use the Enum in JSON for example, it can be represented as an `int`
    or a `string` it’s up to you, but I almost always go for the `string` representation
    in JSON. And of course it’s the 2 most used interfaces in the world. The JSON
    Marshall and Unmarshall interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'OK so now that we have all the individual Enums defined I like to group them
    up in a struct and give it the feel of an Enum more akin to a Java/Kotlin Enum
    when referencing it. Start with making a container wrapper with a `Operation`
    for each case then define a public variable of the container type with all the
    correct mappings. This ends up looking like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to use these Enums like below if for example we are importing
    from the `cmd` pkg.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this container we can also extend the functionality to return all Enums
    as a slice for iteration over all the values if required excluding the `Unknown`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Job Done. Or is it….
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After all this we now have a much nicer more fully featured Enum but the biggest
    problem remains; Anywhere that accepts an `Operation` Enum type will just as happily
    accept an `int`. This is a real pain as it almost completely negates the work
    we have done here. There is also the fact that we have our container but the original
    definitions are also public and can be accessed from outside the package so we
    have two things that are functionally the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To limit this the first thing I did was to make the operation Enum type private
    so `Operation` became `operation` and made all instances of the operation type
    private also. I then defined a new public struct called `Operation` which contains
    this private `operation` Enum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This now makes it impossible to just pass an `int` to any function or struct
    that uses the `Operation` type as they cannot instantiate a new one with a valid
    private `operation` as it cannot be used outside the package. This also means
    even if someone for example uses this as an empty struct `empty := cmd.Operation{}`
    it will be Invalid and will report as `Unknown`. So now that this has been done
    we need to change our public container to accommodate our new `Operation` struct
    but as you can see the container does not need to change but the assignment does.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We also now need to change our Parse function to handle the wrapped `operation`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this new structure we still have the same nice syntax for accessing the
    Enum outside the package but the individual Enums are not public so this encourages
    the use of the singleton Enum container for getting the appropriate value and
    it also makes Intellisense in the IDE better as there is less public variables
    exposed meaning the drop down is cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Now I know - this is a metric ton of work just to get nice Enums, but to be
    honest I think it really makes a nicer developer experience when using them and
    is better than the `iota` approach from a type safety perspective. However I too
    agree that this is way to much work and it’s repetitive work at that, which can
    easily require rework with the adding of Enums or the changing of Enums means
    making sure everything has been done correctly for all the string maps etc.
  prefs: []
  type: TYPE_NORMAL
- en: So ………..
  prefs: []
  type: TYPE_NORMAL
- en: goenums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a a little tool I wrote to accompany this post - its an Enum generator
    that generates Enums in the same style as I have laid out above. It’s a simple
    `text/template` based tool that can turn some simple JSON configuration into a
    formatted go file.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that the config is a JSON array this allows specifying many different Enums
    and have them all get generated in one shot. More about goenums can be found on
    the github at [https://www.github.com/zarldev/goenums](https://www.github.com/zarldev/goenums)
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://www.zarl.dev/articles/enums-take-two)'
  prefs: []
  type: TYPE_NORMAL
- en: '[I have done a follow-up to this, it better reflects the current goenums code.](https://www.zarl.dev/articles/enums-take-two)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
