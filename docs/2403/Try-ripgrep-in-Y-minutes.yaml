- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-29 12:29:58'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-29 12:29:58'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Try ripgrep in Y minutes
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Y 分钟内尝试 ripgrep
- en: 来源：[https://codapi.org/try/ripgrep/](https://codapi.org/try/ripgrep/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://codapi.org/try/ripgrep/](https://codapi.org/try/ripgrep/)
- en: '[ripgrep](https://github.com/BurntSushi/ripgrep) is a command line tool that
    searches your files for patterns that you give it. It''s similar to grep, but
    provides a better user experience and is (generally) faster.'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[ripgrep](https://github.com/BurntSushi/ripgrep) 是一个命令行工具，可以搜索你的文件，查找你给定的模式。它类似于
    grep，但提供更好的用户体验，并且（通常）更快。'
- en: '[Basics](#basics) · [Recursive search](#recursive-search) · [Useful options](#useful-options)
    · [Replacements](#replacements) · [Configuration](#configuration) · [Further reading](#further-reading)'
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[基础知识](#basics) · [递归搜索](#recursive-search) · [有用的选项](#useful-options) · [替换](#replacements)
    · [配置](#configuration) · [进一步阅读](#further-reading)'
- en: ✨ This is an open source guide. Feel free to [improve it](https://github.com/nalgeon/tryxinyminutes/blob/main/try/ripgrep/index.md)!
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: ✨ 这是一个开源指南。随时[改进它](https://github.com/nalgeon/tryxinyminutes/blob/main/try/ripgrep/index.md)！
- en: Basics
  id: totrans-split-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'ripgrep behaves as if it were reading each file line by line:'
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep 表现得就像它逐行读取每个文件一样：
- en: If a line matches the pattern given to ripgrep, that line is printed.
  id: totrans-split-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一行与提供给 ripgrep 的模式匹配，则打印该行。
- en: If a line does not match the pattern, the line is not printed.
  id: totrans-split-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一行不匹配模式，则不打印该行。
- en: The best way to see how this works is with an example.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是通过一个例子来看看这是如何工作的。
- en: 'We''ll try searching [httpurr](https://github.com/rednafi/httpurr) source code,
    which I have already downloaded to the `/opt/httpurr` directory like this:'
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试搜索[httpurr](https://github.com/rednafi/httpurr)源代码，我已经下载到 `/opt/httpurr`
    目录中，像这样：
- en: '[PRE0]'
  id: totrans-split-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Search in file](#search-in-file) · [Partial matches](#partial-matches) · [Regular
    expressions](#regular-expressions) · [Fixed strings](#fixed-strings) · [Multiple
    patterns](#multiple-patterns)'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[在文件中搜索](#search-in-file) · [部分匹配](#partial-matches) · [正则表达式](#regular-expressions)
    · [固定字符串](#fixed-strings) · [多个模式](#multiple-patterns)'
- en: Search in file
  id: totrans-split-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在文件中搜索
- en: 'Let''s find all occurrences of the word `codes` in `README.md`:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `README.md` 中找到所有 `codes` 一词的出现：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE1]
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE1]
- en: So what happened here? ripgrep read the contents of `README.md`, and for each
    line that contained `codes`, ripgrep printed it to the terminal.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这里发生了什么？ripgrep 读取了 `README.md` 的内容，并对每一行包含 `codes` 的行进行了打印。
- en: ripgrep includes the line number for each line by default (use `-n`/`--line-number`
    to force this) and highlights the matches (use `--color=always` to force this).
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep 默认包含每行的行号（使用 `-n`/`--line-number` 强制此行为）并高亮匹配项（使用 `--color=always` 强制此行为）。
- en: Partial matches
  id: totrans-split-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分匹配
- en: 'ripgrep supports partial matches by default:'
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep 默认支持部分匹配：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE2]
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE2]
- en: The word `description` matches the `descr` search pattern.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单词 `description` 匹配 `descr` 搜索模式。
- en: 'To search for whole words instead, use the `-w` (`--word-regexp`) option:'
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
  zh: 若要搜索整个单词而非部分匹配，使用 `-w`（`--word-regexp`）选项：
- en: '[PRE3]'
  id: totrans-split-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE4]
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE4]
- en: ripgrep found strings containing the word `code`, but not `codes`. Try removing
    `--word-regexp` and see how the results change.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep 发现包含单词 `code` 的字符串，但没有 `codes`。尝试移除 `--word-regexp` 看看结果如何变化。
- en: Regular expressions
  id: totrans-split-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'By default, ripgrep treats the search pattern as a *regular expression*. Let''s
    find all lines with a word that contains `res` followed by other letters:'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ripgrep 将搜索模式视为*正则表达式*。让我们找到所有包含 `res` 以及后跟其他字母的单词的行：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE5]
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE5]
- en: '`\w+` means "one or more word-like characters" (e.g. letters like `p` or `o`,
    but not punctuation like `.` or `!`), so `response`, `resource`, and `rest` all
    match.'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`\w+` 表示“一个或多个类似单词的字符”（例如字母如 `p` 或 `o`，但不包括标点符号如 `.` 或 `!`），因此 `response`、`resource`
    和 `rest` 都匹配。'
- en: 'Suppose we are only interested in 4 letter words starting with `res`:'
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只对以 `res` 开头的 4 个字母单词感兴趣：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE6]
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE6]
- en: '`\b` means "word boundary" (e.g. a space, a punctuation character, or the end
    of a line), so `rest` matches, but `response` and `resource` don''t.'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`\b`意味着“单词边界”（例如空格、标点符号或行尾），因此`rest`匹配，但`response`和`resource`不匹配。'
- en: 'Finally, let''s search for 3-digit numbers (showing first 10 matches with `head`):'
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们搜索3位数（显示前10个匹配项使用`head`）：
- en: '[PRE7]'
  id: totrans-split-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE8]
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE8]
- en: A full tutorial on regular expressions is beyond the scope of this guide, but
    ripgrep's specific syntax is documented in the [regex](https://docs.rs/regex/*/regex/#syntax)
    package.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于正则表达式的完整教程超出了本指南的范围，但ripgrep的特定语法在[regex](https://docs.rs/regex/*/regex/#syntax)包中有文档记录。
- en: Fixed strings
  id: totrans-split-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定字符串
- en: 'What if we want to search for a *literal* string instead of a regular expression?
    Suppose we are interested in a word `code` followed by a dot:'
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要搜索一个*字面*字符串而不是正则表达式？假设我们对一个后跟点的单词`code`感兴趣：
- en: '[PRE9]'
  id: totrans-split-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE10]
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE10]
- en: Since `.` means "any character" in regular expressions, our pattern also matches
    `code` , `codes` and other cases we are not interested in.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`.`在正则表达式中表示“任何字符”，我们的模式也匹配`code`、`codes`及其他我们不感兴趣的情况。
- en: 'To treat the pattern as a literal string, use the `-F` (`--fixed-strings`)
    option:'
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模式视为字面字符串，请使用`-F`（`--fixed-strings`）选项：
- en: '[PRE11]'
  id: totrans-split-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE12]
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE12]
- en: Much better!
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！
- en: Multiple patterns
  id: totrans-split-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个模式
- en: To search for multiple patterns, list them with the `-e` (`--regexp`) option.
    ripgrep will output lines matching at least one of the specified patterns.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索多个模式，请使用`-e`（`--regexp`）选项列出它们。ripgrep将输出至少匹配指定模式之一的行。
- en: 'For example, search for `make` or `run`:'
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，搜索`make`或`run`：
- en: '[PRE13]'
  id: totrans-split-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE14]
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE14]
- en: 'If you have many patterns, it may be easier to put them in a file and point
    ripgrep to it with `-f` (`--file`):'
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有许多模式，将它们放在文件中并使用`-f`（`--file`）选项指向ripgrep可能更容易：
- en: '[PRE15]'
  id: totrans-split-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE16]
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE16]
- en: Recursive search
  id: totrans-split-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归搜索
- en: Previously, we used ripgrep to search a single file, but ripgrep is perfectly
    capable of recursively searching in directories.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用ripgrep在单个文件中搜索，但ripgrep可以完全递归搜索目录。
- en: '[Search in directory](#search-in-directory) · [Automatic filtering](#automatic-filtering)
    · [File globs](#file-globs) · [File types](#file-types)'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[目录中搜索](#search-in-directory) · [自动过滤](#automatic-filtering) · [文件通配符](#file-globs)
    · [文件类型](#file-types)'
- en: Search in directory
  id: totrans-split-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在目录中搜索
- en: 'Let''s find all unexported functions (they start with a lowercase letter):'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到所有未导出的函数（它们以小写字母开头）：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE17]
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE17]
- en: 'This search returned matches from both the `cmd` and `src` directories. If
    you are only interested in `cmd`, specify it instead of `.`:'
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此搜索返回了来自`cmd`和`src`目录的匹配项。如果只对`cmd`感兴趣，请指定它而不是`.`：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE18]
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE18]
- en: 'To search multiple directories, list them all like this:'
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索多个目录，请像这样列出它们：
- en: '[PRE19]'
  id: totrans-split-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE20]
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE20]
- en: Automatic filtering
  id: totrans-split-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动过滤
- en: 'ripgrep is smart enough to ignore some paths when searching:'
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep足够聪明，能够在搜索时忽略一些路径：
- en: patterns from `.gitignore`,
  id: totrans-split-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.gitignore`中的模式，'
- en: hidden files and directories,
  id: totrans-split-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏文件和目录，
- en: binary files,
  id: totrans-split-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制文件，
- en: symlinks.
  id: totrans-split-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号链接。
- en: 'For example, let''s search for GitHub action jobs:'
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们搜索GitHub操作任务：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE21]
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE21]
- en: 'Since the GitHub stuff is in a hidden `.github` directory, ripgrep won''t find
    it. But it will with the `-.` (`--hidden`) option:'
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因为GitHub的东西在一个隐藏的`.github`目录中，ripgrep找不到它。但是通过`-.` (`--hidden`)选项可以找到它：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE22]
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE22]
- en: 'Similarly, there are options to enable other paths:'
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还有选项可以启用其他路径：
- en: '`--no-ignore` to search patterns from `.gitignore`;'
  id: totrans-split-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-ignore`来搜索`.gitignore`中的模式；'
- en: '`-a` (`--text`) to search binary files;'
  id: totrans-split-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a` (`--text`)来搜索二进制文件；'
- en: '`-L` (`--follow`) to follow symlinks.'
  id: totrans-split-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-L` (`--follow`)用于跟随符号链接。'
- en: ripgrep allows you to override the ignored paths from `.gitignore` with `.ignore`
    files. See the [official guide](https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#automatic-filtering)
    for details.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep允许你用`.ignore`文件覆盖`.gitignore`中忽略的路径。详细信息请参见[官方指南](https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#automatic-filtering)。
- en: File globs
  id: totrans-split-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件glob
- en: 'Let''s search for `httpurr`:'
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们搜索`httpurr`：
- en: '[PRE23]'
  id: totrans-split-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE24]
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE24]
- en: Note that I have limited the number of results per file to 5 with the `-m` (`--max-count`)
    option to keep the results readable in case there are many matches.
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我通过`-m` (`--max-count`)选项将每个文件的结果数限制为5，以保持结果的可读性（如果有许多匹配项）。
- en: 'Quite a lot of results. Let''s narrow it down by searching only in `.go` files:'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 结果相当多。让我们通过仅在`.go`文件中搜索来缩小范围：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE25]
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE25]
- en: The `-g` (`--glob`) option takes a *glob* (filename pattern), typically containing
    a fixed part (`.go` in our example) and a wildcard `*` ("anything but the path
    separator").
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` (`--glob`)选项接受一个*glob*（文件名模式），通常包含固定部分（在我们的例子中是`.go`）和通配符`*`（“除了路径分隔符外的任何内容”）。'
- en: 'Another example — search in files named `http`-something:'
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子 — 搜索名为`http`的文件：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE26]
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE26]
- en: 'To *negate* the glob, prefix it with `!`. For example, search everywhere except
    the `.go`, `.md`, and `.rb` files:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要*取反*glob，用`!`前缀。例如，除了`.go`、`.md`和`.rb`文件外的所有地方搜索：
- en: '[PRE27]'
  id: totrans-split-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE28]
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE28]
- en: All that is left is `go.mod`.
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是`go.mod`。
- en: 'To apply multiple filters, specify multiple glob options. For example, find
    all functions except those in test files:'
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用多个过滤器，请指定多个glob选项。例如，查找所有函数，除了测试文件中的函数：
- en: '[PRE29]'
  id: totrans-split-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE30]
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE30]
- en: File types
  id: totrans-split-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件类型
- en: 'Instead of using a glob to filter by extension, you can use ripgrep''s support
    for file types. Let''s search for `httpurr` in `.go` files:'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用glob按扩展名过滤，你可以使用ripgrep对文件类型的支持。让我们在`.go`文件中搜索`httpurr`：
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE31]
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE31]
- en: The `-t` (`--type`) option restricts the search results to files of a certain
    type (Go source files in our example).
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t` (`--type`)选项将搜索结果限制为特定类型的文件（在我们的例子中是Go源文件）。'
- en: 'To exclude files of a certain type, use `-T` (`--not-type`):'
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要排除特定类型的文件，请使用`-T` (`--not-type`)选项：
- en: '[PRE32]'
  id: totrans-split-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE33]
  id: totrans-split-107
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE33]
- en: We've excluded Go, Markdown and Ruby files, so all that's left is `go.mod` (personally,
    I'd consider it a Go file as well, but ripgrep disagrees).
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经排除了Go、Markdown和Ruby文件，所以剩下的只有`go.mod`（就我个人而言，我也认为它是Go文件，但ripgrep不这么认为）。
- en: Useful options
  id: totrans-split-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的选项
- en: ripgrep supports a number of additional search and output options you may find
    handy.
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep支持多种额外的搜索和输出选项，这些选项可能对你很有用。
- en: '[Ignore case](#ignore-case) · [Inverse matching](#inverse-matching) · [Count
    matches](#count-matches) · [Show matches only](#show-matches-only) · [Show files
    only](#show-files-only) · [Show context](#show-context) · [Multiline search](#multiline-search)'
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[忽略大小写](#ignore-case) · [反向匹配](#inverse-matching) · [计数匹配项](#count-matches)
    · [仅显示匹配项](#show-matches-only) · [仅显示文件](#show-files-only) · [显示上下文](#show-context)
    · [多行搜索](#multiline-search)'
- en: Ignore case
  id: totrans-split-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略大小写
- en: Remember our search for `codes` in the README?
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在README中搜索`codes`的情况吗？
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE34]
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE34]
- en: 'It returns `codes` matches, but not `Codes` because ripgrep is case-sensitive
    by default. To change this, use `-i` (`--ignore-case`):'
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回`codes`的匹配项，但不返回`Codes`，因为ripgrep默认区分大小写。要更改此设置，请使用`-i`（`--ignore-case`）：
- en: '[PRE35]'
  id: totrans-split-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE36]
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE36]
- en: 'There is also `-S` (`--smart-case`), which behaves like `--ignore-case` unless
    the search pattern is all caps:'
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`-S`（`--smart-case`），它的行为类似于`--ignore-case`，除非搜索模式全为大写：
- en: '[PRE37]'
  id: totrans-split-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE38]
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE38]
- en: Searching for `HTTP` matches `HTTP`, but not `https` or `httpurr`.
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索`HTTP`会匹配`HTTP`，但不会匹配`https`或`httpurr`。
- en: Inverse matching
  id: totrans-split-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向匹配
- en: 'To find lines that *do not* contain the pattern, use `-v` (`--invert-match`).
    For example, find the non-empty lines without the `@` symbol:'
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找*不包含*模式的行，请使用`-v`（`--invert-match`）。例如，查找不含`@`符号的非空行：
- en: '[PRE39]'
  id: totrans-split-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE40]
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE40]
- en: Count matches
  id: totrans-split-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数匹配项
- en: 'To count the number of matched lines (per file), use `-c` (`--count`). For
    example, count the number of functions in each `.go` file:'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算每个`.go`文件中匹配行的数量，请使用`-c`（`--count`）。例如，计算每个`.go`文件中的函数数量：
- en: '[PRE41]'
  id: totrans-split-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE42]
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE42]
- en: 'Note that `--count` counts the number of *lines*, not the number of matches.
    For example, there are 6 words `string` in `src/cli.go`, but two of them are on
    the same line, so `--count` reports 5:'
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`--count`计算的是*行数*，而不是匹配数。例如，`src/cli.go`中有6个`string`单词，但其中两个在同一行，所以`--count`报告5：
- en: '[PRE43]'
  id: totrans-split-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE44]
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE44]
- en: 'To count the number of *matches* instead, use `--count-matches`:'
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算*匹配项*的数量，请使用`--count-matches`：
- en: '[PRE45]'
  id: totrans-split-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE46]
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE46]
- en: Show matches only
  id: totrans-split-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅显示匹配项
- en: By default, ripgrep prints the entire line containing the match. To show only
    the matching part, use `-o` (`--only-matching`).
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ripgrep会打印包含匹配项的整行内容。要仅显示匹配的部分，请使用`-o`（`--only-matching`）选项。
- en: 'Suppose we want to find functions named `print`-something:'
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要查找名称为`print`-something的函数：
- en: '[PRE47]'
  id: totrans-split-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE48]
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE48]
- en: The results are much cleaner than without `--only-matching` (try removing the
    option in the above command and see for yourself).
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结果要比没有使用`--only-matching`（尝试在上述命令中删除该选项并自行查看）时更清晰。
- en: Show files only
  id: totrans-split-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅显示文件
- en: 'If there are too many matches, you may prefer to show only the files where
    the matches occurred. Use `-l` (`--files-with-matches`) to do this:'
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配项过多，可能更喜欢仅显示出现匹配项的文件。使用`-l`（`--files-with-matches`）即可实现此功能：
- en: '[PRE49]'
  id: totrans-split-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE50]
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE50]
- en: Show context
  id: totrans-split-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示上下文
- en: Remember when we searched for GitHub jobs?
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们搜索GitHub职位时的情景吗？
- en: '[PRE51]'
  id: totrans-split-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE52]
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE52]
- en: 'These results are kind of useless, because they don''t return the actual job
    name (which is on the next line after `jobs`). To fix this, let''s use `-C` (`--context`),
    which shows `N` lines around each match:'
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果有点无用，因为它们不返回实际的工作名称（该名称位于 `jobs` 后的下一行）。为了解决这个问题，让我们使用 `-C` (`--context`)，显示每个匹配周围的
    `N` 行：
- en: '[PRE53]'
  id: totrans-split-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE54]
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE54]
- en: 'It might be even better to show only the *next* line after the match, since
    we are not interested in the previous one. Use `-A` (`--after-context`) for this:'
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
  zh: 也许只显示匹配后的 *下一行* 会更好，因为我们不关心前一行。使用 `-A` (`--after-context`) 来实现这一点：
- en: '[PRE55]'
  id: totrans-split-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE56]
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE56]
- en: Nice!
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！
- en: Multiline search
  id: totrans-split-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多行搜索
- en: 'I have another idea for searching GitHub jobs. Since the job name is always
    on the next line after the literal `jobs:`, let''s enable multiline searching
    with `-U` (`--multiline`):'
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我有另一个搜索 GitHub 职位的想法。由于工作名称总是在字面上 `jobs:` 后的下一行，让我们启用带有 `-U` (`--multiline`)
    的多行搜索：
- en: '[PRE57]'
  id: totrans-split-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE58]
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE58]
- en: Now we can see the job names even without using `--context`.
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在即使不使用 `--context`，我们也可以看到工作名称。
- en: Replacements
  id: totrans-split-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换
- en: ripgrep provides a limited ability to replace matched text with some other text.
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep 提供了有限的能力来用其他文本替换匹配的文本。
- en: '[Replace matches](#replace-matches) · [Replace entire line](#replace-entire-line)
    · [Replace groups](#replace-groups)'
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[替换匹配项](#replace-matches) · [替换整行](#replace-entire-line) · [替换分组](#replace-groups)'
- en: Replace matches
  id: totrans-split-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换匹配项
- en: Remember our search for `codes` in the README?
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在 README 中搜索 `codes` 的例子吗？
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE59]
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE59]
- en: 'Now let''s replace all `codes` with `ids` using the `-r` (`--replace`) option:'
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `-r` (`--replace`) 选项将所有 `codes` 替换为 `ids`：
- en: '[PRE60]'
  id: totrans-split-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE61]
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE61]
- en: Replace entire line
  id: totrans-split-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换整行
- en: 'Replace applies only to the matching portion of text. To replace an entire
    line of text, include the entire line in the match like this:'
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
  zh: 替换仅适用于匹配文本的部分。要替换整行文本，包括整行在内，像这样匹配：
- en: '[PRE62]'
  id: totrans-split-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE63]
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE63]
- en: 'Alternatively, you can combine the `-o` (`--only-matching`) option with `--replace`
    to achieve the same result:'
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以结合 `-o` (`--only-matching`) 选项和 `--replace` 来达到相同的结果：
- en: '[PRE64]'
  id: totrans-split-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE65]
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE65]
- en: Replace groups
  id: totrans-split-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换分组
- en: 'Replacements can include capturing groups. Let''s say we want to find all occurrences
    of `status` followed by another word and join them together with a dash. The pattern
    we might use is `status\s+(\w+)`:'
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: 替换可以包括捕获组。假设我们想要找到所有 `status` 后面跟着另一个单词的出现，并用破折号将它们连接起来。我们可能使用的模式是 `status\s+(\w+)`：
- en: literal string `status`,
  id: totrans-split-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面字符串 `status`，
- en: followed by any number of whitespace characters,
  id: totrans-split-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后跟任意数量的空白字符，
- en: followed by any number of "word" characters (e.g. letters).
  id: totrans-split-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后跟任意数量的 "word" 字符（例如字母）。
- en: 'We put the `\w+` in a "capturing group" (indicated by parentheses) so that
    we can reference it later in our replacement string. For example:'
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `\w+` 放在 "捕获组" 中（由括号表示），以便稍后在我们的替换字符串中引用它。例如：
- en: '[PRE66]'
  id: totrans-split-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE67]
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" command="aha" editor="basic" template="httpurr.sh"
    output-mode="html" output="">[PRE67]
- en: Our replacement string (`status-$1`) consists of the literal `status-` followed
    by the contents of the capturing group at index `1`.
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的替换字符串 (`status-$1`) 包括字面上的 `status-`，后跟捕获组索引 `1` 的内容。
- en: Capturing groups actually start at index `0`, but the 0th capturing group always
    corresponds to the entire match. The capturing group at index `1` always corresponds
    to the first explicit capturing group found in the regex pattern.
  id: totrans-split-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 捕获组实际上从索引 `0` 开始，但第 `0` 个捕获组始终对应于整个匹配。索引 `1` 处的捕获组始终对应于正则表达式模式中找到的第一个显式捕获组。
- en: ripgrep **will never modify your files**. The `--replace` flag only controls
    ripgrep's output. (And there is no flag to let you do a replacement in a file.)
  id: totrans-split-188
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep **永远不会修改您的文件**。`--replace` 标志仅控制 ripgrep 的输出。（并且没有标志可以让您在文件中进行替换。）
- en: Configuration
  id: totrans-split-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: ripgrep's has reasonable defaults, but you can change them with configuration
    files.
  id: totrans-split-190
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep 默认具有合理的默认设置，但您可以通过配置文件进行更改。
- en: ripgrep does not automatically look for a config file in a predefined directory.
    To use a config file, set the `RIPGREP_CONFIG_PATH` environment variable to its
    path.
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep 不会自动在预定义目录中查找配置文件。要使用配置文件，请将 `RIPGREP_CONFIG_PATH` 环境变量设置为其路径。
- en: 'Here''s an example of a configuration file:'
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个配置文件的示例：
- en: <codapi-snippet sandbox="shell" editor="basic" template="config.sh" output="">[PRE68]
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" editor="basic" template="config.sh" output="">[PRE68]
- en: When specifying a flag that has a value, either put the flag and the value on
    the same line with a `=` sign (e.g. `--max-columns=40`), or put the flag and the
    value on two different lines (e.g., `--glob`). Do not put them on the same line
    without an equal sign (e.g. not `--max-columns 40`).
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定一个带有值的标志时，可以将标志和值放在同一行，并用 `=` 符号连接（例如 `--max-columns=40`），或者将标志和值放在两行（例如
    `--glob`）。不要在同一行上放置它们而不带等号（例如不要 `--max-columns 40`）。
- en: 'Let''s search using this config:'
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个配置进行搜索：
- en: '[PRE69]'
  id: totrans-split-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: <codapi-snippet sandbox="shell" editor="basic" template="config.sh" output="">[PRE70]
  id: totrans-split-197
  prefs: []
  type: TYPE_NORMAL
  zh: <codapi-snippet sandbox="shell" editor="basic" template="config.sh" output="">[PRE70]
- en: Further reading
  id: totrans-split-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: ripgrep supports more features, such as explicit handling of encodings or searching
    binary data. See the [official guide](https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md)
    for details.
  id: totrans-split-199
  prefs: []
  type: TYPE_NORMAL
  zh: ripgrep 支持更多功能，例如显式处理编码或搜索二进制数据。有关详细信息，请参阅[官方指南](https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md)。
- en: Use `rg --help` to see all supported options (we have covered less than half
    of them in this guide).
  id: totrans-split-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rg --help` 查看所有支持的选项（我们在本指南中仅覆盖了不到一半）。
- en: '[Andrew Gallant](https://blog.burntsushi.net) + [1 others](#contributors) ·
    [original](https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md) · CC-BY-SA-4.0
    · 2024-03-19'
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[Andrew Gallant](https://blog.burntsushi.net) + [1 others](#contributors) ·
    [original](https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md) · CC-BY-SA-4.0
    · 2024-03-19'
- en: '[Andrew Gallant](https://blog.burntsushi.net), [Anton Zhiyanov](https://antonz.org)</codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet>'
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[Andrew Gallant](https://blog.burntsushi.net)，[Anton Zhiyanov](https://antonz.org)</codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet></codapi-snippet>'
