- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 12:31:51'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Rust to WASI
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://benw.is/posts/compiling-rust-to-wasi](https://benw.is/posts/compiling-rust-to-wasi)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Recently I've been taking a bit of a break from building and interacting with
    Rust compiled to the Webassembly target `wasm32-unknown-unknown`, and instead
    spending [a lot of time](https://github.com/fermyon/leptos-spin) working with
    Rust compiled to [WASI](https://wasi.dev/), or the `wasm32_wasi` target.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: You'd be forgiven if you're not sure of the distinction between these two, they're
    both webassembly right? The answer is yes, but they're different in several crucial
    ways. I like to think of the `wasm32-unknown-unknown` as analogous to `no_std`.
    It has no access to anything outside of the webassembly virtual machine. None
    of the standard system calls for file access, network requests, or the kernel
    will be available in the traditional way. This is the target that is supported
    natively by the browser, and is used by Leptos for client side interactivity.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm32-wasi` is `wasm32-unknown-unkown` plus the missing traditional stuff.
    It reimplements the traditional system calls like `read()` and provide access
    to things C expects like `File*` objects. It also fixes a crucial ABI incompatibility
    with `wasm32-unknown-unknown`, due to an [error in the ABI](https://github.com/rust-lang/rust/issues/83788)
    used by `wasm-bindgen` that has become a Rust standard. If you want to hear more
    about that, read on, otherwise you can skip to the next section. I spent far too
    much time figuring this out, so y''all get to hear about it too.'
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: Way back when, when webassembly support in Rust was young, the Rust developer
    working on it made a mistake involving how Rust handles structs in wasm-bindgen.
    LLVM and Clang say passing a struct by value should inline the fields, while for
    Rust it should be passed by pointer. This becomes a problem when you have Rust
    code that interacts with C and does this. Whether compiled together with Rust
    or as a seperate C webassembly module compiled to emscripten, this issue rears
    it's ugly head.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: This is also why Rust code compiled to `wasm32_wasi` and `wasm32-unknown-emscripten`
    can have difficulties talking to each other.
  id: totrans-split-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At some point this issue was fixed for Rust's C ABI, but fixing it for the `wasm32-unknown-unknown`
    target would break compatibility with Rust apps compiled to webassembly with wasm-bindgen
    under the old behavior. Which leaves us in a bit of a bind. wasm-bindgen now has
    [*forward* compatibility](https://github.com/rustwasm/wasm-bindgen/pull/3595)
    with the possible new ABI, meaning it no longer has an issue, but how to introduce
    that in the Rust ecosystem has been a matter of debate. Should you create a new
    target like `wasm32-unknown-unknown2`? Switch it one day? Switch it across an
    edition boundary?
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: For now at least, Rust has decided to eventually incorporate an unstable flag
    that fixes the ABI by switching to the existing C ABI. The [PR](https://github.com/rust-lang/rust/pull/117919)
    for that is here, and the MCP for it has been approved, so it's likely to get
    into the language sometime in the future. So that's fun news. Avoiding passing
    any structs across the ABI boundary is another option, but requires editing all
    the parties involved. Personally I have no appetite for editing all C dependencies
    I might want to use, but you do you.
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: As a fun fact, the `wasm32-wasi` and `wasm32-unknown-emscripten` targets have
    fixed this incompatibility. I suppose the first is new enough and the second is
    unknown/purpose built enough that it was deemed appropriate to do so. For `wasm32-wasi`,
    here was [the fix](https://github.com/rust-lang/rust/pull/79998).
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: One of the sellings points of Webassembly and WASI is that things compiled to
    it are supposed to be portable, but the ABI spec for each language is left up
    to the languages themselves. Perhaps because C is the largest/oldest language,
    we seem to be coalescing arounding [whatever the C/Clang/llvm folks](https://github.com/WebAssembly/tool-conventions/blob/main/BasicCABI.md)
    decide to do. This can have [other implications](https://faultlore.com/blah/c-isnt-a-language/),
    as this lovely article describes for existing systems. At any rate, the Rust folks
    haven't totally commited to this, with a "wasm" ABI option for Rust compiled to
    Webassembly in [the works](https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-04-21-wasm-abi.md),
    and I have no idea what any other languages
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: Now that you all have learned so much about webassembly and webassembly in Rust(or
    skipped straight here), let's talk about building a crate. I started out on this
    journey because I wanted a better editor for blog posts on my blog. For that I
    use [femark](https://crates.io/crates/femark), a crate that I wrote combining
    treesitter and pulldown-cmark to compile markdown to HTML with syntax highlighted
    code blocks. Only trouble with this is that treesitter(and its parsers) are written
    in C/C++.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: Historically I've been converting to html on the server, where the crate can
    be compiled by Rust quite easily. This time I realized that to get the live preview
    experience I desired, I'd have to run it in the browser. And I'm happy to say,
    after much finagling, I was able to get there with the help of Joel Dice and several
    lovely folks on the WASI Zulip.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: Compile Femark to WASI
  id: totrans-split-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'd think this part would be easy, just run
  id: totrans-split-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: bash
  id: totrans-split-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and it'd spit out a wasm file right? Wrong! Instead you get this
  id: totrans-split-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C code
  id: totrans-split-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Turns out the Rust compiler does not know how to handle the C/C++ in the parsers
    for this target. So I went and downloaded the [wasi-sdk](https://github.com/WebAssembly/wasi-sdk)
    and install the released binaries to `/opt/wasi-sdk-21.0`. And then set some RUSTFLAGs
    and env vars to point to things in it.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: bash
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use a special version of clang and other c libs they provide to make wasi/C
    interop easier. Messing with C/C++ compilers is definitely not my forte, so I
    was very thankful to have help figuring that out. Thankfully this builds.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用他们提供的特殊版本的 clang 和其他 C 库，使 wasi/C 互操作更容易。弄清楚 C/C++ 编译器并不是我的强项，所以我非常感谢有人帮助弄清楚这一点。幸运的是这次编译成功了。
- en: Convert a WASI preview 1 file to a WASI preview 2 file
  id: totrans-split-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 WASI 预览 1 文件转换为 WASI 预览 2 文件
- en: If you've been following the development of WASI, you'd know that fairly recently
    we saw the release of [WASI preview 2](https://component-model.bytecodealliance.org/).
    WASI preview 2 provides a component model for WASI components, allowing them to
    talk to each other. Currently, the `wasm32-wasi` target for Rust aims at WASI
    preview 1\. We want preview 2 to get WASI to run in the browser with the newly
    released [jco](https://bytecodealliance.org/articles/jco-1.0) transpiler. The
    linked article mentions allowing WASI preview 2 components to run in node.js,
    but it also has a bit more experimental support for running them in the browser.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在关注 WASI 的发展，你就会知道最近我们看到了 [WASI 预览 2 的发布](https://component-model.bytecodealliance.org/)。WASI
    预览 2 为 WASI 组件提供了一个组件模型，允许它们相互通信。目前，Rust 的 `wasm32-wasi` 目标针对的是 WASI 预览 1。我们希望预览
    2 能够让 WASI 在浏览器中运行，配合新发布的 [jco](https://bytecodealliance.org/articles/jco-1.0)
    转换器。链接的文章提到允许 WASI 预览 2 组件在 node.js 中运行，但它还有更多实验性支持在浏览器中运行它们。
- en: The easiest way to convert a wasi preview 1 module to a wasi preview 2 component
    is to use [cargo-component](https://github.com/bytecodealliance/cargo-component),
    which basically replaces the command above. You do still need all the RUSTFLAGS
    and other env vars up there. If you don't use `cargo component new` to handle
    this for you, I found it works by adding this to your Cargo.toml. The key here
    is that the part after the colon matches your world defined in the wit file.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将 WASI 预览 1 模块转换为 WASI 预览 2 组件的最简单方法是使用 [cargo-component](https://github.com/bytecodealliance/cargo-component)，基本上替换了上面的命令。你仍然需要所有的
    RUSTFLAGS 和其他环境变量。如果你不使用 `cargo component new` 来处理这些问题，我发现通过将以下内容添加到你的 Cargo.toml
    文件中也能运行。关键在于冒号后面的部分要与你在 wit 文件中定义的世界匹配。
- en: TOML markup
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: TOML 标记
- en: '[PRE3]'
  id: totrans-split-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'and then setting up the wit bindings. WASI2 defines functions and types that
    are exported and imported from other components using the [WIT language](https://component-model.bytecodealliance.org/design/wit.html).
    Cargo component will take those bindings, and then match them to Rust functions
    defined in a `Guest` trait implementation. For this crate, we only want to export
    two Rust functions:'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后设置 wit 绑定。WASI2 定义了使用 [WIT 语言](https://component-model.bytecodealliance.org/design/wit.html)
    从其他组件导出和导入的函数和类型。Cargo component 将使用这些绑定，并将它们与 `Guest` trait 中定义的 Rust 函数匹配。对于这个
    crate，我们只想导出两个 Rust 函数：
- en: wit
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 机智
- en: '[PRE4]'
  id: totrans-split-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I won't get too far into the WIT language here, but it's fairly Rust like, and
    I found it functional and fairly easy to pick up. The part that threw me while
    writing this is that while the functions are mapped to Rust functions, the types
    defined here will be automatically converted into Rust types. So existing versions
    of `HighlightError`, `HtmlOutput` and more in Rust needed to be deleted and replaced
    with generated versions from the autogenerated bindings.rs file.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里深入讨论 WIT 语言，但它相当于 Rust，并且我发现它功能强大且易于掌握。在写这篇文章时让我感到困惑的部分是，虽然函数映射到 Rust
    函数，但在这里定义的类型将自动转换为 Rust 类型。因此，需要删除 Rust 中现有版本的 `HighlightError`、`HtmlOutput` 等，并用自动生成的
    bindings.rs 文件中的生成版本替换它们。
- en: To map the functions, we define a `Component` struct and implement the `Guest`
    trait for it in `src/lib.rs`.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了映射这些函数，我们在 `src/lib.rs` 中定义了一个 `Component` 结构体，并为其实现了 `Guest` trait。
- en: Rust code
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 代码
- en: '[PRE5]'
  id: totrans-split-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With all that done, we can run `cargo component build` and get a WASI preview
    2 component `.wasm` file with these exported functions and types built in.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们可以运行 `cargo component build` 并获得一个包含这些导出函数和类型的 WASI 预览 2 组件 `.wasm`
    文件。
- en: Remember all that text I wrote about ABI incompatibility earlier? Well, WASI
    preview 2 defines a [Canonical ABI](https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md)
    so that all the languages compiled to WASI can talk to eother WASI components.
    However, how these types and functions are repesented by their respective languages
    in the webassembly itself is up to each language. So we'd still have issues with
    ABI mismatches compiling Rust and C into the same WASI component, but if they
    were compiled into seperate ones, there'd be a common interface language.
  id: totrans-split-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Transpile it for the web with jco
  id: totrans-split-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[jco](https://github.com/bytecodealliance/jco) can transpile the `.wasm` file
    we generated above into a JS ESM module that node.js and the browser can understand.
    Using it is actually pretty easy. Before we transpile it, jco has a command to
    see the imports and exports of a WASI2 module.'
  id: totrans-split-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: bash
  id: totrans-split-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-split-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output for my module is seen below.
  id: totrans-split-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: wit
  id: totrans-split-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-split-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Looks very similar to our wit file right? The only new stuff here we can see
    is all of the wasi function imports automatically added by wasi. Pretty neat huh?
  id: totrans-split-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: bash
  id: totrans-split-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-split-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So now it'll get transpiled into a folder containing a few wasm files and some
    js glue
  id: totrans-split-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: bash
  id: totrans-split-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-split-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's take a peek in the JS file and see what we see. Probably without the --minify
    to make it a bit easier to read. It's quite long, so I'll link to it here
  id: totrans-split-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: JavaScript code
  id: totrans-split-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-split-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*It''s definitely interesting to see the shenanigans JS has to jump through
    to match the type system of Wit or Rust. Returning a `result<htmloutput, highlighterro>`
    creates a ton of switch cases blocks! At the top we can see a number of imports
    and at the bottom exports of the named functions we''re looking for!'
  id: totrans-split-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember how WASI provides all those interfaces to common system functions?
    Well those are provided through a `@bytecodealliance/preview2-shim`. package If
    you're using Node or using a JS bundler, you can pretty easily pull in the [npm
    package](https://www.npmjs.com/package/@bytecodealliance/preview2-shim?activeTab=versions).
    Since I'm doing neither of those things, I need to serve that library from my
    web server, and change all the paths in the js file to point towards a local [copy
    of it](https://github.com/bytecodealliance/jco/tree/main/packages/preview2-shim).
  id: totrans-split-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: JavaScript code
  id: totrans-split-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-split-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is from the minified version, but you can see I'm setting absolute paths
    to the folder served by my server. With this in place, we should be ready to move
    on!*
  id: totrans-split-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**   Serve all the files'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, we need to serve the `preview2-shim/lib/browser` folder
    as well as the femark wasm and js files we generated earlier. On Leptos for SSR
    apps, this is pretty easy, just put them in your assets dir. The more interesting
    part is how to use it.
  id: totrans-split-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use wasm_bindgen to generate Rust bindings to the exported J'S functions for
    Leptos
  id: totrans-split-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: wasm_bindgen to the rescue! Here we see the wasm functions, exported to JS,
    and then passed into extern C blocks as required by wasm_bindgen. Since the return
    types are structs, I redefine the returned types and create helper functions to
    parse them from `JsValue`. There's probably a better way to do this, but the types
    are defined in a crate that won't compile to wasm32_unknown_unknown, and I figured
    this would be easier than defining a seperate types crate.
  id: totrans-split-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: wasm_bindgen 来拯救！在这里我们看到了导出到JS的wasm函数，并按照wasm_bindgen的要求将其传递到extern C块中。由于返回类型是结构体，我重新定义了返回类型，并创建了帮助函数来从`JsValue`中解析它们。可能有更好的方法来做这个，但是类型是在一个无法编译到wasm32_unknown_unknown的crate中定义的，我想这比定义一个单独的类型crate要容易些。
- en: Rust code
  id: totrans-split-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rust 代码
- en: '[PRE12]'
  id: totrans-split-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Use it in a Leptos component
  id: totrans-split-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Leptos组件中使用它
- en: Finally, the moment of truth! We've compiled our library to WASI preview 2,
    transpiled it with JCO to generate JS bindings, and shimmed the wasi calls with
    a locally served copy of the preview2-shim package. The good news is that since
    those are now regular Rust functions, we can call it as if it was one.
  id: totrans-split-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终，决定时刻到了！我们已经将我们的库编译成了WASI预览2版，用JCO进行了转译以生成JS绑定，并用本地提供的preview2-shim包来衬接wasi调用。好消息是，因为这些现在是普通的Rust函数，我们可以像调用普通函数一样调用它。
- en: Because I'm using it in wasm_bindgen to process the returned values, you can
    see I've gated the function imports for our markdown processing functions behind
    a feature flag
  id: totrans-split-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我在wasm_bindgen中使用它来处理返回的值，你可以看到我已经将我们的markdown处理函数的函数导入放在了一个特性标志后面。
- en: Rust code
  id: totrans-split-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rust 代码
- en: '[PRE13]*'
  id: totrans-split-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE13]*'
- en: '*If you''ll notice, we crate an `on:input` event handler that will read the
    value of the textarea, and calls our `process_markdown_to_html_with_frontmatter()`
    function that we imported from WASI, but only on the client, because it''s only
    defined there.'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你注意到的话，我们创建了一个`on:input`事件处理程序，它将读取文本区域的值，并调用我们从WASI导入的`process_markdown_to_html_with_frontmatter()`函数，但只在客户端上，因为它只在那里定义。'
- en: Success! You can even try it yourself by adding `/edit` to the end of this post
    url like [so](https://benw.is/posts/compiling-rust-to-wasi/edit). If I setup auth
    right, you won't be able to actually commit changes, and if I didn't I'm sure
    someone will let me know :).
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！你甚至可以尝试自己添加`/edit`到这篇文章URL的末尾，像这样[so](https://benw.is/posts/compiling-rust-to-wasi/edit)。如果我设置了正确的认证，你将无法提交更改，如果我没有，我相信会有人告诉我的
    :）。
- en: On this journey I learned a lot about webassembly, wasi, and wasi tooling in
    the Rust ecosystem. I have to say I'm excited, both for what's possible now and
    what's coming in the future. There idea that we could write programs in our own
    favorite language, and compile it to a universal format that can executed on almost
    any platform is truly revolutionary. I'm reminded of this [talk](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript)
    from DestroyAllSoftware in which he posits that these kinds of virtualized environments
    might take over the world, and it feels they were somewhat prescient.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个旅程中，我对WebAssembly、WASI和Rust生态系统中的WASI工具有了很多了解。我不得不说我很兴奋，既为现在可能的事情，也为未来即将到来的事情。我们能够用自己喜欢的编程语言编写程序，并将其编译成几乎任何平台都可以执行的通用格式，这种想法确实是革命性的。我想起了DestroyAllSoftware的这个[演讲](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript)，他在其中提出这些虚拟化环境可能会主导世界，看来他们有点先见之明。
- en: The tooling itself is a bit wonky and experimental, but I expect that'll be
    resolved in time. If you happen to have a Rust only project, I expect compiling
    to WASI preview 2 would be somewhat smoother.The Rust project and the people behind
    the Bytecode Alliance seem to working diligently to make it as easy as possible.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: 工具本身有点奇怪和实验性，但我预计随着时间的推移会解决这个问题。如果你碰巧有一个纯Rust项目，我预计编译到WASI预览2会顺利些。Rust项目和Bytecode
    Alliance背后的人似乎正在努力使其尽可能简单。
- en: For those who want to take a deeper look at the generated wasi or the Leptos
    app that uses it, feel free to check out the github repo [here](https://github.com/benwis/benwis_spin).
    In theory there should be a place where I can post the WASI file as a module for
    others to use, like crates.io, and if I find one I'll post it there as well. If
    you're working on a cool WASI project, I'd love to hear about it! Feel free to
    message me on my Mastodon at @benwis@hachyderm.io or through my other social media
    methods*
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想深入了解生成的wasi或使用它的Leptos应用程序的人，欢迎查看GitHub仓库[这里](https://github.com/benwis/benwis_spin)。理论上应该有一个地方可以发布WASI文件作为模块供其他人使用，就像crates.io一样，如果我找到了，我也会在那里发布。如果你正在做一个酷炫的WASI项目，我很乐意听到。请随时通过我的Mastodon
    @benwis@hachyderm.io或其他社交媒体联系方式来联系我。
