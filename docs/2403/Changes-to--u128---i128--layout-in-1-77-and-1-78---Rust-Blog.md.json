["```\nuse core::mem::{align_of, offset_of};\n\n#[repr(C)]\nstruct Foo {\n    a: u8,  // 1-byte aligned\n    b: u16, // 2-byte aligned\n}\n\n#[repr(C)]\nstruct Bar {\n    a: u8,  // 1-byte aligned\n    b: u64, // 8-byte aligned\n}\n\nprintln!(\"Offset of b (u16) in Foo: {}\", offset_of!(Foo, b));\nprintln!(\"Alignment of Foo: {}\", align_of::<Foo>());\nprintln!(\"Offset of b (u64) in Bar: {}\", offset_of!(Bar, b));\nprintln!(\"Alignment of Bar: {}\", align_of::<Bar>()); \n```", "```\nOffset of b (u16) in Foo: 2\nAlignment of Foo: 2\nOffset of b (u64) in Bar: 8\nAlignment of Bar: 8 \n```", "```\nprintln!(\"alignment of i128: {}\", align_of::<i128>()); \n```", "```\n// rustc 1.76.0\nalignment of i128: 8 \n```", "```\nprintf(\"alignment of __int128: %zu\\n\", _Alignof(__int128)); \n```", "```\n// gcc 13.2\nalignment of __int128: 16\n\n// clang 17.0.1\nalignment of __int128: 16 \n```", "```\n> typedef struct {\n>     long low, high;\n> } __int128; \n> ```", "```\n/* full example at <https://godbolt.org/z/5c8cb5cxs> */\n\n/* to see the issue, we need a padding value to \"mess up\" argument alignment */\nvoid foo(char pad, __int128 a, __int128 b, __int128 c) {\n    printf(\"%#x\\n\", pad & 0xff);\n    print_i128(a);\n    print_i128(b);\n    print_i128(c);\n}\n\nint main() {\n    asm(\n        /* load arguments that fit in registers */\n        \"movl    $0xaf, %edi \\n\\t\"                /* 1st slot (edi): padding char (`edi` is the\n                                                   * same as `rdi`, just a smaller access size) */\n        \"movq    $0x9900aabbccddeeff, %rsi \\n\\t\"  /* 2rd slot (rsi): lower half of `a` */\n        \"movq    $0x1122334455667788, %rdx \\n\\t\"  /* 3nd slot (rdx): upper half of `a` */\n        \"movq    $0x9900aabbccddeeff, %rcx \\n\\t\"  /* 4th slot (rcx): lower half of `b` */\n        \"movq    $0x1122334455667788, %r8  \\n\\t\"  /* 5th slot (r8):  upper half of `b` */\n        \"movq    $0xdeadbeef4c0ffee0, %r9  \\n\\t\"  /* 6th slot (r9):  should be unused, but\n                                                   * let's trick clang! */\n\n        /* reuse our stored registers to load the stack */\n        \"pushq   %rdx \\n\\t\"                       /* upper half of `c` gets passed on the stack */\n        \"pushq   %rsi \\n\\t\"                       /* lower half of `c` gets passed on the stack */\n\n        \"call    foo \\n\\t\"                        /* call the function */\n        \"addq    $16, %rsp \\n\\t\"                  /* reset the stack */\n    );\n} \n```", "```\n0xaf\n0x11223344556677889900aabbccddeeff\n0x11223344556677889900aabbccddeeff\n0x11223344556677889900aabbccddeeff \n```", "```\n0xaf\n0x11223344556677889900aabbccddeeff\n0x11223344556677889900aabbccddeeff\n0x9900aabbccddeeffdeadbeef4c0ffee0\n//^^^^^^^^^^^^^^^^ this should be the lower half\n//                ^^^^^^^^^^^^^^^^ look familiar? \n```", "```\nprintln!(\"alignment of i128: {}\", align_of::<i128>()); \n```", "```\n// rustc 1.77.0\nalignment of i128: 16 \n```"]