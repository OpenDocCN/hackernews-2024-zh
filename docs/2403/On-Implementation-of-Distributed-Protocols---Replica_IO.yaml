- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 14:40:44'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:40:44'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: On Implementation of Distributed Protocols | Replica_IO
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在分布式协议实现上 | Replica_IO
- en: 来源：[https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols](https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols](https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols)
- en: This post concludes the first phase of the [state-of-the-art exploration](https://github.com/replica-io/replica-io/issues/7)
    in the scope of milestone [M0.1](https://github.com/replica-io/replica-io/milestone/1)
    of the Replica_IO project, namely exploration of selected notable distributed
    protocol implementations. It shares the main conclusions drawn from exploring
    14 different code bases and outlines the key areas of focus for the next steps
    developing the Replica_IO framework.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章总结了 Replica_IO 项目的里程碑[M0.1](https://github.com/replica-io/replica-io/milestone/1)的范围内的第一阶段[最新技术探索](https://github.com/replica-io/replica-io/issues/7)，即对选定的显著分布式协议实现的探索。它分享了从探索
    14 个不同代码库中得出的主要结论，并概述了下一步发展 Replica_IO 框架的关键重点。
- en: A companion video is available [here](https://youtu.be/Q6wW8NqtpGw).
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个配套视频可在[此处](https://youtu.be/Q6wW8NqtpGw)找到。
- en: Exploring Distributed Protocol Implementations[​](#exploring-distributed-protocol-implementations
    "Direct link to Exploring Distributed Protocol Implementations")
  id: totrans-split-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索分布式协议实现[​](#exploring-distributed-protocol-implementations "直接链接到探索分布式协议实现")
- en: I believe that discovering neat, yet practical, solutions to complicated problems
    demands serious, deliberate preparation. Clearly, before being able to come up
    with such solutions, one first needs to acquire a deep understanding of the problem,
    identify the relevant aspects and requirements. It is also important to learn
    from prior attempts to deal with the problem. Otherwise, it would be naive to
    expect any significant advancement beyond the status quo.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，发现复杂问题的整洁而实用的解决方案需要严肃、深思熟虑的准备。显然，在能够提出这样的解决方案之前，首先需要深入理解问题，识别相关的方面和需求。从先前尝试解决问题的经验中学习也是很重要的。否则，期望在现状之外有任何重大进展将显得幼稚。
- en: Since Replica_IO aims at making a breakthrough in designing and implementing
    distributed protocols, I decided to start exploring the state of the art by selecting
    and looking into a number of notable distributed protocol implementations. Although
    I already had experience implementing such protocols myself, nevertheless, I decided
    to dive in and see for myself how others had approached this challenge. I wanted
    to learn from those projects, better understand the typical requirements and difficulties
    coming up in real-world use cases, and, perhaps, discover some interesting techniques
    or ideas along the way, as well as to identify the key areas of focus for the
    next steps.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Replica_IO 的目标是在设计和实现分布式协议方面取得突破，我决定开始探索现有技术，选择并深入研究一些显著的分布式协议实现。尽管我已经有过实现这类协议的经验，但我还是决定深入了解其他人是如何应对这一挑战的。我想从这些项目中学习，更好地理解在实际使用中出现的典型需求和困难，并且也许能够在探索过程中发现一些有趣的技术或思路，以及确定下一步关注的关键领域。
- en: So I onboarded myself into one code base after the other, as if I were to work
    on it. I was focused on the general structure of code, node-to-node communication
    mechanisms, the implementation details of the core protocols ensuring consistency
    between nodes, as well as mechanisms for monitoring and controlling execution
    of the protocol. I tried my best to understand *how* those protocols are structured
    and implemented. After having explored each of the code bases, I summarized and
    shared some of my findings. You can find those overviews on [this wiki page](https://github.com/replica-io/replica-io/wiki/State-of-the-art-exploration).
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我像要开始工作一样，一次又一次地深入了解每个代码库。我专注于代码的总体结构，节点间通信机制，核心协议实现细节，确保节点之间一致性的机制，以及监控和控制协议执行的机制。我尽力理解这些协议的结构和实现方式。在探索完每个代码库之后，我总结并分享了一些发现。你可以在[这个维基页面](https://github.com/replica-io/replica-io/wiki/State-of-the-art-exploration)找到这些概述。
- en: 'Here is the full list of the code bases, written in different programming languages,
    that I explored^([1](#user-content-fn-other-impl-d8d72b)):'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我探索过的用不同编程语言编写的代码库完整清单^[1](#user-content-fn-other-impl-d8d72b)：
- en: '[Tendermint Core](https://github.com/tendermint/tendermint) / [CometBFT](https://github.com/cometbft/cometbft)
    — a state machine replication engine (written in Go);'
  id: totrans-split-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Tendermint Core](https://github.com/tendermint/tendermint) / [CometBFT](https://github.com/cometbft/cometbft)
    — 状态机复制引擎（使用Go编写）；'
- en: '[etcd Raft](https://github.com/etcd-io/raft) — a library for maintaining replicated
    state machines (written in Go);'
  id: totrans-split-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[etcd Raft](https://github.com/etcd-io/raft) — 用于维护复制状态机的库（使用Go编写）；'
- en: '[AptosBFT](https://github.com/aptos-labs/aptos-core/tree/aptos-cli-v1.0.13/consensus)
    — a consensus component supporting state machine replication in the Aptos blockchain
    (written in Rust);'
  id: totrans-split-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[AptosBFT](https://github.com/aptos-labs/aptos-core/tree/aptos-cli-v1.0.13/consensus)
    — 支持在Aptos区块链中进行状态机复制的共识组件（使用Rust编写）；'
- en: '[BFT-SMaRt](https://github.com/bft-smart/library) — a library implementing
    BFT-SMaRt, a state machine replication system (written in Java);'
  id: totrans-split-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[BFT-SMaRt](https://github.com/bft-smart/library) — 实现BFT-SMaRt的库，一个状态机复制系统（使用Java编写）；'
- en: '[SmartBFT-Go](https://github.com/SmartBFT-Go/consensus) — a library implementing
    state machine replication inspired by BFT-SMaRt (written in Go);'
  id: totrans-split-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[SmartBFT-Go](https://github.com/SmartBFT-Go/consensus) — 实现受BFT-SMaRt启发的状态机复制的库（使用Go编写）；'
- en: '[Substrate](https://github.com/paritytech/substrate) — a framework for building
    application-specific blockchains (written in Rust);'
  id: totrans-split-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Substrate](https://github.com/paritytech/substrate) — 用于构建特定应用区块链的框架（使用Rust编写）；'
- en: '[Lighthouse](https://github.com/sigp/lighthouse) — an Ethereum consensus client
    (written in Rust);'
  id: totrans-split-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Lighthouse](https://github.com/sigp/lighthouse) — 以太坊共识客户端（使用Rust编写）；'
- en: '[Algorand](https://github.com/algorand/go-algorand) — a blockchain based on
    the Algorand consensus protocol (written in Go);'
  id: totrans-split-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Algorand](https://github.com/algorand/go-algorand) — 基于Algorand共识协议的区块链（使用Go编写）；'
- en: '[Avalanche](https://github.com/ava-labs/avalanchego) — a blockchain platform
    based on the Avalanche consensus protocol (written in Go);'
  id: totrans-split-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Avalanche](https://github.com/ava-labs/avalanchego) — 基于Avalanche共识协议的区块链平台（使用Go编写）；'
- en: '[Internet Computer blockchain](https://github.com/dfinity/ic) (ICP) — a general-purpose
    blockchain system developed by the DFINITY Foundation (written in Rust);'
  id: totrans-split-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Internet Computer blockchain](https://github.com/dfinity/ic)（ICP） — 由DFINITY
    Foundation开发的通用区块链系统（使用Rust编写）；'
- en: '[Sui](https://github.com/MystenLabs/sui) — a smart contract platform based
    on Narwhal and Bullshark protocols (written in Rust);'
  id: totrans-split-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Sui](https://github.com/MystenLabs/sui) — 基于Narwhal和Bullshark协议的智能合约平台（使用Rust编写）；'
- en: '[Apache ZooKeeper](https://github.com/apache/zookeeper) — a distributed coordination,
    synchronization, and configuration service (written in Java);'
  id: totrans-split-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Apache ZooKeeper](https://github.com/apache/zookeeper) — 分布式协调、同步和配置服务（使用Java编写）；'
- en: '[Apache Kafka](https://github.com/apache/kafka) — a distributed event streaming
    platform implementing a variant of the Raft consensus protocol (written in Java,
    integrated with Scala);'
  id: totrans-split-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Apache Kafka](https://github.com/apache/kafka) — 实现Raft共识协议变体的分布式事件流平台（使用Java编写，与Scala集成）；'
- en: '[Cardano](https://github.com/input-output-hk/cardano-node) — a blockchain platform
    based on the Ouroboros family of consensus protocols (written in Haskell).'
  id: totrans-split-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Cardano](https://github.com/input-output-hk/cardano-node) — 基于Ouroboros系列共识协议的区块链平台（使用Haskell编写）；'
- en: 'In the subsequent sections, I will share with you some of the observations
    and conclusions I made while exploring those code bases. I decided to structure
    the discussion around the following aspects of implementing distributed protocols:'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我将分享在探索这些代码库时所做的一些观察和结论。我决定围绕以下实现分布式协议的几个方面进行讨论：
- en: '*complexity*: what makes distributed protocols hard to reason about and implement;'
  id: totrans-split-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复杂性*：是什么使得分布式协议难以理解和实现；'
- en: '*correctness*: how to ensure that the implementation guarantees the requires
    properties;'
  id: totrans-split-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正确性*：如何确保实现保证所需属性；'
- en: '*resource utilization*: how to prevent ineffective expenditure of limited computing
    resources;'
  id: totrans-split-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源利用*：如何防止对有限计算资源的无效消耗；'
- en: '*maintainability*: how to manage long-running distributed systems and diagnose
    issues;'
  id: totrans-split-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性*：如何管理长期运行的分布式系统并诊断问题；'
- en: '*flexibility*: how to achieve high adaptability, reusability, and evolvability
    of code.'
  id: totrans-split-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*灵活性*：如何实现代码的高适应性、可重用性和可演进性；'
- en: Complexity[​](#complexity "Direct link to Complexity")
  id: totrans-split-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Complexity[​](#complexity "复杂性的直接链接")
- en: Distributed, fault-tolerant protocols are notoriously hard to implement, and
    there are justifiable reasons for that. This is primarily because that kind of
    system consists of largely independent nodes communicating through potentially
    unstable, unreliable network; some of the nodes may fail in different ways. The
    protocol is required to tolerate, within a bound, such unfavorable conditions
    and keep working reliably. More than that, it is supposed to deliver decent performance
    using limited resources. All this adds a great deal of *inherent, essential complexity*,
    which we simply cannot remove without weakening our requirements.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式、容错的协议实施起来非常困难，这是众所周知的，而且这其中有充分的理由。这主要是因为这种系统由大部分独立节点组成，通过潜在不稳定、不可靠的网络进行通信；其中一些节点可能以不同的方式失败。协议需要在限定范围内容忍这些不利条件并保持可靠运行。此外，它还应该使用有限资源提供良好的性能。所有这些增加了相当数量的*固有、本质上的复杂性*，如果不满足这些要求就不能简单地移除。
- en: 'However, when it comes to actually designing and implementing these protocols,
    there is also another kind of complexity: *incidental, non-essential complexity*.
    This kind of complexity, though being closely related, does not strictly belong
    to the problem. We incidentally introduce it because we are not aware of or fail
    to recognize a simpler way of solving the problem at hand.'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当实际设计和实施这些协议时，还存在另一种复杂性：*偶发的、非必要的复杂性*。尽管这种复杂性与问题密切相关，但严格来说并不属于问题本身。我们之所以偶然引入它，是因为我们并没有意识到或者没有意识到有更简单的解决问题的方法。
- en: Incidental complexity can start creeping in when trying to understand and interpret
    a protocol specification^([2](#user-content-fn-thinking-complexity-d8d72b)), which
    is often too far from the realities of software engineering. Simply the way a
    protocol is specified can misguide the engineer trying to implement it and induce
    all sorts of difficulties. For example, pseudo-code in scientific papers is often
    defined in terms of global, unstructured variables and omits concurrency issues.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试理解和解释协议规范^([2](#user-content-fn-thinking-complexity-d8d72b))时，偶发复杂性可能开始悄悄蔓延，这些规范通常与软件工程的现实相距甚远。例如，科学论文中的伪代码通常以全局、非结构化变量定义，并且忽略并发问题。
- en: Implementing a distributed protocol in one of the conventional programming languages,
    chances are that the implementation will simply employ some general techniques
    commonly used in that language's ecosystem. Such general techniques may be very
    powerful and universal, but freely using this unconstrained power and flexibility,
    we can easily end up with a code base that is very hard to understand and maintain.
    For example, dealing with concurrency and synchronization using low-level primitives
    in the implementation of high-level protocol logic clutters the code and multiplies
    the complexity.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统编程语言中实现分布式协议时，实现通常会简单地采用该语言生态系统中常用的一些通用技术。这些通用技术可能非常强大和普遍，但是在使用这种不受限制的强大和灵活性时，我们很容易得到一个非常难以理解和维护的代码库。例如，使用低级原语在高级协议逻辑的实现中处理并发和同步会使代码混乱并增加复杂性。
- en: Haste is another great source of incidental complexity. There is always temptation
    to cut corners, especially when under time pressure. Imprudently copying approaches
    from elsewhere, adding temporary workarounds and ad hoc patches makes code entangled
    and poorly structured.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 急躁是偶发复杂性的另一个重要来源。总是在时间紧迫时刻切勿心急，容易忍不住走捷径。从其他地方不谨慎地复制方法，添加临时解决方案和临时补丁会使代码变得混乱和结构不佳。
- en: Using advanced features and sophisticated techniques can also add unnecessary
    complexity. Though this is ambivalent because it can actually help to express
    the implementation more conveniently and simplify the reasoning about it, but
    only when the advanced machinery is hidden behind a simple, clear, and easy to
    use interface.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高级功能和复杂技术也可能增加不必要的复杂性。尽管这是一把双刃剑，因为它实际上可以帮助更方便地表达实现，并简化对其的推理，但只有当这些高级机制隐藏在简单、清晰和易于使用的界面后才能做到这一点。
- en: It is pretty clear that introducing additional complexity is generally bad.
    But does it really matter? Couldn't we just implement the thing somehow, test
    it well, and simply tolerate the additional complexity? Well, surely, with rigorous
    testing, we can be sufficiently confident that our implementation is correct.
    However, in that case, making a small change, e.g. applying a simple fix to address
    a major issue discovered later can reportedly^([3](#user-content-fn-tendermint-liveness-fix-d8d72b))
    take months of work. So it would be very hard to further improve, adapt, or reuse
    such implementation.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，引入额外的复杂性通常是不好的。但这真的重要吗？我们不是可以只是实现这个东西，好好测试它，并简单地容忍额外的复杂性吗？当然，通过严格的测试，我们可以足够自信地认为我们的实现是正确的。然而，在这种情况下，做一个小改动，例如应用一个简单的修复来解决后来发现的一个重大问题，据报道^([3](#user-content-fn-tendermint-liveness-fix-d8d72b))可能需要数月的工作。因此，进一步改进、调整或重用这样的实现将会非常困难。
- en: We need a structured, yet flexible enough, approach guiding us away from incidental
    complexity if we wish to avoid wasted efforts and foster innovation in the field.
    Let's look into more details concerning complexity in implementation of distributed
    protocols.
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望避免浪费并在该领域促进创新，我们需要一种结构化但足够灵活的方法来引导我们远离偶然复杂性。让我们深入探讨分布式协议实施中的复杂性问题。
- en: Modularity[​](#modularity "Direct link to Modularity")
  id: totrans-split-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[模块化](#modularity "模块化的直接链接")'
- en: We can deal with a complex problem, such as implementing a distributed protocol,
    by dividing it into smaller, simpler problems, solving them individually, and
    then combining the solutions to finally address the original problem. This is,
    basically, what modularity is about. In this process, it is crucial how we divide
    the problem, what kind of pieces we get, and how we combine them back together.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将复杂问题，例如实施分布式协议，分解为较小、更简单的问题来处理，分别解决它们，然后将解决方案结合起来，最终解决原始问题。基本上，这就是模块化的意义所在。在这个过程中，如何划分问题，我们得到什么样的片段，以及如何将它们重新组合在一起，都是至关重要的。
- en: Granularity[​](#granularity "Direct link to Granularity")
  id: totrans-split-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[粒度](#granularity "粒度的直接链接")'
- en: First of all, modularity comes in different levels of *granularity*. Implementing
    a large component, such as a state machine replication engine, we can define its
    external dependencies, then split the component into several chunks of functionality
    and stop there. That is certainly better than having to deal with a complete monolith,
    but this level of modularity would still be too *coarse*. Instead, we can continue
    decomposing the sub-components further until we end up with reasonably small and
    simple, yet non-trivial, components; this is *fine* modularity.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，模块化具有不同层次的*粒度*。实现一个大组件，比如状态机复制引擎，我们可以定义其外部依赖，然后将组件拆分为几个功能块，就到此为止。这当然比处理完整的单体要好，但这种模块化程度仍然太*粗糙*。相反，我们可以继续进一步分解子组件，直到得到相当小而简单，但又不简单的组件；这就是*细粒度*的模块化。
- en: All of the explored code bases exhibit some level of modularity. It is quite
    common to separate concerns by delegating pieces of functionality to external
    components. This way, most of the code bases clearly separate implementation of
    the protocol logic from such functionality as communication between nodes, producing
    and verifying cryptographic signatures, persistent storage, executing transactions
    on the replicated state, etc. Most of the implementations also separate dispatching
    of events, such as inbound messages, from their handling; there is typically a
    component responsible for classifying events and a number of components responsible
    for handling specific event types. Quite often there are separate components implementing
    the protocol logic specific to different roles that a node can play, e.g. leader
    and follower, or modes of operation, e.g. synchronization and normal operation.
    It is also common to separate different logical stages of the protocol, e.g. creating
    a proposal, validating a proposal, finalizing the decision. Another common pattern
    is to have a separate class of component responsible for maintaining state for
    each of the remote peers the node communicates with.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有探索过的代码库都展示了一定程度的模块化。通过将功能的不同部分委托给外部组件，将关注点分离是非常普遍的做法。这样，大多数代码库明确地将协议逻辑的实现与诸如节点间通信、生成和验证加密签名、持久存储、在复制状态上执行事务等功能分离开来。大多数实现还将事件的分派（例如入站消息）与其处理分开；通常会有一个负责分类事件的组件和多个负责处理特定事件类型的组件。很多情况下，还会有独立的组件实现特定于节点不同角色（如领导者和追随者）或操作模式（如同步和正常操作）的协议逻辑。将协议的不同逻辑阶段（例如创建提案、验证提案、最终决策）分离也是一种常见模式。另一个常见模式是有一个独立的组件类负责维护与节点通信的每个远程对等方的状态。
- en: Some implementations go further and introduce smaller components, e.g. encapsulating
    the state of each individual proposal or representing the logic of counting votes
    and determining if there is a sufficient quorum. Nevertheless, there still remain
    components that are too complicated and hard to follow, so this modularity cannot
    be considered fine. To combat complexity, we need to learn how to achieve fine
    modularity.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有些实现更进一步，引入更小的组件，例如封装每个个体提案的状态或代表计票逻辑并确定是否有足够的法定人数。尽管如此，仍然存在一些过于复杂和难以理解的组件，因此这种模块化无法被视为良好的。为了应对复杂性，我们需要学习如何实现良好的模块化。
- en: Decomposition[​](#decomposition "Direct link to Decomposition")
  id: totrans-split-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[分解](#decomposition "分解的直接链接")'
- en: As one can cut bricks at different angles, so one can decompose components into
    sub-components in different ways. One way is to focus on the *operational* aspects,
    i.e. on how the pieces of implementation are going to be executed. With this approach,
    components would be primarily organized around actual data and control flow. This
    has a profound effect on the structure of the implementation.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像可以以不同角度切割砖块一样，也可以以不同方式将组件分解为子组件。一种方式是专注于*操作*方面，即实现的各部分如何执行。采用这种方法，组件主要围绕实际数据和控制流进行组织。这对实现结构有深远影响。
- en: Focusing on the operational aspects, protocol implementations will tend to be
    represented as stateful components, or as collections of stateful components,
    reacting to external events. This naturally induces applying the object-oriented
    approach to structuring the whole implementation, in which the protocol logic
    is mostly expressed as modifying pieces of component's state in response to *individual*
    inbound events and optionally producing new outbound events.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关注操作方面，协议实现往往以有状态组件或有状态组件集合的形式表示，以对外部事件做出反应。这自然地促使采用面向对象的方法来构造整个实现，在这种方法中，协议逻辑大多表现为根据个别入站事件修改组件状态并可选地生成新的出站事件。
- en: Although pieces of functionality tend to imply some state, individual events
    in a distributed system mostly happen as logical consequences of some other, causally
    related events in the scope of a larger *distributed* process. Thus structuring
    the implementation around event handling might *not* help to clearly express the
    overall protocol logic.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管功能片段倾向于暗示某种状态，分布式系统中的个别事件大多作为更大*分布*过程范围内一些其他因果相关事件的逻辑结果发生。因此，围绕事件处理构建实现可能*不*有助于清晰表达整体协议逻辑。
- en: The way we approach decomposition also greatly impacts such properties of code
    as [*coupling*](https://en.wikipedia.org/wiki/Coupling_(computer_programming))
    and [*cohesion*](https://en.wikipedia.org/wiki/Cohesion_(computer_science)), i.e.
    the degree of interdependence between different components and the strength of
    relationship between the elements inside components, respectively. Loose coupling
    and high cohesion are generally desirable.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理分解的方式也极大地影响代码的诸如[*耦合*](https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E8%81%AF%E7%B5%90)和[*内聚性*](https://zh.wikipedia.org/wiki/%E5%85%A7%E8%81%9A%E6%80%A7)等属性，即不同组件之间的相互依赖程度以及组件内元素之间关系的强度，分离耦合和高内聚通常是可取的。
- en: Failing to recognize the significance of implicit logical connections and properly
    express them often causes higher degree of coupling between components, i.e. entanglement.
    It is particularly important to distinguish essential and incidental complexity
    here. Sometimes complications, such as *circular dependencies*, may occur naturally
    and represent essential features of the protocol logic, e.g. *recursiveness*.
    For example, some internal events should often be treated, for the most part,
    the same way as equivalent external events. This can be achieved by looping those
    events back for handling in the protocol implementation.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 未能认识到隐含的逻辑连接的重要性并正确表达它们，通常会导致组件之间更高的耦合度，即交织。在此处特别重要的是区分本质和偶然复杂性。有时，复杂性（如*循环依赖*）可能自然而然地发生，并代表协议逻辑的基本特征，例如*递归性*。例如，一些内部事件通常应该与等效的外部事件基本相同处理。这可以通过将这些事件循环回传给协议实现中的处理来实现。
- en: Organizing components in a more structured way helps to manage dependencies
    between them, e.g. they can be arranged in *layers* or *hierarchically*, chained
    together in *pipelines*, etc. For example, in the Algorand implementation, the
    core logic of the consensus protocol is structured as a hierarchical state machine.
    The layered approach is well exemplified in the [`tower`](https://docs.rs/tower/0.4.12/tower/) networking
    library, which is used by the Sui implementation. In the Apache ZooKeeper implementation,
    client requests are processed using a pipeline of request processing components
    chained together.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以更结构化的方式组织组件有助于管理它们之间的依赖关系，例如，它们可以按*层次*或*层级*排列，以*管道*形式链接在一起等。例如，在Algorand实现中，共识协议的核心逻辑被构建为一个分层状态机。分层方法在[`tower`](https://docs.rs/tower/0.4.12/tower/) 网络库中得到了很好的体现，该库被Sui实现使用。在Apache
    ZooKeeper实现中，客户端请求通过链式处理的一系列请求处理组件进行处理。
- en: The amount of mutable internal state maintained by components also matters.
    Making components more static can often help to simplify the implementation. For
    example, in the Sui implementation, most of the consensus-specific components
    are static in terms of consensus configuration, i.e. instead of supporting reconfiguration
    directly in those components, they are simply recreated upon reconfiguration.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 组件维护的可变内部状态量也很重要。使组件更加静态通常有助于简化实现。例如，在Sui实现中，大多数特定于共识的组件在共识配置方面是静态的，即在这些组件中不直接支持重新配置，而是在重新配置时简单地重新创建它们。
- en: Many components require certain *context* or *environment*, i.e. they depend
    on some common piece of state or functionality like information about prior communication
    with the remote peer, access to persistent storage, diagnostic logging, etc. This
    is usually accomplished by capturing references to the environment inside the
    component or passing it explicitly. In functional programming, one can represent
    the environment with a [monadic](https://en.wikipedia.org/wiki/Monad_(functional_programming))
    interface. Some programming languages provide special features for that purpose,
    e.g. [contextual parameters in Scala](https://docs.scala-lang.org/tour/implicit-parameters.html).
    Interacting with the context from withing a component should be convenient but
    clearly constrained by the component's interface.
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组件需要特定的*上下文*或*环境*，即它们依赖于一些共同的状态或功能，如与远程对等方的先前通信信息，对持久存储的访问，诊断日志记录等。通常通过在组件内捕获环境的引用或显式传递来实现这一点。在函数式编程中，可以使用[单子](https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B))接口表示环境。某些编程语言为此目的提供了特殊的功能，例如[Scala中的上下文参数](https://docs.scala-lang.org/tour/implicit-parameters.html)。从组件内部与上下文交互应该是方便的，但受到组件接口明确约束。
- en: We would like to possibly avoid *fragmentation* of the core logic and facilitate
    *local reasoning* so that it is easier to reason about correctness, especially
    when introducing changes, without being too much concerned about larger scopes.
    We need to shift the focus more onto the *functional* and *logical* aspects, i.e.
    what the pieces of implementation achieve and how they ensure the desired outcome,
    so that the protocol implementation better reflects causal dependencies and logical
    connections.
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望可能避免核心逻辑的*碎片化*，并促进*局部推理*，以便更容易推理正确性，特别是在引入变更时，不过度关注较大范围。我们需要更多地将焦点转移到*功能*和*逻辑*方面，即实现的各个部分达到什么目标以及它们如何确保所需的结果，以便协议实现更好地反映因果依赖和逻辑连接。
- en: Composability[​](#composability "Direct link to Composability")
  id: totrans-split-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可组合性[​](#composability "直接链接到可组合性")
- en: 'Even a highly modular implementation is not necessarily highly [*composable*](https://en.wikipedia.org/wiki/Composability),
    i.e. allowing to easily recombine and reuse its components. It is hard to reuse
    components that are not composable. Moreover, composability has huge transformative
    potential: unlocking true power of expressiveness and flexibility, we can push
    the limits and uncover a new dimension of possibilities for finding better solutions,
    whether to fix a flaw in an existing implementation or to design and implement
    something completely new.'
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是高度模块化的实现也不一定是高度[*可组合*](https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7)，即允许轻松重新组合和重用其组件。不可组合的组件很难重用。此外，可组合性具有巨大的变革潜力：释放表达能力和灵活性的真正力量，我们可以推动极限，揭示出新的可能性维度，无论是修复现有实现中的缺陷还是设计和实现全新的解决方案。
- en: Composability primarily emerges from the properties of individual components
    and the way they can be combined together. It demands components that are not
    only loosely coupled, but *generic* as well. It also requires *unified* means
    of abstraction and combination that satisfy certain properties, such as [closure](https://en.wikipedia.org/wiki/Closure_(mathematics))
    and [associativity](https://en.wikipedia.org/wiki/Associative_property), while
    preserving principal properties of individual components in combination.
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合性主要来源于单个组件的属性以及它们可以如何组合在一起的方式。它要求组件不仅松耦合，而且还要*通用*。它还需要*统一*的抽象和组合方式，满足某些特性，如[闭包](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E6%95%B0%E5%AD%A6))和[结合律](https://zh.wikipedia.org/wiki/%E7%BB%93%E5%90%88%E5%BE%8B)，同时保持组合后的个体组件的主要属性。
- en: All of the explored code bases were meant to implement only a specific protocol
    or a close family of protocols, except Substrate, which is supposed to support
    a wide range of protocols. Most of the implementations define abstract interfaces
    for major components, employing various forms of [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)),
    and apply the [dependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle).
    This makes components replacable and can help to reduce coupling. Being able to
    replace a component allows using alternative implementations of the component,
    e.g. for unit testing. However, most of those dependency inversion interfaces
    seem to only make sense within a very specific, predefined structure of the whole
    implementation, i.e. they are mostly about decomposing rather than recomposing.
    Truly composable components, on the other hand, are those that can be put together
    in an open-ended range of new, surprising combinations.
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所有探索的代码库都旨在实现特定协议或紧密相关的协议家族，除了 Substrate，它旨在支持广泛的协议。大多数实现定义了主要组件的抽象接口，采用各种形式的[多态性](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%80%81%E6%80%A7_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))，并应用[依赖反转原则](https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99)。这使得组件可以被替换，有助于减少耦合。能够替换组件允许使用组件的替代实现，例如用于单元测试。然而，大多数依赖反转接口似乎只在整个实现的非常具体预定义结构内有意义，即它们主要是关于分解而非重组。另一方面，真正可组合的组件是那些可以以各种新的、令人惊讶的组合方式放在一起的组件。
- en: 'Though there are some examples of composability used in the explored code bases.
    The communication layer in the Sui implementation takes advantage of the layered
    design of  [`anemo`](https://github.com/MystenLabs/anemo), a peer-to-peer networking
    library based on [`tower`](https://docs.rs/tower/0.4.12/tower/): it processes
    RPC requests from other nodes through pipelines composed out of `tower` middleware
    layers provided by the `anemo` library. The state machine representing the core
    logic of the consensus protocol in the Algorand implementation consists of uniformly
    defined event handlers organized in a hierarchy of event routers dispatching events
    to the corresponding handler.'
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在所探索的代码库中有一些可组合性的例子。Sui 实现中的通信层利用了基于[`tower`](https://docs.rs/tower/0.4.12/tower/)的中间件层管道处理来自其他节点的RPC请求，这是建立在[`anemo`](https://github.com/MystenLabs/anemo)上的对等网络库；Algorand
    实现中代表共识协议核心逻辑的状态机由一组统一定义的事件处理程序组成，这些处理程序按层次组织在事件路由器中，用于分派事件到相应的处理程序。
- en: '[Asynchrony](https://en.wikipedia.org/wiki/Asynchrony_(computer_programming))
    and [concurrency](https://en.wikipedia.org/wiki/Concurrency_(computer_science))
    make achieving composability particularly challenging. Components implemented
    using usual concurrent programming techniques based on [lock-based](https://en.wikipedia.org/wiki/Lock_(computer_science))
    synchronization primitives fall short of composability: a simple combination of
    individually absolutely correct components may easily fail to ensure consistency
    or cause a deadlock. Ensuring correctness in this model often requires breaking
    abstractions and dealing with synchronization directly in an awkward and error-prone
    way. Alternative concurrent programming techniques, such as [software transactional
    memory](https://en.wikipedia.org/wiki/Software_transactional_memory) (STM) used
    in the Cardano implementation, can help to overcome these issues without compromising
    on modularity and composability. More on asynchrony and concurrency in the next
    section.'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[异步性](https://en.wikipedia.org/wiki/Asynchrony_(computer_programming))和[并发性](https://en.wikipedia.org/wiki/Concurrency_(computer_science))使得实现可组合性尤为具有挑战性。使用基于[锁](https://en.wikipedia.org/wiki/Lock_(computer_science))的常规并发编程技术实现的组件，缺乏可组合性：单独绝对正确的组件的简单组合可能很容易导致一致性问题或死锁。在这种模型中确保正确性通常需要打破抽象，并以一种尴尬和容易出错的方式直接处理同步。在
    Cardano 实现中使用的替代并发编程技术，如[软件事务内存](https://en.wikipedia.org/wiki/Software_transactional_memory)，可以帮助克服这些问题，而不会牺牲模块化和可组合性。更多关于异步性和并发性的内容将在下一节讨论。'
- en: Functional programming places a significant emphasis on composability. One of
    its core principles is to break down programs into smaller, reusable functions,
    avoiding side effects, that can be easily combined to create more complex functionality.
    This encourages a more *declarative notation*, which often results in code that
    is easier to reason about. The approaches and techniques employed in functional
    programming, such as [immutability](https://en.wikipedia.org/wiki/Immutable_object),
    [lazy evaluation](https://en.wikipedia.org/wiki/Lazy_evaluation), [monads](https://en.wikipedia.org/wiki/Monad_(functional_programming))
    and [effect systems](https://en.wikipedia.org/wiki/Effect_system), etc., are therefore
    a great source of ideas for enhancing composability.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程非常强调可组合性。其核心原则之一是将程序分解为更小、可重用的函数，避免副作用，并且这些函数可以轻松组合以创建更复杂的功能。这种方法鼓励更*声明性的表示*，通常导致更易于理解的代码。函数式编程中采用的方法和技术，如[不可变性](https://en.wikipedia.org/wiki/Immutable_object)、[惰性评估](https://en.wikipedia.org/wiki/Lazy_evaluation)、[单子](https://en.wikipedia.org/wiki/Monad_(functional_programming))和[效果系统](https://en.wikipedia.org/wiki/Effect_system)，等等，因此是增强可组合性的重要思路来源。
- en: Composability is indispensable for *future-proof* software solutions. Though
    this property doesn't necessarily emerge together with modularity; conversely,
    achieving it may be challenging, especially in the inherently concurrent context
    of distributed systems. Therefore, we should approach this proactively and deliberately
    design for composability.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合性对于*未来的软件解决方案*至关重要。虽然这种特性不一定与模块化同时出现；相反，实现它可能具有挑战性，特别是在分布系统的内在并发上下文中。因此，我们应该主动采取措施，并有意识地设计可组合性。
- en: Concurrency[​](#concurrency "Direct link to Concurrency")
  id: totrans-split-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发[​](#concurrency "到并发的直接链接")
- en: '[Concurrent programming](https://en.wikipedia.org/wiki/Concurrent_computing)
    is a way to structure code into multiple *threads of control*—concurrent tasks—that
    can execute concurrently. Observable effects caused by individual tasks can interleave
    in concurrent execution. Understanding and reasoning about code in concurrent
    programming requires a more complex mental model compared to sequential programming.
    Perhaps, *nondeterminism* is the main source of complexity in concurrent programming:
    concurrent programs can produce different results depending on the exact timing
    of external events and task execution.'
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[并发编程](https://zh.wikipedia.org/wiki/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97)是一种将代码结构化为多个*控制线程*——并发任务——可以并行执行的方式。由于各个任务在并发执行中产生的可观察效果可以交错，理解和推理并发编程中的代码需要比顺序编程更复杂的思维模型。或许，*非确定性*是并发编程中复杂性的主要来源：并发程序的结果可能根据外部事件的确切时机和任务执行不同而不同。'
- en: Concurrent programming is known to be error prone. Concurrent tasks accessing
    shared resources generally require some form of coordination. Depending on the
    available mechanisms for interaction and communication between concurrent tasks,
    there may be different methods of coordinating them and controlling concurrency,
    e.g. [lock-based synchronization primitives](https://en.wikipedia.org/wiki/Lock_(computer_science)),
    [message passing](https://en.wikipedia.org/wiki/Message_passing), and [software
    transactional memory](https://en.wikipedia.org/wiki/Software_transactional_memory).
    However, properly applying those methods in a nontrivial system often becomes
    complicated and requires great deal of care. When concurrent tasks happen to *interfere*
    with each other in unanticipated ways, subtle issues, such as [race conditions](https://en.wikipedia.org/wiki/Race_condition#In_software), [deadlocks](https://en.wikipedia.org/wiki/Deadlock),
    and [resource starvation](https://en.wikipedia.org/wiki/Starvation_(computer_science)),
    may start manifesting themselves.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
  zh: 已知并发编程容易出错。访问共享资源的并发任务通常需要某种形式的协调。根据可用的并发任务之间的交互和通信机制，可能存在不同的协调方法和控制并发的方式，例如[基于锁的同步原语](https://zh.wikipedia.org/wiki/%E9%94%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)),
    [消息传递](https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92), 和
    [软件事务内存](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E4%BA%8B%E5%8A%A1%E5%86%85%E5%AD%98)。然而，在非平凡系统中正确应用这些方法通常变得复杂，并需要极大的注意。当并发任务以意外方式*干扰*彼此时，可能会出现微妙的问题，如[竞争条件](https://zh.wikipedia.org/wiki/%E7%AB%9E%E8%B5%9B%E6%9D%A1%E4%BB%B6#%E8%BD%AF%E4%BB%B6%E4%B8%AD)、[死锁](https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81)和[资源饥饿](https://zh.wikipedia.org/wiki/%E9%A5%A5%E6%AD%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))可能开始显现。
- en: Concurrent programs with mutable memory shared between threads can suffer from
    [*data races*](https://en.wikipedia.org/wiki/Race_condition#Data_race). A data
    race is basically a situation where one thread accesses a memory location whereas
    another thread can simultaneously perform a conflicting write to that memory location.
    Preventing data races is not only important to avoid memory corruption; this can
    also significantly simplify the mental model.
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 并发程序中，多个线程共享可变内存时可能出现[*数据竞争*](https://zh.wikipedia.org/wiki/%E7%AB%9E%E8%B5%9B%E5%8F%8D%E4%BE%8B#%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B)问题。数据竞争基本上是指一个线程访问内存位置，而另一个线程同时进行冲突写入到该内存位置的情况。避免数据竞争不仅对防止内存损坏至关重要；它还可以显著简化思维模型。
- en: Normally, we can assume [sequential consistency](https://en.wikipedia.org/wiki/Sequential_consistency)
    in concurrent programs that are free of data races. In essence, a sequentially
    consistent execution of a concurrent program must be equivalent to *some* *sequential*
    execution, respecting the order and semantics of operations specified in the program.
    So such executions are linear schedules, each representing a possible concurrent
    interleaving of the program.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们可以假设在没有数据竞争的并发程序中存在[顺序一致性](https://zh.wikipedia.org/wiki/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7)。实质上，并发程序的顺序一致执行必须等同于某个*某些*顺序执行，遵守程序中指定操作的顺序和语义。因此，这些执行是线性调度，每个都代表程序的可能并发交错。
- en: Execution schedules that only differ in the interleaving of operations local
    to threads of execution, i.e. operations not visible to other threads or externally,
    are effectively equivalent. Therefore, the number of possible distinct schedules
    depends on the number of *non-local* operations in the execution, i.e. operations
    used to communicate between threads or cause externally visible effects, and it
    grows exponentially.
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在执行线程本地操作的交错不同的执行调度，即不对其他线程或外部可见的操作，实际上是等效的。因此，可能的不同调度数量取决于执行中的*非本地*操作数量，即用于线程间通信或引起外部可见效果的操作，并且呈指数增长。
- en: Concurrent programming is an effective model of computation, but it is more
    complex and requires an appropriate approach in order to avoid subtle concurrency
    issues. Data face freedom is a particularly desired property since it simplifies
    the model providing sequential consistency. Under that model, reducing the number
    of non-local operations can greatly help to further simplify reasoning about the
    concurrent program.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程是计算的一种有效模型，但它更复杂，需要适当的方法以避免微妙的并发问题。数据面自由是一个特别期望的属性，因为它简化了模型，提供了顺序一致性。在该模型下，减少非本地操作的数量可以极大地帮助进一步简化对并发程序的推理。
- en: Approaches to Concurrency[​](#approaches-to-concurrency "Direct link to Approaches
    to Concurrency")
  id: totrans-split-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 并发方法[​](#approaches-to-concurrency "并发方法直接链接")
- en: 'Programming languages support different approaches to concurrency; they provide
    different features and different concurrency mechanisms in their runtimes and
    ecosystems. The explored code bases are written in the following languages: Java,
    Go, Rust, and Haskell. Let''s have a look at how those code bases approach concurrency,
    depending on the choice of programming language.'
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言支持不同的并发方法；它们在运行时和生态系统中提供不同的特性和不同的并发机制。探索的代码库使用以下语言编写：Java、Go、Rust 和 Haskell。让我们看看这些代码库如何根据编程语言的选择处理并发。
- en: The code bases written in traditional mainstream languages like Java tend to
    achieve concurrency by explicitly spawning [*OS threads*](https://en.wikipedia.org/wiki/Thread_(computing)#Kernel_threads),
    which communicate through *shared mutable memory* and synchronize with [*lock-based
    primitives*](https://en.wikipedia.org/wiki/Lock_(computer_science)). Those implementations
    are normally structured into objects exposing thread-safe methods to interact
    with them concurrently. This approach is well known and established in the industry;
    it is therefore *widely supported* in the ecosystems built around those languages.
    Newer system programming languages like Rust usually provide support for this
    approach, as well.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Java 这样的传统主流语言编写的代码库通常通过显式生成[*操作系统线程*](https://en.wikipedia.org/wiki/Thread_(computing)#Kernel_threads)，它们通过*共享可变内存*进行通信，并使用[*基于锁的原语*](https://en.wikipedia.org/wiki/Lock_(computer_science))进行同步。这些实现通常结构化为公开线程安全方法以并发地与它们进行交互的对象。这种方法在行业中是众所周知和建立的，因此在围绕这些语言构建的生态系统中*得到广泛支持*。像
    Rust 这样的新型系统编程语言通常也支持这种方法。
- en: This low-level approach gives the programmer a *high level of control* as it
    directly reflects how concurrency is actually achieved by the system. On the other
    hand, it requires a lot of care since properly using low-level synchronization
    primitives together is tricky and *error prone*. Moreover, OS threads are relatively
    *expensive*, and, therefore, building highly concurrent programs by frequently
    spawning short-living threads on demand is impractical. Instead, programs are
    often organized into a small number of long-running threads; though using thread
    pools can help to achieve more flexibility. Most importantly, as mentioned before,
    concurrent components synchronized with the lock-based primitives suffer from
    *poor composability*.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种低级方法为程序员提供了*高度的控制*，因为它直接反映了系统实际实现并发的方式。另一方面，它需要非常小心，因为正确使用低级同步原语是棘手且*容易出错*的。此外，操作系统线程相对*昂贵*，因此通过频繁地按需生成短生命周期线程来构建高并发程序是不切实际的。相反，程序通常组织成少量长时间运行的线程；尽管使用线程池可以帮助实现更大的灵活性。最重要的是，如前所述，使用基于锁的原语同步的并发组件遭受*组合能力差*的问题。
- en: The Go language has built-in support for concurrency based on [preemptive multitasking](https://en.wikipedia.org/wiki/Computer_multitasking#Preemptive_multitasking)
    with lightweight [user threads](https://en.wikipedia.org/wiki/Thread_(computing)#User_threads)
    called *goroutines*. It encourages *message-passing* style of communication and
    synchronization between goroutines through blocking, optionally buffered FIFO
    *channels*; though it also supports traditional lock-based synchronization. The
    built-in [`select` statement](https://go.dev/ref/spec#Select_statements) can be
    used to combine several channel operations in order to perform a single pseudo-randomly
    selected operation that is ready to proceed; unless there is a default case, the
    `select` statement blocks until at least one of the operations can proceed.
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言内置支持基于[抢占式多任务处理](https://en.wikipedia.org/wiki/Computer_multitasking#Preemptive_multitasking)，采用轻量级的[用户线程](https://en.wikipedia.org/wiki/Thread_(computing)#User_threads)，称为*goroutines*。它鼓励*消息传递*式的通信和goroutines之间通过阻塞的、可选缓冲的FIFO
    *通道*进行同步；尽管它也支持传统的基于锁的同步。内置的[`select`语句](https://go.dev/ref/spec#Select_statements)可用于组合多个通道操作，以执行一个准备好进行的单个伪随机选择操作；除非有默认情况，否则`select`语句将阻塞，直到至少有一个操作可以继续。
- en: The `select` statement in Go allows *composing* multiple potentially blocking
    operations on channels into a single operation. For that reason, some of the explored
    code bases, e.g. SmartBFT-Go, occasionally use Go channels in place of traditional
    lock-based synchronization primitives in order to combine them with channel operations
    in a single `select` statement.
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的`select`语句允许将多个可能阻塞的通道操作组合为单个操作。因此，一些探索过的代码库，例如SmartBFT-Go，偶尔使用Go通道来替代传统的基于锁的同步原语，以便将它们与通道操作结合在单个`select`语句中执行。
- en: Go does not restrict access to *shared mutable data* by concurrent goroutines,
    so *data races* are still possible. Go provides quite *limited control* over the
    runtime managing execution of goroutines, thus making fine-tuning and controlling
    concurrent execution difficult.
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
  zh: Go不限制并发goroutines对*共享可变数据*的访问，因此仍然可能存在*数据竞争*。Go提供了对运行时管理goroutines执行的相当*有限控制*，从而使得对并发执行进行精细调整和控制变得困难。
- en: The Rust language emphasizes safety without sacrificing performance. Thanks
    to the [ownership model](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)
    and strong type system, it can effectively ensure at compile time that the code
    is *free of data races*. Being a system programming language, Rust supports concurrent
    programming with OS threads and shared memory, which are useful to optimize performance
    and for implementing other styles of concurrency, such as message passing. Rust's
    ownership and type system features prevent accidental sharing of mutable state
    between threads.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: Rust语言强调安全性而不牺牲性能。依靠[所有权模型](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)和强类型系统，它可以在编译时有效地确保代码*无数据竞争*。作为系统编程语言，Rust支持使用OS线程和共享内存进行并发编程，这对于优化性能和实现其他消息传递等并发风格非常有用。Rust的所有权和类型系统特性可以防止在线程之间意外共享可变状态。
- en: The explored code bases written in Rust primarily rely on the [asynchronous](https://en.wikipedia.org/wiki/Asynchrony_(computer_programming))
    programming features of Rust to achieve concurrency. Async Rust can be seen as
    a form of [cooperative multitasking](https://en.wikipedia.org/wiki/Cooperative_multitasking)
    where asynchronous, non-blocking computations are represented with the [`Future`](https://docs.rs/futures/latest/futures/future/trait.Future.html)
    trait (interface). Rust futures are *passive*, i.e. they have to be actively driven
    by *polling* in order to make progress.
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Rust编写的探索代码库主要依赖Rust的[异步](https://en.wikipedia.org/wiki/Asynchrony_(computer_programming))编程特性来实现并发。异步Rust可以看作是一种[合作式多任务处理](https://en.wikipedia.org/wiki/Cooperative_multitasking)，其中异步的、非阻塞的计算通过[`Future`](https://docs.rs/futures/latest/futures/future/trait.Future.html)
    trait（接口）表示。Rust的futures是*被动的*，即它们必须通过*轮询*主动驱动才能取得进展。
- en: Ultimately, asynchronous code in Rust requires some *executor* function that
    can drive a future by polling it to completion. There is an open-ended *choice
    of async runtimes* in the Rust ecosystem, which provide executors. [Tokio](https://tokio.rs/)
    is one of the most widely used runtimes in the Rust ecosystem; all of the explored
    code bases written in Rust are based on it. One can create *specialized runtimes*,
    e.g. Sui has a simulator that provides an drop-in replacement for Tokio and supports
    deterministic, randomized execution.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在 Rust 中，异步代码需要某种*执行器*函数来驱动一个 future，通过轮询将其推进到完成状态。Rust 生态系统中有各种开放选择的*异步运行时*，它们提供了执行器。[Tokio](https://tokio.rs/)
    是 Rust 生态系统中使用最广泛的运行时之一；所有使用 Rust 编写的探索代码库都基于它。可以创建*专门的运行时*，例如 Sui 拥有一个模拟器，提供了
    Tokio 的一个可替换方案，并支持确定性和随机执行。
- en: The [async/await syntax](https://en.wikipedia.org/wiki/Async/await) in Rust
    helps writing asynchronous fragments of code very close to normal, synchronous
    code. The `async` keyword introduces an *async context* by constructing a future
    from the corresponding piece of code; the `await` expression can be used within
    an async context to poll another future and yield control if that future is not
    yet ready to produce a value.
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[async/await 语法](https://en.wikipedia.org/wiki/Async/await) 在 Rust 中帮助编写非常接近正常同步代码的异步代码片段。`async`
    关键字通过从相应的代码片段构造一个 future 来引入*异步上下文*；`await` 表达式可在异步上下文中使用，以轮询另一个 future，并在该 future
    尚未准备好生成值时让出控制。'
- en: Apart from using the async/await syntax, Rust futures can be *composed* together
    using various combinators provided by the [`futures`](https://docs.rs/futures/latest/futures/),
    [`tokio`](https://docs.rs/tokio/latest/tokio/), and other crates. In particular,
    the `select` macro allows polling multiple futures simultaneously until one of
    them completes, similar to the `select` statement in Go; the `join` macro polls
    multiple futures to completion. There are also asynchronous channels for asynchronously
    producing a sequence of values and streams for communication between asynchronous
    tasks.
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 async/await 语法外，Rust futures 可以使用由 [`futures`](https://docs.rs/futures/latest/futures/)、[`tokio`](https://docs.rs/tokio/latest/tokio/)
    和其他 crate 提供的各种组合器*组合*在一起。特别是 `select` 宏允许同时轮询多个 futures，直到其中一个完成，类似于 Go 中的 `select`
    语句；`join` 宏则将多个 futures 轮询到完成。还有异步通道用于异步生成一系列值和流用于异步任务之间的通信。
- en: Asynchronous Rust is evolving rapidly; thus, it may still lack maturity, has
    limited documentation and less-established best practices. Many developers find
    programming in asynchronous Rust quite challenging and sometimes counter-intuitive,
    e.g. when dealing with cancellation, long-running or blocking operations, and
    due to the passive nature of futures. Although Rust prevents some concurrency
    problems like data races, concurrent code is still vulnerable to different types
    of concurrency bugs (e.g., deadlocks, logic errors, etc.) and requires deep understanding
    and careful design.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
  zh: 异步 Rust 正在快速发展；因此，它可能仍然缺乏成熟性，文档有限，并且最佳实践不够成熟。许多开发人员发现在异步 Rust 中编程非常具有挑战性，有时甚至不符合直觉，例如处理取消、长时间运行或阻塞操作以及由于
    futures 的被动特性。尽管 Rust 防止了一些并发问题，如数据竞争，但并发代码仍然容易受到不同类型的并发 bug（如死锁、逻辑错误等）的影响，需要深入理解和谨慎设计。
- en: Finally, concurrency in Haskell is based on lightweight [user threads](https://en.wikipedia.org/wiki/Thread_(computing)#User_threads).
    Haskell allows throwing asynchronous exceptions from one thread to another. Handling
    asynchronous exceptions safely requires great care in [critical sections](https://en.wikipedia.org/wiki/Critical_section),
    i.e. when manipulating shared resources. Since Haskell is a [purely functional](https://en.wikipedia.org/wiki/Purely_functional_programming)
    programming language, it does not explicitly support shared mutable memory for
    communication between threads. One of the mechanisms for normal communication
    between Haskell threads is [`MVar`](https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Concurrent-MVar.html),
    a synchronizing variable, which can act as a synchronized container for shared
    state or as a one-place channel. Concurrent Haskell *prevents data races*, but
    using `MVar`s is susceptible to other concurrency bugs, such as race conditions,
    deadlocks, etc.
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Haskell 中的并发基于轻量级[用户线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA)#用户线程)。Haskell
    允许从一个线程向另一个线程抛出异步异常。在[关键段](https://zh.wikipedia.org/wiki/%E4%B8%B4%E6%9A%82%E5%8C%BA)（即操作共享资源时），安全地处理异步异常需要极大的谨慎。由于
    Haskell 是[纯函数](https://zh.wikipedia.org/wiki/%E7%BA%AF%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80)编程语言，它不显式支持用于线程间通信的共享可变内存。在
    Haskell 线程之间正常通信的机制之一是[`MVar`](https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Concurrent-MVar.html)，一种同步变量，它可以作为共享状态的同步容器或单通道。并发
    Haskell *防止数据竞争*，但使用 `MVar` 可能会导致其他并发错误，如竞态条件、死锁等。
- en: Another mechanism for concurrent communication widely used in the Haskell ecosystem
    is [Software Transactional Memory](https://en.wikipedia.org/wiki/Software_transactional_memory)
    (STM). STM is an [optimistic concurrency](https://en.wikipedia.org/wiki/Optimistic_concurrency_control)
    mechanism that allows transactions over shared mutable variables (transactional
    variables or [`TVar`](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Concurrent-STM-TVar.html)s)
    to be *safely composed* and [atomically executed](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Monad-STM.html#v:atomically),
    without exposing the implementation details. STM transactions can [block](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Monad-STM.html#v:retry) on
    an *arbitrary* condition; alternative STM transactions can be composed together
    using the [`orElse`](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Monad-STM.html#v:orElse) combinator.
    The Haskell type system ensure that STM transactions cannot have undesired side
    effects and thus are safe to roll back and retry.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个广泛应用于 Haskell 生态系统中的并发通信机制是[软件事务内存](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E4%BA%8B%E5%8A%A1%E5%86%85%E5%AD%98)（STM）。STM
    是一种[乐观并发](https://zh.wikipedia.org/wiki/%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)机制，允许对共享的可变变量（事务变量或[`TVar`](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Concurrent-STM-TVar.html)）进行*安全组合*和[原子执行](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Monad-STM.html#v:atomically)，而不暴露实现细节。STM
    事务可以根据*任意*条件进行[阻塞](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Monad-STM.html#v:retry)，也可以使用[`orElse`](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Monad-STM.html#v:orElse)组合器将多个STM事务组合在一起。Haskell
    类型系统确保 STM 事务不会产生不期望的副作用，因此可以安全地回滚和重试。
- en: Building various custom concurrency abstractions and combinators with STM is
    relatively easy and safe, thanks to *high composability*. For instance, in Cardano,
    concurrent components expose STM transactions for retrieving relevant pieces of
    their mutable current state; the components then interact by combining and atomically
    executing such STM queries from other components and atomically updating the corresponding
    pieces of their own mutable state.^([4](#user-content-fn-modular-concurrency-with-stm-d8d72b))
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 STM 构建各种自定义并发抽象和组合器相对较为简单和安全，得益于*高可组合性*。例如，在 Cardano 中，各并发组件通过暴露 STM 事务来检索其可变当前状态的相关部分；然后，这些组件通过组合和原子执行来自其他组件的
    STM 查询，并原子更新其自身可变状态的相应部分。^([4](#user-content-fn-modular-concurrency-with-stm-d8d72b))
- en: 'However, STM has some limitations and caveats. First of all, *composable* *multi-way*
    communication between threads cannot be expressed in STM. That is because STM
    transactions cannot produce a visible side effect while being blocked. This is
    closely related to another limitation: STM does not provide *fairness* for threads
    waiting in a blocked STM transaction. In contrast, `MVar`s guarantee fair scheduling
    of threads blocked on the same `MVar`. STM also incurs some overhead in terms
    of memory and performance costs, which depends on the size of transactions. Though
    sometimes it can actually help building more efficient mechanisms. Long-running
    STM transactions can suffer from starvation, i.e. being repeatedly rolled-back
    and retried. Finally, Haskell, similar to Go, provides quite limited control over
    its runtime.'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，STM也有一些限制和注意事项。首先，STM不能在被阻塞时产生可见的副作用，因此无法表达线程之间的可组合的多向通信。这与另一个限制密切相关：STM不为等待在阻塞STM事务中的线程提供公平性。相比之下，`MVar`保证了在相同`MVar`上阻塞的线程的公平调度。此外，STM在内存和性能成本方面存在一些开销，这取决于事务的大小。尽管有时它实际上可以帮助构建更有效的机制。长时间运行的STM事务可能会遭受饥饿问题，即反复回滚和重试。最后，像Haskell一样，类似于Go，对其运行时的控制相当有限。
- en: To summarize, the traditional mainstream approach to concurrency based on explicit,
    low-level synchronization primitives and communication directly through shared
    mutable memory is well known and established, but it is tricky, error prone, and
    suffers from poor composability. Restricting concurrent access to shared memory,
    e.g. with the ownership model as in Rust or immutability as in Haskell, can help
    preventing data races. Communication and synchronization through message passing
    primitives like channels and using combinators like select can improve composability.
    Spawning short-lived OS threads may be too expensive; thread pools and lightweight
    user thread runtimes can help to achieve more flexibility. Though relying on a
    concurrency runtime is an additional dependency that is not always replacable
    or adjustable. Another approach to concurrency with good flexibility and composability
    is asynchronous programming with cooperative multitasking and async/await syntax,
    as exemplified by Rust. Software transactional memory is a highly composable and
    flexible approach to concurrency, though it has some restrictions, additional
    overhead and does not guarantee fairness.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，传统的主流并发方法基于显式、低级别的同步原语和通过共享的可变内存直接通信的方法是众所周知且已确立的，但这种方法容易出错，不太可组合。限制对共享内存的并发访问，例如像Rust中的所有权模型或像Haskell中的不可变性，可以帮助防止数据竞争。通过通道等消息传递原语进行通信和同步，以及使用select等组合子，可以提高可组合性。创建短生命周期的操作系统线程可能过于昂贵；线程池和轻量级用户线程运行时可以帮助实现更高的灵活性。尽管依赖并发运行时是一种额外的依赖关系，不能总是可替换或可调整。另一种具有良好灵活性和可组合性的并发方法是使用协作式多任务和async/await语法的异步编程，正如Rust所示范的那样。软件事务内存是一种高度可组合和灵活的并发方法，尽管它有一些限制，额外的开销，并且不能保证公平性。
- en: Evading Concurrency[​](#evading-concurrency "Direct link to Evading Concurrency")
  id: totrans-split-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[规避并发](#evading-concurrency "直达规避并发的链接")'
- en: Given all the challenges with concurrent programming, why not trying to avoid
    concurrency as much as possible? Some of the explored code bases go quite far
    this route and implement almost all of the core protocol logic as a *completely
    sequential state machine*, perhaps only offloading long-running operations (e.g.,
    computationally intensive cryptography) to dedicated concurrent execution pools.
    Let's consider consequences of this approach.
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于并发编程的所有挑战，为什么不尽可能地避免并发呢？一些探索过的代码库在这方面走得很远，几乎将所有核心协议逻辑实现为*完全顺序状态机*，也许只将长时间运行的操作（例如计算密集型的加密）委托给专用的并发执行池。让我们考虑一下这种方法的后果。
- en: First of all, distributed systems are *inherently concurrent* because they,
    by definition, consist of multiple nodes running largely independently. Thus,
    each node needs to handle events (e.g., messages received over the network or
    expired timeouts) originating from different sources *asynchronously*, i.e. independent
    of its main program flow and handling of events from other sources. Moreover,
    the protocol logic must also reflect the concurrent nature of the system.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，分布式系统因其定义而*固有地并发*，由多个节点独立运行组成。因此，每个节点需要异步地处理来自不同源（例如通过网络接收的消息或已过期的超时）的事件，即与其主程序流和来自其他源的事件处理独立。此外，协议逻辑必须还要反映系统并发性质。
- en: So some parts of the protocol are fundamentally sequential, e.g. delivering
    totally ordered transactions, whereas some parts are fundamentally concurrent,
    e.g. handling of messages received over the network from different peer nodes.
    Some parts *may* be concurrent, but don't have to, e.g. validation of the subsequent
    messages while finishing processing of the current one.
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，协议的某些部分在基本上是顺序的，例如传递完全排序的事务，而某些部分是基本上并发的，例如处理来自不同对等节点的网络消息。某些部分*可能*是并发的，但并非必须，例如，在完成当前消息处理的同时验证后续消息。
- en: Attempting to implement an essentially concurrent part of the protocol in a
    sequential manner, i.e. without using concurrent programming techniques, necessarily
    requires explicitly maintaining and switching contexts. Not only this adds some
    amount of boilerplate code and makes it entangled, more importantly, this causes
    *fragmentation* of the core protocol logic because such an artificially sequential
    component still has to multiplex handling of asynchronous events. Therefore, what
    in concurrent programming could have been naturally expressed as a blocking operation
    becomes an abrupt return of control, breaking out of the sequential component.
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在顺序方式下实现协议的基本并发部分，即不使用并发编程技术，必然需要显式地维护和切换上下文。这不仅增加了一些样板代码并使其交织在一起，更重要的是，这会导致核心协议逻辑的*碎片化*，因为这样的人工顺序组件仍然必须多路复用处理异步事件。因此，在并发编程中可以自然表达为阻塞操作的内容，在顺序组件中变成了控制权的突然返回。
- en: 'There is another problem with multiplexed handling of asynchronous events in
    sequential code, namely controlling the flow of events from concurrent sources.
    Consider a situation where a sequential component is given an event to handle
    that it cannot yet fully process because, in order to make a decision on how to
    react to the event, it first needs to handle some other events, e.g. it has to
    complete the current round of the protocol before participating in a new one.
    Since the sequential component cannot block waiting and has to return the control
    back, there are basically two options: dropping the event or putting it aside
    into some kind of buffer. In the first case, the event source cannot assume that
    all events it emits will be reliably handled and has to take this into account
    in its logic, e.g. emit an equivalent event under some conditions later. In the
    second case, there should be some way to enforce a reasonable bound on the amount
    of buffered pending events without compromising the protocol properties, e.g.
    emitting further events only after having received an acknowledgement from the
    destination. This can add a lot more complexity to the protocol implementation.'
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
  zh: 多路复用处理顺序代码中异步事件存在另一个问题，即控制来自并发源的事件流。考虑这样一种情况，顺序组件接收到一个事件，但由于它尚无法完全处理该事件，需要先处理其他事件，例如，在参与新协议之前必须完成当前协议回合。由于顺序组件不能阻塞等待并且必须返回控制权，基本上有两种选择：丢弃事件或将其放入某种缓冲区中。在第一种情况下，事件源不能假设其发出的所有事件都将得到可靠处理，并且在逻辑上必须考虑到这一点，例如，在某些条件下稍后发出等效事件。在第二种情况下，应该有某种方式来强制限制缓冲挂起事件的数量，而不会损害协议属性，例如，在从目标接收确认后才能继续发出进一步的事件。这可以在协议实现中增加更多复杂性。
- en: 'So concurrency cannot be easily evaded in distributed systems. Attempting to
    avoid using concurrent programming techniques complicates the implementation and
    causes fragmentation of the protocol logic in code. On the other hand, when done
    appropriately, designing for concurrency and using concurrent programming techniques
    can actually be advantageous. It boils down to recognizing inherently concurrent
    and sequential parts of the protocol and finding appropriate ways to express this
    distinction in code. Those parts of the protocol that are neither inherently concurrent
    nor sequential may nevertheless benefit from being implemented as concurrent:
    Designing for concurrency can guide towards better decoupling of components while
    concurrent execution can help to achieve higher responsiveness and performance.'
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在分布式系统中无法轻易地避免并发。试图避免使用并发编程技术会使实现变得复杂，并导致协议逻辑在代码中的分散。另一方面，当适当时，为并发设计并使用并发编程技术实际上可以带来好处。关键在于识别协议中本质上并发和顺序的部分，并找到在代码中表达这种区别的适当方式。那些既不是本质上并发也不是顺序的协议部分可能仍然会因为作为并发实现而受益：为并发设计可以引导更好地解耦组件，而并发执行可以帮助实现更高的响应能力和性能。
- en: Nondeterminism[​](#nondeterminism "Direct link to Nondeterminism")
  id: totrans-split-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[不确定性](#nondeterminism "不确定性的直接链接")'
- en: As mentioned in the previous section, distributed systems are inherently concurrent
    and therefore nondeterministic. If we think of nondeterminism in terms of events
    happening in the system then it can manifest itself as unpredictable events or
    their order. For example, requests from external agents (clients, users, etc.),
    values produced by a random-number generator, or node failures are not known in
    advance; the same set of messages may arrive at different nodes in different order
    due to unpredictable delays in communication; timeouts may happen due to unexpectedly
    long delays. Inner workings of nodes can introduce additional, implementation-specific
    nondeterminism, e.g. unspecified order of iteration over unordered collections,
    scheduling of concurrent tasks, etc. To some extend, the purpose of distributed
    protocols can be seen as confining nondeterminism within certain constraints in
    order to maintain the required invariants.
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，分布式系统本质上是并发的，因此是不确定性的。如果我们将不确定性看作系统中事件发生的方式，那么它可以表现为不可预测的事件或它们的顺序。例如，来自外部代理（客户端、用户等）的请求、随机数生成器产生的值或节点故障都是事先不知道的；同一组消息可能由于通信中不可预测的延迟而以不同的顺序到达不同的节点；超时可能是由于意外的长时间延迟而发生。节点的内部工作可能引入额外的、特定于实现的不确定性，例如无序集合上迭代的未指定顺序、并发任务的调度等。在某种程度上，分布式协议的目的可以被看作是将不确定性限制在某些约束内，以维护所需的不变量。
- en: Nondeterministic steps in protocol execution introduce alternative state transitions,
    thus expanding the [*state space*](https://en.wikipedia.org/wiki/State_space_(computer_science)).
    This complicates reasoning about distributed protocols, as well as implementing
    and verifying them, because it often requires considering a large number of possible
    executions. Nondeterministic execution also makes *reproducing* problems and debugging
    particularly challenging. Therefore, it is desirable to control nondeterminism
    or attempt to eliminate it.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 协议执行中的不确定步骤引入了替代状态转换，从而扩展了[*状态空间*](https://en.wikipedia.org/wiki/State_space_(computer_science))。这增加了对分布式协议的推理、实现和验证的复杂性，因为通常需要考虑大量可能的执行方式。不确定的执行还使得*复现*问题和调试特别具有挑战性。因此，控制不确定性或试图消除它是可取的。
- en: Some of the explored code bases constrain nondeterminism by implementing parts
    of the protocol as *deterministic* state machines. Inherently nondeterministic
    aspects, such as time, randomness, and asynchronous operations, are abstracted
    out of those state machines. Randomness, as well as current time, can be supplied
    to the state machine through abstract interfaces provided as dependencies. Alternatively,
    the current timestamp can be supplied to the state machine at each step explicitly
    in the input. Time can also be represented in terms of an abstract logical clock
    maintained by the state machine, which is then advanced with special tick events
    periodically supplied to the state machine. Asynchronous operations can be requested
    by the state machine by emitting special output events; the result is then supplied
    back as special input events. This approach is very close to evading concurrency
    discussed before and therefore is associated with the same kind of disadvantages.
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一些探索的代码库通过将协议的部分实现为*确定性*状态机来限制非确定性。固有的非确定性方面，如时间、随机性和异步操作，则从这些状态机中抽象出来。随机性和当前时间可以通过提供为依赖项的抽象接口提供给状态机。或者，当前时间戳可以在每个步骤中明确地提供给状态机的输入。时间还可以用状态机维护的抽象逻辑时钟表示，然后通过定期提供给状态机的特殊时钟事件来推进。异步操作可以通过状态机发出特殊输出事件来请求；结果然后作为特殊输入事件返回。这种方法非常接近于以前讨论过的避免并发，因此与相同类型的缺点相关联。
- en: 'In Haskell, as a strictly typed purely functional programming language, ordinary
    functions are deterministic ([referentially transparent](https://en.wikipedia.org/wiki/Referential_transparency))
    in the mathematical sense: given the same input, they must produce the same result.
    Nondeterministic computations are expressed using the [monadic](https://en.wikipedia.org/wiki/Monad_(functional_programming))
    interface. Only IO actions, when executed in the [IO monad](https://hackage.haskell.org/package/base-4.19.0.0/docs/GHC-IO.html#t:IO),
    can cause side effects and produce nondeterministic results. This is enforced
    by the type system. Cardano takes advantage of this by making most of its code
    polymorphic in the main IO-like monad. This allows fully controlling nondeterminism
    by choosing the main monad implementation.'
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，作为严格类型的纯函数式编程语言，普通函数在数学意义上是确定性的（[引用透明](https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E9%80%8F%E6%98%8E%E5%BA%A6)）：给定相同的输入，它们必须产生相同的结果。非确定性计算通过[单子](https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1))接口来表达。只有在
    [IO 单子](https://hackage.haskell.org/package/base-4.19.0.0/docs/GHC-IO.html#t:IO)
    中执行的 IO 动作才能引起副作用并产生非确定性结果。这是由类型系统强制执行的。Cardano 利用这一点，通过选择主要的 IO 类似单子的实现来完全控制非确定性。
- en: Being able to control nondeterminism is particularly useful for testing and
    debugging. This allows creating *reproducible* test environments, as well as [discrete-event
    simulation](https://en.wikipedia.org/wiki/Discrete-event_simulation) for faster-than-real-time
    simulation of time delays. For example, Cardano uses a simulation environment
    for the IO monad that closely follows core Haskell packages; Sui has a simulator
    based on [`madsim`](https://github.com/madsim-rs/madsim) that provides an API-compatible
    replacement for the [Tokio](https://tokio.rs/) runtime and intercepts various
    POSIX API calls in order to enforce determinism. Both allow running the same code
    in production as in the simulator for testing.
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 能够控制非确定性对于测试和调试特别有用。这允许创建*可重复*的测试环境，以及用于比实时模拟时间延迟更快的[离散事件仿真](https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BA%8B%E4%BB%B6%E4%BB%BF%E7%9C%9F)。例如，Cardano
    使用了一个模拟环境，该环境紧密遵循核心 Haskell 包中的 IO 单子；Sui 则使用了基于 [`madsim`](https://github.com/madsim-rs/madsim)
    的模拟器，该模拟器提供了一个 API 兼容的替代品用于 [Tokio](https://tokio.rs/) 运行时，并拦截各种 POSIX API 调用以强制实现确定性。这两者都允许在生产环境中运行相同的代码以进行测试。
- en: Nondeterminism is an important aspect of distributed systems, so it should be
    clearly expressed in the implementation. Type system features can help with that.
    Confining nondeterminism within *natural* boundaries of components can reduce
    complexity and simplify reasoning about the protocol implementation. Simulated
    execution of unmodified code with controlled nondeterminism is a very effective
    technique in testing and debugging.
  id: totrans-split-104
  prefs: []
  type: TYPE_NORMAL
  zh: 非确定性是分布式系统的重要方面，因此在实现中应该清晰表达。类型系统的特性可以帮助处理这一点。将非确定性限制在组件的*自然*边界内可以减少复杂性，并简化对协议实现的推理。通过控制非修改代码的模拟执行中的非确定性是测试和调试中非常有效的技术。
- en: Communication[​](#communication "Direct link to Communication")
  id: totrans-split-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通信[​](#communication "直达通信")
- en: Communication is at the core of distributed systems where individual nodes need
    to coordinate in order to act as a coherent system. Nodes in a distributed system
    interact with each other by exchanging *peer-to-peer* (P2P) messages. The communication
    happens over an *unreliable* network medium that only provides *best-effort, unordered
    delivery* of data packets, i.e. it may fail to deliver individual packets or deliver
    them out of order. Moreover, nodes can fail, and, in general, it may be impossible
    to determine precisely if a peer node has failed or its messages were simply dropped
    or delayed in the network. Nodes can also differ in processing power and experience
    different traffic load. Therefore, it is important to manage the rate of data
    transmission using [*flow control*](https://en.wikipedia.org/wiki/Flow_control_(data))
    mechanisms, as well as to retransmit lost pieces of data. This can contribute
    significantly to the overall complexity of distributed protocols and their implementation.
  id: totrans-split-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通信是分布式系统的核心，其中各个节点需要协调以作为一个一致的系统。分布式系统中的节点通过交换*点对点*（P2P）消息进行互动。通信发生在一个*不可靠*的网络介质上，它仅提供*尽力而为、无序交付*的数据包，即可能无法交付个别数据包或者按顺序交付它们。此外，节点可能会失败，通常情况下很难准确判断节点是否失败或其消息是否仅仅是在网络中丢失或延迟。节点的处理能力和经历的流量负载可能也会有所不同。因此，使用[*流量控制*](https://en.wikipedia.org/wiki/Flow_control_(data))机制管理数据传输速率非常重要，同时需要重新传输丢失的数据片段。这些因素显著增加了分布式协议及其实现的总体复杂性。
- en: Communication Layers[​](#communication-layers "Direct link to Communication
    Layers")
  id: totrans-split-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通信层[​](#communication-layers "直达通信层")
- en: Most of the explored implementations use SSL/TLS over TCP/IP as a transport
    layer for P2P communication. Establishing a TCP connection takes a few packet
    round trips over the network. Moreover, operating systems impose limits on the
    number of open TCP connections per process because they consume system resources.
    For those reasons, communication layers based on TCP establish long-lived connections
    with remote peers and try to keeps the number of open connections low. This often
    means that the transport-level connections have to be *multiplexed* into multiple
    logical sub-streams.
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数研究实施使用 SSL/TLS 在 TCP/IP 上作为 P2P 通信的传输层。建立 TCP 连接需要在网络上进行几次数据包往返。此外，操作系统对每个进程打开的
    TCP 连接数设置了限制，因为它们会消耗系统资源。因此，基于 TCP 的通信层会与远程节点建立长连接，并努力保持开放连接的数量低。这通常意味着传输级别的连接必须*复用*成多个逻辑子流。
- en: Substrate and Lighthouse use [`libp2p`](https://libp2p.io/) as a networking
    stack for communication between nodes. The `libp2p` framework is a versatile modular
    peer-to-peer networking stack. It provides a collections of abstractions, mechanisms,
    and protocols for facilitating communication in P2P systems. In particular, `libp2p`
    supports multiple transport mechanisms (TCP, QUIC, WebSocket, WebTransport, etc.),
    encryption schemes (TLS and Noise), and stream multiplexing. Higher-level protocols
    in `libp2p` are implemented on top of reliable, ordered, bidirectional binary
    streams, which are transparently encrypted and multiplexed by the framework.
  id: totrans-split-109
  prefs: []
  type: TYPE_NORMAL
  zh: Substrate 和 Lighthouse 使用 [`libp2p`](https://libp2p.io/) 作为节点之间通信的网络堆栈。`libp2p`
    框架是一种多功能的模块化对等网络堆栈。它提供了一系列抽象、机制和协议，以促进对等网络系统中的通信。特别是，`libp2p` 支持多种传输机制（TCP、QUIC、WebSocket、WebTransport
    等）、加密方案（TLS 和 Noise）以及流复用。`libp2p` 中的高级协议建立在可靠、有序、双向的二进制流之上，这些流由框架透明地加密和复用。
- en: Communication layer in Sui is based on [`anemo`](https://github.com/MystenLabs/anemo),
    a peer-to-peer networking library built on top of [QUIC](https://en.wikipedia.org/wiki/QUIC).
    QUIC is a modern higher-level network transport protocol layered over UDP. It
    has built-in support for encryption and multiplexing. Similar to TCP connections,
    QUIC streams are reliable, ordered, bidirectional, providing flow control (backpressure),
    but they are cheap and almost instantaneous to open once an initial connection
    is established. The `anemo` library takes advantage of the efficient stream-multiplexing
    capability of QUIC; `libp2p` also uses the built-in capabilities of QUIC when
    it is used as a transport mechanism.
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: Sui中的通信层基于[`anemo`](https://github.com/MystenLabs/anemo)，这是一个构建在[QUIC](https://en.wikipedia.org/wiki/QUIC)之上的对等网络库。QUIC是一种现代化的高级网络传输协议，位于UDP之上。它内置支持加密和多路复用。类似于TCP连接，QUIC流是可靠的、有序的、双向的，并提供流量控制（背压），但它们在建立初始连接后几乎可以立即打开，成本低廉。`anemo`库利用了QUIC的高效流多路复用能力；当作为传输机制使用时，`libp2p`也使用了QUIC的内置功能。
- en: So there may be several levels of communication abstractions. There are low-level
    transport protocols like UDP or TCP, medium-level ones like QUIC, and comprehensive
    high-level networking stacks like `libp2p`. Higher-level mechanisms can be built
    on top of lower-level layers. Sometimes, it makes sense to fuse several layers,
    e.g. QUIC efficiently embeds security into the transport layer. In order to simplify
    implementation of higher-level layers, it is desirable to take advantage of those
    properties that are already guaranteed by lower-level layers, e.g. reliable, ordered
    delivery and flow control provided by commonly used transport layers such as TCP
    and QUIC.
  id: totrans-split-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可能存在多个层次的通信抽象。有低级传输协议，如UDP或TCP，中级协议如QUIC，以及综合高级网络堆栈，如`libp2p`。更高级别的机制可以构建在较低级别的层之上。有时，将几个层次融合在一起是有意义的，例如QUIC有效地将安全性嵌入传输层中。为了简化更高级别层的实现，利用已由低级别层次保证的这些属性是可取的，例如TCP和QUIC等常用传输层提供的可靠有序传递和流量控制。
- en: Styles of Communication[​](#styles-of-communication "Direct link to Styles of
    Communication")
  id: totrans-split-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[通信风格](#styles-of-communication "Styles of Communication的直接链接")'
- en: 'There are different ways to organize communication between nodes. The most
    common styles of communication in the explored code bases are *request-response*
    and *fire-and-forget* message delivery. The *request-response* style follows the
    remote procedure call (RPC) pattern: the initiator node sends a message to the
    remote node, and the latter is expected to respond back. In the fire-and-forget
    style, the initiator node unidirectionally sends messages to the remote node without
    waiting for a response. Another style of communication, which is also often used
    in the explored implementations, is *gossiping*, where nodes publish and disseminate
    pieces of information among themselves in an indirect and random manner. Cardano
    uses a *session-based* style of communication, where peers establish continuous
    bidirectional communication channels and exchange messages according to some stateful
    communication protocol.'
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法来组织节点之间的通信。在探索的代码库中，最常见的通信风格是*请求-响应*和*发即弃*消息传递。*请求-响应*风格遵循远程过程调用（RPC）模式：发起节点向远程节点发送消息，并且后者期望回复。在*发即弃*风格中，发起节点单向发送消息到远程节点，而不等待响应。另一种通信风格，也经常在探索的实现中使用，是*八卦*，其中节点以间接和随机的方式发布和传播信息片段。Cardano使用基于*会话*的通信风格，其中对等体建立连续的双向通信通道，并根据某些有状态的通信协议交换消息。
- en: The *fire-and-forget* message delivery is a very simple style of communication.
    It does not mandate any acknowledgement from the remote node, so it can only provide
    best-effort delivery guarantee. Messages that cannot be handled for any reason
    are often simply dropped, e.g. when a message queue is full. Usually, there is
    also no guarantee about ordering of messages. Higher-level code needs to take
    care of such things as flow control, retransmission of lost messages, as well
    as determining and maintaining the context to handle messages in. On the other
    hand, this style can be expressed with a non-blocking interface. That allows sending
    a message to a group of remote nodes at once, which is a simple form of best-effort
    multi-/broadcasting. Some implementations provide a blocking or asynchronous variant
    of the interface giving more control over data flow within the local node. For
    example, in Substrate, the sender should wait until it acquires a free slot in
    the outgoing message buffer; the slot reservation is then consumed to enqueue
    a message.
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*fire-and-forget* 消息传递是一种非常简单的通信风格。它不要求远程节点发送确认，因此只能提供尽力而为的传递保证。由于各种原因无法处理的消息通常会被简单地丢弃，例如消息队列已满时。通常，消息的顺序也无法保证。高级别的代码需要处理诸如流量控制、重传丢失消息以及确定和维护处理消息上下文等问题。另一方面，这种风格可以通过非阻塞接口来表达。这允许一次将消息发送到一组远程节点，这是一种简单的尽力而为的多播/广播形式。一些实现提供了接口的阻塞或异步变体，在本地节点内部更多地控制数据流动。例如，在
    Substrate 中，发送方应等待，直到在传出消息缓冲区中获得一个空闲槽位；然后消费该槽位来排队一个消息。'
- en: 'The *request-response* style is a simple type of session-based communication:
    sending a request initiates a new session, which normally terminates with reception
    of the corresponding response. Sessions can terminate abnormally, e.g. upon a
    timeout. The request-response style demands blocking or asynchronous interface
    on the sender side since it should wait for and handle the eventual response or
    error. This provides a context for response messages linking them to the corresponding
    requests. However, the communication layer treats each individual session independently.
    More complex patterns of interaction have to be split into a number of one-shot
    request-response sessions. Multiple sessions may be initiated concurrently, and
    the communication layer needs to keep track of those one-shot sessions starting,
    running, and finishing concurrently.'
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*request-response* 风格是一种简单的基于会话的通信类型：发送请求启动一个新会话，通常以接收相应的响应结束。会话可能会因超时等异常情况而异常终止。请求-响应风格要求发送方在接口上提供阻塞或异步支持，因为它需要等待并处理最终的响应或错误。这为响应消息提供了一个上下文，将它们与相应的请求联系起来。然而，通信层独立处理每个个体会话。更复杂的交互模式必须分解成多个一次性请求-响应会话。多个会话可以同时启动，并且通信层需要跟踪这些一次性会话的启动、运行和并发完成情况。'
- en: The *session-based* style of communication is connection-oriented and supports
    *stateful* interaction between nodes. Communication sessions are established between
    individual nodes and represent reliable, ordered, bidirectional message streams.
    This provides a context for the messages being exchanged between nodes and implies
    blocking or asynchronous interface. Thanks to reliable and ordered delivery, the
    context establishes causal relationship between individual messages. Relying on
    those assumptions can greatly simplify the protocol implementation while taking
    advantage of the guarantees commonly provided by stream-based transport layers.
    This style of communication is quite generic and can express many different patterns
    of interaction. Combined with built-in flow control (backpressure), it is particularly
    suited for implementing *consumer-driven* communication. On the other hand, session-based
    communication cannot directly express multi-/broadcasting primitives and can induce
    additional latency in certain patterns of interaction. Though higher-level communication
    mechanisms built on top of session-based communication can implement multi-/broadcasting,
    whereas using [pipelining](https://en.wikipedia.org/wiki/Protocol_pipelining)
    techniques can help to hide latency and achieve good performance.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于会话的*通信风格是面向连接的，并支持节点之间的*有状态*交互。通信会话在个体节点之间建立，并代表可靠、有序、双向的消息流。这为节点之间交换的消息提供了上下文，并暗示了阻塞或异步接口。依靠可靠和有序的传递，上下文建立了个别消息之间的因果关系。依赖这些假设可以极大简化协议的实现，同时利用流传输层通常提供的保证。这种通信风格非常通用，可以表达许多不同的交互模式。结合内置的流量控制（反压），特别适合实现*消费驱动*的通信。另一方面，基于会话的通信不能直接表达多路广播原语，并且在某些交互模式下可能引入额外的延迟。尽管基于会话的通信机制可以在其上构建多路广播，而使用[pipelining](https://en.wikipedia.org/wiki/Protocol_pipelining)技术可以帮助隐藏延迟并实现良好的性能。'
- en: 'The *gossip-style* communication designates probabilistic broadcasting in a
    relay network of nodes. It resembles the best-effort broadcasting in the fire-and-forget
    message delivery style. The key difference is that data in the gossip-style communication
    can propagate from one node to another in multiple hops rather than being received
    directly from the source node. This makes it suitable for sparsely connected networks.
    Therefore, gossip communication can scale well in large networks. It can provide,
    with high probability, eventual delivery of bounded amount of data under normal
    network conditions. This style of communication implies a publish-subscribe interface.
    Similar to the fire-and-forget message delivery, the interface is largely stateless
    and can be non-blocking. Under the hood, it is often implemented using the advertise-request-response
    pattern of communication: nodes advertise available pieces of data to their neighbors
    and exchange with them the missing parts following the request-response pattern.
    Efficient gossip implementations require adaptive network topology and advanced
    data dissemination techniques, which can make them fairly complicated.'
  id: totrans-split-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*八卦式*通信设计ates表示在节点中继网络中的概率广播。它类似于最佳努力广播中的火发忘消息传递风格。关键区别在于，八卦式通信中的数据可以从一个节点传播到另一个节点，经过多个跳跃，而不是直接从源节点接收。这使其适用于稀疏连接的网络。因此，八卦通信在大型网络中可以很好地扩展。在正常网络条件下，它可以以高概率提供有限数量数据的最终传递。这种通信风格意味着发布-订阅接口。类似于火发忘消息传递，接口基本上是无状态的，可以是非阻塞的。在底层，它通常使用广告请求响应通信模式来实现：节点向邻居广告可用数据片段，并按照请求响应模式交换缺失的部分。高效的八卦实现需要自适应网络拓扑和先进的数据传播技术，这使它们相当复杂。'
- en: An interesting example of using the gossip-style communication is artifact pools
    in the Internet Computer blockchain. Artifact pools in ICP are structured collections
    of artifacts, generic pieces of data produced by the local replica or received
    from other nodes. The gossip layer is responsible for synchronizing artifact pools
    between nodes. Nodes communicate with each other through the artifact pools by
    adding/removing/moving artifacts to/from/between pool sections. Higher-level code
    is responsible for artifact validation; it also determines retention and prioritization
    policies.
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网计算机区块链中使用八卦式通信的一个有趣例子是工件池。ICP中的工件池是结构化的工件集合，是本地副本生成或从其他节点接收的通用数据片段。八卦层负责在节点之间同步工件池。节点通过向工件池添加/删除/移动工件来相互通信。更高级别的代码负责工件验证；它还确定保留和优先级化策略。
- en: It is easy to notice that some styles of communication can be implemented in
    terms of others. So the request-response style is a reduced from of the session-based
    communication, which is more generic and expressive. Both can be implemented relying
    on the fire-and-forget delivery and using some message retransmission and acknowledgement
    protocol. Or conversely, the fire-and-forget message delivery can be implemented
    on top of a reliable session-based communication using bounded lossy message queues.
    Similarly, gossip mechanisms can be implemented using any of the other styles
    of communication; though the implementations may differ in complexity.
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 易于注意到，某些通信样式可以用其他样式实现。因此，请求-响应样式是会话基础通信的一种简化形式，后者更通用且表达力更强。两者都可以依赖于点对点交付和使用一些消息重传和确认协议来实现。或者反过来，可以通过可靠的会话基础通信使用有界丢失消息队列来实现点对点交付。类似地，八卦机制可以使用任何其他通信样式实现；尽管实现可能在复杂性上有所不同。
- en: Different styles of communication have different properties that can significantly
    influence the shape of code built around them. Some of them are strictly more
    expressive than others, but do not necessarily reduce to an equivalent, because
    less expressive mechanisms may have more efficient implementations. In order to
    avoid accidental complexity when implementing distributed protocols, it is important
    to have a range of communication mechanisms with aligned interfaces and clearly
    defined properties.
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的通信样式具有不同的属性，这些属性可以显著影响围绕它们构建的代码形状。其中一些通信样式严格更具表达力，但并不一定归约为等效的，因为较不具表达力的机制可能具有更高效的实现。为了避免在实现分布式协议时出现意外复杂性，拥有一系列具有对齐接口和明确定义属性的通信机制非常重要。
- en: Internal Communication[​](#internal-communication "Direct link to Internal Communication")
  id: totrans-split-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内部通信[​](#internal-communication "Direct link to Internal Communication")
- en: 'Apart from interaction between nodes, there is also communication between concurrent
    tasks within the same node. This internal communication shares some similarity
    with communication between nodes. The main difference is in the communication
    medium: while different nodes communicate through unreliable and slow network,
    internal communication happens through fast and reliable shared memory. Some programming
    models and techniques make the similarity particularly prominent, e.g. the [actor
    model](https://en.wikipedia.org/wiki/Actor_model), [communicating sequential processes](https://en.wikipedia.org/wiki/Communicating_sequential_processes)
    (CSP), [remote procedure calls](https://en.wikipedia.org/wiki/Remote_procedure_call)
    (RPC), etc.'
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节点之间的交互外，同一节点内并发任务之间也存在通信。这种内部通信与节点间通信有些相似之处。主要区别在于通信介质：不同节点通过不可靠和缓慢的网络进行通信，而内部通信则通过快速可靠的共享内存进行。一些编程模型和技术使这种相似性特别突出，例如[演员模型](https://en.wikipedia.org/wiki/Actor_model)，[通信顺序进程](https://en.wikipedia.org/wiki/Communicating_sequential_processes)（CSP），[远程过程调用](https://en.wikipedia.org/wiki/Remote_procedure_call)（RPC）等。
- en: Any piece of shared memory can act as a communication channel between internal
    components. Such a channel can be established by simply sharing a reference to
    the corresponding piece of memory. Internal messages do not need translation into/from
    a binary representation; they can be simply shared by reference. The request-response
    style of communication can be implemented as simple invocation of blocking or
    asynchronous procedures (functions); invoking non-blocking procedures (functions)
    without a return value corresponds to the fire-and-forget message delivery style.
    Obviously, such procedures need to be safe for concurrent invocation.
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: 任何共享内存片段都可以作为内部组件之间的通信通道。这样的通道可以通过简单地共享对应内存片段的引用来建立。内部消息不需要转换成/从二进制表示形式；它们可以简单地通过引用共享。请求-响应式通信风格可以实现为简单地调用阻塞或异步过程（函数）；调用无返回值的非阻塞过程（函数）对应于发出并忘记消息传递风格。显然，这些过程需要对并发调用安全。
- en: 'The session-based communication style can be implemented for internal communication
    using the constructs commonly known as [*channels*](https://en.wikipedia.org/wiki/Channel_(programming))
    (e.g. [channels](https://go.dev/ref/spec#Channel_types) in Go, [Tokio channels](https://docs.rs/tokio/latest/tokio/sync/index.html#message-passing)
    in Rust) or concurrent *queues* (e.g. [`LinkedBlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingQueue.html)
    and other concurrent [queues](https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html)
    in Java). Those constructs belong to fundamental mechanisms of *communication
    and coordination* between concurrent components. Channels can be *buffered* or
    *unbuffered* (i.e. not buffered). Buffered channels and queues can hold items
    being sent through them without blocking the sender. In contrast, sending to or
    receiving from an unbuffered channel acts as a rendezvous point: it synchronizes
    the sender and the receiver at the point of communication.'
  id: totrans-split-124
  prefs: []
  type: TYPE_NORMAL
  zh: 会话式通信风格可以通过通常称为[*通道*](https://zh.wikipedia.org/wiki/通道_(程序设计))（例如，在Go中的[通道](https://go.dev/ref/spec#Channel_types)，在Rust中的[Tokio通道](https://docs.rs/tokio/latest/tokio/sync/index.html#message-passing)）或并发*队列*（例如，[`LinkedBlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingQueue.html)及Java中其他并发[队列](https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html)）来实现内部通信。这些构造属于并发组件之间的基本*通信和协调*机制。通道可以是*缓冲*的或*非缓冲*的（即非缓冲的）。缓冲通道和队列可以在发送方不阻塞的情况下保存传输的项。相比之下，向非缓冲通道发送或从中接收作为会合点：它同步了发送方和接收方在通信点。
- en: Buffered channels and queues that can hold more than a singe item may return
    items to a receiver in different order. FIFO is the most commonly used ordering
    policy, in which items are returned in the same order as they were inserted. LIFO
    is another option, in which the most recently inserted item is the one that is
    returned first. One can think of many other options such as priority queues etc.
    The preferred ordering policy would depend on the purpose of communication.
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 能够容纳多个项的缓冲通道和队列可能会以不同顺序向接收者返回项。FIFO是最常用的排序策略，其中项按照插入的顺序返回。LIFO是另一种选项，其中最近插入的项首先返回。人们可以考虑许多其他选项，例如优先级队列等等。首选的排序策略将取决于通信的目的。
- en: Buffered channels and queues can be *bounded* or *unbounded*. The bounded version
    imposes a hard limit on the amount of items that they can hold. Unbounded channels
    and queues usually provide a simple *non-blocking* interface for inserting new
    items. However, they require some additional mechanism to prevent accumulating
    indefinite amount of items, e.g. blocking ingress of external events when internal
    buffers grow above certain threshold or relying on time-based assumptions such
    as throttling the data flow or imposing expiration time on the items. Such mechanisms
    can make reasoning about the protocol implementation more complicated.
  id: totrans-split-126
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道和队列可以是*有界*的或*无界*的。有界版本对它们可以保存的项数施加了硬限制。无界通道和队列通常提供了一个简单的*非阻塞*接口来插入新项。然而，它们需要一些额外的机制来防止累积无限数量的项，例如，在内部缓冲区增长到某个阈值以上时阻止外部事件的进入或依赖基于时间的假设，如限制数据流或对项施加过期时间。这些机制可能使协议实现的推理变得更加复杂。
- en: Bounded channels and queues usually provide blocking or asynchronous interface.
    They can also support non-blocking insertion of new items, but then they must
    discard some items when there is no more capacity left. There may be different
    eviction policies. The simplest one is to discard the item being inserted. Otherwise,
    the new item is inserted, but some of the buffered items must be discarded, e.g.
    the least recently inserted one. Similarly to the ordering policy, there may be
    many other options, and the choice depends on the purpose of communication.
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有界通道和队列通常提供阻塞或异步接口。它们也可以支持非阻塞插入新项目，但当没有剩余容量时必须丢弃一些项目。可能会有不同的驱逐策略。最简单的策略是丢弃正在插入的项目。否则，将插入新项目，但必须丢弃一些缓冲的项目，例如最近插入的项目。类似于排序策略，可能还有许多其他选项，选择取决于通信的目的。
- en: 'It is also worth mentioning buffered channels with a single-item buffer. They
    can be convenient for communicating a single item from one concurrent component
    to another, e.g. sending a response message back to the requester. The [`oneshot`](https://docs.rs/tokio/latest/tokio/sync/oneshot/index.html)
    channel in Tokio is a good example of such channel type. [`CompletableFuture`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)
    in Java can also be considered a kind of single-item buffered channel, as well
    as synchronizing variables [`MVar`](https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Concurrent-MVar.html)
    and [`TMVar`](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Concurrent-STM-TMVar.html)
    in Haskell. Another interesting example of a single-item buffered channel is the
    [`watch`](https://docs.rs/tokio/latest/tokio/sync/watch/index.html) channel in
    Tokio: it always keeps the last value sent to it. The `watch` channel is useful
    for watching for changes to a value from multiple concurrent components. Transactional
    variables ([`TVar`](https://hackage.haskell.org/package/stm-2.5.3.0/docs/Control-Concurrent-STM-TVar.html)s)
    in Haskell are somewhat similar to watch channels since STM transactions can be
    suspended until one of the [`TVar`](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Concurrent-STM-TVar.html)s
    that it has read from has been updated.'
  id: totrans-split-128
  prefs: []
  type: TYPE_NORMAL
  zh: 也值得一提的是带有单项缓冲区的缓冲通道。它们可以方便地将单个项目从一个并发组件传递到另一个，并且例如将响应消息发送回请求者。Tokio中的[`oneshot`](https://docs.rs/tokio/latest/tokio/sync/oneshot/index.html)通道就是这种通道类型的一个很好的例子。Java中的[`CompletableFuture`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)也可以被视为一种单项缓冲通道，以及Haskell中的同步变量[`MVar`](https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Concurrent-MVar.html)和[`TMVar`](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Concurrent-STM-TMVar.html)。另一个有趣的单项缓冲通道的例子是Tokio中的[`watch`](https://docs.rs/tokio/latest/tokio/sync/watch/index.html)通道：它始终保留最后发送到它的值。`watch`通道对于从多个并发组件中观察值的变化非常有用。Haskell中的事务变量（[`TVar`](https://hackage.haskell.org/package/stm-2.5.3.0/docs/Control-Concurrent-STM-TVar.html)）与观察通道有些类似，因为STM事务可以被挂起，直到其读取的某个[`TVar`](https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Concurrent-STM-TVar.html)被更新。
- en: Channels and queues often serve as fundamental constructs to implement [message
    passing](https://en.wikipedia.org/wiki/Message_passing) between concurrent components.
    They can be used to implement various styles of internal communication and higher-level
    components. For example, implementations of components for communication between
    nodes often use channels and queues as internal message buffers.
  id: totrans-split-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通道和队列通常作为在并发组件之间实现[消息传递](https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92)的基本构造。它们可用于实现各种内部通信和高级组件。例如，用于节点之间通信的组件实现通常使用通道和队列作为内部消息缓冲区。
- en: The [publish-subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)
    design pattern resembles the gossip style of communication. It can be implemented
    for internal communication as an event bus or broadcast channel. Same as channels
    and queues, it can be buffered or unbuffered, bounded or unbounded. Unless messages
    can be dropped, unbuffered and bounded buffered implementations only support non-blocking
    publishing/broadcasting of messages if no subscriber blocks.
  id: totrans-split-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[发布-订阅](https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85)设计模式类似于传闻式的通信方式。它可以作为内部通信的事件总线或广播通道进行实现。与通道和队列相同，它可以是有缓冲或无缓冲、有界或无界的。除非消息可以被丢弃，否则无缓冲和有界缓冲的实现只支持在没有订阅者阻塞时非阻塞地发布/广播消息。'
- en: Similar to communication between nodes, different mechanisms and styles of internal
    communication have different properties that can significantly influence the shape
    of code. Therefore, it is equally important to have a range of internal communication
    mechanisms with aligned interfaces and clearly defined properties. The similarity
    between mechanisms for internal communication and communication between nodes
    provides an interesting perspective and can help to come up with better abstractions
    for communication.
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于节点之间的通信，不同的内部通信机制和样式具有不同的特性，这些特性可以显著影响代码的结构。因此，拥有一系列具有对齐接口和清晰定义特性的内部通信机制同样重要。内部通信机制与节点之间通信机制的相似性提供了一个有趣的视角，并有助于提出更好的通信抽象。
- en: Resilience[​](#resilience "Direct link to Resilience")
  id: totrans-split-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[恢复性](#resilience "直达链接到恢复性")'
- en: '*Fault-tolerant* distributed systems are meant to tolerate (within limits)
    faults of individual nodes due to crashes, network partitioning, malfunctioning,
    or even malicious behavior. Crash fault tolerant (CFT) systems, e.g. Apache Kafka
    and Apache Zookeeper, are relatively simple since they can only withstand node
    crashes and network partitioning. Byzantine fault tolerant (BFT) systems, e.g.
    public blockchains, are designed to withstand arbitrary (including malicious)
    behavior of a fraction of nodes and thus are significantly more complicated. There
    are two sides of the issue: preventing faulty or malicious nodes from compromising
    the whole system and recovering failed nodes to rejoin the system.'
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*容错*分布式系统旨在容忍（在一定限度内）由于崩溃、网络分区、故障或者甚至恶意行为导致的单个节点的故障。崩溃容错（CFT）系统，例如 Apache Kafka
    和 Apache Zookeeper，相对简单，因为它们只能抵抗节点崩溃和网络分区。拜占庭容错（BFT）系统，例如公共区块链，则设计成能够抵御部分节点的任意（包括恶意）行为，因此复杂得多。问题的两个方面是：防止故障或恶意节点危害整个系统，并恢复失败的节点以重新加入系统。'
- en: Theoretically, fault-tolerant distributed protocols are designed so that they
    guarantee their safely and liveness properties despite the presence of faulty
    nodes in the system, provided that certain assumptions hold. In practice, those
    guarantees are only provided if the implementation ensures that the required assumptions
    actually hold. This is particularly challenging in BFT systems meant to operate
    in adversarial environments. Nodes in such systems can be subjects to various
    attacks, such as denial-of-service (DoS) attacks through resource exhaustion.
    *Fairness* between peers is another concern since it may also impact resilience.
  id: totrans-split-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，容错分布式协议被设计成在系统中存在故障节点的情况下，仍然能够保证其安全性和活性属性，前提是某些假设成立。实际上，只有在实现确保所需的假设实际成立时，才能提供这些保证。在拜占庭容错系统中，这尤其具有挑战性，因为这些系统旨在在对抗环境中运行。这种系统中的节点可能遭受各种攻击，例如通过资源耗尽进行的拒绝服务（DoS）攻击。同行之间的*公平性*也是一个关注点，因为它可能影响到恢复性。
- en: To mitigate those risks, many implementations maintain *reputation* metrics
    for remote peers and apply *rate-limiting* or *throttling* techniques. Peer reputation
    is based on the observable behavior of the peer, such as protocol violations,
    timeouts, and performance. Nodes normally disconnect from remote peers whose reputation
    drops below a certain threshold, as well as reject inbound connections from those
    peers. Conversely, peers with higher reputation may be preferred for communication
    in sparsely connected systems.
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少这些风险，许多实现会维护远程对等体的*声誉*度量，并应用*速率限制*或*限流*技术。对等体的声誉基于其可观察到的行为，例如协议违规、超时和性能。节点通常会与声誉低于某一阈值的远程对等体断开连接，并拒绝来自这些对等体的入站连接。相反，声誉较高的对等体在稀疏连接的系统中可能更适合进行通信。
- en: 'In its threat-aware design approach, Cardano emphasizes *detecting protocol
    violations as early as possible* in the operational cycle where the data is available
    but the least resources have been expended to process the received data^([5](#user-content-fn-threat-aware-approach-d8d72b)).
    For instance, block and transaction relaying is interleaved with validation to
    avoid circulating invalid data in the system. This approach works well with *stateful*
    *consumer-driven* communication between nodes: Inbound messages must be well-formed
    syntactically and semantically valid in the context of information previously
    received from the peer node.'
  id: totrans-split-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在其面向威胁的设计方法中，Cardano强调在操作周期的早期尽可能*尽早检测到协议违规*，这时数据可用但处理接收数据的资源最少^([5](#user-content-fn-threat-aware-approach-d8d72b))。例如，块和交易的中继与验证交替进行，以避免在系统中传播无效数据。这种方法与节点之间的*有状态*
    *消费驱动*通信非常契合：入站消息在语法上必须格式良好并在信息上下文中语义有效。
- en: In order to allow failed nodes to efficiently restore and safely rejoin the
    system, some parts of the protocol state can be persisted in a stable storage.
    This is usually implemented as a [write-ahead log](https://en.wikipedia.org/wiki/Write-ahead_logging)
    (WAL), an append-only stable storage used for crash recovery. Certain events are
    first recorded in the log before the corresponding actions are taken, e.g. before
    sending messages to other nodes. This allows the node to restore and continue
    participating in the protocol from where it stopped, without violating the protocol.
    Persistence mechanisms are also required to support recovery from a massive system
    crash, i.e. to provide the [durability](https://en.wikipedia.org/wiki/Durability_(database_systems))
    property.
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许失败的节点有效地恢复并安全地重新加入系统，协议状态的某些部分可以持久化存储在稳定的存储器中。通常这被实现为[预写式日志](https://zh.wikipedia.org/wiki/%E9%A2%84%E5%86%99%E5%BC%8F%E6%97%A5%E5%BF%97)（WAL），这是一种仅追加的稳定存储，用于崩溃恢复。在执行对其他节点发送消息等操作之前，某些事件首先记录在日志中。这使得节点能够从停止的地方恢复并继续参与协议，而不违反协议规定。持久性机制也需要支持从大规模系统崩溃中恢复，即提供[持久性](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7)属性。
- en: Early detection of protocol violations is advantageous, and the implementation
    structure should allow that. There should be a clear path for propagating information
    about detected protocol violations and other anomalies to adjust peer reputation
    metrics and take appropriate measures. Persistence mechanisms, such as write-ahead
    logging, are required for durability, as well as for safe and efficient node recovery.
  id: totrans-split-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽早检测到协议违规是有利的，并且实现结构应允许这样做。应该有明确的路径来传播关于检测到的协议违规和其他异常的信息，以调整对等体声誉度量并采取适当措施。持久性机制，如预写式日志，对于持久性以及安全高效的节点恢复也是必需的。
- en: Optimization[​](#optimization "Direct link to Optimization")
  id: totrans-split-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化[​](#optimization "优化的直接链接")
- en: Practical distributed systems require not only reliability but also efficiency.
    Simplistic designs and implementations unfortunately tend to exhibit poor performance,
    whereas we would like that our systems scale well and provide decent *throughput*
    and *latency*. Improving those characteristics demands optimization at protocol
    and implementation levels. Great effort has been put into optimizing distributed
    protocols during decades of active research. This gave rise to a range of elaborate
    protocols attempting to achieve ever higher performance. On the implementation
    level, there also exists a variety of technical means for increasing efficiency.
    Optimizations, however, often add more complexity and make protocols harder to
    reason about and implement.
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的分布式系统不仅需要可靠性，还需要效率。简单化的设计和实现往往会表现出较差的性能，而我们希望系统能够良好扩展并提供合理的*吞吐量*和*延迟*。改进这些特性要求在协议和实现层面进行优化。在几十年的积极研究中，人们已经付出了很大努力来优化分布式协议，这导致了一系列旨在实现更高性能的复杂协议的出现。在实现层面，也存在各种增加效率的技术手段。然而，优化往往会增加更多的复杂性，并使协议更难以理解和实现。
- en: Protocol-level optimizations may involve using more complex communication patterns
    and topologies. Protocol phase *pipelining*, i.e. participating with a single
    message in multiple protocol phases at once, and *speculative execution* are common
    techniques to improve responsiveness. *Batching*, as well as advanced cryptography
    such as [threshold signatures](https://en.wikipedia.org/wiki/Threshold_cryptosystem),
    helps to reduce communication overhead. State-of-the-art protocols are often based
    on *advanced data structures*, such as [directed acyclic graphs](https://en.wikipedia.org/wiki/Directed_acyclic_graph)
    (DAGs). At the implementation level, *on-demand execution* and *caching* are often
    used to avoid performing unnecessary or duplicate operations.
  id: totrans-split-141
  prefs: []
  type: TYPE_NORMAL
  zh: 协议级优化可能涉及使用更复杂的通信模式和拓扑结构。协议阶段*流水线*，即在多个协议阶段同时参与单个消息，以及*推测执行*是改善响应能力的常见技术。*批处理*，以及先进的加密技术，如
    [门限签名](https://en.wikipedia.org/wiki/Threshold_cryptosystem)，有助于减少通信开销。最先进的协议通常基于*先进的数据结构*，例如
    [有向无环图](https://en.wikipedia.org/wiki/Directed_acyclic_graph) (DAGs)。在实现级别，*按需执行*和*缓存*通常用于避免执行不必要或重复的操作。
- en: Communication contributes significantly to the overall overhead in distributed
    systems and, therefore, is a clear target for optimization. Point-to-point [protocol
    *pipelining*](https://en.wikipedia.org/wiki/Protocol_pipelining), i.e. continuous
    sending of requests without waiting for the corresponding responses, can greatly
    increase performance by hiding high network latency. Widely used transport protocols,
    such as TCP, tend to perform best under *steady data flow*. Moreover, keeping
    multiple network connections consumes additional system resources. Therefore,
    implementations commonly *multiplex* multiple logical communication streams through
    a single network connection. Minimizing [*head-of-line blocking*](https://en.wikipedia.org/wiki/Head-of-line_blocking)
    effects may require *flow control* mechanisms at the level of individual logical
    streams; large pieces of data should be transmitted through a multiplexed connection
    *in chunks*. Specific kinds of communication, e.g. state synchronization in blockchain
    systems, can benefit from dedicated, specialized communication mechanisms.
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通信在分布式系统中贡献了相当大的总开销，因此是优化的明显目标。点对点 [协议 *流水线*](https://en.wikipedia.org/wiki/Protocol_pipelining)，即在不等待相应响应的情况下连续发送请求，可以通过隐藏高网络延迟大大提高性能。广泛使用的传输协议，如TCP，在*稳定的数据流*下表现最佳。此外，保持多个网络连接会消耗额外的系统资源。因此，实现通常会通过单个网络连接*复用*多个逻辑通信流。在逻辑流的个别级别上可能需要*流量控制*机制，以减少[*先到线阻塞*](https://en.wikipedia.org/wiki/Head-of-line_blocking)效应；大块数据应通过复用连接*分块*传输。特定类型的通信，例如区块链系统中的状态同步，可以从专门的、专业化的通信机制中获益。
- en: Interaction between concurrent components and across levels of abstraction is
    also subject to fine-tuning and optimization. *Prioritization* and flexible *policies*
    can help to maximize performance. For example, the system may perform better when
    certain concurrent tasks or communication paths have higher priority. Internal
    communication, as well as communication between nodes, may be optimized through
    prioritization and retention policies applied to individual messages or kinds
    of messages. This sort of optimization requires deep understanding of the protocol
    and its inner workings.
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: 并发组件之间以及跨抽象级别的交互也是微调和优化的对象。*优先级*和灵活的*策略*可以帮助最大化性能。例如，当某些并发任务或通信路径具有较高优先级时，系统可能表现更佳。内部通信以及节点之间的通信可以通过应用于单个消息或消息类型的优先级和保留策略进行优化。这种优化要求深入理解协议及其内部运作方式。
- en: Expensive low-level operations, such as spawning threads, blocking on locks,
    and copying data, can become a hidden cause of suboptimal performance. There are
    well-known techniques that can help to avoid unnecessary low-level overhead. For
    example, [*execution pools*](https://en.wikipedia.org/wiki/Thread_pool) avoid
    the overhead associated with creation and destruction of threads for executing
    short-lived concurrent tasks; [*non-blocking algorithms*](https://en.wikipedia.org/wiki/Non-blocking_algorithm)
    can improve performance by avoiding unnecessary suspension of thread execution;
    [*zero-copy*](https://en.wikipedia.org/wiki/Zero-copy) techniques focus on eliminating
    excessive copying of data.
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
  zh: 昂贵的低级操作，如线程创建、锁定阻塞和数据复制，可能成为性能亚优化的隐性原因。有众所周知的技术可以帮助避免不必要的低级开销。例如，[*执行池*](https://en.wikipedia.org/wiki/Thread_pool)避免了为执行短期并发任务创建和销毁线程的开销；[*非阻塞算法*](https://en.wikipedia.org/wiki/Non-blocking_algorithm)可以通过避免不必要的线程挂起来提高性能；[*零拷贝*](https://en.wikipedia.org/wiki/Zero-copy)技术专注于消除数据过度复制。
- en: Improving performance characteristics of distributed systems may require nontrivial
    changes in the underlying protocols and their implementations. The structure of
    the code should be flexible enough to support such changes. Some optimizations
    can be confined within boundaries of abstract components, whereas some may require
    crossing the borders of modularity. *Flexible* and *composable* primitives and
    interfaces *designed for optimization* would help to fully realize the potential
    of distributed systems in practice.
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: 改进分布式系统的性能特征可能需要对底层协议及其实现进行非平凡的更改。代码结构应具有足够的灵活性以支持这些更改。一些优化可以限制在抽象组件的边界内，而有些可能需要跨越模块化的边界。*灵活*和*可组合*的原语和接口*设计用于优化*，有助于充分实现分布式系统在实践中的潜力。
- en: Correctness[​](#correctness "Direct link to Correctness")
  id: totrans-split-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确性[​](#correctness "Direct link to Correctness")
- en: Correctness is absolutely essential for implementation of distributed fault-tolerant
    protocols since they are critical for ensuring reliability of the whole system.
    [*Formal verification*](https://en.wikipedia.org/wiki/Formal_verification) methods
    allow confirming protocol correctness in terms of desired properties. Applying
    those methods requires that the protocol is described precisely with a [*formal
    specification*](https://en.wikipedia.org/wiki/Formal_specification). Though the
    way protocols are actually implemented in code tends to be significantly different
    from the notation used in protocol specifications. This discrepancy is clearly
    a potential source of errors. There are different methods that can help to acquire
    higher confidence in correctness of the protocol implementation.
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施分布式容错协议中，正确性是绝对必要的，因为它们对整个系统的可靠性至关重要。[*形式验证*](https://en.wikipedia.org/wiki/Formal_verification)方法允许在所需属性的术语中确认协议的正确性。应用这些方法需要协议被精确地描述为[*形式规范*](https://en.wikipedia.org/wiki/Formal_specification)。尽管协议实际在代码中的实现方式往往与协议规范中使用的符号显著不同，这种不一致显然是错误的潜在来源。有不同的方法可以帮助获得对协议实施正确性更高的信心。
- en: Testing is an established practice to examine correctness of software. Comprehensive
    testing of complex systems happens at different levels, and modularity of the
    code supports more effective testing by isolating functionalities, enabling independent
    unit testing, simplifying integration testing, and promoting code reuse. Some
    code bases include *dedicated interfaces* and *hooks* to facilitate testing; [*fail
    points*](https://man.freebsd.org/cgi/man.cgi?query=fail) is a technique that allows
    injecting errors and other behavior at runtime for testing purposes, which is
    used in Aptos and Sui. In Algorand, each component of the hierarchical state machine
    implementing the consensus protocol can perform *pre- and post-condition checks*
    to validate if it conforms to its contract. Most code bases perform diagnostic
    *logging* or *tracing* that can also be useful for testing, e.g. to check invariants
    in property-based testing.
  id: totrans-split-148
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一种用来检查软件正确性的成熟实践。对复杂系统的全面测试发生在不同的级别，而代码的模块化通过隔离功能支持更有效的测试，使独立单元测试成为可能，简化集成测试，并促进代码重用。一些代码库包括*专用接口*和*钩子*以便于测试；[*失败点*](https://man.freebsd.org/cgi/man.cgi?query=fail)是一种允许在运行时注入错误和其他行为以进行测试的技术，这在
    Aptos 和 Sui 中使用。在 Algorand 中，实现共识协议的分层状态机的每个组件可以执行*前置和后置条件检查*，以验证其是否符合其合同。大多数代码库执行诊断*日志记录*或*跟踪*，这对于测试也可能很有用，例如用于检查基于属性的测试中的不变量。
- en: '*Deterministic [discrete-event simulation](https://en.wikipedia.org/wiki/Discrete-event_simulation)*
    is a powerful technique that can be used for performing *randomized* but *reproducible*
    testing. For example, Sui, Apache Kafka, and Cardano employ this technique. It
    works by running the code within a special runtime that supports deterministic,
    randomized execution of concurrent code, as well as faster-than-real-time simulation
    of time delays. This technique can be used to run an entire network in a single
    process, with *simulated network* latency and packet loss. To ensure deterministic
    execution, the simulation approach usually requires that the code is generic over
    the sources of local time and randomness; it can also rely on code instrumentation
    techniques. The key advantage of this approach is that it allows running precisely
    the same code in the simulator for testing as in production.'
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*确定性[离散事件仿真](https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BA%8B%E4%BB%B6%E4%BB%BF%E7%9C%9F)*是一种强大的技术，可用于执行*随机化*但*可复现*的测试。例如，Sui、Apache
    Kafka 和 Cardano 都采用了这种技术。它通过在支持确定性、随机执行并发代码以及超过实时时间延迟模拟的特殊运行时中运行代码来实现。该技术可用于在单个进程中运行整个网络，模拟网络延迟和数据包丢失。为了确保确定性执行，仿真方法通常要求代码对本地时间和随机性源是通用的；它还可以依赖于代码仪器技术。这种方法的关键优势在于，它允许在测试模拟器中精确地运行与生产中相同的代码。'
- en: Certain correctness properties of code can be ensured statically, i.e. at compile
    time. Those checks rely on the programming language's type system. Software engineers
    can take advantage of *type safety* features to implement components in a way
    that makes them *safe by construction*. For example, Cardano uses the [`typed-protocols`](https://github.com/input-output-hk/typed-protocols/tree/typed-protocols-0.1.0.5) package,
    a generic framework for implementing application-level protocols, which is based
    on a simple form of [session typing](https://en.wikipedia.org/wiki/Session_type).^([6](#user-content-fn-typed-protocols-talk-d8d72b))
    Within this framework, protocols are described as state machines encoded into
    Haskell types. The allowed transitions between states correspond to messages exchanged
    between the peers, so the protocol state determines which messages are allowed
    to be sent or must be accepted when received, at type level. This simplifies protocol
    implementation, allows early detection of protocol violations, and makes the protocols
    themselves deadlock-free by construction. More advanced type-level programming
    techniques may allow achieving impressive levels of type safety; however, such
    code may be significantly harder to implement, understand, and maintain.
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的某些正确性属性可以在静态情况下，即在编译时确保。这些检查依赖于编程语言的类型系统。软件工程师可以利用*类型安全*功能来实现组件，使它们在*构建时安全*。例如，Cardano使用了[`typed-protocols`](https://github.com/input-output-hk/typed-protocols/tree/typed-protocols-0.1.0.5)包，这是一个用于实现应用级协议的通用框架，其基于一种简单的形式的[会话类型](https://en.wikipedia.org/wiki/Session_type).^([6](#user-content-fn-typed-protocols-talk-d8d72b))
    在这个框架中，协议被描述为编码到Haskell类型中的状态机。允许的状态之间的转换对应于对等体之间交换的消息，因此协议状态确定了允许发送或在接收时必须接受的消息，在类型级别上。这简化了协议的实现，允许早期检测到协议违规，并通过构建使协议本身无死锁。更高级的类型级编程技术可能允许达到令人印象深刻的类型安全水平；然而，这样的代码可能会更难以实现、理解和维护。
- en: Ensuring correctness in distributed systems is a complex task. Protocols and
    their properties can be formally specified and verified. Expressing the protocol
    specification and its implementation using possibly similar notations could help
    to ensure equivalence between the two. Modular and generic structure of code,
    as well as using various testing support features within the code base, support
    more effective testing. Supporting deterministic discrete-event simulation is
    particularly powerful for reproducible randomized testing. Finally, type safety
    techniques like session types and typestates can eliminate certain kinds of programming
    errors at compile time.
  id: totrans-split-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中确保正确性是一个复杂的任务。协议及其属性可以被正式指定和验证。使用可能类似的符号表达协议规范及其实现可以帮助确保两者之间的等价性。代码的模块化和通用结构，以及在代码库中使用各种测试支持特性，支持更有效的测试。支持确定性离散事件模拟对于可重复的随机测试特别有效。最后，像会话类型和类型状态这样的类型安全技术可以在编译时消除某些类型的编程错误。
- en: Resource Utilization[​](#resource-utilization "Direct link to Resource Utilization")
  id: totrans-split-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[资源利用](#resource-utilization "Direct link to Resource Utilization")'
- en: Real computing systems are fundamentally bounded in the amount of available
    resources. Computers operate with limited computational power, memory, storage,
    and network bandwidth. Operating systems impose further limits on such system
    resources as threads, open network connections, file handles, etc. Practical systems
    are required to prevent [resource leaks](https://en.wikipedia.org/wiki/Resource_leak),
    as well as to ensure fair and efficient utilization of available resources.
  id: totrans-split-153
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的计算系统在可用资源方面基本上是有限的。计算机具有有限的计算能力、内存、存储和网络带宽。操作系统对系统资源（如线程、打开的网络连接、文件句柄等）施加进一步限制。实际系统需要防止[资源泄漏](https://en.wikipedia.org/wiki/Resource_leak)，同时确保公平有效地利用可用资源。
- en: Some resources, such as allocated memory, open file handles and network connections,
    spawned concurrent tasks and threads, may require explicit actions to release
    them properly when they are no longer needed. Failing to release resources promptly
    is known as a resource leak. It can cause [resource starvation](https://en.wikipedia.org/wiki/Resource_starvation),
    slowdowns, and instability in the system. Relying on explicit releasing of acquired
    resources is known to be error-prone. Automatically releasing resources based
    on *lifetimes* and *lexical scopes* is a more robust form of [resource management](https://en.wikipedia.org/wiki/Resource_management_(computing)).
    Sometimes the encompassing lexical scope's lifetime is longer than the resource's
    natural life cycle, e.g. when managing concurrent tasks, so that strict lexical
    scoping becomes inappropriate. In such cases, resources may be managed more explicitly
    within the scope, but with a fallback mechanism to track resources and ensure
    that any remaining resource gets released when leaving the scope.^([7](#user-content-fn-cardano-resource-registry-d8d72b))
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有些资源，如分配的内存、打开的文件句柄和网络连接、生成的并发任务和线程，在不再需要时可能需要显式操作来正确释放它们。未能及时释放资源被称为资源泄漏。这可能导致系统出现[资源匮乏](https://en.wikipedia.org/wiki/Resource_starvation)，减慢速度并导致不稳定性。依赖显式释放已获取资源已知容易出错。根据*生命周期*和*词法作用域*自动释放资源是一种更健壮的形式的[资源管理](https://en.wikipedia.org/wiki/Resource_management_(computing))。有时包围的词法作用域生命周期比资源的自然生命周期长，例如在管理并发任务时，因此严格的词法作用域变得不合适。在这种情况下，资源可能更多地在作用域内显式管理，但带有回退机制以跟踪资源，并确保离开作用域时释放任何剩余资源。^([7](#user-content-fn-cardano-resource-registry-d8d72b))
- en: Concurrency often makes resource management more challenging. First of all,
    concurrent tasks running in background is a kind of resource that needs to be
    released when no longer needed. Moreover, they can acquire other resources that
    should be released when the task is terminated, even in case of asynchronous cancellation.
    In simple cases, there is a limited number of long-running concurrent tasks, which
    are responsible for releasing the resources acquired by them, and their termination
    is synchronized with the main task; short-living jobs can run concurrently on
    execution pools that distribute those jobs among a number of long-running concurrent
    tasks. When more flexibility is desired, [*structured concurrency*](https://en.wikipedia.org/wiki/Structured_concurrency)
    can help managing concurrent code in a more organized and predictable manner by
    organizing concurrent tasks into a structured hierarchy with well-defined scopes
    and lifetimes.^([8](#user-content-fn-notes-on-structured-concurrency-d8d72b))
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: 并发通常使资源管理更具挑战性。首先，后台运行的并发任务是一种在不再需要时需要释放的资源。此外，它们可能获取其他资源，应在任务终止时释放，即使在异步取消的情况下也是如此。在简单情况下，有一定数量的长时间运行的并发任务负责释放它们所获取的资源，并且它们的终止与主任务同步；短暂的作业可以在执行池中并发运行，该池将这些作业分发给多个长时间运行的并发任务。当需要更大的灵活性时，[*结构化并发*](https://en.wikipedia.org/wiki/Structured_concurrency)可以通过将并发任务组织成结构化层次，具有定义良好的作用域和生命周期，以更有组织和可预测的方式来管理并发代码。^([8](#user-content-fn-notes-on-structured-concurrency-d8d72b))
- en: Individual parts of a distributed system may operate at different pace. Moreover,
    for performance reasons, it is common to apply pipelining techniques when communicating
    with remote nodes, i.e. proceed without waiting for a response or acknowledgement
    form the remote node in order to hide network latency. Compensating for the delays
    and variability in throughput demands some kind of explicit or implicit buffering,
    e.g. buffered channels, send/receive queues, pending request trackers, out-of-context
    message buffers, etc. The amount of buffered state tends to grow under certain
    conditions, e.g. under heavy load or during network instability. Therefore, there
    should be some mechanisms to prevent *unbounded growth of state* without compromising
    liveness. That can be such mechanisms as backpressure, rate limiting, item expiration
    and eviction policies, etc.
  id: totrans-split-156
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统的各个部分可能以不同的速度运行。此外，出于性能原因，在与远程节点通信时通常会应用流水线技术，即不等待远程节点的响应或确认。为了补偿延迟和吞吐量的变化，需要某种显式或隐式的缓冲，例如缓冲通道、发送/接收队列、待处理请求跟踪器、上下文外消息缓冲等。在某些条件下，例如在负载较重或网络不稳定时，缓冲状态的数量往往会增长。因此，应该有一些机制来防止*状态的无限增长*而不会影响活动性。这些机制可以是反压力、速率限制、项目过期和逐出策略等。
- en: In adversarial environments, potential DoS attacks through *resource exhaustion*
    is a major threat. An adversary may attempt to exhaust node's resources, such
    as network bandwidth, memory and computational capacity. In order to effectively
    mitigate such attacks, they should be prohibitively expensive for the attacker
    relative to the amount of resource consumed from honest participants. *Early detection
    of protocol violations* and *consumer-driven data flow*, as employed in Cardano,
    can reduce the amount of resources expended by the nodes under attack. It may
    also be useful to tack resource expenditure caused by processing messages from
    remote peers, as done in Avalanche, and apply *fair throttling* to communication
    channels.
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在对抗环境中，通过*资源耗尽*进行潜在的 DoS 攻击是一个主要威胁。对手可能会试图耗尽节点的资源，如网络带宽、内存和计算能力。为了有效地减轻这种攻击，对手应该相对于从诚实参与者那里消耗的资源来说是极为昂贵的。*早期检测协议违规*和*消费者驱动的数据流*，如
    Cardano 所采用的方式，可以减少受攻击节点消耗的资源量。对处理来自远程对等体消息所导致的资源消耗进行跟踪，如 Avalanche 所做的，以及对通信通道应用*公平节流*也可能是有用的。
- en: Proper resource management is indispensable in long-running systems. It can
    be particularly challenging combined with concurrency. Reliable resource management
    approaches, e.g. based on lifetimes and lexical scopes, as well as structured
    concurrency, should be, when applicable, preferred to relying on explicit hand-coded
    releasing of acquired resources. Potential growth of state due to buffering requires
    mechanisms for ensuring bounded memory usage. Resource exhaustion attacks should
    be anticipated in adversarial environments and mitigated by minimizing their impact
    on honest nodes.
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在长期运行的系统中，适当的资源管理是必不可少的。与并发结合可能尤其具有挑战性。可靠的资源管理方法，例如基于生命周期和词法范围，以及结构化并发，在适用时应优先于依赖显式手动释放获取的资源。由于缓冲而导致状态增长的潜在问题，需要机制来确保有限的内存使用。在对抗环境中应预期资源耗尽攻击，并通过最小化其对诚实节点的影响来减轻这些攻击的影响。
- en: Maintainability[​](#maintainability "Direct link to Maintainability")
  id: totrans-split-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[可维护性](#maintainability "直达可维护性")'
- en: Maintenance of distributed systems is challenging. Those systems are usually
    long-running critical parts of infrastructure with high reliability requirements.
    They are complex systems consisting of multiple nodes, often operated independently
    by different entities. Publicly available deployments are also subject to malicious
    attacks. Thus effective maintenance of distributed systems demands comprehensive
    mechanisms and tools.
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
  zh: 维护分布式系统具有挑战性。这些系统通常是基础设施的长期关键部分，具有高可靠性要求。它们是由多个节点组成的复杂系统，通常由不同实体独立操作。公开可用的部署也容易受到恶意攻击。因此，有效维护分布式系统需要全面的机制和工具。
- en: First of all, deploying distributed systems may require specific *bootstrapping*
    procedures in order to ensure a secure setup for the whole system. Different distributed
    protocols may have different requirements and rely on different assumptions for
    the *setup phase*.^([9](#user-content-fn-decentralized-setup-assumptions-d8d72b))
    Protocol implementations should be clear about the requirements and assumptions
    for their setup phase. Long-running, highly available distributed systems should
    be capable of *upgrading* individual nodes with newer versions of the protocol
    implementation without disrupting the whole system. This requires designing for
    *backward and forward compatibility*. Similarly, failed nodes should be able to
    *recover* and *rejoin* the system safely and efficiently. Moreover, it is also
    desired that the system is able to safely recover from a massive crash, i.e. provide
    [durability](https://en.wikipedia.org/wiki/Durability_(database_systems)). Therefore,
    the protocols should be designed and implemented with a clear recovery procedure.
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，部署分布式系统可能需要特定的*引导*程序，以确保整个系统的安全设置。不同的分布式协议可能对*设置阶段*有不同的要求，并依赖于不同的假设。协议实现应明确其设置阶段的要求和假设。长时间运行的、高可用的分布式系统应能够升级个别节点到协议实现的更新版本，而不会中断整个系统。这要求设计具备*向后和向前兼容性*。类似地，失败的节点应能够安全、高效地*恢复*并*重新加入*系统。此外，系统应能够安全地从大规模崩溃中恢复，即提供[持久性](https://en.wikipedia.org/wiki/Durability_(database_systems))。因此，协议应设计和实现具备明确的恢复过程。
- en: Distributed system administrators need mechanisms and tools for monitoring individual
    nodes in order to analyze the system and promptly detect anomalies. Developers
    also need effective mechanisms for analyzing, diagnosing issues, and identifying
    bugs in protocol implementations. *Logging*, *tracing*, and collecting *metrics*
    are common *observability* techniques to allow monitoring and obtaining diagnostic
    information from the system; most of the explored code bases use these techniques.
    [OpenTelemetry](https://opentelemetry.io/) and [Prometheus](https://prometheus.io/)
    are popular open-source monitoring solutions, which are used in many of the explored
    code bases.
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统管理员需要监视各个节点的机制和工具，以分析系统并及时检测异常。开发人员还需要有效的机制来分析、诊断问题，并识别协议实现中的错误。*日志*、*追踪*和收集*指标*是常见的*可观察性*技术，允许从系统中监视并获取诊断信息；大多数探索的代码库都使用这些技术。[OpenTelemetry](https://opentelemetry.io/)和[Prometheus](https://prometheus.io/)是流行的开源监控解决方案，广泛应用于许多探索的代码库中。
- en: Diagnostic logging typically refers to emitting and recording chronological
    *textual* messages that capture important events happening during the execution
    of software. Messages in diagnostic logs are traditionally assigned a severity
    level that can be used to disable logging of messages below a certain severity
    level, e.g. debug messages. Log messages can support addition of structured data
    along with a formatted text message, e.g. key-value context fields. Logging can
    be organized hierarchically, reflecting the structure of components within the
    system. Messages in *hierarchical logging* are usually automatically enriched
    with context from higher-level components.
  id: totrans-split-163
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断日志通常指的是发出和记录*文本*消息的过程，这些消息按时间顺序记录了软件执行过程中发生的重要事件。诊断日志中的消息通常分配了严重程度级别，可以用于禁止记录低于某一严重程度级别的消息，例如调试消息。日志消息可以支持在格式化文本消息中添加结构化数据，例如键-值上下文字段。日志可以按层次结构组织，反映系统中组件的结构。*分层日志*中的消息通常会自动从更高级别的组件中获取上下文信息。
- en: Tracing is somewhat similar to logging, but it is focused on capturing a detailed
    view of the flow of execution in the system. Tracing records are primarily *structured*
    rather than textual and reflect *causal relationships*. In particular, *distributed
    tracing* is tracking of events caused by processing individual logical operations,
    such as user requests or transactions, across different components of a distributed
    system. A distributed trace is associated with a single logical operation and
    consists of spans linked with causal relationships where each span represents
    a particular activity within the operation. Spans normally contain structured
    data describing the corresponding activity and timing information.
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪与日志记录有些类似，但它侧重于捕获系统执行流的详细视图。跟踪记录主要是*结构化*而不是文本，反映*因果关系*。特别是*分布式跟踪*是跟踪由处理单个逻辑操作（如用户请求或事务）引起的事件，跨分布式系统的不同组件。分布式追踪与单个逻辑操作相关联，由因果关系链接的跨度组成，每个跨度表示操作中的特定活动。跨度通常包含描述相应活动和时间信息的结构化数据。
- en: Metrics represent numeric measurements that describe the system's behavior over
    time. Metrics are typically collected and aggregated at regular intervals. They
    can include various types of information such as CPU and memory utilization, latency,
    error rates, throughput, queue lengths, etc. There are different kinds or metrics;
    the most widely used are counter, gauge, and histogram. A counter is a cumulative
    metric monotonically increasing over time; a gauge expresses the current value
    of some measurement; a histogram records sampled observations in a statistical
    representation.
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
  zh: 指标代表随时间描述系统行为的数值测量。指标通常定期收集和聚合。它们可以包括各种类型的信息，如 CPU 和内存利用率、延迟、错误率、吞吐量、队列长度等。有不同类型的指标；最常用的是计数器、测量器和直方图。计数器是随时间累积增加的累积指标；测量器表示某些测量的当前值；直方图记录了统计表征中的采样观测数据。
- en: Observability is a [cross-cutting concern](https://en.wikipedia.org/wiki/Cross-cutting_concern
    "Cross-cutting concern"). Most implementations define abstract interfaces for
    logging, tracing, and capturing metrics and require them as dependency across
    components; some use code instrumentation techniques. Cardano uses an interesting
    approach to implement observability features, called *contravariant tracing*,
    in which domain-specific values are provided to domain-agnostic processors. The
    [contravariance](https://en.wikipedia.org/wiki/Functor#Covariance_and_contravariance)
    property allows domain-agnostic tracers to be adapted and stand in where a domain-specific
    tracer is required. This discourages using textual encoding for diagnostic logging/tracing
    in favor of dedicated domain-specific event types. Contravariant tracing can also
    be used to collect metrics.
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性是一种[横切关注点](https://en.wikipedia.org/wiki/Cross-cutting_concern "Cross-cutting
    concern")。大多数实现定义了日志记录、跟踪和捕获指标的抽象接口，并要求它们作为组件之间的依赖；有些使用代码仪器技术。Cardano 使用了一种有趣的方法来实现可观察性特性，称为*反变跟踪*，其中将特定于域的值提供给域不可知的处理器。[反变性](https://en.wikipedia.org/wiki/Functor#Covariance_and_contravariance)属性允许域不可知的跟踪器被适应并代替需要特定于域的跟踪器。这种方法鼓励使用专门的领域特定事件类型而不是文本编码进行诊断日志记录/跟踪。反变跟踪还可以用于收集指标。
- en: Detailed logging and tracing can add significant overhead. When logging a large
    amount of diagnostic data is expensive, logging can be *sampled*, producing only
    a subset of the total messages based on a predetermined sampling rate or criteria.
    The contravariant tracing incurs zero runtime cost if the program is compiled
    with tracing disabled; this is possible even when dealing with a tracer which
    ignores only certain types of events.
  id: totrans-split-167
  prefs: []
  type: TYPE_NORMAL
  zh: 详细的日志记录和跟踪可能会增加显著的开销。当记录大量诊断数据昂贵时，可以进行*采样*日志记录，根据预定的采样率或标准，仅产生总消息的子集。如果程序编译时禁用了跟踪，反变跟踪将不会产生任何运行时成本；即使在处理只忽略某些类型事件的跟踪器时，这也是可能的。
- en: Fault-tolerant distributed protocols should be designed and implemented with
    clear bootstrapping, upgrading, and recovery procedures. Note that upgradability
    relies on backward and forward compatibility of the implementation. It is also
    worth considering the durability feature, i.e. the ability to safely recover the
    system from a massive crash. There should be seamless support for usual observability
    and diagnostic mechanisms.
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: 容错分布式协议应设计并实施清晰的引导、升级和恢复程序。请注意，可升级性依赖于实现的向后和向前兼容性。还应考虑耐久性特性，即安全地从大规模崩溃中恢复系统的能力。应该无缝支持常规的可观察性和诊断机制。
- en: Flexibility[​](#flexibility "Direct link to Flexibility")
  id: totrans-split-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活性[​](#flexibility "直接链接到灵活性")
- en: Flexible software is able to adapt to changing requirements without having to
    undergo extensive restructuring. Flexibility is crucial for *adoption*, *reuse*,
    and *evolution* of code. Each explicit or implicit *assumption* or *requirement*
    imposed on how the code can be used is an additional *constraint* reducing flexibility.
    The explored code bases were primarily meant to implement particular protocols
    or serve specific purposes rather than to address fundamental needs for implementing
    distributed systems in general. This is a common approach to building software,
    but it tends to result in rather limited flexibility of the code.
  id: totrans-split-170
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活的软件能够在不需进行广泛重构的情况下适应变化的需求。灵活性对于代码的*采用*、*重用*和*演变*至关重要。对代码使用方式施加的每一个显式或隐式的*假设*或*要求*都是降低灵活性的额外*约束*。探索的代码库主要用于实现特定协议或服务特定目的，而不是解决一般分布式系统实现的基本需求。这是构建软件的常见方法，但往往导致代码的灵活性相对有限。
- en: In general, highly *modular* and *composable* code is also more flexible. Clear
    [*separation of concerns*](https://en.wikipedia.org/wiki/Separation_of_concerns)
    through abstract interfaces and [dependency inversion](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
    contributes to flexibility by enabling interchangeable components, as well as
    facilitating easier code modifications and extensions. Flexibility can also be
    enhanced with *generic* and *configurable* components. [*Generic programming*](https://en.wikipedia.org/wiki/Generic_programming)
    techniques, such as [parametric polymorphism](https://en.wikipedia.org/wiki/Parametric_polymorphism
    "Parametric polymorphism"), encourage the development of more generic and adaptable
    components that can be used in different contexts without modification.
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，高度*模块化*和*可组合*的代码也更加灵活。通过抽象接口和[依赖反转](https://en.wikipedia.org/wiki/Dependency_inversion_principle)清晰地进行*关注点分离*有助于通过启用可互换的组件以及促进更容易的代码修改和扩展来增强灵活性。*泛型*和*可配置*的组件也可以增强灵活性。[*泛型编程*](https://en.wikipedia.org/wiki/Generic_programming)技术，例如 [参数多态](https://en.wikipedia.org/wiki/Parametric_polymorphism
    "参数多态")，鼓励开发更通用和适应性更强的组件，可以在不同的上下文中使用而无需修改。
- en: The ability to seamlessly integrate into larger systems is another aspect of
    flexibility required for adoption and reuse of protocol implementations. Since
    larger systems may opt for different programming languages and runtime environments,
    it is important to support interfacing with other languages and impose minimal
    runtime requirements. Rust is particularly suitable to implement robust software
    components for integrating into other languages and environments due to its rich
    language features, zero-cost abstractions, predictable performance, safe memory
    management without a garbage collector, and the ability to use custom concurrency
    runtimes.
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
  zh: 无缝集成到更大系统的能力是灵活性的另一个方面，这对于采用和重用协议实现至关重要。由于较大的系统可能选择不同的编程语言和运行时环境，因此支持与其他语言的接口和施加最小的运行时要求是非常重要的。Rust特别适合实现强大的软件组件，以便集成到其他语言和环境中，因为它具有丰富的语言特性、零成本抽象、可预测的性能、无需垃圾收集器的安全内存管理以及使用自定义并发运行时的能力。
- en: Designing for flexibility promotes adoption, reuse, and evolution of code. Following
    this approach should be a deliberate choice from the beginning. Avoiding strong
    constraints, assumptions, and requirements, aiming at modularity and composability
    with generic and configurable components make for greater flexibility.
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
  zh: 设计灵活性促进了代码的采用、重用和演变。从一开始遵循这种方法应该是一个深思熟虑的选择。避免强约束、假设和要求，以模块化和可组合的泛型和可配置的组件来增强灵活性。
- en: Conclusions[​](#conclusions "Direct link to Conclusions")
  id: totrans-split-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论[​](#conclusions "直接链接到结论")
- en: I learned a lot while exploring those 14 code bases. I have acquired a much
    deeper understanding of what is important for a practical distributed protocol
    implementation and what are the typical challenges there. I have seen different
    approaches in use and discovered some interesting ideas and techniques scattered
    around. Though I find the ways distributed protocols are implemented quite unsatisfactory.
    Even for an engineer experienced in implementing this kind of protocols, most
    of the the code bases were fairly hard to comprehend and follow. I can imagine
    how much effort it took and how painful was it to first make them work, as well
    as to improve them later.
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我在探索那些 14 个代码库的过程中学到了很多。我对实际分布式协议实现中的重要内容和典型挑战有了更深入的理解。我看到了不同的应用方法，并发现了一些分散在各处的有趣思想和技术。尽管我觉得分布式协议的实现方式相当令人不满意。即使对于一个有经验的协议实现工程师来说，大多数代码库也很难理解和跟踪。我可以想象，要让它们首次运行以及后续改进都需要花费多少精力和痛苦。
- en: Status Quo[​](#status-quo "Direct link to Status Quo")
  id: totrans-split-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[现状](#status-quo "Status Quo 的直接链接")'
- en: Most of the time, it was rather hard to follow the main protocol, its causal
    dependencies and logical connections in the code that was presumably structured
    focusing on the operational aspects, fragmented, entangled, and cluttered. Structuring
    the protocol implementation directly around simplistic communication mechanisms
    foregoing reliable and ordered delivery guarantees provided by the transport layers,
    expressing concurrency and synchronization explicitly in terms of low-level mechanisms
    based on shared mutable memory and lock-based primitives or attempting to evade
    concurrency in favor of sequential state machines, all seem to cause fragmentation
    of the protocol logic across the code base, shift the focus towards operational
    technicalities, and incur cluttering of the code with boilerplate and hand-coded
    flow control, context switching, resource management, etc. Invasive ad hoc optimizations,
    patches, and cross-cutting concerns also contribute to muddling the code. Often
    insufficient modularity, unclear structure, excessive coupling, and abundance
    of mutable state complicate the matter further. Using sophisticated techniques
    and lack of inline documentation present additional obstacles for understanding.
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，很难跟踪主协议、其因果依赖关系和代码中的逻辑连接。代码的结构看似专注于操作方面，但却是碎片化、交织在一起、凌乱的。直接围绕简单的通信机制构建协议实现，放弃传输层提供的可靠和有序的传递保证，并显式表达并发和同步，基于共享可变内存和基于锁的原语来处理低级机制，或者试图避免并发以支持顺序状态机，似乎都导致了协议逻辑在代码库中的分散，将注意力转向操作技术细节，并在代码中添加样板和手工编码的流控制、上下文切换、资源管理等。侵入式的临时优化、补丁和横切关注点也导致代码混乱。通常存在模块化不足、结构不清晰、耦合度过高和大量可变状态的问题，这进一步复杂化了问题。使用复杂技术和缺乏内联文档还增加了理解的障碍。
- en: It seems barely possible to fully convince oneself that the majority of the
    implementations actually correspond closely to the original protocol and guarantee
    the claimed properties under unfavorable conditions. The way the protocols are
    expressed in code does not appear anything like formal specification. The ever-present
    possibility of such subtle issues as race conditions, deadlocks, resource starvation,
    and, in some languages, data races manifesting themselves in such complicated
    code bases does not add more confidence. Unconstrained nondeterminism and abundance
    of non-local operations result in state space explosion, making rigorous test-based
    verification infeasible. Only a few of the implementations support reproducible
    testing with deterministic discrete-event simulation of unmodified code.
  id: totrans-split-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全说服自己，大多数实现实际上与原始协议密切对应并在不利条件下保证所声明的属性几乎是不可能的。协议在代码中的表达与形式化规范毫不相似。如此复杂的代码库中存在着诸如竞态条件、死锁、资源匮乏以及在某些语言中数据竞争等微妙问题的可能性时刻存在，并且这并没有增加更多的信心。不受限的非确定性和大量的非本地操作导致状态空间膨胀，使得基于严格测试的验证变得不可行。只有少数实现支持使用非修改代码的确定性离散事件模拟进行可重现测试。
- en: It also seems unclear how many of the implementations would behave under certain
    high load conditions, e.g. under a denial-of-service attack. Protocol violations
    are not always optimally detected at early stages of processing incoming data;
    many implementations lack mechanisms for propagating information about detected
    anomalies towards lower communication layers in order to restrict communication
    with offending nodes. The majority of the implementations employ the push style
    of communication and forgo flow control mechanisms of transport layers, so individual
    remote nodes can potentially send arbitrary amounts of data that the receiving
    node has to deal with in time. Uncomfortably often there are unbounded buffers
    and queues with unclear mechanisms that could control growth of state. Unreliable
    explicit hand-coded resource management could cause resource leaks, including
    concurrent tasks dangling in background.
  id: totrans-split-179
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎也不清楚在某些高负载条件下，例如在拒绝服务攻击下，多少实现会如何行为。在处理传入数据的早期阶段，协议违规并非总是被最优地检测出来；许多实现缺乏传播检测到异常信息到较低通信层的机制，以限制与有问题节点的通信。大多数实现采用推送式通信，并放弃传输层的流量控制机制，因此单个远程节点有可能发送接收节点需要及时处理的任意量数据。不适当地频繁出现未限制增长状态的无界缓冲区和队列，以及不明确的控制机制可能导致不可靠的显式手动资源管理，包括后台悬挂的并发任务造成资源泄露。
- en: In terms of observability, most of the protocol implementations rely on simple
    logging with context fields and collect various metrics. However, this may not
    provide enough details and context for effective debugging and analysis of the
    protocol execution.
  id: totrans-split-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就可观察性而言，大多数协议实现依赖带有上下文字段的简单日志记录和收集各种指标。然而，这可能无法为有效调试和分析协议执行提供足够的细节和背景信息。
- en: The explored code bases are quite specific to particular protocols, execution
    environments, and use cases. Modularity there is rather coarse and most of the
    components are not meant to be reused or recombined; tight coupling is also not
    rare. This harms adaptability and reusability of the code, making it inflexible.
  id: totrans-split-181
  prefs: []
  type: TYPE_NORMAL
  zh: 探索过的代码库非常专注于特定的协议、执行环境和使用案例。模块化程度相对较粗，大多数组件并非用于重用或重新组合；紧密耦合也并不少见。这损害了代码的适应性和可重用性，使其显得不灵活。
- en: We Can Do Better[​](#we-can-do-better "Direct link to We Can Do Better")
  id: totrans-split-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[我们可以做得更好](#we-can-do-better "直达我们可以做得更好")'
- en: I think we can do much better. I think we should not waste our efforts reinventing
    the wheel over and over again and repeating mistakes. Builders better focus on
    implementing the functionality specific to their solutions without having to figure
    out how to approach implementing the tricky but critically important distributed
    protocols. There should be a framework that solves the problem of implementing
    distributed protocols once and for all, a framework reach with easy-to-use, reliable
    primitives and components that can be taken as is or mixed and matched as needed,
    a framework that guides towards robust and understandable code, a framework that
    supports analyzing, monitoring, testing, and debugging protocol implementations,
    a framework that is reasonably efficient and can be easily integrated into various
    environments.
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们可以做得更好。我认为我们不应该在一遍又一遍地重新发明轮子和重复错误。建造者应更专注于实现其解决方案特定的功能，而无需考虑如何实现复杂但至关重要的分布式协议。应该有一个框架来一劳永逸地解决实现分布式协议的问题，一个框架，里面有易于使用的可靠基本单元和组件，可以按原样使用或根据需要进行混合和匹配，一个引导编写出健壮且易于理解代码的框架，一个支持协议实现分析、监控、测试和调试的框架，一个相对高效且易于集成到各种环境的框架。
- en: The framework should guide away from incidental, non-essential complexity and
    allow expressing protocol implementations in clear and understandable code. Protocol
    implementations should be structured primarily focusing on functional and logical
    aspects with clear separation of concerns, operational technicalities and sophisticated
    techniques possibly hidden behind simple and clearly defined abstractions. Fine
    modularity of reasonably small and simple components expressed in more declarative
    notation with reduced number of non-local operations should facilitate local reasoning.
    Components should have minimal internal state, as well as clearly defined requirements,
    properties, and external dependencies.
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: 框架应该避免次要的、非必要的复杂性，并允许用清晰易懂的代码表达协议实现。协议实现应主要侧重于功能和逻辑方面的结构化，明确区分关注点、操作技术性细节和可能隐藏在简单和明确定义的抽象背后的复杂技术。以更声明式的方式表达的细粒度和简单组件的良好模块化，以减少非局部操作的数量，应有助于局部推理。组件应具有最小的内部状态，并且具有明确定义的要求、属性和外部依赖。
- en: Concurrency requires special attention since it is unavoidable, tricky, and
    can add a great deal of complexity, whereas designing for concurrency can be actually
    advantageous in terms of code structure and modularity. Working with concurrency
    should be possibly safe, easy, and efficient. Low-level concurrency mechanisms,
    such as OS threads, lock-based synchronization primitives, and shared mutable
    memory, should only be used for implementing the internals of higher-level, safer,
    and easier-to-use concurrency mechanisms, such as concurrency runtimes. Expressing
    concurrent parts of the protocol in code should feel as natural as expressing
    sequential ones. This can be achieved with syntactical means, abstractions, and
    a concurrency model that recognizes any causally independent operations as potentially
    concurrent.
  id: totrans-split-185
  prefs: []
  type: TYPE_NORMAL
  zh: 并发性需要特别注意，因为它是不可避免的、棘手的，并且可能会增加大量复杂性，而设计并发性则实际上在代码结构和模块化方面具有优势。处理并发性应该尽可能安全、简单和高效。低级并发机制，如操作系统线程、基于锁的同步原语和共享可变内存，应仅用于实现更高级、更安全和更易于使用的并发性机制的内部，例如并发运行时。在代码中表达协议的并发部分应该与表达顺序部分一样自然。这可以通过语法手段、抽象化和一种并发模型来实现，该模型将任何因果无关操作识别为潜在并发操作。
- en: Since communication interfaces can greatly affect the structure of code built
    around them, we need a range of communication mechanisms with aligned interfaces
    and clearly defined properties. There should be different levels of abstractions
    for communication. Higher levels should take advantage of the properties already
    guaranteed by lower-level layers, such as reliable, ordered communication channels
    with flow control provided by commonly used transport layers. Expressing communication
    in stateful sessions can help to express causal relationship between individual
    messages and greatly simplify protocol implementations. Similarity between internal
    and external communication can suggest better abstractions.
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通信接口可以极大地影响围绕其构建的代码结构，我们需要一系列具有对齐接口和明确定义属性的通信机制。通信机制应具有不同的抽象级别。更高级别的应该利用底层层已保证的属性，例如可靠的、有序的通信通道，以及由常用传输层提供的流量控制。在状态化会话中表达通信可以帮助表达单个消息之间的因果关系，并极大简化协议实现。内部和外部通信的相似性可以建议更好的抽象化。
- en: Flexibility is extremely important to make the framework applicable to an open-ended
    space of use cases. Therefore, we should by all means avoid strong constraints,
    assumptions, and requirements. The framework should support integration with different
    programming languages and runtime environments. Its components should be generic
    and configurable. It should also support backward and forward compatibility. Composability
    is critical for ensuring great adaptability, reusability, and evolvability. It
    requires unified means of abstraction and combination. Generic programming techniques,
    such as parametric polymorphism, can be used to make components generic; functional
    and asynchronous programming techniques can be great sources of ideas for enhancing
    composability, particularly with concurrency.
  id: totrans-split-187
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活性对于使框架适用于开放式用例空间至关重要。因此，我们应该尽一切可能避免强限制、假设和要求。框架应支持与不同的编程语言和运行时环境集成。其组件应该是通用且可配置的。它还应支持向后和向前兼容性。组合性对于确保良好的适应性、可重用性和可演变性至关重要。这需要统一的抽象和组合手段。通用编程技术，如参数多态性，可以用来使组件通用化；功能和异步编程技术可以成为增强组合性的重要思路，特别是在并发情况下。
- en: Correctness of distributed protocol implementations should be verifiable, in
    terms of both safety and liveness properties. Formal verification methods are
    able to provide rigorous assurance about correctness of protocols and their implementations.
    However, since formal verification involves exhaustively analyzing all possible
    states of a system, it may become infeasible for large and complex components.
    Fine modularity, components amenable to local reasoning, as well as reducing the
    number of non-local and nondeterministic operations, can help making formal verification
    more tractable. In order to maintain equivalence between a formally verified protocol
    specification and its implementation in code, the implementation should be expressed
    possibly close to the formal specification, preferably using an identical notation.
    Type safely techniques, such as ownership, typestates, session types, linear and
    uniqueness types, can greatly help to ensure correctness of the code by making
    it virtually safe by construction in terms of certain properties. Hybrid approaches
    combining formal verification with other testing methods can be used to achieve
    decently high assurance about correctness where purely formal methods become infeasible.
    Deterministic discrete-event simulation of unmodified code is a particularly powerful
    technique to complement other verification methods with randomized, reproducible
    testing. Confining nondeterministic aspects behind abstract interfaces in code
    and being able to control nondeterminism during simulation is the key for enabling
    reproducible testing.
  id: totrans-split-188
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式协议实现的正确性应当是可验证的，包括安全性和活性属性。形式化验证方法能够为协议及其实现提供严格的正确性保证。然而，由于形式化验证涉及对系统所有可能状态的详尽分析，对于大型和复杂组件来说可能变得不可行。良好的模块化、适于局部推理的组件，以及减少非局部和非确定性操作的数量，可以帮助使形式化验证更加可行。为了保持在代码中实现的协议规范与其形式化验证规范的等价性，实现应尽可能接近于形式规范，最好使用相同的符号。类型安全技术，如所有权、类型状态、会话类型、线性和唯一类型，可以通过使代码在某些属性上几乎安全构造来极大地帮助确保代码的正确性。混合方法结合形式化验证和其他测试方法，可以在纯粹的形式方法不可行时实现较高的正确性保证。未修改代码的确定性离散事件模拟是一种特别强大的技术，可以通过随机化、可重复测试来补充其他验证方法。将非确定性方面限制在代码的抽象界面之后，并能够在模拟过程中控制非确定性，是实现可重复测试的关键。
- en: Distributed protocols and their implementations should provide strong guarantees
    even under unfavorable conditions, especially those supposed to be deployed in
    adversarial environments. The framework should employ a reliable approach for
    resource management in concurrent code, e.g. based on lifetimes and lexical scopes,
    structured concurrency. There should be mechanisms for flow control preventing
    unlimited growth of state and ensuring bounded memory usage. The framework should
    emphasize threat-aware design. Potential impact of resource exhaustion (DoS) attacks
    should be minimized with early detection of protocol violations and propagating
    information about detected anomalies for maintaining peer reputation metrics and
    taking appropriate measures. For that reason, consumer-driven patterns of communication
    should be preferred. There should also be mechanisms for safe and efficient recovery
    of failed nodes from persistent storage. Supporting durability, i.e. safe recovery
    after a massive system crash, is also desirable.
  id: totrans-split-189
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式协议及其实现应在不利条件下提供强大的保证，特别是在敌对环境中部署的协议。框架应在并发代码的资源管理方面采用可靠的方法，例如基于生命周期和词法作用域的结构化并发。应有流控制机制，防止状态无限增长并确保有限的内存使用。框架应强调面向威胁的设计。应尽量减少资源耗尽（DoS）攻击的潜在影响，通过早期检测协议违规并传播检测到的异常信息，以维护对等体声誉指标并采取适当措施。因此，应优先考虑消费者驱动的通信模式。还应提供安全高效地从持久存储中恢复失败节点的机制。支持耐久性，即在大规模系统崩溃后的安全恢复，也是可取的。
- en: Protocols and their implementations should be clear about bootstrapping and
    recovery requirements and procedures. Upgradability requires backward and forward
    compatibility. There should be seamless support for usual observability and diagnostic
    mechanisms, such as logging, tracing, and collecting metrics. It may also be useful
    to provide mechanisms for tracking resource expenditure caused by processing incoming
    data. In place of simple logging with context fields, it seems advantageous supporting
    structured distributed tracing using domain-specific trace event types. This kind
    of tracing could also be suitable for collecting metrics. It is important to minimize
    incurred overhead when tracing is disabled. Code instrumentation can help to avoid
    cluttering code with tracing boilerplate.
  id: totrans-split-190
  prefs: []
  type: TYPE_NORMAL
  zh: 协议及其实现应明确引导和恢复要求与流程。可升级性要求向后和向前兼容性。应无缝支持常见的可观察性和诊断机制，如日志记录、跟踪和收集度量。为了跟踪处理传入数据造成的资源消耗，提供追踪机制也可能很有用。与简单的带上下文字段的日志记录相比，支持使用特定于域的追踪事件类型的结构化分布式跟踪似乎更有优势。这种追踪方式也适用于收集度量。在禁用追踪时，减少产生的开销是很重要的。代码仪器化可以帮助避免在代码中添加跟踪模板。
- en: The framework should provide good performance and support various optimizations,
    such as speculative and on-demand execution, caching, flexible prioritization
    policies. To support protocol-level optimizations, the framework should allow
    expressing complex communication patterns. The communication layer should prevent
    such undesired effects as head-of-line blocking, optimize data flow and take advantage
    of the properties provided by the transport layers. Lightweight user threads and
    non-blocking algorithms allow achieving high concurrency without compromising
    efficiency. Zero-copy techniques can be used to eliminate unnecessary copying
    of data.
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
  zh: 框架应提供良好的性能，并支持各种优化，如推测性执行、按需执行、缓存、灵活的优先级策略。为了支持协议级优化，框架应允许表达复杂的通信模式。通信层应防止诸如先到头阻塞等不良影响，优化数据流并利用传输层提供的属性。轻量级用户线程和非阻塞算法可以实现高并发而不影响效率。零拷贝技术可用于消除不必要的数据复制。
- en: So we need a structured, yet flexible enough, approach guiding away from incidental
    complexity towards understandability, fine modularity, and composability. The
    framework's components should be generic and configurable, allowing local reasoning
    about the implementation. Expressing concurrency and communication abstractions
    should be safe and easy, structured and composable. We should be serious about
    correctness and resilience against unfavorable conditions. The framework should
    also cater for maintenance needs, provide great observability and diagnostic mechanisms.
    It should deliver decent performance and allow for various optimizations.
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一种结构化但足够灵活的方法，引导我们远离偶然复杂性，朝向可理解性、良好的模块化和可组合性。框架的组件应该是通用的和可配置的，允许对实现进行局部推理。表达并发和通信抽象应该是安全且容易的，结构化且可组合的。我们应该严肃对待正确性并对抗不利条件的弹性。框架还应该满足维护需求，提供出色的可观察性和诊断机制。它应该提供良好的性能，并允许各种优化。
- en: Next Steps[​](#next-steps "Direct link to Next Steps")
  id: totrans-split-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Next Steps[​](#next-steps "直接链接到Next Steps")
- en: 'Having explored those implementations of distributed protocol, now it became
    more clear to me what is worth focusing on while developing the Replica_IO framework.
    I define the following key areas of focus:'
  id: totrans-split-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了那些分布式协议的实现之后，现在我对开发Replica_IO框架时值得关注的内容更加清楚了。我确定了以下关键关注领域：
- en: '*simplicity*: making protocol implementations well structured and understandable;'
  id: totrans-split-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简单性*：使协议实现结构良好且易于理解；'
- en: '*flexibility*: keeping the framework adaptable, widely applicable, and evolvable;'
  id: totrans-split-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*灵活性*：保持框架的适应性、广泛适用性和可进化性；'
- en: '*reliability*: ensuring that protocol correctness is verifiable and the implementation
    is resilient;'
  id: totrans-split-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可靠性*：确保协议正确性可验证且实现具有弹性；'
- en: '*efficiency*: allowing for various optimizations and delivering good performance;'
  id: totrans-split-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*效率*：允许各种优化并提供良好的性能；'
- en: '*maintainability*: catering for maintenance needs and providing great diagnostic
    mechanisms.'
  id: totrans-split-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性*：满足维护需求并提供优秀的诊断机制。'
- en: Achieving all of that at once is obviously not realistic. Therefore, the primary
    focus will be initially put on simplicity, flexibility, and reliability, but without
    neglecting the remaining aspects. Of particular interest are the matters of structure
    and notation supporting composability in concurrency and communication mechanisms,
    as well as controlling nondeterminism.
  id: totrans-split-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时实现所有这些显然是不现实的。因此，最初的重点将放在简单性、灵活性和可靠性上，但不会忽视其他方面。尤其感兴趣的是支持并发和通信机制中的结构和符号学支持可组合性，以及控制非确定性。
- en: Exploring distributed protocol implementations was the first phase of the initial
    state-of-the-art exploration. The next step is to select and examine some existing
    frameworks for developing distributed protocols in order to find out how they
    attempt to approach the problem and, perhaps, also discover some interesting techniques
    or ideas employed there. Then there are some potentially related concepts, approaches,
    and techniques worth looking into. The exploration tasks are tracked in the scope
    of [this issue](https://github.com/replica-io/replica-io/issues/7) on GitHub.
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: 探索分布式协议实现是初始状态探索的第一阶段。接下来的步骤是选择并检查一些现有的用于开发分布式协议的框架，以了解它们如何尝试解决问题，也许还可以发现一些有趣的技术或思想。然后还有一些可能相关的概念、方法和技术值得深入研究。这些探索任务在GitHub上的[此问题](https://github.com/replica-io/replica-io/issues/7)的范围内进行跟踪。
- en: Once the initial exploratory stage is over, it will be time to come up with
    key ideas concerning core principles that will guide the process of designing
    and implementing generic components within the framework (milestone [M0.1](https://github.com/replica-io/replica-io/milestone/1)).
    Then those ideas will be developed into clearly formulated concepts (milestone [M0.2](https://github.com/replica-io/replica-io/milestone/2)),
    their feasibility will be verified with code (milestone [M0.3](https://github.com/replica-io/replica-io/milestone/3)).
    After that, prototype, MVP, and production versions of the framework will be developed
    and released (milestones  [M1](https://github.com/replica-io/replica-io/milestone/4),
     [M2](https://github.com/replica-io/replica-io/milestone/5), and  [M3](https://github.com/replica-io/replica-io/milestone/6)).
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始的探索阶段结束，就会是提出关于核心原则的关键想法的时候，这些想法将指导在框架内设计和实现通用组件的过程（里程碑 [M0.1](https://github.com/replica-io/replica-io/milestone/1)）。然后这些想法将被发展成明确的概念（里程碑
    [M0.2](https://github.com/replica-io/replica-io/milestone/2)），它们的可行性将通过代码进行验证（里程碑
    [M0.3](https://github.com/replica-io/replica-io/milestone/3)）。之后，框架的原型、MVP版本和生产版本将被开发和发布（里程碑
    [M1](https://github.com/replica-io/replica-io/milestone/4)、[M2](https://github.com/replica-io/replica-io/milestone/5)
    和 [M3](https://github.com/replica-io/replica-io/milestone/6)）。
- en: It does not mean at all that exploration, ideation, and prototyping will not
    take place at later stages; the milestones simply define the framework's general
    level of maturity. The framework will continuously evolve and expand and at some
    point become a de facto standard for implementing critical fault-tolerant systems
    providing a growing collection of easy-to-use reliable and efficient distributed
    replication mechanisms.
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不意味着探索、构思和原型制作将不会在后期阶段进行；里程碑只是定义框架的一般成熟水平。该框架将持续演变和扩展，并在某个时刻成为实施关键容错系统的事实标准，提供一个日益增长的易于使用的可靠和高效的分布式复制机制集合。
- en: ❤️Supporting
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❤️ 支持
- en: If you like the project and find it valuable, please
  id: totrans-split-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢这个项目并觉得它有价值，请
- en: '[support](https://github.com/sponsors/replica-io)'
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[支持](https://github.com/sponsors/replica-io)'
- en: its further development! 🙏
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它的进一步发展！ 🙏
- en: If you have any thought you would like to share or any question regarding this
    post, please add a comment [here](https://github.com/orgs/replica-io/discussions/35).
    You are also welcome to [start a new discussion](https://github.com/orgs/replica-io/discussions/new/choose)
    or chime in to [our Discord](https://discordapp.com/invite/CzPfN75URD) server.
  id: totrans-split-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有任何想分享的想法或关于本篇文章的问题，请在[这里](https://github.com/orgs/replica-io/discussions/35)添加评论。您也可以
    [开始新的讨论](https://github.com/orgs/replica-io/discussions/new/choose)，或者加入到我们的 [Discord](https://discordapp.com/invite/CzPfN75URD)
    服务器。
