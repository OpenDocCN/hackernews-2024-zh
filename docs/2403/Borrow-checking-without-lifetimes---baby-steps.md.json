["```\nOrigin = { Loan }\n\nLoan = shared(Place)\n     | mut(Place)\n\nPlace = variable(.field)*  // e.g., a.b.c \n```", "```\nType = TypeName < Generic* >\n     | & Origin Type\n     | & Origin mut Type\n\nTypeName = u32 (for now I'll ignore the rest of the scalars)\n         | ()  (unit type, don't worry about tuples)\n         | StructName\n         | EnumName\n         | UnionName\n\nGeneric = Type | Origin \n```", "```\nlet  mut  counter: u32 =  22_u32; let  p: & /*{shared(counter)}*/  u32  =  &counter; //       --------------------- //       no syntax for this today! counter  +=  1;  // Error: cannot mutate `counter` while `p` is live println!(\"{p}\"); \n```", "```\nEnv |- Expr : Type \n```", "```\nExpr = integer literal (e.g., 22_u32)\n     | & Place\n     | Expr + Expr\n     | Place (read the value of a place)\n     | Place = Expr (overwrite the value of a place)\n     | ... \n```", "```\nEnv |- Expr1 : u32\nEnv |- Expr2 : u32\n----------------------------------------- addition\nEnv |- Expr1 + Expr2 : u32 \n```", "```\nEnv |- Expr : Type1\nEnv |- Place : Type2\nEnv |- Type1 <: Type2\n----------------------------------------- assignment\nEnv |- Place = Expr : () \n```", "```\nEnv |- Place : Type\n----------------------------------------- shared references\nEnv |- & Place : & {shared(Place)} Type \n```", "```\n&{shared(Place)} Type \n```", "```\nLivePlaces = { Place } \n```", "```\n// `&Place` reads `Place`, so add it to `LivePlaces`\nLiveBefore(Env, LivePlaces, &Place) =\n    LivePlaces ∪ {Place}\n\n// `Place = Expr` overwrites `Place`, so remove it from `LivePlaces`\nLiveBefore(Env, LivePlaces, Place = Expr) =\n    LiveBefore(Env, (LivePlaces - {Place}), Expr)\n\n// `Expr1` is evaluated first, then `Expr2`, so the set of places\n// live after expr1 is the set that are live *before* expr2\nLiveBefore(Env, LivePlaces, Expr1 + Expr2) =\n    LiveBefore(Env, LiveBefore(Env, LivePlaces, Expr2), Expr1)\n\n... etc ... \n```", "```\n(Env, LivePlaces) |- Expr : Type \n```", "```\nLiveAfter1 = LiveBefore(Env, LiveAfter2, Expr2)\n(Env, LiveAfter1) |- Expr1 : u32\n(Env, LiveAfter2) |- Expr2 : u32\n----------------------------------------- addition\n(Env, LiveAfter2) |- Expr1 + Expr2 : u32 \n```", "```\nlet tmp0 = <Expr1>\n    // <-- the set LiveAfter1 is live here (ignoring tmp0, tmp1)\nlet tmp1 = <Expr2>\n    // <-- the set LiveAfter2 is live here (ignoring tmp0, tmp1)\ntmp0 + tmp1\n    // <-- the set LiveAfter2 is live here \n```", "```\n(Env, LiveAfter) permits Loan \n```", "```\n(Env, LiveAfter - {Place}) |- Expr : Type1\n(Env, LiveAfter) |- Place : Type2\n(Env, LiveAfter) |- Type1 <: Type2\n(Env, LiveAfter) permits mut(Place)\n----------------------------------------- assignment\n(Env, LiveAfter) |- Place = Expr : () \n```", "```\nlet  mut  counter: u32 =  22_u32; let  p: &{shared(counter)}  u32  =  &counter; counter  +=  1;  // <-- Error println!(\"{p}\");  // <-- p is live \n```", "```\n∀ Place ∈ Live {\n    (Env, Live) |- Place : Type\n    ∀ Loan2 ∈ Loans(Type) { Compatible(Loan1, Loan2) }\n}\n-----------------------------------------\n(Env, Live) permits Loan1 \n```"]