- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-05-27 14:40:00'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-05-27 14:40:00'
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Supercharge compression efficiency with shared dictionaries  |  Blog  |  Chrome
    for Developers
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享字典来提升压缩效率  |  博客  |  Chrome开发者
- en: 来源：[https://developer.chrome.com/blog/shared-dictionary-compression](https://developer.chrome.com/blog/shared-dictionary-compression)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://developer.chrome.com/blog/shared-dictionary-compression](https://developer.chrome.com/blog/shared-dictionary-compression)
- en: Data compression is a time-tested performance optimization technique that reduces
    the size of eligible page resources. For some time, it was common practice to
    primarily use gzip on web servers to compress common text-based page resources
    such as HTML, CSS, and JavaScript files, and send them to the client where they
    could be decompressed. The result is faster load times for resources without affecting
    the intended behavior of a page.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 数据压缩是一种经过时间检验的性能优化技术，可减少符合条件的页面资源的大小。有一段时间，主要在Web服务器上使用gzip来压缩常见的基于文本的页面资源，如HTML、CSS和JavaScript文件，并将其发送到客户端进行解压缩。结果是资源加载时间更快，而不会影响页面的预期行为。
- en: Though gzip is highly effective in its own right, further improvements in compression
    on the web have been realized in recent years. In 2016, the Brotli algorithm shipped
    in Chrome, delivering overall better compression ratios for eligible resources.
    By the end of 2017, all modern browsers supported Brotli, and server support for
    it started to become more widespread. More recently, Chrome [has shipped ZStandard
    compression](https://chromestatus.com/feature/6186023867908096).
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管gzip本身非常有效，但近年来在网络压缩方面已经实现了进一步的改进。2016年，Brotli算法在Chrome中发布，为符合条件的资源提供了更好的总体压缩比。到2017年底，所有现代浏览器都支持Brotli，并且服务器对其支持开始变得更加普遍。最近，Chrome还[推出了ZStandard压缩](https://chromestatus.com/feature/6186023867908096)。
- en: The work doesn't stop there though! The Chrome team has been working on making
    shared dictionaries usable on the web, which are now available in an origin trial
    for both [Brotli and ZStandard](/origintrials#/view_trial/3693514644397228033).
    Shared dictionaries can supplement Brotli and ZStandard compression to deliver
    substantially higher compression ratios for websites that frequently ship updated
    code, and can—in some cases—deliver **90% or better compression ratios**. This
    post goes into more detail on how shared dictionaries work, and how you can register
    for the origin trials to use them for Brotli and ZStandard on your website.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，工作并未就此止步！Chrome团队一直在努力使共享字典在网络上可用，现在已经可以在[两者（Brotli和ZStandard）的起源试验](/origintrials#/view_trial/3693514644397228033)中使用。共享字典可以补充Brotli和ZStandard压缩，大大提高常更新代码的网站的压缩比，有时甚至可以达到**90%甚至更高的压缩比**。本文详细介绍了共享字典的工作原理，以及如何注册起源试验以在您的网站上使用它们来进行Brotli和ZStandard的压缩。
- en: Shared dictionaries explained
  id: totrans-split-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享字典解释
- en: Compression is a process of finding redundant sequences in an input and using
    that information to create a much smaller output, which can be reversed later
    on. Compression works well on the web because it substantially reduces resource
    load times. Both Brotli and ZStandard can further increase their effectiveness
    by using a *compression dictionary*, which is a collection of additional patterns
    that these algorithms can use during compression. In fact, Brotli's high efficiency
    is achieved to some degree by using an internal dictionary.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩是一种在输入中查找冗余序列并利用这些信息创建更小输出的过程，之后可以反向操作。在网络上，压缩效果显著，因为它大幅减少资源加载时间。Brotli和ZStandard通过使用*压缩字典*进一步提升其效率，该字典是这些算法在压缩过程中可以使用的附加模式集合。事实上，Brotli的高效性在一定程度上是通过使用内部字典实现的。
- en: However, *custom* user-curated dictionaries can be used with Brotli and ZStandard
    that contain patterns specific to particular resources. In practice, a custom
    dictionary is an external file that can be applied to any input. Dictionaries
    can be highly specific to an application's production code, or really any content
    at all. How applicable a given dictionary is to its input can have a big impact
    on overall compression efficiency. Dictionaries that are highly similar to the
    contents of an input will yield outputs with higher compression ratios than dictionaries
    with generic or dissimilar contents.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how effective a custom compression dictionary can be:
    say your website uses the Angular framework, and the current version you''re using
    is version 1.7.9\. This version of the Angular framework is about 172 KiB uncompressed.
    When compressed with Brotli''s default settings, its size becomes about 53 KiB.
    This yields nearly a 70% compression ratio. However, say you decide to upgrade
    to Angular 1.8.3 later on. Given that this version of Angular is roughly the same
    size as version 1.7.9, you can expect pretty much the same compression ratio as
    the previous version.'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
- en: This is where a custom dictionary can come in handy by using a process known
    as *delta compression* , which is when a dictionary of a previous version of a
    resource can be used to compress a later version. Using the previous example,
    if you compressed version 1.8.3 of Angular using version 1.7.9 as a dictionary,
    the output would be just over 4 KiB. This represents a compression ratio of **nearly
    98%**. Clearly, compression dictionaries can have a big impact on loading performance,
    and their effectiveness has already [been realized in real-world applications](https://github.com/WICG/compression-dictionary-transport/blob/main/examples.md#static-resource-flow-results)!
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: However, there's a challenge in making this flow work on the web. The catch
    is that, if you use a dictionary to compress a resource, you need that same dictionary
    in order to *decompress* it. This flow has been attempted on the web before—namely
    [SDCH](https://en.wikipedia.org/wiki/SDCH)—but was challenging to implement safely.
    This latest proposal for shared dictionary compression [addresses those concerns](https://github.com/WICG/compression-dictionary-transport?tab=readme-ov-file#this-time-will-be-different)
    while providing a substantial benefit for both static and dynamic resources.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: How Chrome advertises support for shared dictionaries
  id: totrans-split-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All browsers advertise the compression algorithms they support through the
    [`Accept-Encoding` request header](https://developer.mozilla.org/docs/Web/HTTP/Headers/Accept-Encoding).
    The content of the header is a comma-separated list of supported encodings:'
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This particular `Accept-Encoding` header states that the browser requesting
    the resource supports the gzip, Brotli, and ZStandard compression algorithms.
    A web server responding to the request can then decide which algorithm to use
    when responding to the request.
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: When shared dictionary support is enabled and a relevant dictionary is available
    for a resource, additional tokens are added to the `Accept-Encoding` header. These
    tokens are `br-d` for Brotli and `zstd-d` for Zstandard. Chrome will also include
    the hash of an available dictionary, which is covered next.
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If a web server is configured to recognize this token, and it recognizes the
    dictionary, it can respond to that request with a resource that was compressed
    using the dictionary for the applicable encoding. How this is achieved in practice
    depends on whether the request is for a static or dynamic resource.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: Shared dictionary compression for static resources
  id: totrans-split-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A static page resource is one that always produces the same response for a requested
    URL. Common examples of compressible static page resources are JavaScript and
    CSS files. These resources are typically versioned for caching purposes in some
    way—sometimes with a hash of the file's contents in the filename (for example
    `styles.abcd1234.css`), or some other method of fingerprinting the resource. These
    resource types are a great candidate for the delta compression that shared dictionaries
    provide, as static resources are often cached for long periods of time and tend
    to be updated with some frequency.
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary can be specified for a static resource by setting the `Use-As-Dictionary`
    response header for it. The header takes one of a few key/value pairs, but the
    only required one is `match`, which accepts [`URLPattern` syntax](https://urlpattern.spec.whatwg.org/)
    specifying the resource path where the dictionary should be used:'
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Think of the `Use-As-Dictionary` header as a mechanism that applies to future
    versions of a resource that match the pattern specified within it. So, say your
    website ships all of its styles in a single CSS file. For simplicity's sake, say
    the first version of that resource is located at `/dist/styles.v1.css`, and is
    sent with a `Use-As-Dictionary` response header containing a `match` value of
    `/dist/styles.*.css`.
  id: totrans-split-26
  prefs: []
  type: TYPE_NORMAL
- en: 'After some time passes, you update your website''s CSS and ship a new version
    of it located at `/dist/styles.v2.css`. Because the `match` value used in the
    `Use-As-Dictionary` response header from the previous version applies to this
    request, the browser will send a `Available-Dictionary` header containing a hash
    of the dictionary encoded as a [structured field byte sequence](https://www.rfc-editor.org/rfc/rfc8941.html#name-byte-sequences):'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, it's up to the server to configure compression on its end to
    ensure the matching dictionary is used. The resource compressed with that dictionary
    will then be sent, and the available dictionary in the user's browser cache will
    be used to decompress it.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: If you ship new code often for your website, delta compression can go a long
    way. However, the process is flexible. If the browser doesn't determine that a
    dictionary is available in the user's browser cache, it will *not* specify the
    additional `br-d` or `zstd-d` tokens in the `Accept-Encoding` header. In that
    case, the standard compression flow applies.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: Shared dictionary compression for dynamic resources
  id: totrans-split-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dynamic resources can also benefit from shared dictionary compression. Dynamic
    resources are those that change based on a context—such a news website where the
    main page is updated frequently as news breaks, for example. HTML documents are
    often dynamic resources. In such cases, the dictionary can contain most of the
    site's common HTML structure and template code leading to compressed pages where
    only the unique parts of each page are sent.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the nature of dynamically-generated resources, a dictionary must be
    loaded on the client for later use. Loading a dictionary ahead of time means that
    applying shared dictionary compression to dynamic resources is speculative. The
    hope in such cases is that your website receives enough traffic that the dictionary
    cost can be amortized over a large number of navigations. Should you decide to
    try it, the first step is to specify the dictionary''s location by way of a `<link>`
    element in your page HTML:'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-split-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When Chrome encounters this `<link>` element, it *may* fetch the dictionary
    once the page is idle, and at low priority in an effort to avoid bandwidth contention.
    The response for the dictionary itself must specify a `Use-As-Dictionary` header
    and specify which dynamic resource path it applies to:'
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-split-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From here, the flow is largely the same as for static resources. The browser
    will see that the dictionary itself applies to matching resources, and the browser
    will attach an `Available-Dictionary` header to the request with a hash of the
    dictionary's contents, again, similar to the static resources flow explained earlier.
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: Compress static resources at build time
  id: totrans-split-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're familiar with bundlers, you might be familiar with various plugins
    for them that can compress resources at build time, and subsequently serve those
    compressed resources. For example, [Apache lets you use directives to serve those
    precompressed resources](https://bash-prompt.net/guides/apache-brotli-static/)
    at the time of the request.
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Node.js-based bundlers that support compression use Node''s built-in Zlib
    library. Zlib offers support for Brotli and bundlers that use it typically offer
    an interface to pass options directly into Zlib, which [supports dictionary-aided
    compression](https://nodejs.org/api/zlib.html#class-options). Here are a few bundlers
    that support using dictionaries:'
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: Note that available dictionaries for any given version of a resource may use
    one of any previous versions of a resource. This means that you will need to analyze
    user traffic and plan accordingly. Aim for a balance and generate resources that
    benefit the maximum number of returning users as best as you can. CDN providers
    are currently experimenting with shared dictionary compression. No implementations
    are yet available for public use, but we expect that to change!
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何给定版本资源的可用字典可能使用资源的任何先前版本之一。这意味着您需要分析用户流量并相应地规划。努力实现平衡，并生成最大数量的返回用户受益的资源。CDN提供商目前正在尝试共享字典压缩。尚无公开使用的实现，但我们预计情况将有所改变！
- en: Try it out!
  id: totrans-split-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下！
- en: 'Integrating shared dictionary compression with the browser''s existing compression
    capabilities has the potential to substantially improve loading performance for
    websites that frequently ship updated production code and receive significant
    traffic from returning visitors. If you''re interested in giving shared dictionary
    compression a shot, you have two options:'
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将共享字典压缩与浏览器现有的压缩能力集成，有潜力显著提高经常更新生产代码并且接收大量重复访问的网站的加载性能。如果您有兴趣尝试共享字典压缩，有两种选择：
- en: If you're just looking to tinker with shared dictionary compression on your
    own to get a feel for how it works, you can enable the **Compression dictionary
    transport** experimental feature on the `chrome://flags` page.
  id: totrans-split-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您只是想自己动手尝试共享字典压缩，了解其工作原理，可以在`chrome://flags`页面启用**压缩字典传输**实验性功能。
- en: If you're interested in trying this out on your production website and see how
    shared dictionary compression could benefit real users, [register for the origin
    trial](/origintrials#/view_trial/3693514644397228033) to get a token, and read
    up on [how origin trials work](/docs/web-platform/origin-trials).
  id: totrans-split-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您有兴趣在生产网站上尝试此功能，看看共享字典压缩如何使真实用户受益，请[注册进行起始试验](/origintrials#/view_trial/3693514644397228033)以获取令牌，并详细了解[起始试验的工作原理](/docs/web-platform/origin-trials)。
- en: Conclusion
  id: totrans-split-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: We're quite excited about this major advancement in compression technology on
    the web, and how much faster it could make existing applications that people use
    every day. We encourage you to try it out, and most importantly, [we want to hear
    your thoughts](https://github.com/WICG/compression-dictionary-transport/issues)
    if you do! If you find a bug, [file it at crbug.com](https://issues.chromium.org/issues).
    For additional resources and tools, check out [use-as-dictionary.com](https://use-as-dictionary.com/).
    Finally, if you're interested in a deeper dive into how it all works, [the explainer](https://github.com/WICG/compression-dictionary-transport/blob/main/README.md)
    is a good next step!
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这项网页压缩技术的重大进展感到非常兴奋，以及它可以使人们每天使用的现有应用程序变得更快。我们鼓励您尝试一下，并且最重要的是，[如果您这么做，我们想听听您的想法](https://github.com/WICG/compression-dictionary-transport/issues)！如果您发现了错误，请[在crbug.com上报告](https://issues.chromium.org/issues)。有关更多资源和工具，请访问[use-as-dictionary.com](https://use-as-dictionary.com/)。最后，如果您对其工作原理有更深入的了解兴趣，请查看[解释文档](https://github.com/WICG/compression-dictionary-transport/blob/main/README.md)！
