["```\n// Short example JavaScript code to illustrate Dart/JS interop\nwindow.myTopLevel = {\n  field1: 0,\n  method2() {\n    return this.field1;\n  }\n}\n```", "```\n// Access via `dart:js` (2013)\nimport 'dart:js' as js;\n\nvoid main() {\n  // This line has a typo! oops :(\n  var object = js.context['myTopLevl'];\n  object['field1'] = 1;\n  // This call fails with a noSuchMethod because method2\n  // returns an int, oops\n  object.callMethod('method2', []).substr(1);\n}\n```", "```\n// Access via `package:js` (2015)\nimport 'package:js/js.dart';\n\n// Magic annotations allow us to declare API signatures:\n@JS()\nclass MyObject {\n  external int get field1;\n  external void set field1(int value);\n  external String method2();\n}\n\n@JS()\nexternal MyObject get myTopLevel;\n\nvoid main() {\n  // Access to code is less error prone: analyzer can check that\n  // these symbols match a declaration, and we get code-completion too!\n  var object = myTopLevel;\n  object.field1 = 1;\n  // But types are not checked, this unsoundly invokes substring on an int\n  object.method2().substring(1);\n}\n```", "```\n// Access via `dart:js_interop` (2024)\nimport 'dart:js_interop';\n\n// Declarations use extension types, which are very similar to package:js\n// declarations. The main difference: they are statically dispatched.\nextension type MyObject._(JSObject _) implements JSObject {\n  external int get field1;\n  external void set field1(int value);\n  external String method2();\n}\n\n@JS()\nexternal MyObject get myTopLevel;\n\nvoid main() {\n  var object = myTopLevel;\n  object.field1 = 1;\n  // At last, access is sound - this line fails with a type error\n  // when returning from method2.\n  object.method2().substring(1);\n}\n```"]