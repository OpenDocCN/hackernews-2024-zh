["```\nparagraph: ($) =>\n  seq(repeat1(seq($._inline, \"\\n\")), choice(\"\\n\", $._close_paragraph)), \n```", "```\nexternals: ($) => [$._close_paragraph], \n```", "```\ntypedef enum { CLOSE_PARAGRAPH } TokenType; \n```", "```\nbool tree_sitter_sdjot_external_scanner_scan(void *payload, TSLexer *lexer,\n                                             const bool *valid_symbols)  { return false; }\n\nvoid *tree_sitter_sdjot_external_scanner_create()  { return NULL; }\nvoid tree_sitter_sdjot_external_scanner_destroy(void *payload)  {}\n\nunsigned tree_sitter_sdjot_external_scanner_serialize(void *payload,\n                                                      char *buffer)  { return 0; }\nvoid tree_sitter_sdjot_external_scanner_deserialize(void *payload, char *buffer,\n                                                    unsigned length)  {} \n```", "```\nbool tree_sitter_sdjot_external_scanner_scan(void *payload, TSLexer *lexer,\n                                             const bool *valid_symbols)  { if (valid_symbols[CLOSE_PARAGRAPH] && parse_close_paragraph(lexer)) {\n    return true;\n  }\n  return false; } \n```", "```\nstatic bool parse_close_paragraph(TSLexer *lexer)  { lexer->mark_end(lexer);\n\n  uint8_t colons = consume_chars(lexer, ':');\n  if (colons >= 3) {\n    lexer->result_symbol = CLOSE_PARAGRAPH;\n    return true;\n  } else {\n    return false;\n  } } \n```", "```\nstatic uint8_t consume_chars(TSLexer *lexer, char c)  { uint8_t count = 0;\n  while (lexer->lookahead == c) {\n    lexer->advance(lexer, false);\n    ++count;\n  }\n  return count; } \n```", "```\n:::\nA paragraph inside a div\n::: \n```", "```\n$ tree-sitter parse example-file\n(document [0, 0] - [4, 0]\n  (div [0, 0] - [3, 0]\n    (div_marker [0, 0] - [0, 3])\n    (paragraph [1, 0] - [2, 0])\n    (div_marker [2, 0] - [2, 3]))) \n```", "```\ndiv: ($) =>\n  prec.left( seq( alias($._div_marker_begin, $.div_marker),\n      \"\\n\",\n      repeat($._block),\n      $._block_close,\n      optional(alias($._div_marker_end, $.div_marker))\n    )\n  ),\n\nexternals: ($) => [\n  $._close_paragraph,\n  $._block_close,\n  $._div_marker_begin,\n  $._div_marker_end,\n\n      $._ignored,\n], \n```", "```\ntypedef enum {\n  CLOSE_PARAGRAPH,\n  BLOCK_CLOSE,\n  DIV_MARKER_BEGIN,\n  DIV_MARKER_END,\n IGNORED } TokenType; \n```", "```\ntypedef enum { DIV } BlockType;\n\ntypedef struct {\n  BlockType type;\n  uint8_t level;\n} Block; \n```", "```\nenum Block {\n    Div { colons: u32 },\n    Footnote { indent: u32 }, } \n```", "```\n#include \"tree_sitter/array.h\" \ntypedef struct {\n  Array(Block *) * open_blocks;\n} Scanner; \n```", "```\n#include \"tree_sitter/alloc.h\" \nvoid *tree_sitter_sdjot_external_scanner_create()  { Scanner *s = (Scanner *)ts_malloc(sizeof(Scanner));\n\n    s->open_blocks = ts_malloc(sizeof(Array(Block *)));\n  array_init(s->open_blocks);\n\n  return s; }\n\nvoid tree_sitter_sdjot_external_scanner_destroy(void *payload)  { Scanner *s = (Scanner *)payload;\n\n        for (size_t i = 0; i < s->open_blocks->size; ++i) {\n        ts_free(array_get(s->open_blocks, i));\n  }\n\n      array_delete(s->open_blocks);\n\n  ts_free(s); } \n```", "```\nstatic void push_block(Scanner *s, BlockType type, uint8_t level)  { Block *b = ts_malloc(sizeof(Block));\n  b->type = type;\n  b->level = level;\n\n    array_push(s->open_blocks, b); } \n```", "```\nunsigned tree_sitter_sdjot_external_scanner_serialize(void *payload,\n                                                      char *buffer)  { Scanner *s = (Scanner *)payload;\n  unsigned size = 0;\n  for (size_t i = 0; i < s->open_blocks->size; ++i) {\n    Block *b = *array_get(s->open_blocks, i);\n    buffer[size++] = (char)b->type;\n    buffer[size++] = (char)b->level;\n  }\n  return size; }\n\nvoid tree_sitter_sdjot_external_scanner_deserialize(void *payload, char *buffer,\n                                                    unsigned length)  { Scanner *s = (Scanner *)payload;\n  array_init(s->open_blocks);\n  size_t size = 0;\n  while (size < length) {\n    BlockType type = (BlockType)buffer[size++];\n    uint8_t level = (uint8_t)buffer[size++];\n    push_block(s, type, level);\n  } } \n```", "```\nbool tree_sitter_sdjot_external_scanner_scan(void *payload, TSLexer *lexer,\n                                             const bool *valid_symbols)  { Scanner *s = (Scanner *)payload;\n\n    if (valid_symbols[CLOSE_PARAGRAPH] && parse_close_paragraph(lexer)) {\n    return true;\n  }\n\n    if (parse_div(s, lexer, valid_symbols)) {\n    return true;\n  }\n\n  return false; } \n```", "```\nstatic bool parse_div(Scanner *s, TSLexer *lexer, const bool *valid_symbols)  { if (!valid_symbols[DIV_MARKER_BEGIN] && !valid_symbols[DIV_MARKER_END]) {\n    return false;\n  } } \n```", "```\nstatic uint8_t consume_chars(TSLexer *lexer, char c)  { uint8_t count = 0;\n  while (lexer->lookahead == c) {\n    lexer->advance(lexer, false);\n    ++count;\n  }\n  return count; }\n\nstatic bool parse_div(Scanner *s, TSLexer *lexer, const bool *valid_symbols)  { uint8_t colons = consume_chars(lexer, ':');\n  if (colons < 3) {\n    return false;\n  } } \n```", "```\npush_block(s, DIV, colons);\nlexer->result_symbol = DIV_MARKER_BEGIN;\nreturn true; \n```", "```\nstatic size_t number_of_blocks_from_top(Scanner *s, BlockType type,\n                                        uint8_t level)  { for (int i = s->open_blocks->size - 1; i >= 0; --i) {\n    Block *b = *array_get(s->open_blocks, i);\n    if (b->type == type && b->level == level) {\n      return s->open_blocks->size - i;\n    }\n  }\n  return 0; }\n\nstatic bool parse_div(Scanner *s, TSLexer *lexer, const bool *valid_symbols)  { size_t from_top = number_of_blocks_from_top(s, DIV, colons);\n\n      if (from_top > 0) {\n      } else {\n        lexer->mark_end(lexer);\n    push_block(s, DIV, colons);\n    lexer->result_symbol = DIV_MARKER_BEGIN;\n    return true;\n  } } \n```", "```\n:::\n:::::\n:::::::\ntext\n::: \n```", "```\n7 (top)\n5\n3 (the one we want to close) \n```", "```\ntypedef struct {\n  Array(Block *) * open_blocks;\n\n    uint8_t blocks_to_close;\n\n    TokenType delayed_token;\n    uint8_t delayed_token_width;\n} Scanner; \n```", "```\nbuffer[size++] = (char)s->blocks_to_close;\nbuffer[size++] = (char)s->delayed_token;\nbuffer[size++] = (char)s->delayed_token_width; \n```", "```\ns->blocks_to_close = (uint8_t)buffer[size++];\ns->delayed_token = (TokenType)buffer[size++];\ns->delayed_token_width = (uint8_t)buffer[size++]; \n```", "```\ns->blocks_to_close = 0;\ns->delayed_token = IGNORED; \n```", "```\nbool tree_sitter_sdjot_external_scanner_scan(void *payload, TSLexer *lexer,\n                                             const bool *valid_symbols)  { Scanner *s = (Scanner *)payload;\n\n  if (valid_symbols[BLOCK_CLOSE] && handle_blocks_to_close(s, lexer)) {\n    return true;\n  }\n\n  if (output_delayed_token(s, lexer, valid_symbols)) {\n    return true;\n  } } \n```", "```\nstatic void remove_block(Scanner *s)  { if (s->open_blocks->size > 0) {\n    ts_free(array_pop(s->open_blocks));\n    if (s->blocks_to_close > 0) {\n      --s->blocks_to_close;\n    }\n  } }\n\nstatic bool handle_blocks_to_close(Scanner *s, TSLexer *lexer)  { if (s->open_blocks->size == 0) {\n    return false;\n  }\n\n    if (lexer->eof(lexer) || s->blocks_to_close > 0) {\n    lexer->result_symbol = BLOCK_CLOSE;\n    remove_block(s);\n    return true;\n  }\n  return false; } \n```", "```\nstatic bool output_delayed_token(Scanner *s, TSLexer *lexer,\n                          const bool *valid_symbols)  { if (s->delayed_token == IGNORED || !valid_symbols[s->delayed_token]) {\n    return false;\n  }\n\n  lexer->result_symbol = s->delayed_token;\n  s->delayed_token = IGNORED;\n    while (s->delayed_token_width--) {\n    lexer->advance(lexer, false);\n  }\n  lexer->mark_end(lexer);\n  return true; } \n```", "```\nsize_t from_top = number_of_blocks_from_top(s, DIV, colons);\n\nif (from_top > 0) {\n    close_blocks_with_final_token(s, lexer, from_top, DIV_MARKER_END, colons);\n  return true;\n} else {\n  lexer->mark_end(lexer);\n  push_block(s, DIV, colons);\n  lexer->result_symbol = DIV_MARKER_BEGIN;\n  return true;\n} \n```", "```\nstatic void close_blocks_with_final_token(Scanner *s, TSLexer *lexer,\n                                          size_t count, TokenType final,\n                                          uint8_t final_token_width)  { remove_block(s);\n  s->blocks_to_close = s->blocks_to_close + count - 1;\n  lexer->result_symbol = BLOCK_CLOSE;\n  s->delayed_token = final;\n  s->delayed_token_width = final_token_width; } \n```", "```\n:::::\n:::\n:::::::\nDivception\n::: \n```", "```\n$ tree-sitter parse example-file\n(document [0, 0] - [6, 0]\n  (div [0, 0] - [6, 0]\n    (div_marker [0, 0] - [0, 5])\n    (div [1, 0] - [4, 3]\n      (div_marker [1, 0] - [1, 3])\n      (div [2, 0] - [4, 0]\n        (div_marker [2, 0] - [2, 7])\n        (paragraph [3, 0] - [4, 0]))\n      (div_marker [4, 0] - [4, 3])))) \n```", "```\n$ tree-sitter parse example-file -d\n...\nprocess version:0, version_count:1, state:34, row:4, col:0\nlex_external state:4, row:4, column:0\n  consume character:':'                         // Scan `:::`\n  consume character:':'\n  consume character:':'\nlexed_lookahead sym:_close_paragraph, size:0    // Output _close_paragraph\nreduce sym:paragraph_repeat1, child_count:2\nshift state:17\nprocess version:0, version_count:1, state:17, row:4, col:0\nlex_external state:3, row:4, column:0           // Still on first `:`\n  consume character:':'                         // Scan `:::` again\n  consume character:':'\n  consume character:':'\nlexed_lookahead sym:_block_close, size:0        // Close div with _block_close\nreduce sym:paragraph, child_count:2\nshift state:12\nprocess version:0, version_count:1, state:12, row:4, col:0\nlex_external state:5, row:4, column:0           // Still on first `:`\nlexed_lookahead sym:_block_close, size:0        // Close second div with _block_close\nreduce sym:div, child_count:4\nshift state:12\nprocess version:0, version_count:1, state:12, row:4, col:0\nlex_external state:5, row:4, column:0           // Still on first `:`\n  consume character:':'                         // Consume `:::`\n  consume character:':'\n  consume character:':'\nlexed_lookahead sym:div_marker, size:3          // div_marker is size 3, marks `:::`\nshift state:23 \n```"]