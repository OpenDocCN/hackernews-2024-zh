<!--yml

category: 未分类

date: 2024-05-27 14:42:03

-->

# 从基于规则的分类器进化：Netflix数据平台中的机器学习驱动自动修复 | Netflix 技术博客 | Netflix TechBlog

> 来源：[https://netflixtechblog.com/evolving-from-rule-based-classifier-machine-learning-powered-auto-remediation-in-netflix-data-039d5efd115b?gi=f2beca8c0a2b](https://netflixtechblog.com/evolving-from-rule-based-classifier-machine-learning-powered-auto-remediation-in-netflix-data-039d5efd115b?gi=f2beca8c0a2b)

# 从基于规则的分类器进化：Netflix数据平台中的机器学习驱动自动修复

作者：[侯斌兵](https://www.linkedin.com/in/binbing-hou/overlay/about-this-profile/)，[斯蒂芬妮·韦齐克·塔马约](https://www.linkedin.com/in/stephanievezich/overlay/about-this-profile/)，[陈晓](https://www.linkedin.com/in/chenxiao000/overlay/about-this-profile/)，[田亮](https://www.linkedin.com/in/liangtian/overlay/about-this-profile/)，[特洛伊·里斯托](https://www.linkedin.com/in/troy-ristow-4899b49/overlay/about-this-profile/)，[王浩元](https://www.linkedin.com/in/haoyuanwang/overlay/about-this-profile/)，[斯尼哈尔·切纳鲁](https://www.linkedin.com/in/snehalchennuru/overlay/about-this-profile/)，[帕万·迪克希特](https://www.linkedin.com/in/pawan-dixit-b4307b2/overlay/about-this-profile/)

*这是我们在Netflix关于利用数据洞察和机器学习（ML）改善大数据作业性能和成本效率运营自动化系列工作的第一篇。操作自动化——包括但不限于自动诊断、自动修复、自动配置、自动调整、自动扩展、自动调试和自动测试——是现代数据平台成功的关键。在本博文中，我们介绍了我们的自动修复项目，它将目前使用的基于规则的分类器与ML服务集成，旨在无需人工干预自动修复失败的作业。我们已将自动修复投入生产环境，用于处理Spark作业的内存配置错误和未分类错误，并观察到其效率和效果（例如自动修复了56%的内存配置错误并节省了由所有错误引起的50%的货币成本），并具有进一步改进的巨大潜力。*

# Introduction

在Netflix，每天有数十万个工作流和数百万个作业在大数据平台的多个层次上运行。鉴于这种分布广泛、大规模系统固有的广泛范围和复杂性，即使失败的作业占总工作负载的一小部分，诊断和纠正作业故障也会带来相当大的操作负担。

为了高效处理错误，Netflix开发了一个错误分类服务，名为Pensive，它利用基于规则的分类器进行错误分类。基于一组预定义规则，规则分类器对作业错误进行分类，并为调度器提供决定是否重试作业的见解，同时也为工程师提供诊断和修复作业失败的支持。

然而，随着系统规模和复杂性的增加，基于规则的分类器在操作自动化方面面临挑战，特别是在处理内存配置错误和未分类错误方面支持有限。因此，操作成本随着失败作业数量的增加而线性增加。在某些情况下，例如，诊断和修复由于内存不足（OOM）错误导致的作业失败，需要跨团队共同努力，不仅涉及用户本身，还涉及支持工程师和领域专家。

要解决这些挑战，我们开发了一项名为*自动修复*的新功能，它将基于规则的分类器与机器学习服务集成。根据规则分类器的分类结果，它使用机器学习服务预测重试成功概率和重试成本，并选择最佳的候选配置作为推荐；还有一个配置服务来自动应用这些推荐。其主要优点如下：

+   **集成智能。** 自动修复不是完全废弃当前的基于规则的分类器，而是将其与机器学习服务集成，以便充分利用两者的优点：基于规则的分类器提供静态、确定性的每个错误类别的分类结果，基于领域专家的上下文；机器学习服务针对每个作业提供性能和成本效益意识的推荐，充分利用机器学习的能力。通过集成智能，我们可以有效地满足不同错误的修复要求。

+   **完全自动化。** 对错误进行分类、获取推荐并应用推荐的流程完全自动化。它将推荐与重试决策一起提供给调度器，并特别使用在线配置服务来存储和应用推荐的配置。这样一来，在修复过程中不需要人为干预。

+   **多目标优化。** 自动修复通过同时考虑性能（即重试成功概率）和计算成本效率（即运行作业的货币成本），生成推荐，避免盲目推荐资源消耗过大的配置。例如，对于内存配置错误，它搜索与作业执行的内存使用相关的多个参数，并推荐最小化失败概率和计算成本线性组合的组合。

这些优点已经通过生产部署验证，用于纠正Spark作业的故障。我们的观察表明，自动纠正能够成功纠正约56%的所有内存配置错误，通过在线应用推荐的内存配置，无需人工干预；同时，通过推荐新的配置使内存配置成功，并禁用对未分类错误的不必要重试，从而降低了约50%的成本。我们还注意到，通过模型调整，可以进一步提升潜力（参见生产发布部分）。

# 基于规则的分类器：基础和挑战

## 基础知识

图1展示了数据平台中的错误分类服务Pensive。它利用基于规则的分类器，由三个组件组成：

+   **日志收集器**负责从不同的平台层拉取日志，用于错误分类（例如调度器、作业编排器和计算集群）。

+   **规则执行引擎**负责将收集到的日志与一组预定义规则进行匹配。规则包括：（1）错误的名称、来源、日志和摘要，以及错误是否可重新启动；（2）用于从日志中识别错误的正则表达式。例如，名为SparkDriverOOM的规则包含的信息表明，如果Spark作业的标准输出日志可以匹配到正则表达式*SparkOutOfMemoryError:*，则将此错误分类为用户错误，不可重新启动。

+   **结果最终处理器**根据匹配的规则最终确定错误分类结果。如果匹配了一个或多个规则，则第一个匹配的规则决定最终的分类结果（规则优先级由规则顺序决定，第一个规则优先级最高）。另一方面，如果没有匹配的规则，则认为此错误未分类。

## 挑战

虽然基于规则的分类器简单且有效，但由于其处理配置错误和分类新错误的能力有限，面临挑战：

+   **内存配置错误。** 基于规则的分类器提供错误分类结果，指示是否重新启动作业；但对于非瞬态错误，仍然依赖工程师手动修复作业。最显著的例子是内存配置错误。此类错误通常由于作业内存配置错误引起。设置过小的内存可能导致内存溢出（OOM）错误，而设置过大的内存则可能浪费集群内存资源。更具挑战性的是，某些内存配置错误需要更改多个参数的配置。因此，正确设置内存配置不仅需要手动操作，还需要 Spark 作业执行的专业知识。此外，即使作业的内存配置最初调整良好，数据大小和作业定义的更改也可能导致性能下降。考虑到数据平台每月约有 600 个内存配置错误，及时修复仅内存配置错误就需要大量工程工作。

+   **未分类错误。** 基于已知上下文，规则分类器依赖数据平台工程师手动添加规则以识别错误；否则，这些错误将被视为未分类。由于数据平台不同层次的迁移和应用程序的多样性，现有规则可能失效，并且添加新规则需要工程工作，也依赖于部署周期。分类器已添加了超过 300 条规则，但约 50% 的故障仍未分类。对于未分类错误，作业可能会使用默认重试策略多次重试。如果错误是非瞬态的，这些失败的重试将增加不必要的作业运行成本。

# 演变为自动修复：服务架构

## 方法论

为了解决上述挑战，我们的基本方法是将基于规则的分类器与 ML 服务集成以生成推荐，并使用配置服务自动应用推荐：

+   **生成推荐。** 我们首先使用基于规则的分类器对所有错误进行分类，基于预定义规则，然后使用 ML 服务进行第二次分类，为内存配置错误和未分类错误提供推荐。

+   **应用推荐。** 我们使用在线配置服务存储和应用推荐的配置。管道完全自动化，并且用于生成和应用推荐的服务是解耦的。

## 服务集成

图 2 展示了数据平台中生成和应用推荐服务的集成。主要服务如下：

+   **Nightingale** 是一个运行使用 [Metaflow](https://metaflow.org/) 训练的 ML 模型的服务，负责生成重试建议。该建议包括：(1) 错误是否可重新启动；以及 (2) 如果是，则推荐的配置以重新启动作业。

+   **ConfigService** 是一个在线配置服务。推荐的配置保存为一个 JSON 补丁，并定义范围以指定可以使用推荐配置的作业。当 **Scheduler** 调用 **ConfigService** 获取推荐配置时，**Scheduler** 将原始配置传递给 **ConfigService**，并通过将 JSON 补丁应用于原始配置来返回变异的配置。**Scheduler** 可以使用变异的配置（包括推荐的配置）重新启动作业。

+   **Pensive** 是一个利用基于规则的分类器的错误分类服务。它调用 **Nightingale** 来获取推荐，并将推荐保存到 **ConfigService** 中，以便 **Scheduler** 可以重新启动作业。

+   **Scheduler** 是调度作业的服务（我们当前的实现与 [Netflix Maestro](/orchestrating-data-ml-workflows-at-scale-with-netflix-maestro-aaa2b41b800c)）。每次作业失败时，它调用 **Pensive** 获取错误分类以决定是否重新启动作业，并调用 **ConfigServices** 获取重新启动作业所需的推荐配置。

图 3 描述了带有自动修复功能的服务调用顺序：

1.  在作业失败时，**Scheduler** 调用 **Pensive** 获取错误分类。

1.  **Pensive** 根据基于规则的分类器对错误进行分类。如果识别出错误是内存配置错误或未分类错误，则调用 **Nightingale** 获取推荐。

1.  使用获取的推荐，**Pensive** 更新错误分类结果，并将推荐的配置保存到 **ConfigService**；然后将错误分类结果返回给 **Scheduler**。

1.  根据从 **Pensive** 收到的错误分类结果，**Scheduler** 决定是否重新启动作业。

1.  在重新启动作业之前，**Scheduler** 调用 **ConfigService** 获取推荐的配置，并使用新配置重试作业。

# 进化到自动修复：ML 服务

## 概述

ML 服务，即 Nightingale，旨在为失败的作业生成重试策略，权衡重试成功概率和作业运行成本。它由两个主要组件组成：

+   **一个预测模型**，联合估计了 a) 重试成功的概率，以及 b) 重试成本（以美元计），条件是重试的属性。

+   **一个优化器**，探索 Spark 配置参数空间以推荐最小化重试失败概率和成本的线性组合的配置。

预测模型每天离线重新训练一次，并由优化器调用以评估每组候选配置参数值集合。优化器作为一个 RESTful 服务在作业失败时被调用。如果优化有可行的配置解决方案，响应将包含此推荐，ConfigService 使用它来改变重试的配置。如果没有可行解决方案——换句话说，仅通过更改 Spark 配置参数可能不太可能使重试成功——响应将包含一个标志来禁用重试，从而消除浪费的计算成本。

## 预测模型

考虑到我们想探索在不同配置场景下重试成功和重试成本如何变化，我们需要一种方法来使用我们对作业的信息来预测这两个值。数据平台记录了重试成功的结果和执行成本，为我们提供了可靠的标签。由于我们使用共享的特征集来预测这两个目标，并且需要在线快速运行推理以满足 SLOs，因此我们决定将问题制定为一个多输出监督学习任务。具体来说，我们使用一个简单的前馈多层感知器（MLP）模型，其中有两个输出头，分别用于预测每个结果。

**训练：** 训练集中的每个记录代表了以前由于内存配置错误或未分类错误而失败的潜在重试。标签包括：a) 重试是否失败，b) 重试成本。原始特征输入主要是关于作业的未结构化元数据，例如 Spark 执行计划、运行作业的用户以及 Spark 配置参数和其他作业属性。我们将这些特征分为可以解析为数值的部分（例如 Spark 执行器内存参数）和不能解析为数值的部分（例如用户名）。由于非数值值来自高基数和动态的值集合，我们使用特征哈希处理这些值。然后我们创建一个较低维度的嵌入，它与归一化的数值值连接，并通过几层传递。

**推理：** 在通过验证审计后，每个新的模型版本都存储在我们内部 ML 平台提供的服务 [Metaflow](https://metaflow.org/) Hosting 中。优化器针对每个传入的配置建议请求多次调用模型预测函数，下面详细描述。

## 优化器

当作业尝试失败时，它会向Nightingale发送一个带有作业标识符的请求。从此标识符，服务构建要在推理调用中使用的特征向量。正如之前所述，其中一些特征是Spark配置参数，这些参数可能会被突变（例如，spark.executor.memory，spark.executor.cores）。Spark配置参数集是基于深入从事Spark性能调优的领域专家的精炼知识。我们使用贝叶斯优化（通过Meta的[Ax库](https://ax.dev/)实现）来探索配置空间并生成推荐。在每次迭代中，优化器生成一个候选参数值组合（例如，spark.executor.memory=7192 mb，spark.executor.cores=8），然后通过调用预测模型评估该候选，以估计使用候选配置（即在特征向量中突变其值）的重试失败概率和成本。在固定数量的迭代之后，如果可行，优化器返回“最佳”配置解决方案（即最小化了联合重试失败和成本目标）。如果找不到可行解决方案，我们会禁用重试。

优化器迭代设计的一个缺点是，任何瓶颈都可能阻止完成并导致超时，这是我们最初在一些案例中观察到的。通过进一步的性能分析，我们发现大部分延迟来自于候选生成步骤（即在前一个迭代的评估结果之后找出在配置空间中采取哪些方向）。我们发现这个问题已经被提到Ax库的所有者那里，并且他们在他们的API中添加了GPU加速选项。利用这个选项显著减少了我们的超时率。

# 在生产环境中推出

我们已经在生产环境中部署了自动修复，用于处理Spark作业中的内存配置错误和未分类错误。除了重试成功率和成本效益之外，用户体验的影响是主要关注点：

+   **内存配置错误自动修复：** 自动修复提升了用户体验，因为在没有针对内存配置错误的新配置的情况下，作业重试成功的可能性很小。这意味着使用推荐的配置成功重试可以减少操作负载并节省作业运行成本，而失败的重试并不会使用户体验变差。

+   **对于未分类的错误：** 如果错误无法被规则分类器中现有规则分类，自动修复建议是否重新启动作业。特别是，如果ML模型预测到重试很可能失败，它将建议禁用重试，这可以节省不必要的重试导致的作业运行成本。对于业务关键作业且用户偏好无论重试成功概率低都始终重试的情况，我们可以向规则分类器添加新规则，以便下次由规则分类器分类相同错误，跳过ML服务的建议。这展示了规则分类器和ML服务集成智能的优势。

在生产部署中表明，自动修复可以为内存配置错误提供有效配置，成功修复约56%的所有内存配置问题，无需人工干预。它还通过建议新的配置使重试成功或禁用不必要的重试，将这些作业的计算成本降低约50%。由于性能和成本效率之间的权衡是可调节的，我们可以通过调整ML服务决定达到更高的成功率或更多的成本节省。

值得注意的是，ML服务目前采用保守策略禁用重试。如上所述，这是为了避免对用户偏好作业失败后始终重试的情况的影响。尽管这些情况是预期的，可以通过向规则分类器添加新规则来解决，但我们考虑逐步调整目标函数以逐步禁用更多重试有助于提供理想的用户体验。鉴于目前禁用重试的政策是保守的，自动修复潜力巨大，最终可以带来更多成本节省，而不影响用户体验。

# 超越错误处理：朝向正确的尺寸调整

自动修复是利用数据洞见和机器学习（ML）改善用户体验、减少数据平台运营负担和提高成本效率的第一步。它专注于自动化修复失败作业，同时为自动化处理除错误处理之外的操作铺平道路。

我们正在采取的一项措施之一，称为*合适调整*，是重新配置预定的大数据作业，以请求适当的资源来执行作业。例如，我们注意到Spark作业的平均请求执行器内存约为其最大使用内存的四倍，表明存在显著的过度配置。除了作业本身的配置外，请求执行作业的容器的资源过度配置也可以减少以节省成本。通过启发式和基于ML的方法，我们可以推断作业执行的适当配置，以最小化资源过度配置并每年节省数百万美元，而不影响性能。类似于自动修复，这些配置可以通过ConfigService自动应用，无需人工干预。*合适调整*正在进行中，并将在专门的技术博客文章中详细介绍。请继续关注。

# 致谢

自动修复是来自不同团队和组织的工程师们共同努力的成果。如果没有坚实而深入的合作，这项工作将无法实现。我们要感谢所有的人，包括Spark专家、数据科学家、ML工程师、调度器和作业编排工程师、数据工程师和支持工程师，他们分享了背景信息，并提供了建设性建议和宝贵的反馈（例如，[John Zhuge](https://www.linkedin.com/in/jzhuge/)、[Jun He](https://www.linkedin.com/in/jheua/)、[Holden Karau](https://www.linkedin.com/in/holdenkarau/)、[Samarth Jain](https://www.linkedin.com/in/samarthjain11/)、[Julian Jaffe](https://www.linkedin.com/in/julianjaffe/)、[Batul Shajapurwala](https://www.linkedin.com/in/batul-shajapurwala-3274b863/)、[Michael Sachs](https://www.linkedin.com/in/michael-sachs-b2453b/overlay/about-this-profile/)、[Faisal Siddiqi](https://www.linkedin.com/in/fzsiddiqi/overlay/about-this-profile/)）。
