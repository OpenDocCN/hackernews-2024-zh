- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 12:46:19'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Architecture Pitfalls: Don’t use your ORM entities for everything — embrace
    the SQL!'
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.blackparrotlabs.io/post/architecture-pitfalls-dont-use-your-orm-entities-for-everything](https://www.blackparrotlabs.io/post/architecture-pitfalls-dont-use-your-orm-entities-for-everything)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When designing an application with JPA/Hibernate, I’ve encountered a common
    pattern that suggests developers should channel as many of their interactions
    as possible with their database via their persistence entities and ORM, avoiding
    writing SQL at all costs.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: This mostly seems to stem from a belief that this approach will maximise model
    flexibility and database portability. Sometimes it's also an aversion to learning
    SQL.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: There’s a grain of truth to the portability argument, but in practice, restricting
    yourself so significantly is usually a bad decision for a few reasons that I'll
    outline in this post.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Will you actually need to change between fundamentally different database
    technologies?**'
  id: totrans-split-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: It can be helpful to survey a few business and technical aspects of the project
    to see what latitude you can grant yourself.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: Validate whether you really need portability between SQL and NoSQL databases.
    If you assess that a relational data model is a good match for your requirements,
    it's quite unlikely you will change to a completely different model later on.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: Usually, it is not worth spending too much effort trying to preserve the ability
    to switch to an alternative storage technology (unless you are absolutely certain
    you need it).
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-19
  prefs: []
  type: TYPE_NORMAL
- en: Decisions in this area may fall to your technical architects and product management.
    You should make them aware of the burdens they are imposing with requirements
    like this.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: A much more common real-world requirement is portability between different SQL
    databases and versions — especially if you are an application vendor with multiple
    customers who might prefer to use different databases. More on this later.
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-23
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, good architectural practices (such as the use of [Hexagonal Architecture](https://jmgarridopaz.github.io/content/hexagonalarchitecture.html))
    will make it possible for you to refactor to a new storage technology in future
    without breaking public interfaces, which will almost certainly be a better approach
    than trying to achieve the [Sisyphean task](https://en.wikipedia.org/wiki/Sisyphus)
    of completely abstracting implementation code from its underlying persistence
    technology.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t run away from SQL, embrace it!**'
  id: totrans-split-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
- en: I suspect one of the greatest lies ever told in web application development
    is that if you use an ORM you can avoid writing and understanding SQL, “it’s just
    an implementation detail”. That might be true at first, but once you go beyond
    the basics that falls away quickly.
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: As an example, I quite commonly see the *findAll* plus filter antipattern. This
    is when you fetch all records from a collection and then use your application
    to perform some simple filtering to include/exclude records.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
- en: It’s much better to let the database do this kind of filtering. After all, it’s
    what all of the clever folk who work on databases spend a lot of time and effort
    optimising.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
- en: For most ORMs you have the option of writing analogues to SQL which can get
    you quite a long way. For example, JPA has JPQL and Hibernate has HQL. These let
    you build abstracted queries that should work on all databases that your ORM supports.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: The implication of this is that your team needs to embrace SQL and understand
    how to use it, rather than avoiding it by using application code instead.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
- en: 'To dispel a common source of anxiety on this: you don’t need to be a SQL guru
    to get started and become familiar with what you will need for the vast majority
    of your implementation requirements. There are also excellent resources and books
    available, I will link some below.'
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-39
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to some hyperbolic claims in the past, SQL isn’t going anywhere and
    is not just a legacy technology. Basic SQL knowledge is a good investment in your
    career and you will find it useful all over the place.
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
- en: '**Escaping the Native SQL trap **'
  id: totrans-split-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: ORM SQL analogues like JPQL will only get you so far, once you start doing more
    complex stuff you will find that you are straying beyond what is possible (your
    mileage will vary on this, depending on which ORM and version you are using).
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to create a materialised view, triggers, more complex
    query structures, etc, you usually won’t find this in your ORM.
  id: totrans-split-46
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: 'There are broadly two reasonable solutions to this:'
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: 1) Write strictly standards-compliant native SQL. This can work reasonably well
    for simpler situations, but many databases are not fully SQL standard compliant,
    so you will get some unwelcome surprises that require refactoring to find the
    lowest common denominator.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
- en: 2) Use a fluent SQL builder like [jOOQ](https://www.jooq.org) to handle the
    problem of “what SQL should I produce for this statement” on your behalf. This
    lets you write your query the way you prefer to write it, and jOOQ will figure
    out the right SQL statement for the database and version you are targeting. Equivalents
    exist for other languages.
  id: totrans-split-52
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
- en: As of today, I would say that the latter approach is better if you can go that
    direction — getting stuck maintaining native SQL can be a real hassle if you need
    to support multiple databases. If possible, let a library like jOOQ handle it
    for you!
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmatic query building**'
  id: totrans-split-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
- en: This is Java-specific, but I strongly recommend avoiding the JPA Criteria API.
    By modern standards, the design of the criteria builder is byzantine, and people
    find it extremely difficult to comprehend and maintain the code.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, there are now some great alternatives that won’t give you a headache.
    Again, two solutions that I can personally recommend are: [jOOQ](https://www.jooq.org)
    and [BlazePersistence](https://persistence.blazebit.com).'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: Both give you access to a modern, fluent API that lets you build queries programmatically
    without hassle.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: BlazePersistence is Hibernate-centric, but is free for all databases, whereas
    jOOQ has a much broader set of functionality but requires a modest per-developer
    fee for certain non-free enterprise databases. I think jOOQ is worth paying for,
    but you may have to battle with your company’s beancounters to get approval. If
    you're using common free and open source databases like Postgres, jOOQ is free.
  id: totrans-split-64
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: '**Projections are your friend**'
  id: totrans-split-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-67
  prefs: []
  type: TYPE_NORMAL
- en: A pattern I commonly see is to always return full ORM entities in queries, and
    then copy only the fields needed to DTOs (which are then returned to the caller).
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
- en: For simpler use-cases this is often fine, but it can have a significant performance
    impact for queries that are larger and/or more expensive. To put it another way,
    you are causing significant extra work in the database, serialisation, deserialisation
    and network traffic just to throw away most of the data. You’ll probably also
    notice that “real” ORM entities can have a fair bit of overhead associated with
    them; that's because key functionality that your ORM provides requires injection
    of proxies, interceptors, wrappers, etc.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you should consider using projections. In essence, this is simply a
    SQL query that returns only the data you need, with the results mapped into objects
    specifically designed to hold that data. This will often be flattened and simplified
    compared to your data model. The benefit is that it’s lightweight and removes
    unnecessary overhead. The downside is that these are typically not 'real' entities,
    so you can't do write operations with them — usually, you don't want to do that
    anyway!
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-73
  prefs: []
  type: TYPE_NORMAL
- en: As of writing, I find JPA/Hibernate’s inbuilt way of handling projections to
    be extremely inconvenient and difficult to maintain (e.g. verbose constructor-based
    syntax). I suspect this might be the reason so many people use the inefficient
    "application projection" way of doing things.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
- en: Instead, I recommend using [BlazePersistence’s Entity View](https://persistence.blazebit.com/documentation/1.6/entity-view/manual/en_US/)
    module or [jOOQ’s DTOs/projections.](https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos/)
    These both provide much more convenient ways of mapping, often with code generation
    to remove the requirement to keep your Java class "in sync" with your projection
    query.
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-77
  prefs: []
  type: TYPE_NORMAL
- en: Experience says use of projections pays off very quickly when returning bulk
    data and complex queries, so don’t be shy!
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-79
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, if you are using a newer version of Java, you can also make use
    of [records](https://docs.oracle.com/en/java/javase/19/language/records.html)
    to further reduce boilerplate noise.
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-81
  prefs: []
  type: TYPE_NORMAL
- en: A potential caveat  is that if you are using a second-level cache with your
    ORM, you may need to selectively flush it to avoid staleness issues. People have
    strong opinions on second level caches in ORMs, and I’m not going into that area
    here!
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
- en: Let's run through a quick example.
  id: totrans-split-85
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a listing endpoint that returns an entity, which is in turn
    related to another couple of entities. You want to return only a subset of the
    total fields (highlighted in red). By using the projection *ApiVersionSearchResult*
    you get a simple and compact representation which you can change without changing
    the rest of your API. And your database will thank you for using a query that
    only selects the fields it needs.
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, to achieve this you would create a simple query and ''project''
    it into your *ApiVersionSearchResult*. The specifics of implementation vary depending
    on your chosen approach. Here are a few popular ones:'
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, I've also seen systems that return "projections" using existing
    *@entity* objects with null fields and using Jackson's *Include.NON_NULL*, which
    means fields that are null don't appear in the serialised payload; a kind of poor
    man's projection. You are setting yourself up for problems in the future by doing
    this, so [I recommend avoiding such patterns](/post/dont-let-your-persistence-layer-bleed-into-your-presentation-layer).
  id: totrans-split-92
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t be afraid to mix and match**'
  id: totrans-split-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-95
  prefs: []
  type: TYPE_NORMAL
- en: Use your ORM for basic functions (often a large proportion of what you need),
    and use alternatives when you stray beyond its capabilities. Don’t feel you need
    to buy in completely to a single approach.
  id: totrans-split-96
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
- en: '**But, this is all so obvious!**'
  id: totrans-split-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-99
  prefs: []
  type: TYPE_NORMAL
- en: More experienced developers will often say this is all so obvious. Yet I’ve
    seen all of these mistakes numerous times, so evidently it bears repeating. As
    an industry, I suspect we’re not very good at passing down institutional knowledge
    on these subjects to younger developers.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
- en: ‍
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
- en: Plus, in software engineering, we love throwing away orthodoxy until we discover
    that we did it the old way for a reason. For example, the “SQL is dead” fad that
    started in about 2012, followed by the SQL renaissance when we realised it's actually
    quite good at a lot of things (and incorporated some of the ideas of the NoSQL stores,
    such as JSON support).
  id: totrans-split-102
  prefs: []
  type: TYPE_NORMAL
