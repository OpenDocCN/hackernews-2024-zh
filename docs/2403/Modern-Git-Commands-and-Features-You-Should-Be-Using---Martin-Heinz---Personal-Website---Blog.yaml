- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 12:49:11'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Modern Git Commands and Features You Should Be Using | Martin Heinz | Personal
    Website & Blog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://martinheinz.dev/blog/109](https://martinheinz.dev/blog/109)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All of us - software engineers - use `git` every day, however most people only
    ever touch the most basic of commands, such as `add`, `commit`, `push` or `pull`,
    like it's still 2005\.
  prefs: []
  type: TYPE_NORMAL
- en: Git however, introduced many features since then, and using them can make your
    life so much easier, so let's explore some of the recently added, modern `git`
    commands, that you should know about.
  prefs: []
  type: TYPE_NORMAL
- en: Switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'New since 2019, or more precisely, introduced Git version 2.23, is `git switch`
    which we can use to switch branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Well that's cool, but we've been switching branches in Git since ever using
    `git checkout`, why the need for a separate command? `git checkout` is a very
    versatile command - it can (among other things) check out or restore specific
    files or even specific commits, while the new `git switch` *only* switches the
    branch. Additionally, `switch` performs extra sanity checks that `checkout` doesn't,
    for example switch would abort operation if it would lead to loss of local changes.
  prefs: []
  type: TYPE_NORMAL
- en: Restore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another new subcommand/feature added in Git version 2.23 is `git restore`,
    which we can use to restore a file to last committed version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The comments in the above snippet explain the workings of various `git restore`.
    Generally speaking `git restore` replaces and simplifies some of the use cases
    of `git reset` and `git checkout` which are already overloaded features. See also
    [this docs section](https://git-scm.com/docs/git#_reset_restore_and_revert) for
    comparison of `revert`, `restore` and `reset`.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse Checkout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next one is `git sparse-checkout`, a little more obscure feature that was added
    in Git 2.25, which was released on January 13, 2020\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have a large monorepo, with microservices separated into individual
    directories, and commands such as `checkout` or `status` are super slow because
    of the repository size, but maybe you really just need to work with single subtree/directory.
    Well, `git sparse-checkout` to the rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the above example we first clone the repo without actually checking out all
    the files. We then use `git sparse-checkout init --cone` to configure `git` to
    only match files in the root of the repository. So, after running checkout we
    only have 3 files rather than whole tree. To then download/checkout particular
    directory, we use `git sparse-checkout set ...`.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, this can be very handy when working locally with huge
    repos, but it's equally useful in CI/CD for improving performance of a pipeline,
    when you only want to build/deploy part of the monorepo and there's no need to
    check out everything.
  prefs: []
  type: TYPE_NORMAL
- en: For detailed write-up about `sparse-checkout` see [this article](https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/).
  prefs: []
  type: TYPE_NORMAL
- en: Worktree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not uncommon, that one might have to work on multiple features in single
    application (repository) at the same time, or maybe a critical bug comes in while
    you're in the middle of working some feature request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In those situations, you either have to have multiple versions/branches of
    the repository cloned, or you need to stash/discard whatever you''ve been working
    on at the time. The answer to these situations is `git worktree`, released on
    September 24, 2018:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command allows us to have multiple branches of the same repository checked
    out at the same time. In the example above, we have 2 branches `dev` and `master`.
    Let's say we're working on feature in the `dev` branch, but we're told to make
    urgent bug fix. Rather than stashing the changes and resetting the branch, we
    create a new worktree in the `./hotfix` subdirectory from the `master` branch.
    We can then move to that directory, do our changes, push them and return to the
    original worktree.
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed write-up see [this article](https://opensource.com/article/21/4/git-worktree).
  prefs: []
  type: TYPE_NORMAL
- en: Bisect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Last but not least, `git bisect`, which isn't so new (Git 1.7.14, released on
    May 13, 2012), but most people are using only `git` features from around 2005,
    so I think it's worth showing anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the [docs page](https://git-scm.com/docs/git-bisect) describes it: *`git-bisect`
    - Use binary search to find the commit that introduced a bug*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We start by explicitly starting the bisection session with `git bisect start`,
    after which we provide the commit that doesn't work (most likely the `HEAD`) and
    the last known working commit or tag. With that information, `git` will check
    out a commit halfway between the *"bad"* and *"good"* commit. At which point we
    need to test whether that version has the bug or not, we then use `git bisect
    good` to tell `git` that it works or `git bisect bad` that it doesn't. We keep
    repeating the process until no commits are left and `git` will tell us which commit
    is the one that introduced the issue.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend checking out the [docs page](https://git-scm.com/docs/git-bisect)
    that shows couple more options for `git bisect` including visualizing, replaying
    or skipping commits.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you search for some problem relating to `git`, you will most likely end up
    on *StackOverflow* question with answer that has couple thousand upvotes. While
    this answer will be mostly likely still valid, it very well might be outdated,
    because it was written 10 years ago. Therefore, there might be a better, simpler,
    easier way to do it. So, when faced with some `git` issue, I would recommend to
    check [git docs](https://git-scm.com/) for more recent commands, all of which
    have a lot of great examples, or to explore `man` pages for lots of flags and
    options that were added to the good old commands over the years.
  prefs: []
  type: TYPE_NORMAL
