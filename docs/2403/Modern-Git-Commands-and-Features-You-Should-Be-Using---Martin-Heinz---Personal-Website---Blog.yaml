- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-29 12:49:11'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Modern Git Commands and Features You Should Be Using | Martin Heinz | Personal
    Website & Blog
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://martinheinz.dev/blog/109](https://martinheinz.dev/blog/109)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All of us - software engineers - use `git` every day, however most people only
    ever touch the most basic of commands, such as `add`, `commit`, `push` or `pull`,
    like it's still 2005\.
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Git however, introduced many features since then, and using them can make your
    life so much easier, so let's explore some of the recently added, modern `git`
    commands, that you should know about.
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: Switch
  id: totrans-split-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'New since 2019, or more precisely, introduced Git version 2.23, is `git switch`
    which we can use to switch branches:'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Well that's cool, but we've been switching branches in Git since ever using
    `git checkout`, why the need for a separate command? `git checkout` is a very
    versatile command - it can (among other things) check out or restore specific
    files or even specific commits, while the new `git switch` *only* switches the
    branch. Additionally, `switch` performs extra sanity checks that `checkout` doesn't,
    for example switch would abort operation if it would lead to loss of local changes.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Restore
  id: totrans-split-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another new subcommand/feature added in Git version 2.23 is `git restore`,
    which we can use to restore a file to last committed version:'
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The comments in the above snippet explain the workings of various `git restore`.
    Generally speaking `git restore` replaces and simplifies some of the use cases
    of `git reset` and `git checkout` which are already overloaded features. See also
    [this docs section](https://git-scm.com/docs/git#_reset_restore_and_revert) for
    comparison of `revert`, `restore` and `reset`.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: Sparse Checkout
  id: totrans-split-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next one is `git sparse-checkout`, a little more obscure feature that was added
    in Git 2.25, which was released on January 13, 2020\.
  id: totrans-split-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have a large monorepo, with microservices separated into individual
    directories, and commands such as `checkout` or `status` are super slow because
    of the repository size, but maybe you really just need to work with single subtree/directory.
    Well, `git sparse-checkout` to the rescue:'
  id: totrans-split-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the above example we first clone the repo without actually checking out all
    the files. We then use `git sparse-checkout init --cone` to configure `git` to
    only match files in the root of the repository. So, after running checkout we
    only have 3 files rather than whole tree. To then download/checkout particular
    directory, we use `git sparse-checkout set ...`.
  id: totrans-split-20
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, this can be very handy when working locally with huge
    repos, but it's equally useful in CI/CD for improving performance of a pipeline,
    when you only want to build/deploy part of the monorepo and there's no need to
    check out everything.
  id: totrans-split-21
  prefs: []
  type: TYPE_NORMAL
- en: For detailed write-up about `sparse-checkout` see [this article](https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/).
  id: totrans-split-22
  prefs: []
  type: TYPE_NORMAL
- en: Worktree
  id: totrans-split-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not uncommon, that one might have to work on multiple features in single
    application (repository) at the same time, or maybe a critical bug comes in while
    you're in the middle of working some feature request.
  id: totrans-split-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不少人可能需要同时在单个应用（仓库）中工作多个特性，或者可能在处理某个特性请求时出现了一个关键bug。
- en: 'In those situations, you either have to have multiple versions/branches of
    the repository cloned, or you need to stash/discard whatever you''ve been working
    on at the time. The answer to these situations is `git worktree`, released on
    September 24, 2018:'
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你可能需要克隆仓库的多个版本/分支，或者需要在当时存储/丢弃你正在处理的内容。这些情况的答案是`git worktree`，发布于2018年9月24日：
- en: '[PRE3]'
  id: totrans-split-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command allows us to have multiple branches of the same repository checked
    out at the same time. In the example above, we have 2 branches `dev` and `master`.
    Let's say we're working on feature in the `dev` branch, but we're told to make
    urgent bug fix. Rather than stashing the changes and resetting the branch, we
    create a new worktree in the `./hotfix` subdirectory from the `master` branch.
    We can then move to that directory, do our changes, push them and return to the
    original worktree.
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令允许我们同时在同一个仓库中检出多个分支。在上面的例子中，我们有2个分支`dev`和`master`。假设我们正在`dev`分支上开发一个特性，但被告知要进行紧急bug修复。我们可以在`master`分支的`./hotfix`子目录中创建一个新的工作树。然后我们可以切换到那个目录，进行我们的更改，推送它们，然后返回到原始的工作树。
- en: For a more detailed write-up see [this article](https://opensource.com/article/21/4/git-worktree).
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更详细的内容，请参阅[这篇文章](https://opensource.com/article/21/4/git-worktree)。
- en: Bisect
  id: totrans-split-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分查找
- en: Last but not least, `git bisect`, which isn't so new (Git 1.7.14, released on
    May 13, 2012), but most people are using only `git` features from around 2005,
    so I think it's worth showing anyway.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的，`git bisect`，虽然并不是很新（Git 1.7.14，2012年5月13日发布），但大多数人只使用了大约2005年左右的`git`功能，所以我认为还是值得展示的。
- en: 'As the [docs page](https://git-scm.com/docs/git-bisect) describes it: *`git-bisect`
    - Use binary search to find the commit that introduced a bug*:'
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[文档页面](https://git-scm.com/docs/git-bisect)所描述的：*`git-bisect` - 使用二分查找来找出引入bug的提交*：
- en: '[PRE4]'
  id: totrans-split-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We start by explicitly starting the bisection session with `git bisect start`,
    after which we provide the commit that doesn't work (most likely the `HEAD`) and
    the last known working commit or tag. With that information, `git` will check
    out a commit halfway between the *"bad"* and *"good"* commit. At which point we
    need to test whether that version has the bug or not, we then use `git bisect
    good` to tell `git` that it works or `git bisect bad` that it doesn't. We keep
    repeating the process until no commits are left and `git` will tell us which commit
    is the one that introduced the issue.
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要显式地使用`git bisect start`开始二分查找会话，之后我们提供不工作的提交（最可能是`HEAD`）和最后一个已知的工作提交或标签。有了这些信息，`git`将检出介于*"bad"*和*"good"*提交之间的提交。在这一点上，我们需要测试该版本是否有bug，然后使用`git
    bisect good`告诉`git`它工作正常或者`git bisect bad`告诉`git`它不工作。我们不断重复这个过程，直到没有提交剩余，`git`会告诉我们引入问题的是哪个提交。
- en: I recommend checking out the [docs page](https://git-scm.com/docs/git-bisect)
    that shows couple more options for `git bisect` including visualizing, replaying
    or skipping commits.
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议查看[文档页面](https://git-scm.com/docs/git-bisect)，其中展示了几个`git bisect`的更多选项，包括可视化、重播或跳过提交。
- en: Conclusion
  id: totrans-split-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: If you search for some problem relating to `git`, you will most likely end up
    on *StackOverflow* question with answer that has couple thousand upvotes. While
    this answer will be mostly likely still valid, it very well might be outdated,
    because it was written 10 years ago. Therefore, there might be a better, simpler,
    easier way to do it. So, when faced with some `git` issue, I would recommend to
    check [git docs](https://git-scm.com/) for more recent commands, all of which
    have a lot of great examples, or to explore `man` pages for lots of flags and
    options that were added to the good old commands over the years.
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你搜索与`git`相关的问题，很可能会最终看到*StackOverflow*上的一个答案，其点赞数可能达到几千。尽管这个答案可能仍然有效，但它很可能已经过时，因为它是10年前编写的。因此，可能有更好、更简单、更容易的方法来处理。因此，当面对某个`git`问题时，我建议查看[git文档](https://git-scm.com/)获取更新的命令，这些命令都有很多优秀的示例，或者探索`man`页面，查看多年来添加到这些经典命令中的许多标志和选项。
