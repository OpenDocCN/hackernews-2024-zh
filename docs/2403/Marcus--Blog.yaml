- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:59:02'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
- en: Marcus' Blog
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://mbuffett.com/posts/compressing-chess-moves/](https://mbuffett.com/posts/compressing-chess-moves/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'UPDATE: I’ve written a [new post](/posts/compressing-chess-moves-even-further/)
    with a new technique which is about 2.5x more efficient than this approach'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
- en: Chess notation has come a long way since [descriptive notation](https://en.wikipedia.org/wiki/Descriptive_notation),
    now we have nice and decipherable Standard Algebraic Notation, like `Qxf7` (queen
    takes on f7) or `Nf3` (knight takes on f3).
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
- en: This is a great text format, but a massive waste of space if you’re trying to
    store a lot of these. `Qxf7` takes 4 bytes, or 32 bits. Let’s do some rough back-of-the-envelope
    math of how much information is actually being transmitted though. This move affects
    one of 6 pieces (3 bits), this move is also a capture (1 bit), and it specifies
    a destination squuare (64 possibilities == 6 bits). Add those up, you get 10 bits.
    Far from the 32 bits that the textual representation needs.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
- en: Why do I care? I run a site that stores a *ton* of chess lines, something like
    100 million in total. Assume an average of 6 moves for each line, that’s 600 million
    moves. The database is growing large enough that querying it is IO-constrained.
    I want to speed up the reads from this database when I’m fetching thousands of
    lines.
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
- en: A first pass
  id: totrans-split-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First some general numbers:'
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
- en: Encoding a file or rank (a-h or 1-8) takes 3 bits (8 possibilities)
  id: totrans-split-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding a piece (k, q, r, b, n, p) takes 3 bits (6 possibilities)
  id: totrans-split-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding a square takes 6 bits (64 possibilities)
  id: totrans-split-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let’s see the pieces we’re working with for encoding a SAN.
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
- en: So let’s go with the most naive approach.
  id: totrans-split-16
  prefs: []
  type: TYPE_NORMAL
- en: Which piece was it? 3 bits
  id: totrans-split-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it a capture? 1 bit
  id: totrans-split-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we have to disabiguate it (ie `Ngf3`)? Maximum of 2 bits + 6 bits (this is
    explained more further down)
  id: totrans-split-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where did it go? 6 bits
  id: totrans-split-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it a promotion, and to which piece? 7 bits
  id: totrans-split-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it a check? 1 bit
  id: totrans-split-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it a checkmate? 1 bit
  id: totrans-split-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it a castle? Short or long? 2 bits
  id: totrans-split-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This gives us a total of `3+1+2+6+6+7+1+1+2 = 29` bits, or about 3.5 bytes per
    move. That’s not great though. A lot of moves actually take up less bits than
    that in text format.
  id: totrans-split-25
  prefs: []
  type: TYPE_NORMAL
- en: Getting smarter
  id: totrans-split-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first few bits
  id: totrans-split-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the first pass, we just encoded the piece that moved using 3 bits, but that
    leaves 2 unused permutations available, since there are only 6 pieces in chess.
    Luckily, there are two very common moves that fit neatly into this hole, those
    being short castles (`O-O`) and long castles (`O-O-O`).
  id: totrans-split-28
  prefs: []
  type: TYPE_NORMAL
- en: 'So we can encode the first 3 bits like so:'
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-split-30
  prefs: []
  type: TYPE_PRE
- en: The destination square
  id: totrans-split-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all cases except castling, you need to know the square that the piece is
    moving to, to reproduce the SAN. So we’ll skip this entirely when castling, but
    otherwise always include 6 bits for the destination square.
  id: totrans-split-32
  prefs: []
  type: TYPE_NORMAL
- en: Just kidding, pawn moves!
  id: totrans-split-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s another exception to the destination square rule that might not seem
    so obvious. Let’s take the move `exf6`. We know it’s a pawn move from the e-file,
    so we don’t really need to encode the file it’s capturing using 6 bits. After
    all, you’ll never see `exa6`. So in these cases instead of 6 bits for the destination
    square, we only need 4 (one for the direction, and one for the rank).
  id: totrans-split-34
  prefs: []
  type: TYPE_NORMAL
- en: But we can get even more clever here. Take `hxg6` for example. You know as soon
    as you see `hx`, that the file is going to be the g-file. So we don’t even need
    the extra bit to encode direction, we can just encode the file once, and the rank
    once.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
- en: 'So here’s the setup:'
  id: totrans-split-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Pawn capture from b-g files: 3 bits for the file you’re capturing from, 1 bit
    for the direction of the capture, and 3 bits for the rank'
  id: totrans-split-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Total: 10 bits for movement'
  id: totrans-split-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pawn capture from a and h files: 3 bits for the file you’re capturing from,
    3 bits for rank'
  id: totrans-split-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Total: 6 bits for movement'
  id: totrans-split-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: “Special” moves
  id: totrans-split-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s a bit of a waste to encode for each move, whether it’s a promotion, check,
    checkmate, capture, etc. After all, the vast majority of chess moves in a game
    are not any of these.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
- en: So we’ll devote one bit to determining whether a move is “special”. It means
    we have to use an extra bit for moves that are promotions/checks/captures, but
    it also means that we save a whole lot of bits for “regular” moves.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
- en: Promotions are nice, because even though there are 6 chess pieces, there are
    only 4 valid pieces that you can promote to (after all, you can’t promote to a
    King or Pawn). So we only need 2 bits instead of 3, to encode the promotion piece.
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-split-45
  prefs: []
  type: TYPE_PRE
- en: Disambiguation
  id: totrans-split-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Disambiguation is a bit thorny. You have to encode a surprising amount of information,
    to be able to decode the SAN exactly as you received it.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
- en: Take `Ngf3` for example. Besides the usual stuff you also need to encode the
    disambiguation (file=g). There are 3 different disambiguation possibilities (rank,
    file, or whole square), so we need 2 bits. One goes to waste but disambiguated
    moves aren’t that common and I can’t think of a nice way to take advantage of
    that last permutation.
  id: totrans-split-48
  prefs: []
  type: TYPE_NORMAL
- en: So we always use 2 bits, then either 3 bits for the rank, 3 bits for the file,
    or 6 bits for a whole square (very rare).
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-split-50
  prefs: []
  type: TYPE_PRE
- en: How does this do?
  id: totrans-split-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Move | Original bits | Encoded bits | Savings |'
  id: totrans-split-52
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-split-53
  prefs: []
  type: TYPE_TB
- en: '| e4 | 16 | 10 | 37.5% |'
  id: totrans-split-54
  prefs: []
  type: TYPE_TB
- en: '| exd5 | 32 | 12 | 62.5% |'
  id: totrans-split-55
  prefs: []
  type: TYPE_TB
- en: '| Nf3+ | 24 | 10 | 58.33% |'
  id: totrans-split-56
  prefs: []
  type: TYPE_TB
- en: '| Qxa5+ | 40 | 16 | 60% |'
  id: totrans-split-57
  prefs: []
  type: TYPE_TB
- en: '| cxd8=Q# | 56 | 16 | 71.43% |'
  id: totrans-split-58
  prefs: []
  type: TYPE_TB
- en: Not bad! We’re saving anywhere from 37.5% to 71.43% of the bits.
  id: totrans-split-59
  prefs: []
  type: TYPE_NORMAL
- en: PGNs
  id: totrans-split-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be thinking something like this: “Isn’t is sorta cheating to measure
    these in bits? Since you can only address one byte at a time, needing 10 bits
    for a move is virtually the same as 16 bits”'
  id: totrans-split-61
  prefs: []
  type: TYPE_NORMAL
- en: Well yes, that’s true and means that we get less savings when storing individual
    SANs. But they don’t account for the majority of what I’m storing, which are PGNs.
  id: totrans-split-62
  prefs: []
  type: TYPE_NORMAL
- en: 'PGNs are a way to store lines or games, and they look something like this:'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-split-64
  prefs: []
  type: TYPE_PRE
- en: This PGN is 759 bytes. There’s a ton of wasted space though. One byte between
    each move (the space). Then **at least 3 bytes** between full moves ( `2.`). This
    is sort of crazy, and if we combine our SAN encoding, we can compress this to
    be way smaller.
  id: totrans-split-65
  prefs: []
  type: TYPE_NORMAL
- en: If we encode the whole PGN using our SAN encoding, with no space between moves
    because we know once we’ve reached the end of a move, we can compress this specific
    759-byte PGN down to **195 bytes**, for a savings of **74%**.
  id: totrans-split-66
  prefs: []
  type: TYPE_NORMAL
- en: Impact
  id: totrans-split-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This hasn’t been deployed yet, I’m working on a ton of other performance improvements.
    But I anticipate this along with EPD compression (which I may write another at
    article on) will reduce the size of the database by about 70%. We’re almost entierly
    read-constrained, which should mean a 3x speedup for the most expensive queries
    we run.
  id: totrans-split-68
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  id: totrans-split-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another consideration here is the speed of doing this encoding/decoding; will
    it just cancel out the gains from having a much smaller database? Turns out, computers
    are really fast at this stuff, and conversion to and from this encoding is a rounding
    error.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
- en: I’m using Rust + the `bitvec` library. Encoding and then decoding 1000 moves
    takes about 600,000ns, or 0.6ms. I haven’t taken a performance pass at all either,
    and there’s a few places I know are very inefficient. I’m guessing I’m not even
    within 10x of optimal, but it should be good enough.
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
