- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-05-27 14:50:48'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: (How to Write a (Lisp) Interpreter (in Python))
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://www.norvig.com/lispy.html](https://www.norvig.com/lispy.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (How to Write a (Lisp) Interpreter (in Python))
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This page has two purposes: to describe how to implement computer language
    interpreters in general, and in particular to build an interpreter for most of
    the [*Scheme*](http://en.wikipedia.org/wiki/Scheme_(programming_language)) dialect
    of Lisp using [Python 3](http://python.org) as the implementation language. I
    call my language and interpreter *Lispy* ([**lis.py**](lis.py)). Years ago, I
    showed how to write a semi-practical Scheme interpreter [Java](jscheme.html) and
    in [in Common Lisp](http://books.google.com/books?id=QzGuHnDhvZIC&lpg=PA756&vq=scheme%20interpreter&dq=Paradigms%20of%20Artificial%20Intelligence%20Programming&pg=PA753#v=onepage&q&f=false)).
    This time around the goal is to demonstrate, as concisely and simply as possible,
    what [Alan Kay called](http://queue.acm.org/detail.cfm?id=1039523) "[*Maxwell''s
    Equations of Software*](http://www.righto.com/2008/07/maxwells-equations-of-software-examined.html)."'
  prefs: []
  type: TYPE_NORMAL
- en: Why does this matter? As [Steve Yegge said](http://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html),
    *"If you don't know how compilers work, then you don't know how computers work."*
    Yegge describes 8 problems that can be solved with compilers (or equally well
    with interpreters, or with Yegge's typical heavy dosage of cynicism).
  prefs: []
  type: TYPE_NORMAL
- en: Syntax and Semantics of Scheme Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *syntax* of a language is the arrangement of characters to form correct
    statements or expressions; the *semantics* is the meaning of those statements
    or expressions. For example, in the language of mathematical expressions (and
    in many programming languages), the syntax for adding one plus two is "1 + 2"
    and the semantics is the application of the addition operation to the two numbers,
    yielding the value 3\. We say we are *evaluating* an expression when we determine
    its value; we would say that "1 + 2" evaluates to 3, and write that as "1 + 2"
    ⇒ 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scheme syntax is different from most other programming languages. Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Java |        | Scheme |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| `**if** (x.val() > 0) {   **return** fn(A[i] + 3 * i,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**new** String[] {"one", "two"});'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}` |   | `(**if** (> (val x) 0)     (fn (+ (aref A i) (* 3 i))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (**quote** (one two)))` |
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Java has a wide variety of syntactic conventions (keywords, infix operators,
    three kinds of brackets, operator precedence, dot notation, quotes, commas, semicolons),
    but Scheme syntax is much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: Scheme programs consist solely of *expressions*. There is no statement/expression
    distinction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers (e.g. `1`) and symbols (e.g. `A`) are called *atomic expressions*; they
    cannot be broken into pieces. These are similar to their Java counterparts, except
    that in Scheme, operators such as `+` and `>` are symbols too, and are treated
    the same way as `A` and `fn`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Everything else is a *list expression*: a "(", followed by zero or more expressions,
    followed by a ")". The first element of the list determines what it means:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list starting with a keyword, e.g. `(if ...)`, is a *special form*; the meaning
    depends on the keyword.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A list starting with a non-keyword, e.g. `(fn ...)`, is a function call.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The beauty of Scheme is that the full language only needs 5 keywords and 8 syntactic
    forms. In comparison, Python has 33 keywords and [110](https://docs.python.org/3/reference/grammar.html)
    syntactic forms, and Java has 50 keywords and [133](https://docs.oracle.com/javase/specs/jls/se7/html/jls-18.html)
    syntactic forms. All those parentheses may seem intimidating, but Scheme syntax
    has the virtues of simplicity and consistency. (Some have joked that "Lisp" stands
    for "[***L**ots of **I**rritating **S**illy **P**arentheses*](http://www.google.com/search?q=Lots+of+Irritating+Silly+Parentheses)";
    I think it stand for "[***L**isp **I**s **S**yntactically **P**ure*](http://www.google.com/search?hl=en&as_q=&as_epq=Lisp+Is+Syntactically+Pure)".)
  prefs: []
  type: TYPE_NORMAL
- en: In this page we will cover all the important points of the Scheme language and
    its interpretation (omitting some minor details), but we will take two steps to
    get there, defining a simplified language first, before defining the near-full
    Scheme language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Language 1: Lispy Calculator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Lispy Calculator* is a subset of Scheme using only five syntactic forms (two
    atomic, two special forms, and the procedure call). Lispy Calculator lets you
    do any computation you could do on a typical calculator—as long as you are comfortable
    with prefix notation. And you can do two things that are not offered in typical
    calculator languages: "if" expressions, and the definition of new variables. Here''s
    an example program, that computes the area of a circle of radius 10, using the
    formula π *r*²:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a table of all the allowable expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Syntax | Semantics and Example |'
  prefs: []
  type: TYPE_TB
- en: '| [variable reference](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.1)
    | *symbol* | A symbol is interpreted as a variable name; its value is the variable''s
    value. Example: `r` ⇒ `10` (assuming `r` was previously defined to be 10) |'
  prefs: []
  type: TYPE_TB
- en: '| [constant literal](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.2)
    | *number* | A number evaluates to itself. Examples: `12 ⇒ 12` *or* `-3.45e+6
    ⇒ -3.45e+6` |'
  prefs: []
  type: TYPE_TB
- en: '| [conditional](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.5)
    | `(if` *test conseq alt*`)` | Evaluate *test*; if true, evaluate and return *conseq*;
    otherwise *alt*. Example: `(if (> 10 20) (+ 1 1) (+ 3 3)) ⇒ 6` |'
  prefs: []
  type: TYPE_TB
- en: '| [definition](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-8.html#%_sec_5.2)
    | `(define` *symbol* *exp*`)` | Define a new variable and give it the value of
    evaluating the expression *exp*. Examples: `(define r 10)` |'
  prefs: []
  type: TYPE_TB
- en: '| [procedure call](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.3)
    | `(`*proc arg...*`)` | If *proc* is anything other than one of the symbols `if,
    define,` or `quote` then it is treated as a procedure. Evaluate *proc* and all
    the *args*, and then the procedure is applied to the list of *arg* values. Example:
    `(sqrt (* 2 8)) ⇒ 4.0` |'
  prefs: []
  type: TYPE_TB
- en: In the Syntax column of this table, *symbol* must be a symbol, *number* must
    be an integer or floating point number, and the other italicized words can be
    any expression. The notation *arg...* means zero or more repetitions of *arg*.
  prefs: []
  type: TYPE_NORMAL
- en: What A Language Interpreter Does
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A language interpreter has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parsing:** The parsing component takes an input program in the form of a
    sequence of characters, verifies it according to the *syntactic rules* of the
    language, and translates the program into an internal representation. In a simple
    interpreter the internal representation is a tree structure (often called an *abstract
    syntax tree*) that closely mirrors the nested structure of statements or expressions
    in the program. In a language translator called a *compiler* there is often a
    series of internal representations, starting with an abstract syntax tree, and
    progressing to a sequence of instructions that can be directly executed by the
    computer. The Lispy parser is implemented with the function `parse`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Execution:** The internal representation is then processed according to the
    *semantic rules* of the language, thereby carrying out the computation. Lispy''s
    execution function is called `eval` (note this shadows Python''s built-in function
    of the same name).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a picture of the interpretation process:'
  prefs: []
  type: TYPE_NORMAL
- en: program ➡ `parse` ➡ abstract-syntax-tree ➡ `eval` ➡ result
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And here is a short example of what we want `parse` and `eval` to be able to
    do (`begin` evaluates each expression in order and returns the final one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Type Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s be explicit about our representations for Scheme objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Parsing: `parse`, `tokenize` and `read_from_tokens`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parsing is traditionally separated into two parts: *lexical analysis*, in which
    the input character string is broken up into a sequence of *tokens*, and *syntactic
    analysis*, in which the tokens are assembled into an abstract syntax tree. The
    Lispy tokens are parentheses, symbols, and numbers. There are many tools for lexical
    analysis (such as Mike Lesk and Eric Schmidt''s [lex](http://dinosaur.compilertools.net/#lex)),
    but for now we''ll use a very simple tool: Python''s `str.split`. The function
    `tokenize` takes as input a string of characters; it adds spaces around each paren,
    and then calls `str.split` to get a list of tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we apply tokenize to our sample program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function `parse` will take a string representation of a program as input,
    call `tokenize` to get a list of tokens, and then call `read_from_tokens` to assemble
    an abstract syntax tree. `read_from_tokens` looks at the first token; if it is
    a `'')''` that''s a syntax error. If it is a `''(''`, then we start building up
    a list of sub-expressions until we hit a matching `'')''`. Any non-parenthesis
    token must be a symbol or number. We''ll let Python make the distinction between
    them: for each non-paren token, first try to interpret it as an int, then as a
    float, and if it is neither of those, it must be a symbol. Here is the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`parse` works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We're almost ready to define `eval`. But we need one more concept first.
  prefs: []
  type: TYPE_NORMAL
- en: Environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An environment is a mapping from variable names to their values. By default,
    `eval` will use a global environment that includes the names for a bunch of standard
    functions (like `sqrt` and `max`, and also operators like `*`). This environment
    can be augmented with user-defined variables, using the expression `(define *symbol
    value*)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluation: `eval`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready for the implementation of `eval`. As a refresher, we repeat
    the table of Lispy Calculator forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Syntax | Semantics and Example |'
  prefs: []
  type: TYPE_TB
- en: '| [variable reference](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.1)
    | *symbol* | A symbol is interpreted as a variable name; its value is the variable''s
    value. Example: `r` ⇒ `10` (assuming `r` was previously defined to be 10) |'
  prefs: []
  type: TYPE_TB
- en: '| [constant literal](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.2)
    | *number* | A number evaluates to itself. Examples: `12 ⇒ 12` *or* `-3.45e+6
    ⇒ -3.45e+6` |'
  prefs: []
  type: TYPE_TB
- en: '| [conditional](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.5)
    | `(if` *test conseq alt*`)` | Evaluate *test*; if true, evaluate and return *conseq*;
    otherwise *alt*. Example: `(if (> 10 20) (+ 1 1) (+ 3 3)) ⇒ 6` |'
  prefs: []
  type: TYPE_TB
- en: '| [definition](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-8.html#%_sec_5.2)
    | `(define` *symbol* *exp*`)` | Define a new variable and give it the value of
    evaluating the expression *exp*. Examples: `(define r 10)` |'
  prefs: []
  type: TYPE_TB
- en: '| [procedure call](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.3)
    | `(`*proc arg...*`)` | If *proc* is anything other than one of the symbols `if,
    define,` or `quote` then it is treated as a procedure. Evaluate *proc* and all
    the *args*, and then the procedure is applied to the list of *arg* values. Example:
    `(sqrt (* 2 8)) ⇒ 4.0` |'
  prefs: []
  type: TYPE_TB
- en: 'Here is the code for `eval`, which closely follows the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*We''re done!* You can see it all in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Interaction: A REPL'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is tedious to have to enter `eval(parse("..."))` all the time. One of Lisp''s
    great legacies is the notion of an interactive read-eval-print loop: a way for
    a programmer to enter an expression, and see it immediately read, evaluated, and
    printed, without having to go through a lengthy build/compile/run cycle. So let''s
    define the function `repl` (which stands for read-eval-print-loop), and the function
    `schemestr` which returns a string representing a Scheme object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is `repl` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Language 2: Full Lispy'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now extend our language with three new special forms, giving us a much
    more nearly-complete Scheme subset:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Syntax | Semantics and Example |'
  prefs: []
  type: TYPE_TB
- en: '| [quotation](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.2)
    | `(quote` *exp*`)` | Return the *exp* literally; do not evaluate it. Example:
    `(quote (+ 1 2)) ⇒ (+ 1 2)` |'
  prefs: []
  type: TYPE_TB
- en: '| [assignment](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.6)
    | `(set!` *symbol exp*`)` | Evaluate *exp* and assign that value to *symbol*,
    which must have been previously defined (with a `define` or as a parameter to
    an enclosing procedure). Example: `(set! r2 (* r r))` |'
  prefs: []
  type: TYPE_TB
- en: '| [procedure](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.4)
    | `(lambda (`*symbol...*`)` *exp*`)` | Create a procedure with parameter(s) named
    *symbol...* and *exp* as the body. Example: `(lambda (r) (* pi (* r r)))` |'
  prefs: []
  type: TYPE_TB
- en: 'The `lambda` special form (an obscure nomenclature choice that refers to Alonzo
    Church''s [lambda calculus](http://en.wikipedia.org/wiki/Lambda_calculus)) creates
    a procedure. We want procedures to work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are two steps here. In the first step, the `lambda` expression is evaluated
    to create a procedure, one which refers to the global variables `pi` and `*`,
    takes a single parameter, which it calls `r`. This procedure is used as the value
    of the new variable `circle-area`. In the second step, the procedure we just defined
    is the value of `circle-area`, so it is called, with the value 10 as the argument.
    We want `r` to take on the value 10, but it wouldn't do to just set `r` to 10
    in the global environment. What if we were using `r` for some other purpose? We
    wouldn't want a call to `circle-area` to alter that value. Instead, we want to
    arrange for there to be a *local* variable named `r` that we can set to 10 without
    worrying about interfering with any global variable that happens to have the same
    name. The process for calling a procedure introduces these new local variable(s),
    binding each symbol in the parameter list of. the function to the corresponding
    value in the argument list of the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Redefining `Env` as a Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle local variables, we will redefine `Env` to be a subclass of `dict`.
    When we evaluate `(circle-area (+ 5 5))`, we will fetch the procedure body, `(*
    pi (* r r))`, and evaluate it in an environment that has `r` as the sole local
    variable (with value 10), but also has the global environment as the "outer" environment;
    it is there that we will find the values of `*` and `pi`. In other words, we want
    an environment that looks like this, with the local (blue) environment nested
    inside the outer (red) global environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `pi: 3.141592653589793 *: <built-in function mul>'
  prefs: []
  type: TYPE_NORMAL
- en: '...`  |'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look up a variable in such a nested environment, we look first at the
    innermost level, but if we don''t find the variable name there, we move to the
    next outer level. Procedures and environments are intertwined, so let''s define
    them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that every procedure has three components: a list of parameter names,
    a body expression, and an environment that tells us what other variables are accessible
    from the body. For a procedure defined at the top level this will be the global
    environment, but it is also possible for a procedure to refer to the local variables
    of the environment in which it was *defined* (and not the environment in which
    it is *called*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An environment is a subclass of `dict`, so it has all the methods that `dict`
    has. In addition there are two methods: the constructor `__init__` builds a new
    environment by taking a list of parameter names and a corresponding list of argument
    values, and creating a new environment that has those {variable: value} pairs
    as the inner part, and also refers to the given `outer` environment. The method
    `find` is used to find the right environment for a variable: either the inner
    one or an outer one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how these all go together, here is the new definition of `eval`. Note
    that the clause for variable reference has changed: we now have to call `env.find(x)`
    to find at what level the variable `x` exists; then we can fetch the value of
    `x` from that level. (The clause for `define` has not changed, because a `define`
    always adds a new variable to the innermost environment.) There are two new clauses:
    for `set!`, we find the environment level where the variable exists and set it
    to a new value. With `lambda`, we create a new procedure object with the given
    parameter list, body, and environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To appreciate how procedures and environments work together, consider this
    program and the environment that gets formed when we evaluate `(account1 -20.00)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `(define **make-account**'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;   (lambda (**balance**)'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;     (lambda (**amt**)       (begin **(set! balance (+ balance amt))**'
  prefs: []
  type: TYPE_NORMAL
- en: balance)))) &#124;
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define **account1** (make-account 100.00))'
  prefs: []
  type: TYPE_NORMAL
- en: (account1 -20.00)`` &#124;
  prefs: []
  type: TYPE_NORMAL
- en: '|   |'
  prefs: []
  type: TYPE_TB
- en: '&#124; **`+`**: <built-in operator add> `**make-account**: <a Procedure>'
  prefs: []
  type: TYPE_NORMAL
- en: '``**account1**: <a Procedure>[PRE15]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> repl()'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (define circle-area (lambda (r) (* pi (* r r))))
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (circle-area 3)
  prefs: []
  type: TYPE_NORMAL
- en: '28.274333877'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (define fact (lambda (n) (if (<= n 1) 1 (* n (fact (- n 1))))))
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (fact 10)
  prefs: []
  type: TYPE_NORMAL
- en: '3628800'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (fact 100)
  prefs: []
  type: TYPE_NORMAL
- en: '9332621544394415268169923885626670049071596826438162146859296389521759999322991'
  prefs: []
  type: TYPE_NORMAL
- en: '5608941463976156518286253697920827223758251185210916864000000000000000000000000'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (circle-area (fact 10))
  prefs: []
  type: TYPE_NORMAL
- en: '4.1369087198e+13'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (define first car)
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (define rest cdr)
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (define count (lambda (item L) (if L (+ (equal? item (first L)) (count
    item (rest L))) 0)))
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (count 0 (list 0 1 2 3 0 0))
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (count (quote the) (quote (the more the merrier the bigger the better)))
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (define twice (lambda (x) (* 2 x)))
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (twice 5)
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (define repeat (lambda (f) (lambda (x) (f (f x)))))
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> ((repeat twice) 10)
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> ((repeat (repeat twice)) 10)
  prefs: []
  type: TYPE_NORMAL
- en: '160'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> ((repeat (repeat (repeat twice))) 10)
  prefs: []
  type: TYPE_NORMAL
- en: '2560'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> ((repeat (repeat (repeat (repeat twice)))) 10)
  prefs: []
  type: TYPE_NORMAL
- en: '655360'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (pow 2 16)
  prefs: []
  type: TYPE_NORMAL
- en: '65536.0'
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (define fib (lambda (n) (if (< n 2) 1 (+ (fib (- n 1)) (fib (- n 2))))))
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (define range (lambda (a b) (if (= a b) (quote ()) (cons a (range (+
    a 1) b)))))
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (range 0 10)
  prefs: []
  type: TYPE_NORMAL
- en: (0 1 2 3 4 5 6 7 8 9)
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (map fib (range 0 10))
  prefs: []
  type: TYPE_NORMAL
- en: (1 1 2 3 5 8 13 21 34 55)
  prefs: []
  type: TYPE_NORMAL
- en: lis.py> (map fib (range 0 20))
  prefs: []
  type: TYPE_NORMAL
- en: (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a language with procedures, variables, conditionals (`if`), and
    sequential execution (the `begin` procedure). If you are familiar with other languages,
    you might think that a `while` or `for` loop would be needed, but Scheme manages
    to do without these just fine. The Scheme report says "Scheme demonstrates that
    a very small number of rules for forming expressions, with no restrictions on
    how they are composed, suffice to form a practical and efficient programming language."
    In Scheme you iterate by defining recursive functions.
  prefs: []
  type: TYPE_NORMAL
- en: How Small/Fast/Complete/Good is Lispy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In which we judge Lispy on several criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: True Story
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To back up the idea that it can be very helpful to know how interpreters work,
    here''s a story. Way back in 1984 I was writing a Ph.D. thesis. This was before
    LaTeX, before Microsoft Word for Windows—we used troff. Unfortunately, troff had
    no facility for forward references to symbolic labels: I wanted to be able to
    write "As we will see on page @theorem-x" and then write something like "@(set
    theorem-x \n%)" in the appropriate place (the troff register \n% holds the page
    number). My fellow grad student Tony DeRose felt the same need, and together we
    sketched out a simple Lisp program that would handle this as a preprocessor. However,
    it turned out that the Lisp we had at the time was good at reading Lisp expressions,
    but so slow at reading character-at-a-time non-Lisp expressions that our program
    was annoying to use.'
  prefs: []
  type: TYPE_NORMAL
- en: From there Tony and I split paths. He reasoned that the hard part was the interpreter
    for expressions; he needed Lisp for that, but he knew how to write a tiny C routine
    for reading and echoing the non-Lisp characters and link it in to the Lisp program.
    I didn't know how to do that linking, but I reasoned that writing an interpreter
    for this trivial language (all it had was set variable, fetch variable, and string
    concatenate) was easy, so I wrote an interpreter in C. So, ironically, Tony wrote
    a Lisp program (with one small routine in C) because he was a C programmer, and
    I wrote a C program because I was a Lisp programmer.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we both got our theses done ([Tony](http://www.eecs.berkeley.edu/Pubs/TechRpts/1985/6081.html),
    [Peter](http://www.eecs.berkeley.edu/Pubs/TechRpts/1987/5995.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The Whole Thing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The whole program is here: [lis.py](lis.py).'
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about Scheme consult some of the fine books (by [Friedman and
    Fellesein](http://books.google.com/books?id=xyO-KLexVnMC&lpg=PP1&dq=scheme%20programming%20book&pg=PP1#v=onepage&q&f=false),
    [Dybvig](http://books.google.com/books?id=wftS4tj4XFMC&lpg=PA300&dq=scheme%20programming%20book&pg=PP1#v=onepage&q&f=false),
    [Queinnec](http://books.google.com/books?id=81mFK8pqh5EC&lpg=PP1&dq=scheme%20programming%20book&pg=PP1#v=onepage&q&f=false),
    [Harvey and Wright](http://www.eecs.berkeley.edu/~bh/ss-toc2.html) or [Sussman
    and Abelson](http://mitpress.mit.edu/sicp/)), videos (by [Abelson and Sussman](http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/)),
    tutorials (by [Dorai](http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html),
    [PLT](http://docs.racket-lang.org/quick/index.html), or [Neller](http://cs.gettysburg.edu/~tneller/cs341/scheme-intro/index.html)),
    or the [reference manual](http://www.schemers.org/Documents/Standards/R5RS/HTML).
  prefs: []
  type: TYPE_NORMAL
- en: I also have another page describing a [more advanced version of Lispy](http://norvig.com/lispy2.html).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Peter Norvig](http://norvig.com)*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
