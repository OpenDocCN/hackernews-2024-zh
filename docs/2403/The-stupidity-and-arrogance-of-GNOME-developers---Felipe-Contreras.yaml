- en: <!--yml
  id: totrans-split-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-split-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分类：未分类
- en: 'date: 2024-05-29 12:30:14'
  id: totrans-split-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-05-29 12:30:14
- en: -->
  id: totrans-split-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: The stupidity and arrogance of GNOME developers | Felipe Contreras
  id: totrans-split-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNOME开发者的愚蠢和傲慢 | 费利佩·康特雷拉斯
- en: 来源：[https://felipec.wordpress.com/2024/03/18/stupid-gnome-developers/](https://felipec.wordpress.com/2024/03/18/stupid-gnome-developers/)
  id: totrans-split-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://felipec.wordpress.com/2024/03/18/stupid-gnome-developers/](https://felipec.wordpress.com/2024/03/18/stupid-gnome-developers/)
- en: 'About a year ago I wrote a blog post explaining how the horrible development
    practices of people in the GNOME project lead to a bug in vte that was annoying
    me, even though I don’t use GNOME: [GNOME’s horrid coding practices](https://felipec.wordpress.com/2023/02/24/gnomes-horrid-coding-practices/).'
  id: totrans-split-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大约一年前，我写了一篇博文，解释了GNOME项目中人们可怕的开发实践导致了 vte 中的一个 bug，尽管我不使用 GNOME，它仍然困扰着我：[GNOME可怕的编码实践](https://felipec.wordpress.com/2023/02/24/gnomes-horrid-coding-practices/)。
- en: The post is highly technical, but if you manage to go through it, it’s clear
    they made a mistake, and they refused to acknowledge their mistake, even though
    several users complained about the bug for years (not just me).
  id: totrans-split-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章非常技术性，但如果你能看懂，很明显他们犯了一个错误，并且他们拒绝承认自己的错误，尽管多位用户多年来都抱怨过这个 bug（不只是我）。
- en: But the real problem is not that they refused to fix the bug, it’s that I provided
    them with a perfectly valid fix, and they refused to even look into the merit
    of it, only because of their ego.
  id: totrans-split-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但真正的问题不是他们拒绝修复 bug，而是我给了他们一个完全有效的修复方案，他们却因为自负而连看都不愿看一眼。
- en: 'Today there’s an update: they came up with a [fix of their own](https://gitlab.gnome.org/GNOME/vte/-/commit/1bcf4bca).
    However, the irony is that their fix is an obfuscated and poorer version of my
    own fix.'
  id: totrans-split-9
  prefs: []
  type: TYPE_NORMAL
  zh: 今天有一个更新：他们提出了一个[他们自己的修复方案](https://gitlab.gnome.org/GNOME/vte/-/commit/1bcf4bca)。然而，讽刺的是，他们的修复版本是我自己修复方案的一个模糊和较差的版本。
- en: What’s the problem then? Many are going to presume this is some kind of “I told
    you so” retribution to elevate my ego. No, the problem is that my fix was available
    **three years ago**. All they managed to accomplish by ignoring and censoring
    me, is hurt their own users.
  id: totrans-split-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题是什么？很多人会认为这是某种“我告诉过你”的报复，来提升我的自尊心。不，问题是我的修复方案**三年前**就已经可用了。他们忽视和审查我，唯一达到的结果就是伤害了他们自己的用户。
- en: They could have applied my fix a long time ago.
  id: totrans-split-11
  prefs: []
  type: TYPE_NORMAL
  zh: 他们本可以很久以前应用我的修复。
- en: 'Now, before going into the complex details, I think it’s useful to clarify
    that the bug was introduced because they were not sending a signal of an event,
    when the event happens. But even though the issue is complex, the fix is **extremely
    simple**: send the signal of the event right after the event happens. That’s literally
    it. That’s what my fix did, and that’s what they ultimately ended up doing.'
  id: totrans-split-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在深入复杂细节之前，我认为澄清一下很有必要：这个 bug 是因为在事件发生时，他们没有发送事件信号。但即使问题复杂，修复却**非常简单**：事件发生后立即发送事件信号。就是这样简单。这就是我的修复所做的，最终他们也是这样做的。
- en: For three years they argued that delaying the signal was good, only to come
    up with a patch that doesn’t delay the signal, which is exactly what I argued
    should be the case in the first place.
  id: totrans-split-13
  prefs: []
  type: TYPE_NORMAL
  zh: 三年来，他们争辩说延迟信号是好事，结果他们提出了一个不延迟信号的补丁，这正是我最初主张的情况。
- en: If they made a mistake and realized it several years later, that would be understandably
    human, but that’s not what’s happening. I’m arguing they are stupid not because
    they made mistakes, but because they still haven’t realized that’s what they did.
    So it’s very likely that they will make the same mistakes again.
  id: totrans-split-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们犯了一个错误，并几年后意识到了，那是可以理解的人性，但事情并非如此。我认为他们愚蠢的原因不是因为他们犯了错误，而是因为他们仍然没有意识到他们所犯的错误。因此，他们很可能会再次犯同样的错误。
- en: 'This is a summary of the mistakes they did when dealing with this regression:'
  id: totrans-split-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是他们处理这个回归问题时所犯的错误的总结：
- en: Did not detect the introduction of a regression
  id: totrans-split-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有检测到回归的引入
- en: Refused to revert the change that introduced the regression
  id: totrans-split-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝撤销引入回归的更改
- en: Worked around the regression
  id: totrans-split-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决了这个回归问题
- en: Refused a perfectly valid fix
  id: totrans-split-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝一个完全有效的修复方案
- en: Refused to consider the merit of the valid fix
  id: totrans-split-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝考虑有效修复的优点
- en: Refused to consider other alternatives to mitigate the regression
  id: totrans-split-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝考虑其他减轻回归问题的替代方案
- en: Locked and censored the issue in their tracker
  id: totrans-split-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定并审查了他们的问题跟踪器中的问题
- en: Refused to acknowledge there was a bug despite multiple reports
  id: totrans-split-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管有多次报告，拒绝承认存在错误
- en: Ultimately applied the valid fix anyway
  id: totrans-split-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终仍然应用了有效的修复方案
- en: Never acknowledged the valid fix was already available
  id: totrans-split-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从未承认有效的修复方案已经可用
- en: The issue
  id: totrans-split-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'To understand the issue we don’t need to understand everything there is about
    virtual terminals, all we need to understand are **two signals**: `child-exited`
    and `end-of-stream`.'
  id: totrans-split-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个问题，我们不需要理解虚拟终端的所有内容，我们只需要理解**两个信号**：`子进程退出`和`流结束`。
- en: child-exited
  id: totrans-split-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子进程退出
- en: When you run a terminal (like gnome-terminal) there is always a process that
    is driving everything, for example `bash`. This is the “child” process.
  id: totrans-split-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个终端（比如gnome-terminal），总会有一个驱动一切的进程，比如`bash`。这就是“子”进程。
- en: When the child exits, typically you would want the terminal to exit as well
    (although you can configure it to remain open). Ultimately it’s up to the end
    user to decide what to do, but the job of the terminal library — vte in this case
    — is to provide the relevant information to the terminal — like gnome-terminal
    — in order to do what the end user wants.
  id: totrans-split-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当子进程退出时，通常希望终端也退出（尽管可以配置为保持打开）。最终还是由最终用户决定如何处理，但终端库 — 在这种情况下是vte — 的工作是向终端（如gnome-terminal）提供相关信息，以便按照最终用户的意愿执行操作。
- en: This is a convoluted way of saying that when bash exits, that needs to be communicated
    to gnome-terminal so it can exit right away — as 99.9% of the users would want.
  id: totrans-split-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种复杂的方式来表达，当bash退出时，需要将这一信息传达给gnome-terminal，以便它可以立即退出 — 因为99.9%的用户都希望如此。
- en: end-of-stream
  id: totrans-split-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流结束
- en: 'In most cases the stream ends when the child exits. By “stream” we can think
    of the standard output. So when bash exits, there would be no more output — because
    the program cannot execute any more commands: it’s done. Once the program is done,
    all the file descriptors are cosed — including `stdout`.'
  id: totrans-split-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，子进程退出时流就结束了。所谓的“流”指的是标准输出。因此，当bash退出时，就不会再有输出了 — 因为程序无法再执行任何命令：它已经完成了。一旦程序完成，所有的文件描述符都会关闭
    — 包括`stdout`。
- en: '[PRE0]'
  id: totrans-split-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But this isn’t always the case. A process can always launch subprocesses. And
    each one of those subprocesses would inherit the standard streams. So all the
    children of bash are going to inherit the standard output of bash.
  id: totrans-split-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但并不总是这样。一个进程总是可以启动子进程。而每一个子进程都会继承父进程的标准输出。
- en: '[PRE1]'
  id: totrans-split-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the above example, bash exits immediately, but it spawned a child, and that
    child is going to print “bye grandpa” after 10 seconds. This means the `stdout`
    file descriptor cannot be closed yet (not until all the children of bash exit).
  id: totrans-split-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，bash立即退出，但它产生了一个子进程，在10秒后会打印“bye grandpa”。这意味着`stdout`文件描述符不能立即关闭（直到bash的所有子进程退出）。
- en: So the `end-of-stream` signal is **not** going to be sent when the child exits,
    but when the grandchild exits, because the `stdout` file descriptor is going to
    remain open when bash exits.
  id: totrans-split-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`流结束`信号**不会**在子进程退出时发送，而是在孙子进程退出时发送，因为当bash退出时，`stdout`文件描述符仍然会保持打开状态。
- en: Give it to me straight
  id: totrans-split-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直截了当地说
- en: What does this mean in practical terms?
  id: totrans-split-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这在实际应用中意味着什么？
- en: 'In practical terms it means that when bash exits, the `stdout` file descriptor
    might not be closed yet. In other words: the `end-of-stream` signal might come
    **after** the `child-exited` signal.'
  id: totrans-split-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，这意味着当bash退出时，`stdout`文件描述符可能还没有关闭。换句话说：`流结束`信号可能会在`子进程退出`信号**之后**才到来。
- en: The [bug](https://gitlab.gnome.org/GNOME/vte/-/issues/204) that was introduced
    in 2019, is that if the `end-of-stream` signal hadn’t come yet, then the `child-exited`
    signal was delayed. And this delay could be **infinite**.
  id: totrans-split-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[2019年引入的bug](https://gitlab.gnome.org/GNOME/vte/-/issues/204)是这样的：如果“流结束”信号还没来，那么“子进程退出”信号就会延迟。这个延迟可能是**无限**的。'
- en: So how on Earth would a terminal — like gnome-terminal — know when to exit?
    It didn’t. And that was the regression.
  id: totrans-split-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么gnome-terminal这样的终端究竟何时知道退出呢？它没有知道。这就是退步。
- en: 'To exit immediately, the terminal needed to receive the `child-exited` signal
    **immediately**. And after the commit [7888602c](https://gitlab.gnome.org/GNOME/vte/-/commit/7888602c)
    (lib: Rework child exit and EOF handling) that wasn’t happening anymore: it was
    delayed *ad infinitum*.'
  id: totrans-split-44
  prefs: []
  type: TYPE_NORMAL
  zh: '要立即退出，终端需要立即接收到`子进程退出`信号。但在[7888602c提交](https://gitlab.gnome.org/GNOME/vte/-/commit/7888602c)之后（lib:
    Rework child exit and EOF handling），这种情况不再发生：它被*无限期地*延迟了。'
- en: First the delay was infinite, then it was capped to [5 seconds](https://gitlab.gnome.org/GNOME/vte/-/commit/058adf5f),
    and eventually it was capped to [2 seconds](https://gitlab.gnome.org/GNOME/vte/-/commit/12a54279).
    But the delay was there, and that was the problem.
  id: totrans-split-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是无限延迟，然后被限制为[5秒](https://gitlab.gnome.org/GNOME/vte/-/commit/058adf5f)，最终被限制为[2秒](https://gitlab.gnome.org/GNOME/vte/-/commit/12a54279)。但延迟依然存在，这才是问题的所在。
- en: The fix
  id: totrans-split-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方法
- en: If the user wants the terminal to exit immediately, then the `child-exited`
    signal needs to be sent immediately. It’s as simple as that.
  id: totrans-split-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户希望终端立即退出，则需要立即发送 `child-exited` 信号。就是这么简单。
- en: Stupidly obvious
  id: totrans-split-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 愚蠢而显而易见
- en: The complexity of the explanation of the issue above might have thrown some
    people off, so I want to make sure people understand the fix.
  id: totrans-split-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述问题的解释复杂性可能使一些人困惑，因此我想确保人们理解这个修复。
- en: The fix is to send the signal of the event, when the event happens. So the fix
    is to send the `child-exited` signal, when the child exits.
  id: totrans-split-50
  prefs: []
  type: TYPE_NORMAL
  zh: 修复就是在事件发生时发送事件的信号。所以修复就是在子进程退出时发送 `child-exited` 信号。
- en: I don’t know how the fix could be any simpler.
  id: totrans-split-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道修复能更简单些了。
- en: I don’t pay you to think
  id: totrans-split-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我不是为了让你思考而付钱。
- en: If you tell someone — like your assistant — “please monitor NVDA stock price
    and let me know when it’s bellow $850”. Then if you learn that the stock price
    is at $825 you would be understandably upset with this guy, but don’t worry, you
    assistant has an explanation.
  id: totrans-split-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你告诉某人 — 比如你的助手 — “请监控 NVDA 股票价格，当价格低于$850时通知我”。然后如果你得知股票价格是$825，你可能会对这个家伙感到不满，但别担心，你的助手有解释。
- en: He might calmly explain to you “I know your objective is to make money, so I
    surmised the best way to make money is to buy the stock when the price is $800,
    the price is only $825, so it’s not yet time to buy”.
  id: totrans-split-54
  prefs: []
  type: TYPE_NORMAL
  zh: 他可能会平静地对你解释：“我知道你的目标是赚钱，所以我推测赚钱的最佳方法是在股价为$800时买入，现在价格只有$825，所以还不是买入的时机”。
- en: But you didn’t tell him “notify me when you think it’s time to buy”, did you?
    You never delegated that decision to him.
  id: totrans-split-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但你没告诉他“当你认为是买入时通知我”，对吧？你从未授权他做出那个决定。
- en: 'This bug is very similar. The terminal is telling vte: “please notify me when
    the child exits”, and vte comes back and says “it’s still not time to close the
    terminal”. But that is **not** what the terminal asked.'
  id: totrans-split-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 bug 非常相似。终端告诉 vte：“请在子进程退出时通知我”，而 vte 回答说：“现在还不是关闭终端的时候”。但这不是终端所要求的。
- en: 'You see, it’s not just that GNOME developers think they know better than their
    users, it’s also that the developers of GNOME libraries think they know better
    than the users of those libraries: the developers of vte think they know better
    than the developers of xfce4-terminal (and countless others).'
  id: totrans-split-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，GNOME 开发人员不仅认为他们比用户更懂，而且 GNOME 库的开发人员认为他们比使用这些库的用户更懂：vte 的开发人员认为他们比 xfce4-terminal
    的开发人员（以及无数其他开发者）更懂。
- en: They claimed it was desirable to send the `child-exited` signal when they believed
    the terminal should be closed, instead of when the child had exited.
  id: totrans-split-58
  prefs: []
  type: TYPE_NORMAL
  zh: 他们声称，当他们认为终端应该关闭时发送 `child-exited` 信号是可取的，而不是在子进程退出时发送。
- en: Rogue library
  id: totrans-split-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无序库
- en: '[I did explain to them](https://gitlab.gnome.org/GNOME/vte/-/issues/204#note_1703057)
    that the `child-exited` signal should be sent when the child exits.'
  id: totrans-split-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[我已经向他们解释过](https://gitlab.gnome.org/GNOME/vte/-/issues/204#note_1703057)，`child-exited`
    信号应在子进程退出时发送。'
- en: One has to do pretty advanced mental gymnastics to argue that a `child-exited`
    signal is not useful to issue at the moment a child exits.
  id: totrans-split-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要做出如此先进的心理运动来辩称 `child-exited` 信号在子进程退出时不实用，确实需要不少努力。
- en: Felipe Contreras
  id: totrans-split-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 费利佩·康特雷拉斯
- en: '[They argued](https://gitlab.gnome.org/GNOME/vte/-/issues/204#note_1702760)
    that it was **they** the ones that should decide when the terminal can be closed:'
  id: totrans-split-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[他们辩称](https://gitlab.gnome.org/GNOME/vte/-/issues/204#note_1702760)，是他们应该决定何时关闭终端：'
- en: 'To summarize the experience we have gained so far, both in the original bug,
    and then to the less-than-ideal “fix” to that bug (which broke something else),
    the desired behavior is the combination of **all of these, at the same time**:'
  id: totrans-split-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总结到目前为止我们所获得的经验，既包括原始 bug，也包括对该 bug 的不太理想的“修复”（导致其他问题），期望的行为是**所有这些同时发生**：
- en: Process all output from the immediate child.
  id: totrans-split-65
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理来自直接子进程的所有输出。
- en: After that, quit (or restart, or whatever) ASAP.
  id: totrans-split-66
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后尽快退出（或重新启动，或其他）。
- en: No need to process all the output from grandchildren, their descendants, or
    other processes that somehow got access to the tty line.
  id: totrans-split-67
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无需处理所有来自孙子辈、他们的后代或其他以某种方式访问 tty 行的进程的输出。
- en: Egmont Koblinger
  id: totrans-split-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 埃格蒙特·科布林格
- en: 'Egmont clearly doesn’t understand how standard streams on forks work, because
    there’s no way to distinguish output from the child and output from the grandchildren.
    But even if this was somehow possible, it should be up to the terminal to decide
    when to exit: if the terminal wants to exit before all the output from the child
    has been processed, it should be able to do so.'
  id: totrans-split-69
  prefs: []
  type: TYPE_NORMAL
  zh: 显然Egmont不理解分支上标准流的工作方式，因为无法区分子进程的输出和孙子进程的输出。但即使可能，决定何时退出应由终端决定：如果终端希望在处理完子进程的所有输出之前退出，它应该能够这样做。
- en: Ultimately is I — the end user — the one that should decide, not the terminal,
    and certain not the terminal library. The job of the library is to help achieve
    what the end user wants, not make decisions for the end user.
  id: totrans-split-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我 — 最终用户 — 应该决定，而不是终端，当然也不是终端库。库的工作是帮助实现最终用户想要的结果，而不是为最终用户做决定。
- en: If the end user wants the terminal to close immediately and not display any
    output, vte should just shut up and do that.
  id: totrans-split-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最终用户希望终端立即关闭并且不显示任何输出，vte应该保持安静并做到这一点。
- en: In the end his solution did not achieve anything my solution didn’t either,
    as we’ll soon see.
  id: totrans-split-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，他的解决方案并没有比我的解决方案多做什么，我们很快就会看到。
- en: Proof
  id: totrans-split-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证明
- en: At this point you might be thinking that there’s no way GNOME developers could
    possibly be so oblivious about their own code that an outsider like me could pinpoint
    to such glaring mistakes.
  id: totrans-split-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会认为GNOME开发人员绝对不可能对他们自己的代码如此无视，以至于像我这样的外部人员能够指出如此明显的错误。
- en: Well, let’s see.
  id: totrans-split-75
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，让我们看看。
- en: 'This is the core of the problem before the latest fix was applied, in the `Terminal::child_watch_done`
    method:'
  id: totrans-split-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在应用最新修复之前的问题核心，在`Terminal::child_watch_done`方法中：
- en: '[PRE2]'
  id: totrans-split-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You don’t need to understand what all that is doing, all you need to know is
    that my fix changed that to:'
  id: totrans-split-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要理解那些在做什么，你只需要知道我的修复把它改成了：
- en: '[PRE3]'
  id: totrans-split-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What did their fix do?
  id: totrans-split-80
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的修复做了什么？
- en: '[PRE4]'
  id: totrans-split-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is more code, but at the end they call the `Widget::emit_child_exited`
    method, which is exactly the same thing I did.
  id: totrans-split-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多代码，但最后他们调用了`Widget::emit_child_exited`方法，这与我所做的完全一样。
- en: So now they are sending the `child-exited` signal, when the child exits. **Brilliant
    idea!**
  id: totrans-split-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在他们在子进程退出时发送`child-exited`信号。**绝妙的主意！**
- en: You may be thinking that perhaps the rationale as to why the signal can be sent
    at that moment comes from the extra code above, I’ll get into that. But the important
    thing is that after it’s done, the signal is sent. Period.
  id: totrans-split-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为也许信号可以在那个时刻发送的理由来自上面的额外代码，我会深入讨论这一点。但重要的是，完成后信号就发送了。就这样。
- en: The difference
  id: totrans-split-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区别
- en: Perhaps the chunk of code they added changes everything?
  id: totrans-split-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或许他们添加的代码块改变了一切？
- en: 'Here’s a video showing what happens with their fix:'
  id: totrans-split-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个展示他们修复情况的视频：
- en: 'And here’s the video showing what happens with my fix:'
  id: totrans-split-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个展示我的修复效果的视频：
- en: Can you spot the difference? I doubt that you can, because there is **no difference**.
  id: totrans-split-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现区别吗？我怀疑你能，因为**没有区别**。
- en: So [reading that 64 k of data](https://gitlab.gnome.org/GNOME/vte/-/blob/aeb663ae/src/vte.cc#L3699-3715)
    was not necessary, they could have simply applied my patch. Now, I could go into
    all the details to explain why there isn’t any difference, but it’s not necessary
    because this isn’t even the use case that matters. The relevant use case — as
    we’ll see below — is when the terminal is held open, so there’s even more time
    to receive the data.
  id: totrans-split-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以[阅读那64k数据](https://gitlab.gnome.org/GNOME/vte/-/blob/aeb663ae/src/vte.cc#L3699-3715)是不必要的，他们本可以简单应用我的补丁。现在，我可以详细解释为什么没有任何区别，但这并不必要，因为这甚至不是重要的用例。重要的用例
    — 如下所示 — 是终端保持开放状态，所以有更多时间接收数据。
- en: They delayed the fix for **absolutely no gain**.
  id: totrans-split-91
  prefs: []
  type: TYPE_NORMAL
  zh: 他们推迟了修复，**毫无收益**。
- en: Defence
  id: totrans-split-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辩护
- en: Maybe I’m being unfair and they probably had a good reason. Let’s explore their
    rationale.
  id: totrans-split-93
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我有些不公平，他们可能有充分的理由。让我们探索一下他们的理由。
- en: 'The developers created yet another issue ticket to discuss their “proper” fix
    ([Exit delay in presence of grandchildren processes](https://gitlab.gnome.org/GNOME/vte/-/issues/2627)).
    There Egmont spent 4102 words just to begin to justify his proposal. But in the
    end his proposal is simple:'
  id: totrans-split-94
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员创建了另一个问题票以讨论他们的“正确”修复方案（[在存在子孙进程的情况下退出延迟](https://gitlab.gnome.org/GNOME/vte/-/issues/2627)）。在那里，Egmont用了4102个字来开始为他的提议辩护。但最终他的提议很简单：
- en: Approaching from two different directions, the traffic-based safety cap seems
    to be by far the best bet for me. Plus, the synchronous approach looks safe enough
    and simpler than the mainloop-based one. Therefore this is what my patch does.
    When we notice that the child has quit, we synchronously read up to `EOF`, `EAGAIN`,
    any other error condition, or about 64k of data, whichever comes first, and process
    that data before emitting the ever so slightly deferred `child-exited` signal.
  id: totrans-split-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从两个不同的方向来看，基于流量的安全帽对我来说似乎是最好的选择。此外，同步方法看起来比基于主循环的方法更安全，也更简单。因此，这就是我的补丁所做的事情。当我们注意到子进程退出时，我们会同步读取直到`EOF`、`EAGAIN`或任何其他错误条件，或者是64k数据，以先到者为准，并在发出略微延迟的`child-exited`信号之前处理这些数据。
- en: Egmont Koblinger
  id: totrans-split-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Egmont Koblinger
- en: 'This explains the chunk of code we saw before: it’s trying to read 64 k of
    data synchronously before sending the `child-exited` signal, so now it’s only
    “ever so slightly deferred”.'
  id: totrans-split-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了我们之前看到的代码片段：它试图在发送`child-exited`信号之前同步读取64k数据，所以现在只是“稍微延迟”。
- en: I already proved that chunk makes no difference, but let’s assume that they
    are right and it did make a difference. Why would reading 64 k data be important?
  id: totrans-split-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经证明了那块代码没有任何影响，但让我们假设他们是正确的，它确实产生了影响。为什么读取64k数据很重要呢？
- en: The origin story
  id: totrans-split-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 起源故事
- en: The regression traces back to trying to fix issue [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)
    (End of cmd output discarded with “Hold the terminal open”). But the thing to
    keep in mind is that this is only relevant when you **hold** the terminal open.
  id: totrans-split-100
  prefs: []
  type: TYPE_NORMAL
  zh: 回归问题可以追溯到尝试修复问题[2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)（用“保持终端打开”丢弃cmd输出的结尾）。但要记住的是，只有当你**保持**终端打开时，这才相关。
- en: 'Say you launch a terminal in order to run a single command:'
  id: totrans-split-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你启动一个终端来运行单个命令：
- en: '[PRE5]'
  id: totrans-split-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Naturally you would like to see the output of that command. But if the terminal
    exits when the command finishes, then you won’t see anything. In order to see
    the output after the child has exited, you need to hold the terminal open:'
  id: totrans-split-103
  prefs: []
  type: TYPE_NORMAL
  zh: 自然而然，你想看到那个命令的输出。但是如果终端在命令完成后退出，那么你将什么也看不到。为了在子进程退出后看到输出，你需要保持终端打开：
- en: '[PRE6]'
  id: totrans-split-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The issue reported in [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)
    is that not all the output was displayed, if two things happened:'
  id: totrans-split-105
  prefs: []
  type: TYPE_NORMAL
  zh: 报告在[2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)中的问题是，如果发生了两件事，不会显示所有输出：
- en: The output is more than 8 k of data
  id: totrans-split-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出超过8k的数据
- en: The terminal is held open
  id: totrans-split-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端保持打开
- en: So it was very marginal issue which probably affected less than 1% of users
    (more like 0.01%).
  id: totrans-split-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这只是一个非常边缘的问题，可能只影响不到1%的用户（更像是0.01%）。
- en: Worse than the disease
  id: totrans-split-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比疾病更糟糕
- en: 'The “fix” that caused more problems than it solved ([lib: Rework child exit
    and EOF handling](https://gitlab.gnome.org/GNOME/vte/-/commit/7888602c)) did dozens
    of changes in a single commit, which made it virtually impossible to realize what
    fixed the problem. But after I spent an inordinate amount of time splitting the
    more than 600 lines of code changed into [25 logically atomic commits](https://github.com/GNOME/vte/compare/master...felipec:vte:eos-rewrite),
    it became clear what fixed the issue:'
  id: totrans-split-110
  prefs: []
  type: TYPE_NORMAL
  zh: '导致更多问题而不是解决问题的“修复”（[lib: 重写子进程退出和EOF处理](https://gitlab.gnome.org/GNOME/vte/-/commit/7888602c)）在单个提交中进行了几十次更改，这几乎不可能理解哪一项解决了问题。但在我花费大量时间将600多行代码拆分成[25个逻辑上原子的提交](https://github.com/GNOME/vte/compare/master...felipec:vte:eos-rewrite)之后，问题解决的原因就清楚了：'
- en: '[PRE7]'
  id: totrans-split-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It would take time to explain what a PTY is, but you don’t need to know that:
    all you need to know is that it’s the main channel of communication. So if the
    PTY is closed, the link between the terminal and the child process is severed.
    This means the streams are forcibly closed, and therefore any output coming from
    the child process after this point would be lost.'
  id: totrans-split-112
  prefs: []
  type: TYPE_NORMAL
  zh: 需要时间来解释PTY是什么，但你不需要知道那个：你只需要知道它是主要的通信渠道。因此，如果PTY关闭了，终端与子进程之间的链接就中断了。这意味着流被强制关闭，因此在此之后来自子进程的任何输出都将丢失。
- en: If the PTY is not closed, then the terminal is able to receive output from the
    child **after** the `child-exited` signal is raised.
  id: totrans-split-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果PTY没有关闭，那么终端能够在`child-exited`信号触发之后接收来自子进程的输出。
- en: Essentially the fix decouples the closing of the streams from the `child-exited`
    signal.
  id: totrans-split-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，修复措施将流的关闭与`child-exited`信号解耦。
- en: 'So what did the following 24 changes do? Nothing useful. In fact, the last
    2 changes rejoined the two signals. Before: the streams were being closed when
    `child-exited` was sent, and after: the `child-exited` signal was sent when the
    streams were closed.'
  id: totrans-split-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么接下来的 24 个更改做了什么？没有任何用处。事实上，最后两个更改重新连接了两个信号。之前：当发送 `child-exited` 时，流被关闭，之后：当流关闭时发送
    `child-exited` 信号。
- en: So one issue was replaced by another issue, except that the new issue was **much
    worse**.
  id: totrans-split-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个问题被另一个问题替代，只不过新问题**更糟**。
- en: The myth
  id: totrans-split-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 神话
- en: 'The misconception that vte developers were never able to overcome is that all
    that was needed to avoid the issue reported in [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)
    was to not close the PTY, and thus decoupling the two events: closing of the streams
    from the child exiting.'
  id: totrans-split-118
  prefs: []
  type: TYPE_NORMAL
  zh: vte 开发者从未能克服的误解是，避免[问题 2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)报告的唯一所需就是不关闭
    PTY，从而分离两个事件：流从子进程退出后关闭。
- en: Because they are unable to put themselves in the shoes of the terminal, they
    don’t understand that they sending the signal `child-exited` doesn’t automatically
    result in the terminal being closed. The terminal has autonomy, and it can decide
    to **ignore** the `child-exited` signal. I even wrote a simple vte client terminal
    precisely to test all the uses cases, and I used it to prove that when the terminal
    is held open, my fix works perfectly fine, which [I explained in the bug report](https://gitlab.gnome.org/GNOME/vte/-/issues/204#note_1703121).
    In the issue [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366) it’s explicitly
    stated that the problem is relevant only when the “hold the terminal open” option
    is selected.
  id: totrans-split-119
  prefs: []
  type: TYPE_NORMAL
  zh: 他们无法设身处地地理解终端的立场，不明白他们发送 `child-exited` 信号并不会自动导致终端关闭。终端是自主的，它可以决定**忽略** `child-exited`
    信号。我甚至写了一个简单的 vte 客户端终端来精确测试所有用例，并用它证明了当终端保持打开状态时，我的修复效果非常好，我在[问题报告中解释过](https://gitlab.gnome.org/GNOME/vte/-/issues/204#note_1703121)。在[问题
    2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)中明确指出，此问题只在选择了“保持终端打开”选项时才相关。
- en: When “hold the terminal open” is selected, `child-exited` does not terminate
    the terminal.
  id: totrans-split-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择了“保持终端打开”选项时，`child-exited` 不会终止终端。
- en: The terminal is able to keep displaying output from the child, even after `child-exited`
    was sent, as long as the file descriptors are not closed.
  id: totrans-split-121
  prefs: []
  type: TYPE_NORMAL
  zh: 终端可以在发送 `child-exited` 后继续显示来自子进程的输出，只要文件描述符未关闭。
- en: 'So they didn’t need to delay `child-exited`: all they needed to do is not close
    the PTY.'
  id: totrans-split-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，他们并不需要延迟 `child-exited`：他们所需做的只是不关闭 PTY。
- en: 'They never actually understood why the patch fixed the issue: they wrongly
    attributed it to delaying the signal.'
  id: totrans-split-123
  prefs: []
  type: TYPE_NORMAL
  zh: 他们从未真正理解修补程序为何解决了问题：他们错误地将其归因于延迟信号。
- en: The 64 k chunk
  id: totrans-split-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 64 k 数据块
- en: 'We come back to their fix:'
  id: totrans-split-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到他们的修补：
- en: '[PRE8]'
  id: totrans-split-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There’s always going to be a PTY, so you can ignore the `if (pty())` condition,
    then the logic consists of 3 steps:'
  id: totrans-split-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总会有一个 PTY，所以可以忽略 `if (pty())` 条件，那么逻辑就包括 3 步：
- en: Read a chunk of 64 k data
  id: totrans-split-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取 64 k 数据块
- en: Close the PTY
  id: totrans-split-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 PTY
- en: Emit `child-exited`
  id: totrans-split-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出 `child-exited`
- en: Any data that is going to be read has to be before closing the PTY. Normally
    sending `child-exited` is going to close the PTY (in fact terminate the entire
    program), but not when the “hold the terminal open” option is selected, which
    is what started it all. So data can be read **after** `child-exited` in this case.
  id: totrans-split-131
  prefs: []
  type: TYPE_NORMAL
  zh: 任何要读取的数据都必须在关闭 PTY 之前。通常情况下发送 `child-exited` 会关闭 PTY（实际上终止整个程序），但在选择了“保持终端打开”选项时不会如此。因此，在这种情况下，可以在**之后**读取数据。
- en: 'So we don’t need to do step 2 (which in fact has a comment saying it’s **optional**
    and “it makes a difference if the terminal is held open after the child exits”,
    and it is held open, therefore it makes a difference), and if we don’t do step
    2, then we don’t need to do step 1 either: because the data can be read after
    `child-exited` is emitted.'
  id: totrans-split-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不需要执行步骤 2（实际上有一条注释说这是**可选的**，“在子进程退出后保持终端打开确实有所不同”，并且终端确实保持打开状态，因此确实有所不同），如果不执行步骤
    2，则也不需要执行步骤 1：因为在发出 `child-exited` 后可以读取数据。
- en: If you skip step 2 and step 1 (which are unnecessary), then the code is **exactly
    the same** as my fix.
  id: totrans-split-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果跳过步骤 2 和步骤 1（这些步骤是不必要的），那么代码与我的修复**完全相同**。
- en: Verdict
  id: totrans-split-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: They have no defence. Their code makes **no difference**.
  id: totrans-split-135
  prefs: []
  type: TYPE_NORMAL
  zh: 他们无法自圆其说。他们的代码**没有任何区别**。
- en: The journey
  id: totrans-split-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旅程
- en: In November 2019 this is what the relevant code in `Terminal::child_watch_done`
    looked like before introducing the regression.
  id: totrans-split-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2019 年 11 月，`Terminal::child_watch_done` 中相关的代码在引入回归之前是这样的。
- en: '[PRE9]'
  id: totrans-split-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point the bug reported in [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)
    was present: displaying more than 8 k data right as the child exits didn’t work.'
  id: totrans-split-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，报告的 [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366) bug 仍然存在：当子进程退出时显示超过
    8k 数据并不起作用。
- en: 'However, the fix was simply to remove the `unset_pty()` line and don’t close
    the PTY. Instead, they chose to add several layers of complexity:'
  id: totrans-split-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，修复方法很简单，只需移除 `unset_pty()` 行而不关闭 PTY。相反，他们选择增加了几层复杂性：
- en: '[PRE10]'
  id: totrans-split-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So while trying to fix issue [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)
    which was very marginal — it happened only when the data exceeded 8 k and the
    terminal was configured to remain open and affected less than 0.1% of users —
    they introduced a regression that affected 100% of users.
  id: totrans-split-142
  prefs: []
  type: TYPE_NORMAL
  zh: 修复问题 [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366) 的过程中遇到了一个非常边缘的问题
    — 只有在数据超过 8k 且终端配置为保持打开状态，并且只影响不到 0.1% 的用户 — 他们引入了一个导致所有用户都受影响的回归。
- en: The thing to note is that m_child_exited_after_eos_pending is going to eventually
    trigger the `child-exited` signal by forcing an `end-of-stream` signal, but that
    could take up to 2 seconds.
  id: totrans-split-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`m_child_exited_after_eos_pending` 最终会通过强制 `end-of-stream` 信号触发 `child-exited`
    信号，但这可能需要长达 2 秒的时间。
- en: 'They argued for years that this was necessary in order for the use case described
    in issue [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366) to work. But
    that wasn’t true: they never understood that what fixed the issue was removing
    the `unset_pty()` call.'
  id: totrans-split-144
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，他们争辩称这是必要的，以便解决 [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)
    中描述的用例。但事实并非如此：他们从未意识到解决问题的关键是移除 `unset_pty()` 的调用。
- en: 'Finally in August 2023 — around 4 years later — they finally fix the regression
    with:'
  id: totrans-split-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最终在 2023 年 8 月 — 大约 4 年后 — 他们终于通过以下修复了回归：
- en: '[PRE11]'
  id: totrans-split-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But they reintroduce the `unset_pty()`, when the comment itself says “**optional**“.
    If you remove that the code above that reads 64 k of data unecessarily, we end
    up with:'
  id: totrans-split-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但是他们重新引入了 `unset_pty()`，尽管注释本身说是“**可选的**”。如果去掉这段代码中读取 64k 数据的无用操作，我们最终得到的是：
- en: '[PRE12]'
  id: totrans-split-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Which was **precisely** [my fix](https://github.com/felipec/vte/commit/8158d9c3#diff-5a3d8ae32aded628803bb443f43eac61814650c78132f6e128d2c7be4712538fR3220-R3221).
  id: totrans-split-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 [我的修复](https://github.com/felipec/vte/commit/8158d9c3#diff-5a3d8ae32aded628803bb443f43eac61814650c78132f6e128d2c7be4712538fR3220-R3221)。
- en: 'So let’s get this straight, we went from this code in 2019:'
  id: totrans-split-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们清楚地表达，我们从 2019 年的这段代码：
- en: '[PRE13]'
  id: totrans-split-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To this code in 2023:'
  id: totrans-split-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到 2023 年的这段代码：
- en: '[PRE14]'
  id: totrans-split-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Which does exactly the same as my fix that they rejected for **no good reason**.
  id: totrans-split-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它与我被无故拒绝的修复方案完全相同。
- en: All these years I argued that the two signals should be decoupled, and eventually
    they did decouple them. Forget about all the countless hours I spent analyzing
    the code, trying different approaches, and arguing with these obtuse people; what
    did we (the open source community) gain by this ordeal? **Absolutely nothing**.
    The code they eventually added and wasn’t present in my fix makes **no difference**
    whatsoever.
  id: totrans-split-155
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些年来，我一直认为这两个信号应该解耦，并最终他们确实解耦了。不要提及我花在分析代码、尝试不同方法并与这些愚钝人争论的无数小时；我们（开源社区）通过这场折磨得到了什么？**完全没有**。他们最终添加的代码与我的修复毫无**区别**。
- en: But wait…
  id: totrans-split-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但等等…
- en: When I said it makes no difference, that’s a lie, it’s actually **worse**.
  id: totrans-split-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说没有区别时，那是谎言，实际上情况更加**糟糕**。
- en: If you run the following command you would expect to see the “bye grandpa” output
    after 10 seconds.
  id: totrans-split-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行以下命令，你会期望在 10 秒后看到“bye grandpa”的输出。
- en: '[PRE15]'
  id: totrans-split-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: But it does not happen… because they decided to [close the PTY](https://gitlab.gnome.org/GNOME/vte/-/blob/aeb663ae/src/vte.cc#L3714).
  id: totrans-split-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并没有发生… 因为他们决定 [关闭 PTY](https://gitlab.gnome.org/GNOME/vte/-/blob/aeb663ae/src/vte.cc#L3714)。
- en: In my fix that command works fine.
  id: totrans-split-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的修复中，该命令可以正常工作。
- en: I’ve opened a new [issue ticket](https://gitlab.gnome.org/GNOME/vte/-/issues/2762)
    for that, and I’ve sent a [patch with the fix](https://gitlab.gnome.org/felipec/vte/-/commit/16500861)
    which is simply removing the unnecessary call to `unset_pty()`. If they apply
    my fix, then it becomes even more obvious that reading those 64 k is completely
    unnecessary. But I would not be holding my breath.
  id: totrans-split-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我为此新开了一个 [问题票](https://gitlab.gnome.org/GNOME/vte/-/issues/2762)，并且我已经发送了一个包含修复的
    [补丁](https://gitlab.gnome.org/felipec/vte/-/commit/16500861)，它只是移除了对 `unset_pty()`
    的不必要调用。如果他们采纳我的修复，那么读取那些 64k 的操作显然是完全不必要的。但我不指望他们会这么做。
- en: Lack of attention
  id: totrans-split-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺乏注意力。
- en: In the process of understanding this issue I reverted a lot of changes that
    I thought might be unnecessary, and while doing so I found that they indeed were
    unnecessary. I did so very carefully to make sure I wasn’t missing anything, and
    especially because all this code was new to me.
  id: totrans-split-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解这个问题的过程中，我还原了我认为可能不必要的很多更改，而在这样做的同时，我发现这些更改确实是不必要的。我非常小心地做到了不漏掉任何东西，尤其是因为这些代码对我来说都是新的。
- en: 'That’s how I realized vte developers were not careful at all: they often removed
    the calls to methods without removing the methods.'
  id: totrans-split-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我意识到 vte 开发者根本不仔细的方式：他们经常删除方法的调用却不删除方法本身。
- en: 'Take for example this chunk:'
  id: totrans-split-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个片段：
- en: '[PRE16]'
  id: totrans-split-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The call to `queue_child_exited()` is removed, but after that there isn’t any
    call to that method, so why aren’t they removing the method? Because they aren’t
    paying **attention** to their own code.
  id: totrans-split-168
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `queue_child_exited()` 被移除了，但在此之后没有任何对该方法的调用，那么为什么他们不删除这个方法呢？因为他们没有**注意**自己的代码。
- en: '`Terminal::queue_child_exited` queues a call to `emit_child_exited_idle_cb`
    (which probably could have been called directly anyway), and that calls `Terminal::emit_child_exited`
    (which probably didn’t need to be a separate function), and that finally calls:'
  id: totrans-split-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Terminal::queue_child_exited` 排队调用 `emit_child_exited_idle_cb`（可能本来可以直接调用），然后调用
    `Terminal::emit_child_exited`（可能本来不需要是一个单独的函数），最终调用：'
- en: '[PRE17]'
  id: totrans-split-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Which is now called right away, so obviously it’s not needed anymore.
  id: totrans-split-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在直接调用了这个，所以显然不再需要了。
- en: All these methods can be removed, and therefore `m_child_exit_status` can be
    removed as well.
  id: totrans-split-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都可以移除，因此 `m_child_exit_status` 也可以移除。
- en: The same happened in the [regression patch](https://gitlab.gnome.org/GNOME/vte/-/commit/7888602c),
    where they removed the definition of `Terminal::pty_channel_eof`, but not the
    declaration.
  id: totrans-split-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [回归补丁](https://gitlab.gnome.org/GNOME/vte/-/commit/7888602c) 中也发生了同样的事情，他们删除了
    `Terminal::pty_channel_eof` 的定义，但没有删除声明。
- en: My [version of the fix](https://github.com/felipec/vte/commit/8158d9c3) did
    correctly remove all the code that was not used any more. That’s why I say their
    version is poorer.
  id: totrans-split-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 [修复版本](https://github.com/felipec/vte/commit/8158d9c3) 正确地删除了所有不再使用的代码。这就是为什么我说他们的版本更差。
- en: I’ve [sent a patch](https://gitlab.gnome.org/GNOME/vte/-/issues/2761) to fix
    all their oversights, but I think we all can guess how that is likely going to
    go.
  id: totrans-split-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经 [发送了一个补丁](https://gitlab.gnome.org/GNOME/vte/-/issues/2761) 来修复所有这些疏忽，但我想我们都能猜到可能会发生什么。
- en: Really?
  id: totrans-split-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真的吗？
- en: 'After it was all said and done, Egmont found an [interesting comment](https://gitlab.gnome.org/GNOME/vte/-/issues/2627#note_1753270)
    in the luit command:'
  id: totrans-split-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在一切都说完做完之后，Egmont 在 luit 命令中找到了一个 [有趣的评论](https://gitlab.gnome.org/GNOME/vte/-/issues/2627#note_1753270)：
- en: -x Exit as soon as the child dies. This may cause luit to lose data at the end
    of the child’s output.
  id: totrans-split-178
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -x 当子进程结束时立即退出。这可能导致 luit 在子进程输出结束时丢失数据。
- en: luit(1)
  id: totrans-split-179
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: luit(1)
- en: …
  id: totrans-split-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …
- en: They suffer from the same dilemma, and delegate the decision to the user.
  id: totrans-split-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 他们遇到了同样的困境，并把决定权交给了用户。
- en: Egmont Koblinger
  id: totrans-split-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Egmont Koblinger
- en: No shirt Sherlock. The end user should decide how the software behaves? Who
    would have thought of that?
  id: totrans-split-183
  prefs: []
  type: TYPE_NORMAL
  zh: 没有衬衫，谢尔洛克。最终用户应该决定软件如何行为？谁会想到呢？
- en: But you are wrong, they are not “delegating” the decision to the end user, it
    was always the user’s decision in the first place.
  id: totrans-split-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但你错了，他们并没有把决定权“交给”最终用户，这从一开始就是用户的决定。
- en: First principle of software
  id: totrans-split-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件的第一原则
- en: I am convinced most developers do not even understand what software is, and
    it’s very clear that includes GNOME developers.
  id: totrans-split-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信大多数开发者甚至不了解软件是什么，很显然包括 GNOME 的开发者在内。
- en: 'The biggest thing any program can do is not the technical details of the program
    itself: it’s how useful the program is to users.'
  id: totrans-split-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何程序 - 如内核或任何其他项目 - 任何时候破坏用户体验，对我来说这都是软件项目可能做出的最糟糕的失败。绝对不允许破坏用户空间 - 或者其他项目 -
    永远不能破坏用户依赖的功能。
- en: So any time a program – like the kernel or any other project – breaks the user
    experience, to me that is the absolute worst failure that a software project can
    make. It’s the complete no-no to ever break userspace – or for other projects
    – to ever break features that your users depend on.
  id: totrans-split-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，每当程序（如内核或任何其他项目）破坏用户体验时，对我来说，这是软件项目可能出现的最严重的失败。绝对不允许破坏用户空间 - 或者对其他项目来说 -
    永远不能破坏用户依赖的功能。
- en: Because no project is more important than the users of the project.
  id: totrans-split-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为没有任何项目比项目的用户更重要。
- en: Linus Torvalds
  id: totrans-split-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linus Torvalds
- en: The whole point of software is to be **useful** to users. That’s it.
  id: totrans-split-191
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的整个意义在于对用户**有用**。就是这样。
- en: Your job Egmont — the developer, is to make things easier for me — the end user.
    Not harder.
  id: totrans-split-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工作 Egmont — 开发者，就是让我 — 最终用户，的事情变得更容易。而不是更难。
- en: It’s the end user that should decide how the software behaves. If you are purposely
    making the software **less useful** to the end users, you are **failing** as a
    software developer. Period.
  id: totrans-split-193
  prefs: []
  type: TYPE_NORMAL
  zh: 决定软件如何运行应该由最终用户决定。如果你故意使软件对最终用户**更不实用**，那你作为软件开发者是**失败**的。这是毋庸置疑的事实。
- en: Their sins
  id: totrans-split-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 他们的罪行
- en: 'Once you understand what software is, the list of catastrophic mistakes they
    did is obvious:'
  id: totrans-split-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了软件的本质，他们所犯的灾难性错误清楚无误：
- en: They didn’t revert the patch that introduced the **regression**. This is what
    projects that do understand the purpose of software do, I provided an example
    from the Linux project in my [other blog post](https://felipec.wordpress.com/2023/02/24/gnomes-horrid-coding-practices/).
  id: totrans-split-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们没有撤销引入**回归**的补丁。理解软件目的的项目会这样做，我在我的[另一篇博客文章](https://felipec.wordpress.com/2023/02/24/gnomes-horrid-coding-practices/)中提供了Linux项目的例子。
- en: They didn’t revert the behavior that caused the regression. Even if they didn’t
    want to revert the whole patch — which is understandable because it’s a big patch
    with 600 lines of code (an awful practice to begin with) — they could have changed
    one line of code to restore the previous behavior.
  id: totrans-split-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们没有撤销导致回归的行为。即使他们不想撤销整个补丁——因为这是一个有600行代码的大补丁（本来就是一个糟糕的做法）——他们也可以改变一行代码来恢复先前的行为。
- en: They didn’t consider ways to mitigate the regression. Even if they didn’t want
    to go back to a state where issue [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)
    was still present, they could have considered a middle ground, at least until
    a proper fix is found.
  id: totrans-split-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们没有考虑减轻回归的方法。即使他们不想回到问题[2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)仍然存在的状态，他们至少可以考虑一种折中办法，直到找到一个适当的修复方案。
- en: They didn’t allow the frustration of the end users to be heard. Even if they
    considered their solution to be correct, locking the issue and threatening people
    who criticized this approach with permanent bans is not what a project that cares
    about being useful to its users should do.
  id: totrans-split-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们并没有允许终端用户的挫败感被听到。即使他们认为他们的解决方案是正确的，锁定问题并威胁那些批评这种方法的人永久封禁，并不是一个关心对用户有用性的项目应该做的事情。
- en: They didn’t analyze any of the proposed fixes from outsiders. Even if preserving
    the fix for [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366) was paramount,
    they could have analyzed the fixes that claimed to not break [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366),
    as my fix did, but they didn’t.
  id: totrans-split-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们没有分析外部提出的任何修复方案。即使保留问题[2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)的解决方案至关重要，他们也可以分析那些声称不会破坏问题[2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)的修复方案，就像我的修复方案一样，但他们没有这样做。
- en: 'Even if you give them the benefit of the doubt and consider that the code they
    finally introduced in 2023: [read 64 k of data](https://gitlab.gnome.org/GNOME/vte/-/blob/aeb663ae/src/vte.cc#L3699-3715)
    was somehow necessary (even though it doesn’t make any difference), they shouldn’t
    have enabled the new behavior until they had that “proper” code.'
  id: totrans-split-201
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你给他们以怀疑的余地，并认为他们在2023年最终引入的代码——[读取64K数据](https://gitlab.gnome.org/GNOME/vte/-/blob/aeb663ae/src/vte.cc#L3699-3715)——在某种程度上是必要的（尽管这并没有任何区别），他们在拥有那个“正确”的代码之前不应该启用新行为。
- en: If that meant that issue [2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)
    would not have been properly fixed until 2023, then so be it.
  id: totrans-split-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这意味着直到2023年才能正确修复问题[2366](https://gitlab.gnome.org/GNOME/vte/-/issues/2366)，那就这样吧。
- en: It is better to make 0.01% of users suffer for 4 more years, than introduce
    a regression and make 100% of users suffer for 4 years. Who could argue otherwise?
  id: totrans-split-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让0.01%的用户在未来4年中受苦比引入回归并让100%的用户在未来4年中受苦更好。有谁会反驳这一点呢？
- en: But that’s not even the case, because my fix made everything work correctly,
    and it was available years ago.
  id: totrans-split-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但这甚至不是事实，因为我的修复方案早在多年前就使一切正常运行了。
- en: Conclusion
  id: totrans-split-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: These people made their users suffer unnecessarily for 4 years, for **no reason**.
  id: totrans-split-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些人毫无理由地让他们的用户遭受了4年的痛苦。
- en: When I say they are “stupid”, it’s not out of spite, it’s an objective fact.
    Who argues that the `child-exited` signal should not be sent when the child exits,
    only to eventually write a patch that does precisely that?
  id: totrans-split-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说他们是“愚蠢”的时候，这并不是出于恶意，而是客观事实。谁会争辩说`child-exited`信号在子进程退出时不应该发送，最终却写了一个确实这样做的补丁呢？
- en: And when I say they are “arrogant” it’s not because they rejected my solution,
    it’s because they couldn’t even entertain the possibility that some outsider could
    be more correct than them, and that’s why they didn’t even look at my patch.
  id: totrans-split-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说他们“傲慢”时，并不是因为他们拒绝了我的解决方案，而是因为他们甚至无法考虑到一些外部人可能比他们更正确，这就是为什么他们甚至没有看我的补丁。
- en: This is just one issue that we can leave behind in the past, but the real problem
    is their bad development practices and their shitty attitude. That is not constrained
    to the vte project, but the whole of GNOME and I have similar horror stories in
    other components to prove it.
  id: totrans-split-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个我们可以把它抛在过去的问题，但真正的问题是他们糟糕的开发实践和他们的糟糕态度。这不仅限于 vte 项目，而是 GNOME 整体，我有其他组件的类似恐怖故事来证明这一点。
- en: This isn’t about me, or my fix, this is about documenting the way GNOME developers
    operate in the details, and I think any objective observer would reach the conclusion
    that it’s simply not great.
  id: totrans-split-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是关于我或我的修复，而是关于详细记录 GNOME 开发者的操作方式，我认为任何客观的观察者都会得出这样一个结论：这根本不妙。
- en: Postscript
  id: totrans-split-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附言
- en: 'Because this isn’t my first rodeo, I can already foresee the criticism of this
    article: people are going to focus on my persona and my tone, not on what matters:
    **GNOME**‘s shitty practices.'
  id: totrans-split-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这不是我第一次经历，我已经能预见到本文的批评：人们会关注我的个人形象和语气，而不是真正重要的事情：**GNOME** 的糟糕实践。
- en: 'Let’s make one thing clear: even if Satan was the one providing a patch, if
    the patch is valid and fixes a real issue, you apply the patch, period. Why? Because
    that’s what is best for the users.'
  id: totrans-split-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一件事：即使是撒旦提供了一个补丁，只要这个补丁有效并修复了真实的问题，你都应该应用这个补丁，没有其他选择。为什么呢？因为这是对用户最好的选择。
- en: 'I did nothing but try to fix their awful code. The issue is not me. I don’t
    even care what they do, I already moved on to a non-vte terminal: kitty (which
    does have an option to exit immediately: [close_on_child_death](https://sw.kovidgoyal.net/kitty/conf/#opt-kitty.close_on_child_death)).'
  id: totrans-split-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我做的只是尝试修复他们糟糕的代码。问题不在于我。我甚至不关心他们会做什么，我已经转向了一个非 vte 终端：kitty（这个终端有一个选项可以立即退出：[close_on_child_death](https://sw.kovidgoyal.net/kitty/conf/#opt-kitty.close_on_child_death)）。
- en: People should ignore me and focus on how the GNOME project is going to handle
    similar situations in the future, even though I know many are going to do precisely
    the opposite.
  id: totrans-split-215
  prefs: []
  type: TYPE_NORMAL
  zh: 人们应该忽略我，专注于 GNOME 项目未来如何处理类似情况，尽管我知道许多人会做完全相反的事情。
- en: Bonus
  id: totrans-split-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附赠内容
- en: Some people don’t believe that my fix is valid, so I created a video showing
    step by step how it does work perfectly fine, contrary to what Egmont claimed.
  id: totrans-split-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人不相信我的修复有效，所以我制作了一个视频，逐步展示它是如何完美地运作的，与Egmont声称的相反。
